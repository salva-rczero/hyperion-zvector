; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	map_valid_m3_values_FPX
PUBLIC	map_valid_m3_values_NOFPX
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
float64_default_qnan DQ 7ff8000000000000H
float32_default_qnan DD 07fc00000H
	ORG $+4
map_m3_to_sf_rm DB 00H
	DB	04H
	DB	00H
	DB	05H
	DB	00H
	DB	01H
	DB	03H
	DB	02H
map_fpc_brm_to_sf_rm DB 00H
	DB	01H
	DB	03H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	05H
map_valid_m3_values_FPX DB 01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
map_valid_m3_values_NOFPX DB 01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
CONST	ENDS
PUBLIC	s370_convert_u32_to_bfp_ext_reg
PUBLIC	s370_convert_u32_to_bfp_long_reg
PUBLIC	s370_convert_u32_to_bfp_short_reg
PUBLIC	s370_convert_u64_to_bfp_ext_reg
PUBLIC	s370_convert_u64_to_bfp_long_reg
PUBLIC	s370_convert_u64_to_bfp_short_reg
PUBLIC	s370_convert_bfp_ext_to_u32_reg
PUBLIC	s370_convert_bfp_long_to_u32_reg
PUBLIC	s370_convert_bfp_short_to_u32_reg
PUBLIC	s370_convert_bfp_ext_to_u64_reg
PUBLIC	s370_convert_bfp_long_to_u64_reg
PUBLIC	s370_convert_bfp_short_to_u64_reg
PUBLIC	s370_add_bfp_ext_reg
PUBLIC	s370_add_bfp_long
PUBLIC	s370_add_bfp_long_reg
PUBLIC	s370_add_bfp_short
PUBLIC	s370_add_bfp_short_reg
PUBLIC	s370_compare_and_signal_bfp_ext_reg
PUBLIC	s370_compare_and_signal_bfp_long
PUBLIC	s370_compare_and_signal_bfp_long_reg
PUBLIC	s370_compare_and_signal_bfp_short
PUBLIC	s370_compare_and_signal_bfp_short_reg
PUBLIC	s370_compare_bfp_ext_reg
PUBLIC	s370_compare_bfp_long
PUBLIC	s370_compare_bfp_long_reg
PUBLIC	s370_compare_bfp_short
PUBLIC	s370_compare_bfp_short_reg
PUBLIC	s370_convert_bfp_ext_to_fix32_reg
PUBLIC	s370_convert_bfp_long_to_fix32_reg
PUBLIC	s370_convert_bfp_short_to_fix32_reg
PUBLIC	s370_convert_fix32_to_bfp_ext_reg
PUBLIC	s370_convert_fix32_to_bfp_long_reg
PUBLIC	s370_convert_fix32_to_bfp_short_reg
PUBLIC	s370_divide_bfp_ext_reg
PUBLIC	s370_divide_bfp_long
PUBLIC	s370_divide_bfp_long_reg
PUBLIC	s370_divide_bfp_short
PUBLIC	s370_divide_bfp_short_reg
PUBLIC	s370_divide_integer_bfp_long_reg
PUBLIC	s370_divide_integer_bfp_short_reg
PUBLIC	s370_load_and_test_bfp_ext_reg
PUBLIC	s370_load_and_test_bfp_long_reg
PUBLIC	s370_load_and_test_bfp_short_reg
PUBLIC	s370_load_complement_bfp_ext_reg
PUBLIC	s370_load_complement_bfp_long_reg
PUBLIC	s370_load_complement_bfp_short_reg
PUBLIC	s370_load_fp_int_bfp_ext_reg
PUBLIC	s370_load_fp_int_bfp_long_reg
PUBLIC	s370_load_fp_int_bfp_short_reg
PUBLIC	s370_load_lengthened_bfp_long_to_ext
PUBLIC	s370_load_lengthened_bfp_long_to_ext_reg
PUBLIC	s370_load_lengthened_bfp_short_to_ext
PUBLIC	s370_load_lengthened_bfp_short_to_ext_reg
PUBLIC	s370_load_lengthened_bfp_short_to_long
PUBLIC	s370_load_lengthened_bfp_short_to_long_reg
PUBLIC	s370_load_negative_bfp_ext_reg
PUBLIC	s370_load_negative_bfp_long_reg
PUBLIC	s370_load_negative_bfp_short_reg
PUBLIC	s370_load_positive_bfp_ext_reg
PUBLIC	s370_load_positive_bfp_long_reg
PUBLIC	s370_load_positive_bfp_short_reg
PUBLIC	s370_load_rounded_bfp_ext_to_long_reg
PUBLIC	s370_load_rounded_bfp_ext_to_short_reg
PUBLIC	s370_load_rounded_bfp_long_to_short_reg
PUBLIC	s370_multiply_add_bfp_long
PUBLIC	s370_multiply_add_bfp_long_reg
PUBLIC	s370_multiply_add_bfp_short
PUBLIC	s370_multiply_add_bfp_short_reg
PUBLIC	s370_multiply_bfp_ext_reg
PUBLIC	s370_multiply_bfp_long
PUBLIC	s370_multiply_bfp_long_reg
PUBLIC	s370_multiply_bfp_long_to_ext
PUBLIC	s370_multiply_bfp_long_to_ext_reg
PUBLIC	s370_multiply_bfp_short
PUBLIC	s370_multiply_bfp_short_reg
PUBLIC	s370_multiply_bfp_short_to_long
PUBLIC	s370_multiply_bfp_short_to_long_reg
PUBLIC	s370_multiply_subtract_bfp_long
PUBLIC	s370_multiply_subtract_bfp_long_reg
PUBLIC	s370_multiply_subtract_bfp_short
PUBLIC	s370_multiply_subtract_bfp_short_reg
PUBLIC	s370_squareroot_bfp_ext_reg
PUBLIC	s370_squareroot_bfp_long
PUBLIC	s370_squareroot_bfp_long_reg
PUBLIC	s370_squareroot_bfp_short
PUBLIC	s370_squareroot_bfp_short_reg
PUBLIC	s370_subtract_bfp_ext_reg
PUBLIC	s370_subtract_bfp_long
PUBLIC	s370_subtract_bfp_long_reg
PUBLIC	s370_subtract_bfp_short
PUBLIC	s370_subtract_bfp_short_reg
PUBLIC	s370_test_data_class_bfp_ext
PUBLIC	s370_test_data_class_bfp_long
PUBLIC	s370_test_data_class_bfp_short
PUBLIC	fetch_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	s370_maddr_l
PUBLIC	s370_vfetch4_full
PUBLIC	s370_vfetch8_full
PUBLIC	s370_vfetch4
PUBLIC	s370_vfetch8
PUBLIC	s390_add_bfp_ext_reg
PUBLIC	s390_add_bfp_long
PUBLIC	s390_add_bfp_long_reg
PUBLIC	s390_add_bfp_short
PUBLIC	s390_add_bfp_short_reg
PUBLIC	s390_compare_and_signal_bfp_ext_reg
PUBLIC	s390_compare_and_signal_bfp_long
PUBLIC	s390_compare_and_signal_bfp_long_reg
PUBLIC	s390_compare_and_signal_bfp_short
PUBLIC	s390_compare_and_signal_bfp_short_reg
PUBLIC	s390_compare_bfp_ext_reg
PUBLIC	s390_compare_bfp_long
PUBLIC	s390_compare_bfp_long_reg
PUBLIC	s390_compare_bfp_short
PUBLIC	s390_compare_bfp_short_reg
PUBLIC	s390_convert_bfp_ext_to_fix32_reg
PUBLIC	s390_convert_bfp_long_to_fix32_reg
PUBLIC	s390_convert_bfp_short_to_fix32_reg
PUBLIC	s390_convert_fix32_to_bfp_ext_reg
PUBLIC	s390_convert_fix32_to_bfp_long_reg
PUBLIC	s390_convert_fix32_to_bfp_short_reg
PUBLIC	s390_divide_bfp_ext_reg
PUBLIC	s390_divide_bfp_long
PUBLIC	s390_divide_bfp_long_reg
PUBLIC	s390_divide_bfp_short
PUBLIC	s390_divide_bfp_short_reg
PUBLIC	s390_divide_integer_bfp_long_reg
PUBLIC	s390_divide_integer_bfp_short_reg
PUBLIC	s390_load_and_test_bfp_ext_reg
PUBLIC	s390_load_and_test_bfp_long_reg
PUBLIC	s390_load_and_test_bfp_short_reg
PUBLIC	s390_load_complement_bfp_ext_reg
PUBLIC	s390_load_complement_bfp_long_reg
PUBLIC	s390_load_complement_bfp_short_reg
PUBLIC	s390_load_fp_int_bfp_ext_reg
PUBLIC	s390_load_fp_int_bfp_long_reg
PUBLIC	s390_load_fp_int_bfp_short_reg
PUBLIC	s390_load_lengthened_bfp_long_to_ext
PUBLIC	s390_load_lengthened_bfp_long_to_ext_reg
PUBLIC	s390_load_lengthened_bfp_short_to_ext
PUBLIC	s390_load_lengthened_bfp_short_to_ext_reg
PUBLIC	s390_load_lengthened_bfp_short_to_long
PUBLIC	s390_load_lengthened_bfp_short_to_long_reg
PUBLIC	s390_load_negative_bfp_ext_reg
PUBLIC	s390_load_negative_bfp_long_reg
PUBLIC	s390_load_negative_bfp_short_reg
PUBLIC	s390_load_positive_bfp_ext_reg
PUBLIC	s390_load_positive_bfp_long_reg
PUBLIC	s390_load_positive_bfp_short_reg
PUBLIC	s390_load_rounded_bfp_ext_to_long_reg
PUBLIC	s390_load_rounded_bfp_ext_to_short_reg
PUBLIC	s390_load_rounded_bfp_long_to_short_reg
PUBLIC	s390_multiply_add_bfp_long
PUBLIC	s390_multiply_add_bfp_long_reg
PUBLIC	s390_multiply_add_bfp_short
PUBLIC	s390_multiply_add_bfp_short_reg
PUBLIC	s390_multiply_bfp_ext_reg
PUBLIC	s390_multiply_bfp_long
PUBLIC	s390_multiply_bfp_long_reg
PUBLIC	s390_multiply_bfp_long_to_ext
PUBLIC	s390_multiply_bfp_long_to_ext_reg
PUBLIC	s390_multiply_bfp_short
PUBLIC	s390_multiply_bfp_short_reg
PUBLIC	s390_multiply_bfp_short_to_long
PUBLIC	s390_multiply_bfp_short_to_long_reg
PUBLIC	s390_multiply_subtract_bfp_long
PUBLIC	s390_multiply_subtract_bfp_long_reg
PUBLIC	s390_multiply_subtract_bfp_short
PUBLIC	s390_multiply_subtract_bfp_short_reg
PUBLIC	s390_squareroot_bfp_ext_reg
PUBLIC	s390_squareroot_bfp_long
PUBLIC	s390_squareroot_bfp_long_reg
PUBLIC	s390_squareroot_bfp_short
PUBLIC	s390_squareroot_bfp_short_reg
PUBLIC	s390_subtract_bfp_ext_reg
PUBLIC	s390_subtract_bfp_long
PUBLIC	s390_subtract_bfp_long_reg
PUBLIC	s390_subtract_bfp_short
PUBLIC	s390_subtract_bfp_short_reg
PUBLIC	s390_test_data_class_bfp_ext
PUBLIC	s390_test_data_class_bfp_long
PUBLIC	s390_test_data_class_bfp_short
PUBLIC	s390_convert_bfp_long_to_float_long_reg
PUBLIC	s390_convert_bfp_short_to_float_long_reg
PUBLIC	s390_convert_float_long_to_bfp_long_reg
PUBLIC	s390_convert_float_long_to_bfp_short_reg
PUBLIC	s390_maddr_l
PUBLIC	s390_vfetch4_full
PUBLIC	s390_vfetch8_full
PUBLIC	s390_vfetch4
PUBLIC	s390_vfetch8
PUBLIC	z900_convert_u32_to_bfp_ext_reg
PUBLIC	z900_convert_u32_to_bfp_long_reg
PUBLIC	z900_convert_u32_to_bfp_short_reg
PUBLIC	z900_convert_u64_to_bfp_ext_reg
PUBLIC	z900_convert_u64_to_bfp_long_reg
PUBLIC	z900_convert_u64_to_bfp_short_reg
PUBLIC	z900_convert_bfp_ext_to_u32_reg
PUBLIC	z900_convert_bfp_long_to_u32_reg
PUBLIC	z900_convert_bfp_short_to_u32_reg
PUBLIC	z900_convert_bfp_ext_to_u64_reg
PUBLIC	z900_convert_bfp_long_to_u64_reg
PUBLIC	z900_convert_bfp_short_to_u64_reg
PUBLIC	z900_add_bfp_ext_reg
PUBLIC	z900_add_bfp_long
PUBLIC	z900_add_bfp_long_reg
PUBLIC	z900_add_bfp_short
PUBLIC	z900_add_bfp_short_reg
PUBLIC	z900_compare_and_signal_bfp_ext_reg
PUBLIC	z900_compare_and_signal_bfp_long
PUBLIC	z900_compare_and_signal_bfp_long_reg
PUBLIC	z900_compare_and_signal_bfp_short
PUBLIC	z900_compare_and_signal_bfp_short_reg
PUBLIC	z900_compare_bfp_ext_reg
PUBLIC	z900_compare_bfp_long
PUBLIC	z900_compare_bfp_long_reg
PUBLIC	z900_compare_bfp_short
PUBLIC	z900_compare_bfp_short_reg
PUBLIC	z900_convert_bfp_ext_to_fix32_reg
PUBLIC	z900_convert_bfp_ext_to_fix64_reg
PUBLIC	z900_convert_bfp_long_to_fix32_reg
PUBLIC	z900_convert_bfp_long_to_fix64_reg
PUBLIC	z900_convert_bfp_short_to_fix32_reg
PUBLIC	z900_convert_bfp_short_to_fix64_reg
PUBLIC	z900_convert_fix32_to_bfp_ext_reg
PUBLIC	z900_convert_fix32_to_bfp_long_reg
PUBLIC	z900_convert_fix32_to_bfp_short_reg
PUBLIC	z900_convert_fix64_to_bfp_ext_reg
PUBLIC	z900_convert_fix64_to_bfp_long_reg
PUBLIC	z900_convert_fix64_to_bfp_short_reg
PUBLIC	z900_divide_bfp_ext_reg
PUBLIC	z900_divide_bfp_long
PUBLIC	z900_divide_bfp_long_reg
PUBLIC	z900_divide_bfp_short
PUBLIC	z900_divide_bfp_short_reg
PUBLIC	z900_divide_integer_bfp_long_reg
PUBLIC	z900_divide_integer_bfp_short_reg
PUBLIC	z900_load_and_test_bfp_ext_reg
PUBLIC	z900_load_and_test_bfp_long_reg
PUBLIC	z900_load_and_test_bfp_short_reg
PUBLIC	z900_load_complement_bfp_ext_reg
PUBLIC	z900_load_complement_bfp_long_reg
PUBLIC	z900_load_complement_bfp_short_reg
PUBLIC	z900_load_fp_int_bfp_ext_reg
PUBLIC	z900_load_fp_int_bfp_long_reg
PUBLIC	z900_load_fp_int_bfp_short_reg
PUBLIC	z900_load_lengthened_bfp_long_to_ext
PUBLIC	z900_load_lengthened_bfp_long_to_ext_reg
PUBLIC	z900_load_lengthened_bfp_short_to_ext
PUBLIC	z900_load_lengthened_bfp_short_to_ext_reg
PUBLIC	z900_load_lengthened_bfp_short_to_long
PUBLIC	z900_load_lengthened_bfp_short_to_long_reg
PUBLIC	z900_load_negative_bfp_ext_reg
PUBLIC	z900_load_negative_bfp_long_reg
PUBLIC	z900_load_negative_bfp_short_reg
PUBLIC	z900_load_positive_bfp_ext_reg
PUBLIC	z900_load_positive_bfp_long_reg
PUBLIC	z900_load_positive_bfp_short_reg
PUBLIC	z900_load_rounded_bfp_ext_to_long_reg
PUBLIC	z900_load_rounded_bfp_ext_to_short_reg
PUBLIC	z900_load_rounded_bfp_long_to_short_reg
PUBLIC	z900_multiply_add_bfp_long
PUBLIC	z900_multiply_add_bfp_long_reg
PUBLIC	z900_multiply_add_bfp_short
PUBLIC	z900_multiply_add_bfp_short_reg
PUBLIC	z900_multiply_bfp_ext_reg
PUBLIC	z900_multiply_bfp_long
PUBLIC	z900_multiply_bfp_long_reg
PUBLIC	z900_multiply_bfp_long_to_ext
PUBLIC	z900_multiply_bfp_long_to_ext_reg
PUBLIC	z900_multiply_bfp_short
PUBLIC	z900_multiply_bfp_short_reg
PUBLIC	z900_multiply_bfp_short_to_long
PUBLIC	z900_multiply_bfp_short_to_long_reg
PUBLIC	z900_multiply_subtract_bfp_long
PUBLIC	z900_multiply_subtract_bfp_long_reg
PUBLIC	z900_multiply_subtract_bfp_short
PUBLIC	z900_multiply_subtract_bfp_short_reg
PUBLIC	z900_squareroot_bfp_ext_reg
PUBLIC	z900_squareroot_bfp_long
PUBLIC	z900_squareroot_bfp_long_reg
PUBLIC	z900_squareroot_bfp_short
PUBLIC	z900_squareroot_bfp_short_reg
PUBLIC	z900_subtract_bfp_ext_reg
PUBLIC	z900_subtract_bfp_long
PUBLIC	z900_subtract_bfp_long_reg
PUBLIC	z900_subtract_bfp_short
PUBLIC	z900_subtract_bfp_short_reg
PUBLIC	z900_test_data_class_bfp_ext
PUBLIC	z900_test_data_class_bfp_long
PUBLIC	z900_test_data_class_bfp_short
PUBLIC	z900_convert_bfp_long_to_float_long_reg
PUBLIC	z900_convert_bfp_short_to_float_long_reg
PUBLIC	z900_convert_float_long_to_bfp_long_reg
PUBLIC	z900_convert_float_long_to_bfp_short_reg
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck2
PUBLIC	z900_maddr_l
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vfetch8_full
PUBLIC	z900_vfetch4
PUBLIC	z900_vfetch8
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	f32_scaledResult:PROC
EXTRN	f64_scaledResult:PROC
EXTRN	f128_scaledResult:PROC
EXTRN	ui32_to_f32:PROC
EXTRN	ui32_to_f64:PROC
EXTRN	ui32_to_f128:PROC
EXTRN	ui64_to_f32:PROC
EXTRN	ui64_to_f64:PROC
EXTRN	ui64_to_f128:PROC
EXTRN	i32_to_f32:PROC
EXTRN	i32_to_f64:PROC
EXTRN	i32_to_f128:PROC
EXTRN	i64_to_f32:PROC
EXTRN	i64_to_f64:PROC
EXTRN	i64_to_f128:PROC
EXTRN	f32_to_ui32:PROC
EXTRN	f32_to_ui64:PROC
EXTRN	f32_to_i32:PROC
EXTRN	f32_to_i64:PROC
EXTRN	f32_to_f64:PROC
EXTRN	f32_to_f128:PROC
EXTRN	f32_roundToInt:PROC
EXTRN	f32_add:PROC
EXTRN	f32_sub:PROC
EXTRN	f32_mul:PROC
EXTRN	f32_mulAdd:PROC
EXTRN	f32_div:PROC
EXTRN	f32_sqrt:PROC
EXTRN	f32_eq:PROC
EXTRN	f32_lt_quiet:PROC
EXTRN	f32_isSignalingNaN:PROC
EXTRN	f64_to_ui32:PROC
EXTRN	f64_to_ui64:PROC
EXTRN	f64_to_i32:PROC
EXTRN	f64_to_i64:PROC
EXTRN	f64_to_f32:PROC
EXTRN	f64_to_f128:PROC
EXTRN	f64_roundToInt:PROC
EXTRN	f64_add:PROC
EXTRN	f64_sub:PROC
EXTRN	f64_mul:PROC
EXTRN	f64_mulAdd:PROC
EXTRN	f64_div:PROC
EXTRN	f64_sqrt:PROC
EXTRN	f64_eq:PROC
EXTRN	f64_lt_quiet:PROC
EXTRN	f64_isSignalingNaN:PROC
EXTRN	f128_to_ui32:PROC
EXTRN	f128_to_ui64:PROC
EXTRN	f128_to_i32:PROC
EXTRN	f128_to_i64:PROC
EXTRN	f128_to_f32:PROC
EXTRN	f128_to_f64:PROC
EXTRN	f128_roundToInt:PROC
EXTRN	f128_add:PROC
EXTRN	f128_sub:PROC
EXTRN	f128_mul:PROC
EXTRN	f128_mulAdd:PROC
EXTRN	f128_div:PROC
EXTRN	f128_sqrt:PROC
EXTRN	f128_eq:PROC
EXTRN	f128_lt_quiet:PROC
EXTRN	f128_isSignalingNaN:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	softfloat_roundingMode:BYTE
EXTRN	softfloat_exceptionFlags:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_tls_index:DWORD
pdata	SEGMENT
$pdata$s370_convert_u32_to_bfp_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+589
	DD	imagerel $unwind$s370_convert_u32_to_bfp_ext_reg
$pdata$s370_convert_u32_to_bfp_long_reg DD imagerel $LN11
	DD	imagerel $LN11+459
	DD	imagerel $unwind$s370_convert_u32_to_bfp_long_reg
$pdata$s370_convert_u32_to_bfp_short_reg DD imagerel $LN13
	DD	imagerel $LN13+567
	DD	imagerel $unwind$s370_convert_u32_to_bfp_short_reg
$pdata$s370_convert_u64_to_bfp_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+592
	DD	imagerel $unwind$s370_convert_u64_to_bfp_ext_reg
$pdata$s370_convert_u64_to_bfp_long_reg DD imagerel $LN13
	DD	imagerel $LN13+571
	DD	imagerel $unwind$s370_convert_u64_to_bfp_long_reg
$pdata$s370_convert_u64_to_bfp_short_reg DD imagerel $LN13
	DD	imagerel $LN13+570
	DD	imagerel $unwind$s370_convert_u64_to_bfp_short_reg
$pdata$s370_convert_bfp_ext_to_u32_reg DD imagerel $LN31
	DD	imagerel $LN31+1399
	DD	imagerel $unwind$s370_convert_bfp_ext_to_u32_reg
$pdata$s370_convert_bfp_long_to_u32_reg DD imagerel $LN28
	DD	imagerel $LN28+1143
	DD	imagerel $unwind$s370_convert_bfp_long_to_u32_reg
$pdata$s370_convert_bfp_short_to_u32_reg DD imagerel $LN28
	DD	imagerel $LN28+1049
	DD	imagerel $unwind$s370_convert_bfp_short_to_u32_reg
$pdata$s370_convert_bfp_ext_to_u64_reg DD imagerel $LN31
	DD	imagerel $LN31+1407
	DD	imagerel $unwind$s370_convert_bfp_ext_to_u64_reg
$pdata$s370_convert_bfp_long_to_u64_reg DD imagerel $LN28
	DD	imagerel $LN28+1147
	DD	imagerel $unwind$s370_convert_bfp_long_to_u64_reg
$pdata$s370_convert_bfp_short_to_u64_reg DD imagerel $LN28
	DD	imagerel $LN28+1053
	DD	imagerel $unwind$s370_convert_bfp_short_to_u64_reg
$pdata$s370_add_bfp_ext_reg DD imagerel $LN32
	DD	imagerel $LN32+1221
	DD	imagerel $unwind$s370_add_bfp_ext_reg
$pdata$s370_add_bfp_long DD imagerel $LN28
	DD	imagerel $LN28+1049
	DD	imagerel $unwind$s370_add_bfp_long
$pdata$s370_add_bfp_long_reg DD imagerel $LN29
	DD	imagerel $LN29+889
	DD	imagerel $unwind$s370_add_bfp_long_reg
$pdata$s370_add_bfp_short DD imagerel $LN28
	DD	imagerel $LN28+921
	DD	imagerel $unwind$s370_add_bfp_short
$pdata$s370_add_bfp_short_reg DD imagerel $LN29
	DD	imagerel $LN29+825
	DD	imagerel $unwind$s370_add_bfp_short_reg
$pdata$s370_compare_and_signal_bfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+717
	DD	imagerel $unwind$s370_compare_and_signal_bfp_ext_reg
$pdata$s370_compare_and_signal_bfp_long DD imagerel $LN12
	DD	imagerel $LN12+627
	DD	imagerel $unwind$s370_compare_and_signal_bfp_long
$pdata$s370_compare_and_signal_bfp_long_reg DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$s370_compare_and_signal_bfp_long_reg
$pdata$s370_compare_and_signal_bfp_short DD imagerel $LN12
	DD	imagerel $LN12+624
	DD	imagerel $unwind$s370_compare_and_signal_bfp_short
$pdata$s370_compare_and_signal_bfp_short_reg DD imagerel $LN13
	DD	imagerel $LN13+528
	DD	imagerel $unwind$s370_compare_and_signal_bfp_short_reg
$pdata$s370_compare_bfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+717
	DD	imagerel $unwind$s370_compare_bfp_ext_reg
$pdata$s370_compare_bfp_long DD imagerel $LN12
	DD	imagerel $LN12+627
	DD	imagerel $unwind$s370_compare_bfp_long
$pdata$s370_compare_bfp_long_reg DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$s370_compare_bfp_long_reg
$pdata$s370_compare_bfp_short DD imagerel $LN12
	DD	imagerel $LN12+624
	DD	imagerel $unwind$s370_compare_bfp_short
$pdata$s370_compare_bfp_short_reg DD imagerel $LN13
	DD	imagerel $LN13+528
	DD	imagerel $unwind$s370_compare_bfp_short_reg
$pdata$s370_convert_bfp_ext_to_fix32_reg DD imagerel $LN27
	DD	imagerel $LN27+1268
	DD	imagerel $unwind$s370_convert_bfp_ext_to_fix32_reg
$pdata$s370_convert_bfp_long_to_fix32_reg DD imagerel $LN26
	DD	imagerel $LN26+1048
	DD	imagerel $unwind$s370_convert_bfp_long_to_fix32_reg
$pdata$s370_convert_bfp_short_to_fix32_reg DD imagerel $LN26
	DD	imagerel $LN26+1033
	DD	imagerel $unwind$s370_convert_bfp_short_to_fix32_reg
$pdata$s370_convert_fix32_to_bfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+680
	DD	imagerel $unwind$s370_convert_fix32_to_bfp_ext_reg
$pdata$s370_convert_fix32_to_bfp_long_reg DD imagerel $LN14
	DD	imagerel $LN14+541
	DD	imagerel $unwind$s370_convert_fix32_to_bfp_long_reg
$pdata$s370_convert_fix32_to_bfp_short_reg DD imagerel $LN16
	DD	imagerel $LN16+635
	DD	imagerel $unwind$s370_convert_fix32_to_bfp_short_reg
$pdata$s370_divide_bfp_ext_reg DD imagerel $LN21
	DD	imagerel $LN21+1005
	DD	imagerel $unwind$s370_divide_bfp_ext_reg
$pdata$s370_divide_bfp_long DD imagerel $LN18
	DD	imagerel $LN18+846
	DD	imagerel $unwind$s370_divide_bfp_long
$pdata$s370_divide_bfp_long_reg DD imagerel $LN19
	DD	imagerel $LN19+749
	DD	imagerel $unwind$s370_divide_bfp_long_reg
$pdata$s370_divide_bfp_short DD imagerel $LN18
	DD	imagerel $LN18+841
	DD	imagerel $unwind$s370_divide_bfp_short
$pdata$s370_divide_bfp_short_reg DD imagerel $LN19
	DD	imagerel $LN19+745
	DD	imagerel $unwind$s370_divide_bfp_short_reg
$pdata$s370_divide_integer_bfp_long_reg DD imagerel $LN39
	DD	imagerel $LN39+3108
	DD	imagerel $unwind$s370_divide_integer_bfp_long_reg
$pdata$s370_divide_integer_bfp_short_reg DD imagerel $LN39
	DD	imagerel $LN39+2380
	DD	imagerel $unwind$s370_divide_integer_bfp_short_reg
$pdata$s370_load_and_test_bfp_ext_reg DD imagerel $LN28
	DD	imagerel $LN28+950
	DD	imagerel $unwind$s370_load_and_test_bfp_ext_reg
$pdata$s370_load_and_test_bfp_long_reg DD imagerel $LN24
	DD	imagerel $LN24+689
	DD	imagerel $unwind$s370_load_and_test_bfp_long_reg
$pdata$s370_load_and_test_bfp_short_reg DD imagerel $LN24
	DD	imagerel $LN24+577
	DD	imagerel $unwind$s370_load_and_test_bfp_short_reg
$pdata$s370_load_complement_bfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+690
	DD	imagerel $unwind$s370_load_complement_bfp_ext_reg
$pdata$s370_load_complement_bfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+546
	DD	imagerel $unwind$s370_load_complement_bfp_long_reg
$pdata$s370_load_complement_bfp_short_reg DD imagerel $LN20
	DD	imagerel $LN20+472
	DD	imagerel $unwind$s370_load_complement_bfp_short_reg
$pdata$s370_load_fp_int_bfp_ext_reg DD imagerel $LN19
	DD	imagerel $LN19+948
	DD	imagerel $unwind$s370_load_fp_int_bfp_ext_reg
$pdata$s370_load_fp_int_bfp_long_reg DD imagerel $LN17
	DD	imagerel $LN17+746
	DD	imagerel $unwind$s370_load_fp_int_bfp_long_reg
$pdata$s370_load_fp_int_bfp_short_reg DD imagerel $LN17
	DD	imagerel $LN17+744
	DD	imagerel $unwind$s370_load_fp_int_bfp_short_reg
$pdata$s370_load_lengthened_bfp_long_to_ext DD imagerel $LN14
	DD	imagerel $LN14+802
	DD	imagerel $unwind$s370_load_lengthened_bfp_long_to_ext
$pdata$s370_load_lengthened_bfp_long_to_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+693
	DD	imagerel $unwind$s370_load_lengthened_bfp_long_to_ext_reg
$pdata$s370_load_lengthened_bfp_short_to_ext DD imagerel $LN14
	DD	imagerel $LN14+785
	DD	imagerel $unwind$s370_load_lengthened_bfp_short_to_ext
$pdata$s370_load_lengthened_bfp_short_to_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+677
	DD	imagerel $unwind$s370_load_lengthened_bfp_short_to_ext_reg
$pdata$s370_load_lengthened_bfp_short_to_long DD imagerel $LN13
	DD	imagerel $LN13+640
	DD	imagerel $unwind$s370_load_lengthened_bfp_short_to_long
$pdata$s370_load_lengthened_bfp_short_to_long_reg DD imagerel $LN11
	DD	imagerel $LN11+538
	DD	imagerel $unwind$s370_load_lengthened_bfp_short_to_long_reg
$pdata$s370_load_negative_bfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+690
	DD	imagerel $unwind$s370_load_negative_bfp_ext_reg
$pdata$s370_load_negative_bfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+546
	DD	imagerel $unwind$s370_load_negative_bfp_long_reg
$pdata$s370_load_negative_bfp_short_reg DD imagerel $LN20
	DD	imagerel $LN20+472
	DD	imagerel $unwind$s370_load_negative_bfp_short_reg
$pdata$s370_load_positive_bfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+690
	DD	imagerel $unwind$s370_load_positive_bfp_ext_reg
$pdata$s370_load_positive_bfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+546
	DD	imagerel $unwind$s370_load_positive_bfp_long_reg
$pdata$s370_load_positive_bfp_short_reg DD imagerel $LN20
	DD	imagerel $LN20+472
	DD	imagerel $unwind$s370_load_positive_bfp_short_reg
$pdata$s370_load_rounded_bfp_ext_to_long_reg DD imagerel $LN25
	DD	imagerel $LN25+1161
	DD	imagerel $unwind$s370_load_rounded_bfp_ext_to_long_reg
$pdata$s370_load_rounded_bfp_ext_to_short_reg DD imagerel $LN25
	DD	imagerel $LN25+1154
	DD	imagerel $unwind$s370_load_rounded_bfp_ext_to_short_reg
$pdata$s370_load_rounded_bfp_long_to_short_reg DD imagerel $LN23
	DD	imagerel $LN23+960
	DD	imagerel $unwind$s370_load_rounded_bfp_long_to_short_reg
$pdata$s370_multiply_add_bfp_long DD imagerel $LN20
	DD	imagerel $LN20+840
	DD	imagerel $unwind$s370_multiply_add_bfp_long
$pdata$s370_multiply_add_bfp_long_reg DD imagerel $LN18
	DD	imagerel $LN18+725
	DD	imagerel $unwind$s370_multiply_add_bfp_long_reg
$pdata$s370_multiply_add_bfp_short DD imagerel $LN20
	DD	imagerel $LN20+835
	DD	imagerel $unwind$s370_multiply_add_bfp_short
$pdata$s370_multiply_add_bfp_short_reg DD imagerel $LN18
	DD	imagerel $LN18+721
	DD	imagerel $unwind$s370_multiply_add_bfp_short_reg
$pdata$s370_multiply_bfp_ext_reg DD imagerel $LN20
	DD	imagerel $LN20+923
	DD	imagerel $unwind$s370_multiply_bfp_ext_reg
$pdata$s370_multiply_bfp_long DD imagerel $LN17
	DD	imagerel $LN17+770
	DD	imagerel $unwind$s370_multiply_bfp_long
$pdata$s370_multiply_bfp_long_reg DD imagerel $LN18
	DD	imagerel $LN18+673
	DD	imagerel $unwind$s370_multiply_bfp_long_reg
$pdata$s370_multiply_bfp_long_to_ext DD imagerel $LN18
	DD	imagerel $LN18+1152
	DD	imagerel $unwind$s370_multiply_bfp_long_to_ext
$pdata$s370_multiply_bfp_long_to_ext_reg DD imagerel $LN19
	DD	imagerel $LN19+1046
	DD	imagerel $unwind$s370_multiply_bfp_long_to_ext_reg
$pdata$s370_multiply_bfp_short DD imagerel $LN17
	DD	imagerel $LN17+765
	DD	imagerel $unwind$s370_multiply_bfp_short
$pdata$s370_multiply_bfp_short_reg DD imagerel $LN18
	DD	imagerel $LN18+669
	DD	imagerel $unwind$s370_multiply_bfp_short_reg
$pdata$s370_multiply_bfp_short_to_long DD imagerel $LN17
	DD	imagerel $LN17+842
	DD	imagerel $unwind$s370_multiply_bfp_short_to_long
$pdata$s370_multiply_bfp_short_to_long_reg DD imagerel $LN18
	DD	imagerel $LN18+746
	DD	imagerel $unwind$s370_multiply_bfp_short_to_long_reg
$pdata$s370_multiply_subtract_bfp_long DD imagerel $LN22
	DD	imagerel $LN22+1003
	DD	imagerel $unwind$s370_multiply_subtract_bfp_long
$pdata$s370_multiply_subtract_bfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+822
	DD	imagerel $unwind$s370_multiply_subtract_bfp_long_reg
$pdata$s370_multiply_subtract_bfp_short DD imagerel $LN22
	DD	imagerel $LN22+884
	DD	imagerel $unwind$s370_multiply_subtract_bfp_short
$pdata$s370_multiply_subtract_bfp_short_reg DD imagerel $LN20
	DD	imagerel $LN20+770
	DD	imagerel $unwind$s370_multiply_subtract_bfp_short_reg
$pdata$s370_squareroot_bfp_ext_reg DD imagerel $LN14
	DD	imagerel $LN14+886
	DD	imagerel $unwind$s370_squareroot_bfp_ext_reg
$pdata$s370_squareroot_bfp_long DD imagerel $LN14
	DD	imagerel $LN14+801
	DD	imagerel $unwind$s370_squareroot_bfp_long
$pdata$s370_squareroot_bfp_long_reg DD imagerel $LN12
	DD	imagerel $LN12+698
	DD	imagerel $unwind$s370_squareroot_bfp_long_reg
$pdata$s370_squareroot_bfp_short DD imagerel $LN14
	DD	imagerel $LN14+798
	DD	imagerel $unwind$s370_squareroot_bfp_short
$pdata$s370_squareroot_bfp_short_reg DD imagerel $LN12
	DD	imagerel $LN12+696
	DD	imagerel $unwind$s370_squareroot_bfp_short_reg
$pdata$s370_subtract_bfp_ext_reg DD imagerel $LN32
	DD	imagerel $LN32+1282
	DD	imagerel $unwind$s370_subtract_bfp_ext_reg
$pdata$s370_subtract_bfp_long DD imagerel $LN28
	DD	imagerel $LN28+1049
	DD	imagerel $unwind$s370_subtract_bfp_long
$pdata$s370_subtract_bfp_long_reg DD imagerel $LN29
	DD	imagerel $LN29+889
	DD	imagerel $unwind$s370_subtract_bfp_long_reg
$pdata$s370_subtract_bfp_short DD imagerel $LN28
	DD	imagerel $LN28+921
	DD	imagerel $unwind$s370_subtract_bfp_short
$pdata$s370_subtract_bfp_short_reg DD imagerel $LN29
	DD	imagerel $LN29+825
	DD	imagerel $unwind$s370_subtract_bfp_short_reg
$pdata$s370_test_data_class_bfp_ext DD imagerel $LN14
	DD	imagerel $LN14+572
	DD	imagerel $unwind$s370_test_data_class_bfp_ext
$pdata$s370_test_data_class_bfp_long DD imagerel $LN13
	DD	imagerel $LN13+437
	DD	imagerel $unwind$s370_test_data_class_bfp_long
$pdata$s370_test_data_class_bfp_short DD imagerel $LN13
	DD	imagerel $LN13+436
	DD	imagerel $unwind$s370_test_data_class_bfp_short
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch8 DD imagerel $LN23
	DD	imagerel $LN23+240
	DD	imagerel $unwind$s370_vfetch8
pdata	ENDS
pdata	SEGMENT
$pdata$ieee_trap DD imagerel ieee_trap
	DD	imagerel ieee_trap+116
	DD	imagerel $unwind$ieee_trap
$pdata$ieee_cond_trap DD imagerel ieee_cond_trap
	DD	imagerel ieee_cond_trap+502
	DD	imagerel $unwind$ieee_cond_trap
$pdata$float128_class DD imagerel float128_class
	DD	imagerel float128_class+531
	DD	imagerel $unwind$float128_class
$pdata$float64_class DD imagerel float64_class
	DD	imagerel float64_class+384
	DD	imagerel $unwind$float64_class
$pdata$float32_class DD imagerel float32_class
	DD	imagerel float32_class+285
	DD	imagerel $unwind$float32_class
$pdata$ieee_exception_test_oux DD imagerel ieee_exception_test_oux
	DD	imagerel ieee_exception_test_oux+440
	DD	imagerel $unwind$ieee_exception_test_oux
$pdata$s370_BFP_RM_check DD imagerel s370_BFP_RM_check
	DD	imagerel s370_BFP_RM_check+161
	DD	imagerel $unwind$s370_BFP_RM_check
$pdata$s370_float128_cc_quiet DD imagerel s370_float128_cc_quiet
	DD	imagerel s370_float128_cc_quiet+458
	DD	imagerel $unwind$s370_float128_cc_quiet
$pdata$s370_float128_compare DD imagerel s370_float128_compare
	DD	imagerel s370_float128_compare+226
	DD	imagerel $unwind$s370_float128_compare
$pdata$s370_float128_signaling_compare DD imagerel s370_float128_signaling_compare
	DD	imagerel s370_float128_signaling_compare+349
	DD	imagerel $unwind$s370_float128_signaling_compare
$pdata$s370_float64_cc_quiet DD imagerel s370_float64_cc_quiet
	DD	imagerel s370_float64_cc_quiet+250
	DD	imagerel $unwind$s370_float64_cc_quiet
$pdata$s370_float64_compare DD imagerel s370_float64_compare
	DD	imagerel s370_float64_compare+133
	DD	imagerel $unwind$s370_float64_compare
$pdata$s370_float64_signaling_compare DD imagerel s370_float64_signaling_compare
	DD	imagerel s370_float64_signaling_compare+223
	DD	imagerel $unwind$s370_float64_signaling_compare
$pdata$s370_float32_cc_quiet DD imagerel s370_float32_cc_quiet
	DD	imagerel s370_float32_cc_quiet+174
	DD	imagerel $unwind$s370_float32_cc_quiet
$pdata$s370_float32_compare DD imagerel s370_float32_compare
	DD	imagerel s370_float32_compare+127
	DD	imagerel $unwind$s370_float32_compare
$pdata$s370_float32_signaling_compare DD imagerel s370_float32_signaling_compare
	DD	imagerel s370_float32_signaling_compare+153
	DD	imagerel $unwind$s370_float32_signaling_compare
$pdata$get_lbfp DD imagerel get_lbfp
	DD	imagerel get_lbfp+160
	DD	imagerel $unwind$get_lbfp
$pdata$get_sbfp DD imagerel get_sbfp
	DD	imagerel get_sbfp+104
	DD	imagerel $unwind$get_sbfp
$pdata$put_lbfp DD imagerel put_lbfp
	DD	imagerel put_lbfp+132
	DD	imagerel $unwind$put_lbfp
$pdata$put_sbfp DD imagerel put_sbfp
	DD	imagerel put_sbfp+88
	DD	imagerel $unwind$put_sbfp
$pdata$s390_add_bfp_ext_reg DD imagerel $LN32
	DD	imagerel $LN32+1221
	DD	imagerel $unwind$s390_add_bfp_ext_reg
$pdata$s390_add_bfp_long DD imagerel $LN28
	DD	imagerel $LN28+1062
	DD	imagerel $unwind$s390_add_bfp_long
$pdata$s390_add_bfp_long_reg DD imagerel $LN29
	DD	imagerel $LN29+889
	DD	imagerel $unwind$s390_add_bfp_long_reg
$pdata$s390_add_bfp_short DD imagerel $LN28
	DD	imagerel $LN28+931
	DD	imagerel $unwind$s390_add_bfp_short
$pdata$s390_add_bfp_short_reg DD imagerel $LN29
	DD	imagerel $LN29+825
	DD	imagerel $unwind$s390_add_bfp_short_reg
$pdata$s390_compare_and_signal_bfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+717
	DD	imagerel $unwind$s390_compare_and_signal_bfp_ext_reg
$pdata$s390_compare_and_signal_bfp_long DD imagerel $LN12
	DD	imagerel $LN12+637
	DD	imagerel $unwind$s390_compare_and_signal_bfp_long
$pdata$s390_compare_and_signal_bfp_long_reg DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$s390_compare_and_signal_bfp_long_reg
$pdata$s390_compare_and_signal_bfp_short DD imagerel $LN12
	DD	imagerel $LN12+634
	DD	imagerel $unwind$s390_compare_and_signal_bfp_short
$pdata$s390_compare_and_signal_bfp_short_reg DD imagerel $LN13
	DD	imagerel $LN13+528
	DD	imagerel $unwind$s390_compare_and_signal_bfp_short_reg
$pdata$s390_compare_bfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+717
	DD	imagerel $unwind$s390_compare_bfp_ext_reg
$pdata$s390_compare_bfp_long DD imagerel $LN12
	DD	imagerel $LN12+637
	DD	imagerel $unwind$s390_compare_bfp_long
$pdata$s390_compare_bfp_long_reg DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$s390_compare_bfp_long_reg
$pdata$s390_compare_bfp_short DD imagerel $LN12
	DD	imagerel $LN12+634
	DD	imagerel $unwind$s390_compare_bfp_short
$pdata$s390_compare_bfp_short_reg DD imagerel $LN13
	DD	imagerel $LN13+528
	DD	imagerel $unwind$s390_compare_bfp_short_reg
$pdata$s390_convert_bfp_ext_to_fix32_reg DD imagerel $LN26
	DD	imagerel $LN26+1236
	DD	imagerel $unwind$s390_convert_bfp_ext_to_fix32_reg
$pdata$s390_convert_bfp_long_to_fix32_reg DD imagerel $LN25
	DD	imagerel $LN25+1019
	DD	imagerel $unwind$s390_convert_bfp_long_to_fix32_reg
$pdata$s390_convert_bfp_short_to_fix32_reg DD imagerel $LN25
	DD	imagerel $LN25+1004
	DD	imagerel $unwind$s390_convert_bfp_short_to_fix32_reg
$pdata$s390_convert_fix32_to_bfp_ext_reg DD imagerel $LN13
	DD	imagerel $LN13+628
	DD	imagerel $unwind$s390_convert_fix32_to_bfp_ext_reg
$pdata$s390_convert_fix32_to_bfp_long_reg DD imagerel $LN12
	DD	imagerel $LN12+495
	DD	imagerel $unwind$s390_convert_fix32_to_bfp_long_reg
$pdata$s390_convert_fix32_to_bfp_short_reg DD imagerel $LN14
	DD	imagerel $LN14+589
	DD	imagerel $unwind$s390_convert_fix32_to_bfp_short_reg
$pdata$s390_divide_bfp_ext_reg DD imagerel $LN21
	DD	imagerel $LN21+1005
	DD	imagerel $unwind$s390_divide_bfp_ext_reg
$pdata$s390_divide_bfp_long DD imagerel $LN18
	DD	imagerel $LN18+856
	DD	imagerel $unwind$s390_divide_bfp_long
$pdata$s390_divide_bfp_long_reg DD imagerel $LN19
	DD	imagerel $LN19+749
	DD	imagerel $unwind$s390_divide_bfp_long_reg
$pdata$s390_divide_bfp_short DD imagerel $LN18
	DD	imagerel $LN18+851
	DD	imagerel $unwind$s390_divide_bfp_short
$pdata$s390_divide_bfp_short_reg DD imagerel $LN19
	DD	imagerel $LN19+745
	DD	imagerel $unwind$s390_divide_bfp_short_reg
$pdata$s390_divide_integer_bfp_long_reg DD imagerel $LN39
	DD	imagerel $LN39+3108
	DD	imagerel $unwind$s390_divide_integer_bfp_long_reg
$pdata$s390_divide_integer_bfp_short_reg DD imagerel $LN39
	DD	imagerel $LN39+2380
	DD	imagerel $unwind$s390_divide_integer_bfp_short_reg
$pdata$s390_load_and_test_bfp_ext_reg DD imagerel $LN28
	DD	imagerel $LN28+950
	DD	imagerel $unwind$s390_load_and_test_bfp_ext_reg
$pdata$s390_load_and_test_bfp_long_reg DD imagerel $LN24
	DD	imagerel $LN24+689
	DD	imagerel $unwind$s390_load_and_test_bfp_long_reg
$pdata$s390_load_and_test_bfp_short_reg DD imagerel $LN24
	DD	imagerel $LN24+577
	DD	imagerel $unwind$s390_load_and_test_bfp_short_reg
$pdata$s390_load_complement_bfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+690
	DD	imagerel $unwind$s390_load_complement_bfp_ext_reg
$pdata$s390_load_complement_bfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+546
	DD	imagerel $unwind$s390_load_complement_bfp_long_reg
$pdata$s390_load_complement_bfp_short_reg DD imagerel $LN20
	DD	imagerel $LN20+472
	DD	imagerel $unwind$s390_load_complement_bfp_short_reg
$pdata$s390_load_fp_int_bfp_ext_reg DD imagerel $LN18
	DD	imagerel $LN18+916
	DD	imagerel $unwind$s390_load_fp_int_bfp_ext_reg
$pdata$s390_load_fp_int_bfp_long_reg DD imagerel $LN16
	DD	imagerel $LN16+717
	DD	imagerel $unwind$s390_load_fp_int_bfp_long_reg
$pdata$s390_load_fp_int_bfp_short_reg DD imagerel $LN16
	DD	imagerel $LN16+715
	DD	imagerel $unwind$s390_load_fp_int_bfp_short_reg
$pdata$s390_load_lengthened_bfp_long_to_ext DD imagerel $LN14
	DD	imagerel $LN14+815
	DD	imagerel $unwind$s390_load_lengthened_bfp_long_to_ext
$pdata$s390_load_lengthened_bfp_long_to_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+693
	DD	imagerel $unwind$s390_load_lengthened_bfp_long_to_ext_reg
$pdata$s390_load_lengthened_bfp_short_to_ext DD imagerel $LN14
	DD	imagerel $LN14+798
	DD	imagerel $unwind$s390_load_lengthened_bfp_short_to_ext
$pdata$s390_load_lengthened_bfp_short_to_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+677
	DD	imagerel $unwind$s390_load_lengthened_bfp_short_to_ext_reg
$pdata$s390_load_lengthened_bfp_short_to_long DD imagerel $LN13
	DD	imagerel $LN13+650
	DD	imagerel $unwind$s390_load_lengthened_bfp_short_to_long
$pdata$s390_load_lengthened_bfp_short_to_long_reg DD imagerel $LN11
	DD	imagerel $LN11+538
	DD	imagerel $unwind$s390_load_lengthened_bfp_short_to_long_reg
$pdata$s390_load_negative_bfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+690
	DD	imagerel $unwind$s390_load_negative_bfp_ext_reg
$pdata$s390_load_negative_bfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+546
	DD	imagerel $unwind$s390_load_negative_bfp_long_reg
$pdata$s390_load_negative_bfp_short_reg DD imagerel $LN20
	DD	imagerel $LN20+472
	DD	imagerel $unwind$s390_load_negative_bfp_short_reg
$pdata$s390_load_positive_bfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+690
	DD	imagerel $unwind$s390_load_positive_bfp_ext_reg
$pdata$s390_load_positive_bfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+546
	DD	imagerel $unwind$s390_load_positive_bfp_long_reg
$pdata$s390_load_positive_bfp_short_reg DD imagerel $LN20
	DD	imagerel $LN20+472
	DD	imagerel $unwind$s390_load_positive_bfp_short_reg
$pdata$s390_load_rounded_bfp_ext_to_long_reg DD imagerel $LN19
	DD	imagerel $LN19+916
	DD	imagerel $unwind$s390_load_rounded_bfp_ext_to_long_reg
$pdata$s390_load_rounded_bfp_ext_to_short_reg DD imagerel $LN19
	DD	imagerel $LN19+915
	DD	imagerel $unwind$s390_load_rounded_bfp_ext_to_short_reg
$pdata$s390_load_rounded_bfp_long_to_short_reg DD imagerel $LN17
	DD	imagerel $LN17+727
	DD	imagerel $unwind$s390_load_rounded_bfp_long_to_short_reg
$pdata$s390_multiply_add_bfp_long DD imagerel $LN20
	DD	imagerel $LN20+850
	DD	imagerel $unwind$s390_multiply_add_bfp_long
$pdata$s390_multiply_add_bfp_long_reg DD imagerel $LN18
	DD	imagerel $LN18+725
	DD	imagerel $unwind$s390_multiply_add_bfp_long_reg
$pdata$s390_multiply_add_bfp_short DD imagerel $LN20
	DD	imagerel $LN20+845
	DD	imagerel $unwind$s390_multiply_add_bfp_short
$pdata$s390_multiply_add_bfp_short_reg DD imagerel $LN18
	DD	imagerel $LN18+721
	DD	imagerel $unwind$s390_multiply_add_bfp_short_reg
$pdata$s390_multiply_bfp_ext_reg DD imagerel $LN20
	DD	imagerel $LN20+923
	DD	imagerel $unwind$s390_multiply_bfp_ext_reg
$pdata$s390_multiply_bfp_long DD imagerel $LN17
	DD	imagerel $LN17+780
	DD	imagerel $unwind$s390_multiply_bfp_long
$pdata$s390_multiply_bfp_long_reg DD imagerel $LN18
	DD	imagerel $LN18+673
	DD	imagerel $unwind$s390_multiply_bfp_long_reg
$pdata$s390_multiply_bfp_long_to_ext DD imagerel $LN18
	DD	imagerel $LN18+1165
	DD	imagerel $unwind$s390_multiply_bfp_long_to_ext
$pdata$s390_multiply_bfp_long_to_ext_reg DD imagerel $LN19
	DD	imagerel $LN19+1046
	DD	imagerel $unwind$s390_multiply_bfp_long_to_ext_reg
$pdata$s390_multiply_bfp_short DD imagerel $LN17
	DD	imagerel $LN17+775
	DD	imagerel $unwind$s390_multiply_bfp_short
$pdata$s390_multiply_bfp_short_reg DD imagerel $LN18
	DD	imagerel $LN18+669
	DD	imagerel $unwind$s390_multiply_bfp_short_reg
$pdata$s390_multiply_bfp_short_to_long DD imagerel $LN17
	DD	imagerel $LN17+852
	DD	imagerel $unwind$s390_multiply_bfp_short_to_long
$pdata$s390_multiply_bfp_short_to_long_reg DD imagerel $LN18
	DD	imagerel $LN18+746
	DD	imagerel $unwind$s390_multiply_bfp_short_to_long_reg
$pdata$s390_multiply_subtract_bfp_long DD imagerel $LN22
	DD	imagerel $LN22+1016
	DD	imagerel $unwind$s390_multiply_subtract_bfp_long
$pdata$s390_multiply_subtract_bfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+822
	DD	imagerel $unwind$s390_multiply_subtract_bfp_long_reg
$pdata$s390_multiply_subtract_bfp_short DD imagerel $LN22
	DD	imagerel $LN22+894
	DD	imagerel $unwind$s390_multiply_subtract_bfp_short
$pdata$s390_multiply_subtract_bfp_short_reg DD imagerel $LN20
	DD	imagerel $LN20+770
	DD	imagerel $unwind$s390_multiply_subtract_bfp_short_reg
$pdata$s390_squareroot_bfp_ext_reg DD imagerel $LN14
	DD	imagerel $LN14+886
	DD	imagerel $unwind$s390_squareroot_bfp_ext_reg
$pdata$s390_squareroot_bfp_long DD imagerel $LN14
	DD	imagerel $LN14+811
	DD	imagerel $unwind$s390_squareroot_bfp_long
$pdata$s390_squareroot_bfp_long_reg DD imagerel $LN12
	DD	imagerel $LN12+698
	DD	imagerel $unwind$s390_squareroot_bfp_long_reg
$pdata$s390_squareroot_bfp_short DD imagerel $LN14
	DD	imagerel $LN14+808
	DD	imagerel $unwind$s390_squareroot_bfp_short
$pdata$s390_squareroot_bfp_short_reg DD imagerel $LN12
	DD	imagerel $LN12+696
	DD	imagerel $unwind$s390_squareroot_bfp_short_reg
$pdata$s390_subtract_bfp_ext_reg DD imagerel $LN32
	DD	imagerel $LN32+1282
	DD	imagerel $unwind$s390_subtract_bfp_ext_reg
$pdata$s390_subtract_bfp_long DD imagerel $LN28
	DD	imagerel $LN28+1062
	DD	imagerel $unwind$s390_subtract_bfp_long
$pdata$s390_subtract_bfp_long_reg DD imagerel $LN29
	DD	imagerel $LN29+889
	DD	imagerel $unwind$s390_subtract_bfp_long_reg
$pdata$s390_subtract_bfp_short DD imagerel $LN28
	DD	imagerel $LN28+931
	DD	imagerel $unwind$s390_subtract_bfp_short
$pdata$s390_subtract_bfp_short_reg DD imagerel $LN29
	DD	imagerel $LN29+825
	DD	imagerel $unwind$s390_subtract_bfp_short_reg
$pdata$s390_test_data_class_bfp_ext DD imagerel $LN14
	DD	imagerel $LN14+585
	DD	imagerel $unwind$s390_test_data_class_bfp_ext
$pdata$s390_test_data_class_bfp_long DD imagerel $LN13
	DD	imagerel $LN13+447
	DD	imagerel $unwind$s390_test_data_class_bfp_long
$pdata$s390_test_data_class_bfp_short DD imagerel $LN13
	DD	imagerel $LN13+446
	DD	imagerel $unwind$s390_test_data_class_bfp_short
$pdata$s390_convert_bfp_long_to_float_long_reg DD imagerel $LN11
	DD	imagerel $LN11+384
	DD	imagerel $unwind$s390_convert_bfp_long_to_float_long_reg
$pdata$s390_convert_bfp_short_to_float_long_reg DD imagerel $LN11
	DD	imagerel $LN11+458
	DD	imagerel $unwind$s390_convert_bfp_short_to_float_long_reg
$pdata$s390_convert_float_long_to_bfp_long_reg DD imagerel $LN11
	DD	imagerel $LN11+481
	DD	imagerel $unwind$s390_convert_float_long_to_bfp_long_reg
$pdata$s390_convert_float_long_to_bfp_short_reg DD imagerel $LN11
	DD	imagerel $LN11+489
	DD	imagerel $unwind$s390_convert_float_long_to_bfp_short_reg
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$s390_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+151
	DD	imagerel $unwind$s390_vfetch8
pdata	ENDS
pdata	SEGMENT
$pdata$s390_BFP_RM_check DD imagerel s390_BFP_RM_check
	DD	imagerel s390_BFP_RM_check+74
	DD	imagerel $unwind$s390_BFP_RM_check
$pdata$s390_float128_cc_quiet DD imagerel s390_float128_cc_quiet
	DD	imagerel s390_float128_cc_quiet+458
	DD	imagerel $unwind$s390_float128_cc_quiet
$pdata$s390_float128_compare DD imagerel s390_float128_compare
	DD	imagerel s390_float128_compare+226
	DD	imagerel $unwind$s390_float128_compare
$pdata$s390_float128_signaling_compare DD imagerel s390_float128_signaling_compare
	DD	imagerel s390_float128_signaling_compare+349
	DD	imagerel $unwind$s390_float128_signaling_compare
$pdata$s390_float64_cc_quiet DD imagerel s390_float64_cc_quiet
	DD	imagerel s390_float64_cc_quiet+250
	DD	imagerel $unwind$s390_float64_cc_quiet
$pdata$s390_float64_compare DD imagerel s390_float64_compare
	DD	imagerel s390_float64_compare+133
	DD	imagerel $unwind$s390_float64_compare
$pdata$s390_float64_signaling_compare DD imagerel s390_float64_signaling_compare
	DD	imagerel s390_float64_signaling_compare+223
	DD	imagerel $unwind$s390_float64_signaling_compare
$pdata$s390_float32_cc_quiet DD imagerel s390_float32_cc_quiet
	DD	imagerel s390_float32_cc_quiet+174
	DD	imagerel $unwind$s390_float32_cc_quiet
$pdata$s390_float32_compare DD imagerel s390_float32_compare
	DD	imagerel s390_float32_compare+127
	DD	imagerel $unwind$s390_float32_compare
$pdata$s390_float32_signaling_compare DD imagerel s390_float32_signaling_compare
	DD	imagerel s390_float32_signaling_compare+153
	DD	imagerel $unwind$s390_float32_signaling_compare
$pdata$cnvt_bfp_to_hfp DD imagerel cnvt_bfp_to_hfp
	DD	imagerel cnvt_bfp_to_hfp+706
	DD	imagerel $unwind$cnvt_bfp_to_hfp
$pdata$cnvt_hfp_to_bfp DD imagerel cnvt_hfp_to_bfp
	DD	imagerel cnvt_hfp_to_bfp+944
	DD	imagerel $unwind$cnvt_hfp_to_bfp
$pdata$z900_convert_u32_to_bfp_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+745
	DD	imagerel $unwind$z900_convert_u32_to_bfp_ext_reg
$pdata$z900_convert_u32_to_bfp_long_reg DD imagerel $LN16
	DD	imagerel $LN16+589
	DD	imagerel $unwind$z900_convert_u32_to_bfp_long_reg
$pdata$z900_convert_u32_to_bfp_short_reg DD imagerel $LN18
	DD	imagerel $LN18+697
	DD	imagerel $unwind$z900_convert_u32_to_bfp_short_reg
$pdata$z900_convert_u64_to_bfp_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+748
	DD	imagerel $unwind$z900_convert_u64_to_bfp_ext_reg
$pdata$z900_convert_u64_to_bfp_long_reg DD imagerel $LN18
	DD	imagerel $LN18+701
	DD	imagerel $unwind$z900_convert_u64_to_bfp_long_reg
$pdata$z900_convert_u64_to_bfp_short_reg DD imagerel $LN18
	DD	imagerel $LN18+700
	DD	imagerel $unwind$z900_convert_u64_to_bfp_short_reg
$pdata$z900_convert_bfp_ext_to_u32_reg DD imagerel $LN36
	DD	imagerel $LN36+1555
	DD	imagerel $unwind$z900_convert_bfp_ext_to_u32_reg
$pdata$z900_convert_bfp_long_to_u32_reg DD imagerel $LN33
	DD	imagerel $LN33+1273
	DD	imagerel $unwind$z900_convert_bfp_long_to_u32_reg
$pdata$z900_convert_bfp_short_to_u32_reg DD imagerel $LN33
	DD	imagerel $LN33+1179
	DD	imagerel $unwind$z900_convert_bfp_short_to_u32_reg
$pdata$z900_convert_bfp_ext_to_u64_reg DD imagerel $LN36
	DD	imagerel $LN36+1563
	DD	imagerel $unwind$z900_convert_bfp_ext_to_u64_reg
$pdata$z900_convert_bfp_long_to_u64_reg DD imagerel $LN33
	DD	imagerel $LN33+1277
	DD	imagerel $unwind$z900_convert_bfp_long_to_u64_reg
$pdata$z900_convert_bfp_short_to_u64_reg DD imagerel $LN33
	DD	imagerel $LN33+1183
	DD	imagerel $unwind$z900_convert_bfp_short_to_u64_reg
$pdata$z900_add_bfp_ext_reg DD imagerel $LN37
	DD	imagerel $LN37+1377
	DD	imagerel $unwind$z900_add_bfp_ext_reg
$pdata$z900_add_bfp_long DD imagerel $LN33
	DD	imagerel $LN33+1259
	DD	imagerel $unwind$z900_add_bfp_long
$pdata$z900_add_bfp_long_reg DD imagerel $LN34
	DD	imagerel $LN34+1019
	DD	imagerel $unwind$z900_add_bfp_long_reg
$pdata$z900_add_bfp_short DD imagerel $LN33
	DD	imagerel $LN33+1099
	DD	imagerel $unwind$z900_add_bfp_short
$pdata$z900_add_bfp_short_reg DD imagerel $LN34
	DD	imagerel $LN34+955
	DD	imagerel $unwind$z900_add_bfp_short_reg
$pdata$z900_compare_and_signal_bfp_ext_reg DD imagerel $LN20
	DD	imagerel $LN20+873
	DD	imagerel $unwind$z900_compare_and_signal_bfp_ext_reg
$pdata$z900_compare_and_signal_bfp_long DD imagerel $LN17
	DD	imagerel $LN17+805
	DD	imagerel $unwind$z900_compare_and_signal_bfp_long
$pdata$z900_compare_and_signal_bfp_long_reg DD imagerel $LN18
	DD	imagerel $LN18+660
	DD	imagerel $unwind$z900_compare_and_signal_bfp_long_reg
$pdata$z900_compare_and_signal_bfp_short DD imagerel $LN17
	DD	imagerel $LN17+802
	DD	imagerel $unwind$z900_compare_and_signal_bfp_short
$pdata$z900_compare_and_signal_bfp_short_reg DD imagerel $LN18
	DD	imagerel $LN18+658
	DD	imagerel $unwind$z900_compare_and_signal_bfp_short_reg
$pdata$z900_compare_bfp_ext_reg DD imagerel $LN20
	DD	imagerel $LN20+873
	DD	imagerel $unwind$z900_compare_bfp_ext_reg
$pdata$z900_compare_bfp_long DD imagerel $LN17
	DD	imagerel $LN17+805
	DD	imagerel $unwind$z900_compare_bfp_long
$pdata$z900_compare_bfp_long_reg DD imagerel $LN18
	DD	imagerel $LN18+660
	DD	imagerel $unwind$z900_compare_bfp_long_reg
$pdata$z900_compare_bfp_short DD imagerel $LN17
	DD	imagerel $LN17+802
	DD	imagerel $unwind$z900_compare_bfp_short
$pdata$z900_compare_bfp_short_reg DD imagerel $LN18
	DD	imagerel $LN18+658
	DD	imagerel $unwind$z900_compare_bfp_short_reg
$pdata$z900_convert_bfp_ext_to_fix32_reg DD imagerel $LN32
	DD	imagerel $LN32+1424
	DD	imagerel $unwind$z900_convert_bfp_ext_to_fix32_reg
$pdata$z900_convert_bfp_ext_to_fix64_reg DD imagerel $LN32
	DD	imagerel $LN32+1436
	DD	imagerel $unwind$z900_convert_bfp_ext_to_fix64_reg
$pdata$z900_convert_bfp_long_to_fix32_reg DD imagerel $LN31
	DD	imagerel $LN31+1178
	DD	imagerel $unwind$z900_convert_bfp_long_to_fix32_reg
$pdata$z900_convert_bfp_long_to_fix64_reg DD imagerel $LN31
	DD	imagerel $LN31+1190
	DD	imagerel $unwind$z900_convert_bfp_long_to_fix64_reg
$pdata$z900_convert_bfp_short_to_fix32_reg DD imagerel $LN31
	DD	imagerel $LN31+1163
	DD	imagerel $unwind$z900_convert_bfp_short_to_fix32_reg
$pdata$z900_convert_bfp_short_to_fix64_reg DD imagerel $LN31
	DD	imagerel $LN31+1175
	DD	imagerel $unwind$z900_convert_bfp_short_to_fix64_reg
$pdata$z900_convert_fix32_to_bfp_ext_reg DD imagerel $LN20
	DD	imagerel $LN20+836
	DD	imagerel $unwind$z900_convert_fix32_to_bfp_ext_reg
$pdata$z900_convert_fix32_to_bfp_long_reg DD imagerel $LN19
	DD	imagerel $LN19+671
	DD	imagerel $unwind$z900_convert_fix32_to_bfp_long_reg
$pdata$z900_convert_fix32_to_bfp_short_reg DD imagerel $LN21
	DD	imagerel $LN21+765
	DD	imagerel $unwind$z900_convert_fix32_to_bfp_short_reg
$pdata$z900_convert_fix64_to_bfp_ext_reg DD imagerel $LN20
	DD	imagerel $LN20+839
	DD	imagerel $unwind$z900_convert_fix64_to_bfp_ext_reg
$pdata$z900_convert_fix64_to_bfp_long_reg DD imagerel $LN21
	DD	imagerel $LN21+769
	DD	imagerel $unwind$z900_convert_fix64_to_bfp_long_reg
$pdata$z900_convert_fix64_to_bfp_short_reg DD imagerel $LN21
	DD	imagerel $LN21+768
	DD	imagerel $unwind$z900_convert_fix64_to_bfp_short_reg
$pdata$z900_divide_bfp_ext_reg DD imagerel $LN26
	DD	imagerel $LN26+1161
	DD	imagerel $unwind$z900_divide_bfp_ext_reg
$pdata$z900_divide_bfp_long DD imagerel $LN23
	DD	imagerel $LN23+1024
	DD	imagerel $unwind$z900_divide_bfp_long
$pdata$z900_divide_bfp_long_reg DD imagerel $LN24
	DD	imagerel $LN24+879
	DD	imagerel $unwind$z900_divide_bfp_long_reg
$pdata$z900_divide_bfp_short DD imagerel $LN23
	DD	imagerel $LN23+1019
	DD	imagerel $unwind$z900_divide_bfp_short
$pdata$z900_divide_bfp_short_reg DD imagerel $LN24
	DD	imagerel $LN24+875
	DD	imagerel $unwind$z900_divide_bfp_short_reg
$pdata$z900_divide_integer_bfp_long_reg DD imagerel $LN44
	DD	imagerel $LN44+3264
	DD	imagerel $unwind$z900_divide_integer_bfp_long_reg
$pdata$z900_divide_integer_bfp_short_reg DD imagerel $LN44
	DD	imagerel $LN44+2536
	DD	imagerel $unwind$z900_divide_integer_bfp_short_reg
$pdata$z900_load_and_test_bfp_ext_reg DD imagerel $LN33
	DD	imagerel $LN33+1106
	DD	imagerel $unwind$z900_load_and_test_bfp_ext_reg
$pdata$z900_load_and_test_bfp_long_reg DD imagerel $LN29
	DD	imagerel $LN29+819
	DD	imagerel $unwind$z900_load_and_test_bfp_long_reg
$pdata$z900_load_and_test_bfp_short_reg DD imagerel $LN29
	DD	imagerel $LN29+707
	DD	imagerel $unwind$z900_load_and_test_bfp_short_reg
$pdata$z900_load_complement_bfp_ext_reg DD imagerel $LN28
	DD	imagerel $LN28+820
	DD	imagerel $unwind$z900_load_complement_bfp_ext_reg
$pdata$z900_load_complement_bfp_long_reg DD imagerel $LN25
	DD	imagerel $LN25+676
	DD	imagerel $unwind$z900_load_complement_bfp_long_reg
$pdata$z900_load_complement_bfp_short_reg DD imagerel $LN25
	DD	imagerel $LN25+602
	DD	imagerel $unwind$z900_load_complement_bfp_short_reg
$pdata$z900_load_fp_int_bfp_ext_reg DD imagerel $LN24
	DD	imagerel $LN24+1104
	DD	imagerel $unwind$z900_load_fp_int_bfp_ext_reg
$pdata$z900_load_fp_int_bfp_long_reg DD imagerel $LN22
	DD	imagerel $LN22+876
	DD	imagerel $unwind$z900_load_fp_int_bfp_long_reg
$pdata$z900_load_fp_int_bfp_short_reg DD imagerel $LN22
	DD	imagerel $LN22+874
	DD	imagerel $unwind$z900_load_fp_int_bfp_short_reg
$pdata$z900_load_lengthened_bfp_long_to_ext DD imagerel $LN19
	DD	imagerel $LN19+1012
	DD	imagerel $unwind$z900_load_lengthened_bfp_long_to_ext
$pdata$z900_load_lengthened_bfp_long_to_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+849
	DD	imagerel $unwind$z900_load_lengthened_bfp_long_to_ext_reg
$pdata$z900_load_lengthened_bfp_short_to_ext DD imagerel $LN19
	DD	imagerel $LN19+995
	DD	imagerel $unwind$z900_load_lengthened_bfp_short_to_ext
$pdata$z900_load_lengthened_bfp_short_to_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+833
	DD	imagerel $unwind$z900_load_lengthened_bfp_short_to_ext_reg
$pdata$z900_load_lengthened_bfp_short_to_long DD imagerel $LN18
	DD	imagerel $LN18+818
	DD	imagerel $unwind$z900_load_lengthened_bfp_short_to_long
$pdata$z900_load_lengthened_bfp_short_to_long_reg DD imagerel $LN16
	DD	imagerel $LN16+668
	DD	imagerel $unwind$z900_load_lengthened_bfp_short_to_long_reg
$pdata$z900_load_negative_bfp_ext_reg DD imagerel $LN28
	DD	imagerel $LN28+820
	DD	imagerel $unwind$z900_load_negative_bfp_ext_reg
$pdata$z900_load_negative_bfp_long_reg DD imagerel $LN25
	DD	imagerel $LN25+676
	DD	imagerel $unwind$z900_load_negative_bfp_long_reg
$pdata$z900_load_negative_bfp_short_reg DD imagerel $LN25
	DD	imagerel $LN25+602
	DD	imagerel $unwind$z900_load_negative_bfp_short_reg
$pdata$z900_load_positive_bfp_ext_reg DD imagerel $LN28
	DD	imagerel $LN28+820
	DD	imagerel $unwind$z900_load_positive_bfp_ext_reg
$pdata$z900_load_positive_bfp_long_reg DD imagerel $LN25
	DD	imagerel $LN25+676
	DD	imagerel $unwind$z900_load_positive_bfp_long_reg
$pdata$z900_load_positive_bfp_short_reg DD imagerel $LN25
	DD	imagerel $LN25+602
	DD	imagerel $unwind$z900_load_positive_bfp_short_reg
$pdata$z900_load_rounded_bfp_ext_to_long_reg DD imagerel $LN30
	DD	imagerel $LN30+1317
	DD	imagerel $unwind$z900_load_rounded_bfp_ext_to_long_reg
$pdata$z900_load_rounded_bfp_ext_to_short_reg DD imagerel $LN30
	DD	imagerel $LN30+1310
	DD	imagerel $unwind$z900_load_rounded_bfp_ext_to_short_reg
$pdata$z900_load_rounded_bfp_long_to_short_reg DD imagerel $LN28
	DD	imagerel $LN28+1090
	DD	imagerel $unwind$z900_load_rounded_bfp_long_to_short_reg
$pdata$z900_multiply_add_bfp_long DD imagerel $LN25
	DD	imagerel $LN25+1116
	DD	imagerel $unwind$z900_multiply_add_bfp_long
$pdata$z900_multiply_add_bfp_long_reg DD imagerel $LN23
	DD	imagerel $LN23+855
	DD	imagerel $unwind$z900_multiply_add_bfp_long_reg
$pdata$z900_multiply_add_bfp_short DD imagerel $LN25
	DD	imagerel $LN25+1013
	DD	imagerel $unwind$z900_multiply_add_bfp_short
$pdata$z900_multiply_add_bfp_short_reg DD imagerel $LN23
	DD	imagerel $LN23+851
	DD	imagerel $unwind$z900_multiply_add_bfp_short_reg
$pdata$z900_multiply_bfp_ext_reg DD imagerel $LN25
	DD	imagerel $LN25+1079
	DD	imagerel $unwind$z900_multiply_bfp_ext_reg
$pdata$z900_multiply_bfp_long DD imagerel $LN22
	DD	imagerel $LN22+948
	DD	imagerel $unwind$z900_multiply_bfp_long
$pdata$z900_multiply_bfp_long_reg DD imagerel $LN23
	DD	imagerel $LN23+803
	DD	imagerel $unwind$z900_multiply_bfp_long_reg
$pdata$z900_multiply_bfp_long_to_ext DD imagerel $LN23
	DD	imagerel $LN23+1362
	DD	imagerel $unwind$z900_multiply_bfp_long_to_ext
$pdata$z900_multiply_bfp_long_to_ext_reg DD imagerel $LN24
	DD	imagerel $LN24+1202
	DD	imagerel $unwind$z900_multiply_bfp_long_to_ext_reg
$pdata$z900_multiply_bfp_short DD imagerel $LN22
	DD	imagerel $LN22+943
	DD	imagerel $unwind$z900_multiply_bfp_short
$pdata$z900_multiply_bfp_short_reg DD imagerel $LN23
	DD	imagerel $LN23+799
	DD	imagerel $unwind$z900_multiply_bfp_short_reg
$pdata$z900_multiply_bfp_short_to_long DD imagerel $LN22
	DD	imagerel $LN22+1020
	DD	imagerel $unwind$z900_multiply_bfp_short_to_long
$pdata$z900_multiply_bfp_short_to_long_reg DD imagerel $LN23
	DD	imagerel $LN23+876
	DD	imagerel $unwind$z900_multiply_bfp_short_to_long_reg
$pdata$z900_multiply_subtract_bfp_long DD imagerel $LN27
	DD	imagerel $LN27+1213
	DD	imagerel $unwind$z900_multiply_subtract_bfp_long
$pdata$z900_multiply_subtract_bfp_long_reg DD imagerel $LN25
	DD	imagerel $LN25+952
	DD	imagerel $unwind$z900_multiply_subtract_bfp_long_reg
$pdata$z900_multiply_subtract_bfp_short DD imagerel $LN27
	DD	imagerel $LN27+1062
	DD	imagerel $unwind$z900_multiply_subtract_bfp_short
$pdata$z900_multiply_subtract_bfp_short_reg DD imagerel $LN25
	DD	imagerel $LN25+900
	DD	imagerel $unwind$z900_multiply_subtract_bfp_short_reg
$pdata$z900_squareroot_bfp_ext_reg DD imagerel $LN19
	DD	imagerel $LN19+1042
	DD	imagerel $unwind$z900_squareroot_bfp_ext_reg
$pdata$z900_squareroot_bfp_long DD imagerel $LN19
	DD	imagerel $LN19+979
	DD	imagerel $unwind$z900_squareroot_bfp_long
$pdata$z900_squareroot_bfp_long_reg DD imagerel $LN17
	DD	imagerel $LN17+828
	DD	imagerel $unwind$z900_squareroot_bfp_long_reg
$pdata$z900_squareroot_bfp_short DD imagerel $LN19
	DD	imagerel $LN19+976
	DD	imagerel $unwind$z900_squareroot_bfp_short
$pdata$z900_squareroot_bfp_short_reg DD imagerel $LN17
	DD	imagerel $LN17+826
	DD	imagerel $unwind$z900_squareroot_bfp_short_reg
$pdata$z900_subtract_bfp_ext_reg DD imagerel $LN37
	DD	imagerel $LN37+1438
	DD	imagerel $unwind$z900_subtract_bfp_ext_reg
$pdata$z900_subtract_bfp_long DD imagerel $LN33
	DD	imagerel $LN33+1259
	DD	imagerel $unwind$z900_subtract_bfp_long
$pdata$z900_subtract_bfp_long_reg DD imagerel $LN34
	DD	imagerel $LN34+1019
	DD	imagerel $unwind$z900_subtract_bfp_long_reg
$pdata$z900_subtract_bfp_short DD imagerel $LN33
	DD	imagerel $LN33+1099
	DD	imagerel $unwind$z900_subtract_bfp_short
$pdata$z900_subtract_bfp_short_reg DD imagerel $LN34
	DD	imagerel $LN34+955
	DD	imagerel $unwind$z900_subtract_bfp_short_reg
$pdata$z900_test_data_class_bfp_ext DD imagerel $LN19
	DD	imagerel $LN19+759
	DD	imagerel $unwind$z900_test_data_class_bfp_ext
$pdata$z900_test_data_class_bfp_long DD imagerel $LN18
	DD	imagerel $LN18+595
	DD	imagerel $unwind$z900_test_data_class_bfp_long
$pdata$z900_test_data_class_bfp_short DD imagerel $LN18
	DD	imagerel $LN18+594
	DD	imagerel $unwind$z900_test_data_class_bfp_short
$pdata$z900_convert_bfp_long_to_float_long_reg DD imagerel $LN15
	DD	imagerel $LN15+466
	DD	imagerel $unwind$z900_convert_bfp_long_to_float_long_reg
$pdata$z900_convert_bfp_short_to_float_long_reg DD imagerel $LN15
	DD	imagerel $LN15+552
	DD	imagerel $unwind$z900_convert_bfp_short_to_float_long_reg
$pdata$z900_convert_float_long_to_bfp_long_reg DD imagerel $LN15
	DD	imagerel $LN15+575
	DD	imagerel $unwind$z900_convert_float_long_to_bfp_long_reg
$pdata$z900_convert_float_long_to_bfp_short_reg DD imagerel $LN15
	DD	imagerel $LN15+583
	DD	imagerel $unwind$z900_convert_float_long_to_bfp_short_reg
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck2 DD imagerel $LN18
	DD	imagerel $LN18+485
	DD	imagerel $unwind$z900_per3_zero_xcheck2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+157
	DD	imagerel $unwind$z900_vfetch8
pdata	ENDS
pdata	SEGMENT
$pdata$z900_BFP_RM_check DD imagerel z900_BFP_RM_check
	DD	imagerel z900_BFP_RM_check+161
	DD	imagerel $unwind$z900_BFP_RM_check
$pdata$z900_float128_cc_quiet DD imagerel z900_float128_cc_quiet
	DD	imagerel z900_float128_cc_quiet+458
	DD	imagerel $unwind$z900_float128_cc_quiet
$pdata$z900_float128_compare DD imagerel z900_float128_compare
	DD	imagerel z900_float128_compare+226
	DD	imagerel $unwind$z900_float128_compare
$pdata$z900_float128_signaling_compare DD imagerel z900_float128_signaling_compare
	DD	imagerel z900_float128_signaling_compare+349
	DD	imagerel $unwind$z900_float128_signaling_compare
$pdata$z900_float64_cc_quiet DD imagerel z900_float64_cc_quiet
	DD	imagerel z900_float64_cc_quiet+250
	DD	imagerel $unwind$z900_float64_cc_quiet
$pdata$z900_float64_compare DD imagerel z900_float64_compare
	DD	imagerel z900_float64_compare+133
	DD	imagerel $unwind$z900_float64_compare
$pdata$z900_float64_signaling_compare DD imagerel z900_float64_signaling_compare
	DD	imagerel z900_float64_signaling_compare+223
	DD	imagerel $unwind$z900_float64_signaling_compare
$pdata$z900_float32_cc_quiet DD imagerel z900_float32_cc_quiet
	DD	imagerel z900_float32_cc_quiet+174
	DD	imagerel $unwind$z900_float32_cc_quiet
$pdata$z900_float32_compare DD imagerel z900_float32_compare
	DD	imagerel z900_float32_compare+127
	DD	imagerel $unwind$z900_float32_compare
$pdata$z900_float32_signaling_compare DD imagerel z900_float32_signaling_compare
	DD	imagerel z900_float32_signaling_compare+153
	DD	imagerel $unwind$z900_float32_signaling_compare
pdata	ENDS
_DATA	SEGMENT
$SG198360 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1099', 00H
	ORG $+5
$SG198384 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1125', 00H
	ORG $+5
$SG198407 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1154', 00H
	ORG $+5
$SG198432 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1178', 00H
	ORG $+5
$SG198464 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1204', 00H
	ORG $+5
$SG198500 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1243', 00H
	ORG $+5
$SG198535 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1282', 00H
	ORG $+5
$SG198569 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1320', 00H
	ORG $+5
$SG198604 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1359', 00H
	ORG $+5
$SG198635 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1397', 00H
	ORG $+5
$SG198665 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1425', 00H
	ORG $+5
$SG198694 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1452', 00H
	ORG $+5
$SG198722 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1477', 00H
	ORG $+5
$SG198751 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1503', 00H
	ORG $+5
$SG198779 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1528', 00H
	ORG $+5
$SG198809 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1554', 00H
	ORG $+5
$SG198838 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1579', 00H
	ORG $+5
$SG198866 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1604', 00H
	ORG $+5
$SG198895 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1630', 00H
	ORG $+5
$SG198920 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1676', 00H
	ORG $+5
$SG198948 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1712', 00H
	ORG $+5
$SG198976 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1752', 00H
	ORG $+5
$SG199005 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1795', 00H
	ORG $+5
$SG199034 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1838', 00H
	ORG $+5
$SG199064 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1887', 00H
	ORG $+5
$SG199096 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:1961', 00H
	ORG $+5
$SG199135 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2036', 00H
	ORG $+5
$SG199173 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2107', 00H
	ORG $+5
$SG199211 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2179', 00H
	ORG $+5
$SG199250 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2254', 00H
	ORG $+5
$SG199288 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2328', 00H
	ORG $+5
$SG199322 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2417', 00H
	ORG $+5
$SG199346 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2445', 00H
	ORG $+5
$SG199371 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2475', 00H
	ORG $+5
$SG199396 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2507', 00H
	ORG $+5
$SG199422 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2539', 00H
	ORG $+5
$SG199449 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2577', 00H
	ORG $+5
$SG199477 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2634', 00H
	ORG $+5
$SG199512 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2684', 00H
	ORG $+5
$SG199545 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2733', 00H
	ORG $+5
$SG199578 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2782', 00H
	ORG $+5
$SG199613 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2833', 00H
	ORG $+5
$SG199646 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2883', 00H
	ORG $+5
$SG199680 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2931', 00H
	ORG $+5
$SG199714 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:2971', 00H
	ORG $+5
$SG199747 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3012', 00H
	ORG $+5
$SG199779 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3053', 00H
	ORG $+5
$SG199812 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3094', 00H
	ORG $+5
$SG199841 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3134', 00H
	ORG $+5
$SG199872 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3166', 00H
	ORG $+5
$SG199900 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3198', 00H
	ORG $+5
$SG199928 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3231', 00H
	ORG $+5
$SG199956 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3269', 00H
	ORG $+5
$SG199984 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3307', 00H
	ORG $+5
$SG200013 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3359', 00H
	ORG $+5
$SG200042 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3390', 00H
	ORG $+5
$SG200067 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3419', 00H
	ORG $+5
$SG200097 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3451', 00H
	ORG $+5
$SG200123 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3481', 00H
	ORG $+5
$SG200153 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3513', 00H
	ORG $+5
$SG200180 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3542', 00H
	ORG $+5
$SG200206 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3561', 00H
	ORG $+5
$SG200230 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3579', 00H
	ORG $+5
$SG200254 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3597', 00H
	ORG $+5
$SG200280 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3616', 00H
	ORG $+5
$SG200304 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3634', 00H
	ORG $+5
$SG200328 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3653', 00H
	ORG $+5
$SG200354 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3673', 00H
	ORG $+5
$SG200378 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3691', 00H
	ORG $+5
$SG200403 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3734', 00H
	ORG $+5
$SG200438 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3797', 00H
	ORG $+5
$SG200475 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3861', 00H
	ORG $+5
$SG200514 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3922', 00H
	ORG $+5
$SG200549 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:3964', 00H
	ORG $+5
$SG200586 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4020', 00H
	ORG $+5
$SG200620 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4070', 00H
	ORG $+5
$SG200652 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4109', 00H
	ORG $+5
$SG200685 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4151', 00H
	ORG $+5
$SG200721 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4206', 00H
	ORG $+5
$SG200754 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4256', 00H
	ORG $+5
$SG200786 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4295', 00H
	ORG $+5
$SG200819 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4333', 00H
	ORG $+5
$SG200856 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4373', 00H
	ORG $+5
$SG200889 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4411', 00H
	ORG $+5
$SG200926 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4451', 00H
	ORG $+5
$SG200959 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4489', 00H
	ORG $+5
$SG200998 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4536', 00H
	ORG $+5
$SG201033 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4581', 00H
	ORG $+5
$SG201072 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4628', 00H
	ORG $+5
$SG201103 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4673', 00H
	ORG $+5
$SG201133 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4706', 00H
	ORG $+5
$SG201165 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4740', 00H
	ORG $+5
$SG201193 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4772', 00H
	ORG $+5
$SG201225 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4806', 00H
	ORG $+5
$SG201258 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4839', 00H
	ORG $+5
$SG201294 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4878', 00H
	ORG $+5
$SG201329 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4917', 00H
	ORG $+5
$SG201363 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4955', 00H
	ORG $+5
$SG201398 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:4994', 00H
	ORG $+5
$SG201428 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:5033', 00H
	ORG $+5
$SG201454 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:5052', 00H
	ORG $+5
$SG201480 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:5071', 00H
	ORG $+5
$SG201519 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:5108', 00H
	ORG $+5
$SG201582 DB	'C:\papa\MyGit\hyperion-zvector\ieee.c:5338', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8_full DD 032319H
	DD	07010c214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck2 DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch8 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch8_full DD 032219H
	DD	0700fc213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch8 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch8_full DD 032219H
	DD	0700fc213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_float_long_to_bfp_short_reg
	DD	018H
	DD	0235H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_float_long_to_bfp_long_reg
	DD	018H
	DD	022dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_bfp_short_to_float_long_reg
	DD	018H
	DD	0216H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_bfp_long_to_float_long_reg
	DD	018H
	DD	01c0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_data_class_bfp_ext
	DD	01aH
	DD	02e3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_subtract_bfp_ext_reg
	DD	01dH
	DD	0584H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_squareroot_bfp_ext_reg
	DD	01dH
	DD	03fbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_multiply_bfp_long_to_ext_reg
	DD	01dH
	DD	0498H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_multiply_bfp_long_to_ext
	DD	01dH
	DD	0538H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_multiply_bfp_ext_reg
	DD	01dH
	DD	041dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_rounded_bfp_ext_to_short_reg
	DD	01dH
	DD	0507H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_rounded_bfp_ext_to_long_reg
	DD	01dH
	DD	050bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_positive_bfp_ext_reg
	DD	018H
	DD	0322H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_negative_bfp_ext_reg
	DD	018H
	DD	0322H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_lengthened_bfp_short_to_ext_reg
	DD	01aH
	DD	032dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_lengthened_bfp_short_to_ext
	DD	01aH
	DD	03cfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_lengthened_bfp_long_to_ext_reg
	DD	01aH
	DD	033dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_lengthened_bfp_long_to_ext
	DD	01aH
	DD	03e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_fp_int_bfp_ext_reg
	DD	01dH
	DD	0436H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_complement_bfp_ext_reg
	DD	018H
	DD	0322H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_and_test_bfp_ext_reg
	DD	01aH
	DD	043eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_divide_integer_bfp_long_reg
	DD	01dH
	DD	0ca6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_divide_bfp_ext_reg
	DD	01dH
	DD	046fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_fix64_to_bfp_ext_reg
	DD	01aH
	DD	0333H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_fix32_to_bfp_ext_reg
	DD	01aH
	DD	0330H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_bfp_ext_to_fix64_reg
	DD	01dH
	DD	0582H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_bfp_ext_to_fix32_reg
	DD	01dH
	DD	0576H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_bfp_ext_reg
	DD	01dH
	DD	0352H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_and_signal_bfp_ext_reg
	DD	01dH
	DD	0352H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_add_bfp_ext_reg
	DD	01dH
	DD	0547H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_bfp_ext_to_u64_reg
	DD	01dH
	DD	0601H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_bfp_ext_to_u32_reg
	DD	01dH
	DD	05f9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_u64_to_bfp_ext_reg
	DD	01aH
	DD	02d8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_u32_to_bfp_ext_reg
	DD	01aH
	DD	02d5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_convert_float_long_to_bfp_short_reg
	DD	018H
	DD	01d7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_convert_float_long_to_bfp_long_reg
	DD	018H
	DD	01cfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_convert_bfp_short_to_float_long_reg
	DD	018H
	DD	01b8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_convert_bfp_long_to_float_long_reg
	DD	018H
	DD	016eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_test_data_class_bfp_ext
	DD	01aH
	DD	0235H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_subtract_bfp_ext_reg
	DD	01dH
	DD	04e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_squareroot_bfp_ext_reg
	DD	01dH
	DD	035fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_multiply_bfp_long_to_ext_reg
	DD	01dH
	DD	03fcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_multiply_bfp_long_to_ext
	DD	01dH
	DD	0473H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_multiply_bfp_ext_reg
	DD	01dH
	DD	0381H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_rounded_bfp_ext_to_short_reg
	DD	01dH
	DD	037cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_rounded_bfp_ext_to_long_reg
	DD	01dH
	DD	037dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_positive_bfp_ext_reg
	DD	018H
	DD	02a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_negative_bfp_ext_reg
	DD	018H
	DD	02a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_lengthened_bfp_short_to_ext_reg
	DD	01aH
	DD	0291H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_lengthened_bfp_short_to_ext
	DD	01aH
	DD	030aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_lengthened_bfp_long_to_ext_reg
	DD	01aH
	DD	02a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_lengthened_bfp_long_to_ext
	DD	01aH
	DD	031bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_fp_int_bfp_ext_reg
	DD	01dH
	DD	037aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_complement_bfp_ext_reg
	DD	018H
	DD	02a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_and_test_bfp_ext_reg
	DD	01aH
	DD	03a2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_divide_integer_bfp_long_reg
	DD	01dH
	DD	0c0aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_divide_bfp_ext_reg
	DD	01dH
	DD	03d3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_convert_fix32_to_bfp_ext_reg
	DD	01aH
	DD	0260H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_convert_bfp_ext_to_fix32_reg
	DD	01dH
	DD	04baH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_compare_bfp_ext_reg
	DD	01dH
	DD	02b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_compare_and_signal_bfp_ext_reg
	DD	01dH
	DD	02b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_add_bfp_ext_reg
	DD	01dH
	DD	04abH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_test_data_class_bfp_ext
	DD	01aH
	DD	0228H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_subtract_bfp_ext_reg
	DD	01dH
	DD	04e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_squareroot_bfp_ext_reg
	DD	01dH
	DD	035fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_multiply_bfp_long_to_ext_reg
	DD	01dH
	DD	03fcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_multiply_bfp_long_to_ext
	DD	01dH
	DD	0466H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_multiply_bfp_ext_reg
	DD	01dH
	DD	0381H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_rounded_bfp_ext_to_short_reg
	DD	01dH
	DD	046bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_rounded_bfp_ext_to_long_reg
	DD	01dH
	DD	046fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_positive_bfp_ext_reg
	DD	018H
	DD	02a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_negative_bfp_ext_reg
	DD	018H
	DD	02a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_lengthened_bfp_short_to_ext_reg
	DD	01aH
	DD	0291H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_lengthened_bfp_short_to_ext
	DD	01aH
	DD	02fdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_lengthened_bfp_long_to_ext_reg
	DD	01aH
	DD	02a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_lengthened_bfp_long_to_ext
	DD	01aH
	DD	030eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_fp_int_bfp_ext_reg
	DD	01dH
	DD	039aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_complement_bfp_ext_reg
	DD	018H
	DD	02a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_and_test_bfp_ext_reg
	DD	01aH
	DD	03a2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_divide_integer_bfp_long_reg
	DD	01dH
	DD	0c0aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_divide_bfp_ext_reg
	DD	01dH
	DD	03d3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_fix32_to_bfp_ext_reg
	DD	01aH
	DD	0294H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_bfp_ext_to_fix32_reg
	DD	01dH
	DD	04daH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_bfp_ext_reg
	DD	01dH
	DD	02b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_and_signal_bfp_ext_reg
	DD	01dH
	DD	02b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_add_bfp_ext_reg
	DD	01dH
	DD	04abH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_bfp_ext_to_u64_reg
	DD	01dH
	DD	0565H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_bfp_ext_to_u32_reg
	DD	01dH
	DD	055dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_u64_to_bfp_ext_reg
	DD	01aH
	DD	023cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_u32_to_bfp_ext_reg
	DD	01aH
	DD	0239H
voltbl	ENDS
xdata	SEGMENT
$unwind$s370_convert_u32_to_bfp_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s370_convert_u32_to_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_convert_u32_to_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_convert_u64_to_bfp_ext_reg DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s370_convert_u64_to_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_convert_u64_to_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s370_convert_bfp_ext_to_u32_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s370_convert_bfp_long_to_u32_reg DD 010e01H
	DD	0c20eH
$unwind$s370_convert_bfp_short_to_u32_reg DD 010e01H
	DD	0c20eH
$unwind$s370_convert_bfp_ext_to_u64_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s370_convert_bfp_long_to_u64_reg DD 010e01H
	DD	0c20eH
$unwind$s370_convert_bfp_short_to_u64_reg DD 010e01H
	DD	0c20eH
$unwind$s370_add_bfp_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_add_bfp_long DD 010e01H
	DD	0e20eH
$unwind$s370_add_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$s370_add_bfp_short DD 010e01H
	DD	0c20eH
$unwind$s370_add_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s370_compare_and_signal_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s370_compare_and_signal_bfp_long DD 010e01H
	DD	0a20eH
$unwind$s370_compare_and_signal_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_compare_and_signal_bfp_short DD 010e01H
	DD	0820eH
$unwind$s370_compare_and_signal_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_compare_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s370_compare_bfp_long DD 010e01H
	DD	0a20eH
$unwind$s370_compare_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_compare_bfp_short DD 010e01H
	DD	0820eH
$unwind$s370_compare_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_convert_bfp_ext_to_fix32_reg DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_convert_bfp_long_to_fix32_reg DD 010e01H
	DD	0a20eH
$unwind$s370_convert_bfp_short_to_fix32_reg DD 010e01H
	DD	0a20eH
$unwind$s370_convert_fix32_to_bfp_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s370_convert_fix32_to_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_convert_fix32_to_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_divide_bfp_ext_reg DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s370_divide_bfp_long DD 010e01H
	DD	0c20eH
$unwind$s370_divide_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_divide_bfp_short DD 010e01H
	DD	0a20eH
$unwind$s370_divide_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_divide_integer_bfp_long_reg DD 042519H
	DD	0330113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$s370_divide_integer_bfp_short_reg DD 021101H
	DD	0110111H
$unwind$s370_load_and_test_bfp_ext_reg DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s370_load_and_test_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_load_and_test_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_complement_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s370_load_complement_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_load_complement_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_fp_int_bfp_ext_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s370_load_fp_int_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_load_fp_int_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_lengthened_bfp_long_to_ext DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s370_load_lengthened_bfp_long_to_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s370_load_lengthened_bfp_short_to_ext DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s370_load_lengthened_bfp_short_to_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s370_load_lengthened_bfp_short_to_long DD 010e01H
	DD	0820eH
$unwind$s370_load_lengthened_bfp_short_to_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_negative_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s370_load_negative_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_load_negative_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_positive_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s370_load_positive_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_load_positive_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_rounded_bfp_ext_to_long_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s370_load_rounded_bfp_ext_to_short_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s370_load_rounded_bfp_long_to_short_reg DD 010e01H
	DD	0a20eH
$unwind$s370_multiply_add_bfp_long DD 010e01H
	DD	0c20eH
$unwind$s370_multiply_add_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$s370_multiply_add_bfp_short DD 010e01H
	DD	0a20eH
$unwind$s370_multiply_add_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s370_multiply_bfp_ext_reg DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s370_multiply_bfp_long DD 010e01H
	DD	0c20eH
$unwind$s370_multiply_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_multiply_bfp_long_to_ext DD 042519H
	DD	01d0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s370_multiply_bfp_long_to_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_multiply_bfp_short DD 010e01H
	DD	0a20eH
$unwind$s370_multiply_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_multiply_bfp_short_to_long DD 010e01H
	DD	0c20eH
$unwind$s370_multiply_bfp_short_to_long_reg DD 010e01H
	DD	0a20eH
$unwind$s370_multiply_subtract_bfp_long DD 010e01H
	DD	0e20eH
$unwind$s370_multiply_subtract_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$s370_multiply_subtract_bfp_short DD 010e01H
	DD	0a20eH
$unwind$s370_multiply_subtract_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s370_squareroot_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s370_squareroot_bfp_long DD 010e01H
	DD	0a20eH
$unwind$s370_squareroot_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_squareroot_bfp_short DD 010e01H
	DD	0820eH
$unwind$s370_squareroot_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s370_subtract_bfp_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_subtract_bfp_long DD 010e01H
	DD	0e20eH
$unwind$s370_subtract_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$s370_subtract_bfp_short DD 010e01H
	DD	0c20eH
$unwind$s370_subtract_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s370_test_data_class_bfp_ext DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s370_test_data_class_bfp_long DD 010e01H
	DD	0820eH
$unwind$s370_test_data_class_bfp_short DD 010e01H
	DD	0820eH
$unwind$ieee_trap DD 010d01H
	DD	0420dH
$unwind$ieee_cond_trap DD 010d01H
	DD	0820dH
$unwind$float128_class DD 030b01H
	DD	07007a20bH
	DD	06006H
$unwind$float64_class DD 010901H
	DD	08209H
$unwind$float32_class DD 010801H
	DD	08208H
$unwind$ieee_exception_test_oux DD 010901H
	DD	02209H
$unwind$s370_BFP_RM_check DD 010d01H
	DD	0420dH
$unwind$s370_float128_cc_quiet DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$s370_float128_compare DD 031001H
	DD	0700cc210H
	DD	0600bH
$unwind$s370_float128_signaling_compare DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$s370_float64_cc_quiet DD 010e01H
	DD	0620eH
$unwind$s370_float64_compare DD 010e01H
	DD	0420eH
$unwind$s370_float64_signaling_compare DD 010e01H
	DD	0420eH
$unwind$s370_float32_cc_quiet DD 010c01H
	DD	0620cH
$unwind$s370_float32_compare DD 010c01H
	DD	0420cH
$unwind$s370_float32_signaling_compare DD 010c01H
	DD	0420cH
$unwind$get_lbfp DD 010e01H
	DD	0220eH
$unwind$get_sbfp DD 010e01H
	DD	0220eH
$unwind$put_lbfp DD 010e01H
	DD	0220eH
$unwind$put_sbfp DD 010e01H
	DD	0220eH
$unwind$s390_add_bfp_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s390_add_bfp_long DD 010e01H
	DD	0e20eH
$unwind$s390_add_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$s390_add_bfp_short DD 010e01H
	DD	0c20eH
$unwind$s390_add_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s390_compare_and_signal_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s390_compare_and_signal_bfp_long DD 010e01H
	DD	0a20eH
$unwind$s390_compare_and_signal_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s390_compare_and_signal_bfp_short DD 010e01H
	DD	0820eH
$unwind$s390_compare_and_signal_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_compare_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s390_compare_bfp_long DD 010e01H
	DD	0a20eH
$unwind$s390_compare_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s390_compare_bfp_short DD 010e01H
	DD	0820eH
$unwind$s390_compare_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_convert_bfp_ext_to_fix32_reg DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s390_convert_bfp_long_to_fix32_reg DD 010e01H
	DD	0a20eH
$unwind$s390_convert_bfp_short_to_fix32_reg DD 010e01H
	DD	0a20eH
$unwind$s390_convert_fix32_to_bfp_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s390_convert_fix32_to_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s390_convert_fix32_to_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_divide_bfp_ext_reg DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s390_divide_bfp_long DD 010e01H
	DD	0c20eH
$unwind$s390_divide_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s390_divide_bfp_short DD 010e01H
	DD	0a20eH
$unwind$s390_divide_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_divide_integer_bfp_long_reg DD 042519H
	DD	0330113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$s390_divide_integer_bfp_short_reg DD 021101H
	DD	0110111H
$unwind$s390_load_and_test_bfp_ext_reg DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s390_load_and_test_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s390_load_and_test_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_load_complement_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s390_load_complement_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s390_load_complement_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_load_fp_int_bfp_ext_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s390_load_fp_int_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s390_load_fp_int_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_load_lengthened_bfp_long_to_ext DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s390_load_lengthened_bfp_long_to_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s390_load_lengthened_bfp_short_to_ext DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s390_load_lengthened_bfp_short_to_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s390_load_lengthened_bfp_short_to_long DD 010e01H
	DD	0820eH
$unwind$s390_load_lengthened_bfp_short_to_long_reg DD 010e01H
	DD	0820eH
$unwind$s390_load_negative_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s390_load_negative_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s390_load_negative_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_load_positive_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s390_load_positive_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s390_load_positive_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_load_rounded_bfp_ext_to_long_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s390_load_rounded_bfp_ext_to_short_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s390_load_rounded_bfp_long_to_short_reg DD 010e01H
	DD	0a20eH
$unwind$s390_multiply_add_bfp_long DD 010e01H
	DD	0c20eH
$unwind$s390_multiply_add_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$s390_multiply_add_bfp_short DD 010e01H
	DD	0a20eH
$unwind$s390_multiply_add_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s390_multiply_bfp_ext_reg DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s390_multiply_bfp_long DD 010e01H
	DD	0c20eH
$unwind$s390_multiply_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$s390_multiply_bfp_long_to_ext DD 042519H
	DD	01d0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s390_multiply_bfp_long_to_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s390_multiply_bfp_short DD 010e01H
	DD	0a20eH
$unwind$s390_multiply_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_multiply_bfp_short_to_long DD 010e01H
	DD	0c20eH
$unwind$s390_multiply_bfp_short_to_long_reg DD 010e01H
	DD	0a20eH
$unwind$s390_multiply_subtract_bfp_long DD 010e01H
	DD	0e20eH
$unwind$s390_multiply_subtract_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$s390_multiply_subtract_bfp_short DD 010e01H
	DD	0a20eH
$unwind$s390_multiply_subtract_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s390_squareroot_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s390_squareroot_bfp_long DD 010e01H
	DD	0a20eH
$unwind$s390_squareroot_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$s390_squareroot_bfp_short DD 010e01H
	DD	0820eH
$unwind$s390_squareroot_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$s390_subtract_bfp_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s390_subtract_bfp_long DD 010e01H
	DD	0e20eH
$unwind$s390_subtract_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$s390_subtract_bfp_short DD 010e01H
	DD	0c20eH
$unwind$s390_subtract_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$s390_test_data_class_bfp_ext DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s390_test_data_class_bfp_long DD 010e01H
	DD	0820eH
$unwind$s390_test_data_class_bfp_short DD 010e01H
	DD	0820eH
$unwind$s390_convert_bfp_long_to_float_long_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$s390_convert_bfp_short_to_float_long_reg DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s390_convert_float_long_to_bfp_long_reg DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$s390_convert_float_long_to_bfp_short_reg DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$s390_BFP_RM_check DD 010d01H
	DD	0420dH
$unwind$s390_float128_cc_quiet DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$s390_float128_compare DD 031001H
	DD	0700cc210H
	DD	0600bH
$unwind$s390_float128_signaling_compare DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$s390_float64_cc_quiet DD 010e01H
	DD	0620eH
$unwind$s390_float64_compare DD 010e01H
	DD	0420eH
$unwind$s390_float64_signaling_compare DD 010e01H
	DD	0420eH
$unwind$s390_float32_cc_quiet DD 010c01H
	DD	0620cH
$unwind$s390_float32_compare DD 010c01H
	DD	0420cH
$unwind$s390_float32_signaling_compare DD 010c01H
	DD	0420cH
$unwind$cnvt_bfp_to_hfp DD 011201H
	DD	08212H
$unwind$cnvt_hfp_to_bfp DD 011701H
	DD	08217H
$unwind$z900_convert_u32_to_bfp_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$z900_convert_u32_to_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_convert_u32_to_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_convert_u64_to_bfp_ext_reg DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_convert_u64_to_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_convert_u64_to_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$z900_convert_bfp_ext_to_u32_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$z900_convert_bfp_long_to_u32_reg DD 010e01H
	DD	0c20eH
$unwind$z900_convert_bfp_short_to_u32_reg DD 010e01H
	DD	0c20eH
$unwind$z900_convert_bfp_ext_to_u64_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$z900_convert_bfp_long_to_u64_reg DD 010e01H
	DD	0c20eH
$unwind$z900_convert_bfp_short_to_u64_reg DD 010e01H
	DD	0c20eH
$unwind$z900_add_bfp_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_add_bfp_long DD 010e01H
	DD	0e20eH
$unwind$z900_add_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$z900_add_bfp_short DD 010e01H
	DD	0c20eH
$unwind$z900_add_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$z900_compare_and_signal_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$z900_compare_and_signal_bfp_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_and_signal_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_compare_and_signal_bfp_short DD 010e01H
	DD	0a20eH
$unwind$z900_compare_and_signal_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_compare_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$z900_compare_bfp_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_compare_bfp_short DD 010e01H
	DD	0a20eH
$unwind$z900_compare_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_convert_bfp_ext_to_fix32_reg DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_bfp_ext_to_fix64_reg DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_bfp_long_to_fix32_reg DD 010e01H
	DD	0a20eH
$unwind$z900_convert_bfp_long_to_fix64_reg DD 010e01H
	DD	0c20eH
$unwind$z900_convert_bfp_short_to_fix32_reg DD 010e01H
	DD	0a20eH
$unwind$z900_convert_bfp_short_to_fix64_reg DD 010e01H
	DD	0a20eH
$unwind$z900_convert_fix32_to_bfp_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$z900_convert_fix32_to_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_convert_fix32_to_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_convert_fix64_to_bfp_ext_reg DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_convert_fix64_to_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_convert_fix64_to_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$z900_divide_bfp_ext_reg DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_divide_bfp_long DD 010e01H
	DD	0c20eH
$unwind$z900_divide_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_divide_bfp_short DD 010e01H
	DD	0a20eH
$unwind$z900_divide_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_divide_integer_bfp_long_reg DD 042519H
	DD	0330113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$z900_divide_integer_bfp_short_reg DD 021101H
	DD	0110111H
$unwind$z900_load_and_test_bfp_ext_reg DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_load_and_test_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_load_and_test_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_complement_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$z900_load_complement_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_load_complement_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_fp_int_bfp_ext_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$z900_load_fp_int_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_load_fp_int_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_lengthened_bfp_long_to_ext DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$z900_load_lengthened_bfp_long_to_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$z900_load_lengthened_bfp_short_to_ext DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_load_lengthened_bfp_short_to_ext_reg DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$z900_load_lengthened_bfp_short_to_long DD 010e01H
	DD	0a20eH
$unwind$z900_load_lengthened_bfp_short_to_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_negative_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$z900_load_negative_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_load_negative_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_positive_bfp_ext_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$z900_load_positive_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_load_positive_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_rounded_bfp_ext_to_long_reg DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$z900_load_rounded_bfp_ext_to_short_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$z900_load_rounded_bfp_long_to_short_reg DD 010e01H
	DD	0a20eH
$unwind$z900_multiply_add_bfp_long DD 010e01H
	DD	0e20eH
$unwind$z900_multiply_add_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$z900_multiply_add_bfp_short DD 010e01H
	DD	0c20eH
$unwind$z900_multiply_add_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$z900_multiply_bfp_ext_reg DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_multiply_bfp_long DD 010e01H
	DD	0c20eH
$unwind$z900_multiply_bfp_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_multiply_bfp_long_to_ext DD 042519H
	DD	01d0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$z900_multiply_bfp_long_to_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_multiply_bfp_short DD 010e01H
	DD	0a20eH
$unwind$z900_multiply_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_multiply_bfp_short_to_long DD 010e01H
	DD	0c20eH
$unwind$z900_multiply_bfp_short_to_long_reg DD 010e01H
	DD	0a20eH
$unwind$z900_multiply_subtract_bfp_long DD 010e01H
	DD	0e20eH
$unwind$z900_multiply_subtract_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$z900_multiply_subtract_bfp_short DD 010e01H
	DD	0c20eH
$unwind$z900_multiply_subtract_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$z900_squareroot_bfp_ext_reg DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$z900_squareroot_bfp_long DD 010e01H
	DD	0a20eH
$unwind$z900_squareroot_bfp_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_squareroot_bfp_short DD 010e01H
	DD	0a20eH
$unwind$z900_squareroot_bfp_short_reg DD 010e01H
	DD	0820eH
$unwind$z900_subtract_bfp_ext_reg DD 042519H
	DD	01b0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_subtract_bfp_long DD 010e01H
	DD	0e20eH
$unwind$z900_subtract_bfp_long_reg DD 010e01H
	DD	0c20eH
$unwind$z900_subtract_bfp_short DD 010e01H
	DD	0c20eH
$unwind$z900_subtract_bfp_short_reg DD 010e01H
	DD	0a20eH
$unwind$z900_test_data_class_bfp_ext DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_test_data_class_bfp_long DD 010e01H
	DD	0a20eH
$unwind$z900_test_data_class_bfp_short DD 010e01H
	DD	0820eH
$unwind$z900_convert_bfp_long_to_float_long_reg DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$z900_convert_bfp_short_to_float_long_reg DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_convert_float_long_to_bfp_long_reg DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$z900_convert_float_long_to_bfp_short_reg DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$z900_BFP_RM_check DD 010d01H
	DD	0420dH
$unwind$z900_float128_cc_quiet DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$z900_float128_compare DD 031001H
	DD	0700cc210H
	DD	0600bH
$unwind$z900_float128_signaling_compare DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$z900_float64_cc_quiet DD 010e01H
	DD	0620eH
$unwind$z900_float64_compare DD 010e01H
	DD	0420eH
$unwind$z900_float64_signaling_compare DD 010e01H
	DD	0420eH
$unwind$z900_float32_cc_quiet DD 010c01H
	DD	0620cH
$unwind$z900_float32_compare DD 010c01H
	DD	0420cH
$unwind$z900_float32_signaling_compare DD 010c01H
	DD	0420cH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
z900_float32_signaling_compare PROC

; 689  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 690  :     if (FLOAT32_ISNAN( op1 ) ||

  0000c	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00010	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00015	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0001a	75 0d		 jne	 SHORT $LN4@z900_float
  0001c	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00020	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00025	85 c0		 test	 eax, eax
  00027	75 1d		 jne	 SHORT $LN3@z900_float
$LN4@z900_float:
  00029	8b 44 24 38	 mov	 eax, DWORD PTR op2$[rsp]
  0002d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00032	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00037	75 4e		 jne	 SHORT $LN2@z900_float
  00039	8b 44 24 38	 mov	 eax, DWORD PTR op2$[rsp]
  0003d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00042	85 c0		 test	 eax, eax
  00044	74 41		 je	 SHORT $LN2@z900_float
$LN3@z900_float:

; 691  :         FLOAT32_ISNAN( op2 ))
; 692  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00046	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0004b	8b c0		 mov	 eax, eax
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00053	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00060	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00064	83 c8 10	 or	 eax, 16
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0006d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00076	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0007c	45 8b c0	 mov	 r8d, r8d
  0007f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00083	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@z900_float:

; 693  :     return ARCH_DEP( float32_cc_quiet )( op1, op2 );

  00087	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  0008f	e8 00 00 00 00	 call	 z900_float32_cc_quiet

; 694  : }

  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	c3		 ret	 0
z900_float32_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
z900_float32_compare PROC

; 681  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 682  :     if (f32_isSignalingNaN( op1 ) ||

  0000c	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00010	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	75 10		 jne	 SHORT $LN3@z900_float
  0001c	8b 4c 24 38	 mov	 ecx, DWORD PTR op2$[rsp]
  00020	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 41		 je	 SHORT $LN2@z900_float
$LN3@z900_float:

; 683  :         f32_isSignalingNaN( op2 ))
; 684  :         softfloat_raiseFlags( softfloat_flag_invalid );

  0002c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00031	8b c0		 mov	 eax, eax
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00039	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00042	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00046	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004a	83 c8 10	 or	 eax, 16
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00053	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005c	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00062	45 8b c0	 mov	 r8d, r8d
  00065	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00069	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@z900_float:

; 685  :     return ARCH_DEP( float32_cc_quiet )( op1, op2 );

  0006d	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00071	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00075	e8 00 00 00 00	 call	 z900_float32_cc_quiet

; 686  : }

  0007a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007e	c3		 ret	 0
z900_float32_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv81 = 32
tv83 = 36
tv84 = 40
op1$ = 64
op2$ = 72
z900_float32_cc_quiet PROC

; 673  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 674  :     return FLOAT32_ISNAN( op1      ) ||

  0000c	8b 44 24 40	 mov	 eax, DWORD PTR op1$[rsp]
  00010	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00015	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0001a	75 0d		 jne	 SHORT $LN3@z900_float
  0001c	8b 44 24 40	 mov	 eax, DWORD PTR op1$[rsp]
  00020	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00025	85 c0		 test	 eax, eax
  00027	75 73		 jne	 SHORT $LN5@z900_float
$LN3@z900_float:
  00029	8b 44 24 48	 mov	 eax, DWORD PTR op2$[rsp]
  0002d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00032	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00037	75 0d		 jne	 SHORT $LN4@z900_float
  00039	8b 44 24 48	 mov	 eax, DWORD PTR op2$[rsp]
  0003d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00042	85 c0		 test	 eax, eax
  00044	75 56		 jne	 SHORT $LN5@z900_float
$LN4@z900_float:
  00046	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  0004a	8b 4c 24 40	 mov	 ecx, DWORD PTR op1$[rsp]
  0004e	e8 00 00 00 00	 call	 f32_eq
  00053	0f b6 c0	 movzx	 eax, al
  00056	85 c0		 test	 eax, eax
  00058	74 0a		 je	 SHORT $LN8@z900_float
  0005a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  00062	eb 2e		 jmp	 SHORT $LN9@z900_float
$LN8@z900_float:
  00064	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00068	8b 4c 24 40	 mov	 ecx, DWORD PTR op1$[rsp]
  0006c	e8 00 00 00 00	 call	 f32_lt_quiet
  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	74 0a		 je	 SHORT $LN6@z900_float
  00078	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00080	eb 08		 jmp	 SHORT $LN7@z900_float
$LN6@z900_float:
  00082	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv81[rsp], 2
$LN7@z900_float:
  0008a	8b 44 24 20	 mov	 eax, DWORD PTR tv81[rsp]
  0008e	89 44 24 24	 mov	 DWORD PTR tv83[rsp], eax
$LN9@z900_float:
  00092	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  00096	89 44 24 28	 mov	 DWORD PTR tv84[rsp], eax
  0009a	eb 08		 jmp	 SHORT $LN10@z900_float
$LN5@z900_float:
  0009c	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv84[rsp], 3
$LN10@z900_float:
  000a4	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv84[rsp]

; 675  :            FLOAT32_ISNAN(      op2 ) ? 3 :
; 676  :            f32_eq(        op1, op2 ) ? 0 :
; 677  :            f32_lt_quiet(  op1, op2 ) ? 1 : 2;
; 678  : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
z900_float32_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
z900_float64_signaling_compare PROC

; 665  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 666  :     if (FLOAT64_ISNAN( op1 ) ||

  0000e	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 23 c8	 and	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	75 1a		 jne	 SHORT $LN4@z900_float
  00032	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00041	48 23 c8	 and	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 85 c0	 test	 rax, rax
  0004a	75 3e		 jne	 SHORT $LN3@z900_float
$LN4@z900_float:
  0004c	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00056	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  0005b	48 23 c8	 and	 rcx, rax
  0005e	48 8b c1	 mov	 rax, rcx
  00061	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0006b	48 3b c1	 cmp	 rax, rcx
  0006e	75 5b		 jne	 SHORT $LN2@z900_float
  00070	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0007a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  0007f	48 23 c8	 and	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 85 c0	 test	 rax, rax
  00088	74 41		 je	 SHORT $LN2@z900_float
$LN3@z900_float:

; 667  :         FLOAT64_ISNAN( op2 ))
; 668  :         softfloat_raiseFlags( softfloat_flag_invalid );

  0008a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0008f	8b c0		 mov	 eax, eax
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00097	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000a0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a8	83 c8 10	 or	 eax, 16
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000ba	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  000c0	45 8b c0	 mov	 r8d, r8d
  000c3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000c7	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@z900_float:

; 669  :     return ARCH_DEP( float64_cc_quiet )( op1, op2 );

  000cb	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  000d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  000d5	e8 00 00 00 00	 call	 z900_float64_cc_quiet

; 670  : }

  000da	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000de	c3		 ret	 0
z900_float64_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
z900_float64_compare PROC

; 657  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 658  :     if (f64_isSignalingNaN( op1 ) ||

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00013	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 11		 jne	 SHORT $LN3@z900_float
  0001f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  00024	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	74 41		 je	 SHORT $LN2@z900_float
$LN3@z900_float:

; 659  :         f64_isSignalingNaN( op2 ))
; 660  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00030	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00035	8b c0		 mov	 eax, eax
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00046	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0004a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004e	83 c8 10	 or	 eax, 16
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00057	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00060	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00066	45 8b c0	 mov	 r8d, r8d
  00069	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0006d	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@z900_float:

; 661  :     return ARCH_DEP( float64_cc_quiet )( op1, op2 );

  00071	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  0007b	e8 00 00 00 00	 call	 z900_float64_cc_quiet

; 662  : }

  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	c3		 ret	 0
z900_float64_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv81 = 32
tv83 = 36
tv84 = 40
op1$ = 64
op2$ = 72
z900_float64_cc_quiet PROC

; 649  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 650  :     return FLOAT64_ISNAN( op1      ) ||

  0000e	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 23 c8	 and	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	75 1e		 jne	 SHORT $LN3@z900_float
  00032	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00041	48 23 c8	 and	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 85 c0	 test	 rax, rax
  0004a	0f 85 98 00 00
	00		 jne	 $LN5@z900_float
$LN3@z900_float:
  00050	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  0005f	48 23 c8	 and	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0006f	48 3b c1	 cmp	 rax, rcx
  00072	75 1a		 jne	 SHORT $LN4@z900_float
  00074	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0007e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00083	48 23 c8	 and	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	48 85 c0	 test	 rax, rax
  0008c	75 5a		 jne	 SHORT $LN5@z900_float
$LN4@z900_float:
  0008e	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00098	e8 00 00 00 00	 call	 f64_eq
  0009d	0f b6 c0	 movzx	 eax, al
  000a0	85 c0		 test	 eax, eax
  000a2	74 0a		 je	 SHORT $LN8@z900_float
  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000ac	eb 30		 jmp	 SHORT $LN9@z900_float
$LN8@z900_float:
  000ae	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  000b8	e8 00 00 00 00	 call	 f64_lt_quiet
  000bd	0f b6 c0	 movzx	 eax, al
  000c0	85 c0		 test	 eax, eax
  000c2	74 0a		 je	 SHORT $LN6@z900_float
  000c4	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  000cc	eb 08		 jmp	 SHORT $LN7@z900_float
$LN6@z900_float:
  000ce	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv81[rsp], 2
$LN7@z900_float:
  000d6	8b 44 24 20	 mov	 eax, DWORD PTR tv81[rsp]
  000da	89 44 24 24	 mov	 DWORD PTR tv83[rsp], eax
$LN9@z900_float:
  000de	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  000e2	89 44 24 28	 mov	 DWORD PTR tv84[rsp], eax
  000e6	eb 08		 jmp	 SHORT $LN10@z900_float
$LN5@z900_float:
  000e8	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv84[rsp], 3
$LN10@z900_float:
  000f0	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv84[rsp]

; 651  :            FLOAT64_ISNAN(      op2 ) ? 3 :
; 652  :            f64_eq(        op1, op2 ) ? 0 :
; 653  :            f64_lt_quiet(  op1, op2 ) ? 1 : 2;
; 654  : }

  000f5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f9	c3		 ret	 0
z900_float64_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
op1$ = 96
op2$ = 104
z900_float128_signaling_compare PROC

; 641  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 642  :     if (FLOAT128_ISNAN( op1 ) ||

  00010	b8 08 00 00 00	 mov	 eax, 8
  00015	48 6b c0 01	 imul	 rax, rax, 1
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  0001e	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  00028	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0002c	48 23 c2	 and	 rax, rdx
  0002f	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00039	48 3b c1	 cmp	 rax, rcx
  0003c	75 39		 jne	 SHORT $LN4@z900_float
  0003e	b8 08 00 00 00	 mov	 eax, 8
  00043	48 6b c0 01	 imul	 rax, rax, 1
  00047	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  0004c	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  00056	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0005a	48 23 c2	 and	 rax, rdx
  0005d	48 85 c0	 test	 rax, rax
  00060	75 7c		 jne	 SHORT $LN3@z900_float
  00062	b8 08 00 00 00	 mov	 eax, 8
  00067	48 6b c0 00	 imul	 rax, rax, 0
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  00070	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00075	75 67		 jne	 SHORT $LN3@z900_float
$LN4@z900_float:
  00077	b8 08 00 00 00	 mov	 eax, 8
  0007c	48 6b c0 01	 imul	 rax, rax, 1
  00080	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  00085	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  0008f	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00093	48 23 c2	 and	 rax, rdx
  00096	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  000a0	48 3b c1	 cmp	 rax, rcx
  000a3	75 7a		 jne	 SHORT $LN2@z900_float
  000a5	b8 08 00 00 00	 mov	 eax, 8
  000aa	48 6b c0 01	 imul	 rax, rax, 1
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  000b3	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  000bd	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000c1	48 23 c2	 and	 rax, rdx
  000c4	48 85 c0	 test	 rax, rax
  000c7	75 15		 jne	 SHORT $LN5@z900_float
  000c9	b8 08 00 00 00	 mov	 eax, 8
  000ce	48 6b c0 00	 imul	 rax, rax, 0
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  000d7	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000dc	74 41		 je	 SHORT $LN2@z900_float
$LN5@z900_float:
$LN3@z900_float:

; 643  :         FLOAT128_ISNAN( op2 ))
; 644  :         softfloat_raiseFlags( softfloat_flag_invalid );

  000de	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  000e3	8b c0		 mov	 eax, eax
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000eb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000f4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000f8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fc	83 c8 10	 or	 eax, 16
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00105	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0010e	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00114	45 8b c0	 mov	 r8d, r8d
  00117	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0011b	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@z900_float:

; 645  :     return ARCH_DEP( float128_cc_quiet )( op1, op2 );

  0011f	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00124	48 8b f8	 mov	 rdi, rax
  00127	48 8b 74 24 68	 mov	 rsi, QWORD PTR op2$[rsp]
  0012c	b9 10 00 00 00	 mov	 ecx, 16
  00131	f3 a4		 rep movsb
  00133	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00138	48 8b f8	 mov	 rdi, rax
  0013b	48 8b 74 24 60	 mov	 rsi, QWORD PTR op1$[rsp]
  00140	b9 10 00 00 00	 mov	 ecx, 16
  00145	f3 a4		 rep movsb
  00147	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0014c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00151	e8 00 00 00 00	 call	 z900_float128_cc_quiet

; 646  : }

  00156	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015a	5f		 pop	 rdi
  0015b	5e		 pop	 rsi
  0015c	c3		 ret	 0
z900_float128_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
op1$ = 128
op2$ = 136
z900_float128_compare PROC

; 633  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 634  :     if (f128_isSignalingNaN( op1 ) ||

  00010	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00015	48 8b f8	 mov	 rdi, rax
  00018	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00020	b9 10 00 00 00	 mov	 ecx, 16
  00025	f3 a4		 rep movsb
  00027	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0002c	e8 00 00 00 00	 call	 f128_isSignalingNaN
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 28		 jne	 SHORT $LN3@z900_float
  00038	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0003d	48 8b f8	 mov	 rdi, rax
  00040	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  00048	b9 10 00 00 00	 mov	 ecx, 16
  0004d	f3 a4		 rep movsb
  0004f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00054	e8 00 00 00 00	 call	 f128_isSignalingNaN
  00059	0f b6 c0	 movzx	 eax, al
  0005c	85 c0		 test	 eax, eax
  0005e	74 3e		 je	 SHORT $LN2@z900_float
$LN3@z900_float:

; 635  :         f128_isSignalingNaN( op2 ))
; 636  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00060	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00065	8b c0		 mov	 eax, eax
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0006d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00076	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0007a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007e	83 c8 10	 or	 eax, 16
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00087	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00090	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00095	8b ff		 mov	 edi, edi
  00097	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0009b	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN2@z900_float:

; 637  :     return ARCH_DEP( float128_cc_quiet )( op1, op2 );

  0009e	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  000a3	48 8b f8	 mov	 rdi, rax
  000a6	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  000ae	b9 10 00 00 00	 mov	 ecx, 16
  000b3	f3 a4		 rep movsb
  000b5	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  000ba	48 8b f8	 mov	 rdi, rax
  000bd	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  000c5	b9 10 00 00 00	 mov	 ecx, 16
  000ca	f3 a4		 rep movsb
  000cc	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  000d1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  000d6	e8 00 00 00 00	 call	 z900_float128_cc_quiet

; 638  : }

  000db	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
z900_float128_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv133 = 32
tv135 = 36
tv136 = 40
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
op1$ = 144
op2$ = 152
z900_float128_cc_quiet PROC

; 625  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 626  :     return FLOAT128_ISNAN( op1      ) ||

  00010	b8 08 00 00 00	 mov	 eax, 8
  00015	48 6b c0 01	 imul	 rax, rax, 1
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  00021	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  0002b	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0002f	48 23 c2	 and	 rax, rdx
  00032	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	75 47		 jne	 SHORT $LN4@z900_float
  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	48 6b c0 01	 imul	 rax, rax, 1
  0004a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  00052	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  0005c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00060	48 23 c2	 and	 rax, rdx
  00063	48 85 c0	 test	 rax, rax
  00066	0f 85 4a 01 00
	00		 jne	 $LN3@z900_float
  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 00	 imul	 rax, rax, 0
  00075	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  0007d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00082	0f 85 2e 01 00
	00		 jne	 $LN3@z900_float
$LN4@z900_float:
  00088	b8 08 00 00 00	 mov	 eax, 8
  0008d	48 6b c0 01	 imul	 rax, rax, 1
  00091	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  00099	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  000a3	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a7	48 23 c2	 and	 rax, rdx
  000aa	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  000b4	48 3b c1	 cmp	 rax, rcx
  000b7	75 47		 jne	 SHORT $LN6@z900_float
  000b9	b8 08 00 00 00	 mov	 eax, 8
  000be	48 6b c0 01	 imul	 rax, rax, 1
  000c2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  000ca	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  000d4	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000d8	48 23 c2	 and	 rax, rdx
  000db	48 85 c0	 test	 rax, rax
  000de	0f 85 d2 00 00
	00		 jne	 $LN5@z900_float
  000e4	b8 08 00 00 00	 mov	 eax, 8
  000e9	48 6b c0 00	 imul	 rax, rax, 0
  000ed	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  000f5	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000fa	0f 85 b6 00 00
	00		 jne	 $LN3@z900_float
$LN6@z900_float:
  00100	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00105	48 8b f8	 mov	 rdi, rax
  00108	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  00110	b9 10 00 00 00	 mov	 ecx, 16
  00115	f3 a4		 rep movsb
  00117	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0011c	48 8b f8	 mov	 rdi, rax
  0011f	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00127	b9 10 00 00 00	 mov	 ecx, 16
  0012c	f3 a4		 rep movsb
  0012e	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00133	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00138	e8 00 00 00 00	 call	 f128_eq
  0013d	0f b6 c0	 movzx	 eax, al
  00140	85 c0		 test	 eax, eax
  00142	74 0a		 je	 SHORT $LN9@z900_float
  00144	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
  0014c	eb 5e		 jmp	 SHORT $LN10@z900_float
$LN9@z900_float:
  0014e	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00153	48 8b f8	 mov	 rdi, rax
  00156	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  0015e	b9 10 00 00 00	 mov	 ecx, 16
  00163	f3 a4		 rep movsb
  00165	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  0016a	48 8b f8	 mov	 rdi, rax
  0016d	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00175	b9 10 00 00 00	 mov	 ecx, 16
  0017a	f3 a4		 rep movsb
  0017c	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  00181	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  00186	e8 00 00 00 00	 call	 f128_lt_quiet
  0018b	0f b6 c0	 movzx	 eax, al
  0018e	85 c0		 test	 eax, eax
  00190	74 0a		 je	 SHORT $LN7@z900_float
  00192	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  0019a	eb 08		 jmp	 SHORT $LN8@z900_float
$LN7@z900_float:
  0019c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
$LN8@z900_float:
  001a4	8b 44 24 20	 mov	 eax, DWORD PTR tv133[rsp]
  001a8	89 44 24 24	 mov	 DWORD PTR tv135[rsp], eax
$LN10@z900_float:
  001ac	8b 44 24 24	 mov	 eax, DWORD PTR tv135[rsp]
  001b0	89 44 24 28	 mov	 DWORD PTR tv136[rsp], eax
  001b4	eb 08		 jmp	 SHORT $LN11@z900_float
$LN3@z900_float:
$LN5@z900_float:
  001b6	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv136[rsp], 3
$LN11@z900_float:
  001be	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv136[rsp]

; 627  :            FLOAT128_ISNAN(      op2 ) ? 3 :
; 628  :            f128_eq(        op1, op2 ) ? 0 :
; 629  :            f128_lt_quiet(  op1, op2 ) ? 1 : 2;
; 630  : }

  001c3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001c7	5f		 pop	 rdi
  001c8	5e		 pop	 rsi
  001c9	c3		 ret	 0
z900_float128_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
z900_put_float32 PROC

; 584  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 585  :     *fpr = op->v;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR fpr$[rsp]
  0000f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00014	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00016	89 08		 mov	 DWORD PTR [rax], ecx

; 586  : }

  00018	c3		 ret	 0
z900_put_float32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
z900_get_float32 PROC

; 579  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 580  :     op->v = *fpr;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00014	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00016	89 08		 mov	 DWORD PTR [rax], ecx

; 581  : }

  00018	c3		 ret	 0
z900_get_float32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
z900_put_float64 PROC

; 573  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 574  :     fpr[0] = (U32) (op->v >> 32);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00016	b9 04 00 00 00	 mov	 ecx, 4
  0001b	48 6b c9 00	 imul	 rcx, rcx, 0
  0001f	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00024	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 575  :     fpr[1] = (U32) (op->v & 0xFFFFFFFF);

  00027	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0002c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 23 c1	 and	 rax, rcx
  00037	b9 04 00 00 00	 mov	 ecx, 4
  0003c	48 6b c9 01	 imul	 rcx, rcx, 1
  00040	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00045	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 576  : }

  00048	c3		 ret	 0
z900_put_float64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
z900_get_float64 PROC

; 568  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 569  :     op->v = ((U64)fpr[0] << 32) | fpr[1];

  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	48 6b c0 00	 imul	 rax, rax, 0
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00018	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0001b	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	48 6b c9 01	 imul	 rcx, rcx, 1
  00028	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00030	48 0b c1	 or	 rax, rcx
  00033	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00038	48 89 01	 mov	 QWORD PTR [rcx], rax

; 570  : }

  0003b	c3		 ret	 0
z900_get_float64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
z900_put_float128 PROC

; 560  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 561  :     fpr[0]       = (U32) (op->v[FLOAT128_HI] >> 32);

  0000a	b8 08 00 00 00	 mov	 eax, 8
  0000f	48 6b c0 01	 imul	 rax, rax, 1
  00013	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00018	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0001c	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00020	b9 04 00 00 00	 mov	 ecx, 4
  00025	48 6b c9 00	 imul	 rcx, rcx, 0
  00029	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002e	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 562  :     fpr[1]       = (U32) (op->v[FLOAT128_HI] & 0xFFFFFFFF);

  00031	b8 08 00 00 00	 mov	 eax, 8
  00036	48 6b c0 01	 imul	 rax, rax, 1
  0003a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  0003f	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00044	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00048	48 23 c2	 and	 rax, rdx
  0004b	b9 04 00 00 00	 mov	 ecx, 4
  00050	48 6b c9 01	 imul	 rcx, rcx, 1
  00054	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00059	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 563  :     fpr[FPREX]   = (U32) (op->v[FLOAT128_LO] >> 32);

  0005c	b8 08 00 00 00	 mov	 eax, 8
  00061	48 6b c0 00	 imul	 rax, rax, 0
  00065	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  0006a	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0006e	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00072	b9 04 00 00 00	 mov	 ecx, 4
  00077	48 6b c9 04	 imul	 rcx, rcx, 4
  0007b	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00080	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 564  :     fpr[FPREX+1] = (U32) (op->v[FLOAT128_LO] & 0xFFFFFFFF);

  00083	b8 08 00 00 00	 mov	 eax, 8
  00088	48 6b c0 00	 imul	 rax, rax, 0
  0008c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00091	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00096	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0009a	48 23 c2	 and	 rax, rdx
  0009d	b9 04 00 00 00	 mov	 ecx, 4
  000a2	48 6b c9 05	 imul	 rcx, rcx, 5
  000a6	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  000ab	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 565  : }

  000ae	c3		 ret	 0
z900_put_float128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
z900_get_float128 PROC

; 553  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 554  :                                                       /* high order bits in v[1], low order in v[0]  */
; 555  :     op->v[FLOAT128_HI] = ((U64)fpr[0]     << 32) | fpr[1];               /* *****  Possible endian concern  ******* */

  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	48 6b c0 00	 imul	 rax, rax, 0
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00018	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0001b	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	48 6b c9 01	 imul	 rcx, rcx, 1
  00028	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00030	48 0b c1	 or	 rax, rcx
  00033	b9 08 00 00 00	 mov	 ecx, 8
  00038	48 6b c9 01	 imul	 rcx, rcx, 1
  0003c	48 8b 54 24 08	 mov	 rdx, QWORD PTR op$[rsp]
  00041	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 556  :     op->v[FLOAT128_LO] = ((U64)fpr[FPREX] << 32) | fpr[FPREX+1];

  00045	b8 04 00 00 00	 mov	 eax, 4
  0004a	48 6b c0 04	 imul	 rax, rax, 4
  0004e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00053	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00056	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0005a	b9 04 00 00 00	 mov	 ecx, 4
  0005f	48 6b c9 05	 imul	 rcx, rcx, 5
  00063	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00068	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0006b	48 0b c1	 or	 rax, rcx
  0006e	b9 08 00 00 00	 mov	 ecx, 8
  00073	48 6b c9 00	 imul	 rcx, rcx, 0
  00077	48 8b 54 24 08	 mov	 rdx, QWORD PTR op$[rsp]
  0007c	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 557  : }

  00080	c3		 ret	 0
z900_get_float128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
regs$ = 48
mask$ = 56
z900_BFP_RM_check PROC

; 534  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 535  : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 536  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 04	 imul	 rax, rax, 4
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00023	83 e0 04	 and	 eax, 4
  00026	85 c0		 test	 eax, eax
  00028	74 3a		 je	 SHORT $LN2@z900_BFP_R

; 537  :     {
; 538  :         if (mask > 7 || !map_valid_m3_values_FPX[ (mask & 0x7) ]) 

  0002a	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  0002f	83 f8 07	 cmp	 eax, 7
  00032	7f 19		 jg	 SHORT $LN5@z900_BFP_R
  00034	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  00039	83 e0 07	 and	 eax, 7
  0003c	48 98		 cdqe
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_valid_m3_values_FPX
  00045	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00049	85 c0		 test	 eax, eax
  0004b	75 15		 jne	 SHORT $LN4@z900_BFP_R
$LN5@z900_BFP_R:

; 539  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0004d	ba 06 00 00 00	 mov	 edx, 6
  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@z900_BFP_R:

; 540  :     }

  00062	eb 38		 jmp	 SHORT $LN3@z900_BFP_R
$LN2@z900_BFP_R:

; 541  :     else
; 542  : #endif
; 543  :     {
; 544  :         if (mask > 7 || !map_valid_m3_values_NOFPX[ (mask & 0x7) ])

  00064	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  00069	83 f8 07	 cmp	 eax, 7
  0006c	7f 19		 jg	 SHORT $LN7@z900_BFP_R
  0006e	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  00073	83 e0 07	 and	 eax, 7
  00076	48 98		 cdqe
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_valid_m3_values_NOFPX
  0007f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00083	85 c0		 test	 eax, eax
  00085	75 15		 jne	 SHORT $LN6@z900_BFP_R
$LN7@z900_BFP_R:

; 545  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00087	ba 06 00 00 00	 mov	 edx, 6
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00096	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_BFP_R:
$LN3@z900_BFP_R:

; 546  :     }
; 547  : }

  0009c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a0	c3		 ret	 0
z900_BFP_RM_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0001d	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00023	77 0a		 ja	 SHORT $LN6@z900_vfetc
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vfetc
$LN6@z900_vfetc:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@z900_vfetc:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003c	74 47		 je	 SHORT $LN2@z900_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00043	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00047	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00053	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0005d	ba 08 00 00 00	 mov	 edx, 8
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00067	e8 00 00 00 00	 call	 z900_maddr_l
  0006c	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00076	e8 00 00 00 00	 call	 fetch_dw_noswap
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 _byteswap_uint64
  00083	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00085	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  0008a	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_vfetch8_full
$LN1@z900_vfetc:

; 737  : }

  00098	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009c	c3		 ret	 0
z900_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00031	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00040	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00051	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00055	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005d	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00065	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 z900_maddr_l
  0007d	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  00082	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00087	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0008c	48 8b f9	 mov	 rdi, rcx
  0008f	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00099	b8 08 00 00 00	 mov	 eax, 8
  0009e	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a2	48 98		 cdqe
  000a4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b1	48 03 d1	 add	 rdx, rcx
  000b4	48 8b ca	 mov	 rcx, rdx
  000b7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bf	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ce	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000de	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 z900_maddr_l
  000f6	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  00105	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00108	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  0010d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00112	e8 00 00 00 00	 call	 fetch_dw_noswap
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck2
_TEXT	SEGMENT
tv81 = 32
tv131 = 40
tv150 = 48
tv181 = 56
tv166 = 64
regs$ = 96
x2$ = 104
b2$ = 112
z900_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 ba 01 00
	00		 jne	 $LN3@z900_per3_
  0001c	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00021	75 54		 jne	 SHORT $LN4@z900_per3_
  00023	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  00028	74 4d		 je	 SHORT $LN4@z900_per3_
  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $LN8@z900_per3_
  0003c	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0004e	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
  00053	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  00055	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
$LN9@z900_per3_:
  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv81[rsp], 0
  00071	0f 84 5f 01 00
	00		 je	 $LN3@z900_per3_
$LN4@z900_per3_:
  00077	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007c	75 54		 jne	 SHORT $LN5@z900_per3_
  0007e	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 4d		 je	 SHORT $LN5@z900_per3_
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 19		 je	 SHORT $LN10@z900_per3_
  00097	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a9	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  000ae	eb 16		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  000b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c1	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
$LN11@z900_per3_:
  000c6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv131[rsp], 0
  000cc	0f 84 04 01 00
	00		 je	 $LN3@z900_per3_
$LN5@z900_per3_:
  000d2	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  000d7	0f 84 03 01 00
	00		 je	 $LN2@z900_per3_
  000dd	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  000e2	0f 84 f8 00 00
	00		 je	 $LN2@z900_per3_
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 e4 00 00
	00		 jne	 $LN6@z900_per3_
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 19		 je	 SHORT $LN12@z900_per3_
  00104	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
  0011b	eb 16		 jmp	 SHORT $LN13@z900_per3_
$LN12@z900_per3_:
  0011d	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0012e	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
$LN13@z900_per3_:
  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv150[rsp], 0
  00139	0f 84 97 00 00
	00		 je	 $LN6@z900_per3_
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 19		 je	 SHORT $LN14@z900_per3_
  00151	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00163	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
  00168	eb 16		 jmp	 SHORT $LN15@z900_per3_
$LN14@z900_per3_:
  0016a	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
$LN15@z900_per3_:
  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	74 19		 je	 SHORT $LN16@z900_per3_
  00192	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001a4	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
  001a9	eb 16		 jmp	 SHORT $LN17@z900_per3_
$LN16@z900_per3_:
  001ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001bc	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
$LN17@z900_per3_:
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv181[rsp]
  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv166[rsp]
  001cb	48 03 c8	 add	 rcx, rax
  001ce	48 8b c1	 mov	 rax, rcx
  001d1	48 85 c0	 test	 rax, rax
  001d4	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN6@z900_per3_:
$LN3@z900_per3_:

; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );

  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 777  : #else
; 778  :     UNREFERENCED( regs );
; 779  :     UNREFERENCED( x2 );
; 780  :     UNREFERENCED( b2 );
; 781  : #endif
; 782  : }

  001e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e4	c3		 ret	 0
z900_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 64
r2$ = 68
m3$ = 72
r1$ = 76
fract$ = 80
op1$ = 88
__$ArrayPad$ = 104
inst$ = 128
regs$ = 136
z900_convert_float_long_to_bfp_short_reg PROC

; 1172 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1173 :     int r1, r2, m3;
; 1174 :     struct sbfp op1;
; 1175 :     U64 fract;
; 1176 : 
; 1177 :     RRF_M(inst, regs, r1, r2, m3);

  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	83 e0 0f	 and	 eax, 15
  0003c	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00040	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	c1 e8 04	 shr	 eax, 4
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  0004e	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00052	c1 e8 0c	 shr	 eax, 12
  00055	83 e0 0f	 and	 eax, 15
  00058	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  0005c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0f		 je	 SHORT $LN8@z900_conve
  0007f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  0008e	33 c0		 xor	 eax, eax
  00090	85 c0		 test	 eax, eax
  00092	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1178 :     TXFC_INSTR_CHECK( regs );

  00094	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a3	85 c0		 test	 eax, eax
  000a5	74 3f		 je	 SHORT $LN9@z900_conve
  000a7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b5	0f ba e8 0f	 bts	 eax, 15
  000b9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198432
  000ce	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d4	ba 02 00 00 00	 mov	 edx, 2
  000d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 a8		 jne	 SHORT $LN7@z900_conve

; 1179 :     //logmsg("TBEDR r1=%d r2=%d\n", r1, r2);
; 1180 :     HFPREG2_CHECK(r1, r2, regs);

  000ec	b8 08 00 00 00	 mov	 eax, 8
  000f1	48 6b c0 01	 imul	 rax, rax, 1
  000f5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fd	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00105	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010b	48 85 c0	 test	 rax, rax
  0010e	74 42		 je	 SHORT $LN11@z900_conve
  00110	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011e	d1 e8		 shr	 eax, 1
  00120	83 e0 01	 and	 eax, 1
  00123	85 c0		 test	 eax, eax
  00125	74 6e		 je	 SHORT $LN10@z900_conve
  00127	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00136	b9 08 00 00 00	 mov	 ecx, 8
  0013b	48 6b c9 01	 imul	 rcx, rcx, 1
  0013f	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00147	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014d	48 85 c0	 test	 rax, rax
  00150	75 43		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00152	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  00156	83 e0 09	 and	 eax, 9
  00159	85 c0		 test	 eax, eax
  0015b	75 0b		 jne	 SHORT $LN13@z900_conve
  0015d	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00161	83 e0 09	 and	 eax, 9
  00164	85 c0		 test	 eax, eax
  00166	74 2d		 je	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00168	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0017a	ba 07 00 00 00	 mov	 edx, 7
  0017f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:
$LN10@z900_conve:

; 1181 :     BFPRM_CHECK(m3,regs);

  00195	0f b6 54 24 48	 movzx	 edx, BYTE PTR m3$[rsp]
  0019a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 1182 : 
; 1183 :     regs->psw.cc =

  001a7	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  001ab	d1 e0		 shl	 eax, 1
  001ad	48 98		 cdqe
  001af	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001bf	48 8d 4c 24 50	 lea	 rcx, QWORD PTR fract$[rsp]
  001c4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c9	48 8d 4c 24 5c	 lea	 rcx, QWORD PTR op1$[rsp+4]
  001ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d3	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  001d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001dd	c7 44 24 20 7f
	00 00 00	 mov	 DWORD PTR [rsp+32], 127	; 0000007fH
  001e5	41 b9 7f 00 00
	00		 mov	 r9d, 127		; 0000007fH
  001eb	41 b8 17 00 00
	00		 mov	 r8d, 23
  001f1	8b 54 24 48	 mov	 edx, DWORD PTR m3$[rsp]
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	e8 00 00 00 00	 call	 cnvt_hfp_to_bfp
  001fd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00205	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1184 :         cnvt_hfp_to_bfp (regs->fpr + FPR2I(r2), m3,
; 1185 :             /*fractbits*/23, /*emax*/127, /*ebias*/127,
; 1186 :             &(op1.sign), &(op1.exp), &fract);
; 1187 :     op1.fract = (U32)fract;

  00208	8b 44 24 50	 mov	 eax, DWORD PTR fract$[rsp]
  0020c	89 44 24 60	 mov	 DWORD PTR op1$[rsp+8], eax

; 1188 : 
; 1189 :     put_sbfp(&op1, regs->fpr + FPR2I(r1));

  00210	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  00214	d1 e0		 shl	 eax, 1
  00216	48 98		 cdqe
  00218	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00220	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00228	48 8b d0	 mov	 rdx, rax
  0022b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  00230	e8 00 00 00 00	 call	 put_sbfp

; 1190 : 
; 1191 : } /* end DEF_INST(convert_float_long_to_bfp_short_reg) */

  00235	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023a	48 33 cc	 xor	 rcx, rsp
  0023d	e8 00 00 00 00	 call	 __security_check_cookie
  00242	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00246	c3		 ret	 0
z900_convert_float_long_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 64
r2$ = 68
m3$ = 72
r1$ = 76
op1$ = 80
__$ArrayPad$ = 104
inst$ = 128
regs$ = 136
z900_convert_float_long_to_bfp_long_reg PROC

; 1149 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1150 :     int r1, r2, m3;
; 1151 :     struct lbfp op1;
; 1152 : 
; 1153 :     RRF_M(inst, regs, r1, r2, m3);

  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	83 e0 0f	 and	 eax, 15
  0003c	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00040	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	c1 e8 04	 shr	 eax, 4
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  0004e	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00052	c1 e8 0c	 shr	 eax, 12
  00055	83 e0 0f	 and	 eax, 15
  00058	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  0005c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0f		 je	 SHORT $LN8@z900_conve
  0007f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  0008e	33 c0		 xor	 eax, eax
  00090	85 c0		 test	 eax, eax
  00092	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1154 :     TXFC_INSTR_CHECK( regs );

  00094	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a3	85 c0		 test	 eax, eax
  000a5	74 3f		 je	 SHORT $LN9@z900_conve
  000a7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b5	0f ba e8 0f	 bts	 eax, 15
  000b9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198407
  000ce	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d4	ba 02 00 00 00	 mov	 edx, 2
  000d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 a8		 jne	 SHORT $LN7@z900_conve

; 1155 :     //logmsg("TBDR r1=%d r2=%d\n", r1, r2);
; 1156 :     HFPREG2_CHECK(r1, r2, regs);

  000ec	b8 08 00 00 00	 mov	 eax, 8
  000f1	48 6b c0 01	 imul	 rax, rax, 1
  000f5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fd	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00105	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010b	48 85 c0	 test	 rax, rax
  0010e	74 42		 je	 SHORT $LN11@z900_conve
  00110	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011e	d1 e8		 shr	 eax, 1
  00120	83 e0 01	 and	 eax, 1
  00123	85 c0		 test	 eax, eax
  00125	74 6e		 je	 SHORT $LN10@z900_conve
  00127	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00136	b9 08 00 00 00	 mov	 ecx, 8
  0013b	48 6b c9 01	 imul	 rcx, rcx, 1
  0013f	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00147	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014d	48 85 c0	 test	 rax, rax
  00150	75 43		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00152	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  00156	83 e0 09	 and	 eax, 9
  00159	85 c0		 test	 eax, eax
  0015b	75 0b		 jne	 SHORT $LN13@z900_conve
  0015d	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00161	83 e0 09	 and	 eax, 9
  00164	85 c0		 test	 eax, eax
  00166	74 2d		 je	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00168	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0017a	ba 07 00 00 00	 mov	 edx, 7
  0017f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:
$LN10@z900_conve:

; 1157 :     BFPRM_CHECK(m3,regs);

  00195	0f b6 54 24 48	 movzx	 edx, BYTE PTR m3$[rsp]
  0019a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 1158 : 
; 1159 :     regs->psw.cc =

  001a7	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  001ab	d1 e0		 shl	 eax, 1
  001ad	48 98		 cdqe
  001af	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001bf	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp+8]
  001c4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c9	48 8d 4c 24 54	 lea	 rcx, QWORD PTR op1$[rsp+4]
  001ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  001d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001dd	c7 44 24 20 ff
	03 00 00	 mov	 DWORD PTR [rsp+32], 1023 ; 000003ffH
  001e5	41 b9 ff 03 00
	00		 mov	 r9d, 1023		; 000003ffH
  001eb	41 b8 34 00 00
	00		 mov	 r8d, 52			; 00000034H
  001f1	8b 54 24 48	 mov	 edx, DWORD PTR m3$[rsp]
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	e8 00 00 00 00	 call	 cnvt_hfp_to_bfp
  001fd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00205	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1160 :         cnvt_hfp_to_bfp (regs->fpr + FPR2I(r2), m3,
; 1161 :             /*fractbits*/52, /*emax*/1023, /*ebias*/1023,
; 1162 :             &(op1.sign), &(op1.exp), &(op1.fract));
; 1163 : 
; 1164 :     put_lbfp(&op1, regs->fpr + FPR2I(r1));

  00208	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  0020c	d1 e0		 shl	 eax, 1
  0020e	48 98		 cdqe
  00210	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00220	48 8b d0	 mov	 rdx, rax
  00223	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  00228	e8 00 00 00 00	 call	 put_lbfp

; 1165 : 
; 1166 : } /* end DEF_INST(convert_float_long_to_bfp_long_reg) */

  0022d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00232	48 33 cc	 xor	 rcx, rsp
  00235	e8 00 00 00 00	 call	 __security_check_cookie
  0023a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0023e	c3		 ret	 0
z900_convert_float_long_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv161 = 48
op2$ = 56
lbfp_op2$ = 72
__$ArrayPad$ = 96
inst$ = 128
regs$ = 136
z900_convert_bfp_short_to_float_long_reg PROC

; 1119 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1120 :     int r1, r2;
; 1121 :     struct sbfp op2;
; 1122 :     struct lbfp lbfp_op2;
; 1123 : 
; 1124 :     RRE(inst, regs, r1, r2);

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00032	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00036	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00041	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00045	c1 f8 04	 sar	 eax, 4
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  0004f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00067	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006b	33 c0		 xor	 eax, eax
  0006d	83 f8 04	 cmp	 eax, 4
  00070	74 0f		 je	 SHORT $LN8@z900_conve
  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1125 :     TXFC_INSTR_CHECK( regs );

  00087	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00096	85 c0		 test	 eax, eax
  00098	74 3f		 je	 SHORT $LN9@z900_conve
  0009a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000a8	0f ba e8 0f	 bts	 eax, 15
  000ac	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ba	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198384
  000c1	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000c7	ba 02 00 00 00	 mov	 edx, 2
  000cc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d4	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  000d9	33 c0		 xor	 eax, eax
  000db	85 c0		 test	 eax, eax
  000dd	75 a8		 jne	 SHORT $LN7@z900_conve

; 1126 :     //logmsg("THDER r1=%d r2=%d\n", r1, r2);
; 1127 :     HFPREG2_CHECK(r1, r2, regs);

  000df	b8 08 00 00 00	 mov	 eax, 8
  000e4	48 6b c0 01	 imul	 rax, rax, 1
  000e8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000f8	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000fe	48 85 c0	 test	 rax, rax
  00101	74 42		 je	 SHORT $LN11@z900_conve
  00103	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 6e		 je	 SHORT $LN10@z900_conve
  0011a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 43		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00145	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00149	83 e0 09	 and	 eax, 9
  0014c	85 c0		 test	 eax, eax
  0014e	75 0b		 jne	 SHORT $LN13@z900_conve
  00150	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00154	83 e0 09	 and	 eax, 9
  00157	85 c0		 test	 eax, eax
  00159	74 2d		 je	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  0015b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0016d	ba 07 00 00 00	 mov	 edx, 7
  00172	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:
$LN10@z900_conve:

; 1128 : 
; 1129 :     /* Load sbfp operand from R2 register */
; 1130 :     get_sbfp(&op2, regs->fpr + FPR2I(r2));

  00188	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  0018c	d1 e0		 shl	 eax, 1
  0018e	48 98		 cdqe
  00190	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a0	48 8b d0	 mov	 rdx, rax
  001a3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  001a8	e8 00 00 00 00	 call	 get_sbfp

; 1131 : 
; 1132 :     /* Lengthen sbfp operand to lbfp */
; 1133 :     lbfp_op2.sign = op2.sign;

  001ad	8b 44 24 38	 mov	 eax, DWORD PTR op2$[rsp]
  001b1	89 44 24 48	 mov	 DWORD PTR lbfp_op2$[rsp], eax

; 1134 :     lbfp_op2.exp = op2.exp - 127 + 1023;

  001b5	8b 44 24 3c	 mov	 eax, DWORD PTR op2$[rsp+4]
  001b9	05 80 03 00 00	 add	 eax, 896		; 00000380H
  001be	89 44 24 4c	 mov	 DWORD PTR lbfp_op2$[rsp+4], eax

; 1135 :     lbfp_op2.fract = (U64)op2.fract << (52 - 23);

  001c2	48 63 44 24 40	 movsxd	 rax, DWORD PTR op2$[rsp+8]
  001c7	48 c1 e0 1d	 shl	 rax, 29
  001cb	48 89 44 24 50	 mov	 QWORD PTR lbfp_op2$[rsp+8], rax

; 1136 : 
; 1137 :     /* Convert lbfp to hfp register and set condition code */
; 1138 :     regs->psw.cc =

  001d0	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001d4	d1 e0		 shl	 eax, 1
  001d6	48 98		 cdqe
  001d8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001e8	48 89 44 24 30	 mov	 QWORD PTR tv161[rsp], rax
  001ed	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  001f2	e8 00 00 00 00	 call	 sbfpclassify
  001f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv161[rsp]
  001fc	4c 8b c1	 mov	 r8, rcx
  001ff	8b d0		 mov	 edx, eax
  00201	48 8d 4c 24 48	 lea	 rcx, QWORD PTR lbfp_op2$[rsp]
  00206	e8 00 00 00 00	 call	 cnvt_bfp_to_hfp
  0020b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1139 :         cnvt_bfp_to_hfp (&lbfp_op2,
; 1140 :                          sbfpclassify(&op2),
; 1141 :                          regs->fpr + FPR2I(r1));
; 1142 : 
; 1143 : } /* end DEF_INST(convert_bfp_short_to_float_long_reg) */

  00216	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0021b	48 33 cc	 xor	 rcx, rsp
  0021e	e8 00 00 00 00	 call	 __security_check_cookie
  00223	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00227	c3		 ret	 0
z900_convert_bfp_short_to_float_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv157 = 48
op2$ = 56
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
z900_convert_bfp_long_to_float_long_reg PROC

; 1094 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1095 :     int r1, r2;
; 1096 :     struct lbfp op2;
; 1097 : 
; 1098 :     RRE(inst, regs, r1, r2);

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN8@z900_conve
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1099 :     TXFC_INSTR_CHECK( regs );

  0007b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00087	85 c0		 test	 eax, eax
  00089	74 36		 je	 SHORT $LN9@z900_conve
  0008b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00090	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00096	0f ba e8 0f	 bts	 eax, 15
  0009a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000a5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198360
  000ac	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000b2	ba 02 00 00 00	 mov	 edx, 2
  000b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 b4		 jne	 SHORT $LN7@z900_conve

; 1100 :     //logmsg("THDR r1=%d r2=%d\n", r1, r2);
; 1101 :     HFPREG2_CHECK(r1, r2, regs);

  000c7	b8 08 00 00 00	 mov	 eax, 8
  000cc	48 6b c0 01	 imul	 rax, rax, 1
  000d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000dd	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000e3	48 85 c0	 test	 rax, rax
  000e6	74 3c		 je	 SHORT $LN11@z900_conve
  000e8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000f3	d1 e8		 shr	 eax, 1
  000f5	83 e0 01	 and	 eax, 1
  000f8	85 c0		 test	 eax, eax
  000fa	74 62		 je	 SHORT $LN10@z900_conve
  000fc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00101	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00108	b9 08 00 00 00	 mov	 ecx, 8
  0010d	48 6b c9 01	 imul	 rcx, rcx, 1
  00111	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00119	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0011f	48 85 c0	 test	 rax, rax
  00122	75 3a		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00124	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 09	 and	 eax, 9
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN13@z900_conve
  0012f	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 09	 and	 eax, 9
  00136	85 c0		 test	 eax, eax
  00138	74 24		 je	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  0013a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  00149	ba 07 00 00 00	 mov	 edx, 7
  0014e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00158	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:
$LN10@z900_conve:

; 1102 : 
; 1103 :     /* Load lbfp operand from R2 register */
; 1104 :     get_lbfp(&op2, regs->fpr + FPR2I(r2));

  0015e	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00162	d1 e0		 shl	 eax, 1
  00164	48 98		 cdqe
  00166	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00173	48 8b d0	 mov	 rdx, rax
  00176	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  0017b	e8 00 00 00 00	 call	 get_lbfp

; 1105 : 
; 1106 :     /* Convert to hfp register and set condition code */
; 1107 :     regs->psw.cc =

  00180	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00184	d1 e0		 shl	 eax, 1
  00186	48 98		 cdqe
  00188	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 89 44 24 30	 mov	 QWORD PTR tv157[rsp], rax
  0019a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  0019f	e8 00 00 00 00	 call	 lbfpclassify
  001a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv157[rsp]
  001a9	4c 8b c1	 mov	 r8, rcx
  001ac	8b d0		 mov	 edx, eax
  001ae	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  001b3	e8 00 00 00 00	 call	 cnvt_bfp_to_hfp
  001b8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1108 :         cnvt_bfp_to_hfp (&op2,
; 1109 :                          lbfpclassify(&op2),
; 1110 :                          regs->fpr + FPR2I(r1));
; 1111 : 
; 1112 : } /* end DEF_INST(convert_bfp_long_to_float_long_reg) */

  001c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c5	48 33 cc	 xor	 rcx, rsp
  001c8	e8 00 00 00 00	 call	 __security_check_cookie
  001cd	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001d1	c3		 ret	 0
z900_convert_bfp_long_to_float_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
x2$ = 36
b2$ = 40
tv183 = 44
r1$ = 48
op1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_test_data_class_bfp_short PROC

; 5027 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5028 :     int        r1, x2, b2;
; 5029 :     VADR       effective_addr2;
; 5030 :     float32_t  op1;
; 5031 : 
; 5032 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 24	 mov	 DWORD PTR x2$[rsp], eax
  00041	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00045	c1 e8 14	 shr	 eax, 20
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004f	83 7c 24 24 00	 cmp	 DWORD PTR x2$[rsp], 0
  00054	74 22		 je	 SHORT $LN8@z900_test_
  00056	48 63 44 24 24	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00068	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  00078	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 22		 je	 SHORT $LN9@z900_test_
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c0	48 23 c8	 and	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 06	 add	 rax, 6
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e1	33 c0		 xor	 eax, eax
  000e3	83 f8 06	 cmp	 eax, 6
  000e6	74 0c		 je	 SHORT $LN10@z900_test_
  000e8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 d1		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5033 :     TXF_FLOAT_INSTR_CHECK( regs );

  000fa	33 c0		 xor	 eax, eax
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	74 6f		 je	 SHORT $LN11@z900_test_
  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0010d	85 c0		 test	 eax, eax
  0010f	74 5f		 je	 SHORT $LN11@z900_test_
  00111	33 c0		 xor	 eax, eax
  00113	85 c0		 test	 eax, eax
  00115	75 23		 jne	 SHORT $LN12@z900_test_
  00117	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00123	85 c0		 test	 eax, eax
  00125	75 13		 jne	 SHORT $LN12@z900_test_
  00127	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00133	83 e0 04	 and	 eax, 4
  00136	85 c0		 test	 eax, eax
  00138	75 36		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  0013a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00145	0f ba e8 0b	 bts	 eax, 11
  00149	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00154	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201428
  0015b	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00161	ba 02 00 00 00	 mov	 edx, 2
  00166	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  00170	33 c0		 xor	 eax, eax
  00172	85 c0		 test	 eax, eax
  00174	75 84		 jne	 SHORT $LN7@z900_test_

; 5034 :     BFPINST_CHECK( regs );

  00176	b8 08 00 00 00	 mov	 eax, 8
  0017b	48 6b c0 01	 imul	 rax, rax, 1
  0017f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0018c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00192	48 85 c0	 test	 rax, rax
  00195	74 3c		 je	 SHORT $LN14@z900_test_
  00197	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0019c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001a2	d1 e8		 shr	 eax, 1
  001a4	83 e0 01	 and	 eax, 1
  001a7	85 c0		 test	 eax, eax
  001a9	74 4c		 je	 SHORT $LN13@z900_test_
  001ab	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001b7	b9 08 00 00 00	 mov	 ecx, 8
  001bc	48 6b c9 01	 imul	 rcx, rcx, 1
  001c0	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001c8	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ce	48 85 c0	 test	 rax, rax
  001d1	75 24		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  001d3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001e2	ba 07 00 00 00	 mov	 edx, 7
  001e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ec	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5035 : 
; 5036 :     GET_FLOAT32_OP( op1, r1, regs );

  001f7	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001fb	d1 e0		 shl	 eax, 1
  001fd	48 98		 cdqe
  001ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0020c	48 8b d0	 mov	 rdx, rax
  0020f	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00214	e8 00 00 00 00	 call	 z900_get_float32

; 5037 : 
; 5038 :     regs->psw.cc = !!(((U32)effective_addr2) & float32_class( op1 ));

  00219	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  0021d	e8 00 00 00 00	 call	 float32_class
  00222	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00226	23 c8		 and	 ecx, eax
  00228	8b c1		 mov	 eax, ecx
  0022a	85 c0		 test	 eax, eax
  0022c	74 0a		 je	 SHORT $LN16@z900_test_
  0022e	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
  00236	eb 08		 jmp	 SHORT $LN17@z900_test_
$LN16@z900_test_:
  00238	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv183[rsp], 0
$LN17@z900_test_:
  00240	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00245	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR tv183[rsp]
  0024a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5039 : }

  0024d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00251	c3		 ret	 0
z900_test_data_class_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
x2$ = 36
b2$ = 40
tv183 = 44
r1$ = 48
effective_addr2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
z900_test_data_class_bfp_long PROC

; 5046 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5047 :     int        r1, x2, b2;
; 5048 :     VADR       effective_addr2;
; 5049 :     float64_t  op1;
; 5050 : 
; 5051 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 24	 mov	 DWORD PTR x2$[rsp], eax
  00041	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00045	c1 e8 14	 shr	 eax, 20
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004f	83 7c 24 24 00	 cmp	 DWORD PTR x2$[rsp], 0
  00054	74 22		 je	 SHORT $LN8@z900_test_
  00056	48 63 44 24 24	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00068	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  00078	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 22		 je	 SHORT $LN9@z900_test_
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c0	48 23 c8	 and	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 06	 add	 rax, 6
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e1	33 c0		 xor	 eax, eax
  000e3	83 f8 06	 cmp	 eax, 6
  000e6	74 0c		 je	 SHORT $LN10@z900_test_
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 d1		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5052 :     TXF_FLOAT_INSTR_CHECK( regs );

  000fa	33 c0		 xor	 eax, eax
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	74 6f		 je	 SHORT $LN11@z900_test_
  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0010d	85 c0		 test	 eax, eax
  0010f	74 5f		 je	 SHORT $LN11@z900_test_
  00111	33 c0		 xor	 eax, eax
  00113	85 c0		 test	 eax, eax
  00115	75 23		 jne	 SHORT $LN12@z900_test_
  00117	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00123	85 c0		 test	 eax, eax
  00125	75 13		 jne	 SHORT $LN12@z900_test_
  00127	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00133	83 e0 04	 and	 eax, 4
  00136	85 c0		 test	 eax, eax
  00138	75 36		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00145	0f ba e8 0b	 bts	 eax, 11
  00149	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00154	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201454
  0015b	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00161	ba 02 00 00 00	 mov	 edx, 2
  00166	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  00170	33 c0		 xor	 eax, eax
  00172	85 c0		 test	 eax, eax
  00174	75 84		 jne	 SHORT $LN7@z900_test_

; 5053 :     BFPINST_CHECK( regs );

  00176	b8 08 00 00 00	 mov	 eax, 8
  0017b	48 6b c0 01	 imul	 rax, rax, 1
  0017f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0018c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00192	48 85 c0	 test	 rax, rax
  00195	74 3c		 je	 SHORT $LN14@z900_test_
  00197	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0019c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001a2	d1 e8		 shr	 eax, 1
  001a4	83 e0 01	 and	 eax, 1
  001a7	85 c0		 test	 eax, eax
  001a9	74 4c		 je	 SHORT $LN13@z900_test_
  001ab	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001b7	b9 08 00 00 00	 mov	 ecx, 8
  001bc	48 6b c9 01	 imul	 rcx, rcx, 1
  001c0	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001c8	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ce	48 85 c0	 test	 rax, rax
  001d1	75 24		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  001d3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001e2	ba 07 00 00 00	 mov	 edx, 7
  001e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ec	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5054 : 
; 5055 :     GET_FLOAT64_OP( op1, r1, regs );

  001f7	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001fb	d1 e0		 shl	 eax, 1
  001fd	48 98		 cdqe
  001ff	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0020c	48 8b d0	 mov	 rdx, rax
  0020f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00214	e8 00 00 00 00	 call	 z900_get_float64

; 5056 : 
; 5057 :     regs->psw.cc = !!(((U32)effective_addr2) & float64_class( op1 ));

  00219	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0021e	e8 00 00 00 00	 call	 float64_class
  00223	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00227	23 c8		 and	 ecx, eax
  00229	8b c1		 mov	 eax, ecx
  0022b	85 c0		 test	 eax, eax
  0022d	74 0a		 je	 SHORT $LN16@z900_test_
  0022f	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
  00237	eb 08		 jmp	 SHORT $LN17@z900_test_
$LN16@z900_test_:
  00239	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv183[rsp], 0
$LN17@z900_test_:
  00241	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00246	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR tv183[rsp]
  0024b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5058 : }

  0024e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00252	c3		 ret	 0
z900_test_data_class_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r1$ = 56
tv188 = 60
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
z900_test_data_class_bfp_ext PROC

; 5065 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5066 :     int         r1, x2, b2;
; 5067 :     VADR        effective_addr2;
; 5068 :     float128_t  op1;
; 5069 : 
; 5070 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	8b c0		 mov	 eax, eax
  00042	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00055	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00068	74 25		 je	 SHORT $LN8@z900_test_
  0006a	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  0008f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00093	c1 e8 0c	 shr	 eax, 12
  00096	83 e0 0f	 and	 eax, 15
  00099	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  0009d	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a2	74 25		 je	 SHORT $LN9@z900_test_
  000a4	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000be	48 03 c8	 add	 rcx, rax
  000c1	48 8b c1	 mov	 rax, rcx
  000c4	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000c9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000dd	48 23 c8	 and	 rcx, rax
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000e8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f4	48 83 c0 06	 add	 rax, 6
  000f8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00104	33 c0		 xor	 eax, eax
  00106	83 f8 06	 cmp	 eax, 6
  00109	74 0f		 je	 SHORT $LN10@z900_test_
  0010b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00113	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  0011a	33 c0		 xor	 eax, eax
  0011c	85 c0		 test	 eax, eax
  0011e	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5071 :     TXF_FLOAT_INSTR_CHECK( regs );

  00120	33 c0		 xor	 eax, eax
  00122	83 f8 01	 cmp	 eax, 1
  00125	0f 84 81 00 00
	00		 je	 $LN11@z900_test_
  0012b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00133	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0013a	85 c0		 test	 eax, eax
  0013c	74 6e		 je	 SHORT $LN11@z900_test_
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	75 29		 jne	 SHORT $LN12@z900_test_
  00144	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00153	85 c0		 test	 eax, eax
  00155	75 16		 jne	 SHORT $LN12@z900_test_
  00157	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00166	83 e0 04	 and	 eax, 4
  00169	85 c0		 test	 eax, eax
  0016b	75 3f		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  0016d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00175	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0017b	0f ba e8 0b	 bts	 eax, 11
  0017f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0018d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201480
  00194	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0019a	ba 02 00 00 00	 mov	 edx, 2
  0019f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  001ac	33 c0		 xor	 eax, eax
  001ae	85 c0		 test	 eax, eax
  001b0	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_test_

; 5072 :     BFPINST_CHECK( regs );

  001b6	b8 08 00 00 00	 mov	 eax, 8
  001bb	48 6b c0 01	 imul	 rax, rax, 1
  001bf	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001cf	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001d5	48 85 c0	 test	 rax, rax
  001d8	74 42		 je	 SHORT $LN14@z900_test_
  001da	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001e8	d1 e8		 shr	 eax, 1
  001ea	83 e0 01	 and	 eax, 1
  001ed	85 c0		 test	 eax, eax
  001ef	74 58		 je	 SHORT $LN13@z900_test_
  001f1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00200	b9 08 00 00 00	 mov	 ecx, 8
  00205	48 6b c9 01	 imul	 rcx, rcx, 1
  00209	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00211	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00217	48 85 c0	 test	 rax, rax
  0021a	75 2d		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  0021c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00224	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0022e	ba 07 00 00 00	 mov	 edx, 7
  00233	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00243	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5073 :     BFPREGPAIR_CHECK( r1, regs );

  00249	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0024d	83 e0 02	 and	 eax, 2
  00250	85 c0		 test	 eax, eax
  00252	74 1b		 je	 SHORT $LN15@z900_test_
  00254	ba 06 00 00 00	 mov	 edx, 6
  00259	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00261	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00269	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_test_:

; 5074 : 
; 5075 :     GET_FLOAT128_OP( op1, r1, regs );

  0026f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00273	d1 e0		 shl	 eax, 1
  00275	48 98		 cdqe
  00277	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00287	48 8b d0	 mov	 rdx, rax
  0028a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0028f	e8 00 00 00 00	 call	 z900_get_float128

; 5076 : 
; 5077 :     regs->psw.cc = !!(((U32)effective_addr2) & float128_class( op1 ));

  00294	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  00299	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0029e	48 8b f8	 mov	 rdi, rax
  002a1	48 8b f1	 mov	 rsi, rcx
  002a4	b9 10 00 00 00	 mov	 ecx, 16
  002a9	f3 a4		 rep movsb
  002ab	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  002b0	e8 00 00 00 00	 call	 float128_class
  002b5	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  002b9	23 c8		 and	 ecx, eax
  002bb	8b c1		 mov	 eax, ecx
  002bd	85 c0		 test	 eax, eax
  002bf	74 0a		 je	 SHORT $LN17@z900_test_
  002c1	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv188[rsp], 1
  002c9	eb 08		 jmp	 SHORT $LN18@z900_test_
$LN17@z900_test_:
  002cb	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
$LN18@z900_test_:
  002d3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002db	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR tv188[rsp]
  002e0	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5078 : }

  002e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002e8	48 33 cc	 xor	 rcx, rsp
  002eb	e8 00 00 00 00	 call	 __security_check_cookie
  002f0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002f4	5f		 pop	 rdi
  002f5	5e		 pop	 rsi
  002f6	c3		 ret	 0
z900_test_data_class_bfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ans$ = 32
ieee_trap_conds$ = 36
i$1 = 40
tv214 = 44
r1$ = 48
tv230 = 52
tv233 = 56
tv235 = 60
tv236 = 64
r2$ = 68
op2$ = 72
op1$ = 76
inst$ = 96
regs$ = 104
z900_subtract_bfp_short_reg PROC

; 4949 : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4950 :     int        r1, r2;
; 4951 :     float32_t  op1, op2, ans;
; 4952 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4953 : 
; 4954 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_subtr:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN14@z900_subtr
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN14@z900_subtr:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_subtr
$LN7@z900_subtr:

; 4955 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN15@z900_subtr
  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN15@z900_subtr
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN16@z900_subtr
  00091	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN16@z900_subtr
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN15@z900_subtr
$LN16@z900_subtr:
  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201363
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN15@z900_subtr:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_subtr

; 4956 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN18@z900_subtr
  00111	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN17@z900_subtr
  00125	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN17@z900_subtr
$LN18@z900_subtr:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_subtr:
$LN10@z900_subtr:

; 4957 : 
; 4958 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00171	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR op1$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float32
  00193	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00197	d1 e0		 shl	 eax, 1
  00199	48 98		 cdqe
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_get_float32
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 b6		 jne	 SHORT $LN10@z900_subtr

; 4959 : 
; 4960 :     softfloat_exceptionFlags = 0;

  001bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c0	8b c0		 mov	 eax, eax
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4961 :     SET_SF_RM_FROM_FPC;

  001d9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001de	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e4	83 e0 07	 and	 eax, 7
  001e7	8b c0		 mov	 eax, eax
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001f0	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001f5	8b d2		 mov	 edx, edx
  001f7	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001fe	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00207	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4962 : 
; 4963 :     ans = f32_sub( op1, op2 );

  00213	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00217	8b 4c 24 4c	 mov	 ecx, DWORD PTR op1$[rsp]
  0021b	e8 00 00 00 00	 call	 f32_sub
  00220	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax

; 4964 : 
; 4965 :     if (softfloat_exceptionFlags)

  00224	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00229	8b c0		 mov	 eax, eax
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00231	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00242	85 c0		 test	 eax, eax
  00244	0f 84 93 00 00
	00		 je	 $LN19@z900_subtr

; 4966 :     {
; 4967 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0024a	33 c0		 xor	 eax, eax
  0024c	83 f8 01	 cmp	 eax, 1
  0024f	74 45		 je	 SHORT $LN20@z900_subtr
  00251	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00256	8b c0		 mov	 eax, eax
  00258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0025e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00267	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026f	83 e0 10	 and	 eax, 16
  00272	85 c0		 test	 eax, eax
  00274	74 20		 je	 SHORT $LN20@z900_subtr
  00276	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0027b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00281	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00286	85 c0		 test	 eax, eax
  00288	74 0c		 je	 SHORT $LN20@z900_subtr
  0028a	b2 80		 mov	 dl, 128			; 00000080H
  0028c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00291	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_subtr:

; 4968 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00296	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002a0	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4969 : 
; 4970 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002a4	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002a8	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002ad	85 c0		 test	 eax, eax
  002af	74 2c		 je	 SHORT $LN21@z900_subtr

; 4971 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002b1	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b5	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002ba	85 c0		 test	 eax, eax
  002bc	74 0a		 je	 SHORT $LN24@z900_subtr
  002be	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv214[rsp], -192 ; ffffffffffffff40H
  002c6	eb 08		 jmp	 SHORT $LN25@z900_subtr
$LN24@z900_subtr:
  002c8	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv214[rsp], 192 ; 000000c0H
$LN25@z900_subtr:
  002d0	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv214[rsp]
  002d4	e8 00 00 00 00	 call	 f32_scaledResult
  002d9	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax
$LN21@z900_subtr:
$LN19@z900_subtr:
$LN13@z900_subtr:

; 4972 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4973 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4974 :     }
; 4975 : 
; 4976 :     PUT_FLOAT32_CC( ans, r1, regs );

  002dd	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  002e1	d1 e0		 shl	 eax, 1
  002e3	48 98		 cdqe
  002e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ea	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002f2	48 8b d0	 mov	 rdx, rax
  002f5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ans$[rsp]
  002fa	e8 00 00 00 00	 call	 z900_put_float32
  002ff	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00303	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00308	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0030d	75 17		 jne	 SHORT $LN26@z900_subtr
  0030f	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00313	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00318	85 c0		 test	 eax, eax
  0031a	74 0a		 je	 SHORT $LN26@z900_subtr
  0031c	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv236[rsp], 3
  00324	eb 5e		 jmp	 SHORT $LN33@z900_subtr
$LN26@z900_subtr:
  00326	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  0032a	0f ba f0 1f	 btr	 eax, 31
  0032e	85 c0		 test	 eax, eax
  00330	75 0a		 jne	 SHORT $LN27@z900_subtr
  00332	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
  0033a	eb 08		 jmp	 SHORT $LN28@z900_subtr
$LN27@z900_subtr:
  0033c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv230[rsp], 0
$LN28@z900_subtr:
  00344	83 7c 24 34 00	 cmp	 DWORD PTR tv230[rsp], 0
  00349	74 0a		 je	 SHORT $LN31@z900_subtr
  0034b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv235[rsp], 0
  00353	eb 27		 jmp	 SHORT $LN32@z900_subtr
$LN31@z900_subtr:
  00355	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00359	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0035e	85 c0		 test	 eax, eax
  00360	74 0a		 je	 SHORT $LN29@z900_subtr
  00362	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  0036a	eb 08		 jmp	 SHORT $LN30@z900_subtr
$LN29@z900_subtr:
  0036c	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv233[rsp], 2
$LN30@z900_subtr:
  00374	8b 44 24 38	 mov	 eax, DWORD PTR tv233[rsp]
  00378	89 44 24 3c	 mov	 DWORD PTR tv235[rsp], eax
$LN32@z900_subtr:
  0037c	8b 44 24 3c	 mov	 eax, DWORD PTR tv235[rsp]
  00380	89 44 24 40	 mov	 DWORD PTR tv236[rsp], eax
$LN33@z900_subtr:
  00384	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00389	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv236[rsp]
  0038e	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00391	33 c0		 xor	 eax, eax
  00393	85 c0		 test	 eax, eax
  00395	0f 85 42 ff ff
	ff		 jne	 $LN13@z900_subtr

; 4977 : 
; 4978 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0039b	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0039f	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003a4	85 c0		 test	 eax, eax
  003a6	74 0e		 je	 SHORT $LN22@z900_subtr
  003a8	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN22@z900_subtr:

; 4979 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4980 : }

  003b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003ba	c3		 ret	 0
z900_subtract_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ans$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
effective_addr2$ = 56
tv235 = 64
r1$ = 68
tv251 = 72
tv254 = 76
tv256 = 80
tv257 = 84
op2$ = 88
op1$ = 92
inst$ = 112
regs$ = 120
z900_subtract_bfp_short PROC

; 4986 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4987 :     int        r1, x2, b2;
; 4988 :     VADR       effective_addr2;
; 4989 :     float32_t  op1, op2, ans;
; 4990 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4991 : 
; 4992 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	8b c0		 mov	 eax, eax
  00036	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 22		 je	 SHORT $LN11@z900_subtr
  0005e	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_subtr:
  00080	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0008e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00093	74 22		 je	 SHORT $LN12@z900_subtr
  00095	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_subtr:
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c8	48 23 c8	 and	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_subtr:
  000d3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000dc	48 83 c0 06	 add	 rax, 6
  000e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0c		 je	 SHORT $LN13@z900_subtr
  000f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_subtr:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 d1		 jne	 SHORT $LN4@z900_subtr

; 4993 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00102	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b2$[rsp]
  00107	8b 54 24 30	 mov	 edx, DWORD PTR x2$[rsp]
  0010b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_subtr:

; 4994 :     TXF_FLOAT_INSTR_CHECK( regs );

  00115	33 c0		 xor	 eax, eax
  00117	83 f8 01	 cmp	 eax, 1
  0011a	74 6f		 je	 SHORT $LN14@z900_subtr
  0011c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00128	85 c0		 test	 eax, eax
  0012a	74 5f		 je	 SHORT $LN14@z900_subtr
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 23		 jne	 SHORT $LN15@z900_subtr
  00132	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0013e	85 c0		 test	 eax, eax
  00140	75 13		 jne	 SHORT $LN15@z900_subtr
  00142	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00147	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0014e	83 e0 04	 and	 eax, 4
  00151	85 c0		 test	 eax, eax
  00153	75 36		 jne	 SHORT $LN14@z900_subtr
$LN15@z900_subtr:
  00155	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00160	0f ba e8 0b	 bts	 eax, 11
  00164	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0016f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201398
  00176	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0017c	ba 02 00 00 00	 mov	 edx, 2
  00181	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_subtr:
  0018b	33 c0		 xor	 eax, eax
  0018d	85 c0		 test	 eax, eax
  0018f	75 84		 jne	 SHORT $LN7@z900_subtr

; 4995 :     BFPINST_CHECK( regs );

  00191	b8 08 00 00 00	 mov	 eax, 8
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001a7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 3c		 je	 SHORT $LN17@z900_subtr
  001b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bd	d1 e8		 shr	 eax, 1
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	74 4c		 je	 SHORT $LN16@z900_subtr
  001c6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d2	b9 08 00 00 00	 mov	 ecx, 8
  001d7	48 6b c9 01	 imul	 rcx, rcx, 1
  001db	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001e3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 24		 jne	 SHORT $LN16@z900_subtr
$LN17@z900_subtr:
  001ee	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001f3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001fd	ba 07 00 00 00	 mov	 edx, 7
  00202	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_subtr:

; 4996 : 
; 4997 :     GET_FLOAT32_OP( op1, r1, regs );

  00212	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  00216	d1 e0		 shl	 eax, 1
  00218	48 98		 cdqe
  0021a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00227	48 8b d0	 mov	 rdx, rax
  0022a	48 8d 4c 24 5c	 lea	 rcx, QWORD PTR op1$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_get_float32

; 4998 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00234	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00239	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0023d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00242	e8 00 00 00 00	 call	 z900_vfetch4
  00247	89 44 24 58	 mov	 DWORD PTR op2$[rsp], eax

; 4999 : 
; 5000 :     softfloat_exceptionFlags = 0;

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5001 :     SET_SF_RM_FROM_FPC;

  00269	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0026e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00274	83 e0 07	 and	 eax, 7
  00277	8b c0		 mov	 eax, eax
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00280	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00285	8b d2		 mov	 edx, edx
  00287	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00297	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5002 : 
; 5003 :     ans = f32_sub( op1, op2 );

  002a3	8b 54 24 58	 mov	 edx, DWORD PTR op2$[rsp]
  002a7	8b 4c 24 5c	 mov	 ecx, DWORD PTR op1$[rsp]
  002ab	e8 00 00 00 00	 call	 f32_sub
  002b0	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax

; 5004 : 
; 5005 :     if (softfloat_exceptionFlags)

  002b4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b9	8b c0		 mov	 eax, eax
  002bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ca	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d2	85 c0		 test	 eax, eax
  002d4	0f 84 93 00 00
	00		 je	 $LN18@z900_subtr

; 5006 :     {
; 5007 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002da	33 c0		 xor	 eax, eax
  002dc	83 f8 01	 cmp	 eax, 1
  002df	74 45		 je	 SHORT $LN19@z900_subtr
  002e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e6	8b c0		 mov	 eax, eax
  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ff	83 e0 10	 and	 eax, 16
  00302	85 c0		 test	 eax, eax
  00304	74 20		 je	 SHORT $LN19@z900_subtr
  00306	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0030b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00311	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00316	85 c0		 test	 eax, eax
  00318	74 0c		 je	 SHORT $LN19@z900_subtr
  0031a	b2 80		 mov	 dl, 128			; 00000080H
  0031c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_subtr:

; 5008 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00326	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00330	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5009 : 
; 5010 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00334	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00338	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0033d	85 c0		 test	 eax, eax
  0033f	74 2c		 je	 SHORT $LN20@z900_subtr

; 5011 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00341	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00345	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0034a	85 c0		 test	 eax, eax
  0034c	74 0a		 je	 SHORT $LN23@z900_subtr
  0034e	c7 44 24 40 40
	ff ff ff	 mov	 DWORD PTR tv235[rsp], -192 ; ffffffffffffff40H
  00356	eb 08		 jmp	 SHORT $LN24@z900_subtr
$LN23@z900_subtr:
  00358	c7 44 24 40 c0
	00 00 00	 mov	 DWORD PTR tv235[rsp], 192 ; 000000c0H
$LN24@z900_subtr:
  00360	8b 4c 24 40	 mov	 ecx, DWORD PTR tv235[rsp]
  00364	e8 00 00 00 00	 call	 f32_scaledResult
  00369	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax
$LN20@z900_subtr:
$LN18@z900_subtr:
$LN10@z900_subtr:

; 5012 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 5013 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 5014 :     }
; 5015 : 
; 5016 :     PUT_FLOAT32_CC( ans, r1, regs );

  0036d	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  00371	d1 e0		 shl	 eax, 1
  00373	48 98		 cdqe
  00375	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0037a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00382	48 8b d0	 mov	 rdx, rax
  00385	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ans$[rsp]
  0038a	e8 00 00 00 00	 call	 z900_put_float32
  0038f	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00393	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00398	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0039d	75 17		 jne	 SHORT $LN25@z900_subtr
  0039f	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  003a3	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  003a8	85 c0		 test	 eax, eax
  003aa	74 0a		 je	 SHORT $LN25@z900_subtr
  003ac	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR tv257[rsp], 3
  003b4	eb 5e		 jmp	 SHORT $LN32@z900_subtr
$LN25@z900_subtr:
  003b6	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  003ba	0f ba f0 1f	 btr	 eax, 31
  003be	85 c0		 test	 eax, eax
  003c0	75 0a		 jne	 SHORT $LN26@z900_subtr
  003c2	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv251[rsp], 1
  003ca	eb 08		 jmp	 SHORT $LN27@z900_subtr
$LN26@z900_subtr:
  003cc	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN27@z900_subtr:
  003d4	83 7c 24 48 00	 cmp	 DWORD PTR tv251[rsp], 0
  003d9	74 0a		 je	 SHORT $LN30@z900_subtr
  003db	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv256[rsp], 0
  003e3	eb 27		 jmp	 SHORT $LN31@z900_subtr
$LN30@z900_subtr:
  003e5	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  003e9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003ee	85 c0		 test	 eax, eax
  003f0	74 0a		 je	 SHORT $LN28@z900_subtr
  003f2	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv254[rsp], 1
  003fa	eb 08		 jmp	 SHORT $LN29@z900_subtr
$LN28@z900_subtr:
  003fc	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv254[rsp], 2
$LN29@z900_subtr:
  00404	8b 44 24 4c	 mov	 eax, DWORD PTR tv254[rsp]
  00408	89 44 24 50	 mov	 DWORD PTR tv256[rsp], eax
$LN31@z900_subtr:
  0040c	8b 44 24 50	 mov	 eax, DWORD PTR tv256[rsp]
  00410	89 44 24 54	 mov	 DWORD PTR tv257[rsp], eax
$LN32@z900_subtr:
  00414	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00419	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR tv257[rsp]
  0041e	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00421	33 c0		 xor	 eax, eax
  00423	85 c0		 test	 eax, eax
  00425	0f 85 42 ff ff
	ff		 jne	 $LN10@z900_subtr

; 5017 : 
; 5018 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0042b	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0042f	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00434	85 c0		 test	 eax, eax
  00436	74 0e		 je	 SHORT $LN21@z900_subtr
  00438	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0043c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00441	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_subtr:

; 5019 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 5020 : }

  00446	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0044a	c3		 ret	 0
z900_subtract_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
ans$ = 40
i$1 = 48
tv214 = 52
r1$ = 56
tv230 = 60
tv233 = 64
tv235 = 68
tv236 = 72
r2$ = 76
op2$ = 80
op1$ = 88
inst$ = 112
regs$ = 120
z900_subtract_bfp_long_reg PROC

; 4872 : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4873 :     int        r1, r2;
; 4874 :     float64_t  op1, op2, ans;
; 4875 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4876 : 
; 4877 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_subtr:
  00045	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN14@z900_subtr
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN14@z900_subtr:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_subtr
$LN7@z900_subtr:

; 4878 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN15@z900_subtr
  0007b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN15@z900_subtr
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN16@z900_subtr
  00091	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN16@z900_subtr
  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN15@z900_subtr
$LN16@z900_subtr:
  000b4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201294
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN15@z900_subtr:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_subtr

; 4879 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN18@z900_subtr
  00111	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN17@z900_subtr
  00125	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN17@z900_subtr
$LN18@z900_subtr:
  0014d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_subtr:
$LN10@z900_subtr:

; 4880 : 
; 4881 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00171	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float64
  00193	8b 44 24 4c	 mov	 eax, DWORD PTR r2$[rsp]
  00197	d1 e0		 shl	 eax, 1
  00199	48 98		 cdqe
  0019b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_get_float64
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 b6		 jne	 SHORT $LN10@z900_subtr

; 4882 : 
; 4883 :     softfloat_exceptionFlags = 0;

  001bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c0	8b c0		 mov	 eax, eax
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4884 :     SET_SF_RM_FROM_FPC;

  001d9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001de	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e4	83 e0 07	 and	 eax, 7
  001e7	8b c0		 mov	 eax, eax
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001f0	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001f5	8b d2		 mov	 edx, edx
  001f7	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001fe	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00207	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4885 : 
; 4886 :     ans = f64_sub( op1, op2 );

  00213	48 8b 54 24 50	 mov	 rdx, QWORD PTR op2$[rsp]
  00218	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op1$[rsp]
  0021d	e8 00 00 00 00	 call	 f64_sub
  00222	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax

; 4887 : 
; 4888 :     if (softfloat_exceptionFlags)

  00227	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022c	8b c0		 mov	 eax, eax
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00234	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00241	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00245	85 c0		 test	 eax, eax
  00247	0f 84 94 00 00
	00		 je	 $LN19@z900_subtr

; 4889 :     {
; 4890 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0024d	33 c0		 xor	 eax, eax
  0024f	83 f8 01	 cmp	 eax, 1
  00252	74 45		 je	 SHORT $LN20@z900_subtr
  00254	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00259	8b c0		 mov	 eax, eax
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00261	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00272	83 e0 10	 and	 eax, 16
  00275	85 c0		 test	 eax, eax
  00277	74 20		 je	 SHORT $LN20@z900_subtr
  00279	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0027e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00284	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00289	85 c0		 test	 eax, eax
  0028b	74 0c		 je	 SHORT $LN20@z900_subtr
  0028d	b2 80		 mov	 dl, 128			; 00000080H
  0028f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_subtr:

; 4891 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00299	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002a3	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4892 : 
; 4893 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002a7	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ab	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002b0	85 c0		 test	 eax, eax
  002b2	74 2d		 je	 SHORT $LN21@z900_subtr

; 4894 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002b4	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b8	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002bd	85 c0		 test	 eax, eax
  002bf	74 0a		 je	 SHORT $LN24@z900_subtr
  002c1	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv214[rsp], -1536 ; fffffffffffffa00H
  002c9	eb 08		 jmp	 SHORT $LN25@z900_subtr
$LN24@z900_subtr:
  002cb	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv214[rsp], 1536 ; 00000600H
$LN25@z900_subtr:
  002d3	8b 4c 24 34	 mov	 ecx, DWORD PTR tv214[rsp]
  002d7	e8 00 00 00 00	 call	 f64_scaledResult
  002dc	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax
$LN21@z900_subtr:
$LN19@z900_subtr:
$LN13@z900_subtr:

; 4895 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4896 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4897 :     }
; 4898 : 
; 4899 :     PUT_FLOAT64_CC( ans, r1, regs );

  002e1	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002e5	d1 e0		 shl	 eax, 1
  002e7	48 98		 cdqe
  002e9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002ee	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002f6	48 8b d0	 mov	 rdx, rax
  002f9	48 8d 4c 24 28	 lea	 rcx, QWORD PTR ans$[rsp]
  002fe	e8 00 00 00 00	 call	 z900_put_float64
  00303	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0030d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00312	48 23 c8	 and	 rcx, rax
  00315	48 8b c1	 mov	 rax, rcx
  00318	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00322	48 3b c1	 cmp	 rax, rcx
  00325	75 24		 jne	 SHORT $LN26@z900_subtr
  00327	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00331	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00336	48 23 c8	 and	 rcx, rax
  00339	48 8b c1	 mov	 rax, rcx
  0033c	48 85 c0	 test	 rax, rax
  0033f	74 0a		 je	 SHORT $LN26@z900_subtr
  00341	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR tv236[rsp], 3
  00349	eb 79		 jmp	 SHORT $LN33@z900_subtr
$LN26@z900_subtr:
  0034b	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00355	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  0035a	48 23 c8	 and	 rcx, rax
  0035d	48 8b c1	 mov	 rax, rcx
  00360	48 85 c0	 test	 rax, rax
  00363	75 0a		 jne	 SHORT $LN27@z900_subtr
  00365	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
  0036d	eb 08		 jmp	 SHORT $LN28@z900_subtr
$LN27@z900_subtr:
  0036f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv230[rsp], 0
$LN28@z900_subtr:
  00377	83 7c 24 3c 00	 cmp	 DWORD PTR tv230[rsp], 0
  0037c	74 0a		 je	 SHORT $LN31@z900_subtr
  0037e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv235[rsp], 0
  00386	eb 34		 jmp	 SHORT $LN32@z900_subtr
$LN31@z900_subtr:
  00388	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00392	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00397	48 23 c8	 and	 rcx, rax
  0039a	48 8b c1	 mov	 rax, rcx
  0039d	48 85 c0	 test	 rax, rax
  003a0	74 0a		 je	 SHORT $LN29@z900_subtr
  003a2	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  003aa	eb 08		 jmp	 SHORT $LN30@z900_subtr
$LN29@z900_subtr:
  003ac	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv233[rsp], 2
$LN30@z900_subtr:
  003b4	8b 44 24 40	 mov	 eax, DWORD PTR tv233[rsp]
  003b8	89 44 24 44	 mov	 DWORD PTR tv235[rsp], eax
$LN32@z900_subtr:
  003bc	8b 44 24 44	 mov	 eax, DWORD PTR tv235[rsp]
  003c0	89 44 24 48	 mov	 DWORD PTR tv236[rsp], eax
$LN33@z900_subtr:
  003c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c9	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv236[rsp]
  003ce	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  003d1	33 c0		 xor	 eax, eax
  003d3	85 c0		 test	 eax, eax
  003d5	0f 85 06 ff ff
	ff		 jne	 $LN13@z900_subtr

; 4900 : 
; 4901 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003db	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003df	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003e4	85 c0		 test	 eax, eax
  003e6	74 0e		 je	 SHORT $LN22@z900_subtr
  003e8	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN22@z900_subtr:

; 4902 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4903 : }

  003f6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003fa	c3		 ret	 0
z900_subtract_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
ans$ = 56
tv235 = 64
r1$ = 68
tv251 = 72
tv254 = 76
tv256 = 80
tv257 = 84
op2$ = 88
op1$ = 96
inst$ = 128
regs$ = 136
z900_subtract_bfp_long PROC

; 4909 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4910 :     int        r1, x2, b2;
; 4911 :     VADR       effective_addr2;
; 4912 :     float64_t  op1, op2, ans;
; 4913 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4914 : 
; 4915 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00037	8b c0		 mov	 eax, eax
  00039	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 10	 shr	 eax, 16
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  0004c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00050	c1 e8 14	 shr	 eax, 20
  00053	83 e0 0f	 and	 eax, 15
  00056	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  0005a	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005f	74 25		 je	 SHORT $LN11@z900_subtr
  00061	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00066	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 03 c8	 add	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_subtr:
  00086	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008a	c1 e8 0c	 shr	 eax, 12
  0008d	83 e0 0f	 and	 eax, 15
  00090	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00094	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 25		 je	 SHORT $LN12@z900_subtr
  0009b	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b5	48 03 c8	 add	 rcx, rax
  000b8	48 8b c1	 mov	 rax, rcx
  000bb	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_subtr:
  000c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d4	48 23 c8	 and	 rcx, rax
  000d7	48 8b c1	 mov	 rax, rcx
  000da	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_subtr:
  000df	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000eb	48 83 c0 06	 add	 rax, 6
  000ef	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fb	33 c0		 xor	 eax, eax
  000fd	83 f8 06	 cmp	 eax, 6
  00100	74 0f		 je	 SHORT $LN13@z900_subtr
  00102	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_subtr:
  00111	33 c0		 xor	 eax, eax
  00113	85 c0		 test	 eax, eax
  00115	75 c8		 jne	 SHORT $LN4@z900_subtr

; 4916 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00117	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0011c	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00120	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_subtr:

; 4917 :     TXF_FLOAT_INSTR_CHECK( regs );

  0012d	33 c0		 xor	 eax, eax
  0012f	83 f8 01	 cmp	 eax, 1
  00132	0f 84 81 00 00
	00		 je	 $LN14@z900_subtr
  00138	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00140	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00147	85 c0		 test	 eax, eax
  00149	74 6e		 je	 SHORT $LN14@z900_subtr
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	75 29		 jne	 SHORT $LN15@z900_subtr
  00151	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00160	85 c0		 test	 eax, eax
  00162	75 16		 jne	 SHORT $LN15@z900_subtr
  00164	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00173	83 e0 04	 and	 eax, 4
  00176	85 c0		 test	 eax, eax
  00178	75 3f		 jne	 SHORT $LN14@z900_subtr
$LN15@z900_subtr:
  0017a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00188	0f ba e8 0b	 bts	 eax, 11
  0018c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0019a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201329
  001a1	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a7	ba 02 00 00 00	 mov	 edx, 2
  001ac	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b4	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_subtr:
  001b9	33 c0		 xor	 eax, eax
  001bb	85 c0		 test	 eax, eax
  001bd	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_subtr

; 4918 :     BFPINST_CHECK( regs );

  001c3	b8 08 00 00 00	 mov	 eax, 8
  001c8	48 6b c0 01	 imul	 rax, rax, 1
  001cc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001dc	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e2	48 85 c0	 test	 rax, rax
  001e5	74 42		 je	 SHORT $LN17@z900_subtr
  001e7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f5	d1 e8		 shr	 eax, 1
  001f7	83 e0 01	 and	 eax, 1
  001fa	85 c0		 test	 eax, eax
  001fc	74 58		 je	 SHORT $LN16@z900_subtr
  001fe	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00206	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020d	b9 08 00 00 00	 mov	 ecx, 8
  00212	48 6b c9 01	 imul	 rcx, rcx, 1
  00216	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00224	48 85 c0	 test	 rax, rax
  00227	75 2d		 jne	 SHORT $LN16@z900_subtr
$LN17@z900_subtr:
  00229	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00231	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0023b	ba 07 00 00 00	 mov	 edx, 7
  00240	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00248	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00250	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_subtr:

; 4919 : 
; 4920 :     GET_FLOAT64_OP( op1, r1, regs );

  00256	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  0025a	d1 e0		 shl	 eax, 1
  0025c	48 98		 cdqe
  0025e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00266	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0026e	48 8b d0	 mov	 rdx, rax
  00271	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  00276	e8 00 00 00 00	 call	 z900_get_float64

; 4921 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0027b	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00283	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00287	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0028c	e8 00 00 00 00	 call	 z900_vfetch8
  00291	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 4922 : 
; 4923 :     softfloat_exceptionFlags = 0;

  00296	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0029b	8b c0		 mov	 eax, eax
  0029d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ac	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b0	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4924 :     SET_SF_RM_FROM_FPC;

  002b4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c2	83 e0 07	 and	 eax, 7
  002c5	8b c0		 mov	 eax, eax
  002c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  002d3	8b d2		 mov	 edx, edx
  002d5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  002dc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  002e5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  002e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ed	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4925 : 
; 4926 :     ans = f64_sub( op1, op2 );

  002f1	48 8b 54 24 58	 mov	 rdx, QWORD PTR op2$[rsp]
  002f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  002fb	e8 00 00 00 00	 call	 f64_sub
  00300	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 4927 : 
; 4928 :     if (softfloat_exceptionFlags)

  00305	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0030a	8b c0		 mov	 eax, eax
  0030c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00312	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0031b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00323	85 c0		 test	 eax, eax
  00325	0f 84 9d 00 00
	00		 je	 $LN18@z900_subtr

; 4929 :     {
; 4930 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0032b	33 c0		 xor	 eax, eax
  0032d	83 f8 01	 cmp	 eax, 1
  00330	74 4b		 je	 SHORT $LN19@z900_subtr
  00332	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00337	8b c0		 mov	 eax, eax
  00339	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0033f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00348	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0034c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00350	83 e0 10	 and	 eax, 16
  00353	85 c0		 test	 eax, eax
  00355	74 26		 je	 SHORT $LN19@z900_subtr
  00357	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00365	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0036a	85 c0		 test	 eax, eax
  0036c	74 0f		 je	 SHORT $LN19@z900_subtr
  0036e	b2 80		 mov	 dl, 128			; 00000080H
  00370	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_subtr:

; 4931 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0037d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00385	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0038a	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4932 : 
; 4933 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0038e	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00392	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00397	85 c0		 test	 eax, eax
  00399	74 2d		 je	 SHORT $LN20@z900_subtr

; 4934 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0039b	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0039f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003a4	85 c0		 test	 eax, eax
  003a6	74 0a		 je	 SHORT $LN23@z900_subtr
  003a8	c7 44 24 40 00
	fa ff ff	 mov	 DWORD PTR tv235[rsp], -1536 ; fffffffffffffa00H
  003b0	eb 08		 jmp	 SHORT $LN24@z900_subtr
$LN23@z900_subtr:
  003b2	c7 44 24 40 00
	06 00 00	 mov	 DWORD PTR tv235[rsp], 1536 ; 00000600H
$LN24@z900_subtr:
  003ba	8b 4c 24 40	 mov	 ecx, DWORD PTR tv235[rsp]
  003be	e8 00 00 00 00	 call	 f64_scaledResult
  003c3	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN20@z900_subtr:
$LN18@z900_subtr:
$LN10@z900_subtr:

; 4935 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4936 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4937 :     }
; 4938 : 
; 4939 :     PUT_FLOAT64_CC( ans, r1, regs );

  003c8	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  003cc	d1 e0		 shl	 eax, 1
  003ce	48 98		 cdqe
  003d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003e0	48 8b d0	 mov	 rdx, rax
  003e3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  003e8	e8 00 00 00 00	 call	 z900_put_float64
  003ed	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  003f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ans$[rsp]
  003fc	48 23 c8	 and	 rcx, rax
  003ff	48 8b c1	 mov	 rax, rcx
  00402	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0040c	48 3b c1	 cmp	 rax, rcx
  0040f	75 24		 jne	 SHORT $LN25@z900_subtr
  00411	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0041b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ans$[rsp]
  00420	48 23 c8	 and	 rcx, rax
  00423	48 8b c1	 mov	 rax, rcx
  00426	48 85 c0	 test	 rax, rax
  00429	74 0a		 je	 SHORT $LN25@z900_subtr
  0042b	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR tv257[rsp], 3
  00433	eb 79		 jmp	 SHORT $LN32@z900_subtr
$LN25@z900_subtr:
  00435	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0043f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ans$[rsp]
  00444	48 23 c8	 and	 rcx, rax
  00447	48 8b c1	 mov	 rax, rcx
  0044a	48 85 c0	 test	 rax, rax
  0044d	75 0a		 jne	 SHORT $LN26@z900_subtr
  0044f	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv251[rsp], 1
  00457	eb 08		 jmp	 SHORT $LN27@z900_subtr
$LN26@z900_subtr:
  00459	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN27@z900_subtr:
  00461	83 7c 24 48 00	 cmp	 DWORD PTR tv251[rsp], 0
  00466	74 0a		 je	 SHORT $LN30@z900_subtr
  00468	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv256[rsp], 0
  00470	eb 34		 jmp	 SHORT $LN31@z900_subtr
$LN30@z900_subtr:
  00472	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0047c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ans$[rsp]
  00481	48 23 c8	 and	 rcx, rax
  00484	48 8b c1	 mov	 rax, rcx
  00487	48 85 c0	 test	 rax, rax
  0048a	74 0a		 je	 SHORT $LN28@z900_subtr
  0048c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv254[rsp], 1
  00494	eb 08		 jmp	 SHORT $LN29@z900_subtr
$LN28@z900_subtr:
  00496	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv254[rsp], 2
$LN29@z900_subtr:
  0049e	8b 44 24 4c	 mov	 eax, DWORD PTR tv254[rsp]
  004a2	89 44 24 50	 mov	 DWORD PTR tv256[rsp], eax
$LN31@z900_subtr:
  004a6	8b 44 24 50	 mov	 eax, DWORD PTR tv256[rsp]
  004aa	89 44 24 54	 mov	 DWORD PTR tv257[rsp], eax
$LN32@z900_subtr:
  004ae	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b6	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR tv257[rsp]
  004bb	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  004be	33 c0		 xor	 eax, eax
  004c0	85 c0		 test	 eax, eax
  004c2	0f 85 00 ff ff
	ff		 jne	 $LN10@z900_subtr

; 4940 : 
; 4941 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  004c8	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004cc	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  004d1	85 c0		 test	 eax, eax
  004d3	74 11		 je	 SHORT $LN21@z900_subtr
  004d5	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_subtr:

; 4942 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4943 : }

  004e6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004ea	c3		 ret	 0
z900_subtract_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv234 = 48
tv264 = 52
tv269 = 56
tv271 = 60
tv272 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
ans$ = 144
op2$ = 160
op1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
z900_subtract_bfp_ext_reg PROC

; 4833 : {

$LN37:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4834 :     int         r1, r2;
; 4835 :     float128_t  op1, op2, ans;
; 4836 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4837 : 
; 4838 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_subtr:
  0005f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN14@z900_subtr
  00082	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN14@z900_subtr:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@z900_subtr
$LN7@z900_subtr:

; 4839 :     TXF_FLOAT_INSTR_CHECK( regs );

  00097	33 c0		 xor	 eax, eax
  00099	83 f8 01	 cmp	 eax, 1
  0009c	0f 84 81 00 00
	00		 je	 $LN15@z900_subtr
  000a2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b1	85 c0		 test	 eax, eax
  000b3	74 6e		 je	 SHORT $LN15@z900_subtr
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 29		 jne	 SHORT $LN16@z900_subtr
  000bb	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000ca	85 c0		 test	 eax, eax
  000cc	75 16		 jne	 SHORT $LN16@z900_subtr
  000ce	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000dd	83 e0 04	 and	 eax, 4
  000e0	85 c0		 test	 eax, eax
  000e2	75 3f		 jne	 SHORT $LN15@z900_subtr
$LN16@z900_subtr:
  000e4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f2	0f ba e8 0b	 bts	 eax, 11
  000f6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00104	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201258
  0010b	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN15@z900_subtr:
  00123	33 c0		 xor	 eax, eax
  00125	85 c0		 test	 eax, eax
  00127	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_subtr

; 4840 :     BFPINST_CHECK( regs );

  0012d	b8 08 00 00 00	 mov	 eax, 8
  00132	48 6b c0 01	 imul	 rax, rax, 1
  00136	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00146	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014c	48 85 c0	 test	 rax, rax
  0014f	74 42		 je	 SHORT $LN18@z900_subtr
  00151	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015f	d1 e8		 shr	 eax, 1
  00161	83 e0 01	 and	 eax, 1
  00164	85 c0		 test	 eax, eax
  00166	74 58		 je	 SHORT $LN17@z900_subtr
  00168	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00177	b9 08 00 00 00	 mov	 ecx, 8
  0017c	48 6b c9 01	 imul	 rcx, rcx, 1
  00180	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00188	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018e	48 85 c0	 test	 rax, rax
  00191	75 2d		 jne	 SHORT $LN17@z900_subtr
$LN18@z900_subtr:
  00193	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001a5	ba 07 00 00 00	 mov	 edx, 7
  001aa	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_subtr:

; 4841 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001c0	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001c4	83 e0 02	 and	 eax, 2
  001c7	85 c0		 test	 eax, eax
  001c9	75 0b		 jne	 SHORT $LN20@z900_subtr
  001cb	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001cf	83 e0 02	 and	 eax, 2
  001d2	85 c0		 test	 eax, eax
  001d4	74 1b		 je	 SHORT $LN19@z900_subtr
$LN20@z900_subtr:
  001d6	ba 06 00 00 00	 mov	 edx, 6
  001db	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_subtr:
$LN10@z900_subtr:

; 4842 : 
; 4843 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  001f1	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001f5	d1 e0		 shl	 eax, 1
  001f7	48 98		 cdqe
  001f9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00209	48 8b d0	 mov	 rdx, rax
  0020c	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00214	e8 00 00 00 00	 call	 z900_get_float128
  00219	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0021d	d1 e0		 shl	 eax, 1
  0021f	48 98		 cdqe
  00221	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00231	48 8b d0	 mov	 rdx, rax
  00234	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0023c	e8 00 00 00 00	 call	 z900_get_float128
  00241	33 c0		 xor	 eax, eax
  00243	85 c0		 test	 eax, eax
  00245	75 aa		 jne	 SHORT $LN10@z900_subtr

; 4844 : 
; 4845 :     SET_SF_RM_FROM_FPC;

  00247	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00255	83 e0 07	 and	 eax, 7
  00258	8b c0		 mov	 eax, eax
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00261	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00266	8b d2		 mov	 edx, edx
  00268	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0026f	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00278	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0027c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00280	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4846 :     softfloat_exceptionFlags = 0;

  00284	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00289	8b c0		 mov	 eax, eax
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00291	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029e	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4847 :     SET_SF_RM_FROM_FPC;

  002a2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002aa	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002b0	83 e0 07	 and	 eax, 7
  002b3	8b c0		 mov	 eax, eax
  002b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002bc	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  002c1	8b d2		 mov	 edx, edx
  002c3	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  002ca	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  002d3	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  002d7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002db	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4848 : 
; 4849 :     ans = f128_sub( op1, op2 );

  002df	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  002e4	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  002ec	48 8b f8	 mov	 rdi, rax
  002ef	48 8b f1	 mov	 rsi, rcx
  002f2	b9 10 00 00 00	 mov	 ecx, 16
  002f7	f3 a4		 rep movsb
  002f9	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  002fe	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00306	48 8b f8	 mov	 rdi, rax
  00309	48 8b f1	 mov	 rsi, rcx
  0030c	b9 10 00 00 00	 mov	 ecx, 16
  00311	f3 a4		 rep movsb
  00313	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  00318	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  0031d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  00322	e8 00 00 00 00	 call	 f128_sub
  00327	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0032f	48 8b f9	 mov	 rdi, rcx
  00332	48 8b f0	 mov	 rsi, rax
  00335	b9 10 00 00 00	 mov	 ecx, 16
  0033a	f3 a4		 rep movsb

; 4850 : 
; 4851 :     if (softfloat_exceptionFlags)

  0033c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00341	8b c0		 mov	 eax, eax
  00343	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00349	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00352	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00356	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035a	85 c0		 test	 eax, eax
  0035c	0f 84 b5 00 00
	00		 je	 $LN21@z900_subtr

; 4852 :     {
; 4853 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00362	33 c0		 xor	 eax, eax
  00364	83 f8 01	 cmp	 eax, 1
  00367	74 4b		 je	 SHORT $LN22@z900_subtr
  00369	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0036e	8b c0		 mov	 eax, eax
  00370	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00376	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0037f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00383	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00387	83 e0 10	 and	 eax, 16
  0038a	85 c0		 test	 eax, eax
  0038c	74 26		 je	 SHORT $LN22@z900_subtr
  0038e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00396	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0039c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003a1	85 c0		 test	 eax, eax
  003a3	74 0f		 je	 SHORT $LN22@z900_subtr
  003a5	b2 80		 mov	 dl, 128			; 00000080H
  003a7	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003af	e8 00 00 00 00	 call	 ieee_trap
$LN22@z900_subtr:

; 4854 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  003b4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bc	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003c1	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4855 : 
; 4856 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  003c5	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003c9	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  003ce	85 c0		 test	 eax, eax
  003d0	74 45		 je	 SHORT $LN23@z900_subtr

; 4857 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  003d2	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003d6	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003db	85 c0		 test	 eax, eax
  003dd	74 0a		 je	 SHORT $LN26@z900_subtr
  003df	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv234[rsp], -24576 ; ffffffffffffa000H
  003e7	eb 08		 jmp	 SHORT $LN27@z900_subtr
$LN26@z900_subtr:
  003e9	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv234[rsp], 24576 ; 00006000H
$LN27@z900_subtr:
  003f1	8b 54 24 30	 mov	 edx, DWORD PTR tv234[rsp]
  003f5	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  003fd	e8 00 00 00 00	 call	 f128_scaledResult
  00402	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0040a	48 8b f9	 mov	 rdi, rcx
  0040d	48 8b f0	 mov	 rsi, rax
  00410	b9 10 00 00 00	 mov	 ecx, 16
  00415	f3 a4		 rep movsb
$LN23@z900_subtr:
$LN21@z900_subtr:
$LN13@z900_subtr:

; 4858 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 4859 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 4860 :     }
; 4861 : 
; 4862 :     PUT_FLOAT128_CC( ans, r1, regs );

  00417	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0041b	d1 e0		 shl	 eax, 1
  0041d	48 98		 cdqe
  0041f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00427	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0042f	48 8b d0	 mov	 rdx, rax
  00432	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0043a	e8 00 00 00 00	 call	 z900_put_float128
  0043f	b8 08 00 00 00	 mov	 eax, 8
  00444	48 6b c0 01	 imul	 rax, rax, 1
  00448	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00452	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  0045a	48 23 c1	 and	 rax, rcx
  0045d	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00467	48 3b c1	 cmp	 rax, rcx
  0046a	75 44		 jne	 SHORT $LN29@z900_subtr
  0046c	b8 08 00 00 00	 mov	 eax, 8
  00471	48 6b c0 01	 imul	 rax, rax, 1
  00475	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  0047f	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  00487	48 23 c1	 and	 rax, rcx
  0048a	48 85 c0	 test	 rax, rax
  0048d	75 14		 jne	 SHORT $LN28@z900_subtr
  0048f	b8 08 00 00 00	 mov	 eax, 8
  00494	48 6b c0 00	 imul	 rax, rax, 0
  00498	48 83 bc 04 90
	00 00 00 00	 cmp	 QWORD PTR ans$[rsp+rax], 0
  004a1	74 0d		 je	 SHORT $LN29@z900_subtr
$LN28@z900_subtr:
  004a3	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv272[rsp], 3
  004ab	e9 9c 00 00 00	 jmp	 $LN36@z900_subtr
$LN29@z900_subtr:
  004b0	b8 08 00 00 00	 mov	 eax, 8
  004b5	48 6b c0 01	 imul	 rax, rax, 1
  004b9	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  004c3	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  004cb	48 23 c1	 and	 rax, rcx
  004ce	b9 08 00 00 00	 mov	 ecx, 8
  004d3	48 6b c9 00	 imul	 rcx, rcx, 0
  004d7	48 0b 84 0c 90
	00 00 00	 or	 rax, QWORD PTR ans$[rsp+rcx]
  004df	48 85 c0	 test	 rax, rax
  004e2	75 0a		 jne	 SHORT $LN30@z900_subtr
  004e4	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv264[rsp], 1
  004ec	eb 08		 jmp	 SHORT $LN31@z900_subtr
$LN30@z900_subtr:
  004ee	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv264[rsp], 0
$LN31@z900_subtr:
  004f6	83 7c 24 34 00	 cmp	 DWORD PTR tv264[rsp], 0
  004fb	74 0a		 je	 SHORT $LN34@z900_subtr
  004fd	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv271[rsp], 0
  00505	eb 3d		 jmp	 SHORT $LN35@z900_subtr
$LN34@z900_subtr:
  00507	b8 08 00 00 00	 mov	 eax, 8
  0050c	48 6b c0 01	 imul	 rax, rax, 1
  00510	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0051a	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  00522	48 23 c1	 and	 rax, rcx
  00525	48 85 c0	 test	 rax, rax
  00528	74 0a		 je	 SHORT $LN32@z900_subtr
  0052a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv269[rsp], 1
  00532	eb 08		 jmp	 SHORT $LN33@z900_subtr
$LN32@z900_subtr:
  00534	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv269[rsp], 2
$LN33@z900_subtr:
  0053c	8b 44 24 38	 mov	 eax, DWORD PTR tv269[rsp]
  00540	89 44 24 3c	 mov	 DWORD PTR tv271[rsp], eax
$LN35@z900_subtr:
  00544	8b 44 24 3c	 mov	 eax, DWORD PTR tv271[rsp]
  00548	89 44 24 40	 mov	 DWORD PTR tv272[rsp], eax
$LN36@z900_subtr:
  0054c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00554	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv272[rsp]
  00559	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0055c	33 c0		 xor	 eax, eax
  0055e	85 c0		 test	 eax, eax
  00560	0f 85 b1 fe ff
	ff		 jne	 $LN13@z900_subtr

; 4863 : 
; 4864 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00566	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0056a	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0056f	85 c0		 test	 eax, eax
  00571	74 11		 je	 SHORT $LN24@z900_subtr
  00573	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00577	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN24@z900_subtr:

; 4865 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4866 : }

  00584	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0058c	48 33 cc	 xor	 rcx, rsp
  0058f	e8 00 00 00 00	 call	 __security_check_cookie
  00594	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0059b	5f		 pop	 rdi
  0059c	5e		 pop	 rsi
  0059d	c3		 ret	 0
z900_subtract_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
op2$ = 44
r1$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
z900_squareroot_bfp_short_reg PROC

; 4766 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4767 :     int        r1, r2;
; 4768 :     float32_t  op1, op2;
; 4769 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4770 : 
; 4771 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_squar:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@z900_squar
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_squar:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_squar
$LN7@z900_squar:

; 4772 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN9@z900_squar
  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN9@z900_squar
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN10@z900_squar
  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN10@z900_squar
  000a1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN9@z900_squar
$LN10@z900_squar:
  000b4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201193
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_squar:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_squar

; 4773 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN12@z900_squar
  00111	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN11@z900_squar
  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN11@z900_squar
$LN12@z900_squar:
  0014d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_squar:

; 4774 : 
; 4775 :     GET_FLOAT32_OP( op2, r2, regs );

  00171	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR op2$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float32

; 4776 : 
; 4777 :     softfloat_exceptionFlags = 0;

  00193	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00198	8b c0		 mov	 eax, eax
  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ad	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4778 :     SET_SF_RM_FROM_FPC;

  001b1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001bc	83 e0 07	 and	 eax, 7
  001bf	8b c0		 mov	 eax, eax
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001c8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001cd	8b d2		 mov	 edx, edx
  001cf	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001d6	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001df	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e7	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4779 : 
; 4780 :     op1 = f32_sqrt( op2 );

  001eb	8b 4c 24 2c	 mov	 ecx, DWORD PTR op2$[rsp]
  001ef	e8 00 00 00 00	 call	 f32_sqrt
  001f4	89 44 24 34	 mov	 DWORD PTR op1$[rsp], eax

; 4781 : 
; 4782 :     if (softfloat_exceptionFlags)

  001f8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001fd	8b c0		 mov	 eax, eax
  001ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00205	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0020e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00212	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00216	85 c0		 test	 eax, eax
  00218	0f 84 88 00 00
	00		 je	 $LN13@z900_squar

; 4783 :     {
; 4784 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0021e	33 c0		 xor	 eax, eax
  00220	83 f8 01	 cmp	 eax, 1
  00223	74 45		 je	 SHORT $LN14@z900_squar
  00225	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022a	8b c0		 mov	 eax, eax
  0022c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00232	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00243	83 e0 10	 and	 eax, 16
  00246	85 c0		 test	 eax, eax
  00248	74 20		 je	 SHORT $LN14@z900_squar
  0024a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0024f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00255	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0025a	85 c0		 test	 eax, eax
  0025c	74 0c		 je	 SHORT $LN14@z900_squar
  0025e	b2 80		 mov	 dl, 128			; 00000080H
  00260	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	e8 00 00 00 00	 call	 ieee_trap
$LN14@z900_squar:

; 4785 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  0026a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00275	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  0027a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  0027f	8b c9		 mov	 ecx, ecx
  00281	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00287	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00290	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00294	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00298	c1 e1 1b	 shl	 ecx, 27
  0029b	23 c1		 and	 eax, ecx
  0029d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002a2	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN13@z900_squar:

; 4786 :     }
; 4787 : 
; 4788 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  002a6	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  002aa	d1 e0		 shl	 eax, 1
  002ac	48 98		 cdqe
  002ae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002bb	48 8b d0	 mov	 rdx, rax
  002be	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  002c3	e8 00 00 00 00	 call	 z900_put_float32

; 4789 : 
; 4790 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002c8	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cc	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002d1	85 c0		 test	 eax, eax
  002d3	74 0e		 je	 SHORT $LN15@z900_squar
  002d5	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002de	e8 00 00 00 00	 call	 ieee_cond_trap
$LN15@z900_squar:

; 4791 :     SET_FPC_FLAGS_FROM_SF( regs );

  002e3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e8	8b c0		 mov	 eax, eax
  002ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00301	c1 e0 13	 shl	 eax, 19
  00304	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0030f	c1 e9 08	 shr	 ecx, 8
  00312	f7 d1		 not	 ecx
  00314	23 c1		 and	 eax, ecx
  00316	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0031b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00326	0b c8		 or	 ecx, eax
  00328	8b c1		 mov	 eax, ecx
  0032a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0032f	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4792 : }

  00335	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00339	c3		 ret	 0
z900_squareroot_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
b2$ = 36
x2$ = 40
ieee_trap_conds$ = 44
op2$ = 48
r1$ = 52
op1$ = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_squareroot_bfp_short PROC

; 4798 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4799 :     int        r1, x2, b2;
; 4800 :     VADR       effective_addr2;
; 4801 :     float32_t  op1, op2;
; 4802 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4803 : 
; 4804 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	8b c0		 mov	 eax, eax
  00036	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 22		 je	 SHORT $LN8@z900_squar
  0005e	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_squar:
  00080	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  0008e	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  00093	74 22		 je	 SHORT $LN9@z900_squar
  00095	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_squar:
  000b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c8	48 23 c8	 and	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_squar:
  000d3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000dc	48 83 c0 06	 add	 rax, 6
  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0c		 je	 SHORT $LN10@z900_squar
  000f0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_squar:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 d1		 jne	 SHORT $LN4@z900_squar

; 4805 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00102	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  00107	8b 54 24 28	 mov	 edx, DWORD PTR x2$[rsp]
  0010b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_squar:

; 4806 :     TXF_FLOAT_INSTR_CHECK( regs );

  00115	33 c0		 xor	 eax, eax
  00117	83 f8 01	 cmp	 eax, 1
  0011a	74 6f		 je	 SHORT $LN11@z900_squar
  0011c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00128	85 c0		 test	 eax, eax
  0012a	74 5f		 je	 SHORT $LN11@z900_squar
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 23		 jne	 SHORT $LN12@z900_squar
  00132	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0013e	85 c0		 test	 eax, eax
  00140	75 13		 jne	 SHORT $LN12@z900_squar
  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00147	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0014e	83 e0 04	 and	 eax, 4
  00151	85 c0		 test	 eax, eax
  00153	75 36		 jne	 SHORT $LN11@z900_squar
$LN12@z900_squar:
  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00160	0f ba e8 0b	 bts	 eax, 11
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0016f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201225
  00176	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0017c	ba 02 00 00 00	 mov	 edx, 2
  00181	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_squar:
  0018b	33 c0		 xor	 eax, eax
  0018d	85 c0		 test	 eax, eax
  0018f	75 84		 jne	 SHORT $LN7@z900_squar

; 4807 :     BFPINST_CHECK( regs );

  00191	b8 08 00 00 00	 mov	 eax, 8
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001a7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 3c		 je	 SHORT $LN14@z900_squar
  001b2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bd	d1 e8		 shr	 eax, 1
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	74 4c		 je	 SHORT $LN13@z900_squar
  001c6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d2	b9 08 00 00 00	 mov	 ecx, 8
  001d7	48 6b c9 01	 imul	 rcx, rcx, 1
  001db	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001e3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 24		 jne	 SHORT $LN13@z900_squar
$LN14@z900_squar:
  001ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001fd	ba 07 00 00 00	 mov	 edx, 7
  00202	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_squar:

; 4808 : 
; 4809 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00212	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00217	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  0021b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00220	e8 00 00 00 00	 call	 z900_vfetch4
  00225	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 4810 : 
; 4811 :     softfloat_exceptionFlags = 0;

  00229	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022e	8b c0		 mov	 eax, eax
  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00236	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00243	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4812 :     SET_SF_RM_FROM_FPC;

  00247	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00252	83 e0 07	 and	 eax, 7
  00255	8b c0		 mov	 eax, eax
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0025e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00263	8b d2		 mov	 edx, edx
  00265	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0026c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00275	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00279	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4813 : 
; 4814 :     op1 = f32_sqrt( op2 );

  00281	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  00285	e8 00 00 00 00	 call	 f32_sqrt
  0028a	89 44 24 38	 mov	 DWORD PTR op1$[rsp], eax

; 4815 : 
; 4816 :     if (softfloat_exceptionFlags)

  0028e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00293	8b c0		 mov	 eax, eax
  00295	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ac	85 c0		 test	 eax, eax
  002ae	0f 84 88 00 00
	00		 je	 $LN15@z900_squar

; 4817 :     {
; 4818 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002b4	33 c0		 xor	 eax, eax
  002b6	83 f8 01	 cmp	 eax, 1
  002b9	74 45		 je	 SHORT $LN16@z900_squar
  002bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c0	8b c0		 mov	 eax, eax
  002c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d9	83 e0 10	 and	 eax, 16
  002dc	85 c0		 test	 eax, eax
  002de	74 20		 je	 SHORT $LN16@z900_squar
  002e0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002e5	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002eb	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002f0	85 c0		 test	 eax, eax
  002f2	74 0c		 je	 SHORT $LN16@z900_squar
  002f4	b2 80		 mov	 dl, 128			; 00000080H
  002f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fb	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_squar:

; 4819 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  00300	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00305	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0030b	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00310	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  00315	8b c9		 mov	 ecx, ecx
  00317	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0031d	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00326	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  0032a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0032e	c1 e1 1b	 shl	 ecx, 27
  00331	23 c1		 and	 eax, ecx
  00333	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00338	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN15@z900_squar:

; 4820 :     }
; 4821 : 
; 4822 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  0033c	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00340	d1 e0		 shl	 eax, 1
  00342	48 98		 cdqe
  00344	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00349	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00351	48 8b d0	 mov	 rdx, rax
  00354	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00359	e8 00 00 00 00	 call	 z900_put_float32

; 4823 : 
; 4824 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0035e	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00362	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00367	85 c0		 test	 eax, eax
  00369	74 0e		 je	 SHORT $LN17@z900_squar
  0036b	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0036f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00374	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@z900_squar:

; 4825 :     SET_FPC_FLAGS_FROM_SF( regs );

  00379	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0037e	8b c0		 mov	 eax, eax
  00380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00386	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	c1 e0 13	 shl	 eax, 19
  0039a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0039f	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003a5	c1 e9 08	 shr	 ecx, 8
  003a8	f7 d1		 not	 ecx
  003aa	23 c1		 and	 eax, ecx
  003ac	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  003b1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b6	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003bc	0b c8		 or	 ecx, eax
  003be	8b c1		 mov	 eax, ecx
  003c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003c5	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4826 : }

  003cb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003cf	c3		 ret	 0
z900_squareroot_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
z900_squareroot_bfp_long_reg PROC

; 4700 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4701 :     int        r1, r2;
; 4702 :     float64_t  op1, op2;
; 4703 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4704 : 
; 4705 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_squar:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@z900_squar
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_squar:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_squar
$LN7@z900_squar:

; 4706 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN9@z900_squar
  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN9@z900_squar
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN10@z900_squar
  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN10@z900_squar
  000a1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN9@z900_squar
$LN10@z900_squar:
  000b4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201133
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_squar:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_squar

; 4707 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN12@z900_squar
  00111	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN11@z900_squar
  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN11@z900_squar
$LN12@z900_squar:
  0014d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_squar:

; 4708 : 
; 4709 :     GET_FLOAT64_OP( op2, r2, regs );

  00171	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float64

; 4710 : 
; 4711 :     softfloat_exceptionFlags = 0;

  00193	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00198	8b c0		 mov	 eax, eax
  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ad	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4712 :     SET_SF_RM_FROM_FPC;

  001b1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001bc	83 e0 07	 and	 eax, 7
  001bf	8b c0		 mov	 eax, eax
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001c8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001cd	8b d2		 mov	 edx, edx
  001cf	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001d6	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001df	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e7	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4713 : 
; 4714 :     op1 = f64_sqrt( op2 );

  001eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  001f0	e8 00 00 00 00	 call	 f64_sqrt
  001f5	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 4715 : 
; 4716 :     if (softfloat_exceptionFlags)

  001fa	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ff	8b c0		 mov	 eax, eax
  00201	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00207	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00210	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00214	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00218	85 c0		 test	 eax, eax
  0021a	0f 84 88 00 00
	00		 je	 $LN13@z900_squar

; 4717 :     {
; 4718 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00220	33 c0		 xor	 eax, eax
  00222	83 f8 01	 cmp	 eax, 1
  00225	74 45		 je	 SHORT $LN14@z900_squar
  00227	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022c	8b c0		 mov	 eax, eax
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00234	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00241	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00245	83 e0 10	 and	 eax, 16
  00248	85 c0		 test	 eax, eax
  0024a	74 20		 je	 SHORT $LN14@z900_squar
  0024c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00251	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00257	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0025c	85 c0		 test	 eax, eax
  0025e	74 0c		 je	 SHORT $LN14@z900_squar
  00260	b2 80		 mov	 dl, 128			; 00000080H
  00262	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00267	e8 00 00 00 00	 call	 ieee_trap
$LN14@z900_squar:

; 4719 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  0026c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00271	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00277	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  0027c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  00281	8b c9		 mov	 ecx, ecx
  00283	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00289	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00292	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00296	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0029a	c1 e1 1b	 shl	 ecx, 27
  0029d	23 c1		 and	 eax, ecx
  0029f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002a4	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN13@z900_squar:

; 4720 :     }
; 4721 : 
; 4722 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  002a8	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002ac	d1 e0		 shl	 eax, 1
  002ae	48 98		 cdqe
  002b0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002b5	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002bd	48 8b d0	 mov	 rdx, rax
  002c0	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  002c5	e8 00 00 00 00	 call	 z900_put_float64

; 4723 : 
; 4724 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002ca	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ce	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002d3	85 c0		 test	 eax, eax
  002d5	74 0e		 je	 SHORT $LN15@z900_squar
  002d7	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002e0	e8 00 00 00 00	 call	 ieee_cond_trap
$LN15@z900_squar:

; 4725 :     SET_FPC_FLAGS_FROM_SF( regs );

  002e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ea	8b c0		 mov	 eax, eax
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00303	c1 e0 13	 shl	 eax, 19
  00306	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0030b	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00311	c1 e9 08	 shr	 ecx, 8
  00314	f7 d1		 not	 ecx
  00316	23 c1		 and	 eax, ecx
  00318	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0031d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00322	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00328	0b c8		 or	 ecx, eax
  0032a	8b c1		 mov	 eax, ecx
  0032c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4726 : }

  00337	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0033b	c3		 ret	 0
z900_squareroot_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
b2$ = 36
x2$ = 40
ieee_trap_conds$ = 44
r1$ = 48
effective_addr2$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
z900_squareroot_bfp_long PROC

; 4732 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4733 :     int        r1, x2, b2;
; 4734 :     VADR       effective_addr2;
; 4735 :     float64_t  op1, op2;
; 4736 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4737 : 
; 4738 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	8b c0		 mov	 eax, eax
  00036	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 22		 je	 SHORT $LN8@z900_squar
  0005e	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_squar:
  00080	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  0008e	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  00093	74 22		 je	 SHORT $LN9@z900_squar
  00095	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_squar:
  000b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c8	48 23 c8	 and	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_squar:
  000d3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000dc	48 83 c0 06	 add	 rax, 6
  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0c		 je	 SHORT $LN10@z900_squar
  000f0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_squar:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 d1		 jne	 SHORT $LN4@z900_squar

; 4739 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00102	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  00107	8b 54 24 28	 mov	 edx, DWORD PTR x2$[rsp]
  0010b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_squar:

; 4740 :     TXF_FLOAT_INSTR_CHECK( regs );

  00115	33 c0		 xor	 eax, eax
  00117	83 f8 01	 cmp	 eax, 1
  0011a	74 6f		 je	 SHORT $LN11@z900_squar
  0011c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00128	85 c0		 test	 eax, eax
  0012a	74 5f		 je	 SHORT $LN11@z900_squar
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 23		 jne	 SHORT $LN12@z900_squar
  00132	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0013e	85 c0		 test	 eax, eax
  00140	75 13		 jne	 SHORT $LN12@z900_squar
  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00147	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0014e	83 e0 04	 and	 eax, 4
  00151	85 c0		 test	 eax, eax
  00153	75 36		 jne	 SHORT $LN11@z900_squar
$LN12@z900_squar:
  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00160	0f ba e8 0b	 bts	 eax, 11
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0016f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201165
  00176	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0017c	ba 02 00 00 00	 mov	 edx, 2
  00181	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_squar:
  0018b	33 c0		 xor	 eax, eax
  0018d	85 c0		 test	 eax, eax
  0018f	75 84		 jne	 SHORT $LN7@z900_squar

; 4741 :     BFPINST_CHECK( regs );

  00191	b8 08 00 00 00	 mov	 eax, 8
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001a7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 3c		 je	 SHORT $LN14@z900_squar
  001b2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bd	d1 e8		 shr	 eax, 1
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	74 4c		 je	 SHORT $LN13@z900_squar
  001c6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d2	b9 08 00 00 00	 mov	 ecx, 8
  001d7	48 6b c9 01	 imul	 rcx, rcx, 1
  001db	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001e3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 24		 jne	 SHORT $LN13@z900_squar
$LN14@z900_squar:
  001ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001fd	ba 07 00 00 00	 mov	 edx, 7
  00202	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_squar:

; 4742 : 
; 4743 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00212	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00217	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  0021b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00220	e8 00 00 00 00	 call	 z900_vfetch8
  00225	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 4744 : 
; 4745 :     softfloat_exceptionFlags = 0;

  0022a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022f	8b c0		 mov	 eax, eax
  00231	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00237	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00240	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00244	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4746 :     SET_SF_RM_FROM_FPC;

  00248	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00253	83 e0 07	 and	 eax, 7
  00256	8b c0		 mov	 eax, eax
  00258	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0025f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00264	8b d2		 mov	 edx, edx
  00266	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0026d	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00276	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0027a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027e	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4747 : 
; 4748 :     op1 = f64_sqrt( op2 );

  00282	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  00287	e8 00 00 00 00	 call	 f64_sqrt
  0028c	48 89 44 24 48	 mov	 QWORD PTR op1$[rsp], rax

; 4749 : 
; 4750 :     if (softfloat_exceptionFlags)

  00291	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00296	8b c0		 mov	 eax, eax
  00298	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ab	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002af	85 c0		 test	 eax, eax
  002b1	0f 84 88 00 00
	00		 je	 $LN15@z900_squar

; 4751 :     {
; 4752 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002b7	33 c0		 xor	 eax, eax
  002b9	83 f8 01	 cmp	 eax, 1
  002bc	74 45		 je	 SHORT $LN16@z900_squar
  002be	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c3	8b c0		 mov	 eax, eax
  002c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002cb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002dc	83 e0 10	 and	 eax, 16
  002df	85 c0		 test	 eax, eax
  002e1	74 20		 je	 SHORT $LN16@z900_squar
  002e3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002e8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ee	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002f3	85 c0		 test	 eax, eax
  002f5	74 0c		 je	 SHORT $LN16@z900_squar
  002f7	b2 80		 mov	 dl, 128			; 00000080H
  002f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fe	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_squar:

; 4753 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  00303	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00308	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0030e	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00313	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  00318	8b c9		 mov	 ecx, ecx
  0031a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00320	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00329	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  0032d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00331	c1 e1 1b	 shl	 ecx, 27
  00334	23 c1		 and	 eax, ecx
  00336	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0033b	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN15@z900_squar:

; 4754 :     }
; 4755 : 
; 4756 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  0033f	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00343	d1 e0		 shl	 eax, 1
  00345	48 98		 cdqe
  00347	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00354	48 8b d0	 mov	 rdx, rax
  00357	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0035c	e8 00 00 00 00	 call	 z900_put_float64

; 4757 : 
; 4758 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00361	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00365	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0036a	85 c0		 test	 eax, eax
  0036c	74 0e		 je	 SHORT $LN17@z900_squar
  0036e	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00372	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00377	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@z900_squar:

; 4759 :     SET_FPC_FLAGS_FROM_SF( regs );

  0037c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00381	8b c0		 mov	 eax, eax
  00383	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00389	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00392	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00396	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039a	c1 e0 13	 shl	 eax, 19
  0039d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003a2	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003a8	c1 e9 08	 shr	 ecx, 8
  003ab	f7 d1		 not	 ecx
  003ad	23 c1		 and	 eax, ecx
  003af	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  003b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003bf	0b c8		 or	 ecx, eax
  003c1	8b c1		 mov	 eax, ecx
  003c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003c8	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4760 : }

  003ce	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003d2	c3		 ret	 0
z900_squareroot_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
z900_squareroot_bfp_ext_reg PROC

; 4667 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4668 :     int         r1, r2;
; 4669 :     float128_t  op1, op2;
; 4670 :     U32         ieee_trap_conds = 0;

  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4671 : 
; 4672 :     RRE( inst, regs, r1, r2 );

  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 03	 imul	 rax, rax, 3
  00033	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003f	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0004e	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00052	c1 f8 04	 sar	 eax, 4
  00055	83 e0 0f	 and	 eax, 15
  00058	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_squar:
  0005c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0f		 je	 SHORT $LN8@z900_squar
  0007f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_squar:
  0008e	33 c0		 xor	 eax, eax
  00090	85 c0		 test	 eax, eax
  00092	75 c8		 jne	 SHORT $LN4@z900_squar
$LN7@z900_squar:

; 4673 :     TXF_FLOAT_INSTR_CHECK( regs );

  00094	33 c0		 xor	 eax, eax
  00096	83 f8 01	 cmp	 eax, 1
  00099	0f 84 81 00 00
	00		 je	 $LN9@z900_squar
  0009f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000ae	85 c0		 test	 eax, eax
  000b0	74 6e		 je	 SHORT $LN9@z900_squar
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 29		 jne	 SHORT $LN10@z900_squar
  000b8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c7	85 c0		 test	 eax, eax
  000c9	75 16		 jne	 SHORT $LN10@z900_squar
  000cb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000da	83 e0 04	 and	 eax, 4
  000dd	85 c0		 test	 eax, eax
  000df	75 3f		 jne	 SHORT $LN9@z900_squar
$LN10@z900_squar:
  000e1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ef	0f ba e8 0b	 bts	 eax, 11
  000f3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fb	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00101	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201103
  00108	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0010e	ba 02 00 00 00	 mov	 edx, 2
  00113	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_squar:
  00120	33 c0		 xor	 eax, eax
  00122	85 c0		 test	 eax, eax
  00124	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_squar

; 4674 :     BFPINST_CHECK( regs );

  0012a	b8 08 00 00 00	 mov	 eax, 8
  0012f	48 6b c0 01	 imul	 rax, rax, 1
  00133	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00143	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00149	48 85 c0	 test	 rax, rax
  0014c	74 42		 je	 SHORT $LN12@z900_squar
  0014e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00156	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015c	d1 e8		 shr	 eax, 1
  0015e	83 e0 01	 and	 eax, 1
  00161	85 c0		 test	 eax, eax
  00163	74 58		 je	 SHORT $LN11@z900_squar
  00165	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	48 6b c9 01	 imul	 rcx, rcx, 1
  0017d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00185	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018b	48 85 c0	 test	 rax, rax
  0018e	75 2d		 jne	 SHORT $LN11@z900_squar
$LN12@z900_squar:
  00190	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001a2	ba 07 00 00 00	 mov	 edx, 7
  001a7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001af	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_squar:

; 4675 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001bd	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001c1	83 e0 02	 and	 eax, 2
  001c4	85 c0		 test	 eax, eax
  001c6	75 0b		 jne	 SHORT $LN14@z900_squar
  001c8	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001cc	83 e0 02	 and	 eax, 2
  001cf	85 c0		 test	 eax, eax
  001d1	74 1b		 je	 SHORT $LN13@z900_squar
$LN14@z900_squar:
  001d3	ba 06 00 00 00	 mov	 edx, 6
  001d8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_squar:

; 4676 : 
; 4677 :     GET_FLOAT128_OP( op2, r2, regs );

  001ee	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001f2	d1 e0		 shl	 eax, 1
  001f4	48 98		 cdqe
  001f6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00206	48 8b d0	 mov	 rdx, rax
  00209	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0020e	e8 00 00 00 00	 call	 z900_get_float128

; 4678 : 
; 4679 :     softfloat_exceptionFlags = 0;

  00213	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00218	8b c0		 mov	 eax, eax
  0021a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00220	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00229	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022d	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4680 :     SET_SF_RM_FROM_FPC;

  00231	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00239	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0023f	83 e0 07	 and	 eax, 7
  00242	8b c0		 mov	 eax, eax
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0024b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00250	8b d2		 mov	 edx, edx
  00252	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00259	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00262	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00266	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026a	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4681 : 
; 4682 :     op1 = f128_sqrt( op2 );

  0026e	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00273	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  00278	48 8b f8	 mov	 rdi, rax
  0027b	48 8b f1	 mov	 rsi, rcx
  0027e	b9 10 00 00 00	 mov	 ecx, 16
  00283	f3 a4		 rep movsb
  00285	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  0028a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0028f	e8 00 00 00 00	 call	 f128_sqrt
  00294	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  00299	48 8b f9	 mov	 rdi, rcx
  0029c	48 8b f0	 mov	 rsi, rax
  0029f	b9 10 00 00 00	 mov	 ecx, 16
  002a4	f3 a4		 rep movsb

; 4683 : 
; 4684 :     if (softfloat_exceptionFlags)

  002a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ab	8b c0		 mov	 eax, eax
  002ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002bc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c4	85 c0		 test	 eax, eax
  002c6	0f 84 91 00 00
	00		 je	 $LN15@z900_squar

; 4685 :     {
; 4686 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002cc	33 c0		 xor	 eax, eax
  002ce	83 f8 01	 cmp	 eax, 1
  002d1	74 4b		 je	 SHORT $LN16@z900_squar
  002d3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d8	8b c0		 mov	 eax, eax
  002da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ed	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f1	83 e0 10	 and	 eax, 16
  002f4	85 c0		 test	 eax, eax
  002f6	74 26		 je	 SHORT $LN16@z900_squar
  002f8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00300	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00306	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0030b	85 c0		 test	 eax, eax
  0030d	74 0f		 je	 SHORT $LN16@z900_squar
  0030f	b2 80		 mov	 dl, 128			; 00000080H
  00311	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_squar:

; 4687 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  0031e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00326	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0032c	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00331	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  00336	8b c9		 mov	 ecx, ecx
  00338	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0033e	65 48 8b 3c 25
	58 00 00 00	 mov	 rdi, QWORD PTR gs:88
  00347	48 8b 14 d7	 mov	 rdx, QWORD PTR [rdi+rdx*8]
  0034b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0034f	c1 e1 1b	 shl	 ecx, 27
  00352	23 c1		 and	 eax, ecx
  00354	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00359	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN15@z900_squar:

; 4688 :     }
; 4689 : 
; 4690 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0035d	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00361	d1 e0		 shl	 eax, 1
  00363	48 98		 cdqe
  00365	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00375	48 8b d0	 mov	 rdx, rax
  00378	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  0037d	e8 00 00 00 00	 call	 z900_put_float128

; 4691 : 
; 4692 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00382	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00386	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0038b	85 c0		 test	 eax, eax
  0038d	74 11		 je	 SHORT $LN17@z900_squar
  0038f	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00393	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039b	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@z900_squar:

; 4693 :     SET_FPC_FLAGS_FROM_SF( regs );

  003a0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003a5	8b c0		 mov	 eax, eax
  003a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003ad	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003b6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003be	c1 e0 13	 shl	 eax, 19
  003c1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003cf	c1 e9 08	 shr	 ecx, 8
  003d2	f7 d1		 not	 ecx
  003d4	23 c1		 and	 eax, ecx
  003d6	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  003db	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e3	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003e9	0b c8		 or	 ecx, eax
  003eb	8b c1		 mov	 eax, ecx
  003ed	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f5	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4694 : }

  003fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00400	48 33 cc	 xor	 rcx, rsp
  00403	e8 00 00 00 00	 call	 __security_check_cookie
  00408	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0040f	5f		 pop	 rdi
  00410	5e		 pop	 rsi
  00411	c3		 ret	 0
z900_squareroot_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
tv232 = 44
r1$ = 48
ans$ = 52
r3$ = 56
r2$ = 60
op3$ = 64
op2$ = 68
inst$ = 96
regs$ = 104
z900_multiply_subtract_bfp_short_reg PROC

; 4575 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4576 :     int        r1, r2, r3;
; 4577 :     float32_t  op1, op2, op3, ans;
; 4578 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4579 : 
; 4580 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 3c	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN11@z900_multi
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4581 :     TXF_FLOAT_INSTR_CHECK( regs );

  00081	33 c0		 xor	 eax, eax
  00083	83 f8 01	 cmp	 eax, 1
  00086	74 6f		 je	 SHORT $LN12@z900_multi
  00088	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00094	85 c0		 test	 eax, eax
  00096	74 5f		 je	 SHORT $LN12@z900_multi
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 23		 jne	 SHORT $LN13@z900_multi
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000aa	85 c0		 test	 eax, eax
  000ac	75 13		 jne	 SHORT $LN13@z900_multi
  000ae	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b3	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ba	83 e0 04	 and	 eax, 4
  000bd	85 c0		 test	 eax, eax
  000bf	75 36		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000cc	0f ba e8 0b	 bts	 eax, 11
  000d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201033
  000e2	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e8	ba 02 00 00 00	 mov	 edx, 2
  000ed	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  000f7	33 c0		 xor	 eax, eax
  000f9	85 c0		 test	 eax, eax
  000fb	75 84		 jne	 SHORT $LN7@z900_multi

; 4582 :     BFPINST_CHECK( regs );

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00113	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00119	48 85 c0	 test	 rax, rax
  0011c	74 3c		 je	 SHORT $LN15@z900_multi
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00129	d1 e8		 shr	 eax, 1
  0012b	83 e0 01	 and	 eax, 1
  0012e	85 c0		 test	 eax, eax
  00130	74 4c		 je	 SHORT $LN14@z900_multi
  00132	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013e	b9 08 00 00 00	 mov	 ecx, 8
  00143	48 6b c9 01	 imul	 rcx, rcx, 1
  00147	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0014f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00155	48 85 c0	 test	 rax, rax
  00158	75 24		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0015a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00169	ba 07 00 00 00	 mov	 edx, 7
  0016e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00178	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:
$LN10@z900_multi:

; 4583 : 
; 4584 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  0017e	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00182	d1 e0		 shl	 eax, 1
  00184	48 98		 cdqe
  00186	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00193	48 8b d0	 mov	 rdx, rax
  00196	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 z900_get_float32
  001a0	8b 44 24 38	 mov	 eax, DWORD PTR r3$[rsp]
  001a4	d1 e0		 shl	 eax, 1
  001a6	48 98		 cdqe
  001a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ad	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b5	48 8b d0	 mov	 rdx, rax
  001b8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op3$[rsp]
  001bd	e8 00 00 00 00	 call	 z900_get_float32
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	75 b6		 jne	 SHORT $LN10@z900_multi

; 4585 :     GET_FLOAT32_OP( op2, r2, regs );

  001c8	8b 44 24 3c	 mov	 eax, DWORD PTR r2$[rsp]
  001cc	d1 e0		 shl	 eax, 1
  001ce	48 98		 cdqe
  001d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001d5	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001dd	48 8b d0	 mov	 rdx, rax
  001e0	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op2$[rsp]
  001e5	e8 00 00 00 00	 call	 z900_get_float32

; 4586 : 
; 4587 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4588 :     if (0
; 4589 :         || !(op1.v & 0x007FFFFF)
; 4590 :         || ((op1.v & 0x7F800000) ^ 0x7F800000)

  001ea	33 c0		 xor	 eax, eax
  001ec	85 c0		 test	 eax, eax
  001ee	75 1f		 jne	 SHORT $LN17@z900_multi
  001f0	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  001f4	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001f9	85 c0		 test	 eax, eax
  001fb	74 12		 je	 SHORT $LN17@z900_multi
  001fd	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  00201	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00206	35 00 00 80 7f	 xor	 eax, 2139095040		; 7f800000H
  0020b	85 c0		 test	 eax, eax
  0020d	74 0c		 je	 SHORT $LN16@z900_multi
$LN17@z900_multi:

; 4591 :     )
; 4592 :         op1.v ^= 0x80000000;

  0020f	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  00213	0f ba f8 1f	 btc	 eax, 31
  00217	89 44 24 20	 mov	 DWORD PTR op1$[rsp], eax
$LN16@z900_multi:

; 4593 : 
; 4594 :     softfloat_exceptionFlags = 0;

  0021b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00220	8b c0		 mov	 eax, eax
  00222	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00228	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00231	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00235	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4595 :     SET_SF_RM_FROM_FPC;

  00239	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0023e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00244	83 e0 07	 and	 eax, 7
  00247	8b c0		 mov	 eax, eax
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00250	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00255	8b d2		 mov	 edx, edx
  00257	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0025e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00267	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0026b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4596 : 
; 4597 :     ans = f32_mulAdd( op2, op3, op1 );

  00273	44 8b 44 24 20	 mov	 r8d, DWORD PTR op1$[rsp]
  00278	8b 54 24 40	 mov	 edx, DWORD PTR op3$[rsp]
  0027c	8b 4c 24 44	 mov	 ecx, DWORD PTR op2$[rsp]
  00280	e8 00 00 00 00	 call	 f32_mulAdd
  00285	89 44 24 34	 mov	 DWORD PTR ans$[rsp], eax

; 4598 : 
; 4599 :     if (softfloat_exceptionFlags)

  00289	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0028e	8b c0		 mov	 eax, eax
  00290	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00296	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a7	85 c0		 test	 eax, eax
  002a9	0f 84 93 00 00
	00		 je	 $LN18@z900_multi

; 4600 :     {
; 4601 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002af	33 c0		 xor	 eax, eax
  002b1	83 f8 01	 cmp	 eax, 1
  002b4	74 45		 je	 SHORT $LN19@z900_multi
  002b6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002bb	8b c0		 mov	 eax, eax
  002bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002cc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d4	83 e0 10	 and	 eax, 16
  002d7	85 c0		 test	 eax, eax
  002d9	74 20		 je	 SHORT $LN19@z900_multi
  002db	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002e0	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002e6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002eb	85 c0		 test	 eax, eax
  002ed	74 0c		 je	 SHORT $LN19@z900_multi
  002ef	b2 80		 mov	 dl, 128			; 00000080H
  002f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f6	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_multi:

; 4602 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00300	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00305	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4603 : 
; 4604 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00309	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0030d	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00312	85 c0		 test	 eax, eax
  00314	74 2c		 je	 SHORT $LN20@z900_multi

; 4605 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00316	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0031a	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0031f	85 c0		 test	 eax, eax
  00321	74 0a		 je	 SHORT $LN23@z900_multi
  00323	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv232[rsp], -192 ; ffffffffffffff40H
  0032b	eb 08		 jmp	 SHORT $LN24@z900_multi
$LN23@z900_multi:
  0032d	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv232[rsp], 192 ; 000000c0H
$LN24@z900_multi:
  00335	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv232[rsp]
  00339	e8 00 00 00 00	 call	 f32_scaledResult
  0033e	89 44 24 34	 mov	 DWORD PTR ans$[rsp], eax
$LN20@z900_multi:
$LN18@z900_multi:

; 4606 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4607 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4608 :     }
; 4609 : 
; 4610 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  00342	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00346	d1 e0		 shl	 eax, 1
  00348	48 98		 cdqe
  0034a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0034f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00357	48 8b d0	 mov	 rdx, rax
  0035a	48 8d 4c 24 34	 lea	 rcx, QWORD PTR ans$[rsp]
  0035f	e8 00 00 00 00	 call	 z900_put_float32

; 4611 : 
; 4612 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00364	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00368	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0036d	85 c0		 test	 eax, eax
  0036f	74 0e		 je	 SHORT $LN21@z900_multi
  00371	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00375	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0037a	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_multi:

; 4613 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4614 : }

  0037f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00383	c3		 ret	 0
z900_multiply_subtract_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
effective_addr2$ = 56
tv255 = 64
r1$ = 68
ans$ = 72
r3$ = 76
op3$ = 80
op2$ = 84
inst$ = 112
regs$ = 120
z900_multiply_subtract_bfp_short PROC

; 4620 : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4621 :     int        x2, r1, r3, b2;
; 4622 :     VADR       effective_addr2;
; 4623 :     float32_t  op1, op2, op3, ans;
; 4624 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4625 : 
; 4626 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 04	 imul	 rax, rax, 4
  00034	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	c1 f8 04	 sar	 eax, 4
  00040	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	8b c0		 mov	 eax, eax
  0004f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 10	 shr	 eax, 16
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00062	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 14	 shr	 eax, 20
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 4c	 mov	 DWORD PTR r3$[rsp], eax
  00070	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00075	74 22		 je	 SHORT $LN11@z900_multi
  00077	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0007c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00089	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0008e	48 03 c8	 add	 rcx, rax
  00091	48 8b c1	 mov	 rax, rcx
  00094	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_multi:
  00099	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0009d	c1 e8 0c	 shr	 eax, 12
  000a0	83 e0 0f	 and	 eax, 15
  000a3	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  000a7	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ac	74 22		 je	 SHORT $LN12@z900_multi
  000ae	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000c0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c5	48 03 c8	 add	 rcx, rax
  000c8	48 8b c1	 mov	 rax, rcx
  000cb	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_multi:
  000d0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000dc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e1	48 23 c8	 and	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_multi:
  000ec	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f5	48 83 c0 06	 add	 rax, 6
  000f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00102	33 c0		 xor	 eax, eax
  00104	83 f8 06	 cmp	 eax, 6
  00107	74 0c		 je	 SHORT $LN13@z900_multi
  00109	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_multi:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	75 d1		 jne	 SHORT $LN4@z900_multi

; 4627 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  0011b	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b2$[rsp]
  00120	8b 54 24 30	 mov	 edx, DWORD PTR x2$[rsp]
  00124	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00129	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 4628 :     TXF_FLOAT_INSTR_CHECK( regs );

  0012e	33 c0		 xor	 eax, eax
  00130	83 f8 01	 cmp	 eax, 1
  00133	74 6f		 je	 SHORT $LN14@z900_multi
  00135	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00141	85 c0		 test	 eax, eax
  00143	74 5f		 je	 SHORT $LN14@z900_multi
  00145	33 c0		 xor	 eax, eax
  00147	85 c0		 test	 eax, eax
  00149	75 23		 jne	 SHORT $LN15@z900_multi
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00157	85 c0		 test	 eax, eax
  00159	75 13		 jne	 SHORT $LN15@z900_multi
  0015b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00160	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00167	83 e0 04	 and	 eax, 4
  0016a	85 c0		 test	 eax, eax
  0016c	75 36		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0016e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00173	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00179	0f ba e8 0b	 bts	 eax, 11
  0017d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00188	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201072
  0018f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00195	ba 02 00 00 00	 mov	 edx, 2
  0019a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_multi:
  001a4	33 c0		 xor	 eax, eax
  001a6	85 c0		 test	 eax, eax
  001a8	75 84		 jne	 SHORT $LN7@z900_multi

; 4629 :     BFPINST_CHECK( regs );

  001aa	b8 08 00 00 00	 mov	 eax, 8
  001af	48 6b c0 01	 imul	 rax, rax, 1
  001b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001c0	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001c6	48 85 c0	 test	 rax, rax
  001c9	74 3c		 je	 SHORT $LN17@z900_multi
  001cb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001d0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001d6	d1 e8		 shr	 eax, 1
  001d8	83 e0 01	 and	 eax, 1
  001db	85 c0		 test	 eax, eax
  001dd	74 4c		 je	 SHORT $LN16@z900_multi
  001df	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001eb	b9 08 00 00 00	 mov	 ecx, 8
  001f0	48 6b c9 01	 imul	 rcx, rcx, 1
  001f4	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001fc	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00202	48 85 c0	 test	 rax, rax
  00205	75 24		 jne	 SHORT $LN16@z900_multi
$LN17@z900_multi:
  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00216	ba 07 00 00 00	 mov	 edx, 7
  0021b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00220	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00225	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_multi:
$LN10@z900_multi:

; 4630 : 
; 4631 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  0022b	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  0022f	d1 e0		 shl	 eax, 1
  00231	48 98		 cdqe
  00233	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00238	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00240	48 8b d0	 mov	 rdx, rax
  00243	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op1$[rsp]
  00248	e8 00 00 00 00	 call	 z900_get_float32
  0024d	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  00251	d1 e0		 shl	 eax, 1
  00253	48 98		 cdqe
  00255	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0025a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00262	48 8b d0	 mov	 rdx, rax
  00265	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op3$[rsp]
  0026a	e8 00 00 00 00	 call	 z900_get_float32
  0026f	33 c0		 xor	 eax, eax
  00271	85 c0		 test	 eax, eax
  00273	75 b6		 jne	 SHORT $LN10@z900_multi

; 4632 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00275	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0027a	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0027e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00283	e8 00 00 00 00	 call	 z900_vfetch4
  00288	89 44 24 54	 mov	 DWORD PTR op2$[rsp], eax

; 4633 : 
; 4634 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4635 :     if (0
; 4636 :         || !(op1.v & 0x007FFFFF)
; 4637 :         || ((op1.v & 0x7F800000) ^ 0x7F800000)

  0028c	33 c0		 xor	 eax, eax
  0028e	85 c0		 test	 eax, eax
  00290	75 1f		 jne	 SHORT $LN19@z900_multi
  00292	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  00296	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  0029b	85 c0		 test	 eax, eax
  0029d	74 12		 je	 SHORT $LN19@z900_multi
  0029f	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  002a3	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  002a8	35 00 00 80 7f	 xor	 eax, 2139095040		; 7f800000H
  002ad	85 c0		 test	 eax, eax
  002af	74 0c		 je	 SHORT $LN18@z900_multi
$LN19@z900_multi:

; 4638 :     )
; 4639 :         op1.v ^= 0x80000000;

  002b1	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  002b5	0f ba f8 1f	 btc	 eax, 31
  002b9	89 44 24 20	 mov	 DWORD PTR op1$[rsp], eax
$LN18@z900_multi:

; 4640 : 
; 4641 :     softfloat_exceptionFlags = 0;

  002bd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c2	8b c0		 mov	 eax, eax
  002c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ca	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d7	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4642 :     SET_SF_RM_FROM_FPC;

  002db	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002e0	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002e6	83 e0 07	 and	 eax, 7
  002e9	8b c0		 mov	 eax, eax
  002eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002f2	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  002f7	8b d2		 mov	 edx, edx
  002f9	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00300	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00309	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0030d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00311	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4643 : 
; 4644 :     ans = f32_mulAdd( op2, op3, op1 );

  00315	44 8b 44 24 20	 mov	 r8d, DWORD PTR op1$[rsp]
  0031a	8b 54 24 50	 mov	 edx, DWORD PTR op3$[rsp]
  0031e	8b 4c 24 54	 mov	 ecx, DWORD PTR op2$[rsp]
  00322	e8 00 00 00 00	 call	 f32_mulAdd
  00327	89 44 24 48	 mov	 DWORD PTR ans$[rsp], eax

; 4645 : 
; 4646 :     if (softfloat_exceptionFlags)

  0032b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00330	8b c0		 mov	 eax, eax
  00332	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00338	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00341	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00345	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00349	85 c0		 test	 eax, eax
  0034b	0f 84 93 00 00
	00		 je	 $LN20@z900_multi

; 4647 :     {
; 4648 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00351	33 c0		 xor	 eax, eax
  00353	83 f8 01	 cmp	 eax, 1
  00356	74 45		 je	 SHORT $LN21@z900_multi
  00358	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0035d	8b c0		 mov	 eax, eax
  0035f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00365	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0036e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00372	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00376	83 e0 10	 and	 eax, 16
  00379	85 c0		 test	 eax, eax
  0037b	74 20		 je	 SHORT $LN21@z900_multi
  0037d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00382	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00388	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0038d	85 c0		 test	 eax, eax
  0038f	74 0c		 je	 SHORT $LN21@z900_multi
  00391	b2 80		 mov	 dl, 128			; 00000080H
  00393	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00398	e8 00 00 00 00	 call	 ieee_trap
$LN21@z900_multi:

; 4649 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0039d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003a2	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003a7	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4650 : 
; 4651 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  003ab	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003af	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  003b4	85 c0		 test	 eax, eax
  003b6	74 2c		 je	 SHORT $LN22@z900_multi

; 4652 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  003b8	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003bc	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003c1	85 c0		 test	 eax, eax
  003c3	74 0a		 je	 SHORT $LN25@z900_multi
  003c5	c7 44 24 40 40
	ff ff ff	 mov	 DWORD PTR tv255[rsp], -192 ; ffffffffffffff40H
  003cd	eb 08		 jmp	 SHORT $LN26@z900_multi
$LN25@z900_multi:
  003cf	c7 44 24 40 c0
	00 00 00	 mov	 DWORD PTR tv255[rsp], 192 ; 000000c0H
$LN26@z900_multi:
  003d7	8b 4c 24 40	 mov	 ecx, DWORD PTR tv255[rsp]
  003db	e8 00 00 00 00	 call	 f32_scaledResult
  003e0	89 44 24 48	 mov	 DWORD PTR ans$[rsp], eax
$LN22@z900_multi:
$LN20@z900_multi:

; 4653 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4654 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4655 :     }
; 4656 : 
; 4657 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  003e4	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  003e8	d1 e0		 shl	 eax, 1
  003ea	48 98		 cdqe
  003ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003f9	48 8b d0	 mov	 rdx, rax
  003fc	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ans$[rsp]
  00401	e8 00 00 00 00	 call	 z900_put_float32

; 4658 : 
; 4659 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00406	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0040a	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0040f	85 c0		 test	 eax, eax
  00411	74 0e		 je	 SHORT $LN23@z900_multi
  00413	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00417	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0041c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN23@z900_multi:

; 4660 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4661 : }

  00421	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00425	c3		 ret	 0
z900_multiply_subtract_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv232 = 40
r1$ = 44
op1$ = 48
r3$ = 56
r2$ = 60
ans$ = 64
op3$ = 72
op2$ = 80
inst$ = 112
regs$ = 120
z900_multiply_subtract_bfp_long_reg PROC

; 4483 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4484 :     int        r1, r2, r3;
; 4485 :     float64_t  op1, op2, op3, ans;
; 4486 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4487 : 
; 4488 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 3c	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  00052	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN11@z900_multi
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4489 :     TXF_FLOAT_INSTR_CHECK( regs );

  00081	33 c0		 xor	 eax, eax
  00083	83 f8 01	 cmp	 eax, 1
  00086	74 6f		 je	 SHORT $LN12@z900_multi
  00088	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00094	85 c0		 test	 eax, eax
  00096	74 5f		 je	 SHORT $LN12@z900_multi
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 23		 jne	 SHORT $LN13@z900_multi
  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000aa	85 c0		 test	 eax, eax
  000ac	75 13		 jne	 SHORT $LN13@z900_multi
  000ae	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b3	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ba	83 e0 04	 and	 eax, 4
  000bd	85 c0		 test	 eax, eax
  000bf	75 36		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000cc	0f ba e8 0b	 bts	 eax, 11
  000d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200959
  000e2	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e8	ba 02 00 00 00	 mov	 edx, 2
  000ed	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  000f7	33 c0		 xor	 eax, eax
  000f9	85 c0		 test	 eax, eax
  000fb	75 84		 jne	 SHORT $LN7@z900_multi

; 4490 :     BFPINST_CHECK( regs );

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00113	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00119	48 85 c0	 test	 rax, rax
  0011c	74 3c		 je	 SHORT $LN15@z900_multi
  0011e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00123	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00129	d1 e8		 shr	 eax, 1
  0012b	83 e0 01	 and	 eax, 1
  0012e	85 c0		 test	 eax, eax
  00130	74 4c		 je	 SHORT $LN14@z900_multi
  00132	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013e	b9 08 00 00 00	 mov	 ecx, 8
  00143	48 6b c9 01	 imul	 rcx, rcx, 1
  00147	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0014f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00155	48 85 c0	 test	 rax, rax
  00158	75 24		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0015a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00169	ba 07 00 00 00	 mov	 edx, 7
  0016e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00178	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:
$LN10@z900_multi:

; 4491 : 
; 4492 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  0017e	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00182	d1 e0		 shl	 eax, 1
  00184	48 98		 cdqe
  00186	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00193	48 8b d0	 mov	 rdx, rax
  00196	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 z900_get_float64
  001a0	8b 44 24 38	 mov	 eax, DWORD PTR r3$[rsp]
  001a4	d1 e0		 shl	 eax, 1
  001a6	48 98		 cdqe
  001a8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ad	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b5	48 8b d0	 mov	 rdx, rax
  001b8	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  001bd	e8 00 00 00 00	 call	 z900_get_float64
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	75 b6		 jne	 SHORT $LN10@z900_multi

; 4493 :     GET_FLOAT64_OP( op2, r2, regs );

  001c8	8b 44 24 3c	 mov	 eax, DWORD PTR r2$[rsp]
  001cc	d1 e0		 shl	 eax, 1
  001ce	48 98		 cdqe
  001d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001d5	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001dd	48 8b d0	 mov	 rdx, rax
  001e0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001e5	e8 00 00 00 00	 call	 z900_get_float64

; 4494 : 
; 4495 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4496 :     if (0
; 4497 :         || !(op1.v & 0x000FFFFFFFFFFFFF)
; 4498 :         || ((op1.v & 0x7FF0000000000000) ^ 0x7FF0000000000000)

  001ea	33 c0		 xor	 eax, eax
  001ec	85 c0		 test	 eax, eax
  001ee	75 41		 jne	 SHORT $LN17@z900_multi
  001f0	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  001fa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  001ff	48 23 c8	 and	 rcx, rax
  00202	48 8b c1	 mov	 rax, rcx
  00205	48 85 c0	 test	 rax, rax
  00208	74 27		 je	 SHORT $LN17@z900_multi
  0020a	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00214	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00219	48 23 c8	 and	 rcx, rax
  0021c	48 8b c1	 mov	 rax, rcx
  0021f	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00229	48 33 c1	 xor	 rax, rcx
  0022c	48 85 c0	 test	 rax, rax
  0022f	74 1a		 je	 SHORT $LN16@z900_multi
$LN17@z900_multi:

; 4499 :     )
; 4500 :         op1.v ^= 0x8000000000000000ULL;

  00231	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0023b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00240	48 33 c8	 xor	 rcx, rax
  00243	48 8b c1	 mov	 rax, rcx
  00246	48 89 44 24 30	 mov	 QWORD PTR op1$[rsp], rax
$LN16@z900_multi:

; 4501 : 
; 4502 :     softfloat_exceptionFlags = 0;

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4503 :     SET_SF_RM_FROM_FPC;

  00269	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0026e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00274	83 e0 07	 and	 eax, 7
  00277	8b c0		 mov	 eax, eax
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00280	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00285	8b d2		 mov	 edx, edx
  00287	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00297	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4504 : 
; 4505 :     ans = f64_mulAdd( op2, op3, op1 );

  002a3	4c 8b 44 24 30	 mov	 r8, QWORD PTR op1$[rsp]
  002a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR op3$[rsp]
  002ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  002b2	e8 00 00 00 00	 call	 f64_mulAdd
  002b7	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 4506 : 
; 4507 :     if (softfloat_exceptionFlags)

  002bc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c1	8b c0		 mov	 eax, eax
  002c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002da	85 c0		 test	 eax, eax
  002dc	0f 84 94 00 00
	00		 je	 $LN18@z900_multi

; 4508 :     {
; 4509 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002e2	33 c0		 xor	 eax, eax
  002e4	83 f8 01	 cmp	 eax, 1
  002e7	74 45		 je	 SHORT $LN19@z900_multi
  002e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ee	8b c0		 mov	 eax, eax
  002f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ff	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00303	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00307	83 e0 10	 and	 eax, 16
  0030a	85 c0		 test	 eax, eax
  0030c	74 20		 je	 SHORT $LN19@z900_multi
  0030e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00313	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00319	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0031e	85 c0		 test	 eax, eax
  00320	74 0c		 je	 SHORT $LN19@z900_multi
  00322	b2 80		 mov	 dl, 128			; 00000080H
  00324	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00329	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_multi:

; 4510 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0032e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00333	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00338	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4511 : 
; 4512 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0033c	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00340	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00345	85 c0		 test	 eax, eax
  00347	74 2d		 je	 SHORT $LN20@z900_multi

; 4513 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00349	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0034d	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00352	85 c0		 test	 eax, eax
  00354	74 0a		 je	 SHORT $LN23@z900_multi
  00356	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv232[rsp], -1536 ; fffffffffffffa00H
  0035e	eb 08		 jmp	 SHORT $LN24@z900_multi
$LN23@z900_multi:
  00360	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv232[rsp], 1536 ; 00000600H
$LN24@z900_multi:
  00368	8b 4c 24 28	 mov	 ecx, DWORD PTR tv232[rsp]
  0036c	e8 00 00 00 00	 call	 f64_scaledResult
  00371	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN20@z900_multi:
$LN18@z900_multi:

; 4514 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4515 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4516 :     }
; 4517 : 
; 4518 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00376	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0037a	d1 e0		 shl	 eax, 1
  0037c	48 98		 cdqe
  0037e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0038b	48 8b d0	 mov	 rdx, rax
  0038e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  00393	e8 00 00 00 00	 call	 z900_put_float64

; 4519 : 
; 4520 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00398	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0039c	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003a1	85 c0		 test	 eax, eax
  003a3	74 0e		 je	 SHORT $LN21@z900_multi
  003a5	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003ae	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_multi:

; 4521 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4522 : }

  003b3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003b7	c3		 ret	 0
z900_multiply_subtract_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
tv255 = 56
r1$ = 60
op1$ = 64
r3$ = 72
ans$ = 80
op3$ = 88
op2$ = 96
inst$ = 128
regs$ = 136
z900_multiply_subtract_bfp_long PROC

; 4528 : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4529 :     int        x2, r1, r3, b2;
; 4530 :     VADR       effective_addr2;
; 4531 :     float64_t  op1, op2, op3, ans;
; 4532 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4533 : 
; 4534 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 04	 imul	 rax, rax, 4
  00037	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00043	c1 f8 04	 sar	 eax, 4
  00046	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00053	8b c0		 mov	 eax, eax
  00055	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0005a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005e	c1 e8 10	 shr	 eax, 16
  00061	83 e0 0f	 and	 eax, 15
  00064	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00068	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0006c	c1 e8 14	 shr	 eax, 20
  0006f	83 e0 0f	 and	 eax, 15
  00072	89 44 24 48	 mov	 DWORD PTR r3$[rsp], eax
  00076	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007b	74 25		 je	 SHORT $LN11@z900_multi
  0007d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00082	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00097	48 03 c8	 add	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_multi:
  000a2	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  000a6	c1 e8 0c	 shr	 eax, 12
  000a9	83 e0 0f	 and	 eax, 15
  000ac	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  000b0	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b5	74 25		 je	 SHORT $LN12@z900_multi
  000b7	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_multi:
  000dc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000f0	48 23 c8	 and	 rcx, rax
  000f3	48 8b c1	 mov	 rax, rcx
  000f6	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_multi:
  000fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00103	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00107	48 83 c0 06	 add	 rax, 6
  0010b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0f		 je	 SHORT $LN13@z900_multi
  0011e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_multi:
  0012d	33 c0		 xor	 eax, eax
  0012f	85 c0		 test	 eax, eax
  00131	75 c8		 jne	 SHORT $LN4@z900_multi

; 4535 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00133	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  00138	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0013c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 4536 :     TXF_FLOAT_INSTR_CHECK( regs );

  00149	33 c0		 xor	 eax, eax
  0014b	83 f8 01	 cmp	 eax, 1
  0014e	0f 84 81 00 00
	00		 je	 $LN14@z900_multi
  00154	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00163	85 c0		 test	 eax, eax
  00165	74 6e		 je	 SHORT $LN14@z900_multi
  00167	33 c0		 xor	 eax, eax
  00169	85 c0		 test	 eax, eax
  0016b	75 29		 jne	 SHORT $LN15@z900_multi
  0016d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00175	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0017c	85 c0		 test	 eax, eax
  0017e	75 16		 jne	 SHORT $LN15@z900_multi
  00180	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00188	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0018f	83 e0 04	 and	 eax, 4
  00192	85 c0		 test	 eax, eax
  00194	75 3f		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  00196	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001a4	0f ba e8 0b	 bts	 eax, 11
  001a8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001b6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200998
  001bd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001c3	ba 02 00 00 00	 mov	 edx, 2
  001c8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_multi:
  001d5	33 c0		 xor	 eax, eax
  001d7	85 c0		 test	 eax, eax
  001d9	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_multi

; 4537 :     BFPINST_CHECK( regs );

  001df	b8 08 00 00 00	 mov	 eax, 8
  001e4	48 6b c0 01	 imul	 rax, rax, 1
  001e8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f0	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001f8	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001fe	48 85 c0	 test	 rax, rax
  00201	74 42		 je	 SHORT $LN17@z900_multi
  00203	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00211	d1 e8		 shr	 eax, 1
  00213	83 e0 01	 and	 eax, 1
  00216	85 c0		 test	 eax, eax
  00218	74 58		 je	 SHORT $LN16@z900_multi
  0021a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00222	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00229	b9 08 00 00 00	 mov	 ecx, 8
  0022e	48 6b c9 01	 imul	 rcx, rcx, 1
  00232	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0023a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00240	48 85 c0	 test	 rax, rax
  00243	75 2d		 jne	 SHORT $LN16@z900_multi
$LN17@z900_multi:
  00245	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00257	ba 07 00 00 00	 mov	 edx, 7
  0025c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_multi:
$LN10@z900_multi:

; 4538 : 
; 4539 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  00272	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00276	d1 e0		 shl	 eax, 1
  00278	48 98		 cdqe
  0027a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00282	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0028a	48 8b d0	 mov	 rdx, rax
  0028d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00292	e8 00 00 00 00	 call	 z900_get_float64
  00297	8b 44 24 48	 mov	 eax, DWORD PTR r3$[rsp]
  0029b	d1 e0		 shl	 eax, 1
  0029d	48 98		 cdqe
  0029f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a7	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002af	48 8b d0	 mov	 rdx, rax
  002b2	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op3$[rsp]
  002b7	e8 00 00 00 00	 call	 z900_get_float64
  002bc	33 c0		 xor	 eax, eax
  002be	85 c0		 test	 eax, eax
  002c0	75 b0		 jne	 SHORT $LN10@z900_multi

; 4540 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  002c2	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ca	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  002ce	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  002d3	e8 00 00 00 00	 call	 z900_vfetch8
  002d8	48 89 44 24 60	 mov	 QWORD PTR op2$[rsp], rax

; 4541 : 
; 4542 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4543 :     if (0
; 4544 :         || !(op1.v & 0x000FFFFFFFFFFFFF)
; 4545 :         || ((op1.v & 0x7FF0000000000000) ^ 0x7FF0000000000000)

  002dd	33 c0		 xor	 eax, eax
  002df	85 c0		 test	 eax, eax
  002e1	75 41		 jne	 SHORT $LN19@z900_multi
  002e3	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  002ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  002f2	48 23 c8	 and	 rcx, rax
  002f5	48 8b c1	 mov	 rax, rcx
  002f8	48 85 c0	 test	 rax, rax
  002fb	74 27		 je	 SHORT $LN19@z900_multi
  002fd	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00307	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0030c	48 23 c8	 and	 rcx, rax
  0030f	48 8b c1	 mov	 rax, rcx
  00312	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0031c	48 33 c1	 xor	 rax, rcx
  0031f	48 85 c0	 test	 rax, rax
  00322	74 1a		 je	 SHORT $LN18@z900_multi
$LN19@z900_multi:

; 4546 :     )
; 4547 :         op1.v ^= 0x8000000000000000ULL;

  00324	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0032e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00333	48 33 c8	 xor	 rcx, rax
  00336	48 8b c1	 mov	 rax, rcx
  00339	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax
$LN18@z900_multi:

; 4548 : 
; 4549 :     softfloat_exceptionFlags = 0;

  0033e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00343	8b c0		 mov	 eax, eax
  00345	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0034b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00354	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00358	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4550 :     SET_SF_RM_FROM_FPC;

  0035c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00364	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0036a	83 e0 07	 and	 eax, 7
  0036d	8b c0		 mov	 eax, eax
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00376	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0037b	8b d2		 mov	 edx, edx
  0037d	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00384	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  0038d	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00391	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00395	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4551 : 
; 4552 :     ans = f64_mulAdd( op2, op3, op1 );

  00399	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  0039e	48 8b 54 24 58	 mov	 rdx, QWORD PTR op3$[rsp]
  003a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op2$[rsp]
  003a8	e8 00 00 00 00	 call	 f64_mulAdd
  003ad	48 89 44 24 50	 mov	 QWORD PTR ans$[rsp], rax

; 4553 : 
; 4554 :     if (softfloat_exceptionFlags)

  003b2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003b7	8b c0		 mov	 eax, eax
  003b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003bf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003c8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003d0	85 c0		 test	 eax, eax
  003d2	0f 84 9d 00 00
	00		 je	 $LN20@z900_multi

; 4555 :     {
; 4556 :         IEEE_EXCEPTION_TRAP_XI( regs );

  003d8	33 c0		 xor	 eax, eax
  003da	83 f8 01	 cmp	 eax, 1
  003dd	74 4b		 je	 SHORT $LN21@z900_multi
  003df	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003e4	8b c0		 mov	 eax, eax
  003e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003ec	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003f5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003f9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003fd	83 e0 10	 and	 eax, 16
  00400	85 c0		 test	 eax, eax
  00402	74 26		 je	 SHORT $LN21@z900_multi
  00404	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00412	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00417	85 c0		 test	 eax, eax
  00419	74 0f		 je	 SHORT $LN21@z900_multi
  0041b	b2 80		 mov	 dl, 128			; 00000080H
  0041d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00425	e8 00 00 00 00	 call	 ieee_trap
$LN21@z900_multi:

; 4557 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0042a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00432	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00437	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4558 : 
; 4559 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0043b	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0043f	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00444	85 c0		 test	 eax, eax
  00446	74 2d		 je	 SHORT $LN22@z900_multi

; 4560 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00448	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0044c	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00451	85 c0		 test	 eax, eax
  00453	74 0a		 je	 SHORT $LN25@z900_multi
  00455	c7 44 24 38 00
	fa ff ff	 mov	 DWORD PTR tv255[rsp], -1536 ; fffffffffffffa00H
  0045d	eb 08		 jmp	 SHORT $LN26@z900_multi
$LN25@z900_multi:
  0045f	c7 44 24 38 00
	06 00 00	 mov	 DWORD PTR tv255[rsp], 1536 ; 00000600H
$LN26@z900_multi:
  00467	8b 4c 24 38	 mov	 ecx, DWORD PTR tv255[rsp]
  0046b	e8 00 00 00 00	 call	 f64_scaledResult
  00470	48 89 44 24 50	 mov	 QWORD PTR ans$[rsp], rax
$LN22@z900_multi:
$LN20@z900_multi:

; 4561 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4562 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4563 :     }
; 4564 : 
; 4565 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00475	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00479	d1 e0		 shl	 eax, 1
  0047b	48 98		 cdqe
  0047d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0048d	48 8b d0	 mov	 rdx, rax
  00490	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ans$[rsp]
  00495	e8 00 00 00 00	 call	 z900_put_float64

; 4566 : 
; 4567 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0049a	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0049e	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  004a3	85 c0		 test	 eax, eax
  004a5	74 11		 je	 SHORT $LN23@z900_multi
  004a7	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004ab	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN23@z900_multi:

; 4568 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4569 : }

  004b8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004bc	c3		 ret	 0
z900_multiply_subtract_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
op1$ = 44
op2$ = 48
ans$ = 56
iop2$ = 64
iop1$ = 72
inst$ = 96
regs$ = 104
z900_multiply_bfp_short_to_long_reg PROC

; 4145 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4146 :     int        r1, r2;
; 4147 :     float32_t  op1, op2;
; 4148 :     float64_t  iop1, iop2, ans;
; 4149 : 
; 4150 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_multi
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4151 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_multi
  00073	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_multi
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_multi
  00089	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_multi
  00099	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200685
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_multi

; 4152 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_multi
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_multi
  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  00145	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:
$LN10@z900_multi:

; 4153 : 
; 4154 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00169	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR op1$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float32
  0018b	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0018f	d1 e0		 shl	 eax, 1
  00191	48 98		 cdqe
  00193	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a0	48 8b d0	 mov	 rdx, rax
  001a3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  001a8	e8 00 00 00 00	 call	 z900_get_float32
  001ad	33 c0		 xor	 eax, eax
  001af	85 c0		 test	 eax, eax
  001b1	75 b6		 jne	 SHORT $LN10@z900_multi

; 4155 : 
; 4156 :     /* f32_to_f64 will, if presented with a SNaN, convert it to quiet
; 4157 :        and raise softfloat_flags_invalid.  Unfortunately, if one of
; 4158 :        the operands is an SNaN and the other a QNaN, f64_mul() will be
; 4159 :        unable to do NaN propagation correctly because it will see only
; 4160 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 4161 :        input operands, that becomes the answer.  If both operands are
; 4162 :        QNaNs, then f64_mul() will be able to do NaN propagation correctly.
; 4163 :     */
; 4164 :     softfloat_exceptionFlags = 0;

  001b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b8	8b c0		 mov	 eax, eax
  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001cd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4165 :     softfloat_roundingMode = softfloat_round_near_even;

  001d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001d6	8b c0		 mov	 eax, eax
  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001de	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001eb	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4166 : 
; 4167 :     iop1 = f32_to_f64( op1 );

  001ef	8b 4c 24 2c	 mov	 ecx, DWORD PTR op1$[rsp]
  001f3	e8 00 00 00 00	 call	 f32_to_f64
  001f8	48 89 44 24 48	 mov	 QWORD PTR iop1$[rsp], rax

; 4168 : 
; 4169 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  001fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00202	8b c0		 mov	 eax, eax
  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00213	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00217	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021b	83 e0 10	 and	 eax, 16
  0021e	85 c0		 test	 eax, eax
  00220	74 0c		 je	 SHORT $LN16@z900_multi

; 4170 :         ans = iop1;

  00222	48 8b 44 24 48	 mov	 rax, QWORD PTR iop1$[rsp]
  00227	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
  0022c	eb 53		 jmp	 SHORT $LN17@z900_multi
$LN16@z900_multi:

; 4171 :     else
; 4172 :     {
; 4173 :         iop2 = f32_to_f64( op2 );

  0022e	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  00232	e8 00 00 00 00	 call	 f32_to_f64
  00237	48 89 44 24 40	 mov	 QWORD PTR iop2$[rsp], rax

; 4174 : 
; 4175 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0023c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00241	8b c0		 mov	 eax, eax
  00243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00249	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00252	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00256	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025a	83 e0 10	 and	 eax, 16
  0025d	85 c0		 test	 eax, eax
  0025f	74 0c		 je	 SHORT $LN18@z900_multi

; 4176 :             ans = iop2;

  00261	48 8b 44 24 40	 mov	 rax, QWORD PTR iop2$[rsp]
  00266	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
  0026b	eb 14		 jmp	 SHORT $LN19@z900_multi
$LN18@z900_multi:

; 4177 :         else
; 4178 :             ans = f64_mul( iop1, iop2 );

  0026d	48 8b 54 24 40	 mov	 rdx, QWORD PTR iop2$[rsp]
  00272	48 8b 4c 24 48	 mov	 rcx, QWORD PTR iop1$[rsp]
  00277	e8 00 00 00 00	 call	 f64_mul
  0027c	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN19@z900_multi:
$LN17@z900_multi:

; 4179 :     }
; 4180 : 
; 4181 :     if (softfloat_exceptionFlags)

  00281	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00286	8b c0		 mov	 eax, eax
  00288	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0028e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00297	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029f	85 c0		 test	 eax, eax
  002a1	0f 84 9e 00 00
	00		 je	 $LN20@z900_multi

; 4182 :     {
; 4183 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002a7	33 c0		 xor	 eax, eax
  002a9	83 f8 01	 cmp	 eax, 1
  002ac	74 45		 je	 SHORT $LN21@z900_multi
  002ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b3	8b c0		 mov	 eax, eax
  002b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002bb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002c4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002cc	83 e0 10	 and	 eax, 16
  002cf	85 c0		 test	 eax, eax
  002d1	74 20		 je	 SHORT $LN21@z900_multi
  002d3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002d8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002de	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002e3	85 c0		 test	 eax, eax
  002e5	74 0c		 je	 SHORT $LN21@z900_multi
  002e7	b2 80		 mov	 dl, 128			; 00000080H
  002e9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ee	e8 00 00 00 00	 call	 ieee_trap
$LN21@z900_multi:

; 4184 :         SET_FPC_FLAGS_FROM_SF( regs );

  002f3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002f8	8b c0		 mov	 eax, eax
  002fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00300	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00309	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0030d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00311	c1 e0 13	 shl	 eax, 19
  00314	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0031f	c1 e9 08	 shr	 ecx, 8
  00322	f7 d1		 not	 ecx
  00324	23 c1		 and	 eax, ecx
  00326	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0032b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00330	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00336	0b c8		 or	 ecx, eax
  00338	8b c1		 mov	 eax, ecx
  0033a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0033f	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN20@z900_multi:

; 4185 :     }
; 4186 : 
; 4187 :     PUT_FLOAT64_NOCC(ans, r1, regs);

  00345	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00349	d1 e0		 shl	 eax, 1
  0034b	48 98		 cdqe
  0034d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0035a	48 8b d0	 mov	 rdx, rax
  0035d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  00362	e8 00 00 00 00	 call	 z900_put_float64

; 4188 : }

  00367	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0036b	c3		 ret	 0
z900_multiply_bfp_short_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
b2$ = 36
x2$ = 40
effective_addr2$ = 48
r1$ = 56
op1$ = 60
op2$ = 64
ans$ = 72
iop2$ = 80
iop1$ = 88
inst$ = 112
regs$ = 120
z900_multiply_bfp_short_to_long PROC

; 4198 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4199 :     int        r1, x2, b2;
; 4200 :     VADR       effective_addr2;
; 4201 :     float32_t  op1, op2;
; 4202 :     float64_t  iop1, iop2, ans;
; 4203 : 
; 4204 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00041	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00045	c1 e8 14	 shr	 eax, 20
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  0004f	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00054	74 22		 je	 SHORT $LN8@z900_multi
  00056	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_multi:
  00078	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 22		 je	 SHORT $LN9@z900_multi
  0008d	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_multi:
  000af	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000bb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c0	48 23 c8	 and	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_multi:
  000cb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 06	 add	 rax, 6
  000d8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e1	33 c0		 xor	 eax, eax
  000e3	83 f8 06	 cmp	 eax, 6
  000e6	74 0c		 je	 SHORT $LN10@z900_multi
  000e8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_multi:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 d1		 jne	 SHORT $LN4@z900_multi

; 4205 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  000fa	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  000ff	8b 54 24 28	 mov	 edx, DWORD PTR x2$[rsp]
  00103	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 4206 :     TXF_FLOAT_INSTR_CHECK( regs );

  0010d	33 c0		 xor	 eax, eax
  0010f	83 f8 01	 cmp	 eax, 1
  00112	74 6f		 je	 SHORT $LN11@z900_multi
  00114	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00119	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00120	85 c0		 test	 eax, eax
  00122	74 5f		 je	 SHORT $LN11@z900_multi
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 23		 jne	 SHORT $LN12@z900_multi
  0012a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00136	85 c0		 test	 eax, eax
  00138	75 13		 jne	 SHORT $LN12@z900_multi
  0013a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00146	83 e0 04	 and	 eax, 4
  00149	85 c0		 test	 eax, eax
  0014b	75 36		 jne	 SHORT $LN11@z900_multi
$LN12@z900_multi:
  0014d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00152	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00158	0f ba e8 0b	 bts	 eax, 11
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00167	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200721
  0016e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00174	ba 02 00 00 00	 mov	 edx, 2
  00179	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_multi:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 84		 jne	 SHORT $LN7@z900_multi

; 4207 :     BFPINST_CHECK( regs );

  00189	b8 08 00 00 00	 mov	 eax, 8
  0018e	48 6b c0 01	 imul	 rax, rax, 1
  00192	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0019f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 3c		 je	 SHORT $LN14@z900_multi
  001aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b5	d1 e8		 shr	 eax, 1
  001b7	83 e0 01	 and	 eax, 1
  001ba	85 c0		 test	 eax, eax
  001bc	74 4c		 je	 SHORT $LN13@z900_multi
  001be	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001ca	b9 08 00 00 00	 mov	 ecx, 8
  001cf	48 6b c9 01	 imul	 rcx, rcx, 1
  001d3	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001db	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e1	48 85 c0	 test	 rax, rax
  001e4	75 24		 jne	 SHORT $LN13@z900_multi
$LN14@z900_multi:
  001e6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001f5	ba 07 00 00 00	 mov	 edx, 7
  001fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_multi:

; 4208 : 
; 4209 :     GET_FLOAT32_OP( op1, r1, regs );

  0020a	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0020e	d1 e0		 shl	 eax, 1
  00210	48 98		 cdqe
  00212	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00217	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0021f	48 8b d0	 mov	 rdx, rax
  00222	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  00227	e8 00 00 00 00	 call	 z900_get_float32

; 4210 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0022c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00231	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  00235	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0023a	e8 00 00 00 00	 call	 z900_vfetch4
  0023f	89 44 24 40	 mov	 DWORD PTR op2$[rsp], eax

; 4211 : 
; 4212 :     /* f32_to_f64 will, if presented with a SNaN, convert it to quiet
; 4213 :        and raise softfloat_flags_invalid.  Unfortunately, if one of the
; 4214 :        operands is an SNaN and the other a QNaN, f64_mul() will be
; 4215 :        unable to do NaN propagation correctly because it will see only
; 4216 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 4217 :        input operands, that becomes the answer.  If both operands are
; 4218 :        QNaNs, then f64_mul() will be able to do NaN propagation correctly.
; 4219 :     */
; 4220 :     softfloat_exceptionFlags = 0;

  00243	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00248	8b c0		 mov	 eax, eax
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00250	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00259	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025d	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4221 :     softfloat_roundingMode = softfloat_round_near_even;

  00261	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00266	8b c0		 mov	 eax, eax
  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00277	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4222 : 
; 4223 :     iop1 = f32_to_f64( op1 );

  0027f	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  00283	e8 00 00 00 00	 call	 f32_to_f64
  00288	48 89 44 24 58	 mov	 QWORD PTR iop1$[rsp], rax

; 4224 : 
; 4225 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0028d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00292	8b c0		 mov	 eax, eax
  00294	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ab	83 e0 10	 and	 eax, 16
  002ae	85 c0		 test	 eax, eax
  002b0	74 0c		 je	 SHORT $LN15@z900_multi

; 4226 :         ans = iop1;

  002b2	48 8b 44 24 58	 mov	 rax, QWORD PTR iop1$[rsp]
  002b7	48 89 44 24 48	 mov	 QWORD PTR ans$[rsp], rax
  002bc	eb 53		 jmp	 SHORT $LN16@z900_multi
$LN15@z900_multi:

; 4227 :     else
; 4228 :     {
; 4229 :         iop2 = f32_to_f64( op2 );

  002be	8b 4c 24 40	 mov	 ecx, DWORD PTR op2$[rsp]
  002c2	e8 00 00 00 00	 call	 f32_to_f64
  002c7	48 89 44 24 50	 mov	 QWORD PTR iop2$[rsp], rax

; 4230 : 
; 4231 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  002cc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d1	8b c0		 mov	 eax, eax
  002d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ea	83 e0 10	 and	 eax, 16
  002ed	85 c0		 test	 eax, eax
  002ef	74 0c		 je	 SHORT $LN17@z900_multi

; 4232 :             ans = iop2;

  002f1	48 8b 44 24 50	 mov	 rax, QWORD PTR iop2$[rsp]
  002f6	48 89 44 24 48	 mov	 QWORD PTR ans$[rsp], rax
  002fb	eb 14		 jmp	 SHORT $LN18@z900_multi
$LN17@z900_multi:

; 4233 :         else
; 4234 :             ans = f64_mul( iop1, iop2 );

  002fd	48 8b 54 24 50	 mov	 rdx, QWORD PTR iop2$[rsp]
  00302	48 8b 4c 24 58	 mov	 rcx, QWORD PTR iop1$[rsp]
  00307	e8 00 00 00 00	 call	 f64_mul
  0030c	48 89 44 24 48	 mov	 QWORD PTR ans$[rsp], rax
$LN18@z900_multi:
$LN16@z900_multi:

; 4235 :     }
; 4236 : 
; 4237 :     if (softfloat_exceptionFlags)

  00311	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00316	8b c0		 mov	 eax, eax
  00318	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0031e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00327	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0032b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0032f	85 c0		 test	 eax, eax
  00331	0f 84 9e 00 00
	00		 je	 $LN19@z900_multi

; 4238 :     {
; 4239 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00337	33 c0		 xor	 eax, eax
  00339	83 f8 01	 cmp	 eax, 1
  0033c	74 45		 je	 SHORT $LN20@z900_multi
  0033e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00343	8b c0		 mov	 eax, eax
  00345	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0034b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00354	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00358	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035c	83 e0 10	 and	 eax, 16
  0035f	85 c0		 test	 eax, eax
  00361	74 20		 je	 SHORT $LN20@z900_multi
  00363	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00368	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0036e	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00373	85 c0		 test	 eax, eax
  00375	74 0c		 je	 SHORT $LN20@z900_multi
  00377	b2 80		 mov	 dl, 128			; 00000080H
  00379	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0037e	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_multi:

; 4240 :         SET_FPC_FLAGS_FROM_SF( regs );

  00383	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00388	8b c0		 mov	 eax, eax
  0038a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00390	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00399	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0039d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a1	c1 e0 13	 shl	 eax, 19
  003a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003a9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003af	c1 e9 08	 shr	 ecx, 8
  003b2	f7 d1		 not	 ecx
  003b4	23 c1		 and	 eax, ecx
  003b6	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  003bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003c0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003c6	0b c8		 or	 ecx, eax
  003c8	8b c1		 mov	 eax, ecx
  003ca	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003cf	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN19@z900_multi:

; 4241 :     }
; 4242 : 
; 4243 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  003d5	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  003d9	d1 e0		 shl	 eax, 1
  003db	48 98		 cdqe
  003dd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003e2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003ea	48 8b d0	 mov	 rdx, rax
  003ed	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ans$[rsp]
  003f2	e8 00 00 00 00	 call	 z900_put_float64

; 4244 : }

  003f7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003fb	c3		 ret	 0
z900_multiply_bfp_short_to_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv214 = 40
r1$ = 44
ans$ = 48
r2$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
z900_multiply_bfp_short_reg PROC

; 4250 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4251 :     int        r1, r2;
; 4252 :     float32_t  op1, op2, ans;
; 4253 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4254 : 
; 4255 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@z900_multi
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4256 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN12@z900_multi
  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN12@z900_multi
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN13@z900_multi
  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN13@z900_multi
  000a1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000b4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200754
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_multi

; 4257 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN15@z900_multi
  00111	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN14@z900_multi
  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0014d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:
$LN10@z900_multi:

; 4258 : 
; 4259 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00171	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float32
  00193	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00197	d1 e0		 shl	 eax, 1
  00199	48 98		 cdqe
  0019b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_get_float32
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 b6		 jne	 SHORT $LN10@z900_multi

; 4260 : 
; 4261 :     softfloat_exceptionFlags = 0;

  001bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c0	8b c0		 mov	 eax, eax
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4262 :     SET_SF_RM_FROM_FPC;

  001d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001de	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e4	83 e0 07	 and	 eax, 7
  001e7	8b c0		 mov	 eax, eax
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001f0	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001f5	8b d2		 mov	 edx, edx
  001f7	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001fe	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00207	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4263 : 
; 4264 :     ans = f32_mul( op1, op2 );

  00213	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00217	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  0021b	e8 00 00 00 00	 call	 f32_mul
  00220	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 4265 : 
; 4266 :     if (softfloat_exceptionFlags)

  00224	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00229	8b c0		 mov	 eax, eax
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00231	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00242	85 c0		 test	 eax, eax
  00244	0f 84 93 00 00
	00		 je	 $LN16@z900_multi

; 4267 :     {
; 4268 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0024a	33 c0		 xor	 eax, eax
  0024c	83 f8 01	 cmp	 eax, 1
  0024f	74 45		 je	 SHORT $LN17@z900_multi
  00251	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00256	8b c0		 mov	 eax, eax
  00258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0025e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00267	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026f	83 e0 10	 and	 eax, 16
  00272	85 c0		 test	 eax, eax
  00274	74 20		 je	 SHORT $LN17@z900_multi
  00276	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0027b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00281	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00286	85 c0		 test	 eax, eax
  00288	74 0c		 je	 SHORT $LN17@z900_multi
  0028a	b2 80		 mov	 dl, 128			; 00000080H
  0028c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00291	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_multi:

; 4269 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00296	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0029b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002a0	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4270 : 
; 4271 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002a4	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002a8	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002ad	85 c0		 test	 eax, eax
  002af	74 2c		 je	 SHORT $LN18@z900_multi

; 4272 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002b1	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b5	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002ba	85 c0		 test	 eax, eax
  002bc	74 0a		 je	 SHORT $LN21@z900_multi
  002be	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv214[rsp], -192 ; ffffffffffffff40H
  002c6	eb 08		 jmp	 SHORT $LN22@z900_multi
$LN21@z900_multi:
  002c8	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv214[rsp], 192 ; 000000c0H
$LN22@z900_multi:
  002d0	8b 4c 24 28	 mov	 ecx, DWORD PTR tv214[rsp]
  002d4	e8 00 00 00 00	 call	 f32_scaledResult
  002d9	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN18@z900_multi:
$LN16@z900_multi:

; 4273 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4274 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4275 :     }
; 4276 : 
; 4277 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  002dd	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002e1	d1 e0		 shl	 eax, 1
  002e3	48 98		 cdqe
  002e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002ea	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002f2	48 8b d0	 mov	 rdx, rax
  002f5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  002fa	e8 00 00 00 00	 call	 z900_put_float32

; 4278 : 
; 4279 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002ff	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00303	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00308	85 c0		 test	 eax, eax
  0030a	74 0e		 je	 SHORT $LN19@z900_multi
  0030c	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00310	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00315	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_multi:

; 4280 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4281 : }

  0031a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0031e	c3		 ret	 0
z900_multiply_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
tv235 = 56
r1$ = 60
ans$ = 64
op2$ = 68
op1$ = 72
inst$ = 96
regs$ = 104
z900_multiply_bfp_short PROC

; 4287 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4288 :     int        r1, x2, b2;
; 4289 :     VADR       effective_addr2;
; 4290 :     float32_t  op1, op2, ans;
; 4291 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4292 : 
; 4293 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	8b c0		 mov	 eax, eax
  00036	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 22		 je	 SHORT $LN8@z900_multi
  0005e	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00070	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_multi:
  00080	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008e	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00093	74 22		 je	 SHORT $LN9@z900_multi
  00095	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_multi:
  000b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c8	48 23 c8	 and	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_multi:
  000d3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000dc	48 83 c0 06	 add	 rax, 6
  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0c		 je	 SHORT $LN10@z900_multi
  000f0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_multi:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 d1		 jne	 SHORT $LN4@z900_multi

; 4294 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00102	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  00107	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0010b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 4295 :     TXF_FLOAT_INSTR_CHECK( regs );

  00115	33 c0		 xor	 eax, eax
  00117	83 f8 01	 cmp	 eax, 1
  0011a	74 6f		 je	 SHORT $LN11@z900_multi
  0011c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00128	85 c0		 test	 eax, eax
  0012a	74 5f		 je	 SHORT $LN11@z900_multi
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 23		 jne	 SHORT $LN12@z900_multi
  00132	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0013e	85 c0		 test	 eax, eax
  00140	75 13		 jne	 SHORT $LN12@z900_multi
  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00147	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0014e	83 e0 04	 and	 eax, 4
  00151	85 c0		 test	 eax, eax
  00153	75 36		 jne	 SHORT $LN11@z900_multi
$LN12@z900_multi:
  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00160	0f ba e8 0b	 bts	 eax, 11
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0016f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200786
  00176	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0017c	ba 02 00 00 00	 mov	 edx, 2
  00181	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_multi:
  0018b	33 c0		 xor	 eax, eax
  0018d	85 c0		 test	 eax, eax
  0018f	75 84		 jne	 SHORT $LN7@z900_multi

; 4296 :     BFPINST_CHECK( regs );

  00191	b8 08 00 00 00	 mov	 eax, 8
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001a7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 3c		 je	 SHORT $LN14@z900_multi
  001b2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bd	d1 e8		 shr	 eax, 1
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	74 4c		 je	 SHORT $LN13@z900_multi
  001c6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d2	b9 08 00 00 00	 mov	 ecx, 8
  001d7	48 6b c9 01	 imul	 rcx, rcx, 1
  001db	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001e3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 24		 jne	 SHORT $LN13@z900_multi
$LN14@z900_multi:
  001ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001fd	ba 07 00 00 00	 mov	 edx, 7
  00202	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_multi:

; 4297 : 
; 4298 :     GET_FLOAT32_OP( op1, r1, regs );

  00212	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00216	d1 e0		 shl	 eax, 1
  00218	48 98		 cdqe
  0021a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00227	48 8b d0	 mov	 rdx, rax
  0022a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_get_float32

; 4299 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00234	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00239	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  0023d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00242	e8 00 00 00 00	 call	 z900_vfetch4
  00247	89 44 24 44	 mov	 DWORD PTR op2$[rsp], eax

; 4300 : 
; 4301 :     softfloat_exceptionFlags = 0;

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4302 :     SET_SF_RM_FROM_FPC;

  00269	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0026e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00274	83 e0 07	 and	 eax, 7
  00277	8b c0		 mov	 eax, eax
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00280	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00285	8b d2		 mov	 edx, edx
  00287	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00297	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4303 : 
; 4304 :     ans = f32_mul( op1, op2 );

  002a3	8b 54 24 44	 mov	 edx, DWORD PTR op2$[rsp]
  002a7	8b 4c 24 48	 mov	 ecx, DWORD PTR op1$[rsp]
  002ab	e8 00 00 00 00	 call	 f32_mul
  002b0	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax

; 4305 : 
; 4306 :     if (softfloat_exceptionFlags)

  002b4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b9	8b c0		 mov	 eax, eax
  002bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ca	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d2	85 c0		 test	 eax, eax
  002d4	0f 84 93 00 00
	00		 je	 $LN15@z900_multi

; 4307 :     {
; 4308 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002da	33 c0		 xor	 eax, eax
  002dc	83 f8 01	 cmp	 eax, 1
  002df	74 45		 je	 SHORT $LN16@z900_multi
  002e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e6	8b c0		 mov	 eax, eax
  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ff	83 e0 10	 and	 eax, 16
  00302	85 c0		 test	 eax, eax
  00304	74 20		 je	 SHORT $LN16@z900_multi
  00306	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0030b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00311	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00316	85 c0		 test	 eax, eax
  00318	74 0c		 je	 SHORT $LN16@z900_multi
  0031a	b2 80		 mov	 dl, 128			; 00000080H
  0031c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_multi:

; 4309 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00326	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00330	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4310 : 
; 4311 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00334	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00338	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0033d	85 c0		 test	 eax, eax
  0033f	74 2c		 je	 SHORT $LN17@z900_multi

; 4312 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00341	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00345	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0034a	85 c0		 test	 eax, eax
  0034c	74 0a		 je	 SHORT $LN20@z900_multi
  0034e	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv235[rsp], -192 ; ffffffffffffff40H
  00356	eb 08		 jmp	 SHORT $LN21@z900_multi
$LN20@z900_multi:
  00358	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv235[rsp], 192 ; 000000c0H
$LN21@z900_multi:
  00360	8b 4c 24 38	 mov	 ecx, DWORD PTR tv235[rsp]
  00364	e8 00 00 00 00	 call	 f32_scaledResult
  00369	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax
$LN17@z900_multi:
$LN15@z900_multi:

; 4313 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4314 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4315 :     }
; 4316 : 
; 4317 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  0036d	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00371	d1 e0		 shl	 eax, 1
  00373	48 98		 cdqe
  00375	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0037a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00382	48 8b d0	 mov	 rdx, rax
  00385	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  0038a	e8 00 00 00 00	 call	 z900_put_float32

; 4318 : 
; 4319 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0038f	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00393	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00398	85 c0		 test	 eax, eax
  0039a	74 0e		 je	 SHORT $LN18@z900_multi
  0039c	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003a0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@z900_multi:

; 4320 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4321 : }

  003aa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003ae	c3		 ret	 0
z900_multiply_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
r1$ = 32
i$1 = 36
r2$ = 40
op1$ = 48
op2$ = 56
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
ans$ = 144
iop2$ = 160
iop1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
z900_multiply_bfp_long_to_ext_reg PROC

; 3958 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3959 :     int         r1, r2;
; 3960 :     float64_t   op1, op2;
; 3961 :     float128_t  iop1, iop2, ans;
; 3962 : 
; 3963 :     RRE( inst, regs, r1, r2 );

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	48 6b c0 03	 imul	 rax, rax, 3
  0002e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00036	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003a	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004d	c1 f8 04	 sar	 eax, 4
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  00057	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00063	48 83 c0 04	 add	 rax, 4
  00067	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00073	33 c0		 xor	 eax, eax
  00075	83 f8 04	 cmp	 eax, 4
  00078	74 0f		 je	 SHORT $LN11@z900_multi
  0007a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 c8		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 3964 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	0f 84 81 00 00
	00		 je	 $LN12@z900_multi
  0009a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a9	85 c0		 test	 eax, eax
  000ab	74 6e		 je	 SHORT $LN12@z900_multi
  000ad	33 c0		 xor	 eax, eax
  000af	85 c0		 test	 eax, eax
  000b1	75 29		 jne	 SHORT $LN13@z900_multi
  000b3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c2	85 c0		 test	 eax, eax
  000c4	75 16		 jne	 SHORT $LN13@z900_multi
  000c6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ce	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d5	83 e0 04	 and	 eax, 4
  000d8	85 c0		 test	 eax, eax
  000da	75 3f		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000dc	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ea	0f ba e8 0b	 bts	 eax, 11
  000ee	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200549
  00103	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00109	ba 02 00 00 00	 mov	 edx, 2
  0010e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  0011b	33 c0		 xor	 eax, eax
  0011d	85 c0		 test	 eax, eax
  0011f	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_multi

; 3965 :     BFPINST_CHECK( regs );

  00125	b8 08 00 00 00	 mov	 eax, 8
  0012a	48 6b c0 01	 imul	 rax, rax, 1
  0012e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00144	48 85 c0	 test	 rax, rax
  00147	74 42		 je	 SHORT $LN15@z900_multi
  00149	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00151	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00157	d1 e8		 shr	 eax, 1
  00159	83 e0 01	 and	 eax, 1
  0015c	85 c0		 test	 eax, eax
  0015e	74 58		 je	 SHORT $LN14@z900_multi
  00160	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00168	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016f	b9 08 00 00 00	 mov	 ecx, 8
  00174	48 6b c9 01	 imul	 rcx, rcx, 1
  00178	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00180	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00186	48 85 c0	 test	 rax, rax
  00189	75 2d		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0018b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00193	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0019d	ba 07 00 00 00	 mov	 edx, 7
  001a2	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001aa	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:

; 3966 :     BFPREGPAIR_CHECK( r1, regs );

  001b8	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  001bc	83 e0 02	 and	 eax, 2
  001bf	85 c0		 test	 eax, eax
  001c1	74 1b		 je	 SHORT $LN16@z900_multi
  001c3	ba 06 00 00 00	 mov	 edx, 6
  001c8	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_multi:
$LN10@z900_multi:

; 3967 : 
; 3968 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  001de	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  001e2	d1 e0		 shl	 eax, 1
  001e4	48 98		 cdqe
  001e6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ee	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001f6	48 8b d0	 mov	 rdx, rax
  001f9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  001fe	e8 00 00 00 00	 call	 z900_get_float64
  00203	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00207	d1 e0		 shl	 eax, 1
  00209	48 98		 cdqe
  0020b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0021b	48 8b d0	 mov	 rdx, rax
  0021e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  00223	e8 00 00 00 00	 call	 z900_get_float64
  00228	33 c0		 xor	 eax, eax
  0022a	85 c0		 test	 eax, eax
  0022c	75 b0		 jne	 SHORT $LN10@z900_multi

; 3969 : 
; 3970 :     /* f64_to_f128 will, if presented with a SNaN, convert it to quiet
; 3971 :        and raise softfloat_flags_invalid. Unfortunately, if one of the
; 3972 :        operands is an SNaN and the other a QNaN, f128_mul() will be
; 3973 :        unable to do NaN propagation correctly because it will see only
; 3974 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 3975 :        input operands, that becomes the answer.  If both operands are
; 3976 :        QNaNs, then f128_mul() will be able to do NaN propagation correctly.
; 3977 :     */
; 3978 :     softfloat_exceptionFlags = 0;

  0022e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00233	8b c0		 mov	 eax, eax
  00235	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00244	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00248	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3979 :     softfloat_roundingMode = softfloat_round_near_even;

  0024c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00251	8b c0		 mov	 eax, eax
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00259	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00262	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00266	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3980 : 
; 3981 :     iop1 = f64_to_f128( op1 );

  0026a	48 8b 54 24 30	 mov	 rdx, QWORD PTR op1$[rsp]
  0026f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  00274	e8 00 00 00 00	 call	 f64_to_f128
  00279	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  00281	48 8b f9	 mov	 rdi, rcx
  00284	48 8b f0	 mov	 rsi, rax
  00287	b9 10 00 00 00	 mov	 ecx, 16
  0028c	f3 a4		 rep movsb

; 3982 : 
; 3983 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0028e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00293	8b c0		 mov	 eax, eax
  00295	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ac	83 e0 10	 and	 eax, 16
  002af	85 c0		 test	 eax, eax
  002b1	74 22		 je	 SHORT $LN17@z900_multi

; 3984 :         ans = iop1;

  002b3	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  002bb	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  002c3	48 8b f8	 mov	 rdi, rax
  002c6	48 8b f1	 mov	 rsi, rcx
  002c9	b9 10 00 00 00	 mov	 ecx, 16
  002ce	f3 a4		 rep movsb
  002d0	e9 c8 00 00 00	 jmp	 $LN18@z900_multi
$LN17@z900_multi:

; 3985 :     else
; 3986 :     {
; 3987 :         iop2 = f64_to_f128( op2 );

  002d5	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  002da	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  002df	e8 00 00 00 00	 call	 f64_to_f128
  002e4	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  002ec	48 8b f9	 mov	 rdi, rcx
  002ef	48 8b f0	 mov	 rsi, rax
  002f2	b9 10 00 00 00	 mov	 ecx, 16
  002f7	f3 a4		 rep movsb

; 3988 : 
; 3989 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  002f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002fe	8b c0		 mov	 eax, eax
  00300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00306	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0030f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00313	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00317	83 e0 10	 and	 eax, 16
  0031a	85 c0		 test	 eax, eax
  0031c	74 1f		 je	 SHORT $LN19@z900_multi

; 3990 :             ans = iop2;

  0031e	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  00326	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  0032e	48 8b f8	 mov	 rdi, rax
  00331	48 8b f1	 mov	 rsi, rcx
  00334	b9 10 00 00 00	 mov	 ecx, 16
  00339	f3 a4		 rep movsb
  0033b	eb 60		 jmp	 SHORT $LN20@z900_multi
$LN19@z900_multi:

; 3991 :         else
; 3992 :             ans = f128_mul( iop1, iop2 );

  0033d	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  00342	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  0034a	48 8b f8	 mov	 rdi, rax
  0034d	48 8b f1	 mov	 rsi, rcx
  00350	b9 10 00 00 00	 mov	 ecx, 16
  00355	f3 a4		 rep movsb
  00357	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  0035c	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  00364	48 8b f8	 mov	 rdi, rax
  00367	48 8b f1	 mov	 rsi, rcx
  0036a	b9 10 00 00 00	 mov	 ecx, 16
  0036f	f3 a4		 rep movsb
  00371	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  00376	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  0037b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00383	e8 00 00 00 00	 call	 f128_mul
  00388	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00390	48 8b f9	 mov	 rdi, rcx
  00393	48 8b f0	 mov	 rsi, rax
  00396	b9 10 00 00 00	 mov	 ecx, 16
  0039b	f3 a4		 rep movsb
$LN20@z900_multi:
$LN18@z900_multi:

; 3993 :     }
; 3994 : 
; 3995 :     if (softfloat_exceptionFlags)

  0039d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003a2	8b c0		 mov	 eax, eax
  003a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003aa	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003b3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003bb	85 c0		 test	 eax, eax
  003bd	0f 84 ad 00 00
	00		 je	 $LN21@z900_multi

; 3996 :     {
; 3997 :         IEEE_EXCEPTION_TRAP_XI( regs );

  003c3	33 c0		 xor	 eax, eax
  003c5	83 f8 01	 cmp	 eax, 1
  003c8	74 4b		 je	 SHORT $LN22@z900_multi
  003ca	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003cf	8b c0		 mov	 eax, eax
  003d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003d7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003e0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e8	83 e0 10	 and	 eax, 16
  003eb	85 c0		 test	 eax, eax
  003ed	74 26		 je	 SHORT $LN22@z900_multi
  003ef	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003fd	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00402	85 c0		 test	 eax, eax
  00404	74 0f		 je	 SHORT $LN22@z900_multi
  00406	b2 80		 mov	 dl, 128			; 00000080H
  00408	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00410	e8 00 00 00 00	 call	 ieee_trap
$LN22@z900_multi:

; 3998 :         SET_FPC_FLAGS_FROM_SF( regs );

  00415	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0041a	8b c0		 mov	 eax, eax
  0041c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00422	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0042b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0042f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00433	c1 e0 13	 shl	 eax, 19
  00436	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00444	c1 e9 08	 shr	 ecx, 8
  00447	f7 d1		 not	 ecx
  00449	23 c1		 and	 eax, ecx
  0044b	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00450	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00458	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0045e	0b c8		 or	 ecx, eax
  00460	8b c1		 mov	 eax, ecx
  00462	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN21@z900_multi:

; 3999 :     }
; 4000 : 
; 4001 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  00470	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  00474	d1 e0		 shl	 eax, 1
  00476	48 98		 cdqe
  00478	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00480	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00488	48 8b d0	 mov	 rdx, rax
  0048b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00493	e8 00 00 00 00	 call	 z900_put_float128

; 4002 : }

  00498	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a0	48 33 cc	 xor	 rcx, rsp
  004a3	e8 00 00 00 00	 call	 __security_check_cookie
  004a8	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  004af	5f		 pop	 rdi
  004b0	5e		 pop	 rsi
  004b1	c3		 ret	 0
z900_multiply_bfp_long_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
b2$ = 36
x2$ = 40
r1$ = 44
effective_addr2$ = 48
op1$ = 56
op2$ = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
ans$ = 160
iop2$ = 176
iop1$ = 192
__$ArrayPad$ = 208
inst$ = 256
regs$ = 264
z900_multiply_bfp_long_to_ext PROC

; 4012 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4013 :     int         r1, x2, b2;
; 4014 :     VADR        effective_addr2;
; 4015 :     float64_t   op1, op2;
; 4016 :     float128_t  iop1, iop2, ans;
; 4017 : 
; 4018 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00025	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 _byteswap_ulong
  00039	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003d	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00041	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00046	8b c0		 mov	 eax, eax
  00048	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004d	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  0005b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 14	 shr	 eax, 20
  00062	83 e0 0f	 and	 eax, 15
  00065	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00069	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006e	74 25		 je	 SHORT $LN8@z900_multi
  00070	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00075	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0008a	48 03 c8	 add	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_multi:
  00095	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00099	c1 e8 0c	 shr	 eax, 12
  0009c	83 e0 0f	 and	 eax, 15
  0009f	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  000a3	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a8	74 25		 je	 SHORT $LN9@z900_multi
  000aa	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  000af	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000bf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c4	48 03 c8	 add	 rcx, rax
  000c7	48 8b c1	 mov	 rax, rcx
  000ca	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_multi:
  000cf	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e3	48 23 c8	 and	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_multi:
  000ee	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000fa	48 83 c0 06	 add	 rax, 6
  000fe	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00106	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0010a	33 c0		 xor	 eax, eax
  0010c	83 f8 06	 cmp	 eax, 6
  0010f	74 0f		 je	 SHORT $LN10@z900_multi
  00111	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00119	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_multi:
  00120	33 c0		 xor	 eax, eax
  00122	85 c0		 test	 eax, eax
  00124	75 c8		 jne	 SHORT $LN4@z900_multi

; 4019 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00126	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  0012b	8b 54 24 28	 mov	 edx, DWORD PTR x2$[rsp]
  0012f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00137	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 4020 :     TXF_FLOAT_INSTR_CHECK( regs );

  0013c	33 c0		 xor	 eax, eax
  0013e	83 f8 01	 cmp	 eax, 1
  00141	0f 84 81 00 00
	00		 je	 $LN11@z900_multi
  00147	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00156	85 c0		 test	 eax, eax
  00158	74 6e		 je	 SHORT $LN11@z900_multi
  0015a	33 c0		 xor	 eax, eax
  0015c	85 c0		 test	 eax, eax
  0015e	75 29		 jne	 SHORT $LN12@z900_multi
  00160	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00168	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0016f	85 c0		 test	 eax, eax
  00171	75 16		 jne	 SHORT $LN12@z900_multi
  00173	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017b	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00182	83 e0 04	 and	 eax, 4
  00185	85 c0		 test	 eax, eax
  00187	75 3f		 jne	 SHORT $LN11@z900_multi
$LN12@z900_multi:
  00189	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00197	0f ba e8 0b	 bts	 eax, 11
  0019b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001a9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200586
  001b0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001b6	ba 02 00 00 00	 mov	 edx, 2
  001bb	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_multi:
  001c8	33 c0		 xor	 eax, eax
  001ca	85 c0		 test	 eax, eax
  001cc	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_multi

; 4021 :     BFPINST_CHECK( regs );

  001d2	b8 08 00 00 00	 mov	 eax, 8
  001d7	48 6b c0 01	 imul	 rax, rax, 1
  001db	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001eb	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001f1	48 85 c0	 test	 rax, rax
  001f4	74 42		 je	 SHORT $LN14@z900_multi
  001f6	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fe	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00204	d1 e8		 shr	 eax, 1
  00206	83 e0 01	 and	 eax, 1
  00209	85 c0		 test	 eax, eax
  0020b	74 58		 je	 SHORT $LN13@z900_multi
  0020d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00215	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0021c	b9 08 00 00 00	 mov	 ecx, 8
  00221	48 6b c9 01	 imul	 rcx, rcx, 1
  00225	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0022d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00233	48 85 c0	 test	 rax, rax
  00236	75 2d		 jne	 SHORT $LN13@z900_multi
$LN14@z900_multi:
  00238	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00240	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0024a	ba 07 00 00 00	 mov	 edx, 7
  0024f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00257	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_multi:

; 4022 :     BFPREGPAIR_CHECK( r1, regs );

  00265	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00269	83 e0 02	 and	 eax, 2
  0026c	85 c0		 test	 eax, eax
  0026e	74 1b		 je	 SHORT $LN15@z900_multi
  00270	ba 06 00 00 00	 mov	 edx, 6
  00275	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00285	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_multi:

; 4023 : 
; 4024 :     GET_FLOAT64_OP( op1, r1, regs );

  0028b	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0028f	d1 e0		 shl	 eax, 1
  00291	48 98		 cdqe
  00293	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002a3	48 8b d0	 mov	 rdx, rax
  002a6	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  002ab	e8 00 00 00 00	 call	 z900_get_float64

; 4025 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  002b0	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002b8	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  002bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  002c1	e8 00 00 00 00	 call	 z900_vfetch8
  002c6	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 4026 : 
; 4027 :     /* f64_to_f128 will, if presented with a SNaN, convert it to quiet
; 4028 :        and raise softfloat_flags_invalid.  Unfortunately, if one of
; 4029 :        the operands is an SNaN and the other a QNaN, f128_mul() will
; 4030 :        be unable to do NaN propagation correctly because it will see
; 4031 :        only two QNaNs.  So if we encounter an SNaN while upconverting
; 4032 :        the input operands, that becomes the answer.  If both operands
; 4033 :        are QNaNs, then f128_mul() will be able to do NaN propagation correctly.
; 4034 :     */
; 4035 :     softfloat_exceptionFlags = 0;

  002cb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d0	8b c0		 mov	 eax, eax
  002d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4036 :     softfloat_roundingMode = softfloat_round_near_even;

  002e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002ee	8b c0		 mov	 eax, eax
  002f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ff	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00303	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4037 : 
; 4038 :     iop1 = f64_to_f128( op1 );

  00307	48 8b 54 24 38	 mov	 rdx, QWORD PTR op1$[rsp]
  0030c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  00311	e8 00 00 00 00	 call	 f64_to_f128
  00316	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  0031e	48 8b f9	 mov	 rdi, rcx
  00321	48 8b f0	 mov	 rsi, rax
  00324	b9 10 00 00 00	 mov	 ecx, 16
  00329	f3 a4		 rep movsb

; 4039 : 
; 4040 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0032b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00330	8b c0		 mov	 eax, eax
  00332	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00338	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00341	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00345	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00349	83 e0 10	 and	 eax, 16
  0034c	85 c0		 test	 eax, eax
  0034e	74 22		 je	 SHORT $LN16@z900_multi

; 4041 :         ans = iop1;

  00350	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  00358	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  00360	48 8b f8	 mov	 rdi, rax
  00363	48 8b f1	 mov	 rsi, rcx
  00366	b9 10 00 00 00	 mov	 ecx, 16
  0036b	f3 a4		 rep movsb
  0036d	e9 cb 00 00 00	 jmp	 $LN17@z900_multi
$LN16@z900_multi:

; 4042 :     else
; 4043 :     {
; 4044 :         iop2 = f64_to_f128( op2 );

  00372	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00377	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  0037f	e8 00 00 00 00	 call	 f64_to_f128
  00384	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  0038c	48 8b f9	 mov	 rdi, rcx
  0038f	48 8b f0	 mov	 rsi, rax
  00392	b9 10 00 00 00	 mov	 ecx, 16
  00397	f3 a4		 rep movsb

; 4045 : 
; 4046 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00399	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0039e	8b c0		 mov	 eax, eax
  003a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b7	83 e0 10	 and	 eax, 16
  003ba	85 c0		 test	 eax, eax
  003bc	74 1f		 je	 SHORT $LN18@z900_multi

; 4047 :             ans = iop2;

  003be	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  003c6	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  003ce	48 8b f8	 mov	 rdi, rax
  003d1	48 8b f1	 mov	 rsi, rcx
  003d4	b9 10 00 00 00	 mov	 ecx, 16
  003d9	f3 a4		 rep movsb
  003db	eb 60		 jmp	 SHORT $LN19@z900_multi
$LN18@z900_multi:

; 4048 :         else
; 4049 :             ans = f128_mul( iop1, iop2 );

  003dd	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  003e2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  003ea	48 8b f8	 mov	 rdi, rax
  003ed	48 8b f1	 mov	 rsi, rcx
  003f0	b9 10 00 00 00	 mov	 ecx, 16
  003f5	f3 a4		 rep movsb
  003f7	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  003fc	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  00404	48 8b f8	 mov	 rdi, rax
  00407	48 8b f1	 mov	 rsi, rcx
  0040a	b9 10 00 00 00	 mov	 ecx, 16
  0040f	f3 a4		 rep movsb
  00411	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  00416	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  0041b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00423	e8 00 00 00 00	 call	 f128_mul
  00428	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00430	48 8b f9	 mov	 rdi, rcx
  00433	48 8b f0	 mov	 rsi, rax
  00436	b9 10 00 00 00	 mov	 ecx, 16
  0043b	f3 a4		 rep movsb
$LN19@z900_multi:
$LN17@z900_multi:

; 4050 :     }
; 4051 : 
; 4052 :     if (softfloat_exceptionFlags)

  0043d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00442	8b c0		 mov	 eax, eax
  00444	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0044a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00453	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00457	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0045b	85 c0		 test	 eax, eax
  0045d	0f 84 ad 00 00
	00		 je	 $LN20@z900_multi

; 4053 :     {
; 4054 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00463	33 c0		 xor	 eax, eax
  00465	83 f8 01	 cmp	 eax, 1
  00468	74 4b		 je	 SHORT $LN21@z900_multi
  0046a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0046f	8b c0		 mov	 eax, eax
  00471	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00477	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00480	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00484	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00488	83 e0 10	 and	 eax, 16
  0048b	85 c0		 test	 eax, eax
  0048d	74 26		 je	 SHORT $LN21@z900_multi
  0048f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00497	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0049d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  004a2	85 c0		 test	 eax, eax
  004a4	74 0f		 je	 SHORT $LN21@z900_multi
  004a6	b2 80		 mov	 dl, 128			; 00000080H
  004a8	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b0	e8 00 00 00 00	 call	 ieee_trap
$LN21@z900_multi:

; 4055 :         SET_FPC_FLAGS_FROM_SF( regs );

  004b5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  004ba	8b c0		 mov	 eax, eax
  004bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004c2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004cb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d3	c1 e0 13	 shl	 eax, 19
  004d6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004de	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  004e4	c1 e9 08	 shr	 ecx, 8
  004e7	f7 d1		 not	 ecx
  004e9	23 c1		 and	 eax, ecx
  004eb	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  004f0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f8	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  004fe	0b c8		 or	 ecx, eax
  00500	8b c1		 mov	 eax, ecx
  00502	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050a	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN20@z900_multi:

; 4056 :     }
; 4057 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  00510	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00514	d1 e0		 shl	 eax, 1
  00516	48 98		 cdqe
  00518	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00520	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00528	48 8b d0	 mov	 rdx, rax
  0052b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00533	e8 00 00 00 00	 call	 z900_put_float128

; 4058 : }

  00538	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00540	48 33 cc	 xor	 rcx, rsp
  00543	e8 00 00 00 00	 call	 __security_check_cookie
  00548	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0054f	5f		 pop	 rdi
  00550	5e		 pop	 rsi
  00551	c3		 ret	 0
z900_multiply_bfp_long_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv214 = 40
r1$ = 44
r2$ = 48
ans$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
z900_multiply_bfp_long_reg PROC

; 4064 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4065 :     int        r1, r2;
; 4066 :     float64_t  op1, op2, ans;
; 4067 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4068 : 
; 4069 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@z900_multi
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4070 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN12@z900_multi
  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN12@z900_multi
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN13@z900_multi
  00091	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN13@z900_multi
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200620
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_multi

; 4071 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN15@z900_multi
  00111	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN14@z900_multi
  00125	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:
$LN10@z900_multi:

; 4072 : 
; 4073 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00171	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float64
  00193	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00197	d1 e0		 shl	 eax, 1
  00199	48 98		 cdqe
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_get_float64
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 b6		 jne	 SHORT $LN10@z900_multi

; 4074 : 
; 4075 :     softfloat_exceptionFlags = 0;

  001bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c0	8b c0		 mov	 eax, eax
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4076 :     SET_SF_RM_FROM_FPC;

  001d9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001de	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e4	83 e0 07	 and	 eax, 7
  001e7	8b c0		 mov	 eax, eax
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001f0	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001f5	8b d2		 mov	 edx, edx
  001f7	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001fe	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00207	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4077 : 
; 4078 :     ans = f64_mul( op1, op2 );

  00213	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00218	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0021d	e8 00 00 00 00	 call	 f64_mul
  00222	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 4079 : 
; 4080 :     if (softfloat_exceptionFlags)

  00227	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022c	8b c0		 mov	 eax, eax
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00234	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00241	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00245	85 c0		 test	 eax, eax
  00247	0f 84 94 00 00
	00		 je	 $LN16@z900_multi

; 4081 :     {
; 4082 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0024d	33 c0		 xor	 eax, eax
  0024f	83 f8 01	 cmp	 eax, 1
  00252	74 45		 je	 SHORT $LN17@z900_multi
  00254	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00259	8b c0		 mov	 eax, eax
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00261	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00272	83 e0 10	 and	 eax, 16
  00275	85 c0		 test	 eax, eax
  00277	74 20		 je	 SHORT $LN17@z900_multi
  00279	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0027e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00284	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00289	85 c0		 test	 eax, eax
  0028b	74 0c		 je	 SHORT $LN17@z900_multi
  0028d	b2 80		 mov	 dl, 128			; 00000080H
  0028f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_multi:

; 4083 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00299	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002a3	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4084 : 
; 4085 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002a7	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ab	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002b0	85 c0		 test	 eax, eax
  002b2	74 2d		 je	 SHORT $LN18@z900_multi

; 4086 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002b4	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b8	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002bd	85 c0		 test	 eax, eax
  002bf	74 0a		 je	 SHORT $LN21@z900_multi
  002c1	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv214[rsp], -1536 ; fffffffffffffa00H
  002c9	eb 08		 jmp	 SHORT $LN22@z900_multi
$LN21@z900_multi:
  002cb	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv214[rsp], 1536 ; 00000600H
$LN22@z900_multi:
  002d3	8b 4c 24 28	 mov	 ecx, DWORD PTR tv214[rsp]
  002d7	e8 00 00 00 00	 call	 f64_scaledResult
  002dc	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN18@z900_multi:
$LN16@z900_multi:

; 4087 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4088 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4089 :     }
; 4090 : 
; 4091 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  002e1	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002e5	d1 e0		 shl	 eax, 1
  002e7	48 98		 cdqe
  002e9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ee	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002f6	48 8b d0	 mov	 rdx, rax
  002f9	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  002fe	e8 00 00 00 00	 call	 z900_put_float64

; 4092 : 
; 4093 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00303	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00307	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0030c	85 c0		 test	 eax, eax
  0030e	74 0e		 je	 SHORT $LN19@z900_multi
  00310	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00314	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_multi:

; 4094 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4095 : }

  0031e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00322	c3		 ret	 0
z900_multiply_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
tv235 = 56
r1$ = 60
ans$ = 64
op2$ = 72
op1$ = 80
inst$ = 112
regs$ = 120
z900_multiply_bfp_long PROC

; 4101 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4102 :     int        r1, x2, b2;
; 4103 :     VADR       effective_addr2;
; 4104 :     float64_t  op1, op2, ans;
; 4105 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4106 : 
; 4107 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	8b c0		 mov	 eax, eax
  00036	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 22		 je	 SHORT $LN8@z900_multi
  0005e	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00070	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_multi:
  00080	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008e	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00093	74 22		 je	 SHORT $LN9@z900_multi
  00095	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_multi:
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c8	48 23 c8	 and	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_multi:
  000d3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000dc	48 83 c0 06	 add	 rax, 6
  000e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0c		 je	 SHORT $LN10@z900_multi
  000f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_multi:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 d1		 jne	 SHORT $LN4@z900_multi

; 4108 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00102	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  00107	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0010b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 4109 :     TXF_FLOAT_INSTR_CHECK( regs );

  00115	33 c0		 xor	 eax, eax
  00117	83 f8 01	 cmp	 eax, 1
  0011a	74 6f		 je	 SHORT $LN11@z900_multi
  0011c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00128	85 c0		 test	 eax, eax
  0012a	74 5f		 je	 SHORT $LN11@z900_multi
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 23		 jne	 SHORT $LN12@z900_multi
  00132	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0013e	85 c0		 test	 eax, eax
  00140	75 13		 jne	 SHORT $LN12@z900_multi
  00142	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00147	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0014e	83 e0 04	 and	 eax, 4
  00151	85 c0		 test	 eax, eax
  00153	75 36		 jne	 SHORT $LN11@z900_multi
$LN12@z900_multi:
  00155	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00160	0f ba e8 0b	 bts	 eax, 11
  00164	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0016f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200652
  00176	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0017c	ba 02 00 00 00	 mov	 edx, 2
  00181	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_multi:
  0018b	33 c0		 xor	 eax, eax
  0018d	85 c0		 test	 eax, eax
  0018f	75 84		 jne	 SHORT $LN7@z900_multi

; 4110 :     BFPINST_CHECK( regs );

  00191	b8 08 00 00 00	 mov	 eax, 8
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001a7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 3c		 je	 SHORT $LN14@z900_multi
  001b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bd	d1 e8		 shr	 eax, 1
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	74 4c		 je	 SHORT $LN13@z900_multi
  001c6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d2	b9 08 00 00 00	 mov	 ecx, 8
  001d7	48 6b c9 01	 imul	 rcx, rcx, 1
  001db	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001e3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 24		 jne	 SHORT $LN13@z900_multi
$LN14@z900_multi:
  001ee	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001f3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001fd	ba 07 00 00 00	 mov	 edx, 7
  00202	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_multi:

; 4111 : 
; 4112 :     GET_FLOAT64_OP( op1, r1, regs );

  00212	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00216	d1 e0		 shl	 eax, 1
  00218	48 98		 cdqe
  0021a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00227	48 8b d0	 mov	 rdx, rax
  0022a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_get_float64

; 4113 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00234	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00239	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  0023d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00242	e8 00 00 00 00	 call	 z900_vfetch8
  00247	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 4114 : 
; 4115 :     softfloat_exceptionFlags = 0;

  0024c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00251	8b c0		 mov	 eax, eax
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00259	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00262	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00266	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4116 :     SET_SF_RM_FROM_FPC;

  0026a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00275	83 e0 07	 and	 eax, 7
  00278	8b c0		 mov	 eax, eax
  0027a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00281	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00286	8b d2		 mov	 edx, edx
  00288	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028f	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00298	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a0	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4117 : 
; 4118 :     ans = f64_mul( op1, op2 );

  002a4	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  002a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op1$[rsp]
  002ae	e8 00 00 00 00	 call	 f64_mul
  002b3	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 4119 : 
; 4120 :     if (softfloat_exceptionFlags)

  002b8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002bd	8b c0		 mov	 eax, eax
  002bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ce	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d6	85 c0		 test	 eax, eax
  002d8	0f 84 94 00 00
	00		 je	 $LN15@z900_multi

; 4121 :     {
; 4122 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002de	33 c0		 xor	 eax, eax
  002e0	83 f8 01	 cmp	 eax, 1
  002e3	74 45		 je	 SHORT $LN16@z900_multi
  002e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ea	8b c0		 mov	 eax, eax
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00303	83 e0 10	 and	 eax, 16
  00306	85 c0		 test	 eax, eax
  00308	74 20		 je	 SHORT $LN16@z900_multi
  0030a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0030f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00315	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0031a	85 c0		 test	 eax, eax
  0031c	74 0c		 je	 SHORT $LN16@z900_multi
  0031e	b2 80		 mov	 dl, 128			; 00000080H
  00320	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00325	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_multi:

; 4123 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0032a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0032f	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00334	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4124 : 
; 4125 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00338	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0033c	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00341	85 c0		 test	 eax, eax
  00343	74 2d		 je	 SHORT $LN17@z900_multi

; 4126 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00345	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00349	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0034e	85 c0		 test	 eax, eax
  00350	74 0a		 je	 SHORT $LN20@z900_multi
  00352	c7 44 24 38 00
	fa ff ff	 mov	 DWORD PTR tv235[rsp], -1536 ; fffffffffffffa00H
  0035a	eb 08		 jmp	 SHORT $LN21@z900_multi
$LN20@z900_multi:
  0035c	c7 44 24 38 00
	06 00 00	 mov	 DWORD PTR tv235[rsp], 1536 ; 00000600H
$LN21@z900_multi:
  00364	8b 4c 24 38	 mov	 ecx, DWORD PTR tv235[rsp]
  00368	e8 00 00 00 00	 call	 f64_scaledResult
  0036d	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN17@z900_multi:
$LN15@z900_multi:

; 4127 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4128 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4129 :     }
; 4130 : 
; 4131 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00372	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00376	d1 e0		 shl	 eax, 1
  00378	48 98		 cdqe
  0037a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0037f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00387	48 8b d0	 mov	 rdx, rax
  0038a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  0038f	e8 00 00 00 00	 call	 z900_put_float64

; 4132 : 
; 4133 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00394	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00398	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0039d	85 c0		 test	 eax, eax
  0039f	74 0e		 je	 SHORT $LN18@z900_multi
  003a1	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003a5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003aa	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@z900_multi:

; 4134 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4135 : }

  003af	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003b3	c3		 ret	 0
z900_multiply_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv223 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
ans$ = 128
op2$ = 144
op1$ = 160
__$ArrayPad$ = 176
inst$ = 224
regs$ = 232
z900_multiply_bfp_ext_reg PROC

; 3916 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3917 :     int         r1, r2;
; 3918 :     float128_t  op1, op2, ans;
; 3919 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3920 : 
; 3921 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  0005f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN11@z900_multi
  00082	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 3922 :     TXF_FLOAT_INSTR_CHECK( regs );

  00097	33 c0		 xor	 eax, eax
  00099	83 f8 01	 cmp	 eax, 1
  0009c	0f 84 81 00 00
	00		 je	 $LN12@z900_multi
  000a2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b1	85 c0		 test	 eax, eax
  000b3	74 6e		 je	 SHORT $LN12@z900_multi
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 29		 jne	 SHORT $LN13@z900_multi
  000bb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000ca	85 c0		 test	 eax, eax
  000cc	75 16		 jne	 SHORT $LN13@z900_multi
  000ce	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000dd	83 e0 04	 and	 eax, 4
  000e0	85 c0		 test	 eax, eax
  000e2	75 3f		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000e4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f2	0f ba e8 0b	 bts	 eax, 11
  000f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00104	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200514
  0010b	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  00123	33 c0		 xor	 eax, eax
  00125	85 c0		 test	 eax, eax
  00127	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_multi

; 3923 :     BFPINST_CHECK( regs );

  0012d	b8 08 00 00 00	 mov	 eax, 8
  00132	48 6b c0 01	 imul	 rax, rax, 1
  00136	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00146	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014c	48 85 c0	 test	 rax, rax
  0014f	74 42		 je	 SHORT $LN15@z900_multi
  00151	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015f	d1 e8		 shr	 eax, 1
  00161	83 e0 01	 and	 eax, 1
  00164	85 c0		 test	 eax, eax
  00166	74 58		 je	 SHORT $LN14@z900_multi
  00168	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00177	b9 08 00 00 00	 mov	 ecx, 8
  0017c	48 6b c9 01	 imul	 rcx, rcx, 1
  00180	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00188	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018e	48 85 c0	 test	 rax, rax
  00191	75 2d		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  00193	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001a5	ba 07 00 00 00	 mov	 edx, 7
  001aa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:

; 3924 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001c0	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001c4	83 e0 02	 and	 eax, 2
  001c7	85 c0		 test	 eax, eax
  001c9	75 0b		 jne	 SHORT $LN17@z900_multi
  001cb	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001cf	83 e0 02	 and	 eax, 2
  001d2	85 c0		 test	 eax, eax
  001d4	74 1b		 je	 SHORT $LN16@z900_multi
$LN17@z900_multi:
  001d6	ba 06 00 00 00	 mov	 edx, 6
  001db	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_multi:
$LN10@z900_multi:

; 3925 : 
; 3926 :     GET_FLOAT128_OPS(op1, r1, op2, r2, regs);

  001f1	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001f5	d1 e0		 shl	 eax, 1
  001f7	48 98		 cdqe
  001f9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00209	48 8b d0	 mov	 rdx, rax
  0020c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00214	e8 00 00 00 00	 call	 z900_get_float128
  00219	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0021d	d1 e0		 shl	 eax, 1
  0021f	48 98		 cdqe
  00221	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00231	48 8b d0	 mov	 rdx, rax
  00234	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0023c	e8 00 00 00 00	 call	 z900_get_float128
  00241	33 c0		 xor	 eax, eax
  00243	85 c0		 test	 eax, eax
  00245	75 aa		 jne	 SHORT $LN10@z900_multi

; 3927 : 
; 3928 :     softfloat_exceptionFlags = 0;

  00247	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0024c	8b c0		 mov	 eax, eax
  0024e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00254	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00261	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3929 :     SET_SF_RM_FROM_FPC;

  00265	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00273	83 e0 07	 and	 eax, 7
  00276	8b c0		 mov	 eax, eax
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0027f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00284	8b d2		 mov	 edx, edx
  00286	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028d	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00296	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029e	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3930 : 
; 3931 :     ans = f128_mul( op1, op2 );

  002a2	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  002a7	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  002af	48 8b f8	 mov	 rdi, rax
  002b2	48 8b f1	 mov	 rsi, rcx
  002b5	b9 10 00 00 00	 mov	 ecx, 16
  002ba	f3 a4		 rep movsb
  002bc	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  002c1	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  002c9	48 8b f8	 mov	 rdi, rax
  002cc	48 8b f1	 mov	 rsi, rcx
  002cf	b9 10 00 00 00	 mov	 ecx, 16
  002d4	f3 a4		 rep movsb
  002d6	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  002db	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  002e0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  002e5	e8 00 00 00 00	 call	 f128_mul
  002ea	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  002f2	48 8b f9	 mov	 rdi, rcx
  002f5	48 8b f0	 mov	 rsi, rax
  002f8	b9 10 00 00 00	 mov	 ecx, 16
  002fd	f3 a4		 rep movsb

; 3932 : 
; 3933 :     if (softfloat_exceptionFlags)

  002ff	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00304	8b c0		 mov	 eax, eax
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00315	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00319	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031d	85 c0		 test	 eax, eax
  0031f	0f 84 b2 00 00
	00		 je	 $LN18@z900_multi

; 3934 :     {
; 3935 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00325	33 c0		 xor	 eax, eax
  00327	83 f8 01	 cmp	 eax, 1
  0032a	74 4b		 je	 SHORT $LN19@z900_multi
  0032c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00331	8b c0		 mov	 eax, eax
  00333	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00339	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00342	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00346	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034a	83 e0 10	 and	 eax, 16
  0034d	85 c0		 test	 eax, eax
  0034f	74 26		 je	 SHORT $LN19@z900_multi
  00351	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00359	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0035f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00364	85 c0		 test	 eax, eax
  00366	74 0f		 je	 SHORT $LN19@z900_multi
  00368	b2 80		 mov	 dl, 128			; 00000080H
  0036a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00372	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_multi:

; 3936 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00377	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037f	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00384	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3937 : 
; 3938 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00388	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0038c	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00391	85 c0		 test	 eax, eax
  00393	74 42		 je	 SHORT $LN20@z900_multi

; 3939 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00395	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00399	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0039e	85 c0		 test	 eax, eax
  003a0	74 0a		 je	 SHORT $LN23@z900_multi
  003a2	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv223[rsp], -24576 ; ffffffffffffa000H
  003aa	eb 08		 jmp	 SHORT $LN24@z900_multi
$LN23@z900_multi:
  003ac	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv223[rsp], 24576 ; 00006000H
$LN24@z900_multi:
  003b4	8b 54 24 30	 mov	 edx, DWORD PTR tv223[rsp]
  003b8	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  003bd	e8 00 00 00 00	 call	 f128_scaledResult
  003c2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  003ca	48 8b f9	 mov	 rdi, rcx
  003cd	48 8b f0	 mov	 rsi, rax
  003d0	b9 10 00 00 00	 mov	 ecx, 16
  003d5	f3 a4		 rep movsb
$LN20@z900_multi:
$LN18@z900_multi:

; 3940 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 3941 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 3942 :     }
; 3943 : 
; 3944 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  003d7	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  003db	d1 e0		 shl	 eax, 1
  003dd	48 98		 cdqe
  003df	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e7	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003ef	48 8b d0	 mov	 rdx, rax
  003f2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  003fa	e8 00 00 00 00	 call	 z900_put_float128

; 3945 : 
; 3946 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003ff	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00403	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00408	85 c0		 test	 eax, eax
  0040a	74 11		 je	 SHORT $LN21@z900_multi
  0040c	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00410	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00418	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_multi:

; 3947 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3948 : }

  0041d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00425	48 33 cc	 xor	 rcx, rsp
  00428	e8 00 00 00 00	 call	 __security_check_cookie
  0042d	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00434	5f		 pop	 rdi
  00435	5e		 pop	 rsi
  00436	c3		 ret	 0
z900_multiply_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv225 = 40
r1$ = 44
ans$ = 48
r3$ = 52
r2$ = 56
op1$ = 60
op3$ = 64
op2$ = 68
inst$ = 96
regs$ = 104
z900_multiply_add_bfp_short_reg PROC

; 4405 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4406 :     int        r1, r2, r3;
; 4407 :     float32_t  op1, op2, op3, ans;
; 4408 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4409 : 
; 4410 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN11@z900_multi
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4411 :     TXF_FLOAT_INSTR_CHECK( regs );

  00081	33 c0		 xor	 eax, eax
  00083	83 f8 01	 cmp	 eax, 1
  00086	74 6f		 je	 SHORT $LN12@z900_multi
  00088	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00094	85 c0		 test	 eax, eax
  00096	74 5f		 je	 SHORT $LN12@z900_multi
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 23		 jne	 SHORT $LN13@z900_multi
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000aa	85 c0		 test	 eax, eax
  000ac	75 13		 jne	 SHORT $LN13@z900_multi
  000ae	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b3	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ba	83 e0 04	 and	 eax, 4
  000bd	85 c0		 test	 eax, eax
  000bf	75 36		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000cc	0f ba e8 0b	 bts	 eax, 11
  000d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200889
  000e2	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e8	ba 02 00 00 00	 mov	 edx, 2
  000ed	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  000f7	33 c0		 xor	 eax, eax
  000f9	85 c0		 test	 eax, eax
  000fb	75 84		 jne	 SHORT $LN7@z900_multi

; 4412 :     BFPINST_CHECK( regs );

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00113	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00119	48 85 c0	 test	 rax, rax
  0011c	74 3c		 je	 SHORT $LN15@z900_multi
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00129	d1 e8		 shr	 eax, 1
  0012b	83 e0 01	 and	 eax, 1
  0012e	85 c0		 test	 eax, eax
  00130	74 4c		 je	 SHORT $LN14@z900_multi
  00132	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013e	b9 08 00 00 00	 mov	 ecx, 8
  00143	48 6b c9 01	 imul	 rcx, rcx, 1
  00147	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0014f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00155	48 85 c0	 test	 rax, rax
  00158	75 24		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0015a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00169	ba 07 00 00 00	 mov	 edx, 7
  0016e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00178	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:
$LN10@z900_multi:

; 4413 : 
; 4414 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  0017e	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00182	d1 e0		 shl	 eax, 1
  00184	48 98		 cdqe
  00186	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00193	48 8b d0	 mov	 rdx, rax
  00196	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 z900_get_float32
  001a0	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  001a4	d1 e0		 shl	 eax, 1
  001a6	48 98		 cdqe
  001a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ad	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b5	48 8b d0	 mov	 rdx, rax
  001b8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op3$[rsp]
  001bd	e8 00 00 00 00	 call	 z900_get_float32
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	75 b6		 jne	 SHORT $LN10@z900_multi

; 4415 :     GET_FLOAT32_OP( op2, r2, regs );

  001c8	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  001cc	d1 e0		 shl	 eax, 1
  001ce	48 98		 cdqe
  001d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001d5	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001dd	48 8b d0	 mov	 rdx, rax
  001e0	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op2$[rsp]
  001e5	e8 00 00 00 00	 call	 z900_get_float32

; 4416 : 
; 4417 :     softfloat_exceptionFlags = 0;

  001ea	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ef	8b c0		 mov	 eax, eax
  001f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00200	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00204	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4418 :     SET_SF_RM_FROM_FPC;

  00208	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00213	83 e0 07	 and	 eax, 7
  00216	8b c0		 mov	 eax, eax
  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0021f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00224	8b d2		 mov	 edx, edx
  00226	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0022d	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00236	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0023a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023e	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4419 : 
; 4420 :     ans = f32_mulAdd( op2, op3, op1 );

  00242	44 8b 44 24 3c	 mov	 r8d, DWORD PTR op1$[rsp]
  00247	8b 54 24 40	 mov	 edx, DWORD PTR op3$[rsp]
  0024b	8b 4c 24 44	 mov	 ecx, DWORD PTR op2$[rsp]
  0024f	e8 00 00 00 00	 call	 f32_mulAdd
  00254	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 4421 : 
; 4422 :     if (softfloat_exceptionFlags)

  00258	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0025d	8b c0		 mov	 eax, eax
  0025f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00265	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00272	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00276	85 c0		 test	 eax, eax
  00278	0f 84 93 00 00
	00		 je	 $LN16@z900_multi

; 4423 :     {
; 4424 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0027e	33 c0		 xor	 eax, eax
  00280	83 f8 01	 cmp	 eax, 1
  00283	74 45		 je	 SHORT $LN17@z900_multi
  00285	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0028a	8b c0		 mov	 eax, eax
  0028c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00292	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a3	83 e0 10	 and	 eax, 16
  002a6	85 c0		 test	 eax, eax
  002a8	74 20		 je	 SHORT $LN17@z900_multi
  002aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002af	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002b5	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002ba	85 c0		 test	 eax, eax
  002bc	74 0c		 je	 SHORT $LN17@z900_multi
  002be	b2 80		 mov	 dl, 128			; 00000080H
  002c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c5	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_multi:

; 4425 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002cf	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002d4	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4426 : 
; 4427 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002d8	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002dc	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002e1	85 c0		 test	 eax, eax
  002e3	74 2c		 je	 SHORT $LN18@z900_multi

; 4428 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002e5	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e9	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002ee	85 c0		 test	 eax, eax
  002f0	74 0a		 je	 SHORT $LN21@z900_multi
  002f2	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv225[rsp], -192 ; ffffffffffffff40H
  002fa	eb 08		 jmp	 SHORT $LN22@z900_multi
$LN21@z900_multi:
  002fc	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv225[rsp], 192 ; 000000c0H
$LN22@z900_multi:
  00304	8b 4c 24 28	 mov	 ecx, DWORD PTR tv225[rsp]
  00308	e8 00 00 00 00	 call	 f32_scaledResult
  0030d	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN18@z900_multi:
$LN16@z900_multi:

; 4429 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4430 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4431 :     }
; 4432 : 
; 4433 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  00311	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00315	d1 e0		 shl	 eax, 1
  00317	48 98		 cdqe
  00319	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00326	48 8b d0	 mov	 rdx, rax
  00329	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  0032e	e8 00 00 00 00	 call	 z900_put_float32

; 4434 : 
; 4435 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00333	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00337	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0033c	85 c0		 test	 eax, eax
  0033e	74 0e		 je	 SHORT $LN19@z900_multi
  00340	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00344	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00349	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_multi:

; 4436 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4437 : }

  0034e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00352	c3		 ret	 0
z900_multiply_add_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
tv248 = 56
r1$ = 60
ans$ = 64
r3$ = 68
op1$ = 72
op3$ = 76
op2$ = 80
inst$ = 112
regs$ = 120
z900_multiply_add_bfp_short PROC

; 4443 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4444 :     int        x2, r1, r3, b2;
; 4445 :     VADR       effective_addr2;
; 4446 :     float32_t  op1, op2, op3, ans;
; 4447 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4448 : 
; 4449 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 04	 imul	 rax, rax, 4
  00034	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	c1 f8 04	 sar	 eax, 4
  00040	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	8b c0		 mov	 eax, eax
  0004f	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 10	 shr	 eax, 16
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 14	 shr	 eax, 20
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 44	 mov	 DWORD PTR r3$[rsp], eax
  00070	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00075	74 22		 je	 SHORT $LN11@z900_multi
  00077	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0007c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0008e	48 03 c8	 add	 rcx, rax
  00091	48 8b c1	 mov	 rax, rcx
  00094	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_multi:
  00099	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0009d	c1 e8 0c	 shr	 eax, 12
  000a0	83 e0 0f	 and	 eax, 15
  000a3	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  000a7	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ac	74 22		 je	 SHORT $LN12@z900_multi
  000ae	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000c0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c5	48 03 c8	 add	 rcx, rax
  000c8	48 8b c1	 mov	 rax, rcx
  000cb	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_multi:
  000d0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e1	48 23 c8	 and	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_multi:
  000ec	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f5	48 83 c0 06	 add	 rax, 6
  000f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00102	33 c0		 xor	 eax, eax
  00104	83 f8 06	 cmp	 eax, 6
  00107	74 0c		 je	 SHORT $LN13@z900_multi
  00109	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_multi:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	75 d1		 jne	 SHORT $LN4@z900_multi

; 4450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  0011b	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  00120	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00124	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00129	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 4451 :     TXF_FLOAT_INSTR_CHECK( regs );

  0012e	33 c0		 xor	 eax, eax
  00130	83 f8 01	 cmp	 eax, 1
  00133	74 6f		 je	 SHORT $LN14@z900_multi
  00135	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00141	85 c0		 test	 eax, eax
  00143	74 5f		 je	 SHORT $LN14@z900_multi
  00145	33 c0		 xor	 eax, eax
  00147	85 c0		 test	 eax, eax
  00149	75 23		 jne	 SHORT $LN15@z900_multi
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00157	85 c0		 test	 eax, eax
  00159	75 13		 jne	 SHORT $LN15@z900_multi
  0015b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00160	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00167	83 e0 04	 and	 eax, 4
  0016a	85 c0		 test	 eax, eax
  0016c	75 36		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0016e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00173	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00179	0f ba e8 0b	 bts	 eax, 11
  0017d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00188	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200926
  0018f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00195	ba 02 00 00 00	 mov	 edx, 2
  0019a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_multi:
  001a4	33 c0		 xor	 eax, eax
  001a6	85 c0		 test	 eax, eax
  001a8	75 84		 jne	 SHORT $LN7@z900_multi

; 4452 :     BFPINST_CHECK( regs );

  001aa	b8 08 00 00 00	 mov	 eax, 8
  001af	48 6b c0 01	 imul	 rax, rax, 1
  001b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001c0	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001c6	48 85 c0	 test	 rax, rax
  001c9	74 3c		 je	 SHORT $LN17@z900_multi
  001cb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001d0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001d6	d1 e8		 shr	 eax, 1
  001d8	83 e0 01	 and	 eax, 1
  001db	85 c0		 test	 eax, eax
  001dd	74 4c		 je	 SHORT $LN16@z900_multi
  001df	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001eb	b9 08 00 00 00	 mov	 ecx, 8
  001f0	48 6b c9 01	 imul	 rcx, rcx, 1
  001f4	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001fc	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00202	48 85 c0	 test	 rax, rax
  00205	75 24		 jne	 SHORT $LN16@z900_multi
$LN17@z900_multi:
  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00216	ba 07 00 00 00	 mov	 edx, 7
  0021b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00220	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00225	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_multi:
$LN10@z900_multi:

; 4453 : 
; 4454 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  0022b	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0022f	d1 e0		 shl	 eax, 1
  00231	48 98		 cdqe
  00233	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00238	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00240	48 8b d0	 mov	 rdx, rax
  00243	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00248	e8 00 00 00 00	 call	 z900_get_float32
  0024d	8b 44 24 44	 mov	 eax, DWORD PTR r3$[rsp]
  00251	d1 e0		 shl	 eax, 1
  00253	48 98		 cdqe
  00255	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0025a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00262	48 8b d0	 mov	 rdx, rax
  00265	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR op3$[rsp]
  0026a	e8 00 00 00 00	 call	 z900_get_float32
  0026f	33 c0		 xor	 eax, eax
  00271	85 c0		 test	 eax, eax
  00273	75 b6		 jne	 SHORT $LN10@z900_multi

; 4455 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00275	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0027a	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  0027e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00283	e8 00 00 00 00	 call	 z900_vfetch4
  00288	89 44 24 50	 mov	 DWORD PTR op2$[rsp], eax

; 4456 : 
; 4457 :     softfloat_exceptionFlags = 0;

  0028c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00291	8b c0		 mov	 eax, eax
  00293	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00299	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4458 :     SET_SF_RM_FROM_FPC;

  002aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002af	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002b5	83 e0 07	 and	 eax, 7
  002b8	8b c0		 mov	 eax, eax
  002ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002c1	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  002c6	8b d2		 mov	 edx, edx
  002c8	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  002cf	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  002d8	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  002dc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e0	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4459 : 
; 4460 :     ans = f32_mulAdd( op2, op3, op1 );

  002e4	44 8b 44 24 48	 mov	 r8d, DWORD PTR op1$[rsp]
  002e9	8b 54 24 4c	 mov	 edx, DWORD PTR op3$[rsp]
  002ed	8b 4c 24 50	 mov	 ecx, DWORD PTR op2$[rsp]
  002f1	e8 00 00 00 00	 call	 f32_mulAdd
  002f6	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax

; 4461 : 
; 4462 :     if (softfloat_exceptionFlags)

  002fa	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ff	8b c0		 mov	 eax, eax
  00301	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00307	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00310	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00314	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00318	85 c0		 test	 eax, eax
  0031a	0f 84 93 00 00
	00		 je	 $LN18@z900_multi

; 4463 :     {
; 4464 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00320	33 c0		 xor	 eax, eax
  00322	83 f8 01	 cmp	 eax, 1
  00325	74 45		 je	 SHORT $LN19@z900_multi
  00327	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0032c	8b c0		 mov	 eax, eax
  0032e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00334	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0033d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00341	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00345	83 e0 10	 and	 eax, 16
  00348	85 c0		 test	 eax, eax
  0034a	74 20		 je	 SHORT $LN19@z900_multi
  0034c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00351	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00357	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0035c	85 c0		 test	 eax, eax
  0035e	74 0c		 je	 SHORT $LN19@z900_multi
  00360	b2 80		 mov	 dl, 128			; 00000080H
  00362	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00367	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_multi:

; 4465 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0036c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00371	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00376	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4466 : 
; 4467 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0037a	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0037e	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00383	85 c0		 test	 eax, eax
  00385	74 2c		 je	 SHORT $LN20@z900_multi

; 4468 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00387	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0038b	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00390	85 c0		 test	 eax, eax
  00392	74 0a		 je	 SHORT $LN23@z900_multi
  00394	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv248[rsp], -192 ; ffffffffffffff40H
  0039c	eb 08		 jmp	 SHORT $LN24@z900_multi
$LN23@z900_multi:
  0039e	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv248[rsp], 192 ; 000000c0H
$LN24@z900_multi:
  003a6	8b 4c 24 38	 mov	 ecx, DWORD PTR tv248[rsp]
  003aa	e8 00 00 00 00	 call	 f32_scaledResult
  003af	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax
$LN20@z900_multi:
$LN18@z900_multi:

; 4469 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4470 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4471 :     }
; 4472 : 
; 4473 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  003b3	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  003b7	d1 e0		 shl	 eax, 1
  003b9	48 98		 cdqe
  003bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003c0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003c8	48 8b d0	 mov	 rdx, rax
  003cb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  003d0	e8 00 00 00 00	 call	 z900_put_float32

; 4474 : 
; 4475 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003d5	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003d9	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003de	85 c0		 test	 eax, eax
  003e0	74 0e		 je	 SHORT $LN21@z900_multi
  003e2	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003eb	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_multi:

; 4476 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4477 : }

  003f0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003f4	c3		 ret	 0
z900_multiply_add_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv225 = 40
r1$ = 44
r3$ = 48
r2$ = 52
ans$ = 56
op1$ = 64
op3$ = 72
op2$ = 80
inst$ = 112
regs$ = 120
z900_multiply_add_bfp_long_reg PROC

; 4327 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4328 :     int        r1, r2, r3;
; 4329 :     float64_t  op1, op2, op3, ans;
; 4330 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4331 : 
; 4332 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  00052	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN11@z900_multi
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4333 :     TXF_FLOAT_INSTR_CHECK( regs );

  00081	33 c0		 xor	 eax, eax
  00083	83 f8 01	 cmp	 eax, 1
  00086	74 6f		 je	 SHORT $LN12@z900_multi
  00088	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00094	85 c0		 test	 eax, eax
  00096	74 5f		 je	 SHORT $LN12@z900_multi
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 23		 jne	 SHORT $LN13@z900_multi
  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000aa	85 c0		 test	 eax, eax
  000ac	75 13		 jne	 SHORT $LN13@z900_multi
  000ae	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b3	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ba	83 e0 04	 and	 eax, 4
  000bd	85 c0		 test	 eax, eax
  000bf	75 36		 jne	 SHORT $LN12@z900_multi
$LN13@z900_multi:
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000cc	0f ba e8 0b	 bts	 eax, 11
  000d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200819
  000e2	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e8	ba 02 00 00 00	 mov	 edx, 2
  000ed	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_multi:
  000f7	33 c0		 xor	 eax, eax
  000f9	85 c0		 test	 eax, eax
  000fb	75 84		 jne	 SHORT $LN7@z900_multi

; 4334 :     BFPINST_CHECK( regs );

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00113	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00119	48 85 c0	 test	 rax, rax
  0011c	74 3c		 je	 SHORT $LN15@z900_multi
  0011e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00123	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00129	d1 e8		 shr	 eax, 1
  0012b	83 e0 01	 and	 eax, 1
  0012e	85 c0		 test	 eax, eax
  00130	74 4c		 je	 SHORT $LN14@z900_multi
  00132	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013e	b9 08 00 00 00	 mov	 ecx, 8
  00143	48 6b c9 01	 imul	 rcx, rcx, 1
  00147	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0014f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00155	48 85 c0	 test	 rax, rax
  00158	75 24		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  0015a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00169	ba 07 00 00 00	 mov	 edx, 7
  0016e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00178	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_multi:
$LN10@z900_multi:

; 4335 : 
; 4336 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  0017e	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00182	d1 e0		 shl	 eax, 1
  00184	48 98		 cdqe
  00186	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00193	48 8b d0	 mov	 rdx, rax
  00196	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 z900_get_float64
  001a0	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  001a4	d1 e0		 shl	 eax, 1
  001a6	48 98		 cdqe
  001a8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ad	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b5	48 8b d0	 mov	 rdx, rax
  001b8	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  001bd	e8 00 00 00 00	 call	 z900_get_float64
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	75 b6		 jne	 SHORT $LN10@z900_multi

; 4337 :     GET_FLOAT64_OP( op2, r2, regs );

  001c8	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  001cc	d1 e0		 shl	 eax, 1
  001ce	48 98		 cdqe
  001d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001d5	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001dd	48 8b d0	 mov	 rdx, rax
  001e0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001e5	e8 00 00 00 00	 call	 z900_get_float64

; 4338 : 
; 4339 :     softfloat_exceptionFlags = 0;

  001ea	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ef	8b c0		 mov	 eax, eax
  001f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00200	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00204	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4340 :     SET_SF_RM_FROM_FPC;

  00208	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00213	83 e0 07	 and	 eax, 7
  00216	8b c0		 mov	 eax, eax
  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0021f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00224	8b d2		 mov	 edx, edx
  00226	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0022d	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00236	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0023a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023e	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4341 : 
; 4342 :     ans = f64_mulAdd( op2, op3, op1 );

  00242	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  00247	48 8b 54 24 48	 mov	 rdx, QWORD PTR op3$[rsp]
  0024c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  00251	e8 00 00 00 00	 call	 f64_mulAdd
  00256	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 4343 : 
; 4344 :     if (softfloat_exceptionFlags)

  0025b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00260	8b c0		 mov	 eax, eax
  00262	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00268	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00271	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00275	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00279	85 c0		 test	 eax, eax
  0027b	0f 84 94 00 00
	00		 je	 $LN16@z900_multi

; 4345 :     {
; 4346 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00281	33 c0		 xor	 eax, eax
  00283	83 f8 01	 cmp	 eax, 1
  00286	74 45		 je	 SHORT $LN17@z900_multi
  00288	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0028d	8b c0		 mov	 eax, eax
  0028f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00295	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a6	83 e0 10	 and	 eax, 16
  002a9	85 c0		 test	 eax, eax
  002ab	74 20		 je	 SHORT $LN17@z900_multi
  002ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002b2	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002b8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002bd	85 c0		 test	 eax, eax
  002bf	74 0c		 je	 SHORT $LN17@z900_multi
  002c1	b2 80		 mov	 dl, 128			; 00000080H
  002c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_multi:

; 4347 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002d7	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4348 : 
; 4349 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002db	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002df	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002e4	85 c0		 test	 eax, eax
  002e6	74 2d		 je	 SHORT $LN18@z900_multi

; 4350 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002e8	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ec	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002f1	85 c0		 test	 eax, eax
  002f3	74 0a		 je	 SHORT $LN21@z900_multi
  002f5	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv225[rsp], -1536 ; fffffffffffffa00H
  002fd	eb 08		 jmp	 SHORT $LN22@z900_multi
$LN21@z900_multi:
  002ff	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv225[rsp], 1536 ; 00000600H
$LN22@z900_multi:
  00307	8b 4c 24 28	 mov	 ecx, DWORD PTR tv225[rsp]
  0030b	e8 00 00 00 00	 call	 f64_scaledResult
  00310	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN18@z900_multi:
$LN16@z900_multi:

; 4351 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4352 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4353 :     }
; 4354 : 
; 4355 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00315	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00319	d1 e0		 shl	 eax, 1
  0031b	48 98		 cdqe
  0031d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00322	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0032a	48 8b d0	 mov	 rdx, rax
  0032d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  00332	e8 00 00 00 00	 call	 z900_put_float64

; 4356 : 
; 4357 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00337	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0033b	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00340	85 c0		 test	 eax, eax
  00342	74 0e		 je	 SHORT $LN19@z900_multi
  00344	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00348	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0034d	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_multi:

; 4358 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4359 : }

  00352	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00356	c3		 ret	 0
z900_multiply_add_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
tv248 = 56
r1$ = 60
r3$ = 64
ans$ = 72
op1$ = 80
op3$ = 88
op2$ = 96
inst$ = 128
regs$ = 136
z900_multiply_add_bfp_long PROC

; 4365 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4366 :     int        x2, r1, r3, b2;
; 4367 :     VADR       effective_addr2;
; 4368 :     float64_t  op1, op2, op3, ans;
; 4369 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4370 : 
; 4371 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 04	 imul	 rax, rax, 4
  00037	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00043	c1 f8 04	 sar	 eax, 4
  00046	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00053	8b c0		 mov	 eax, eax
  00055	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0005a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005e	c1 e8 10	 shr	 eax, 16
  00061	83 e0 0f	 and	 eax, 15
  00064	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00068	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0006c	c1 e8 14	 shr	 eax, 20
  0006f	83 e0 0f	 and	 eax, 15
  00072	89 44 24 40	 mov	 DWORD PTR r3$[rsp], eax
  00076	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007b	74 25		 je	 SHORT $LN11@z900_multi
  0007d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00082	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00097	48 03 c8	 add	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_multi:
  000a2	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  000a6	c1 e8 0c	 shr	 eax, 12
  000a9	83 e0 0f	 and	 eax, 15
  000ac	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  000b0	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b5	74 25		 je	 SHORT $LN12@z900_multi
  000b7	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_multi:
  000dc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000f0	48 23 c8	 and	 rcx, rax
  000f3	48 8b c1	 mov	 rax, rcx
  000f6	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_multi:
  000fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00103	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00107	48 83 c0 06	 add	 rax, 6
  0010b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0f		 je	 SHORT $LN13@z900_multi
  0011e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_multi:
  0012d	33 c0		 xor	 eax, eax
  0012f	85 c0		 test	 eax, eax
  00131	75 c8		 jne	 SHORT $LN4@z900_multi

; 4372 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00133	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  00138	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0013c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 4373 :     TXF_FLOAT_INSTR_CHECK( regs );

  00149	33 c0		 xor	 eax, eax
  0014b	83 f8 01	 cmp	 eax, 1
  0014e	0f 84 81 00 00
	00		 je	 $LN14@z900_multi
  00154	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00163	85 c0		 test	 eax, eax
  00165	74 6e		 je	 SHORT $LN14@z900_multi
  00167	33 c0		 xor	 eax, eax
  00169	85 c0		 test	 eax, eax
  0016b	75 29		 jne	 SHORT $LN15@z900_multi
  0016d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00175	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0017c	85 c0		 test	 eax, eax
  0017e	75 16		 jne	 SHORT $LN15@z900_multi
  00180	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00188	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0018f	83 e0 04	 and	 eax, 4
  00192	85 c0		 test	 eax, eax
  00194	75 3f		 jne	 SHORT $LN14@z900_multi
$LN15@z900_multi:
  00196	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001a4	0f ba e8 0b	 bts	 eax, 11
  001a8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001b6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200856
  001bd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001c3	ba 02 00 00 00	 mov	 edx, 2
  001c8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_multi:
  001d5	33 c0		 xor	 eax, eax
  001d7	85 c0		 test	 eax, eax
  001d9	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_multi

; 4374 :     BFPINST_CHECK( regs );

  001df	b8 08 00 00 00	 mov	 eax, 8
  001e4	48 6b c0 01	 imul	 rax, rax, 1
  001e8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f0	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001f8	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001fe	48 85 c0	 test	 rax, rax
  00201	74 42		 je	 SHORT $LN17@z900_multi
  00203	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00211	d1 e8		 shr	 eax, 1
  00213	83 e0 01	 and	 eax, 1
  00216	85 c0		 test	 eax, eax
  00218	74 58		 je	 SHORT $LN16@z900_multi
  0021a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00222	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00229	b9 08 00 00 00	 mov	 ecx, 8
  0022e	48 6b c9 01	 imul	 rcx, rcx, 1
  00232	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0023a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00240	48 85 c0	 test	 rax, rax
  00243	75 2d		 jne	 SHORT $LN16@z900_multi
$LN17@z900_multi:
  00245	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00257	ba 07 00 00 00	 mov	 edx, 7
  0025c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_multi:
$LN10@z900_multi:

; 4375 : 
; 4376 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  00272	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00276	d1 e0		 shl	 eax, 1
  00278	48 98		 cdqe
  0027a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00282	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0028a	48 8b d0	 mov	 rdx, rax
  0028d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  00292	e8 00 00 00 00	 call	 z900_get_float64
  00297	8b 44 24 40	 mov	 eax, DWORD PTR r3$[rsp]
  0029b	d1 e0		 shl	 eax, 1
  0029d	48 98		 cdqe
  0029f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a7	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002af	48 8b d0	 mov	 rdx, rax
  002b2	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op3$[rsp]
  002b7	e8 00 00 00 00	 call	 z900_get_float64
  002bc	33 c0		 xor	 eax, eax
  002be	85 c0		 test	 eax, eax
  002c0	75 b0		 jne	 SHORT $LN10@z900_multi

; 4377 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  002c2	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ca	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  002ce	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  002d3	e8 00 00 00 00	 call	 z900_vfetch8
  002d8	48 89 44 24 60	 mov	 QWORD PTR op2$[rsp], rax

; 4378 : 
; 4379 :     softfloat_exceptionFlags = 0;

  002dd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e2	8b c0		 mov	 eax, eax
  002e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ea	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002f7	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4380 :     SET_SF_RM_FROM_FPC;

  002fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00303	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00309	83 e0 07	 and	 eax, 7
  0030c	8b c0		 mov	 eax, eax
  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00315	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0031a	8b d2		 mov	 edx, edx
  0031c	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00323	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  0032c	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00330	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00334	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4381 : 
; 4382 :     ans = f64_mulAdd( op2, op3, op1 );

  00338	4c 8b 44 24 50	 mov	 r8, QWORD PTR op1$[rsp]
  0033d	48 8b 54 24 58	 mov	 rdx, QWORD PTR op3$[rsp]
  00342	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op2$[rsp]
  00347	e8 00 00 00 00	 call	 f64_mulAdd
  0034c	48 89 44 24 48	 mov	 QWORD PTR ans$[rsp], rax

; 4383 : 
; 4384 :     if (softfloat_exceptionFlags)

  00351	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00356	8b c0		 mov	 eax, eax
  00358	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0035e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00367	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0036b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036f	85 c0		 test	 eax, eax
  00371	0f 84 9d 00 00
	00		 je	 $LN18@z900_multi

; 4385 :     {
; 4386 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00377	33 c0		 xor	 eax, eax
  00379	83 f8 01	 cmp	 eax, 1
  0037c	74 4b		 je	 SHORT $LN19@z900_multi
  0037e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00383	8b c0		 mov	 eax, eax
  00385	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0038b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00394	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00398	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039c	83 e0 10	 and	 eax, 16
  0039f	85 c0		 test	 eax, eax
  003a1	74 26		 je	 SHORT $LN19@z900_multi
  003a3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ab	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003b1	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003b6	85 c0		 test	 eax, eax
  003b8	74 0f		 je	 SHORT $LN19@z900_multi
  003ba	b2 80		 mov	 dl, 128			; 00000080H
  003bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c4	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_multi:

; 4387 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  003c9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d1	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003d6	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4388 : 
; 4389 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  003da	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003de	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  003e3	85 c0		 test	 eax, eax
  003e5	74 2d		 je	 SHORT $LN20@z900_multi

; 4390 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  003e7	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003eb	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003f0	85 c0		 test	 eax, eax
  003f2	74 0a		 je	 SHORT $LN23@z900_multi
  003f4	c7 44 24 38 00
	fa ff ff	 mov	 DWORD PTR tv248[rsp], -1536 ; fffffffffffffa00H
  003fc	eb 08		 jmp	 SHORT $LN24@z900_multi
$LN23@z900_multi:
  003fe	c7 44 24 38 00
	06 00 00	 mov	 DWORD PTR tv248[rsp], 1536 ; 00000600H
$LN24@z900_multi:
  00406	8b 4c 24 38	 mov	 ecx, DWORD PTR tv248[rsp]
  0040a	e8 00 00 00 00	 call	 f64_scaledResult
  0040f	48 89 44 24 48	 mov	 QWORD PTR ans$[rsp], rax
$LN20@z900_multi:
$LN18@z900_multi:

; 4391 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4392 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4393 :     }
; 4394 : 
; 4395 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00414	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00418	d1 e0		 shl	 eax, 1
  0041a	48 98		 cdqe
  0041c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00424	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0042c	48 8b d0	 mov	 rdx, rax
  0042f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ans$[rsp]
  00434	e8 00 00 00 00	 call	 z900_put_float64

; 4396 : 
; 4397 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00439	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0043d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00442	85 c0		 test	 eax, eax
  00444	74 11		 je	 SHORT $LN21@z900_multi
  00446	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0044a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00452	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_multi:

; 4398 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4399 : }

  00457	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0045b	c3		 ret	 0
z900_multiply_add_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
tv187 = 44
tv276 = 48
r1$ = 52
r2$ = 56
op1$ = 60
op2$ = 64
inst$ = 96
regs$ = 104
z900_load_rounded_bfp_long_to_short_reg PROC

; 3726 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3727 :     int        r1, r2;
; 3728 :     BYTE       m3, m4;
; 3729 :     float64_t  op2;
; 3730 :     float32_t  op1;
; 3731 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3732 : 
; 3733 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_load_:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_load_
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3734 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_load_
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_load_
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_load_
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_load_
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200403
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_load_

; 3735 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_load_
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_load_
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3736 : 
; 3737 :     GET_FLOAT64_OP( op2, r2, regs );

  0018c	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  00190	d1 e0		 shl	 eax, 1
  00192	48 98		 cdqe
  00194	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a1	48 8b d0	 mov	 rdx, rax
  001a4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  001a9	e8 00 00 00 00	 call	 z900_get_float64

; 3738 : 
; 3739 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3740 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  001ae	b8 01 00 00 00	 mov	 eax, 1
  001b3	48 6b c0 04	 imul	 rax, rax, 4
  001b7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001bc	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001c4	83 e0 04	 and	 eax, 4
  001c7	85 c0		 test	 eax, eax
  001c9	74 62		 je	 SHORT $LN13@z900_load_

; 3741 :         SET_SF_RM_FROM_MASK( m3 );

  001cb	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001d0	85 c0		 test	 eax, eax
  001d2	74 16		 je	 SHORT $LN24@z900_load_
  001d4	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001e0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e4	89 44 24 2c	 mov	 DWORD PTR tv187[rsp], eax
  001e8	eb 1f		 jmp	 SHORT $LN25@z900_load_
$LN24@z900_load_:
  001ea	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f5	83 e0 07	 and	 eax, 7
  001f8	8b c0		 mov	 eax, eax
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00201	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00205	89 44 24 2c	 mov	 DWORD PTR tv187[rsp], eax
$LN25@z900_load_:
  00209	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0020e	8b c0		 mov	 eax, eax
  00210	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00216	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00223	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv187[rsp]
  00228	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  0022b	eb 61		 jmp	 SHORT $LN14@z900_load_
$LN13@z900_load_:

; 3742 :     else
; 3743 : #endif
; 3744 :     {
; 3745 :         if (m3 || m4)

  0022d	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00232	85 c0		 test	 eax, eax
  00234	75 09		 jne	 SHORT $LN16@z900_load_
  00236	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  0023b	85 c0		 test	 eax, eax
  0023d	74 15		 je	 SHORT $LN15@z900_load_
$LN16@z900_load_:

; 3746 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0023f	ba 06 00 00 00	 mov	 edx, 6
  00244	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_load_:

; 3747 :         SET_SF_RM_FROM_FPC;

  00254	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00259	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0025f	83 e0 07	 and	 eax, 7
  00262	8b c0		 mov	 eax, eax
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0026b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00270	8b d2		 mov	 edx, edx
  00272	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00279	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00282	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00286	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028a	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al
$LN14@z900_load_:

; 3748 :     }
; 3749 : 
; 3750 :     softfloat_exceptionFlags = 0;

  0028e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00293	8b c0		 mov	 eax, eax
  00295	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a8	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3751 : 
; 3752 :     op1 = f64_to_f32( op2 );

  002ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  002b1	e8 00 00 00 00	 call	 f64_to_f32
  002b6	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 3753 : 
; 3754 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3755 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  002ba	b8 01 00 00 00	 mov	 eax, 1
  002bf	48 6b c0 04	 imul	 rax, rax, 4
  002c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  002d0	83 e0 04	 and	 eax, 4
  002d3	85 c0		 test	 eax, eax
  002d5	74 4d		 je	 SHORT $LN17@z900_load_

; 3756 :     {
; 3757 :         if (SUPPRESS_INEXACT( m4 ))

  002d7	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002dc	83 e0 04	 and	 eax, 4
  002df	85 c0		 test	 eax, eax
  002e1	74 41		 je	 SHORT $LN18@z900_load_

; 3758 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;

  002e3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e8	8b c0		 mov	 eax, eax
  002ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00301	83 e0 fe	 and	 eax, -2
  00304	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00313	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00319	45 8b c0	 mov	 r8d, r8d
  0031c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00320	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN18@z900_load_:
$LN17@z900_load_:

; 3759 :     }
; 3760 : #endif
; 3761 : 
; 3762 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00324	33 c0		 xor	 eax, eax
  00326	83 f8 01	 cmp	 eax, 1
  00329	74 45		 je	 SHORT $LN19@z900_load_
  0032b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00330	8b c0		 mov	 eax, eax
  00332	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00338	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00341	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00345	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00349	83 e0 10	 and	 eax, 16
  0034c	85 c0		 test	 eax, eax
  0034e	74 20		 je	 SHORT $LN19@z900_load_
  00350	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00355	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0035b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00360	85 c0		 test	 eax, eax
  00362	74 0c		 je	 SHORT $LN19@z900_load_
  00364	b2 80		 mov	 dl, 128			; 00000080H
  00366	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0036b	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_load_:

; 3763 : 
; 3764 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  00370	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00374	d1 e0		 shl	 eax, 1
  00376	48 98		 cdqe
  00378	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0037d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00385	48 8b d0	 mov	 rdx, rax
  00388	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0038d	e8 00 00 00 00	 call	 z900_put_float32

; 3765 : 
; 3766 :     if (softfloat_exceptionFlags)

  00392	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00397	8b c0		 mov	 eax, eax
  00399	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0039f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b0	85 c0		 test	 eax, eax
  003b2	0f 84 85 00 00
	00		 je	 $LN20@z900_load_

; 3767 :     {
; 3768 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  003b8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003bd	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003c2	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3769 : 
; 3770 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  003c6	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003ca	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  003cf	85 c0		 test	 eax, eax
  003d1	74 4f		 je	 SHORT $LN21@z900_load_

; 3771 :         {
; 3772 :             op2 = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  003d3	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003d7	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003dc	85 c0		 test	 eax, eax
  003de	74 0a		 je	 SHORT $LN26@z900_load_
  003e0	c7 44 24 30 00
	fe ff ff	 mov	 DWORD PTR tv276[rsp], -512 ; fffffffffffffe00H
  003e8	eb 08		 jmp	 SHORT $LN27@z900_load_
$LN26@z900_load_:
  003ea	c7 44 24 30 00
	02 00 00	 mov	 DWORD PTR tv276[rsp], 512 ; 00000200H
$LN27@z900_load_:
  003f2	8b 4c 24 30	 mov	 ecx, DWORD PTR tv276[rsp]
  003f6	e8 00 00 00 00	 call	 f64_scaledResult
  003fb	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 3773 :                 SCALE_FACTOR_LOADR_OFLOW_LONG :
; 3774 :                 SCALE_FACTOR_LOADR_UFLOW_LONG );
; 3775 : 
; 3776 :             PUT_FLOAT64_NOCC( op2, r1, regs );

  00400	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00404	d1 e0		 shl	 eax, 1
  00406	48 98		 cdqe
  00408	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0040d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00415	48 8b d0	 mov	 rdx, rax
  00418	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  0041d	e8 00 00 00 00	 call	 z900_put_float64
$LN21@z900_load_:

; 3777 :         }
; 3778 : 
; 3779 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00422	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00426	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0042b	85 c0		 test	 eax, eax
  0042d	74 0e		 je	 SHORT $LN22@z900_load_
  0042f	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00433	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00438	e8 00 00 00 00	 call	 ieee_cond_trap
$LN22@z900_load_:
$LN20@z900_load_:

; 3780 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3781 :     }
; 3782 : }

  0043d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00441	c3		 ret	 0
z900_load_rounded_bfp_long_to_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
r1$ = 44
r2$ = 48
tv194 = 52
tv283 = 56
op1$ = 60
$T2 = 64
$T3 = 80
op2$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
z900_load_rounded_bfp_ext_to_short_reg PROC

; 3853 : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3854 :     int         r1, r2;
; 3855 :     BYTE        m3, m4;
; 3856 :     float128_t  op2;
; 3857 :     float32_t   op1;
; 3858 :     U32         ieee_trap_conds = 0;

  00022	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3859 : 
; 3860 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  0004d	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 04	 shr	 eax, 4
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0005b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 08	 shr	 eax, 8
  00062	83 e0 0f	 and	 eax, 15
  00065	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00069	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 0c	 shr	 eax, 12
  00070	83 e0 0f	 and	 eax, 15
  00073	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_load_:
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00083	48 83 c0 04	 add	 rax, 4
  00087	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00093	33 c0		 xor	 eax, eax
  00095	83 f8 04	 cmp	 eax, 4
  00098	74 0f		 je	 SHORT $LN8@z900_load_
  0009a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3861 :     TXF_FLOAT_INSTR_CHECK( regs );

  000af	33 c0		 xor	 eax, eax
  000b1	83 f8 01	 cmp	 eax, 1
  000b4	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000ba	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c9	85 c0		 test	 eax, eax
  000cb	74 6e		 je	 SHORT $LN9@z900_load_
  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 29		 jne	 SHORT $LN10@z900_load_
  000d3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000e2	85 c0		 test	 eax, eax
  000e4	75 16		 jne	 SHORT $LN10@z900_load_
  000e6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000f5	83 e0 04	 and	 eax, 4
  000f8	85 c0		 test	 eax, eax
  000fa	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000fc	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00104	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010a	0f ba e8 0b	 bts	 eax, 11
  0010e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200475
  00123	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00129	ba 02 00 00 00	 mov	 edx, 2
  0012e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  0013b	33 c0		 xor	 eax, eax
  0013d	85 c0		 test	 eax, eax
  0013f	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 3862 :     BFPINST_CHECK( regs );

  00145	b8 08 00 00 00	 mov	 eax, 8
  0014a	48 6b c0 01	 imul	 rax, rax, 1
  0014e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0015e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00164	48 85 c0	 test	 rax, rax
  00167	74 42		 je	 SHORT $LN12@z900_load_
  00169	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00171	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00177	d1 e8		 shr	 eax, 1
  00179	83 e0 01	 and	 eax, 1
  0017c	85 c0		 test	 eax, eax
  0017e	74 58		 je	 SHORT $LN11@z900_load_
  00180	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00188	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0018f	b9 08 00 00 00	 mov	 ecx, 8
  00194	48 6b c9 01	 imul	 rcx, rcx, 1
  00198	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001a0	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a6	48 85 c0	 test	 rax, rax
  001a9	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  001ab	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001bd	ba 07 00 00 00	 mov	 edx, 7
  001c2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3863 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001d8	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001dc	83 e0 02	 and	 eax, 2
  001df	85 c0		 test	 eax, eax
  001e1	75 0b		 jne	 SHORT $LN14@z900_load_
  001e3	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  001e7	83 e0 02	 and	 eax, 2
  001ea	85 c0		 test	 eax, eax
  001ec	74 1b		 je	 SHORT $LN13@z900_load_
$LN14@z900_load_:
  001ee	ba 06 00 00 00	 mov	 edx, 6
  001f3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00203	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 3864 : 
; 3865 :     GET_FLOAT128_OP( op2, r2, regs );

  00209	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0020d	d1 e0		 shl	 eax, 1
  0020f	48 98		 cdqe
  00211	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00221	48 8b d0	 mov	 rdx, rax
  00224	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  00229	e8 00 00 00 00	 call	 z900_get_float128

; 3866 : 
; 3867 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3868 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0022e	b8 01 00 00 00	 mov	 eax, 1
  00233	48 6b c0 04	 imul	 rax, rax, 4
  00237	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00247	83 e0 04	 and	 eax, 4
  0024a	85 c0		 test	 eax, eax
  0024c	74 65		 je	 SHORT $LN15@z900_load_

; 3869 :         SET_SF_RM_FROM_MASK( m3 );

  0024e	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00253	85 c0		 test	 eax, eax
  00255	74 16		 je	 SHORT $LN26@z900_load_
  00257	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00263	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00267	89 44 24 34	 mov	 DWORD PTR tv194[rsp], eax
  0026b	eb 22		 jmp	 SHORT $LN27@z900_load_
$LN26@z900_load_:
  0026d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00275	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0027b	83 e0 07	 and	 eax, 7
  0027e	8b c0		 mov	 eax, eax
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00287	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028b	89 44 24 34	 mov	 DWORD PTR tv194[rsp], eax
$LN27@z900_load_:
  0028f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00294	8b c0		 mov	 eax, eax
  00296	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a9	0f b6 54 24 34	 movzx	 edx, BYTE PTR tv194[rsp]
  002ae	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  002b1	eb 6a		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:

; 3870 :     else
; 3871 : #endif
; 3872 :     {
; 3873 :         if (m3 || m4)

  002b3	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  002b8	85 c0		 test	 eax, eax
  002ba	75 09		 jne	 SHORT $LN18@z900_load_
  002bc	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002c1	85 c0		 test	 eax, eax
  002c3	74 1b		 je	 SHORT $LN17@z900_load_
$LN18@z900_load_:

; 3874 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  002c5	ba 06 00 00 00	 mov	 edx, 6
  002ca	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002da	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_load_:

; 3875 :         SET_SF_RM_FROM_FPC;

  002e0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ee	83 e0 07	 and	 eax, 7
  002f1	8b c0		 mov	 eax, eax
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002fa	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  002ff	8b d2		 mov	 edx, edx
  00301	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00308	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00311	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00315	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00319	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al
$LN16@z900_load_:

; 3876 :     }
; 3877 : 
; 3878 :     softfloat_exceptionFlags = 0;

  0031d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00322	8b c0		 mov	 eax, eax
  00324	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0032a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00333	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00337	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3879 : 
; 3880 :     op1 = f128_to_f32( op2 );

  0033b	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  00340	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  00345	48 8b f8	 mov	 rdi, rax
  00348	48 8b f1	 mov	 rsi, rcx
  0034b	b9 10 00 00 00	 mov	 ecx, 16
  00350	f3 a4		 rep movsb
  00352	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00357	e8 00 00 00 00	 call	 f128_to_f32
  0035c	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 3881 : 
; 3882 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3883 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00360	b8 01 00 00 00	 mov	 eax, 1
  00365	48 6b c0 04	 imul	 rax, rax, 4
  00369	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00371	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00379	83 e0 04	 and	 eax, 4
  0037c	85 c0		 test	 eax, eax
  0037e	74 4a		 je	 SHORT $LN19@z900_load_

; 3884 :     {
; 3885 :         if (SUPPRESS_INEXACT( m4 ))

  00380	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00385	83 e0 04	 and	 eax, 4
  00388	85 c0		 test	 eax, eax
  0038a	74 3e		 je	 SHORT $LN20@z900_load_

; 3886 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;

  0038c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00391	8b c0		 mov	 eax, eax
  00393	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00399	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003a2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003aa	83 e0 fe	 and	 eax, -2
  003ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003b3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003bc	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  003c1	8b ff		 mov	 edi, edi
  003c3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003c7	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN20@z900_load_:
$LN19@z900_load_:

; 3887 :     }
; 3888 : #endif
; 3889 : 
; 3890 :     IEEE_EXCEPTION_TRAP_XI( regs );

  003ca	33 c0		 xor	 eax, eax
  003cc	83 f8 01	 cmp	 eax, 1
  003cf	74 4b		 je	 SHORT $LN21@z900_load_
  003d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003d6	8b c0		 mov	 eax, eax
  003d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003de	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003e7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ef	83 e0 10	 and	 eax, 16
  003f2	85 c0		 test	 eax, eax
  003f4	74 26		 je	 SHORT $LN21@z900_load_
  003f6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fe	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00404	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00409	85 c0		 test	 eax, eax
  0040b	74 0f		 je	 SHORT $LN21@z900_load_
  0040d	b2 80		 mov	 dl, 128			; 00000080H
  0040f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00417	e8 00 00 00 00	 call	 ieee_trap
$LN21@z900_load_:

; 3891 : 
; 3892 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  0041c	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00420	d1 e0		 shl	 eax, 1
  00422	48 98		 cdqe
  00424	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00434	48 8b d0	 mov	 rdx, rax
  00437	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0043c	e8 00 00 00 00	 call	 z900_put_float32

; 3893 : 
; 3894 :     if (softfloat_exceptionFlags)

  00441	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00446	8b c0		 mov	 eax, eax
  00448	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0044e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00457	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0045b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0045f	85 c0		 test	 eax, eax
  00461	0f 84 a0 00 00
	00		 je	 $LN22@z900_load_

; 3895 :     {
; 3896 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00467	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046f	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00474	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3897 : 
; 3898 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00478	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0047c	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00481	85 c0		 test	 eax, eax
  00483	74 64		 je	 SHORT $LN23@z900_load_

; 3899 :         {
; 3900 :             op2 = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00485	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00489	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0048e	85 c0		 test	 eax, eax
  00490	74 0a		 je	 SHORT $LN28@z900_load_
  00492	c7 44 24 38 00
	e0 ff ff	 mov	 DWORD PTR tv283[rsp], -8192 ; ffffffffffffe000H
  0049a	eb 08		 jmp	 SHORT $LN29@z900_load_
$LN28@z900_load_:
  0049c	c7 44 24 38 00
	20 00 00	 mov	 DWORD PTR tv283[rsp], 8192 ; 00002000H
$LN29@z900_load_:
  004a4	8b 54 24 38	 mov	 edx, DWORD PTR tv283[rsp]
  004a8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  004ad	e8 00 00 00 00	 call	 f128_scaledResult
  004b2	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  004b7	48 8b f9	 mov	 rdi, rcx
  004ba	48 8b f0	 mov	 rsi, rax
  004bd	b9 10 00 00 00	 mov	 ecx, 16
  004c2	f3 a4		 rep movsb

; 3901 :                 SCALE_FACTOR_LOADR_OFLOW_EXTD :
; 3902 :                 SCALE_FACTOR_LOADR_UFLOW_EXTD );
; 3903 : 
; 3904 :             PUT_FLOAT128_NOCC( op2, r1, regs );

  004c4	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  004c8	d1 e0		 shl	 eax, 1
  004ca	48 98		 cdqe
  004cc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  004dc	48 8b d0	 mov	 rdx, rax
  004df	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  004e4	e8 00 00 00 00	 call	 z900_put_float128
$LN23@z900_load_:

; 3905 :         }
; 3906 : 
; 3907 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  004e9	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004ed	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  004f2	85 c0		 test	 eax, eax
  004f4	74 11		 je	 SHORT $LN24@z900_load_
  004f6	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004fa	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00502	e8 00 00 00 00	 call	 ieee_cond_trap
$LN24@z900_load_:
$LN22@z900_load_:

; 3908 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3909 :     }
; 3910 : }

  00507	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0050c	48 33 cc	 xor	 rcx, rsp
  0050f	e8 00 00 00 00	 call	 __security_check_cookie
  00514	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0051b	5f		 pop	 rdi
  0051c	5e		 pop	 rsi
  0051d	c3		 ret	 0
z900_load_rounded_bfp_ext_to_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
r1$ = 44
r2$ = 48
tv194 = 52
tv283 = 56
op1$ = 64
$T2 = 80
$T3 = 96
op2$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
z900_load_rounded_bfp_ext_to_long_reg PROC

; 3789 : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3790 :     int         r1, r2;
; 3791 :     BYTE        m3, m4;
; 3792 :     float128_t  op2;
; 3793 :     float64_t   op1;
; 3794 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3795 : 
; 3796 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_load_:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN8@z900_load_
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3797 :     TXF_FLOAT_INSTR_CHECK( regs );

  000b2	33 c0		 xor	 eax, eax
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000cc	85 c0		 test	 eax, eax
  000ce	74 6e		 je	 SHORT $LN9@z900_load_
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 29		 jne	 SHORT $LN10@z900_load_
  000d6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000e5	85 c0		 test	 eax, eax
  000e7	75 16		 jne	 SHORT $LN10@z900_load_
  000e9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000f8	83 e0 04	 and	 eax, 4
  000fb	85 c0		 test	 eax, eax
  000fd	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000ff	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010d	0f ba e8 0b	 bts	 eax, 11
  00111	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200438
  00126	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012c	ba 02 00 00 00	 mov	 edx, 2
  00131	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 3798 :     BFPINST_CHECK( regs );

  00148	b8 08 00 00 00	 mov	 eax, 8
  0014d	48 6b c0 01	 imul	 rax, rax, 1
  00151	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00161	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00167	48 85 c0	 test	 rax, rax
  0016a	74 42		 je	 SHORT $LN12@z900_load_
  0016c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017a	d1 e8		 shr	 eax, 1
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 58		 je	 SHORT $LN11@z900_load_
  00183	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00192	b9 08 00 00 00	 mov	 ecx, 8
  00197	48 6b c9 01	 imul	 rcx, rcx, 1
  0019b	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001a3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a9	48 85 c0	 test	 rax, rax
  001ac	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  001ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001c0	ba 07 00 00 00	 mov	 edx, 7
  001c5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3799 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001db	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001df	83 e0 02	 and	 eax, 2
  001e2	85 c0		 test	 eax, eax
  001e4	75 0b		 jne	 SHORT $LN14@z900_load_
  001e6	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  001ea	83 e0 02	 and	 eax, 2
  001ed	85 c0		 test	 eax, eax
  001ef	74 1b		 je	 SHORT $LN13@z900_load_
$LN14@z900_load_:
  001f1	ba 06 00 00 00	 mov	 edx, 6
  001f6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00206	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 3800 : 
; 3801 :     GET_FLOAT128_OP( op2, r2, regs );

  0020c	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00210	d1 e0		 shl	 eax, 1
  00212	48 98		 cdqe
  00214	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00224	48 8b d0	 mov	 rdx, rax
  00227	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  0022c	e8 00 00 00 00	 call	 z900_get_float128

; 3802 : 
; 3803 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3804 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00231	b8 01 00 00 00	 mov	 eax, 1
  00236	48 6b c0 04	 imul	 rax, rax, 4
  0023a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00242	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0024a	83 e0 04	 and	 eax, 4
  0024d	85 c0		 test	 eax, eax
  0024f	74 65		 je	 SHORT $LN15@z900_load_

; 3805 :         SET_SF_RM_FROM_MASK( m3 );

  00251	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00256	85 c0		 test	 eax, eax
  00258	74 16		 je	 SHORT $LN26@z900_load_
  0025a	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0025f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00266	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026a	89 44 24 34	 mov	 DWORD PTR tv194[rsp], eax
  0026e	eb 22		 jmp	 SHORT $LN27@z900_load_
$LN26@z900_load_:
  00270	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00278	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0027e	83 e0 07	 and	 eax, 7
  00281	8b c0		 mov	 eax, eax
  00283	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0028a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028e	89 44 24 34	 mov	 DWORD PTR tv194[rsp], eax
$LN27@z900_load_:
  00292	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00297	8b c0		 mov	 eax, eax
  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ac	0f b6 54 24 34	 movzx	 edx, BYTE PTR tv194[rsp]
  002b1	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  002b4	eb 6a		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:

; 3806 :     else
; 3807 : #endif
; 3808 :     {
; 3809 :         if (m3 || m4)

  002b6	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  002bb	85 c0		 test	 eax, eax
  002bd	75 09		 jne	 SHORT $LN18@z900_load_
  002bf	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002c4	85 c0		 test	 eax, eax
  002c6	74 1b		 je	 SHORT $LN17@z900_load_
$LN18@z900_load_:

; 3810 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  002c8	ba 06 00 00 00	 mov	 edx, 6
  002cd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002dd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_load_:

; 3811 :         SET_SF_RM_FROM_FPC;

  002e3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002eb	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002f1	83 e0 07	 and	 eax, 7
  002f4	8b c0		 mov	 eax, eax
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002fd	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00302	8b d2		 mov	 edx, edx
  00304	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0030b	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00314	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00318	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031c	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al
$LN16@z900_load_:

; 3812 :     }
; 3813 : 
; 3814 :     softfloat_exceptionFlags = 0;

  00320	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00325	8b c0		 mov	 eax, eax
  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0032d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00336	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0033a	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3815 : 
; 3816 :     op1 = f128_to_f64( op2 );

  0033e	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  00343	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  00348	48 8b f8	 mov	 rdi, rax
  0034b	48 8b f1	 mov	 rsi, rcx
  0034e	b9 10 00 00 00	 mov	 ecx, 16
  00353	f3 a4		 rep movsb
  00355	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T2[rsp]
  0035a	e8 00 00 00 00	 call	 f128_to_f64
  0035f	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 3817 : 
; 3818 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3819 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00364	b8 01 00 00 00	 mov	 eax, 1
  00369	48 6b c0 04	 imul	 rax, rax, 4
  0036d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00375	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0037d	83 e0 04	 and	 eax, 4
  00380	85 c0		 test	 eax, eax
  00382	74 4a		 je	 SHORT $LN19@z900_load_

; 3820 :     {
; 3821 :         if (SUPPRESS_INEXACT( m4 ))

  00384	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00389	83 e0 04	 and	 eax, 4
  0038c	85 c0		 test	 eax, eax
  0038e	74 3e		 je	 SHORT $LN20@z900_load_

; 3822 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;

  00390	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00395	8b c0		 mov	 eax, eax
  00397	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0039d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ae	83 e0 fe	 and	 eax, -2
  003b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003b7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003c0	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  003c5	8b ff		 mov	 edi, edi
  003c7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003cb	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN20@z900_load_:
$LN19@z900_load_:

; 3823 :     }
; 3824 : #endif
; 3825 : 
; 3826 :     IEEE_EXCEPTION_TRAP_XI( regs );

  003ce	33 c0		 xor	 eax, eax
  003d0	83 f8 01	 cmp	 eax, 1
  003d3	74 4b		 je	 SHORT $LN21@z900_load_
  003d5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003da	8b c0		 mov	 eax, eax
  003dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003e2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003eb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003ef	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003f3	83 e0 10	 and	 eax, 16
  003f6	85 c0		 test	 eax, eax
  003f8	74 26		 je	 SHORT $LN21@z900_load_
  003fa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00402	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00408	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0040d	85 c0		 test	 eax, eax
  0040f	74 0f		 je	 SHORT $LN21@z900_load_
  00411	b2 80		 mov	 dl, 128			; 00000080H
  00413	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041b	e8 00 00 00 00	 call	 ieee_trap
$LN21@z900_load_:

; 3827 : 
; 3828 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00420	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00424	d1 e0		 shl	 eax, 1
  00426	48 98		 cdqe
  00428	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00430	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00438	48 8b d0	 mov	 rdx, rax
  0043b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00440	e8 00 00 00 00	 call	 z900_put_float64

; 3829 : 
; 3830 :     if (softfloat_exceptionFlags)

  00445	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0044a	8b c0		 mov	 eax, eax
  0044c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00452	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0045b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0045f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00463	85 c0		 test	 eax, eax
  00465	0f 84 a0 00 00
	00		 je	 $LN22@z900_load_

; 3831 :     {
; 3832 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0046b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00473	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00478	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3833 : 
; 3834 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0047c	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00480	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00485	85 c0		 test	 eax, eax
  00487	74 64		 je	 SHORT $LN23@z900_load_

; 3835 :         {
; 3836 :             op2 = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00489	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0048d	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00492	85 c0		 test	 eax, eax
  00494	74 0a		 je	 SHORT $LN28@z900_load_
  00496	c7 44 24 38 00
	e0 ff ff	 mov	 DWORD PTR tv283[rsp], -8192 ; ffffffffffffe000H
  0049e	eb 08		 jmp	 SHORT $LN29@z900_load_
$LN28@z900_load_:
  004a0	c7 44 24 38 00
	20 00 00	 mov	 DWORD PTR tv283[rsp], 8192 ; 00002000H
$LN29@z900_load_:
  004a8	8b 54 24 38	 mov	 edx, DWORD PTR tv283[rsp]
  004ac	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  004b1	e8 00 00 00 00	 call	 f128_scaledResult
  004b6	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  004bb	48 8b f9	 mov	 rdi, rcx
  004be	48 8b f0	 mov	 rsi, rax
  004c1	b9 10 00 00 00	 mov	 ecx, 16
  004c6	f3 a4		 rep movsb

; 3837 :                 SCALE_FACTOR_LOADR_OFLOW_EXTD :
; 3838 :                 SCALE_FACTOR_LOADR_UFLOW_EXTD );
; 3839 : 
; 3840 :             PUT_FLOAT128_NOCC( op2, r1, regs );

  004c8	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  004cc	d1 e0		 shl	 eax, 1
  004ce	48 98		 cdqe
  004d0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  004e0	48 8b d0	 mov	 rdx, rax
  004e3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  004e8	e8 00 00 00 00	 call	 z900_put_float128
$LN23@z900_load_:

; 3841 :         }
; 3842 : 
; 3843 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  004ed	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004f1	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  004f6	85 c0		 test	 eax, eax
  004f8	74 11		 je	 SHORT $LN24@z900_load_
  004fa	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004fe	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00506	e8 00 00 00 00	 call	 ieee_cond_trap
$LN24@z900_load_:
$LN22@z900_load_:

; 3844 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3845 :     }
; 3846 : }

  0050b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00513	48 33 cc	 xor	 rcx, rsp
  00516	e8 00 00 00 00	 call	 __security_check_cookie
  0051b	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00522	5f		 pop	 rdi
  00523	5e		 pop	 rsi
  00524	c3		 ret	 0
z900_load_rounded_bfp_ext_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv171 = 40
tv174 = 44
tv176 = 48
tv177 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
z900_load_positive_bfp_short_reg PROC

; 3686 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3687 :     int        r1, r2;
; 3688 :     float32_t  op;
; 3689 : 
; 3690 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3691 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_load_
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_load_
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_load_
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200378
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3692 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_load_
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_load_
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3693 : 
; 3694 :     GET_FLOAT32_OP( op, r2, regs );

  00169	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float32

; 3695 :     op.v &= ~0x80000000;

  0018b	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0018f	0f ba f0 1f	 btr	 eax, 31
  00193	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN10@z900_load_:

; 3696 : 
; 3697 :     PUT_FLOAT32_CC( op, r1, regs );

  00197	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0019b	d1 e0		 shl	 eax, 1
  0019d	48 98		 cdqe
  0019f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001ac	48 8b d0	 mov	 rdx, rax
  001af	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  001b4	e8 00 00 00 00	 call	 z900_put_float32
  001b9	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001bd	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  001c2	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  001c7	75 17		 jne	 SHORT $LN17@z900_load_
  001c9	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001cd	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001d2	85 c0		 test	 eax, eax
  001d4	74 0a		 je	 SHORT $LN17@z900_load_
  001d6	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv177[rsp], 3
  001de	eb 5e		 jmp	 SHORT $LN24@z900_load_
$LN17@z900_load_:
  001e0	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001e4	0f ba f0 1f	 btr	 eax, 31
  001e8	85 c0		 test	 eax, eax
  001ea	75 0a		 jne	 SHORT $LN18@z900_load_
  001ec	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  001f4	eb 08		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  001f6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN19@z900_load_:
  001fe	83 7c 24 28 00	 cmp	 DWORD PTR tv171[rsp], 0
  00203	74 0a		 je	 SHORT $LN22@z900_load_
  00205	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  0020d	eb 27		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  0020f	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00213	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00218	85 c0		 test	 eax, eax
  0021a	74 0a		 je	 SHORT $LN20@z900_load_
  0021c	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00224	eb 08		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00226	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN21@z900_load_:
  0022e	8b 44 24 2c	 mov	 eax, DWORD PTR tv174[rsp]
  00232	89 44 24 30	 mov	 DWORD PTR tv176[rsp], eax
$LN23@z900_load_:
  00236	8b 44 24 30	 mov	 eax, DWORD PTR tv176[rsp]
  0023a	89 44 24 34	 mov	 DWORD PTR tv177[rsp], eax
$LN24@z900_load_:
  0023e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00243	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv177[rsp]
  00248	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0024b	33 c0		 xor	 eax, eax
  0024d	85 c0		 test	 eax, eax
  0024f	0f 85 42 ff ff
	ff		 jne	 $LN10@z900_load_

; 3698 : }

  00255	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00259	c3		 ret	 0
z900_load_positive_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv171 = 36
tv174 = 40
tv176 = 44
tv177 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
z900_load_positive_bfp_long_reg PROC

; 3667 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3668 :     int        r1, r2;
; 3669 :     float64_t  op;
; 3670 : 
; 3671 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3672 : 
; 3673 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_load_
  00073	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_load_
  00089	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_load_
  00099	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200354
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3674 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_load_
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_load_
  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00145	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3675 : 
; 3676 :     GET_FLOAT64_OP( op, r2, regs );

  00169	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float64

; 3677 :     op.v  &= ~0x8000000000000000ULL;

  0018b	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00195	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019a	48 23 c8	 and	 rcx, rax
  0019d	48 8b c1	 mov	 rax, rcx
  001a0	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN10@z900_load_:

; 3678 : 
; 3679 :     PUT_FLOAT64_CC( op, r1, regs );

  001a5	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001a9	d1 e0		 shl	 eax, 1
  001ab	48 98		 cdqe
  001ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001ba	48 8b d0	 mov	 rdx, rax
  001bd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001c2	e8 00 00 00 00	 call	 z900_put_float64
  001c7	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  001d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d6	48 23 c8	 and	 rcx, rax
  001d9	48 8b c1	 mov	 rax, rcx
  001dc	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001e6	48 3b c1	 cmp	 rax, rcx
  001e9	75 24		 jne	 SHORT $LN17@z900_load_
  001eb	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  001f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001fa	48 23 c8	 and	 rcx, rax
  001fd	48 8b c1	 mov	 rax, rcx
  00200	48 85 c0	 test	 rax, rax
  00203	74 0a		 je	 SHORT $LN17@z900_load_
  00205	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv177[rsp], 3
  0020d	eb 79		 jmp	 SHORT $LN24@z900_load_
$LN17@z900_load_:
  0020f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00219	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0021e	48 23 c8	 and	 rcx, rax
  00221	48 8b c1	 mov	 rax, rcx
  00224	48 85 c0	 test	 rax, rax
  00227	75 0a		 jne	 SHORT $LN18@z900_load_
  00229	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  00231	eb 08		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  00233	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN19@z900_load_:
  0023b	83 7c 24 24 00	 cmp	 DWORD PTR tv171[rsp], 0
  00240	74 0a		 je	 SHORT $LN22@z900_load_
  00242	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  0024a	eb 34		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  0024c	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00256	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0025b	48 23 c8	 and	 rcx, rax
  0025e	48 8b c1	 mov	 rax, rcx
  00261	48 85 c0	 test	 rax, rax
  00264	74 0a		 je	 SHORT $LN20@z900_load_
  00266	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0026e	eb 08		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00270	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN21@z900_load_:
  00278	8b 44 24 28	 mov	 eax, DWORD PTR tv174[rsp]
  0027c	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
$LN23@z900_load_:
  00280	8b 44 24 2c	 mov	 eax, DWORD PTR tv176[rsp]
  00284	89 44 24 30	 mov	 DWORD PTR tv177[rsp], eax
$LN24@z900_load_:
  00288	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0028d	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv177[rsp]
  00292	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00295	33 c0		 xor	 eax, eax
  00297	85 c0		 test	 eax, eax
  00299	0f 85 06 ff ff
	ff		 jne	 $LN10@z900_load_

; 3680 : }

  0029f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002a3	c3		 ret	 0
z900_load_positive_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv194 = 44
tv199 = 48
tv201 = 52
tv202 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
z900_load_positive_bfp_ext_reg PROC

; 3647 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3648 :     int         r1, r2;
; 3649 :     float128_t  op;
; 3650 : 
; 3651 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN11@z900_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3652 : 
; 3653 :     TXF_FLOAT_INSTR_CHECK( regs );

  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 01	 cmp	 eax, 1
  00080	74 6f		 je	 SHORT $LN12@z900_load_
  00082	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00087	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0008e	85 c0		 test	 eax, eax
  00090	74 5f		 je	 SHORT $LN12@z900_load_
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	75 23		 jne	 SHORT $LN13@z900_load_
  00098	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a4	85 c0		 test	 eax, eax
  000a6	75 13		 jne	 SHORT $LN13@z900_load_
  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000b4	83 e0 04	 and	 eax, 4
  000b7	85 c0		 test	 eax, eax
  000b9	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000bb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c6	0f ba e8 0b	 bts	 eax, 11
  000ca	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200328
  000dc	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e2	ba 02 00 00 00	 mov	 edx, 2
  000e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 84		 jne	 SHORT $LN7@z900_load_

; 3654 :     BFPINST_CHECK( regs );

  000f7	b8 08 00 00 00	 mov	 eax, 8
  000fc	48 6b c0 01	 imul	 rax, rax, 1
  00100	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0010d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00113	48 85 c0	 test	 rax, rax
  00116	74 3c		 je	 SHORT $LN15@z900_load_
  00118	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00123	d1 e8		 shr	 eax, 1
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	74 4c		 je	 SHORT $LN14@z900_load_
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00138	b9 08 00 00 00	 mov	 ecx, 8
  0013d	48 6b c9 01	 imul	 rcx, rcx, 1
  00141	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00154	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00159	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00163	ba 07 00 00 00	 mov	 edx, 7
  00168	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00172	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3655 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00178	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0017c	83 e0 02	 and	 eax, 2
  0017f	85 c0		 test	 eax, eax
  00181	75 0b		 jne	 SHORT $LN17@z900_load_
  00183	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00187	83 e0 02	 and	 eax, 2
  0018a	85 c0		 test	 eax, eax
  0018c	74 15		 je	 SHORT $LN16@z900_load_
$LN17@z900_load_:
  0018e	ba 06 00 00 00	 mov	 edx, 6
  00193	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_load_:

; 3656 : 
; 3657 :     GET_FLOAT128_OP( op, r2, regs );

  001a3	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001a7	d1 e0		 shl	 eax, 1
  001a9	48 98		 cdqe
  001ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b8	48 8b d0	 mov	 rdx, rax
  001bb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001c0	e8 00 00 00 00	 call	 z900_get_float128

; 3658 :     op.v[FLOAT128_HI] &= ~0x8000000000000000ULL;

  001c5	b8 08 00 00 00	 mov	 eax, 8
  001ca	48 6b c0 01	 imul	 rax, rax, 1
  001ce	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  001d8	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001dd	48 23 c1	 and	 rax, rcx
  001e0	b9 08 00 00 00	 mov	 ecx, 8
  001e5	48 6b c9 01	 imul	 rcx, rcx, 1
  001e9	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN10@z900_load_:

; 3659 : 
; 3660 :     PUT_FLOAT128_CC( op, r1, regs );

  001ee	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001f2	d1 e0		 shl	 eax, 1
  001f4	48 98		 cdqe
  001f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001fb	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00203	48 8b d0	 mov	 rdx, rax
  00206	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0020b	e8 00 00 00 00	 call	 z900_put_float128
  00210	b8 08 00 00 00	 mov	 eax, 8
  00215	48 6b c0 01	 imul	 rax, rax, 1
  00219	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00223	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00228	48 23 c1	 and	 rax, rcx
  0022b	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00235	48 3b c1	 cmp	 rax, rcx
  00238	75 3e		 jne	 SHORT $LN20@z900_load_
  0023a	b8 08 00 00 00	 mov	 eax, 8
  0023f	48 6b c0 01	 imul	 rax, rax, 1
  00243	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  0024d	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00252	48 23 c1	 and	 rax, rcx
  00255	48 85 c0	 test	 rax, rax
  00258	75 11		 jne	 SHORT $LN19@z900_load_
  0025a	b8 08 00 00 00	 mov	 eax, 8
  0025f	48 6b c0 00	 imul	 rax, rax, 0
  00263	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  00269	74 0d		 je	 SHORT $LN20@z900_load_
$LN19@z900_load_:
  0026b	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv202[rsp], 3
  00273	e9 93 00 00 00	 jmp	 $LN27@z900_load_
$LN20@z900_load_:
  00278	b8 08 00 00 00	 mov	 eax, 8
  0027d	48 6b c0 01	 imul	 rax, rax, 1
  00281	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0028b	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00290	48 23 c1	 and	 rax, rcx
  00293	b9 08 00 00 00	 mov	 ecx, 8
  00298	48 6b c9 00	 imul	 rcx, rcx, 0
  0029c	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  002a1	48 85 c0	 test	 rax, rax
  002a4	75 0a		 jne	 SHORT $LN21@z900_load_
  002a6	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  002ae	eb 08		 jmp	 SHORT $LN22@z900_load_
$LN21@z900_load_:
  002b0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN22@z900_load_:
  002b8	83 7c 24 2c 00	 cmp	 DWORD PTR tv194[rsp], 0
  002bd	74 0a		 je	 SHORT $LN25@z900_load_
  002bf	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv201[rsp], 0
  002c7	eb 3a		 jmp	 SHORT $LN26@z900_load_
$LN25@z900_load_:
  002c9	b8 08 00 00 00	 mov	 eax, 8
  002ce	48 6b c0 01	 imul	 rax, rax, 1
  002d2	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002dc	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  002e1	48 23 c1	 and	 rax, rcx
  002e4	48 85 c0	 test	 rax, rax
  002e7	74 0a		 je	 SHORT $LN23@z900_load_
  002e9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv199[rsp], 1
  002f1	eb 08		 jmp	 SHORT $LN24@z900_load_
$LN23@z900_load_:
  002f3	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv199[rsp], 2
$LN24@z900_load_:
  002fb	8b 44 24 30	 mov	 eax, DWORD PTR tv199[rsp]
  002ff	89 44 24 34	 mov	 DWORD PTR tv201[rsp], eax
$LN26@z900_load_:
  00303	8b 44 24 34	 mov	 eax, DWORD PTR tv201[rsp]
  00307	89 44 24 38	 mov	 DWORD PTR tv202[rsp], eax
$LN27@z900_load_:
  0030b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00310	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv202[rsp]
  00315	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00318	33 c0		 xor	 eax, eax
  0031a	85 c0		 test	 eax, eax
  0031c	0f 85 cc fe ff
	ff		 jne	 $LN10@z900_load_

; 3661 : }

  00322	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00327	48 33 cc	 xor	 rcx, rsp
  0032a	e8 00 00 00 00	 call	 __security_check_cookie
  0032f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00333	c3		 ret	 0
z900_load_positive_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv171 = 40
tv174 = 44
tv176 = 48
tv177 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
z900_load_negative_bfp_short_reg PROC

; 3574 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3575 :     int        r1, r2;
; 3576 :     float32_t  op;
; 3577 : 
; 3578 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3579 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_load_
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_load_
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_load_
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200230
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3580 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_load_
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_load_
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3581 : 
; 3582 :     GET_FLOAT32_OP( op, r2, regs );

  00169	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float32

; 3583 :     op.v |= 0x80000000;

  0018b	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0018f	0f ba e8 1f	 bts	 eax, 31
  00193	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN10@z900_load_:

; 3584 : 
; 3585 :     PUT_FLOAT32_CC( op, r1, regs );

  00197	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0019b	d1 e0		 shl	 eax, 1
  0019d	48 98		 cdqe
  0019f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001ac	48 8b d0	 mov	 rdx, rax
  001af	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  001b4	e8 00 00 00 00	 call	 z900_put_float32
  001b9	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001bd	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  001c2	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  001c7	75 17		 jne	 SHORT $LN17@z900_load_
  001c9	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001cd	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001d2	85 c0		 test	 eax, eax
  001d4	74 0a		 je	 SHORT $LN17@z900_load_
  001d6	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv177[rsp], 3
  001de	eb 5e		 jmp	 SHORT $LN24@z900_load_
$LN17@z900_load_:
  001e0	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001e4	0f ba f0 1f	 btr	 eax, 31
  001e8	85 c0		 test	 eax, eax
  001ea	75 0a		 jne	 SHORT $LN18@z900_load_
  001ec	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  001f4	eb 08		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  001f6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN19@z900_load_:
  001fe	83 7c 24 28 00	 cmp	 DWORD PTR tv171[rsp], 0
  00203	74 0a		 je	 SHORT $LN22@z900_load_
  00205	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  0020d	eb 27		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  0020f	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00213	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00218	85 c0		 test	 eax, eax
  0021a	74 0a		 je	 SHORT $LN20@z900_load_
  0021c	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00224	eb 08		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00226	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN21@z900_load_:
  0022e	8b 44 24 2c	 mov	 eax, DWORD PTR tv174[rsp]
  00232	89 44 24 30	 mov	 DWORD PTR tv176[rsp], eax
$LN23@z900_load_:
  00236	8b 44 24 30	 mov	 eax, DWORD PTR tv176[rsp]
  0023a	89 44 24 34	 mov	 DWORD PTR tv177[rsp], eax
$LN24@z900_load_:
  0023e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00243	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv177[rsp]
  00248	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0024b	33 c0		 xor	 eax, eax
  0024d	85 c0		 test	 eax, eax
  0024f	0f 85 42 ff ff
	ff		 jne	 $LN10@z900_load_

; 3586 : }

  00255	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00259	c3		 ret	 0
z900_load_negative_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv171 = 36
tv174 = 40
tv176 = 44
tv177 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
z900_load_negative_bfp_long_reg PROC

; 3556 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3557 :     int        r1, r2;
; 3558 :     float64_t  op;
; 3559 : 
; 3560 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3561 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_load_
  00073	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_load_
  00089	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_load_
  00099	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200206
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3562 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_load_
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_load_
  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00145	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3563 : 
; 3564 :     GET_FLOAT64_OP( op, r2, regs );

  00169	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float64

; 3565 :     op.v |= 0x8000000000000000ULL;

  0018b	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00195	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019a	48 0b c8	 or	 rcx, rax
  0019d	48 8b c1	 mov	 rax, rcx
  001a0	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN10@z900_load_:

; 3566 : 
; 3567 :     PUT_FLOAT64_CC( op, r1, regs );

  001a5	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001a9	d1 e0		 shl	 eax, 1
  001ab	48 98		 cdqe
  001ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001ba	48 8b d0	 mov	 rdx, rax
  001bd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001c2	e8 00 00 00 00	 call	 z900_put_float64
  001c7	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  001d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d6	48 23 c8	 and	 rcx, rax
  001d9	48 8b c1	 mov	 rax, rcx
  001dc	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001e6	48 3b c1	 cmp	 rax, rcx
  001e9	75 24		 jne	 SHORT $LN17@z900_load_
  001eb	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  001f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001fa	48 23 c8	 and	 rcx, rax
  001fd	48 8b c1	 mov	 rax, rcx
  00200	48 85 c0	 test	 rax, rax
  00203	74 0a		 je	 SHORT $LN17@z900_load_
  00205	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv177[rsp], 3
  0020d	eb 79		 jmp	 SHORT $LN24@z900_load_
$LN17@z900_load_:
  0020f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00219	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0021e	48 23 c8	 and	 rcx, rax
  00221	48 8b c1	 mov	 rax, rcx
  00224	48 85 c0	 test	 rax, rax
  00227	75 0a		 jne	 SHORT $LN18@z900_load_
  00229	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  00231	eb 08		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  00233	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN19@z900_load_:
  0023b	83 7c 24 24 00	 cmp	 DWORD PTR tv171[rsp], 0
  00240	74 0a		 je	 SHORT $LN22@z900_load_
  00242	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  0024a	eb 34		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  0024c	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00256	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0025b	48 23 c8	 and	 rcx, rax
  0025e	48 8b c1	 mov	 rax, rcx
  00261	48 85 c0	 test	 rax, rax
  00264	74 0a		 je	 SHORT $LN20@z900_load_
  00266	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0026e	eb 08		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00270	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN21@z900_load_:
  00278	8b 44 24 28	 mov	 eax, DWORD PTR tv174[rsp]
  0027c	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
$LN23@z900_load_:
  00280	8b 44 24 2c	 mov	 eax, DWORD PTR tv176[rsp]
  00284	89 44 24 30	 mov	 DWORD PTR tv177[rsp], eax
$LN24@z900_load_:
  00288	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0028d	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv177[rsp]
  00292	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00295	33 c0		 xor	 eax, eax
  00297	85 c0		 test	 eax, eax
  00299	0f 85 06 ff ff
	ff		 jne	 $LN10@z900_load_

; 3568 : }

  0029f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002a3	c3		 ret	 0
z900_load_negative_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv194 = 44
tv199 = 48
tv201 = 52
tv202 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
z900_load_negative_bfp_ext_reg PROC

; 3537 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3538 :     int         r1, r2;
; 3539 :     float128_t  op;
; 3540 : 
; 3541 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN11@z900_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3542 :     TXF_FLOAT_INSTR_CHECK( regs );

  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 01	 cmp	 eax, 1
  00080	74 6f		 je	 SHORT $LN12@z900_load_
  00082	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00087	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0008e	85 c0		 test	 eax, eax
  00090	74 5f		 je	 SHORT $LN12@z900_load_
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	75 23		 jne	 SHORT $LN13@z900_load_
  00098	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a4	85 c0		 test	 eax, eax
  000a6	75 13		 jne	 SHORT $LN13@z900_load_
  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000b4	83 e0 04	 and	 eax, 4
  000b7	85 c0		 test	 eax, eax
  000b9	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000bb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c6	0f ba e8 0b	 bts	 eax, 11
  000ca	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200180
  000dc	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e2	ba 02 00 00 00	 mov	 edx, 2
  000e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 84		 jne	 SHORT $LN7@z900_load_

; 3543 :     BFPINST_CHECK( regs );

  000f7	b8 08 00 00 00	 mov	 eax, 8
  000fc	48 6b c0 01	 imul	 rax, rax, 1
  00100	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0010d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00113	48 85 c0	 test	 rax, rax
  00116	74 3c		 je	 SHORT $LN15@z900_load_
  00118	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00123	d1 e8		 shr	 eax, 1
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	74 4c		 je	 SHORT $LN14@z900_load_
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00138	b9 08 00 00 00	 mov	 ecx, 8
  0013d	48 6b c9 01	 imul	 rcx, rcx, 1
  00141	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00154	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00159	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00163	ba 07 00 00 00	 mov	 edx, 7
  00168	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00172	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3544 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00178	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0017c	83 e0 02	 and	 eax, 2
  0017f	85 c0		 test	 eax, eax
  00181	75 0b		 jne	 SHORT $LN17@z900_load_
  00183	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00187	83 e0 02	 and	 eax, 2
  0018a	85 c0		 test	 eax, eax
  0018c	74 15		 je	 SHORT $LN16@z900_load_
$LN17@z900_load_:
  0018e	ba 06 00 00 00	 mov	 edx, 6
  00193	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_load_:

; 3545 : 
; 3546 :     GET_FLOAT128_OP( op, r2, regs );

  001a3	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001a7	d1 e0		 shl	 eax, 1
  001a9	48 98		 cdqe
  001ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b8	48 8b d0	 mov	 rdx, rax
  001bb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001c0	e8 00 00 00 00	 call	 z900_get_float128

; 3547 :     op.v[FLOAT128_HI] |= 0x8000000000000000ULL;

  001c5	b8 08 00 00 00	 mov	 eax, 8
  001ca	48 6b c0 01	 imul	 rax, rax, 1
  001ce	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  001d8	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001dd	48 0b c1	 or	 rax, rcx
  001e0	b9 08 00 00 00	 mov	 ecx, 8
  001e5	48 6b c9 01	 imul	 rcx, rcx, 1
  001e9	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN10@z900_load_:

; 3548 : 
; 3549 :     PUT_FLOAT128_CC( op, r1, regs );

  001ee	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001f2	d1 e0		 shl	 eax, 1
  001f4	48 98		 cdqe
  001f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001fb	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00203	48 8b d0	 mov	 rdx, rax
  00206	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0020b	e8 00 00 00 00	 call	 z900_put_float128
  00210	b8 08 00 00 00	 mov	 eax, 8
  00215	48 6b c0 01	 imul	 rax, rax, 1
  00219	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00223	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00228	48 23 c1	 and	 rax, rcx
  0022b	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00235	48 3b c1	 cmp	 rax, rcx
  00238	75 3e		 jne	 SHORT $LN20@z900_load_
  0023a	b8 08 00 00 00	 mov	 eax, 8
  0023f	48 6b c0 01	 imul	 rax, rax, 1
  00243	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  0024d	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00252	48 23 c1	 and	 rax, rcx
  00255	48 85 c0	 test	 rax, rax
  00258	75 11		 jne	 SHORT $LN19@z900_load_
  0025a	b8 08 00 00 00	 mov	 eax, 8
  0025f	48 6b c0 00	 imul	 rax, rax, 0
  00263	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  00269	74 0d		 je	 SHORT $LN20@z900_load_
$LN19@z900_load_:
  0026b	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv202[rsp], 3
  00273	e9 93 00 00 00	 jmp	 $LN27@z900_load_
$LN20@z900_load_:
  00278	b8 08 00 00 00	 mov	 eax, 8
  0027d	48 6b c0 01	 imul	 rax, rax, 1
  00281	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0028b	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00290	48 23 c1	 and	 rax, rcx
  00293	b9 08 00 00 00	 mov	 ecx, 8
  00298	48 6b c9 00	 imul	 rcx, rcx, 0
  0029c	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  002a1	48 85 c0	 test	 rax, rax
  002a4	75 0a		 jne	 SHORT $LN21@z900_load_
  002a6	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  002ae	eb 08		 jmp	 SHORT $LN22@z900_load_
$LN21@z900_load_:
  002b0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN22@z900_load_:
  002b8	83 7c 24 2c 00	 cmp	 DWORD PTR tv194[rsp], 0
  002bd	74 0a		 je	 SHORT $LN25@z900_load_
  002bf	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv201[rsp], 0
  002c7	eb 3a		 jmp	 SHORT $LN26@z900_load_
$LN25@z900_load_:
  002c9	b8 08 00 00 00	 mov	 eax, 8
  002ce	48 6b c0 01	 imul	 rax, rax, 1
  002d2	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002dc	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  002e1	48 23 c1	 and	 rax, rcx
  002e4	48 85 c0	 test	 rax, rax
  002e7	74 0a		 je	 SHORT $LN23@z900_load_
  002e9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv199[rsp], 1
  002f1	eb 08		 jmp	 SHORT $LN24@z900_load_
$LN23@z900_load_:
  002f3	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv199[rsp], 2
$LN24@z900_load_:
  002fb	8b 44 24 30	 mov	 eax, DWORD PTR tv199[rsp]
  002ff	89 44 24 34	 mov	 DWORD PTR tv201[rsp], eax
$LN26@z900_load_:
  00303	8b 44 24 34	 mov	 eax, DWORD PTR tv201[rsp]
  00307	89 44 24 38	 mov	 DWORD PTR tv202[rsp], eax
$LN27@z900_load_:
  0030b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00310	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv202[rsp]
  00315	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00318	33 c0		 xor	 eax, eax
  0031a	85 c0		 test	 eax, eax
  0031c	0f 85 cc fe ff
	ff		 jne	 $LN10@z900_load_

; 3550 : }

  00322	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00327	48 33 cc	 xor	 rcx, rsp
  0032a	e8 00 00 00 00	 call	 __security_check_cookie
  0032f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00333	c3		 ret	 0
z900_load_negative_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op2$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
op1$ = 48
inst$ = 80
regs$ = 88
z900_load_lengthened_bfp_short_to_long_reg PROC

; 3353 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3354 :     int        r1, r2;
; 3355 :     float32_t  op2;
; 3356 :     float64_t  op1;
; 3357 : 
; 3358 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@z900_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3359 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN9@z900_load_
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN9@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN10@z900_load_
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN10@z900_load_
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200013
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3360 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN12@z900_load_
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN11@z900_load_
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3361 : 
; 3362 :     GET_FLOAT32_OP( op2, r2, regs );

  00169	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op2$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float32

; 3363 : 
; 3364 :     if (f32_isSignalingNaN( op2 ))

  0018b	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  0018f	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00194	0f b6 c0	 movzx	 eax, al
  00197	85 c0		 test	 eax, eax
  00199	0f 84 c8 00 00
	00		 je	 $LN13@z900_load_

; 3365 :     {
; 3366 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  0019f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a4	8b c0		 mov	 eax, eax
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ac	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b9	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3367 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001bd	33 c0		 xor	 eax, eax
  001bf	83 f8 01	 cmp	 eax, 1
  001c2	74 45		 je	 SHORT $LN14@z900_load_
  001c4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c9	8b c0		 mov	 eax, eax
  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001da	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001de	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e2	83 e0 10	 and	 eax, 16
  001e5	85 c0		 test	 eax, eax
  001e7	74 20		 je	 SHORT $LN14@z900_load_
  001e9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001ee	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001f9	85 c0		 test	 eax, eax
  001fb	74 0c		 je	 SHORT $LN14@z900_load_
  001fd	b2 80		 mov	 dl, 128			; 00000080H
  001ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	e8 00 00 00 00	 call	 ieee_trap
$LN14@z900_load_:

; 3368 : 
; 3369 :         FLOAT32_MAKE_QNAN( op2 );

  00209	8b 44 24 20	 mov	 eax, DWORD PTR op2$[rsp]
  0020d	0f ba e8 16	 bts	 eax, 22
  00211	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 3370 :         SET_FPC_FLAGS_FROM_SF( regs );

  00215	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021a	8b c0		 mov	 eax, eax
  0021c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00222	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00233	c1 e0 13	 shl	 eax, 19
  00236	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0023b	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00241	c1 e9 08	 shr	 ecx, 8
  00244	f7 d1		 not	 ecx
  00246	23 c1		 and	 eax, ecx
  00248	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0024d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00252	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00258	0b c8		 or	 ecx, eax
  0025a	8b c1		 mov	 eax, ecx
  0025c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00261	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN13@z900_load_:

; 3371 :     }
; 3372 : 
; 3373 :     op1 = f32_to_f64( op2 );

  00267	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  0026b	e8 00 00 00 00	 call	 f32_to_f64
  00270	48 89 44 24 30	 mov	 QWORD PTR op1$[rsp], rax

; 3374 : 
; 3375 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00275	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00279	d1 e0		 shl	 eax, 1
  0027b	48 98		 cdqe
  0027d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00282	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0028a	48 8b d0	 mov	 rdx, rax
  0028d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00292	e8 00 00 00 00	 call	 z900_put_float64

; 3376 : }

  00297	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0029b	c3		 ret	 0
z900_load_lengthened_bfp_short_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
b2$ = 36
op2$ = 40
x2$ = 44
r1$ = 48
effective_addr2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
z900_load_lengthened_bfp_short_to_long PROC

; 3382 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3383 :     int        r1, x2, b2;
; 3384 :     VADR       effective_addr2;
; 3385 :     float32_t  op2;
; 3386 :     float64_t  op1;
; 3387 : 
; 3388 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00041	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00045	c1 e8 14	 shr	 eax, 20
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004f	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00054	74 22		 je	 SHORT $LN8@z900_load_
  00056	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00068	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_load_:
  00078	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 22		 je	 SHORT $LN9@z900_load_
  0008d	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c0	48 23 c8	 and	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_load_:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 06	 add	 rax, 6
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e1	33 c0		 xor	 eax, eax
  000e3	83 f8 06	 cmp	 eax, 6
  000e6	74 0c		 je	 SHORT $LN10@z900_load_
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 d1		 jne	 SHORT $LN4@z900_load_

; 3389 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  000fa	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  000ff	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_load_:

; 3390 :     TXF_FLOAT_INSTR_CHECK( regs );

  0010d	33 c0		 xor	 eax, eax
  0010f	83 f8 01	 cmp	 eax, 1
  00112	74 6f		 je	 SHORT $LN11@z900_load_
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00120	85 c0		 test	 eax, eax
  00122	74 5f		 je	 SHORT $LN11@z900_load_
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 23		 jne	 SHORT $LN12@z900_load_
  0012a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00136	85 c0		 test	 eax, eax
  00138	75 13		 jne	 SHORT $LN12@z900_load_
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00146	83 e0 04	 and	 eax, 4
  00149	85 c0		 test	 eax, eax
  0014b	75 36		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00158	0f ba e8 0b	 bts	 eax, 11
  0015c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00167	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200042
  0016e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00174	ba 02 00 00 00	 mov	 edx, 2
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_load_:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 84		 jne	 SHORT $LN7@z900_load_

; 3391 :     BFPINST_CHECK( regs );

  00189	b8 08 00 00 00	 mov	 eax, 8
  0018e	48 6b c0 01	 imul	 rax, rax, 1
  00192	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0019f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 3c		 je	 SHORT $LN14@z900_load_
  001aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b5	d1 e8		 shr	 eax, 1
  001b7	83 e0 01	 and	 eax, 1
  001ba	85 c0		 test	 eax, eax
  001bc	74 4c		 je	 SHORT $LN13@z900_load_
  001be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001ca	b9 08 00 00 00	 mov	 ecx, 8
  001cf	48 6b c9 01	 imul	 rcx, rcx, 1
  001d3	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001db	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e1	48 85 c0	 test	 rax, rax
  001e4	75 24		 jne	 SHORT $LN13@z900_load_
$LN14@z900_load_:
  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001f5	ba 07 00 00 00	 mov	 edx, 7
  001fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 3392 : 
; 3393 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0020a	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0020f	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  00213	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00218	e8 00 00 00 00	 call	 z900_vfetch4
  0021d	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3394 : 
; 3395 :     if (f32_isSignalingNaN( op2 ))

  00221	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  00225	e8 00 00 00 00	 call	 f32_isSignalingNaN
  0022a	0f b6 c0	 movzx	 eax, al
  0022d	85 c0		 test	 eax, eax
  0022f	0f 84 c8 00 00
	00		 je	 $LN15@z900_load_

; 3396 :     {
; 3397 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  00235	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023a	8b c0		 mov	 eax, eax
  0023c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00242	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024f	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3398 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00253	33 c0		 xor	 eax, eax
  00255	83 f8 01	 cmp	 eax, 1
  00258	74 45		 je	 SHORT $LN16@z900_load_
  0025a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0025f	8b c0		 mov	 eax, eax
  00261	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00267	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00270	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00274	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00278	83 e0 10	 and	 eax, 16
  0027b	85 c0		 test	 eax, eax
  0027d	74 20		 je	 SHORT $LN16@z900_load_
  0027f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00284	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0028a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0028f	85 c0		 test	 eax, eax
  00291	74 0c		 je	 SHORT $LN16@z900_load_
  00293	b2 80		 mov	 dl, 128			; 00000080H
  00295	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029a	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_load_:

; 3399 : 
; 3400 :         FLOAT32_MAKE_QNAN( op2 );

  0029f	8b 44 24 28	 mov	 eax, DWORD PTR op2$[rsp]
  002a3	0f ba e8 16	 bts	 eax, 22
  002a7	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3401 :         SET_FPC_FLAGS_FROM_SF( regs );

  002ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b0	8b c0		 mov	 eax, eax
  002b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c9	c1 e0 13	 shl	 eax, 19
  002cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002d1	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002d7	c1 e9 08	 shr	 ecx, 8
  002da	f7 d1		 not	 ecx
  002dc	23 c1		 and	 eax, ecx
  002de	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e8	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002ee	0b c8		 or	 ecx, eax
  002f0	8b c1		 mov	 eax, ecx
  002f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN15@z900_load_:

; 3402 :     }
; 3403 : 
; 3404 :     op1 = f32_to_f64( op2 );

  002fd	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  00301	e8 00 00 00 00	 call	 f32_to_f64
  00306	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 3405 : 
; 3406 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  0030b	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0030f	d1 e0		 shl	 eax, 1
  00311	48 98		 cdqe
  00313	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00318	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00320	48 8b d0	 mov	 rdx, rax
  00323	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00328	e8 00 00 00 00	 call	 z900_put_float64

; 3407 : }

  0032d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00331	c3		 ret	 0
z900_load_lengthened_bfp_short_to_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op2$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
op1$ = 64
__$ArrayPad$ = 80
inst$ = 128
regs$ = 136
z900_load_lengthened_bfp_short_to_ext_reg PROC

; 3475 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3476 :     int         r1, r2;
; 3477 :     float32_t   op2;
; 3478 :     float128_t  op1;
; 3479 : 
; 3480 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00051	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN8@z900_load_
  00074	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3481 :     TXF_FLOAT_INSTR_CHECK( regs );

  00089	33 c0		 xor	 eax, eax
  0008b	83 f8 01	 cmp	 eax, 1
  0008e	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  00094	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a3	85 c0		 test	 eax, eax
  000a5	74 6e		 je	 SHORT $LN9@z900_load_
  000a7	33 c0		 xor	 eax, eax
  000a9	85 c0		 test	 eax, eax
  000ab	75 29		 jne	 SHORT $LN10@z900_load_
  000ad	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000bc	85 c0		 test	 eax, eax
  000be	75 16		 jne	 SHORT $LN10@z900_load_
  000c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000cf	83 e0 04	 and	 eax, 4
  000d2	85 c0		 test	 eax, eax
  000d4	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000d6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e4	0f ba e8 0b	 bts	 eax, 11
  000e8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000f6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200123
  000fd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00103	ba 02 00 00 00	 mov	 edx, 2
  00108	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 3482 :     BFPINST_CHECK( regs );

  0011f	b8 08 00 00 00	 mov	 eax, 8
  00124	48 6b c0 01	 imul	 rax, rax, 1
  00128	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00138	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0013e	48 85 c0	 test	 rax, rax
  00141	74 42		 je	 SHORT $LN12@z900_load_
  00143	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00151	d1 e8		 shr	 eax, 1
  00153	83 e0 01	 and	 eax, 1
  00156	85 c0		 test	 eax, eax
  00158	74 58		 je	 SHORT $LN11@z900_load_
  0015a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00162	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00169	b9 08 00 00 00	 mov	 ecx, 8
  0016e	48 6b c9 01	 imul	 rcx, rcx, 1
  00172	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00180	48 85 c0	 test	 rax, rax
  00183	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00185	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00197	ba 07 00 00 00	 mov	 edx, 7
  0019c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3483 :     BFPREGPAIR_CHECK( r1, regs );

  001b2	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001b6	83 e0 02	 and	 eax, 2
  001b9	85 c0		 test	 eax, eax
  001bb	74 1b		 je	 SHORT $LN13@z900_load_
  001bd	ba 06 00 00 00	 mov	 edx, 6
  001c2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 3484 : 
; 3485 :     GET_FLOAT32_OP( op2, r2, regs );

  001d8	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001dc	d1 e0		 shl	 eax, 1
  001de	48 98		 cdqe
  001e0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001f0	48 8b d0	 mov	 rdx, rax
  001f3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op2$[rsp]
  001f8	e8 00 00 00 00	 call	 z900_get_float32

; 3486 : 
; 3487 :     if (f32_isSignalingNaN( op2 ))

  001fd	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  00201	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00206	0f b6 c0	 movzx	 eax, al
  00209	85 c0		 test	 eax, eax
  0020b	0f 84 d7 00 00
	00		 je	 $LN14@z900_load_

; 3488 :     {
; 3489 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  00211	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00216	8b c0		 mov	 eax, eax
  00218	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00227	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022b	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3490 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0022f	33 c0		 xor	 eax, eax
  00231	83 f8 01	 cmp	 eax, 1
  00234	74 4b		 je	 SHORT $LN15@z900_load_
  00236	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023b	8b c0		 mov	 eax, eax
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00243	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00250	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00254	83 e0 10	 and	 eax, 16
  00257	85 c0		 test	 eax, eax
  00259	74 26		 je	 SHORT $LN15@z900_load_
  0025b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00263	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00269	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0026e	85 c0		 test	 eax, eax
  00270	74 0f		 je	 SHORT $LN15@z900_load_
  00272	b2 80		 mov	 dl, 128			; 00000080H
  00274	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027c	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_load_:

; 3491 : 
; 3492 :         FLOAT32_MAKE_QNAN( op2 );

  00281	8b 44 24 20	 mov	 eax, DWORD PTR op2$[rsp]
  00285	0f ba e8 16	 bts	 eax, 22
  00289	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 3493 :         SET_FPC_FLAGS_FROM_SF( regs );

  0028d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00292	8b c0		 mov	 eax, eax
  00294	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ab	c1 e0 13	 shl	 eax, 19
  002ae	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b6	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002bc	c1 e9 08	 shr	 ecx, 8
  002bf	f7 d1		 not	 ecx
  002c1	23 c1		 and	 eax, ecx
  002c3	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002c8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002d6	0b c8		 or	 ecx, eax
  002d8	8b c1		 mov	 eax, ecx
  002da	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN14@z900_load_:

; 3494 :     }
; 3495 : 
; 3496 :     op1 = f32_to_f128( op2 );

  002e8	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  002ec	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  002f1	e8 00 00 00 00	 call	 f32_to_f128
  002f6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  002fb	48 8b f9	 mov	 rdi, rcx
  002fe	48 8b f0	 mov	 rsi, rax
  00301	b9 10 00 00 00	 mov	 ecx, 16
  00306	f3 a4		 rep movsb

; 3497 : 
; 3498 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  00308	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0030c	d1 e0		 shl	 eax, 1
  0030e	48 98		 cdqe
  00310	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00318	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00320	48 8b d0	 mov	 rdx, rax
  00323	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00328	e8 00 00 00 00	 call	 z900_put_float128

; 3499 : }

  0032d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00332	48 33 cc	 xor	 rcx, rsp
  00335	e8 00 00 00 00	 call	 __security_check_cookie
  0033a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0033e	5f		 pop	 rdi
  0033f	5e		 pop	 rsi
  00340	c3		 ret	 0
z900_load_lengthened_bfp_short_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
b2$ = 36
op2$ = 40
x2$ = 44
effective_addr2$ = 48
r1$ = 56
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
z900_load_lengthened_bfp_short_to_ext PROC

; 3505 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3506 :     int         r1, x2, b2;
; 3507 :     VADR        effective_addr2;
; 3508 :     float32_t   op2;
; 3509 :     float128_t  op1;
; 3510 : 
; 3511 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	8b c0		 mov	 eax, eax
  00042	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00055	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00068	74 25		 je	 SHORT $LN8@z900_load_
  0006a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_load_:
  0008f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00093	c1 e8 0c	 shr	 eax, 12
  00096	83 e0 0f	 and	 eax, 15
  00099	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  0009d	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a2	74 25		 je	 SHORT $LN9@z900_load_
  000a4	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000be	48 03 c8	 add	 rcx, rax
  000c1	48 8b c1	 mov	 rax, rcx
  000c4	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
  000c9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000dd	48 23 c8	 and	 rcx, rax
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_load_:
  000e8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f4	48 83 c0 06	 add	 rax, 6
  000f8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00104	33 c0		 xor	 eax, eax
  00106	83 f8 06	 cmp	 eax, 6
  00109	74 0f		 je	 SHORT $LN10@z900_load_
  0010b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00113	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  0011a	33 c0		 xor	 eax, eax
  0011c	85 c0		 test	 eax, eax
  0011e	75 c8		 jne	 SHORT $LN4@z900_load_

; 3512 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00120	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  00125	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00129	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_load_:

; 3513 :     TXF_FLOAT_INSTR_CHECK( regs );

  00136	33 c0		 xor	 eax, eax
  00138	83 f8 01	 cmp	 eax, 1
  0013b	0f 84 81 00 00
	00		 je	 $LN11@z900_load_
  00141	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00150	85 c0		 test	 eax, eax
  00152	74 6e		 je	 SHORT $LN11@z900_load_
  00154	33 c0		 xor	 eax, eax
  00156	85 c0		 test	 eax, eax
  00158	75 29		 jne	 SHORT $LN12@z900_load_
  0015a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00162	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00169	85 c0		 test	 eax, eax
  0016b	75 16		 jne	 SHORT $LN12@z900_load_
  0016d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00175	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0017c	83 e0 04	 and	 eax, 4
  0017f	85 c0		 test	 eax, eax
  00181	75 3f		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00183	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00191	0f ba e8 0b	 bts	 eax, 11
  00195	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200153
  001aa	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001b0	ba 02 00 00 00	 mov	 edx, 2
  001b5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_load_:
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 3514 :     BFPINST_CHECK( regs );

  001cc	b8 08 00 00 00	 mov	 eax, 8
  001d1	48 6b c0 01	 imul	 rax, rax, 1
  001d5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001e5	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001eb	48 85 c0	 test	 rax, rax
  001ee	74 42		 je	 SHORT $LN14@z900_load_
  001f0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001fe	d1 e8		 shr	 eax, 1
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	74 58		 je	 SHORT $LN13@z900_load_
  00207	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00216	b9 08 00 00 00	 mov	 ecx, 8
  0021b	48 6b c9 01	 imul	 rcx, rcx, 1
  0021f	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00227	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0022d	48 85 c0	 test	 rax, rax
  00230	75 2d		 jne	 SHORT $LN13@z900_load_
$LN14@z900_load_:
  00232	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00244	ba 07 00 00 00	 mov	 edx, 7
  00249	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00259	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 3515 :     BFPREGPAIR_CHECK( r1, regs );

  0025f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00263	83 e0 02	 and	 eax, 2
  00266	85 c0		 test	 eax, eax
  00268	74 1b		 je	 SHORT $LN15@z900_load_
  0026a	ba 06 00 00 00	 mov	 edx, 6
  0026f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00277	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_load_:

; 3516 : 
; 3517 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00285	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0028d	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  00291	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00296	e8 00 00 00 00	 call	 z900_vfetch4
  0029b	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3518 : 
; 3519 :     if (f32_isSignalingNaN( op2 ))

  0029f	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  002a3	e8 00 00 00 00	 call	 f32_isSignalingNaN
  002a8	0f b6 c0	 movzx	 eax, al
  002ab	85 c0		 test	 eax, eax
  002ad	0f 84 d7 00 00
	00		 je	 $LN16@z900_load_

; 3520 :     {
; 3521 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  002b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b8	8b c0		 mov	 eax, eax
  002ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002cd	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3522 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002d1	33 c0		 xor	 eax, eax
  002d3	83 f8 01	 cmp	 eax, 1
  002d6	74 4b		 je	 SHORT $LN17@z900_load_
  002d8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002dd	8b c0		 mov	 eax, eax
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ee	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f6	83 e0 10	 and	 eax, 16
  002f9	85 c0		 test	 eax, eax
  002fb	74 26		 je	 SHORT $LN17@z900_load_
  002fd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00305	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0030b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00310	85 c0		 test	 eax, eax
  00312	74 0f		 je	 SHORT $LN17@z900_load_
  00314	b2 80		 mov	 dl, 128			; 00000080H
  00316	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_load_:

; 3523 : 
; 3524 :         FLOAT32_MAKE_QNAN( op2 );

  00323	8b 44 24 28	 mov	 eax, DWORD PTR op2$[rsp]
  00327	0f ba e8 16	 bts	 eax, 22
  0032b	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3525 :         SET_FPC_FLAGS_FROM_SF( regs );

  0032f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00334	8b c0		 mov	 eax, eax
  00336	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0033c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00345	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00349	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034d	c1 e0 13	 shl	 eax, 19
  00350	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00358	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0035e	c1 e9 08	 shr	 ecx, 8
  00361	f7 d1		 not	 ecx
  00363	23 c1		 and	 eax, ecx
  00365	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0036a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00372	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00378	0b c8		 or	 ecx, eax
  0037a	8b c1		 mov	 eax, ecx
  0037c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN16@z900_load_:

; 3526 :     }
; 3527 : 
; 3528 :     op1 = f32_to_f128( op2 );

  0038a	8b 54 24 28	 mov	 edx, DWORD PTR op2$[rsp]
  0038e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00393	e8 00 00 00 00	 call	 f32_to_f128
  00398	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0039d	48 8b f9	 mov	 rdi, rcx
  003a0	48 8b f0	 mov	 rsi, rax
  003a3	b9 10 00 00 00	 mov	 ecx, 16
  003a8	f3 a4		 rep movsb

; 3529 : 
; 3530 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  003aa	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  003ae	d1 e0		 shl	 eax, 1
  003b0	48 98		 cdqe
  003b2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ba	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003c2	48 8b d0	 mov	 rdx, rax
  003c5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  003ca	e8 00 00 00 00	 call	 z900_put_float128

; 3531 : }

  003cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003d4	48 33 cc	 xor	 rcx, rsp
  003d7	e8 00 00 00 00	 call	 __security_check_cookie
  003dc	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003e0	5f		 pop	 rdi
  003e1	5e		 pop	 rsi
  003e2	c3		 ret	 0
z900_load_lengthened_bfp_short_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
op2$ = 40
r2$ = 48
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
z900_load_lengthened_bfp_long_to_ext_reg PROC

; 3413 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3414 :     int         r1, r2;
; 3415 :     float64_t   op2;
; 3416 :     float128_t  op1;
; 3417 : 
; 3418 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00051	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN8@z900_load_
  00074	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3419 :     TXF_FLOAT_INSTR_CHECK( regs );

  00089	33 c0		 xor	 eax, eax
  0008b	83 f8 01	 cmp	 eax, 1
  0008e	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  00094	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a3	85 c0		 test	 eax, eax
  000a5	74 6e		 je	 SHORT $LN9@z900_load_
  000a7	33 c0		 xor	 eax, eax
  000a9	85 c0		 test	 eax, eax
  000ab	75 29		 jne	 SHORT $LN10@z900_load_
  000ad	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000bc	85 c0		 test	 eax, eax
  000be	75 16		 jne	 SHORT $LN10@z900_load_
  000c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000cf	83 e0 04	 and	 eax, 4
  000d2	85 c0		 test	 eax, eax
  000d4	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000d6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e4	0f ba e8 0b	 bts	 eax, 11
  000e8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000f6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200067
  000fd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00103	ba 02 00 00 00	 mov	 edx, 2
  00108	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 3420 :     BFPINST_CHECK( regs );

  0011f	b8 08 00 00 00	 mov	 eax, 8
  00124	48 6b c0 01	 imul	 rax, rax, 1
  00128	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00138	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0013e	48 85 c0	 test	 rax, rax
  00141	74 42		 je	 SHORT $LN12@z900_load_
  00143	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00151	d1 e8		 shr	 eax, 1
  00153	83 e0 01	 and	 eax, 1
  00156	85 c0		 test	 eax, eax
  00158	74 58		 je	 SHORT $LN11@z900_load_
  0015a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00162	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00169	b9 08 00 00 00	 mov	 ecx, 8
  0016e	48 6b c9 01	 imul	 rcx, rcx, 1
  00172	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00180	48 85 c0	 test	 rax, rax
  00183	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00185	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00197	ba 07 00 00 00	 mov	 edx, 7
  0019c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3421 :     BFPREGPAIR_CHECK( r1, regs );

  001b2	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001b6	83 e0 02	 and	 eax, 2
  001b9	85 c0		 test	 eax, eax
  001bb	74 1b		 je	 SHORT $LN13@z900_load_
  001bd	ba 06 00 00 00	 mov	 edx, 6
  001c2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 3422 : 
; 3423 :     GET_FLOAT64_OP( op2, r2, regs );

  001d8	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  001dc	d1 e0		 shl	 eax, 1
  001de	48 98		 cdqe
  001e0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001f0	48 8b d0	 mov	 rdx, rax
  001f3	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op2$[rsp]
  001f8	e8 00 00 00 00	 call	 z900_get_float64

; 3424 : 
; 3425 :     if (f64_isSignalingNaN( op2 ))

  001fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op2$[rsp]
  00202	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00207	0f b6 c0	 movzx	 eax, al
  0020a	85 c0		 test	 eax, eax
  0020c	0f 84 e5 00 00
	00		 je	 $LN14@z900_load_

; 3426 :     {
; 3427 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  00212	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00217	8b c0		 mov	 eax, eax
  00219	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00228	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022c	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3428 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00230	33 c0		 xor	 eax, eax
  00232	83 f8 01	 cmp	 eax, 1
  00235	74 4b		 je	 SHORT $LN15@z900_load_
  00237	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023c	8b c0		 mov	 eax, eax
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00244	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00251	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00255	83 e0 10	 and	 eax, 16
  00258	85 c0		 test	 eax, eax
  0025a	74 26		 je	 SHORT $LN15@z900_load_
  0025c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00264	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0026a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0026f	85 c0		 test	 eax, eax
  00271	74 0f		 je	 SHORT $LN15@z900_load_
  00273	b2 80		 mov	 dl, 128			; 00000080H
  00275	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_load_:

; 3429 : 
; 3430 :         FLOAT64_MAKE_QNAN( op2 );

  00282	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  0028c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op2$[rsp]
  00291	48 0b c8	 or	 rcx, rax
  00294	48 8b c1	 mov	 rax, rcx
  00297	48 89 44 24 28	 mov	 QWORD PTR op2$[rsp], rax

; 3431 :         SET_FPC_FLAGS_FROM_SF( regs );

  0029c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a1	8b c0		 mov	 eax, eax
  002a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ba	c1 e0 13	 shl	 eax, 19
  002bd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c5	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002cb	c1 e9 08	 shr	 ecx, 8
  002ce	f7 d1		 not	 ecx
  002d0	23 c1		 and	 eax, ecx
  002d2	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002d7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002e5	0b c8		 or	 ecx, eax
  002e7	8b c1		 mov	 eax, ecx
  002e9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f1	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN14@z900_load_:

; 3432 :     }
; 3433 : 
; 3434 :     op1 = f64_to_f128( op2 );

  002f7	48 8b 54 24 28	 mov	 rdx, QWORD PTR op2$[rsp]
  002fc	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  00301	e8 00 00 00 00	 call	 f64_to_f128
  00306	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0030b	48 8b f9	 mov	 rdi, rcx
  0030e	48 8b f0	 mov	 rsi, rax
  00311	b9 10 00 00 00	 mov	 ecx, 16
  00316	f3 a4		 rep movsb

; 3435 : 
; 3436 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  00318	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0031c	d1 e0		 shl	 eax, 1
  0031e	48 98		 cdqe
  00320	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00328	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00330	48 8b d0	 mov	 rdx, rax
  00333	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00338	e8 00 00 00 00	 call	 z900_put_float128

; 3437 : }

  0033d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00342	48 33 cc	 xor	 rcx, rsp
  00345	e8 00 00 00 00	 call	 __security_check_cookie
  0034a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0034e	5f		 pop	 rdi
  0034f	5e		 pop	 rsi
  00350	c3		 ret	 0
z900_load_lengthened_bfp_long_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 32
b2$ = 36
x2$ = 40
effective_addr2$ = 48
r1$ = 56
op2$ = 64
$T2 = 72
op1$ = 88
__$ArrayPad$ = 104
inst$ = 144
regs$ = 152
z900_load_lengthened_bfp_long_to_ext PROC

; 3443 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3444 :     int         r1, x2, b2;
; 3445 :     VADR        effective_addr2;
; 3446 :     float64_t   op2;
; 3447 :     float128_t  op1;
; 3448 : 
; 3449 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	8b c0		 mov	 eax, eax
  00042	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00055	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00068	74 25		 je	 SHORT $LN8@z900_load_
  0006a	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_load_:
  0008f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00093	c1 e8 0c	 shr	 eax, 12
  00096	83 e0 0f	 and	 eax, 15
  00099	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  0009d	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a2	74 25		 je	 SHORT $LN9@z900_load_
  000a4	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000be	48 03 c8	 add	 rcx, rax
  000c1	48 8b c1	 mov	 rax, rcx
  000c4	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
  000c9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000dd	48 23 c8	 and	 rcx, rax
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_load_:
  000e8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f4	48 83 c0 06	 add	 rax, 6
  000f8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00104	33 c0		 xor	 eax, eax
  00106	83 f8 06	 cmp	 eax, 6
  00109	74 0f		 je	 SHORT $LN10@z900_load_
  0010b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00113	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  0011a	33 c0		 xor	 eax, eax
  0011c	85 c0		 test	 eax, eax
  0011e	75 c8		 jne	 SHORT $LN4@z900_load_

; 3450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00120	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  00125	8b 54 24 28	 mov	 edx, DWORD PTR x2$[rsp]
  00129	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_load_:

; 3451 :     TXF_FLOAT_INSTR_CHECK( regs );

  00136	33 c0		 xor	 eax, eax
  00138	83 f8 01	 cmp	 eax, 1
  0013b	0f 84 81 00 00
	00		 je	 $LN11@z900_load_
  00141	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00150	85 c0		 test	 eax, eax
  00152	74 6e		 je	 SHORT $LN11@z900_load_
  00154	33 c0		 xor	 eax, eax
  00156	85 c0		 test	 eax, eax
  00158	75 29		 jne	 SHORT $LN12@z900_load_
  0015a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00162	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00169	85 c0		 test	 eax, eax
  0016b	75 16		 jne	 SHORT $LN12@z900_load_
  0016d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00175	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0017c	83 e0 04	 and	 eax, 4
  0017f	85 c0		 test	 eax, eax
  00181	75 3f		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00183	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00191	0f ba e8 0b	 bts	 eax, 11
  00195	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200097
  001aa	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001b0	ba 02 00 00 00	 mov	 edx, 2
  001b5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_load_:
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 3452 :     BFPINST_CHECK( regs );

  001cc	b8 08 00 00 00	 mov	 eax, 8
  001d1	48 6b c0 01	 imul	 rax, rax, 1
  001d5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001e5	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001eb	48 85 c0	 test	 rax, rax
  001ee	74 42		 je	 SHORT $LN14@z900_load_
  001f0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001fe	d1 e8		 shr	 eax, 1
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	74 58		 je	 SHORT $LN13@z900_load_
  00207	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00216	b9 08 00 00 00	 mov	 ecx, 8
  0021b	48 6b c9 01	 imul	 rcx, rcx, 1
  0021f	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00227	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0022d	48 85 c0	 test	 rax, rax
  00230	75 2d		 jne	 SHORT $LN13@z900_load_
$LN14@z900_load_:
  00232	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00244	ba 07 00 00 00	 mov	 edx, 7
  00249	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00259	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 3453 :     BFPREGPAIR_CHECK( r1, regs );

  0025f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00263	83 e0 02	 and	 eax, 2
  00266	85 c0		 test	 eax, eax
  00268	74 1b		 je	 SHORT $LN15@z900_load_
  0026a	ba 06 00 00 00	 mov	 edx, 6
  0026f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00277	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_load_:

; 3454 : 
; 3455 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00285	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0028d	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  00291	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00296	e8 00 00 00 00	 call	 z900_vfetch8
  0029b	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 3456 : 
; 3457 :     if (f64_isSignalingNaN( op2 ))

  002a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  002a5	e8 00 00 00 00	 call	 f64_isSignalingNaN
  002aa	0f b6 c0	 movzx	 eax, al
  002ad	85 c0		 test	 eax, eax
  002af	0f 84 e5 00 00
	00		 je	 $LN16@z900_load_

; 3458 :     {
; 3459 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  002b5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ba	8b c0		 mov	 eax, eax
  002bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002cb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002cf	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3460 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002d3	33 c0		 xor	 eax, eax
  002d5	83 f8 01	 cmp	 eax, 1
  002d8	74 4b		 je	 SHORT $LN17@z900_load_
  002da	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002df	8b c0		 mov	 eax, eax
  002e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f8	83 e0 10	 and	 eax, 16
  002fb	85 c0		 test	 eax, eax
  002fd	74 26		 je	 SHORT $LN17@z900_load_
  002ff	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00307	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0030d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00312	85 c0		 test	 eax, eax
  00314	74 0f		 je	 SHORT $LN17@z900_load_
  00316	b2 80		 mov	 dl, 128			; 00000080H
  00318	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_load_:

; 3461 : 
; 3462 :         FLOAT64_MAKE_QNAN( op2 );

  00325	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  0032f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  00334	48 0b c8	 or	 rcx, rax
  00337	48 8b c1	 mov	 rax, rcx
  0033a	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 3463 :         SET_FPC_FLAGS_FROM_SF( regs );

  0033f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00344	8b c0		 mov	 eax, eax
  00346	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0034c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00355	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00359	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035d	c1 e0 13	 shl	 eax, 19
  00360	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00368	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0036e	c1 e9 08	 shr	 ecx, 8
  00371	f7 d1		 not	 ecx
  00373	23 c1		 and	 eax, ecx
  00375	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0037a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00382	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00388	0b c8		 or	 ecx, eax
  0038a	8b c1		 mov	 eax, ecx
  0038c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00394	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN16@z900_load_:

; 3464 :     }
; 3465 : 
; 3466 :     op1 = f64_to_f128( op2 );

  0039a	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  0039f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T2[rsp]
  003a4	e8 00 00 00 00	 call	 f64_to_f128
  003a9	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  003ae	48 8b f9	 mov	 rdi, rcx
  003b1	48 8b f0	 mov	 rsi, rax
  003b4	b9 10 00 00 00	 mov	 ecx, 16
  003b9	f3 a4		 rep movsb

; 3467 : 
; 3468 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  003bb	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  003bf	d1 e0		 shl	 eax, 1
  003c1	48 98		 cdqe
  003c3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003cb	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003d3	48 8b d0	 mov	 rdx, rax
  003d6	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  003db	e8 00 00 00 00	 call	 z900_put_float128

; 3469 : }

  003e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003e5	48 33 cc	 xor	 rcx, rsp
  003e8	e8 00 00 00 00	 call	 __security_check_cookie
  003ed	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003f1	5f		 pop	 rdi
  003f2	5e		 pop	 rsi
  003f3	c3		 ret	 0
z900_load_lengthened_bfp_long_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
op$ = 40
ieee_trap_conds$ = 44
tv195 = 48
tv201 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
z900_load_fp_int_bfp_short_reg PROC

; 3224 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3225 :     int        r1, r2;
; 3226 :     BYTE       m3, m4;
; 3227 :     float32_t  op;
; 3228 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3229 : 
; 3230 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_load_:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_load_
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3231 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_load_
  00096	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_load_
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_load_
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_load_
  000bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000cf	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199928
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_load_

; 3232 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_load_
  0012c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_load_
  00140	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00168	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3233 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 3234 : 
; 3235 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3236 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0019b	b8 01 00 00 00	 mov	 eax, 1
  001a0	48 6b c0 04	 imul	 rax, rax, 4
  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001b1	83 e0 04	 and	 eax, 4
  001b4	85 c0		 test	 eax, eax
  001b6	75 05		 jne	 SHORT $LN13@z900_load_

; 3237 : #endif
; 3238 :         m4 = 0;

  001b8	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0
$LN13@z900_load_:

; 3239 : 
; 3240 :     GET_FLOAT32_OP( op, r2, regs );

  001bd	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  001c1	d1 e0		 shl	 eax, 1
  001c3	48 98		 cdqe
  001c5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op$[rsp]
  001da	e8 00 00 00 00	 call	 z900_get_float32

; 3241 : 
; 3242 :     softfloat_exceptionFlags = 0;

  001df	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e4	8b c0		 mov	 eax, eax
  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ec	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f9	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3243 :     SET_SF_RM_FROM_MASK( m3 );

  001fd	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00202	85 c0		 test	 eax, eax
  00204	74 16		 je	 SHORT $LN18@z900_load_
  00206	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00212	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00216	89 44 24 30	 mov	 DWORD PTR tv195[rsp], eax
  0021a	eb 1f		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  0021c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00221	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00227	83 e0 07	 and	 eax, 7
  0022a	8b c0		 mov	 eax, eax
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00233	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00237	89 44 24 30	 mov	 DWORD PTR tv195[rsp], eax
$LN19@z900_load_:
  0023b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00240	8b c0		 mov	 eax, eax
  00242	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00248	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00251	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00255	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv195[rsp]
  0025a	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3244 : 
; 3245 :     op = f32_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  0025d	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00262	83 e0 04	 and	 eax, 4
  00265	85 c0		 test	 eax, eax
  00267	75 0a		 jne	 SHORT $LN20@z900_load_
  00269	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv201[rsp], 1
  00271	eb 08		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00273	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv201[rsp], 0
$LN21@z900_load_:
  0027b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00280	8b c0		 mov	 eax, eax
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00288	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00291	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00295	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv201[rsp]
  0029b	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0029f	8b 4c 24 28	 mov	 ecx, DWORD PTR op$[rsp]
  002a3	e8 00 00 00 00	 call	 f32_roundToInt
  002a8	89 44 24 28	 mov	 DWORD PTR op$[rsp], eax

; 3246 : 
; 3247 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002ac	33 c0		 xor	 eax, eax
  002ae	83 f8 01	 cmp	 eax, 1
  002b1	74 45		 je	 SHORT $LN14@z900_load_
  002b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b8	8b c0		 mov	 eax, eax
  002ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002cd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d1	83 e0 10	 and	 eax, 16
  002d4	85 c0		 test	 eax, eax
  002d6	74 20		 je	 SHORT $LN14@z900_load_
  002d8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  002dd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002e3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002e8	85 c0		 test	 eax, eax
  002ea	74 0c		 je	 SHORT $LN14@z900_load_
  002ec	b2 80		 mov	 dl, 128			; 00000080H
  002ee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002f3	e8 00 00 00 00	 call	 ieee_trap
$LN14@z900_load_:

; 3248 : 
; 3249 :     PUT_FLOAT32_NOCC( op, r1, regs );

  002f8	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  002fc	d1 e0		 shl	 eax, 1
  002fe	48 98		 cdqe
  00300	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00305	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0030d	48 8b d0	 mov	 rdx, rax
  00310	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op$[rsp]
  00315	e8 00 00 00 00	 call	 z900_put_float32

; 3250 : 
; 3251 :     if (softfloat_exceptionFlags)

  0031a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0031f	8b c0		 mov	 eax, eax
  00321	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00327	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00330	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00334	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00338	85 c0		 test	 eax, eax
  0033a	74 29		 je	 SHORT $LN15@z900_load_

; 3252 :     {
; 3253 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0033c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00341	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00346	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3254 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0034a	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0034e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00353	85 c0		 test	 eax, eax
  00355	74 0e		 je	 SHORT $LN16@z900_load_
  00357	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0035b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00360	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@z900_load_:
$LN15@z900_load_:

; 3255 :     }
; 3256 : }

  00365	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00369	c3		 ret	 0
z900_load_fp_int_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv195 = 44
tv201 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
z900_load_fp_int_bfp_long_reg PROC

; 3262 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3263 :     int        r1, r2;
; 3264 :     BYTE m3,   m4;
; 3265 :     float64_t  op;
; 3266 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3267 : 
; 3268 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_load_:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_load_
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3269 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_load_
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_load_
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_load_
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_load_
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199956
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_load_

; 3270 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_load_
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_load_
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3271 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 3272 : 
; 3273 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3274 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0019b	b8 01 00 00 00	 mov	 eax, 1
  001a0	48 6b c0 04	 imul	 rax, rax, 4
  001a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001b1	83 e0 04	 and	 eax, 4
  001b4	85 c0		 test	 eax, eax
  001b6	75 05		 jne	 SHORT $LN13@z900_load_

; 3275 : #endif
; 3276 :         m4 = 0;

  001b8	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0
$LN13@z900_load_:

; 3277 : 
; 3278 :     GET_FLOAT64_OP( op, r2, regs );

  001bd	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  001c1	d1 e0		 shl	 eax, 1
  001c3	48 98		 cdqe
  001c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001da	e8 00 00 00 00	 call	 z900_get_float64

; 3279 : 
; 3280 :     softfloat_exceptionFlags = 0;

  001df	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e4	8b c0		 mov	 eax, eax
  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ec	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f9	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3281 :     SET_SF_RM_FROM_MASK( m3 );

  001fd	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00202	85 c0		 test	 eax, eax
  00204	74 16		 je	 SHORT $LN18@z900_load_
  00206	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00212	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00216	89 44 24 2c	 mov	 DWORD PTR tv195[rsp], eax
  0021a	eb 1f		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  0021c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00221	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00227	83 e0 07	 and	 eax, 7
  0022a	8b c0		 mov	 eax, eax
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00233	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00237	89 44 24 2c	 mov	 DWORD PTR tv195[rsp], eax
$LN19@z900_load_:
  0023b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00240	8b c0		 mov	 eax, eax
  00242	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00248	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00251	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00255	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv195[rsp]
  0025a	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3282 : 
; 3283 :     op = f64_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  0025d	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00262	83 e0 04	 and	 eax, 4
  00265	85 c0		 test	 eax, eax
  00267	75 0a		 jne	 SHORT $LN20@z900_load_
  00269	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv201[rsp], 1
  00271	eb 08		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00273	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv201[rsp], 0
$LN21@z900_load_:
  0027b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00280	8b c0		 mov	 eax, eax
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00288	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00291	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00295	44 0f b6 44 24
	30		 movzx	 r8d, BYTE PTR tv201[rsp]
  0029b	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0029f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  002a4	e8 00 00 00 00	 call	 f64_roundToInt
  002a9	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax

; 3284 : 
; 3285 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002ae	33 c0		 xor	 eax, eax
  002b0	83 f8 01	 cmp	 eax, 1
  002b3	74 45		 je	 SHORT $LN14@z900_load_
  002b5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ba	8b c0		 mov	 eax, eax
  002bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002cb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d3	83 e0 10	 and	 eax, 16
  002d6	85 c0		 test	 eax, eax
  002d8	74 20		 je	 SHORT $LN14@z900_load_
  002da	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002df	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002e5	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002ea	85 c0		 test	 eax, eax
  002ec	74 0c		 je	 SHORT $LN14@z900_load_
  002ee	b2 80		 mov	 dl, 128			; 00000080H
  002f0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f5	e8 00 00 00 00	 call	 ieee_trap
$LN14@z900_load_:

; 3286 : 
; 3287 :     PUT_FLOAT64_NOCC( op, r1, regs );

  002fa	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002fe	d1 e0		 shl	 eax, 1
  00300	48 98		 cdqe
  00302	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00307	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0030f	48 8b d0	 mov	 rdx, rax
  00312	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00317	e8 00 00 00 00	 call	 z900_put_float64

; 3288 : 
; 3289 :     if (softfloat_exceptionFlags)

  0031c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00321	8b c0		 mov	 eax, eax
  00323	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00329	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00332	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00336	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0033a	85 c0		 test	 eax, eax
  0033c	74 29		 je	 SHORT $LN15@z900_load_

; 3290 :     {
; 3291 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0033e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00343	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00348	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3292 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0034c	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00350	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00355	85 c0		 test	 eax, eax
  00357	74 0e		 je	 SHORT $LN16@z900_load_
  00359	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0035d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00362	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@z900_load_:
$LN15@z900_load_:

; 3293 :     }
; 3294 : }

  00367	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0036b	c3		 ret	 0
z900_load_fp_int_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
r2$ = 44
tv202 = 48
tv208 = 52
r1$ = 56
tv261 = 64
$T2 = 80
$T3 = 96
op$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
z900_load_fp_int_bfp_ext_reg PROC

; 3300 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3301 :     int         r1, r2;
; 3302 :     BYTE        m3, m4;
; 3303 :     float128_t  op;
; 3304 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3305 : 
; 3306 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_load_:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN8@z900_load_
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3307 :     TXF_FLOAT_INSTR_CHECK( regs );

  000b2	33 c0		 xor	 eax, eax
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000cc	85 c0		 test	 eax, eax
  000ce	74 6e		 je	 SHORT $LN9@z900_load_
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 29		 jne	 SHORT $LN10@z900_load_
  000d6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000e5	85 c0		 test	 eax, eax
  000e7	75 16		 jne	 SHORT $LN10@z900_load_
  000e9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000f8	83 e0 04	 and	 eax, 4
  000fb	85 c0		 test	 eax, eax
  000fd	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000ff	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010d	0f ba e8 0b	 bts	 eax, 11
  00111	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199984
  00126	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012c	ba 02 00 00 00	 mov	 edx, 2
  00131	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 3308 :     BFPINST_CHECK( regs );

  00148	b8 08 00 00 00	 mov	 eax, 8
  0014d	48 6b c0 01	 imul	 rax, rax, 1
  00151	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00161	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00167	48 85 c0	 test	 rax, rax
  0016a	74 42		 je	 SHORT $LN12@z900_load_
  0016c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017a	d1 e8		 shr	 eax, 1
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 58		 je	 SHORT $LN11@z900_load_
  00183	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00192	b9 08 00 00 00	 mov	 ecx, 8
  00197	48 6b c9 01	 imul	 rcx, rcx, 1
  0019b	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001a3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a9	48 85 c0	 test	 rax, rax
  001ac	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  001ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001c0	ba 07 00 00 00	 mov	 edx, 7
  001c5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 3309 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001db	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001df	83 e0 02	 and	 eax, 2
  001e2	85 c0		 test	 eax, eax
  001e4	75 0b		 jne	 SHORT $LN14@z900_load_
  001e6	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001ea	83 e0 02	 and	 eax, 2
  001ed	85 c0		 test	 eax, eax
  001ef	74 1b		 je	 SHORT $LN13@z900_load_
$LN14@z900_load_:
  001f1	ba 06 00 00 00	 mov	 edx, 6
  001f6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00206	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 3310 :     BFPRM_CHECK( m3, regs );

  0020c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00211	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 3311 : 
; 3312 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3313 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0021e	b8 01 00 00 00	 mov	 eax, 1
  00223	48 6b c0 04	 imul	 rax, rax, 4
  00227	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022f	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00237	83 e0 04	 and	 eax, 4
  0023a	85 c0		 test	 eax, eax
  0023c	75 05		 jne	 SHORT $LN15@z900_load_

; 3314 : #endif
; 3315 :         m4 = 0;

  0023e	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0
$LN15@z900_load_:

; 3316 : 
; 3317 :     GET_FLOAT128_OP( op, r2, regs );

  00243	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00247	d1 e0		 shl	 eax, 1
  00249	48 98		 cdqe
  0024b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00253	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0025b	48 8b d0	 mov	 rdx, rax
  0025e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  00263	e8 00 00 00 00	 call	 z900_get_float128

; 3318 : 
; 3319 :     softfloat_exceptionFlags = 0;

  00268	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0026d	8b c0		 mov	 eax, eax
  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00275	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00282	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3320 :     SET_SF_RM_FROM_MASK( m3 );

  00286	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0028b	85 c0		 test	 eax, eax
  0028d	74 16		 je	 SHORT $LN20@z900_load_
  0028f	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0029b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029f	89 44 24 30	 mov	 DWORD PTR tv202[rsp], eax
  002a3	eb 22		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  002a5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002b3	83 e0 07	 and	 eax, 7
  002b6	8b c0		 mov	 eax, eax
  002b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c3	89 44 24 30	 mov	 DWORD PTR tv202[rsp], eax
$LN21@z900_load_:
  002c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002cc	8b c0		 mov	 eax, eax
  002ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e1	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv202[rsp]
  002e6	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3321 : 
; 3322 :     op = f128_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002e9	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002ee	83 e0 04	 and	 eax, 4
  002f1	85 c0		 test	 eax, eax
  002f3	75 0a		 jne	 SHORT $LN22@z900_load_
  002f5	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv208[rsp], 1
  002fd	eb 08		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  002ff	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv208[rsp], 0
$LN23@z900_load_:
  00307	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0030c	8b c0		 mov	 eax, eax
  0030e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00314	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0031d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00321	48 89 4c 24 40	 mov	 QWORD PTR tv261[rsp], rcx
  00326	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  0032b	4c 8d 44 24 70	 lea	 r8, QWORD PTR op$[rsp]
  00330	48 8b fa	 mov	 rdi, rdx
  00333	49 8b f0	 mov	 rsi, r8
  00336	b9 10 00 00 00	 mov	 ecx, 16
  0033b	f3 a4		 rep movsb
  0033d	44 0f b6 4c 24
	34		 movzx	 r9d, BYTE PTR tv208[rsp]
  00343	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv261[rsp]
  00348	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  0034d	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00352	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  00357	e8 00 00 00 00	 call	 f128_roundToInt
  0035c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  00361	48 8b f9	 mov	 rdi, rcx
  00364	48 8b f0	 mov	 rsi, rax
  00367	b9 10 00 00 00	 mov	 ecx, 16
  0036c	f3 a4		 rep movsb

; 3323 : 
; 3324 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0036e	33 c0		 xor	 eax, eax
  00370	83 f8 01	 cmp	 eax, 1
  00373	74 4b		 je	 SHORT $LN16@z900_load_
  00375	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0037a	8b c0		 mov	 eax, eax
  0037c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00382	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0038f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00393	83 e0 10	 and	 eax, 16
  00396	85 c0		 test	 eax, eax
  00398	74 26		 je	 SHORT $LN16@z900_load_
  0039a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a2	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003a8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003ad	85 c0		 test	 eax, eax
  003af	74 0f		 je	 SHORT $LN16@z900_load_
  003b1	b2 80		 mov	 dl, 128			; 00000080H
  003b3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bb	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_load_:

; 3325 : 
; 3326 :     PUT_FLOAT128_NOCC( op, r1, regs );

  003c0	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  003c4	d1 e0		 shl	 eax, 1
  003c6	48 98		 cdqe
  003c8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003d8	48 8b d0	 mov	 rdx, rax
  003db	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  003e0	e8 00 00 00 00	 call	 z900_put_float128

; 3327 : 
; 3328 :     if (softfloat_exceptionFlags)

  003e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003ea	8b c0		 mov	 eax, eax
  003ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00403	85 c0		 test	 eax, eax
  00405	74 2f		 je	 SHORT $LN17@z900_load_

; 3329 :     {
; 3330 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00407	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040f	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00414	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3331 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00418	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0041c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00421	85 c0		 test	 eax, eax
  00423	74 11		 je	 SHORT $LN18@z900_load_
  00425	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00429	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00431	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@z900_load_:
$LN17@z900_load_:

; 3332 :     }
; 3333 : }

  00436	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043e	48 33 cc	 xor	 rcx, rsp
  00441	e8 00 00 00 00	 call	 __security_check_cookie
  00446	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0044d	5f		 pop	 rdi
  0044e	5e		 pop	 rsi
  0044f	c3		 ret	 0
z900_load_fp_int_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv171 = 40
tv174 = 44
tv176 = 48
tv177 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
z900_load_complement_bfp_short_reg PROC

; 3629 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3630 :     int        r1, r2;
; 3631 :     float32_t  op;
; 3632 : 
; 3633 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3634 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_load_
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_load_
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_load_
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200304
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3635 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_load_
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_load_
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3636 : 
; 3637 :     GET_FLOAT32_OP( op, r2, regs );

  00169	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float32

; 3638 :     op.v ^= 0x80000000;

  0018b	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0018f	0f ba f8 1f	 btc	 eax, 31
  00193	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN10@z900_load_:

; 3639 : 
; 3640 :     PUT_FLOAT32_CC( op, r1, regs );

  00197	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0019b	d1 e0		 shl	 eax, 1
  0019d	48 98		 cdqe
  0019f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001ac	48 8b d0	 mov	 rdx, rax
  001af	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  001b4	e8 00 00 00 00	 call	 z900_put_float32
  001b9	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001bd	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  001c2	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  001c7	75 17		 jne	 SHORT $LN17@z900_load_
  001c9	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001cd	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001d2	85 c0		 test	 eax, eax
  001d4	74 0a		 je	 SHORT $LN17@z900_load_
  001d6	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv177[rsp], 3
  001de	eb 5e		 jmp	 SHORT $LN24@z900_load_
$LN17@z900_load_:
  001e0	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001e4	0f ba f0 1f	 btr	 eax, 31
  001e8	85 c0		 test	 eax, eax
  001ea	75 0a		 jne	 SHORT $LN18@z900_load_
  001ec	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  001f4	eb 08		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  001f6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN19@z900_load_:
  001fe	83 7c 24 28 00	 cmp	 DWORD PTR tv171[rsp], 0
  00203	74 0a		 je	 SHORT $LN22@z900_load_
  00205	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  0020d	eb 27		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  0020f	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00213	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00218	85 c0		 test	 eax, eax
  0021a	74 0a		 je	 SHORT $LN20@z900_load_
  0021c	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00224	eb 08		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00226	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN21@z900_load_:
  0022e	8b 44 24 2c	 mov	 eax, DWORD PTR tv174[rsp]
  00232	89 44 24 30	 mov	 DWORD PTR tv176[rsp], eax
$LN23@z900_load_:
  00236	8b 44 24 30	 mov	 eax, DWORD PTR tv176[rsp]
  0023a	89 44 24 34	 mov	 DWORD PTR tv177[rsp], eax
$LN24@z900_load_:
  0023e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00243	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv177[rsp]
  00248	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0024b	33 c0		 xor	 eax, eax
  0024d	85 c0		 test	 eax, eax
  0024f	0f 85 42 ff ff
	ff		 jne	 $LN10@z900_load_

; 3641 : }

  00255	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00259	c3		 ret	 0
z900_load_complement_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv171 = 36
tv174 = 40
tv176 = 44
tv177 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
z900_load_complement_bfp_long_reg PROC

; 3611 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3612 :     int        r1, r2;
; 3613 :     float64_t  op;
; 3614 : 
; 3615 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3616 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_load_
  00073	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_load_
  00089	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_load_
  00099	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200280
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3617 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_load_
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_load_
  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00145	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3618 : 
; 3619 :     GET_FLOAT64_OP( op, r2, regs );

  00169	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float64

; 3620 :     op.v ^= 0x8000000000000000ULL;

  0018b	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00195	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019a	48 33 c8	 xor	 rcx, rax
  0019d	48 8b c1	 mov	 rax, rcx
  001a0	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN10@z900_load_:

; 3621 : 
; 3622 :     PUT_FLOAT64_CC( op, r1, regs );

  001a5	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001a9	d1 e0		 shl	 eax, 1
  001ab	48 98		 cdqe
  001ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001ba	48 8b d0	 mov	 rdx, rax
  001bd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001c2	e8 00 00 00 00	 call	 z900_put_float64
  001c7	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  001d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d6	48 23 c8	 and	 rcx, rax
  001d9	48 8b c1	 mov	 rax, rcx
  001dc	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001e6	48 3b c1	 cmp	 rax, rcx
  001e9	75 24		 jne	 SHORT $LN17@z900_load_
  001eb	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  001f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001fa	48 23 c8	 and	 rcx, rax
  001fd	48 8b c1	 mov	 rax, rcx
  00200	48 85 c0	 test	 rax, rax
  00203	74 0a		 je	 SHORT $LN17@z900_load_
  00205	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv177[rsp], 3
  0020d	eb 79		 jmp	 SHORT $LN24@z900_load_
$LN17@z900_load_:
  0020f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00219	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0021e	48 23 c8	 and	 rcx, rax
  00221	48 8b c1	 mov	 rax, rcx
  00224	48 85 c0	 test	 rax, rax
  00227	75 0a		 jne	 SHORT $LN18@z900_load_
  00229	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  00231	eb 08		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  00233	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN19@z900_load_:
  0023b	83 7c 24 24 00	 cmp	 DWORD PTR tv171[rsp], 0
  00240	74 0a		 je	 SHORT $LN22@z900_load_
  00242	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  0024a	eb 34		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  0024c	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00256	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0025b	48 23 c8	 and	 rcx, rax
  0025e	48 8b c1	 mov	 rax, rcx
  00261	48 85 c0	 test	 rax, rax
  00264	74 0a		 je	 SHORT $LN20@z900_load_
  00266	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0026e	eb 08		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00270	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN21@z900_load_:
  00278	8b 44 24 28	 mov	 eax, DWORD PTR tv174[rsp]
  0027c	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
$LN23@z900_load_:
  00280	8b 44 24 2c	 mov	 eax, DWORD PTR tv176[rsp]
  00284	89 44 24 30	 mov	 DWORD PTR tv177[rsp], eax
$LN24@z900_load_:
  00288	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0028d	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv177[rsp]
  00292	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00295	33 c0		 xor	 eax, eax
  00297	85 c0		 test	 eax, eax
  00299	0f 85 06 ff ff
	ff		 jne	 $LN10@z900_load_

; 3623 : }

  0029f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002a3	c3		 ret	 0
z900_load_complement_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv194 = 44
tv199 = 48
tv201 = 52
tv202 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
z900_load_complement_bfp_ext_reg PROC

; 3592 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3593 :     int         r1, r2;
; 3594 :     float128_t  op;
; 3595 : 
; 3596 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN11@z900_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3597 :     TXF_FLOAT_INSTR_CHECK( regs );

  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 01	 cmp	 eax, 1
  00080	74 6f		 je	 SHORT $LN12@z900_load_
  00082	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00087	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0008e	85 c0		 test	 eax, eax
  00090	74 5f		 je	 SHORT $LN12@z900_load_
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	75 23		 jne	 SHORT $LN13@z900_load_
  00098	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a4	85 c0		 test	 eax, eax
  000a6	75 13		 jne	 SHORT $LN13@z900_load_
  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000b4	83 e0 04	 and	 eax, 4
  000b7	85 c0		 test	 eax, eax
  000b9	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000bb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c6	0f ba e8 0b	 bts	 eax, 11
  000ca	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG200254
  000dc	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e2	ba 02 00 00 00	 mov	 edx, 2
  000e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 84		 jne	 SHORT $LN7@z900_load_

; 3598 :     BFPINST_CHECK( regs );

  000f7	b8 08 00 00 00	 mov	 eax, 8
  000fc	48 6b c0 01	 imul	 rax, rax, 1
  00100	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0010d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00113	48 85 c0	 test	 rax, rax
  00116	74 3c		 je	 SHORT $LN15@z900_load_
  00118	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00123	d1 e8		 shr	 eax, 1
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	74 4c		 je	 SHORT $LN14@z900_load_
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00138	b9 08 00 00 00	 mov	 ecx, 8
  0013d	48 6b c9 01	 imul	 rcx, rcx, 1
  00141	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00154	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00159	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00163	ba 07 00 00 00	 mov	 edx, 7
  00168	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00172	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3599 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00178	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0017c	83 e0 02	 and	 eax, 2
  0017f	85 c0		 test	 eax, eax
  00181	75 0b		 jne	 SHORT $LN17@z900_load_
  00183	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00187	83 e0 02	 and	 eax, 2
  0018a	85 c0		 test	 eax, eax
  0018c	74 15		 je	 SHORT $LN16@z900_load_
$LN17@z900_load_:
  0018e	ba 06 00 00 00	 mov	 edx, 6
  00193	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_load_:

; 3600 : 
; 3601 :     GET_FLOAT128_OP( op, r2, regs );

  001a3	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001a7	d1 e0		 shl	 eax, 1
  001a9	48 98		 cdqe
  001ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b8	48 8b d0	 mov	 rdx, rax
  001bb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001c0	e8 00 00 00 00	 call	 z900_get_float128

; 3602 :     op.v[FLOAT128_HI] ^= 0x8000000000000000ULL;

  001c5	b8 08 00 00 00	 mov	 eax, 8
  001ca	48 6b c0 01	 imul	 rax, rax, 1
  001ce	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  001d8	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001dd	48 33 c1	 xor	 rax, rcx
  001e0	b9 08 00 00 00	 mov	 ecx, 8
  001e5	48 6b c9 01	 imul	 rcx, rcx, 1
  001e9	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN10@z900_load_:

; 3603 : 
; 3604 :     PUT_FLOAT128_CC( op, r1, regs );

  001ee	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001f2	d1 e0		 shl	 eax, 1
  001f4	48 98		 cdqe
  001f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001fb	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00203	48 8b d0	 mov	 rdx, rax
  00206	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0020b	e8 00 00 00 00	 call	 z900_put_float128
  00210	b8 08 00 00 00	 mov	 eax, 8
  00215	48 6b c0 01	 imul	 rax, rax, 1
  00219	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00223	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00228	48 23 c1	 and	 rax, rcx
  0022b	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00235	48 3b c1	 cmp	 rax, rcx
  00238	75 3e		 jne	 SHORT $LN20@z900_load_
  0023a	b8 08 00 00 00	 mov	 eax, 8
  0023f	48 6b c0 01	 imul	 rax, rax, 1
  00243	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  0024d	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00252	48 23 c1	 and	 rax, rcx
  00255	48 85 c0	 test	 rax, rax
  00258	75 11		 jne	 SHORT $LN19@z900_load_
  0025a	b8 08 00 00 00	 mov	 eax, 8
  0025f	48 6b c0 00	 imul	 rax, rax, 0
  00263	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  00269	74 0d		 je	 SHORT $LN20@z900_load_
$LN19@z900_load_:
  0026b	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv202[rsp], 3
  00273	e9 93 00 00 00	 jmp	 $LN27@z900_load_
$LN20@z900_load_:
  00278	b8 08 00 00 00	 mov	 eax, 8
  0027d	48 6b c0 01	 imul	 rax, rax, 1
  00281	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0028b	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  00290	48 23 c1	 and	 rax, rcx
  00293	b9 08 00 00 00	 mov	 ecx, 8
  00298	48 6b c9 00	 imul	 rcx, rcx, 0
  0029c	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  002a1	48 85 c0	 test	 rax, rax
  002a4	75 0a		 jne	 SHORT $LN21@z900_load_
  002a6	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  002ae	eb 08		 jmp	 SHORT $LN22@z900_load_
$LN21@z900_load_:
  002b0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN22@z900_load_:
  002b8	83 7c 24 2c 00	 cmp	 DWORD PTR tv194[rsp], 0
  002bd	74 0a		 je	 SHORT $LN25@z900_load_
  002bf	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv201[rsp], 0
  002c7	eb 3a		 jmp	 SHORT $LN26@z900_load_
$LN25@z900_load_:
  002c9	b8 08 00 00 00	 mov	 eax, 8
  002ce	48 6b c0 01	 imul	 rax, rax, 1
  002d2	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002dc	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  002e1	48 23 c1	 and	 rax, rcx
  002e4	48 85 c0	 test	 rax, rax
  002e7	74 0a		 je	 SHORT $LN23@z900_load_
  002e9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv199[rsp], 1
  002f1	eb 08		 jmp	 SHORT $LN24@z900_load_
$LN23@z900_load_:
  002f3	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv199[rsp], 2
$LN24@z900_load_:
  002fb	8b 44 24 30	 mov	 eax, DWORD PTR tv199[rsp]
  002ff	89 44 24 34	 mov	 DWORD PTR tv201[rsp], eax
$LN26@z900_load_:
  00303	8b 44 24 34	 mov	 eax, DWORD PTR tv201[rsp]
  00307	89 44 24 38	 mov	 DWORD PTR tv202[rsp], eax
$LN27@z900_load_:
  0030b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00310	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv202[rsp]
  00315	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00318	33 c0		 xor	 eax, eax
  0031a	85 c0		 test	 eax, eax
  0031c	0f 85 cc fe ff
	ff		 jne	 $LN10@z900_load_

; 3605 : }

  00322	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00327	48 33 cc	 xor	 rcx, rsp
  0032a	e8 00 00 00 00	 call	 __security_check_cookie
  0032f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00333	c3		 ret	 0
z900_load_complement_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv187 = 40
tv190 = 44
tv192 = 48
tv193 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
z900_load_and_test_bfp_short_reg PROC

; 3192 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3193 :     int        r1, r2;
; 3194 :     float32_t  op;
; 3195 : 
; 3196 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3197 : 
; 3198 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_load_
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_load_
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_load_
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199900
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3199 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_load_
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_load_
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3200 : 
; 3201 :     GET_FLOAT32_OP( op, r2, regs );

  00169	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float32

; 3202 : 
; 3203 :     if (FLOAT32_ISNAN( op ))

  0018b	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0018f	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00194	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00199	75 65		 jne	 SHORT $LN16@z900_load_
  0019b	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0019f	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001a4	85 c0		 test	 eax, eax
  001a6	74 58		 je	 SHORT $LN16@z900_load_

; 3204 :     {
; 3205 :         if (f32_isSignalingNaN( op ))

  001a8	8b 4c 24 20	 mov	 ecx, DWORD PTR op$[rsp]
  001ac	e8 00 00 00 00	 call	 f32_isSignalingNaN
  001b1	0f b6 c0	 movzx	 eax, al
  001b4	85 c0		 test	 eax, eax
  001b6	74 48		 je	 SHORT $LN17@z900_load_

; 3206 :         {
; 3207 :             if (regs->fpc & FPC_MASK_IMI)

  001b8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001c8	85 c0		 test	 eax, eax
  001ca	74 0e		 je	 SHORT $LN18@z900_load_

; 3208 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  001cc	b2 80		 mov	 dl, 128			; 00000080H
  001ce	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d3	e8 00 00 00 00	 call	 ieee_trap
  001d8	eb 26		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:

; 3209 :             else
; 3210 :             {
; 3211 :                 regs->fpc |= FPC_FLAG_SFI;

  001da	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001df	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e5	0f ba e8 17	 bts	 eax, 23
  001e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ee	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3212 :                 FLOAT32_MAKE_QNAN( op );

  001f4	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001f8	0f ba e8 16	 bts	 eax, 22
  001fc	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN19@z900_load_:
$LN17@z900_load_:
$LN16@z900_load_:
$LN10@z900_load_:

; 3213 :             }
; 3214 :         }
; 3215 :     }
; 3216 : 
; 3217 :     PUT_FLOAT32_CC( op, r1, regs );

  00200	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00204	d1 e0		 shl	 eax, 1
  00206	48 98		 cdqe
  00208	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0020d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00215	48 8b d0	 mov	 rdx, rax
  00218	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  0021d	e8 00 00 00 00	 call	 z900_put_float32
  00222	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00226	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  0022b	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00230	75 17		 jne	 SHORT $LN21@z900_load_
  00232	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00236	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  0023b	85 c0		 test	 eax, eax
  0023d	74 0a		 je	 SHORT $LN21@z900_load_
  0023f	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv193[rsp], 3
  00247	eb 5e		 jmp	 SHORT $LN28@z900_load_
$LN21@z900_load_:
  00249	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0024d	0f ba f0 1f	 btr	 eax, 31
  00251	85 c0		 test	 eax, eax
  00253	75 0a		 jne	 SHORT $LN22@z900_load_
  00255	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  0025d	eb 08		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  0025f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN23@z900_load_:
  00267	83 7c 24 28 00	 cmp	 DWORD PTR tv187[rsp], 0
  0026c	74 0a		 je	 SHORT $LN26@z900_load_
  0026e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
  00276	eb 27		 jmp	 SHORT $LN27@z900_load_
$LN26@z900_load_:
  00278	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0027c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00281	85 c0		 test	 eax, eax
  00283	74 0a		 je	 SHORT $LN24@z900_load_
  00285	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv190[rsp], 1
  0028d	eb 08		 jmp	 SHORT $LN25@z900_load_
$LN24@z900_load_:
  0028f	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv190[rsp], 2
$LN25@z900_load_:
  00297	8b 44 24 2c	 mov	 eax, DWORD PTR tv190[rsp]
  0029b	89 44 24 30	 mov	 DWORD PTR tv192[rsp], eax
$LN27@z900_load_:
  0029f	8b 44 24 30	 mov	 eax, DWORD PTR tv192[rsp]
  002a3	89 44 24 34	 mov	 DWORD PTR tv193[rsp], eax
$LN28@z900_load_:
  002a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  002ac	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv193[rsp]
  002b1	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  002b4	33 c0		 xor	 eax, eax
  002b6	85 c0		 test	 eax, eax
  002b8	0f 85 42 ff ff
	ff		 jne	 $LN10@z900_load_

; 3218 : }

  002be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002c2	c3		 ret	 0
z900_load_and_test_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv187 = 36
tv190 = 40
tv192 = 44
tv193 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
z900_load_and_test_bfp_long_reg PROC

; 3161 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3162 :     int        r1, r2;
; 3163 :     float64_t  op;
; 3164 : 
; 3165 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3166 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_load_
  00073	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_load_
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_load_
  00089	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_load_
  00099	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199872
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_load_

; 3167 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_load_
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_load_
  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00145	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3168 : 
; 3169 :     GET_FLOAT64_OP( op, r2, regs );

  00169	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float64

; 3170 : 
; 3171 :     if (FLOAT64_ISNAN( op ))

  0018b	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00195	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019a	48 23 c8	 and	 rcx, rax
  0019d	48 8b c1	 mov	 rax, rcx
  001a0	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001aa	48 3b c1	 cmp	 rax, rcx
  001ad	0f 85 81 00 00
	00		 jne	 $LN16@z900_load_
  001b3	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  001bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001c2	48 23 c8	 and	 rcx, rax
  001c5	48 8b c1	 mov	 rax, rcx
  001c8	48 85 c0	 test	 rax, rax
  001cb	74 67		 je	 SHORT $LN16@z900_load_

; 3172 :     {
; 3173 :         if (f64_isSignalingNaN( op ))

  001cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d2	e8 00 00 00 00	 call	 f64_isSignalingNaN
  001d7	0f b6 c0	 movzx	 eax, al
  001da	85 c0		 test	 eax, eax
  001dc	74 56		 je	 SHORT $LN17@z900_load_

; 3174 :         {
; 3175 :             if (regs->fpc & FPC_MASK_IMI)

  001de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001e3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001ee	85 c0		 test	 eax, eax
  001f0	74 0e		 je	 SHORT $LN18@z900_load_

; 3176 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  001f2	b2 80		 mov	 dl, 128			; 00000080H
  001f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001f9	e8 00 00 00 00	 call	 ieee_trap
  001fe	eb 34		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:

; 3177 :             else
; 3178 :             {
; 3179 :                 regs->fpc |= FPC_FLAG_SFI;

  00200	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00205	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0020b	0f ba e8 17	 bts	 eax, 23
  0020f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00214	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3180 :                 FLOAT64_MAKE_QNAN( op );

  0021a	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  00224	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00229	48 0b c8	 or	 rcx, rax
  0022c	48 8b c1	 mov	 rax, rcx
  0022f	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN19@z900_load_:
$LN17@z900_load_:
$LN16@z900_load_:
$LN10@z900_load_:

; 3181 :             }
; 3182 :         }
; 3183 :     }
; 3184 : 
; 3185 :     PUT_FLOAT64_CC( op, r1, regs );

  00234	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00238	d1 e0		 shl	 eax, 1
  0023a	48 98		 cdqe
  0023c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00241	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00249	48 8b d0	 mov	 rdx, rax
  0024c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00251	e8 00 00 00 00	 call	 z900_put_float64
  00256	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00260	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00265	48 23 c8	 and	 rcx, rax
  00268	48 8b c1	 mov	 rax, rcx
  0026b	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00275	48 3b c1	 cmp	 rax, rcx
  00278	75 24		 jne	 SHORT $LN21@z900_load_
  0027a	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00284	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00289	48 23 c8	 and	 rcx, rax
  0028c	48 8b c1	 mov	 rax, rcx
  0028f	48 85 c0	 test	 rax, rax
  00292	74 0a		 je	 SHORT $LN21@z900_load_
  00294	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv193[rsp], 3
  0029c	eb 79		 jmp	 SHORT $LN28@z900_load_
$LN21@z900_load_:
  0029e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  002ad	48 23 c8	 and	 rcx, rax
  002b0	48 8b c1	 mov	 rax, rcx
  002b3	48 85 c0	 test	 rax, rax
  002b6	75 0a		 jne	 SHORT $LN22@z900_load_
  002b8	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  002c0	eb 08		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  002c2	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN23@z900_load_:
  002ca	83 7c 24 24 00	 cmp	 DWORD PTR tv187[rsp], 0
  002cf	74 0a		 je	 SHORT $LN26@z900_load_
  002d1	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
  002d9	eb 34		 jmp	 SHORT $LN27@z900_load_
$LN26@z900_load_:
  002db	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  002e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  002ea	48 23 c8	 and	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	48 85 c0	 test	 rax, rax
  002f3	74 0a		 je	 SHORT $LN24@z900_load_
  002f5	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv190[rsp], 1
  002fd	eb 08		 jmp	 SHORT $LN25@z900_load_
$LN24@z900_load_:
  002ff	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv190[rsp], 2
$LN25@z900_load_:
  00307	8b 44 24 28	 mov	 eax, DWORD PTR tv190[rsp]
  0030b	89 44 24 2c	 mov	 DWORD PTR tv192[rsp], eax
$LN27@z900_load_:
  0030f	8b 44 24 2c	 mov	 eax, DWORD PTR tv192[rsp]
  00313	89 44 24 30	 mov	 DWORD PTR tv193[rsp], eax
$LN28@z900_load_:
  00317	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0031c	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv193[rsp]
  00321	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00324	33 c0		 xor	 eax, eax
  00326	85 c0		 test	 eax, eax
  00328	0f 85 06 ff ff
	ff		 jne	 $LN10@z900_load_

; 3186 : }

  0032e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00332	c3		 ret	 0
z900_load_and_test_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv217 = 44
tv222 = 48
tv224 = 52
tv225 = 56
$T2 = 64
op$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
z900_load_and_test_bfp_ext_reg PROC

; 3129 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3130 :     int         r1, r2;
; 3131 :     float128_t  op;
; 3132 : 
; 3133 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00051	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN11@z900_load_
  00074	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 3134 :     TXF_FLOAT_INSTR_CHECK( regs );

  00089	33 c0		 xor	 eax, eax
  0008b	83 f8 01	 cmp	 eax, 1
  0008e	0f 84 81 00 00
	00		 je	 $LN12@z900_load_
  00094	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a3	85 c0		 test	 eax, eax
  000a5	74 6e		 je	 SHORT $LN12@z900_load_
  000a7	33 c0		 xor	 eax, eax
  000a9	85 c0		 test	 eax, eax
  000ab	75 29		 jne	 SHORT $LN13@z900_load_
  000ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000bc	85 c0		 test	 eax, eax
  000be	75 16		 jne	 SHORT $LN13@z900_load_
  000c0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000cf	83 e0 04	 and	 eax, 4
  000d2	85 c0		 test	 eax, eax
  000d4	75 3f		 jne	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  000d6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e4	0f ba e8 0b	 bts	 eax, 11
  000e8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000f6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199841
  000fd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00103	ba 02 00 00 00	 mov	 edx, 2
  00108	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_load_:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 3135 :     BFPINST_CHECK( regs );

  0011f	b8 08 00 00 00	 mov	 eax, 8
  00124	48 6b c0 01	 imul	 rax, rax, 1
  00128	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00138	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0013e	48 85 c0	 test	 rax, rax
  00141	74 42		 je	 SHORT $LN15@z900_load_
  00143	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00151	d1 e8		 shr	 eax, 1
  00153	83 e0 01	 and	 eax, 1
  00156	85 c0		 test	 eax, eax
  00158	74 58		 je	 SHORT $LN14@z900_load_
  0015a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00162	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00169	b9 08 00 00 00	 mov	 ecx, 8
  0016e	48 6b c9 01	 imul	 rcx, rcx, 1
  00172	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00180	48 85 c0	 test	 rax, rax
  00183	75 2d		 jne	 SHORT $LN14@z900_load_
$LN15@z900_load_:
  00185	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00197	ba 07 00 00 00	 mov	 edx, 7
  0019c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_load_:

; 3136 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001b2	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001b6	83 e0 02	 and	 eax, 2
  001b9	85 c0		 test	 eax, eax
  001bb	75 0b		 jne	 SHORT $LN17@z900_load_
  001bd	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001c1	83 e0 02	 and	 eax, 2
  001c4	85 c0		 test	 eax, eax
  001c6	74 1b		 je	 SHORT $LN16@z900_load_
$LN17@z900_load_:
  001c8	ba 06 00 00 00	 mov	 edx, 6
  001cd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_load_:

; 3137 : 
; 3138 :     GET_FLOAT128_OP( op, r2, regs );

  001e3	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001e7	d1 e0		 shl	 eax, 1
  001e9	48 98		 cdqe
  001eb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001fb	48 8b d0	 mov	 rdx, rax
  001fe	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  00203	e8 00 00 00 00	 call	 z900_get_float128

; 3139 : 
; 3140 :     if (FLOAT128_ISNAN( op ))

  00208	b8 08 00 00 00	 mov	 eax, 8
  0020d	48 6b c0 01	 imul	 rax, rax, 1
  00211	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0021b	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  00220	48 23 c1	 and	 rax, rcx
  00223	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0022d	48 3b c1	 cmp	 rax, rcx
  00230	0f 85 ce 00 00
	00		 jne	 $LN18@z900_load_
  00236	b8 08 00 00 00	 mov	 eax, 8
  0023b	48 6b c0 01	 imul	 rax, rax, 1
  0023f	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  00249	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  0024e	48 23 c1	 and	 rax, rcx
  00251	48 85 c0	 test	 rax, rax
  00254	75 15		 jne	 SHORT $LN19@z900_load_
  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 00	 imul	 rax, rax, 0
  0025f	48 83 7c 04 50
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  00265	0f 84 99 00 00
	00		 je	 $LN18@z900_load_
$LN19@z900_load_:

; 3141 :     {
; 3142 :         if (f128_isSignalingNaN( op ))

  0026b	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  00270	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  00275	48 8b f8	 mov	 rdi, rax
  00278	48 8b f1	 mov	 rsi, rcx
  0027b	b9 10 00 00 00	 mov	 ecx, 16
  00280	f3 a4		 rep movsb
  00282	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00287	e8 00 00 00 00	 call	 f128_isSignalingNaN
  0028c	0f b6 c0	 movzx	 eax, al
  0028f	85 c0		 test	 eax, eax
  00291	74 71		 je	 SHORT $LN20@z900_load_

; 3143 :         {
; 3144 :             if (regs->fpc & FPC_MASK_IMI)

  00293	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002a1	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002a6	85 c0		 test	 eax, eax
  002a8	74 11		 je	 SHORT $LN21@z900_load_

; 3145 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  002aa	b2 80		 mov	 dl, 128			; 00000080H
  002ac	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b4	e8 00 00 00 00	 call	 ieee_trap
  002b9	eb 49		 jmp	 SHORT $LN22@z900_load_
$LN21@z900_load_:

; 3146 :             else
; 3147 :             {
; 3148 :                 regs->fpc |= FPC_FLAG_SFI;

  002bb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c9	0f ba e8 17	 bts	 eax, 23
  002cd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d5	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3149 :                 FLOAT128_MAKE_QNAN( op );

  002db	b8 08 00 00 00	 mov	 eax, 8
  002e0	48 6b c0 01	 imul	 rax, rax, 1
  002e4	48 b9 00 00 00
	00 00 80 00 00	 mov	 rcx, 140737488355328	; 0000800000000000H
  002ee	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  002f3	48 0b c1	 or	 rax, rcx
  002f6	b9 08 00 00 00	 mov	 ecx, 8
  002fb	48 6b c9 01	 imul	 rcx, rcx, 1
  002ff	48 89 44 0c 50	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN22@z900_load_:
$LN20@z900_load_:
$LN18@z900_load_:
$LN10@z900_load_:

; 3150 :             }
; 3151 :         }
; 3152 :     }
; 3153 : 
; 3154 :     PUT_FLOAT128_CC( op, r1, regs );

  00304	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00308	d1 e0		 shl	 eax, 1
  0030a	48 98		 cdqe
  0030c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00314	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0031c	48 8b d0	 mov	 rdx, rax
  0031f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  00324	e8 00 00 00 00	 call	 z900_put_float128
  00329	b8 08 00 00 00	 mov	 eax, 8
  0032e	48 6b c0 01	 imul	 rax, rax, 1
  00332	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0033c	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  00341	48 23 c1	 and	 rax, rcx
  00344	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0034e	48 3b c1	 cmp	 rax, rcx
  00351	75 3e		 jne	 SHORT $LN25@z900_load_
  00353	b8 08 00 00 00	 mov	 eax, 8
  00358	48 6b c0 01	 imul	 rax, rax, 1
  0035c	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  00366	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  0036b	48 23 c1	 and	 rax, rcx
  0036e	48 85 c0	 test	 rax, rax
  00371	75 11		 jne	 SHORT $LN24@z900_load_
  00373	b8 08 00 00 00	 mov	 eax, 8
  00378	48 6b c0 00	 imul	 rax, rax, 0
  0037c	48 83 7c 04 50
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  00382	74 0d		 je	 SHORT $LN25@z900_load_
$LN24@z900_load_:
  00384	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv225[rsp], 3
  0038c	e9 93 00 00 00	 jmp	 $LN32@z900_load_
$LN25@z900_load_:
  00391	b8 08 00 00 00	 mov	 eax, 8
  00396	48 6b c0 01	 imul	 rax, rax, 1
  0039a	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  003a4	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  003a9	48 23 c1	 and	 rax, rcx
  003ac	b9 08 00 00 00	 mov	 ecx, 8
  003b1	48 6b c9 00	 imul	 rcx, rcx, 0
  003b5	48 0b 44 0c 50	 or	 rax, QWORD PTR op$[rsp+rcx]
  003ba	48 85 c0	 test	 rax, rax
  003bd	75 0a		 jne	 SHORT $LN26@z900_load_
  003bf	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv217[rsp], 1
  003c7	eb 08		 jmp	 SHORT $LN27@z900_load_
$LN26@z900_load_:
  003c9	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv217[rsp], 0
$LN27@z900_load_:
  003d1	83 7c 24 2c 00	 cmp	 DWORD PTR tv217[rsp], 0
  003d6	74 0a		 je	 SHORT $LN30@z900_load_
  003d8	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv224[rsp], 0
  003e0	eb 3a		 jmp	 SHORT $LN31@z900_load_
$LN30@z900_load_:
  003e2	b8 08 00 00 00	 mov	 eax, 8
  003e7	48 6b c0 01	 imul	 rax, rax, 1
  003eb	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  003f5	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  003fa	48 23 c1	 and	 rax, rcx
  003fd	48 85 c0	 test	 rax, rax
  00400	74 0a		 je	 SHORT $LN28@z900_load_
  00402	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv222[rsp], 1
  0040a	eb 08		 jmp	 SHORT $LN29@z900_load_
$LN28@z900_load_:
  0040c	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv222[rsp], 2
$LN29@z900_load_:
  00414	8b 44 24 30	 mov	 eax, DWORD PTR tv222[rsp]
  00418	89 44 24 34	 mov	 DWORD PTR tv224[rsp], eax
$LN31@z900_load_:
  0041c	8b 44 24 34	 mov	 eax, DWORD PTR tv224[rsp]
  00420	89 44 24 38	 mov	 DWORD PTR tv225[rsp], eax
$LN32@z900_load_:
  00424	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042c	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv225[rsp]
  00431	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00434	33 c0		 xor	 eax, eax
  00436	85 c0		 test	 eax, eax
  00438	0f 85 c6 fe ff
	ff		 jne	 $LN10@z900_load_

; 3155 : }

  0043e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00443	48 33 cc	 xor	 rcx, rsp
  00446	e8 00 00 00 00	 call	 __security_check_cookie
  0044b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0044f	5f		 pop	 rdi
  00450	5e		 pop	 rsi
  00451	c3		 ret	 0
z900_load_and_test_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
quo$ = 36
rem$ = 40
m4$ = 44
op1$ = 48
op2$ = 52
temp$1 = 56
op1_data_class$ = 60
op2_data_class$ = 64
r1$ = 68
r2$ = 72
r3$ = 76
tv210 = 80
ieee_trap_conds$ = 84
intquo64$2 = 88
op164$3 = 96
op264$4 = 104
quo64$5 = 112
rem64$6 = 120
inst$ = 144
regs$ = 152
z900_divide_integer_bfp_short_reg PROC

; 5329 : {

$LN44:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 5330 :     int        r1, r2, r3;
; 5331 :     BYTE       m4, newcc;
; 5332 :     float32_t  op1, op2;
; 5333 :     float32_t  rem, quo;
; 5334 :     U32        ieee_trap_conds = 0;

  00011	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 5335 :     U32        op1_data_class, op2_data_class;
; 5336 : 
; 5337 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00021	e8 00 00 00 00	 call	 fetch_fw_noswap
  00026	8b c8		 mov	 ecx, eax
  00028	e8 00 00 00 00	 call	 _byteswap_ulong
  0002d	89 44 24 38	 mov	 DWORD PTR temp$1[rsp], eax
  00031	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  0003c	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 04	 shr	 eax, 4
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  0004a	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 08	 shr	 eax, 8
  00051	83 e0 0f	 and	 eax, 15
  00054	88 44 24 2c	 mov	 BYTE PTR m4$[rsp], al
  00058	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 0c	 shr	 eax, 12
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 4c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_divid:
  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00072	48 83 c0 04	 add	 rax, 4
  00076	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00082	33 c0		 xor	 eax, eax
  00084	83 f8 04	 cmp	 eax, 4
  00087	74 0f		 je	 SHORT $LN11@z900_divid
  00089	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_divid:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 c8		 jne	 SHORT $LN4@z900_divid
$LN7@z900_divid:

; 5338 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009e	33 c0		 xor	 eax, eax
  000a0	83 f8 01	 cmp	 eax, 1
  000a3	0f 84 81 00 00
	00		 je	 $LN12@z900_divid
  000a9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b8	85 c0		 test	 eax, eax
  000ba	74 6e		 je	 SHORT $LN12@z900_divid
  000bc	33 c0		 xor	 eax, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 29		 jne	 SHORT $LN13@z900_divid
  000c2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000d1	85 c0		 test	 eax, eax
  000d3	75 16		 jne	 SHORT $LN13@z900_divid
  000d5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e4	83 e0 04	 and	 eax, 4
  000e7	85 c0		 test	 eax, eax
  000e9	75 3f		 jne	 SHORT $LN12@z900_divid
$LN13@z900_divid:
  000eb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f9	0f ba e8 0b	 bts	 eax, 11
  000fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0010b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201582
  00112	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00118	ba 02 00 00 00	 mov	 edx, 2
  0011d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_divid:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_divid

; 5339 :     BFPINST_CHECK( regs );

  00134	b8 08 00 00 00	 mov	 eax, 8
  00139	48 6b c0 01	 imul	 rax, rax, 1
  0013d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0014d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00153	48 85 c0	 test	 rax, rax
  00156	74 42		 je	 SHORT $LN15@z900_divid
  00158	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00166	d1 e8		 shr	 eax, 1
  00168	83 e0 01	 and	 eax, 1
  0016b	85 c0		 test	 eax, eax
  0016d	74 58		 je	 SHORT $LN14@z900_divid
  0016f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00177	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017e	b9 08 00 00 00	 mov	 ecx, 8
  00183	48 6b c9 01	 imul	 rcx, rcx, 1
  00187	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00195	48 85 c0	 test	 rax, rax
  00198	75 2d		 jne	 SHORT $LN14@z900_divid
$LN15@z900_divid:
  0019a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a2	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001ac	ba 07 00 00 00	 mov	 edx, 7
  001b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_divid:

; 5340 :     BFPRM_CHECK( m4, regs );

  001c7	0f b6 54 24 2c	 movzx	 edx, BYTE PTR m4$[rsp]
  001cc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 5341 : 
; 5342 :     if (r1 == r2 || r2 == r3 || r1 == r3)

  001d9	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  001dd	39 44 24 44	 cmp	 DWORD PTR r1$[rsp], eax
  001e1	74 14		 je	 SHORT $LN17@z900_divid
  001e3	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  001e7	39 44 24 48	 cmp	 DWORD PTR r2$[rsp], eax
  001eb	74 0a		 je	 SHORT $LN17@z900_divid
  001ed	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  001f1	39 44 24 44	 cmp	 DWORD PTR r1$[rsp], eax
  001f5	75 1b		 jne	 SHORT $LN16@z900_divid
$LN17@z900_divid:

; 5343 :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001f7	ba 06 00 00 00	 mov	 edx, 6
  001fc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_divid:
$LN10@z900_divid:

; 5344 : 
; 5345 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00212	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  00216	d1 e0		 shl	 eax, 1
  00218	48 98		 cdqe
  0021a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00222	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0022a	48 8b d0	 mov	 rdx, rax
  0022d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00232	e8 00 00 00 00	 call	 z900_get_float32
  00237	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  0023b	d1 e0		 shl	 eax, 1
  0023d	48 98		 cdqe
  0023f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00247	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0024f	48 8b d0	 mov	 rdx, rax
  00252	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op2$[rsp]
  00257	e8 00 00 00 00	 call	 z900_get_float32
  0025c	33 c0		 xor	 eax, eax
  0025e	85 c0		 test	 eax, eax
  00260	75 b0		 jne	 SHORT $LN10@z900_divid

; 5346 : 
; 5347 :     op1_data_class = float32_class( op1 );

  00262	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00266	e8 00 00 00 00	 call	 float32_class
  0026b	89 44 24 3c	 mov	 DWORD PTR op1_data_class$[rsp], eax

; 5348 :     op2_data_class = float32_class( op2 );

  0026f	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  00273	e8 00 00 00 00	 call	 float32_class
  00278	89 44 24 40	 mov	 DWORD PTR op2_data_class$[rsp], eax

; 5349 : 
; 5350 :     softfloat_exceptionFlags = 0;

  0027c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00281	8b c0		 mov	 eax, eax
  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00289	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00292	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00296	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5351 : 
; 5352 :     /************************************************************************************/
; 5353 :     /* Following if / else if / else implements a decision tree based on SA-22-7832-10  */
; 5354 :     /* Table 19-21 parts 1 and 2 on pages 19-29 and 19-30 respectively.                 */
; 5355 :     /*                                                                                  */
; 5356 :     /* ORDER OF TESTS IS IMPORTANT                                                      */
; 5357 :     /*                                                                                  */
; 5358 :     /*  1. Tests for cases that include two non-finite non-zeroes.                      */
; 5359 :     /*  2. Tests for cases that include one or two NaNs as input values                 */
; 5360 :     /*  3. Tests for cases that always generate the default quiet NaN                   */
; 5361 :     /*  4. Tests for cases that generate non-NaN results.                               */
; 5362 :     /*                                                                                  */
; 5363 :     /* When viewed from the perspective of Table 19-21, this order:                     */
; 5364 :     /*                                                                                  */
; 5365 :     /*  1. Addresses what is likely to be the most frequent case first                  */
; 5366 :     /*  2. Removes the bottom two rows and the right-hand two columns                   */
; 5367 :     /*  3. Removes the center two colums and the top and new bottom rows                */
; 5368 :     /*  4. Leaves only those cases that involve returning a zero or operand as a result.*/
; 5369 :     /*                                                                                  */
; 5370 :     /************************************************************************************/
; 5371 : 
; 5372 :     /************************************************************************************/
; 5373 :     /* Group 1: Tests for cases with finite non-zeros for both operands.  This is seen  */
; 5374 :     /* as the most frequent case, and should therefore be tested first.                 */
; 5375 :     /************************************************************************************/
; 5376 : 
; 5377 :                                                                     /* Both operands finite numbers?*/
; 5378 :     if ((op1_data_class & (float_class_neg_normal
; 5379 :                          | float_class_pos_normal
; 5380 :                          | float_class_neg_subnormal
; 5381 :                          | float_class_pos_subnormal))
; 5382 :         &&

  0029a	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  0029e	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  002a3	85 c0		 test	 eax, eax
  002a5	0f 84 a5 04 00
	00		 je	 $LN18@z900_divid
  002ab	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  002af	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  002b4	85 c0		 test	 eax, eax
  002b6	0f 84 94 04 00
	00		 je	 $LN18@z900_divid

; 5383 :         (op2_data_class & (float_class_neg_normal
; 5384 :                          | float_class_pos_normal
; 5385 :                          | float_class_neg_subnormal
; 5386 :                          | float_class_pos_subnormal))
; 5387 :     )
; 5388 :     {                                                               /* ..yes, we can do division */
; 5389 : 
; 5390 :         newcc = 0;                                                  /* Initial cc set to zero    */

  002bc	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 5391 :         SET_SF_RM_FROM_MASK( m4 );

  002c1	0f b6 44 24 2c	 movzx	 eax, BYTE PTR m4$[rsp]
  002c6	85 c0		 test	 eax, eax
  002c8	74 16		 je	 SHORT $LN42@z900_divid
  002ca	0f b6 44 24 2c	 movzx	 eax, BYTE PTR m4$[rsp]
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  002d6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002da	89 44 24 50	 mov	 DWORD PTR tv210[rsp], eax
  002de	eb 22		 jmp	 SHORT $LN43@z900_divid
$LN42@z900_divid:
  002e0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ee	83 e0 07	 and	 eax, 7
  002f1	8b c0		 mov	 eax, eax
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002fe	89 44 24 50	 mov	 DWORD PTR tv210[rsp], eax
$LN43@z900_divid:
  00302	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00307	8b c0		 mov	 eax, eax
  00309	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00318	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031c	0f b6 54 24 50	 movzx	 edx, BYTE PTR tv210[rsp]
  00321	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 5392 : 
; 5393 :         quo = f32_div( op1, op2 );                                  /* calculate precise quotient                       */

  00324	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  00328	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  0032c	e8 00 00 00 00	 call	 f32_div
  00331	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5394 :         quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode            */

  00335	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0033a	8b c0		 mov	 eax, eax
  0033c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00342	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0034b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0034f	41 b0 01	 mov	 r8b, 1
  00352	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00356	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0035a	e8 00 00 00 00	 call	 f32_roundToInt
  0035f	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5395 : 
; 5396 :         softfloat_exceptionFlags &= softfloat_flag_overflow;        /* Quotient only cares about overflow               */

  00363	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00368	8b c0		 mov	 eax, eax
  0036a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00370	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00379	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0037d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00381	83 e0 04	 and	 eax, 4
  00384	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0038a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00393	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00399	45 8b c0	 mov	 r8d, r8d
  0039c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003a0	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5397 :         SET_SF_RM_FROM_FPC;                                         /* Set rounding mode from FPC for final remainder   */

  003a4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ac	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003b2	83 e0 07	 and	 eax, 7
  003b5	8b c0		 mov	 eax, eax
  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  003be	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  003c3	8b d2		 mov	 edx, edx
  003c5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  003cc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  003d5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  003d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003dd	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5398 :         quo.v ^= 0x80000000;                                        /* Reverse sign of integer quotient                 */

  003e1	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  003e5	0f ba f8 1f	 btc	 eax, 31
  003e9	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5399 :         rem = f32_mulAdd(quo, op2, op1);                            /* Calculate remainder                              */

  003ed	44 8b 44 24 30	 mov	 r8d, DWORD PTR op1$[rsp]
  003f2	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  003f6	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  003fa	e8 00 00 00 00	 call	 f32_mulAdd
  003ff	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5400 :         quo.v ^= 0x80000000;                                        /* Return sign of integer quotient to original value*/

  00403	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00407	0f ba f8 1f	 btc	 eax, 31
  0040b	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5401 : 
; 5402 :         if (!(rem.v & 0x7fffffff))                                  /* Is remainder zero?                               */

  0040f	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  00413	0f ba f0 1f	 btr	 eax, 31
  00417	85 c0		 test	 eax, eax
  00419	75 17		 jne	 SHORT $LN20@z900_divid

; 5403 :             rem.v = (op1.v & 0x80000000) | (rem.v & 0x7fffffff);    /* ..yes, ensure remainder sign matches dividend    */

  0041b	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  0041f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00424	8b 4c 24 28	 mov	 ecx, DWORD PTR rem$[rsp]
  00428	0f ba f1 1f	 btr	 ecx, 31
  0042c	0b c1		 or	 eax, ecx
  0042e	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
$LN20@z900_divid:

; 5404 : 
; 5405 :         if (!softfloat_exceptionFlags)                              /* If no exceptions, check for partial results      */

  00432	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00437	8b c0		 mov	 eax, eax
  00439	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0043f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00448	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0044c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00450	85 c0		 test	 eax, eax
  00452	0f 85 fb 00 00
	00		 jne	 $LN21@z900_divid

; 5406 :         {
; 5407 :             if (((quo.v & 0x7fffffff) > 0x4B800000) && (rem.v & 0x7fffffff))  /* Quotient > 2^24th & rem <>0?           */

  00458	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0045c	0f ba f0 1f	 btr	 eax, 31
  00460	3d 00 00 80 4b	 cmp	 eax, 1266679808		; 4b800000H
  00465	0f 86 e3 00 00
	00		 jbe	 $LN23@z900_divid
  0046b	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  0046f	0f ba f0 1f	 btr	 eax, 31
  00473	85 c0		 test	 eax, eax
  00475	0f 84 d3 00 00
	00		 je	 $LN23@z900_divid

; 5408 :             {
; 5409 :                 newcc += 2;                                         /* ..yes, indicate partial results in cc            */

  0047b	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  00480	83 c0 02	 add	 eax, 2
  00483	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5410 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  00487	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0048c	8b c0		 mov	 eax, eax
  0048e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00494	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0049d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004a1	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5411 :                                                                     /* ..with rounding toward zero                      */
; 5412 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  004a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  004aa	8b c0		 mov	 eax, eax
  004ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004bf	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5413 : 
; 5414 :                 quo = f32_div( op1, op2 );                          /* calculate precise quotient                       */

  004c3	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  004c7	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  004cb	e8 00 00 00 00	 call	 f32_div
  004d0	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5415 :                 quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  004d4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  004d9	8b c0		 mov	 eax, eax
  004db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004e1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004ea	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004ee	41 b0 01	 mov	 r8b, 1
  004f1	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  004f5	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  004f9	e8 00 00 00 00	 call	 f32_roundToInt
  004fe	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5416 : 
; 5417 :                 quo.v ^= 0x80000000;                                /* Reverse sign of integer quotient                 */

  00502	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00506	0f ba f8 1f	 btc	 eax, 31
  0050a	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5418 : 
; 5419 :                 rem = f32_mulAdd( quo, op2, op1 );                  /* Calculate remainder                              */

  0050e	44 8b 44 24 30	 mov	 r8d, DWORD PTR op1$[rsp]
  00513	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  00517	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0051b	e8 00 00 00 00	 call	 f32_mulAdd
  00520	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5420 : 
; 5421 :                 quo.v ^= 0x80000000;                                /* Return sign of integer quotient to original value*/

  00524	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00528	0f ba f8 1f	 btc	 eax, 31
  0052c	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5422 :                 softfloat_exceptionFlags = 0;                       /* No exceptions or flags on partial results        */

  00530	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00535	8b c0		 mov	 eax, eax
  00537	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0053d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00546	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0054a	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN23@z900_divid:

; 5423 :             }
; 5424 :         }

  0054e	e9 f8 01 00 00	 jmp	 $LN22@z900_divid
$LN21@z900_divid:

; 5425 :         else                                                        /* Exception flagged...we have work to do.          */
; 5426 :         {                                                                                                          
; 5427 :             if (softfloat_exceptionFlags & softfloat_flag_overflow) /* on oveflow, scale result and set cc=1 or 3       */

  00553	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00558	8b c0		 mov	 eax, eax
  0055a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00560	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00569	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0056d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00571	83 e0 04	 and	 eax, 4
  00574	85 c0		 test	 eax, eax
  00576	0f 84 85 01 00
	00		 je	 $LN24@z900_divid

; 5428 :                                                                     /* and recalculate the remainder using a scaled     */
; 5429 :                                                                     /* quotient in 64-bit precision                     */
; 5430 :                                                                     /* Note that there is no fractional part to the     */
; 5431 :                                                                     /* quotient when the quotient overflows             */
; 5432 :             {
; 5433 :                 float64_t  quo64, intquo64, rem64;
; 5434 :                 float64_t  op164, op264;
; 5435 : 
; 5436 :                 newcc += 1;                                         /* Set condition code odd for quotient overflow     */

  0057c	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  00581	ff c0		 inc	 eax
  00583	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5437 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  00587	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0058c	8b c0		 mov	 eax, eax
  0058e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00594	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0059d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005a1	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5438 :                                                                     /* ..with rounding toward zero                      */
; 5439 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  005a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  005aa	8b c0		 mov	 eax, eax
  005ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005bf	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5440 : 
; 5441 :                 quo = f32_div( op1, op2 );                          /* calculate precise quotient                       */

  005c3	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  005c7	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  005cb	e8 00 00 00 00	 call	 f32_div
  005d0	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5442 :                 quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE ); /* Partial result, round to zero             */

  005d4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  005d9	8b c0		 mov	 eax, eax
  005db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005e1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005ea	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005ee	41 b0 01	 mov	 r8b, 1
  005f1	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  005f5	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  005f9	e8 00 00 00 00	 call	 f32_roundToInt
  005fe	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5443 :                 quo = f32_scaledResult( SCALE_FACTOR_ARITH_OFLOW_SHORT );  /* Scale quotient                            */

  00602	b9 40 ff ff ff	 mov	 ecx, -192		; ffffffffffffff40H
  00607	e8 00 00 00 00	 call	 f32_scaledResult
  0060c	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5444 : 
; 5445 :                 op164 = f32_to_f64( op1 );

  00610	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00614	e8 00 00 00 00	 call	 f32_to_f64
  00619	48 89 44 24 60	 mov	 QWORD PTR op164$3[rsp], rax

; 5446 :                 op264 = f32_to_f64( op2 );

  0061e	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  00622	e8 00 00 00 00	 call	 f32_to_f64
  00627	48 89 44 24 68	 mov	 QWORD PTR op264$4[rsp], rax

; 5447 : 
; 5448 :                 softfloat_roundingMode = softfloat_round_minMag;

  0062c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00631	8b c0		 mov	 eax, eax
  00633	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00639	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00642	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00646	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5449 : 
; 5450 :                 quo64 = f64_div( op164, op264 );

  0064a	48 8b 54 24 68	 mov	 rdx, QWORD PTR op264$4[rsp]
  0064f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op164$3[rsp]
  00654	e8 00 00 00 00	 call	 f64_div
  00659	48 89 44 24 70	 mov	 QWORD PTR quo64$5[rsp], rax

; 5451 : 
; 5452 :                 intquo64.v = quo64.v & 0xFFFFFFFFE0000000ULL;       /* Truncate significand to BFP Short bits           */

  0065e	48 8b 44 24 70	 mov	 rax, QWORD PTR quo64$5[rsp]
  00663	48 25 00 00 00
	e0		 and	 rax, -536870912		; ffffffffe0000000H
  00669	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5453 :                 intquo64.v ^= 0x8000000000000000ULL;                /* flip sign of dividend for fused multiply-add     */

  0066e	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00678	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  0067d	48 33 c8	 xor	 rcx, rax
  00680	48 8b c1	 mov	 rax, rcx
  00683	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5454 : 
; 5455 :                 rem64 = f64_mulAdd( intquo64, op264, op164 );       /* -rem = intquo * divisor + (-dividend)            */

  00688	4c 8b 44 24 60	 mov	 r8, QWORD PTR op164$3[rsp]
  0068d	48 8b 54 24 68	 mov	 rdx, QWORD PTR op264$4[rsp]
  00692	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  00697	e8 00 00 00 00	 call	 f64_mulAdd
  0069c	48 89 44 24 78	 mov	 QWORD PTR rem64$6[rsp], rax

; 5456 : 
; 5457 :                 intquo64.v ^= 0x8000000000000000ULL;                /* Restore sign of dividend                         */

  006a1	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  006ab	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  006b0	48 33 c8	 xor	 rcx, rax
  006b3	48 8b c1	 mov	 rax, rcx
  006b6	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5458 :                 softfloat_exceptionFlags = 0;                       /* clear any prior Softfloat flags                  */

  006bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  006c0	8b c0		 mov	 eax, eax
  006c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  006c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  006d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  006d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5459 : 
; 5460 :                 rem = f64_to_f32( rem64 );                          /* should be exact!?)                               */

  006d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rem64$6[rsp]
  006de	e8 00 00 00 00	 call	 f64_to_f32
  006e3	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5461 : 
; 5462 :                 if (rem.v & 0x7fffffff)                             /* non-zero remainder?                              */

  006e7	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  006eb	0f ba f0 1f	 btr	 eax, 31
  006ef	85 c0		 test	 eax, eax
  006f1	74 0c		 je	 SHORT $LN26@z900_divid

; 5463 :                     newcc += 2;                                     /* yes, indicate partial results                    */

  006f3	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  006f8	83 c0 02	 add	 eax, 2
  006fb	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al
$LN26@z900_divid:

; 5464 :             }

  006ff	eb 4a		 jmp	 SHORT $LN25@z900_divid
$LN24@z900_divid:

; 5465 :             else if (softfloat_exceptionFlags & (softfloat_flag_tiny | softfloat_flag_underflow))

  00701	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00706	8b c0		 mov	 eax, eax
  00708	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0070e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00717	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0071b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0071f	83 e0 42	 and	 eax, 66			; 00000042H
  00722	85 c0		 test	 eax, eax
  00724	74 25		 je	 SHORT $LN27@z900_divid

; 5466 :             {
; 5467 :                 /* Inexact and underflow'ed remainder issues and traps are handled by code at the end of Divide To Integer  */
; 5468 :                 /* But because this is the only situation where the remainder might need scaling, we will do it here        */
; 5469 :                 if (regs->fpc & FPC_MASK_IMU)

  00726	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00734	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00739	85 c0		 test	 eax, eax
  0073b	74 0e		 je	 SHORT $LN28@z900_divid

; 5470 :                     rem = f32_scaledResult(SCALE_FACTOR_ARITH_UFLOW_SHORT);

  0073d	b9 c0 00 00 00	 mov	 ecx, 192		; 000000c0H
  00742	e8 00 00 00 00	 call	 f32_scaledResult
  00747	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
$LN28@z900_divid:
$LN27@z900_divid:
$LN25@z900_divid:
$LN22@z900_divid:

; 5471 :             }
; 5472 :         }
; 5473 :     }

  0074b	e9 c2 01 00 00	 jmp	 $LN19@z900_divid
$LN18@z900_divid:

; 5474 : 
; 5475 :     /************************************************************************************/
; 5476 :     /* Group 2: tests for cases with NaNs for one or both operands                      */
; 5477 :     /* The sequence is required to ensure that the generated results match the IBM NaN  */
; 5478 :     /* propagation rules shown in Table 19-21                                           */
; 5479 :     /************************************************************************************/
; 5480 : 
; 5481 :     /* ******* NEXT FOUR TESTS, ALL GROUP 2 TESTS, MUST REMAIN IN SEQUENCE *******      */
; 5482 :     else if (op1_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* first case: op1 an SNaN?  */

  00750	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00754	83 e0 03	 and	 eax, 3
  00757	85 c0		 test	 eax, eax
  00759	74 67		 je	 SHORT $LN29@z900_divid

; 5483 :     {
; 5484 :         quo = op1;

  0075b	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  0075f	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5485 :         FLOAT32_MAKE_QNAN( quo );

  00763	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00767	0f ba e8 16	 bts	 eax, 22
  0076b	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5486 :         rem = quo;

  0076f	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00773	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5487 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  00777	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0077c	8b c0		 mov	 eax, eax
  0077e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00784	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0078d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00791	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00795	83 c8 10	 or	 eax, 16
  00798	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0079e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  007a7	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  007ad	45 8b c0	 mov	 r8d, r8d
  007b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  007b4	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5488 :         newcc = 1;                                                                               /* Any NaN returns cc=1      */

  007b8	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5489 :     }

  007bd	e9 50 01 00 00	 jmp	 $LN30@z900_divid
$LN29@z900_divid:

; 5490 :     else if (op2_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* second case: op2 an SNaN? */

  007c2	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  007c6	83 e0 03	 and	 eax, 3
  007c9	85 c0		 test	 eax, eax
  007cb	74 67		 je	 SHORT $LN31@z900_divid

; 5491 :     {
; 5492 :         quo = op2;

  007cd	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  007d1	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5493 :         FLOAT32_MAKE_QNAN( quo );

  007d5	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  007d9	0f ba e8 16	 bts	 eax, 22
  007dd	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5494 :         rem = quo;

  007e1	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  007e5	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5495 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  007e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  007ee	8b c0		 mov	 eax, eax
  007f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  007f6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  007ff	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00803	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00807	83 c8 10	 or	 eax, 16
  0080a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00810	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00819	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0081f	45 8b c0	 mov	 r8d, r8d
  00822	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00826	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5496 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  0082a	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5497 :     }

  0082f	e9 de 00 00 00	 jmp	 $LN32@z900_divid
$LN31@z900_divid:

; 5498 :     else if (op1_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* third case: op1 a QNaN?    */

  00834	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00838	83 e0 0c	 and	 eax, 12
  0083b	85 c0		 test	 eax, eax
  0083d	74 1a		 je	 SHORT $LN33@z900_divid

; 5499 :     {
; 5500 :         rem = quo = op1;

  0083f	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00843	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax
  00847	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0084b	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5501 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  0084f	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5502 :     }

  00854	e9 b9 00 00 00	 jmp	 $LN34@z900_divid
$LN33@z900_divid:

; 5503 :     else if (op2_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* fourth case: op2 a QNaN?   */

  00859	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  0085d	83 e0 0c	 and	 eax, 12
  00860	85 c0		 test	 eax, eax
  00862	74 1a		 je	 SHORT $LN35@z900_divid

; 5504 :     {
; 5505 :         rem = quo = op2;

  00864	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  00868	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax
  0086c	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00870	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5506 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00874	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5507 :     }

  00879	e9 94 00 00 00	 jmp	 $LN36@z900_divid
$LN35@z900_divid:

; 5508 :     /* END OF FOUR TESTS THAT MUST REMAIN IN SEQUENCE                                   */
; 5509 : 
; 5510 :     /************************************************************************************/
; 5511 :     /* NEXT TEST MUST FOLLOW ALL FOUR NAN TESTS                                         */
; 5512 :     /* Group 3: Test cases that generate the default NaN and IEEE exception Invalid     */
; 5513 :     /* If operand 1 is an infinity OR operand two is a zero, and none of the above      */
; 5514 :     /* conditions are met, i.e., neither operand is a NaN, return a default NaN         */
; 5515 :     /************************************************************************************/
; 5516 : 
; 5517 :     else if ((op1_data_class & (float_class_neg_infinity | float_class_pos_infinity))           /* Operand 1 an infinity?     */
; 5518 :          ||  (op2_data_class & (float_class_neg_zero     | float_class_pos_zero))               /* ..or operand 2 a zero?     */

  0087e	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00882	83 e0 30	 and	 eax, 48			; 00000030H
  00885	85 c0		 test	 eax, eax
  00887	75 0d		 jne	 SHORT $LN39@z900_divid
  00889	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  0088d	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00892	85 c0		 test	 eax, eax
  00894	74 5a		 je	 SHORT $LN37@z900_divid
$LN39@z900_divid:

; 5519 :     )
; 5520 :     {                                                                                           /* ..yes, return DNaN, raise invalid  */
; 5521 :         quo = rem = float32_default_qnan;

  00896	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR float32_default_qnan
  0089c	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
  008a0	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  008a4	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5522 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  008a8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  008ad	8b c0		 mov	 eax, eax
  008af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  008b5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  008be	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  008c2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008c6	83 c8 10	 or	 eax, 16
  008c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  008cf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  008d8	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  008de	45 8b c0	 mov	 r8d, r8d
  008e1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  008e5	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5523 :         newcc = 1;

  008e9	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5524 :     }

  008ee	eb 22		 jmp	 SHORT $LN38@z900_divid
$LN37@z900_divid:

; 5525 :     /* ABOVE TEST MUST IMMEDIATELY FOLLOW ALL FOUR NAN TESTS                            */
; 5526 : 
; 5527 :     /************************************************************************************/
; 5528 :     /* Group 4: Tests for cases that generate zero or an operand value as a result.     */
; 5529 :     /*                                                                                  */
; 5530 :     /* At this point, only the remaining operand combinations remain:                   */
; 5531 :     /* - Operand 1 is zero and operand 2 is non-zero (either finite or infinity)        */
; 5532 :     /* - Operand 1 is finite and operand 2 is infinity                                  */
; 5533 :     /*                                                                                  */
; 5534 :     /* The result is the same for each of the above: Operand 1 becomes the remainder,   */
; 5535 :     /* and the quotient is zero with a signed determined by the signs of the operands.  */
; 5536 :     /* Exclusive Or sets the sign correctly.                                            */
; 5537 :     /************************************************************************************/
; 5538 :     else
; 5539 :     {
; 5540 :         rem = op1;                                          /* remainder is operand 1                       */

  008f0	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  008f4	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5541 :         quo.v = (op1.v ^ op2.v) & 0x80000000;               /* quotient zero, sign is exclusive or of operand signs   */

  008f8	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  008fc	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00900	33 c8		 xor	 ecx, eax
  00902	8b c1		 mov	 eax, ecx
  00904	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00909	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5542 :         newcc = 0;

  0090d	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0
$LN38@z900_divid:
$LN36@z900_divid:
$LN34@z900_divid:
$LN32@z900_divid:
$LN30@z900_divid:
$LN19@z900_divid:

; 5543 :     }
; 5544 : 
; 5545 :     IEEE_EXCEPTION_TRAP_XI( regs );                         /* IEEE Invalid Exception raised and trappable?         */

  00912	33 c0		 xor	 eax, eax
  00914	83 f8 01	 cmp	 eax, 1
  00917	74 4b		 je	 SHORT $LN40@z900_divid
  00919	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0091e	8b c0		 mov	 eax, eax
  00920	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00926	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0092f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00933	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00937	83 e0 10	 and	 eax, 16
  0093a	85 c0		 test	 eax, eax
  0093c	74 26		 je	 SHORT $LN40@z900_divid
  0093e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00946	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0094c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00951	85 c0		 test	 eax, eax
  00953	74 0f		 je	 SHORT $LN40@z900_divid
  00955	b2 80		 mov	 dl, 128			; 00000080H
  00957	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0095f	e8 00 00 00 00	 call	 ieee_trap
$LN40@z900_divid:

; 5546 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00964	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0096c	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00971	89 44 24 54	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5547 : 
; 5548 :     /* *********** Underflow flag means remainder underflowed.  It has already been scaled if necessary             */
; 5549 : 
; 5550 :     regs->psw.cc = newcc;

  00975	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0097d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00982	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5551 : 
; 5552 :     PUT_FLOAT32_NOCC( rem, r1, regs );

  00985	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  00989	d1 e0		 shl	 eax, 1
  0098b	48 98		 cdqe
  0098d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00995	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0099d	48 8b d0	 mov	 rdx, rax
  009a0	48 8d 4c 24 28	 lea	 rcx, QWORD PTR rem$[rsp]
  009a5	e8 00 00 00 00	 call	 z900_put_float32

; 5553 :     PUT_FLOAT32_NOCC( quo, r3, regs );

  009aa	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  009ae	d1 e0		 shl	 eax, 1
  009b0	48 98		 cdqe
  009b2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ba	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  009c2	48 8b d0	 mov	 rdx, rax
  009c5	48 8d 4c 24 24	 lea	 rcx, QWORD PTR quo$[rsp]
  009ca	e8 00 00 00 00	 call	 z900_put_float32

; 5554 : 
; 5555 :     ieee_cond_trap( regs, ieee_trap_conds );

  009cf	8b 54 24 54	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  009d3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009db	e8 00 00 00 00	 call	 ieee_cond_trap

; 5556 : }

  009e0	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  009e7	c3		 ret	 0
z900_divide_integer_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
quo$ = 40
m4$ = 48
rem$ = 56
op1$ = 64
op2$ = 72
temp$1 = 80
op1_data_class$ = 84
op2_data_class$ = 88
r1$ = 92
r2$ = 96
r3$ = 100
tv210 = 104
ieee_trap_conds$ = 108
$T2 = 112
$T3 = 128
$T4 = 144
$T5 = 160
$T6 = 176
$T7 = 192
$T8 = 208
$T9 = 224
$T10 = 240
$T11 = 256
$T12 = 272
$T13 = 288
intquo128$14 = 304
quo128$15 = 320
op1128$16 = 336
op2128$17 = 352
rem128$18 = 368
__$ArrayPad$ = 384
inst$ = 432
regs$ = 440
z900_divide_integer_bfp_long_reg PROC

; 5099 : {

$LN44:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5100 :     int        r1, r2, r3;
; 5101 :     BYTE       m4, newcc;
; 5102 :     float64_t  op1, op2;
; 5103 :     float64_t  quo, rem;
; 5104 :     U32        ieee_trap_conds = 0;

  00025	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 5105 :     U32        op1_data_class, op2_data_class;
; 5106 : 
; 5107 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  0002d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 60	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 5c	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 30	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	89 44 24 64	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_divid:
  0007a	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN11@z900_divid
  0009d	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_divid:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@z900_divid
$LN7@z900_divid:

; 5108 :     TXF_FLOAT_INSTR_CHECK( regs );

  000b2	33 c0		 xor	 eax, eax
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	0f 84 81 00 00
	00		 je	 $LN12@z900_divid
  000bd	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000cc	85 c0		 test	 eax, eax
  000ce	74 6e		 je	 SHORT $LN12@z900_divid
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 29		 jne	 SHORT $LN13@z900_divid
  000d6	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000e5	85 c0		 test	 eax, eax
  000e7	75 16		 jne	 SHORT $LN13@z900_divid
  000e9	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000f8	83 e0 04	 and	 eax, 4
  000fb	85 c0		 test	 eax, eax
  000fd	75 3f		 jne	 SHORT $LN12@z900_divid
$LN13@z900_divid:
  000ff	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010d	0f ba e8 0b	 bts	 eax, 11
  00111	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG201519
  00126	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012c	ba 02 00 00 00	 mov	 edx, 2
  00131	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_divid:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_divid

; 5109 :     BFPINST_CHECK( regs );

  00148	b8 08 00 00 00	 mov	 eax, 8
  0014d	48 6b c0 01	 imul	 rax, rax, 1
  00151	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00161	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00167	48 85 c0	 test	 rax, rax
  0016a	74 42		 je	 SHORT $LN15@z900_divid
  0016c	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017a	d1 e8		 shr	 eax, 1
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 58		 je	 SHORT $LN14@z900_divid
  00183	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00192	b9 08 00 00 00	 mov	 ecx, 8
  00197	48 6b c9 01	 imul	 rcx, rcx, 1
  0019b	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001a3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a9	48 85 c0	 test	 rax, rax
  001ac	75 2d		 jne	 SHORT $LN14@z900_divid
$LN15@z900_divid:
  001ae	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001c0	ba 07 00 00 00	 mov	 edx, 7
  001c5	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_divid:

; 5110 :     BFPRM_CHECK( m4,regs );

  001db	0f b6 54 24 30	 movzx	 edx, BYTE PTR m4$[rsp]
  001e0	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e8	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 5111 : 
; 5112 :     if (r1 == r2 || r2 == r3 || r1 == r3)

  001ed	8b 44 24 60	 mov	 eax, DWORD PTR r2$[rsp]
  001f1	39 44 24 5c	 cmp	 DWORD PTR r1$[rsp], eax
  001f5	74 14		 je	 SHORT $LN17@z900_divid
  001f7	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  001fb	39 44 24 60	 cmp	 DWORD PTR r2$[rsp], eax
  001ff	74 0a		 je	 SHORT $LN17@z900_divid
  00201	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  00205	39 44 24 5c	 cmp	 DWORD PTR r1$[rsp], eax
  00209	75 1b		 jne	 SHORT $LN16@z900_divid
$LN17@z900_divid:

; 5113 :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0020b	ba 06 00 00 00	 mov	 edx, 6
  00210	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00220	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_divid:
$LN10@z900_divid:

; 5114 : 
; 5115 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00226	8b 44 24 5c	 mov	 eax, DWORD PTR r1$[rsp]
  0022a	d1 e0		 shl	 eax, 1
  0022c	48 98		 cdqe
  0022e	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00236	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0023e	48 8b d0	 mov	 rdx, rax
  00241	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00246	e8 00 00 00 00	 call	 z900_get_float64
  0024b	8b 44 24 60	 mov	 eax, DWORD PTR r2$[rsp]
  0024f	d1 e0		 shl	 eax, 1
  00251	48 98		 cdqe
  00253	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00263	48 8b d0	 mov	 rdx, rax
  00266	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  0026b	e8 00 00 00 00	 call	 z900_get_float64
  00270	33 c0		 xor	 eax, eax
  00272	85 c0		 test	 eax, eax
  00274	75 b0		 jne	 SHORT $LN10@z900_divid

; 5116 : 
; 5117 :     op1_data_class = float64_class( op1 );

  00276	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0027b	e8 00 00 00 00	 call	 float64_class
  00280	89 44 24 54	 mov	 DWORD PTR op1_data_class$[rsp], eax

; 5118 :     op2_data_class = float64_class( op2 );

  00284	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00289	e8 00 00 00 00	 call	 float64_class
  0028e	89 44 24 58	 mov	 DWORD PTR op2_data_class$[rsp], eax

; 5119 : 
; 5120 :     softfloat_exceptionFlags = 0;

  00292	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00297	8b c0		 mov	 eax, eax
  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ac	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5121 : 
; 5122 :     /************************************************************************************/
; 5123 :     /* Following if / else if / else implements a decision tree based on SA-22-7832-10  */
; 5124 :     /* Table 19-21 parts 1 and 2 on pages 19-29 and 19-30 respectively.                 */
; 5125 :     /*                                                                                  */
; 5126 :     /* ORDER OF TESTS IS IMPORTANT                                                      */
; 5127 :     /*                                                                                  */
; 5128 :     /*  1. Tests for cases that include two non-finite non-zeroes.                      */
; 5129 :     /*  2. Tests for cases that include one or two NaNs as input values                 */
; 5130 :     /*  3. Tests for cases that always generate the default quiet NaN                   */
; 5131 :     /*  4. Tests for cases that generate non-NaN results.                               */
; 5132 :     /*                                                                                  */
; 5133 :     /* When viewed from the perspective of Table 19-21, this order:                     */
; 5134 :     /*                                                                                  */
; 5135 :     /*  1. Addresses what is likely to be the most frequent case first                  */
; 5136 :     /*  2. Removes the bottom two rows and the right-hand two columns                   */
; 5137 :     /*  3. Removes the center two colums and the top and new bottom rows                */
; 5138 :     /*  4. Leaves only those cases that involve returning a zero or operand as a result.*/
; 5139 :     /*                                                                                  */
; 5140 :     /************************************************************************************/
; 5141 : 
; 5142 :     /************************************************************************************/
; 5143 :     /* Group 1: Tests for cases with finite non-zeros for both operands.  This is seen  */
; 5144 :     /* as the most frequent case, and should therefore be tested first.                 */
; 5145 :     /************************************************************************************/
; 5146 : 
; 5147 :                                                                     /* Both operands finite numbers?*/
; 5148 :     if ((op1_data_class & (float_class_neg_normal
; 5149 :                          | float_class_pos_normal
; 5150 :                          | float_class_neg_subnormal
; 5151 :                          | float_class_pos_subnormal))
; 5152 :         &&

  002b0	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  002b4	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  002b9	85 c0		 test	 eax, eax
  002bb	0f 84 1f 07 00
	00		 je	 $LN18@z900_divid
  002c1	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  002c5	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  002ca	85 c0		 test	 eax, eax
  002cc	0f 84 0e 07 00
	00		 je	 $LN18@z900_divid

; 5153 :         (op2_data_class & (float_class_neg_normal
; 5154 :                          | float_class_pos_normal
; 5155 :                          | float_class_neg_subnormal
; 5156 :                          | float_class_pos_subnormal))
; 5157 :     )
; 5158 :     {                                                               /* ..yes, we can do division */
; 5159 :         newcc = 0;                                                  /* Initial cc set to zero    */

  002d2	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 5160 :         SET_SF_RM_FROM_MASK( m4 );

  002d7	0f b6 44 24 30	 movzx	 eax, BYTE PTR m4$[rsp]
  002dc	85 c0		 test	 eax, eax
  002de	74 16		 je	 SHORT $LN42@z900_divid
  002e0	0f b6 44 24 30	 movzx	 eax, BYTE PTR m4$[rsp]
  002e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  002ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f0	89 44 24 68	 mov	 DWORD PTR tv210[rsp], eax
  002f4	eb 22		 jmp	 SHORT $LN43@z900_divid
$LN42@z900_divid:
  002f6	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fe	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00304	83 e0 07	 and	 eax, 7
  00307	8b c0		 mov	 eax, eax
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00310	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00314	89 44 24 68	 mov	 DWORD PTR tv210[rsp], eax
$LN43@z900_divid:
  00318	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0031d	8b c0		 mov	 eax, eax
  0031f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00325	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0032e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00332	0f b6 54 24 68	 movzx	 edx, BYTE PTR tv210[rsp]
  00337	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 5161 : 
; 5162 :         quo = f64_div( op1, op2 );                                  /* calculate precise quotient                       */

  0033a	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  0033f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00344	e8 00 00 00 00	 call	 f64_div
  00349	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5163 :         quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode            */

  0034e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00353	8b c0		 mov	 eax, eax
  00355	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0035b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00364	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00368	41 b0 01	 mov	 r8b, 1
  0036b	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0036f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00374	e8 00 00 00 00	 call	 f64_roundToInt
  00379	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5164 : 
; 5165 :         softfloat_exceptionFlags &= softfloat_flag_overflow;        /* Quotient only cares about overflow               */

  0037e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00383	8b c0		 mov	 eax, eax
  00385	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0038b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00394	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00398	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039c	83 e0 04	 and	 eax, 4
  0039f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003ae	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  003b4	45 8b c0	 mov	 r8d, r8d
  003b7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003bb	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5166 :         SET_SF_RM_FROM_FPC;                                         /* Set rounding mode from FPC for final remainder   */

  003bf	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003cd	83 e0 07	 and	 eax, 7
  003d0	8b c0		 mov	 eax, eax
  003d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  003d9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  003de	8b d2		 mov	 edx, edx
  003e0	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  003e7	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  003f0	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  003f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003f8	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5167 :         quo.v ^= 0x8000000000000000ULL;                             /* Reverse sign of integer quotient                 */

  003fc	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00406	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0040b	48 33 c8	 xor	 rcx, rax
  0040e	48 8b c1	 mov	 rax, rcx
  00411	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5168 :         rem = f64_mulAdd( quo, op2, op1 );                          /* Calculate remainder                              */

  00416	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  0041b	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00420	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00425	e8 00 00 00 00	 call	 f64_mulAdd
  0042a	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5169 :         quo.v ^= 0x8000000000000000ULL;                             /* Return sign of integer quotient to original value*/

  0042f	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00439	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0043e	48 33 c8	 xor	 rcx, rax
  00441	48 8b c1	 mov	 rax, rcx
  00444	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5170 : 
; 5171 :         if (!(rem.v & 0x7fffffffffffffffULL))                       /* Is remainder zero?                               */

  00449	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00453	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  00458	48 23 c8	 and	 rcx, rax
  0045b	48 8b c1	 mov	 rax, rcx
  0045e	48 85 c0	 test	 rax, rax
  00461	75 32		 jne	 SHORT $LN20@z900_divid

; 5172 :             rem.v = (op1.v & 0x8000000000000000ULL) | (rem.v & 0x7fffffffffffffffULL);

  00463	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0046d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00472	48 23 c8	 and	 rcx, rax
  00475	48 8b c1	 mov	 rax, rcx
  00478	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00482	48 8b 54 24 38	 mov	 rdx, QWORD PTR rem$[rsp]
  00487	48 23 d1	 and	 rdx, rcx
  0048a	48 8b ca	 mov	 rcx, rdx
  0048d	48 0b c1	 or	 rax, rcx
  00490	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
$LN20@z900_divid:

; 5173 :                                                                     /* ..yes, ensure remainder sign matches dividend    */
; 5174 :         if (!softfloat_exceptionFlags)                              /* If no exceptions, check for partial results      */

  00495	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0049a	8b c0		 mov	 eax, eax
  0049c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004a2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004ab	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004af	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004b3	85 c0		 test	 eax, eax
  004b5	0f 85 42 01 00
	00		 jne	 $LN21@z900_divid

; 5175 :         {
; 5176 :             if (((quo.v & 0x7fffffffffffffffULL) > 0x4340000000000000ULL) && (rem.v & 0x7fffffffffffffffULL))

  004bb	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  004c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  004ca	48 23 c8	 and	 rcx, rax
  004cd	48 8b c1	 mov	 rax, rcx
  004d0	48 b9 00 00 00
	00 00 00 40 43	 mov	 rcx, 4845873199050653696 ; 4340000000000000H
  004da	48 3b c1	 cmp	 rax, rcx
  004dd	0f 86 15 01 00
	00		 jbe	 $LN23@z900_divid
  004e3	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  004ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  004f2	48 23 c8	 and	 rcx, rax
  004f5	48 8b c1	 mov	 rax, rcx
  004f8	48 85 c0	 test	 rax, rax
  004fb	0f 84 f7 00 00
	00		 je	 $LN23@z900_divid

; 5177 :             {                                                       /* Quotient > 2^24th & rem <>0?                     */
; 5178 :                 newcc += 2;                                         /* ..yes, indicate partial results in cc            */

  00501	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  00506	83 c0 02	 add	 eax, 2
  00509	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5179 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  0050d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00512	8b c0		 mov	 eax, eax
  00514	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0051a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00523	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00527	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5180 :                                                                     /* ..with rounding toward zero                      */
; 5181 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  0052b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00530	8b c0		 mov	 eax, eax
  00532	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00538	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00541	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00545	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5182 : 
; 5183 :                 quo = f64_div( op1, op2 );                          /* calculate precise quotient                       */

  00549	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  0054e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00553	e8 00 00 00 00	 call	 f64_div
  00558	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5184 :                 quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  0055d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00562	8b c0		 mov	 eax, eax
  00564	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0056a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00573	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00577	41 b0 01	 mov	 r8b, 1
  0057a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0057e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00583	e8 00 00 00 00	 call	 f64_roundToInt
  00588	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5185 : 
; 5186 :                 quo.v ^= 0x8000000000000000ULL;                     /* Reverse sign of integer quotient                 */

  0058d	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00597	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0059c	48 33 c8	 xor	 rcx, rax
  0059f	48 8b c1	 mov	 rax, rcx
  005a2	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5187 :                 rem = f64_mulAdd( quo, op2, op1 );                  /* Calculate remainder                              */

  005a7	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  005ac	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  005b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  005b6	e8 00 00 00 00	 call	 f64_mulAdd
  005bb	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5188 :                 quo.v ^= 0x8000000000000000ULL;                     /* Return sign of integer quotient to original value*/

  005c0	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  005ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  005cf	48 33 c8	 xor	 rcx, rax
  005d2	48 8b c1	 mov	 rax, rcx
  005d5	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5189 :                 softfloat_exceptionFlags = 0;                       /* No exceptions or flags on partial results        */

  005da	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  005df	8b c0		 mov	 eax, eax
  005e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005e7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005f0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005f4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN23@z900_divid:

; 5190 :             }
; 5191 :         }

  005f8	e9 de 03 00 00	 jmp	 $LN22@z900_divid
$LN21@z900_divid:

; 5192 :         else                                                        /* Exception flagged...we have work to do.          */
; 5193 :         {
; 5194 :             if (softfloat_exceptionFlags & softfloat_flag_overflow) /* on oveflow, scale result and set cc=1 or 3       */

  005fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00602	8b c0		 mov	 eax, eax
  00604	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0060a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00613	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00617	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0061b	83 e0 04	 and	 eax, 4
  0061e	85 c0		 test	 eax, eax
  00620	0f 84 6a 03 00
	00		 je	 $LN24@z900_divid

; 5195 :                                                                     /* and recalculate the remainder using a scaled     */
; 5196 :                                                                     /* quotient in 64-bit precision                     */
; 5197 :             {
; 5198 :                 float128_t  quo128, intquo128, rem128;
; 5199 :                 float128_t  op1128, op2128;
; 5200 : 
; 5201 :                 newcc += 1;                                         /* Set condition code odd for quotient overflow     */

  00626	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  0062b	ff c0		 inc	 eax
  0062d	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5202 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  00631	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00636	8b c0		 mov	 eax, eax
  00638	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0063e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00647	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0064b	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5203 :                                                                     /* ..with rounding toward zero                      */
; 5204 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  0064f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00654	8b c0		 mov	 eax, eax
  00656	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0065c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00665	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00669	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5205 : 
; 5206 :                 quo = f64_div( op1, op2 );                          /* calculate precise quotient                       */

  0066d	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00672	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00677	e8 00 00 00 00	 call	 f64_div
  0067c	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5207 :                 quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  00681	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00686	8b c0		 mov	 eax, eax
  00688	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0068e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00697	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0069b	41 b0 01	 mov	 r8b, 1
  0069e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  006a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  006a7	e8 00 00 00 00	 call	 f64_roundToInt
  006ac	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5208 :                 quo = f64_scaledResult( SCALE_FACTOR_ARITH_OFLOW_LONG );

  006b1	b9 00 fa ff ff	 mov	 ecx, -1536		; fffffffffffffa00H
  006b6	e8 00 00 00 00	 call	 f64_scaledResult
  006bb	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5209 : 
; 5210 :                 op1128 = f64_to_f128( op1 );

  006c0	48 8b 54 24 40	 mov	 rdx, QWORD PTR op1$[rsp]
  006c5	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  006cd	e8 00 00 00 00	 call	 f64_to_f128
  006d2	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  006da	48 8b f9	 mov	 rdi, rcx
  006dd	48 8b f0	 mov	 rsi, rax
  006e0	b9 10 00 00 00	 mov	 ecx, 16
  006e5	f3 a4		 rep movsb

; 5211 :                 op2128 = f64_to_f128( op2 );

  006e7	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  006ec	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  006f4	e8 00 00 00 00	 call	 f64_to_f128
  006f9	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  00701	48 8b f9	 mov	 rdi, rcx
  00704	48 8b f0	 mov	 rsi, rax
  00707	b9 10 00 00 00	 mov	 ecx, 16
  0070c	f3 a4		 rep movsb

; 5212 : 
; 5213 :                 softfloat_roundingMode = softfloat_round_minMag;

  0070e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00713	8b c0		 mov	 eax, eax
  00715	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0071b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00724	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00728	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5214 : 
; 5215 :                 quo128 = f128_div( op1128, op2128 );

  0072c	48 8d 44 24 70	 lea	 rax, QWORD PTR $T2[rsp]
  00731	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  00739	48 8b f8	 mov	 rdi, rax
  0073c	48 8b f1	 mov	 rsi, rcx
  0073f	b9 10 00 00 00	 mov	 ecx, 16
  00744	f3 a4		 rep movsb
  00746	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T3[rsp]
  0074e	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  00756	48 8b f8	 mov	 rdi, rax
  00759	48 8b f1	 mov	 rsi, rcx
  0075c	b9 10 00 00 00	 mov	 ecx, 16
  00761	f3 a4		 rep movsb
  00763	4c 8d 44 24 70	 lea	 r8, QWORD PTR $T2[rsp]
  00768	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T3[rsp]
  00770	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  00778	e8 00 00 00 00	 call	 f128_div
  0077d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR quo128$15[rsp]
  00785	48 8b f9	 mov	 rdi, rcx
  00788	48 8b f0	 mov	 rsi, rax
  0078b	b9 10 00 00 00	 mov	 ecx, 16
  00790	f3 a4		 rep movsb

; 5216 :                 quo128.v[FLOAT128_LO] &= 0xf000000000000000ULL;     /* truncate to long precision with extended exponent*/

  00792	b8 08 00 00 00	 mov	 eax, 8
  00797	48 6b c0 00	 imul	 rax, rax, 0
  0079b	48 b9 00 00 00
	00 00 00 00 f0	 mov	 rcx, -1152921504606846976 ; f000000000000000H
  007a5	48 8b 84 04 40
	01 00 00	 mov	 rax, QWORD PTR quo128$15[rsp+rax]
  007ad	48 23 c1	 and	 rax, rcx
  007b0	b9 08 00 00 00	 mov	 ecx, 8
  007b5	48 6b c9 00	 imul	 rcx, rcx, 0
  007b9	48 89 84 0c 40
	01 00 00	 mov	 QWORD PTR quo128$15[rsp+rcx], rax

; 5217 : 
; 5218 :                 intquo128 = f128_roundToInt( quo128, softfloat_round_minMag, FALSE );

  007c1	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  007c9	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR quo128$15[rsp]
  007d1	48 8b f8	 mov	 rdi, rax
  007d4	48 8b f1	 mov	 rsi, rcx
  007d7	b9 10 00 00 00	 mov	 ecx, 16
  007dc	f3 a4		 rep movsb
  007de	45 33 c9	 xor	 r9d, r9d
  007e1	41 b0 01	 mov	 r8b, 1
  007e4	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T4[rsp]
  007ec	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  007f4	e8 00 00 00 00	 call	 f128_roundToInt
  007f9	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR intquo128$14[rsp]
  00801	48 8b f9	 mov	 rdi, rcx
  00804	48 8b f0	 mov	 rsi, rax
  00807	b9 10 00 00 00	 mov	 ecx, 16
  0080c	f3 a4		 rep movsb

; 5219 :                 intquo128.v[FLOAT128_HI] ^= 0x8000000000000000ULL;  /* flip sign of dividend for fused multiply-add     */

  0080e	b8 08 00 00 00	 mov	 eax, 8
  00813	48 6b c0 01	 imul	 rax, rax, 1
  00817	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00821	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR intquo128$14[rsp+rax]
  00829	48 33 c1	 xor	 rax, rcx
  0082c	b9 08 00 00 00	 mov	 ecx, 8
  00831	48 6b c9 01	 imul	 rcx, rcx, 1
  00835	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR intquo128$14[rsp+rcx], rax

; 5220 : 
; 5221 :                 rem128 = f128_mulAdd( intquo128, op2128, op1128 );  /* rem = (-intquo * divisor) + dividend             */

  0083d	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  00845	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  0084d	48 8b f8	 mov	 rdi, rax
  00850	48 8b f1	 mov	 rsi, rcx
  00853	b9 10 00 00 00	 mov	 ecx, 16
  00858	f3 a4		 rep movsb
  0085a	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  00862	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  0086a	48 8b f8	 mov	 rdi, rax
  0086d	48 8b f1	 mov	 rsi, rcx
  00870	b9 10 00 00 00	 mov	 ecx, 16
  00875	f3 a4		 rep movsb
  00877	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  0087f	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR intquo128$14[rsp]
  00887	48 8b f8	 mov	 rdi, rax
  0088a	48 8b f1	 mov	 rsi, rcx
  0088d	b9 10 00 00 00	 mov	 ecx, 16
  00892	f3 a4		 rep movsb
  00894	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR $T5[rsp]
  0089c	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR $T6[rsp]
  008a4	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  008ac	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  008b4	e8 00 00 00 00	 call	 f128_mulAdd
  008b9	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR rem128$18[rsp]
  008c1	48 8b f9	 mov	 rdi, rcx
  008c4	48 8b f0	 mov	 rsi, rax
  008c7	b9 10 00 00 00	 mov	 ecx, 16
  008cc	f3 a4		 rep movsb

; 5222 : 
; 5223 :                 intquo128.v[FLOAT128_HI] ^= 0x8000000000000000ULL;  /* Restore sign of dividend                         */

  008ce	b8 08 00 00 00	 mov	 eax, 8
  008d3	48 6b c0 01	 imul	 rax, rax, 1
  008d7	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  008e1	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR intquo128$14[rsp+rax]
  008e9	48 33 c1	 xor	 rax, rcx
  008ec	b9 08 00 00 00	 mov	 ecx, 8
  008f1	48 6b c9 01	 imul	 rcx, rcx, 1
  008f5	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR intquo128$14[rsp+rcx], rax

; 5224 :                 softfloat_exceptionFlags = 0;                       /* clear any prior Softfloat flags                  */

  008fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00902	8b c0		 mov	 eax, eax
  00904	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0090a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00913	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00917	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5225 :                 softfloat_roundingMode = softfloat_round_minMag;    /* round remainder toward zero (but remainder       */

  0091b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00920	8b c0		 mov	 eax, eax
  00922	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00928	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00931	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00935	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5226 : 
; 5227 :                 rem = f128_to_f64( rem128 );                        /* should be exact!?)                               */

  00939	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  00941	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR rem128$18[rsp]
  00949	48 8b f8	 mov	 rdi, rax
  0094c	48 8b f1	 mov	 rsi, rcx
  0094f	b9 10 00 00 00	 mov	 ecx, 16
  00954	f3 a4		 rep movsb
  00956	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  0095e	e8 00 00 00 00	 call	 f128_to_f64
  00963	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5228 : 
; 5229 :                 if (rem.v & 0x7fffffffffffffffULL)                  /* non-zero remainder?                              */

  00968	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00972	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  00977	48 23 c8	 and	 rcx, rax
  0097a	48 8b c1	 mov	 rax, rcx
  0097d	48 85 c0	 test	 rax, rax
  00980	74 0c		 je	 SHORT $LN26@z900_divid

; 5230 :                     newcc += 2;                                     /* yes, indicate partial results                    */

  00982	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  00987	83 c0 02	 add	 eax, 2
  0098a	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al
$LN26@z900_divid:

; 5231 : 
; 5232 :             }

  0098e	eb 4b		 jmp	 SHORT $LN25@z900_divid
$LN24@z900_divid:

; 5233 :             else if (softfloat_exceptionFlags & (softfloat_flag_tiny | softfloat_flag_underflow))

  00990	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00995	8b c0		 mov	 eax, eax
  00997	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0099d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  009a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  009aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009ae	83 e0 42	 and	 eax, 66			; 00000042H
  009b1	85 c0		 test	 eax, eax
  009b3	74 26		 je	 SHORT $LN27@z900_divid

; 5234 :             {
; 5235 :                 /* Inexact and underflow'ed remainder issues and traps are handled by code at the end of Divide To Integer  */
; 5236 :                 /* But because this is the only situation where the remainder might need scaling, we will do it here        */
; 5237 :                 if (regs->fpc & FPC_MASK_IMU)

  009b5	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  009c3	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  009c8	85 c0		 test	 eax, eax
  009ca	74 0f		 je	 SHORT $LN28@z900_divid

; 5238 :                     rem = f64_scaledResult( SCALE_FACTOR_ARITH_UFLOW_LONG );

  009cc	b9 00 06 00 00	 mov	 ecx, 1536		; 00000600H
  009d1	e8 00 00 00 00	 call	 f64_scaledResult
  009d6	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
$LN28@z900_divid:
$LN27@z900_divid:
$LN25@z900_divid:
$LN22@z900_divid:

; 5239 :             }
; 5240 :         }
; 5241 :     }

  009db	e9 f8 01 00 00	 jmp	 $LN19@z900_divid
$LN18@z900_divid:

; 5242 : 
; 5243 :     /************************************************************************************/
; 5244 :     /* Group 2: tests for cases with NaNs for one or both operands                      */
; 5245 :     /* The sequence is required to ensure that the generated results match the IBM NaN  */
; 5246 :     /* propagation rules shown in Table 19-21                                           */
; 5247 :     /************************************************************************************/
; 5248 : 
; 5249 :     /* ******* NEXT FOUR TESTS, ALL GROUP 2 TESTS, MUST REMAIN IN SEQUENCE *******      */
; 5250 :     else if (op1_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* first case: op1 an SNaN?  */

  009e0	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  009e4	83 e0 03	 and	 eax, 3
  009e7	85 c0		 test	 eax, eax
  009e9	74 76		 je	 SHORT $LN29@z900_divid

; 5251 :     {
; 5252 :         quo = op1;

  009eb	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  009f0	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5253 :         FLOAT64_MAKE_QNAN( quo );

  009f5	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  009ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00a04	48 0b c8	 or	 rcx, rax
  00a07	48 8b c1	 mov	 rax, rcx
  00a0a	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5254 :         rem = quo;

  00a0f	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00a14	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5255 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  00a19	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00a1e	8b c0		 mov	 eax, eax
  00a20	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00a26	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00a2f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00a33	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a37	83 c8 10	 or	 eax, 16
  00a3a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00a40	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00a49	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00a4e	8b ff		 mov	 edi, edi
  00a50	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00a54	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5256 :         newcc = 1;                                                                               /* Any NaN returns cc=1      */

  00a57	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5257 :     }

  00a5c	e9 77 01 00 00	 jmp	 $LN30@z900_divid
$LN29@z900_divid:

; 5258 :     else if (op2_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* second case: op2 an SNaN? */

  00a61	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00a65	83 e0 03	 and	 eax, 3
  00a68	85 c0		 test	 eax, eax
  00a6a	74 76		 je	 SHORT $LN31@z900_divid

; 5259 :     {
; 5260 :         quo = op2;

  00a6c	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  00a71	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5261 :         FLOAT64_MAKE_QNAN( quo );

  00a76	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  00a80	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00a85	48 0b c8	 or	 rcx, rax
  00a88	48 8b c1	 mov	 rax, rcx
  00a8b	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5262 :         rem = quo;

  00a90	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00a95	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5263 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  00a9a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00a9f	8b c0		 mov	 eax, eax
  00aa1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00aa7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00ab0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00ab4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ab8	83 c8 10	 or	 eax, 16
  00abb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00ac1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00aca	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00acf	8b ff		 mov	 edi, edi
  00ad1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00ad5	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5264 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00ad8	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5265 :     }

  00add	e9 f6 00 00 00	 jmp	 $LN32@z900_divid
$LN31@z900_divid:

; 5266 :     else if (op1_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* third case: op1 a QNaN?    */

  00ae2	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00ae6	83 e0 0c	 and	 eax, 12
  00ae9	85 c0		 test	 eax, eax
  00aeb	74 1e		 je	 SHORT $LN33@z900_divid

; 5267 :     {
; 5268 :         rem = quo = op1;

  00aed	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  00af2	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax
  00af7	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00afc	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5269 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00b01	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5270 :     }

  00b06	e9 cd 00 00 00	 jmp	 $LN34@z900_divid
$LN33@z900_divid:

; 5271 :     else if (op2_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* fourth case: op2 a QNaN?   */

  00b0b	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00b0f	83 e0 0c	 and	 eax, 12
  00b12	85 c0		 test	 eax, eax
  00b14	74 1e		 je	 SHORT $LN35@z900_divid

; 5272 :     {
; 5273 :         rem = quo = op2;

  00b16	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  00b1b	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax
  00b20	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00b25	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5274 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00b2a	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5275 :     }

  00b2f	e9 a4 00 00 00	 jmp	 $LN36@z900_divid
$LN35@z900_divid:

; 5276 :     /* END OF FOUR TESTS THAT MUST REMAIN IN SEQUENCE                                   */
; 5277 : 
; 5278 :     /************************************************************************************/
; 5279 :     /* NEXT TEST MUST FOLLOW ALL FOUR NAN TESTS                                         */
; 5280 :     /* Group 3: Test cases that generate the default NaN and IEEE exception Invalid     */
; 5281 :     /* If operand 1 is an infinity OR operand two is a zero, and none of the above      */
; 5282 :     /* conditions are met, i.e., neither operand is a NaN, return a default NaN         */
; 5283 :     /************************************************************************************/
; 5284 :     else if ((op1_data_class & (float_class_neg_infinity | float_class_pos_infinity))           /* Operand 1 an infinity?             */
; 5285 :          ||  (op2_data_class & (float_class_neg_zero     | float_class_pos_zero))               /* ..or operand 2 a zero?             */

  00b34	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00b38	83 e0 30	 and	 eax, 48			; 00000030H
  00b3b	85 c0		 test	 eax, eax
  00b3d	75 0d		 jne	 SHORT $LN39@z900_divid
  00b3f	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00b43	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00b48	85 c0		 test	 eax, eax
  00b4a	74 5b		 je	 SHORT $LN37@z900_divid
$LN39@z900_divid:

; 5286 :     )
; 5287 :     {                                                                                           /* ..yes, return DNaN, raise invalid  */
; 5288 :         quo = rem = float64_default_qnan;

  00b4c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR float64_default_qnan
  00b53	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
  00b58	48 8b 44 24 38	 mov	 rax, QWORD PTR rem$[rsp]
  00b5d	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5289 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  00b62	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00b67	8b c0		 mov	 eax, eax
  00b69	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00b6f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00b78	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b7c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b80	83 c8 10	 or	 eax, 16
  00b83	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00b89	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00b92	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00b97	8b ff		 mov	 edi, edi
  00b99	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b9d	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5290 :         newcc = 1;

  00ba0	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5291 :     }

  00ba5	eb 31		 jmp	 SHORT $LN38@z900_divid
$LN37@z900_divid:

; 5292 :     /* ABOVE TEST MUST IMMEDIATELY FOLLOW ALL FOUR NAN TESTS                            */
; 5293 : 
; 5294 :     /************************************************************************************/
; 5295 :     /* Group 4: Tests for cases that generate zero or an operand value as a result.     */
; 5296 :     /*                                                                                  */
; 5297 :     /* At this point, only the remaining operand combinations remain:                   */
; 5298 :     /* - Operand 1 is zero and operand 2 is non-zero (either finite or infinity)        */
; 5299 :     /* - Operand 1 is finite and operand 2 is infinity                                  */
; 5300 :     /*                                                                                  */
; 5301 :     /* The result is the same for each of the above: Operand 1 becomes the remainder,   */
; 5302 :     /* and the quotient is zero with a signed determined by the signs of the operands.  */
; 5303 :     /* Exclusive Or sets the sign correctly.                                            */
; 5304 :     /************************************************************************************/
; 5305 :     else
; 5306 :     {
; 5307 :         rem = op1;                                          /* remainder is operand 1                               */

  00ba7	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  00bac	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5308 :         quo.v = (op1.v ^ op2.v) & 0x8000000000000000ULL;    /* quotient zero, sign is exclusive or of operand signs */

  00bb1	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  00bb6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00bbb	48 33 c8	 xor	 rcx, rax
  00bbe	48 8b c1	 mov	 rax, rcx
  00bc1	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00bcb	48 23 c1	 and	 rax, rcx
  00bce	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5309 :         newcc = 0;

  00bd3	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0
$LN38@z900_divid:
$LN36@z900_divid:
$LN34@z900_divid:
$LN32@z900_divid:
$LN30@z900_divid:
$LN19@z900_divid:

; 5310 :     }
; 5311 : 
; 5312 :     IEEE_EXCEPTION_TRAP_XI( regs );                         /* IEEE Invalid Exception raised and trappable?         */

  00bd8	33 c0		 xor	 eax, eax
  00bda	83 f8 01	 cmp	 eax, 1
  00bdd	74 4b		 je	 SHORT $LN40@z900_divid
  00bdf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00be4	8b c0		 mov	 eax, eax
  00be6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00bec	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00bf5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00bf9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00bfd	83 e0 10	 and	 eax, 16
  00c00	85 c0		 test	 eax, eax
  00c02	74 26		 je	 SHORT $LN40@z900_divid
  00c04	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c0c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00c12	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00c17	85 c0		 test	 eax, eax
  00c19	74 0f		 je	 SHORT $LN40@z900_divid
  00c1b	b2 80		 mov	 dl, 128			; 00000080H
  00c1d	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c25	e8 00 00 00 00	 call	 ieee_trap
$LN40@z900_divid:

; 5313 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00c2a	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c32	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00c37	89 44 24 6c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5314 : 
; 5315 :     /* *********** Underflow flag means remainder underflowed.  It has already been scaled if necessary             */
; 5316 : 
; 5317 :     regs->psw.cc = newcc;

  00c3b	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c43	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00c48	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5318 : 
; 5319 :     PUT_FLOAT64_NOCC( rem, r1, regs );

  00c4b	8b 44 24 5c	 mov	 eax, DWORD PTR r1$[rsp]
  00c4f	d1 e0		 shl	 eax, 1
  00c51	48 98		 cdqe
  00c53	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c5b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00c63	48 8b d0	 mov	 rdx, rax
  00c66	48 8d 4c 24 38	 lea	 rcx, QWORD PTR rem$[rsp]
  00c6b	e8 00 00 00 00	 call	 z900_put_float64

; 5320 :     PUT_FLOAT64_NOCC( quo, r3, regs );

  00c70	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  00c74	d1 e0		 shl	 eax, 1
  00c76	48 98		 cdqe
  00c78	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c80	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00c88	48 8b d0	 mov	 rdx, rax
  00c8b	48 8d 4c 24 28	 lea	 rcx, QWORD PTR quo$[rsp]
  00c90	e8 00 00 00 00	 call	 z900_put_float64

; 5321 : 
; 5322 :     ieee_cond_trap( regs, ieee_trap_conds );

  00c95	8b 54 24 6c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00c99	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ca1	e8 00 00 00 00	 call	 ieee_cond_trap

; 5323 : }

  00ca6	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00cae	48 33 cc	 xor	 rcx, rsp
  00cb1	e8 00 00 00 00	 call	 __security_check_cookie
  00cb6	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00cbd	5f		 pop	 rdi
  00cbe	5e		 pop	 rsi
  00cbf	c3		 ret	 0
z900_divide_integer_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv229 = 40
r1$ = 44
ans$ = 48
r2$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
z900_divide_bfp_short_reg PROC

; 3047 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3048 :     int        r1, r2;
; 3049 :     float32_t  op1, op2, ans;
; 3050 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3051 : 
; 3052 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_divid:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@z900_divid
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_divid:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_divid
$LN7@z900_divid:

; 3053 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN12@z900_divid
  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN12@z900_divid
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN13@z900_divid
  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN13@z900_divid
  000a1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN12@z900_divid
$LN13@z900_divid:
  000b4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199779
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_divid:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_divid

; 3054 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN15@z900_divid
  00111	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN14@z900_divid
  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN14@z900_divid
$LN15@z900_divid:
  0014d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_divid:
$LN10@z900_divid:

; 3055 : 
; 3056 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00171	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float32
  00193	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00197	d1 e0		 shl	 eax, 1
  00199	48 98		 cdqe
  0019b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_get_float32
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 b6		 jne	 SHORT $LN10@z900_divid

; 3057 : 
; 3058 :     softfloat_exceptionFlags = 0;

  001bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c0	8b c0		 mov	 eax, eax
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3059 :     SET_SF_RM_FROM_FPC;

  001d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001de	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e4	83 e0 07	 and	 eax, 7
  001e7	8b c0		 mov	 eax, eax
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001f0	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001f5	8b d2		 mov	 edx, edx
  001f7	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001fe	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00207	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3060 : 
; 3061 :     ans = f32_div( op1, op2 );

  00213	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00217	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  0021b	e8 00 00 00 00	 call	 f32_div
  00220	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 3062 : 
; 3063 :     if (softfloat_exceptionFlags)

  00224	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00229	8b c0		 mov	 eax, eax
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00231	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00242	85 c0		 test	 eax, eax
  00244	0f 84 df 00 00
	00		 je	 $LN16@z900_divid

; 3064 :     {
; 3065 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0024a	33 c0		 xor	 eax, eax
  0024c	83 f8 01	 cmp	 eax, 1
  0024f	74 45		 je	 SHORT $LN17@z900_divid
  00251	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00256	8b c0		 mov	 eax, eax
  00258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0025e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00267	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026f	83 e0 10	 and	 eax, 16
  00272	85 c0		 test	 eax, eax
  00274	74 20		 je	 SHORT $LN17@z900_divid
  00276	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0027b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00281	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00286	85 c0		 test	 eax, eax
  00288	74 0c		 je	 SHORT $LN17@z900_divid
  0028a	b2 80		 mov	 dl, 128			; 00000080H
  0028c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00291	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_divid:

; 3066 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00296	33 c0		 xor	 eax, eax
  00298	83 f8 01	 cmp	 eax, 1
  0029b	74 45		 je	 SHORT $LN18@z900_divid
  0029d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a2	8b c0		 mov	 eax, eax
  002a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002aa	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002bb	83 e0 08	 and	 eax, 8
  002be	85 c0		 test	 eax, eax
  002c0	74 20		 je	 SHORT $LN18@z900_divid
  002c2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  002c7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002cd	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002d2	85 c0		 test	 eax, eax
  002d4	74 0c		 je	 SHORT $LN18@z900_divid
  002d6	b2 40		 mov	 dl, 64			; 00000040H
  002d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002dd	e8 00 00 00 00	 call	 ieee_trap
$LN18@z900_divid:

; 3067 : 
; 3068 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002e2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002e7	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002ec	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3069 : 
; 3070 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002f0	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f4	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002f9	85 c0		 test	 eax, eax
  002fb	74 2c		 je	 SHORT $LN19@z900_divid

; 3071 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002fd	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00301	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00306	85 c0		 test	 eax, eax
  00308	74 0a		 je	 SHORT $LN22@z900_divid
  0030a	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv229[rsp], -192 ; ffffffffffffff40H
  00312	eb 08		 jmp	 SHORT $LN23@z900_divid
$LN22@z900_divid:
  00314	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv229[rsp], 192 ; 000000c0H
$LN23@z900_divid:
  0031c	8b 4c 24 28	 mov	 ecx, DWORD PTR tv229[rsp]
  00320	e8 00 00 00 00	 call	 f32_scaledResult
  00325	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN19@z900_divid:
$LN16@z900_divid:

; 3072 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 3073 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 3074 :     }
; 3075 : 
; 3076 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  00329	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0032d	d1 e0		 shl	 eax, 1
  0032f	48 98		 cdqe
  00331	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00336	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0033e	48 8b d0	 mov	 rdx, rax
  00341	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  00346	e8 00 00 00 00	 call	 z900_put_float32

; 3077 : 
; 3078 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0034b	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0034f	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00354	85 c0		 test	 eax, eax
  00356	74 0e		 je	 SHORT $LN20@z900_divid
  00358	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0035c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00361	e8 00 00 00 00	 call	 ieee_cond_trap
$LN20@z900_divid:

; 3079 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3080 : }

  00366	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0036a	c3		 ret	 0
z900_divide_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
tv250 = 56
r1$ = 60
ans$ = 64
op2$ = 68
op1$ = 72
inst$ = 96
regs$ = 104
z900_divide_bfp_short PROC

; 3086 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3087 :     int        r1, x2, b2;
; 3088 :     VADR       effective_addr2;
; 3089 :     float32_t  op1, op2, ans;
; 3090 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3091 : 
; 3092 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	8b c0		 mov	 eax, eax
  00036	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 22		 je	 SHORT $LN8@z900_divid
  0005e	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00070	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_divid:
  00080	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008e	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00093	74 22		 je	 SHORT $LN9@z900_divid
  00095	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_divid:
  000b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c8	48 23 c8	 and	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_divid:
  000d3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000dc	48 83 c0 06	 add	 rax, 6
  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0c		 je	 SHORT $LN10@z900_divid
  000f0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_divid:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 d1		 jne	 SHORT $LN4@z900_divid

; 3093 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00102	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  00107	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0010b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_divid:

; 3094 :     TXF_FLOAT_INSTR_CHECK( regs );

  00115	33 c0		 xor	 eax, eax
  00117	83 f8 01	 cmp	 eax, 1
  0011a	74 6f		 je	 SHORT $LN11@z900_divid
  0011c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00128	85 c0		 test	 eax, eax
  0012a	74 5f		 je	 SHORT $LN11@z900_divid
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 23		 jne	 SHORT $LN12@z900_divid
  00132	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0013e	85 c0		 test	 eax, eax
  00140	75 13		 jne	 SHORT $LN12@z900_divid
  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00147	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0014e	83 e0 04	 and	 eax, 4
  00151	85 c0		 test	 eax, eax
  00153	75 36		 jne	 SHORT $LN11@z900_divid
$LN12@z900_divid:
  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00160	0f ba e8 0b	 bts	 eax, 11
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0016f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199812
  00176	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0017c	ba 02 00 00 00	 mov	 edx, 2
  00181	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_divid:
  0018b	33 c0		 xor	 eax, eax
  0018d	85 c0		 test	 eax, eax
  0018f	75 84		 jne	 SHORT $LN7@z900_divid

; 3095 :     BFPINST_CHECK( regs );

  00191	b8 08 00 00 00	 mov	 eax, 8
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001a7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 3c		 je	 SHORT $LN14@z900_divid
  001b2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bd	d1 e8		 shr	 eax, 1
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	74 4c		 je	 SHORT $LN13@z900_divid
  001c6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d2	b9 08 00 00 00	 mov	 ecx, 8
  001d7	48 6b c9 01	 imul	 rcx, rcx, 1
  001db	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001e3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 24		 jne	 SHORT $LN13@z900_divid
$LN14@z900_divid:
  001ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001fd	ba 07 00 00 00	 mov	 edx, 7
  00202	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_divid:

; 3096 : 
; 3097 :     GET_FLOAT32_OP( op1, r1, regs );

  00212	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00216	d1 e0		 shl	 eax, 1
  00218	48 98		 cdqe
  0021a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00227	48 8b d0	 mov	 rdx, rax
  0022a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_get_float32

; 3098 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00234	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00239	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  0023d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00242	e8 00 00 00 00	 call	 z900_vfetch4
  00247	89 44 24 44	 mov	 DWORD PTR op2$[rsp], eax

; 3099 : 
; 3100 :     softfloat_exceptionFlags = 0;

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3101 :     SET_SF_RM_FROM_FPC;

  00269	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0026e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00274	83 e0 07	 and	 eax, 7
  00277	8b c0		 mov	 eax, eax
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00280	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00285	8b d2		 mov	 edx, edx
  00287	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00297	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3102 : 
; 3103 :     ans = f32_div( op1, op2 );

  002a3	8b 54 24 44	 mov	 edx, DWORD PTR op2$[rsp]
  002a7	8b 4c 24 48	 mov	 ecx, DWORD PTR op1$[rsp]
  002ab	e8 00 00 00 00	 call	 f32_div
  002b0	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax

; 3104 : 
; 3105 :     if (softfloat_exceptionFlags)

  002b4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b9	8b c0		 mov	 eax, eax
  002bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ca	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d2	85 c0		 test	 eax, eax
  002d4	0f 84 df 00 00
	00		 je	 $LN15@z900_divid

; 3106 :     {
; 3107 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002da	33 c0		 xor	 eax, eax
  002dc	83 f8 01	 cmp	 eax, 1
  002df	74 45		 je	 SHORT $LN16@z900_divid
  002e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e6	8b c0		 mov	 eax, eax
  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ff	83 e0 10	 and	 eax, 16
  00302	85 c0		 test	 eax, eax
  00304	74 20		 je	 SHORT $LN16@z900_divid
  00306	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0030b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00311	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00316	85 c0		 test	 eax, eax
  00318	74 0c		 je	 SHORT $LN16@z900_divid
  0031a	b2 80		 mov	 dl, 128			; 00000080H
  0031c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_divid:

; 3108 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00326	33 c0		 xor	 eax, eax
  00328	83 f8 01	 cmp	 eax, 1
  0032b	74 45		 je	 SHORT $LN17@z900_divid
  0032d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00332	8b c0		 mov	 eax, eax
  00334	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0033a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00343	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00347	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034b	83 e0 08	 and	 eax, 8
  0034e	85 c0		 test	 eax, eax
  00350	74 20		 je	 SHORT $LN17@z900_divid
  00352	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00357	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0035d	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00362	85 c0		 test	 eax, eax
  00364	74 0c		 je	 SHORT $LN17@z900_divid
  00366	b2 40		 mov	 dl, 64			; 00000040H
  00368	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0036d	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_divid:

; 3109 : 
; 3110 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00372	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00377	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0037c	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3111 : 
; 3112 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00380	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00384	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00389	85 c0		 test	 eax, eax
  0038b	74 2c		 je	 SHORT $LN18@z900_divid

; 3113 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0038d	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00391	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00396	85 c0		 test	 eax, eax
  00398	74 0a		 je	 SHORT $LN21@z900_divid
  0039a	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv250[rsp], -192 ; ffffffffffffff40H
  003a2	eb 08		 jmp	 SHORT $LN22@z900_divid
$LN21@z900_divid:
  003a4	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv250[rsp], 192 ; 000000c0H
$LN22@z900_divid:
  003ac	8b 4c 24 38	 mov	 ecx, DWORD PTR tv250[rsp]
  003b0	e8 00 00 00 00	 call	 f32_scaledResult
  003b5	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax
$LN18@z900_divid:
$LN15@z900_divid:

; 3114 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 3115 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 3116 :     }
; 3117 : 
; 3118 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  003b9	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  003bd	d1 e0		 shl	 eax, 1
  003bf	48 98		 cdqe
  003c1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003c6	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003ce	48 8b d0	 mov	 rdx, rax
  003d1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  003d6	e8 00 00 00 00	 call	 z900_put_float32

; 3119 : 
; 3120 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003db	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003df	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003e4	85 c0		 test	 eax, eax
  003e6	74 0e		 je	 SHORT $LN19@z900_divid
  003e8	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003ec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_divid:

; 3121 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3122 : }

  003f6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003fa	c3		 ret	 0
z900_divide_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv229 = 40
r1$ = 44
r2$ = 48
ans$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
z900_divide_bfp_long_reg PROC

; 2965 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2966 :     int        r1, r2;
; 2967 :     float64_t  op1, op2, ans;
; 2968 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2969 : 
; 2970 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_divid:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@z900_divid
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_divid:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_divid
$LN7@z900_divid:

; 2971 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN12@z900_divid
  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN12@z900_divid
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN13@z900_divid
  00091	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN13@z900_divid
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN12@z900_divid
$LN13@z900_divid:
  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199714
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_divid:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_divid

; 2972 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN15@z900_divid
  00111	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN14@z900_divid
  00125	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN14@z900_divid
$LN15@z900_divid:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_divid:
$LN10@z900_divid:

; 2973 : 
; 2974 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00171	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float64
  00193	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00197	d1 e0		 shl	 eax, 1
  00199	48 98		 cdqe
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_get_float64
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 b6		 jne	 SHORT $LN10@z900_divid

; 2975 : 
; 2976 :     softfloat_exceptionFlags = 0;

  001bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c0	8b c0		 mov	 eax, eax
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2977 :     SET_SF_RM_FROM_FPC;

  001d9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001de	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e4	83 e0 07	 and	 eax, 7
  001e7	8b c0		 mov	 eax, eax
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001f0	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001f5	8b d2		 mov	 edx, edx
  001f7	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001fe	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00207	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 2978 : 
; 2979 :     ans = f64_div( op1, op2 );

  00213	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00218	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0021d	e8 00 00 00 00	 call	 f64_div
  00222	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 2980 : 
; 2981 :     if (softfloat_exceptionFlags)

  00227	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022c	8b c0		 mov	 eax, eax
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00234	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00241	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00245	85 c0		 test	 eax, eax
  00247	0f 84 e0 00 00
	00		 je	 $LN16@z900_divid

; 2982 :     {
; 2983 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0024d	33 c0		 xor	 eax, eax
  0024f	83 f8 01	 cmp	 eax, 1
  00252	74 45		 je	 SHORT $LN17@z900_divid
  00254	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00259	8b c0		 mov	 eax, eax
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00261	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00272	83 e0 10	 and	 eax, 16
  00275	85 c0		 test	 eax, eax
  00277	74 20		 je	 SHORT $LN17@z900_divid
  00279	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0027e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00284	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00289	85 c0		 test	 eax, eax
  0028b	74 0c		 je	 SHORT $LN17@z900_divid
  0028d	b2 80		 mov	 dl, 128			; 00000080H
  0028f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_divid:

; 2984 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00299	33 c0		 xor	 eax, eax
  0029b	83 f8 01	 cmp	 eax, 1
  0029e	74 45		 je	 SHORT $LN18@z900_divid
  002a0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a5	8b c0		 mov	 eax, eax
  002a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ad	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002be	83 e0 08	 and	 eax, 8
  002c1	85 c0		 test	 eax, eax
  002c3	74 20		 je	 SHORT $LN18@z900_divid
  002c5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002ca	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002d0	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002d5	85 c0		 test	 eax, eax
  002d7	74 0c		 je	 SHORT $LN18@z900_divid
  002d9	b2 40		 mov	 dl, 64			; 00000040H
  002db	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e0	e8 00 00 00 00	 call	 ieee_trap
$LN18@z900_divid:

; 2985 : 
; 2986 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ea	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002ef	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2987 : 
; 2988 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002f3	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f7	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002fc	85 c0		 test	 eax, eax
  002fe	74 2d		 je	 SHORT $LN19@z900_divid

; 2989 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00300	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00304	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00309	85 c0		 test	 eax, eax
  0030b	74 0a		 je	 SHORT $LN22@z900_divid
  0030d	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv229[rsp], -1536 ; fffffffffffffa00H
  00315	eb 08		 jmp	 SHORT $LN23@z900_divid
$LN22@z900_divid:
  00317	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv229[rsp], 1536 ; 00000600H
$LN23@z900_divid:
  0031f	8b 4c 24 28	 mov	 ecx, DWORD PTR tv229[rsp]
  00323	e8 00 00 00 00	 call	 f64_scaledResult
  00328	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN19@z900_divid:
$LN16@z900_divid:

; 2990 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 2991 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 2992 :     }
; 2993 : 
; 2994 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  0032d	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00331	d1 e0		 shl	 eax, 1
  00333	48 98		 cdqe
  00335	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0033a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00342	48 8b d0	 mov	 rdx, rax
  00345	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  0034a	e8 00 00 00 00	 call	 z900_put_float64

; 2995 : 
; 2996 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0034f	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00353	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00358	85 c0		 test	 eax, eax
  0035a	74 0e		 je	 SHORT $LN20@z900_divid
  0035c	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00360	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00365	e8 00 00 00 00	 call	 ieee_cond_trap
$LN20@z900_divid:

; 2997 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 2998 : }

  0036a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0036e	c3		 ret	 0
z900_divide_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
tv250 = 56
r1$ = 60
ans$ = 64
op2$ = 72
op1$ = 80
inst$ = 112
regs$ = 120
z900_divide_bfp_long PROC

; 3004 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3005 :     int        r1, x2, b2;
; 3006 :     VADR       effective_addr2;
; 3007 :     float64_t  op1, op2, ans;
; 3008 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3009 : 
; 3010 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	8b c0		 mov	 eax, eax
  00036	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 22		 je	 SHORT $LN8@z900_divid
  0005e	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00070	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_divid:
  00080	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008e	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00093	74 22		 je	 SHORT $LN9@z900_divid
  00095	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_divid:
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c8	48 23 c8	 and	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_divid:
  000d3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000dc	48 83 c0 06	 add	 rax, 6
  000e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0c		 je	 SHORT $LN10@z900_divid
  000f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_divid:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 d1		 jne	 SHORT $LN4@z900_divid

; 3011 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00102	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  00107	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0010b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_divid:

; 3012 :     TXF_FLOAT_INSTR_CHECK( regs );

  00115	33 c0		 xor	 eax, eax
  00117	83 f8 01	 cmp	 eax, 1
  0011a	74 6f		 je	 SHORT $LN11@z900_divid
  0011c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00128	85 c0		 test	 eax, eax
  0012a	74 5f		 je	 SHORT $LN11@z900_divid
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 23		 jne	 SHORT $LN12@z900_divid
  00132	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0013e	85 c0		 test	 eax, eax
  00140	75 13		 jne	 SHORT $LN12@z900_divid
  00142	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00147	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0014e	83 e0 04	 and	 eax, 4
  00151	85 c0		 test	 eax, eax
  00153	75 36		 jne	 SHORT $LN11@z900_divid
$LN12@z900_divid:
  00155	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00160	0f ba e8 0b	 bts	 eax, 11
  00164	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0016f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199747
  00176	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0017c	ba 02 00 00 00	 mov	 edx, 2
  00181	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_divid:
  0018b	33 c0		 xor	 eax, eax
  0018d	85 c0		 test	 eax, eax
  0018f	75 84		 jne	 SHORT $LN7@z900_divid

; 3013 :     BFPINST_CHECK( regs );

  00191	b8 08 00 00 00	 mov	 eax, 8
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001a7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 3c		 je	 SHORT $LN14@z900_divid
  001b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bd	d1 e8		 shr	 eax, 1
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	74 4c		 je	 SHORT $LN13@z900_divid
  001c6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d2	b9 08 00 00 00	 mov	 ecx, 8
  001d7	48 6b c9 01	 imul	 rcx, rcx, 1
  001db	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001e3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 24		 jne	 SHORT $LN13@z900_divid
$LN14@z900_divid:
  001ee	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001f3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001fd	ba 07 00 00 00	 mov	 edx, 7
  00202	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_divid:

; 3014 : 
; 3015 :     GET_FLOAT64_OP( op1, r1, regs );

  00212	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00216	d1 e0		 shl	 eax, 1
  00218	48 98		 cdqe
  0021a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00227	48 8b d0	 mov	 rdx, rax
  0022a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_get_float64

; 3016 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00234	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00239	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  0023d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00242	e8 00 00 00 00	 call	 z900_vfetch8
  00247	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 3017 : 
; 3018 :     softfloat_exceptionFlags = 0;

  0024c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00251	8b c0		 mov	 eax, eax
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00259	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00262	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00266	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3019 :     SET_SF_RM_FROM_FPC;

  0026a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00275	83 e0 07	 and	 eax, 7
  00278	8b c0		 mov	 eax, eax
  0027a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00281	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00286	8b d2		 mov	 edx, edx
  00288	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028f	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00298	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a0	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3020 : 
; 3021 :     ans = f64_div( op1, op2 );

  002a4	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  002a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op1$[rsp]
  002ae	e8 00 00 00 00	 call	 f64_div
  002b3	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 3022 : 
; 3023 :     if (softfloat_exceptionFlags)

  002b8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002bd	8b c0		 mov	 eax, eax
  002bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ce	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d6	85 c0		 test	 eax, eax
  002d8	0f 84 e0 00 00
	00		 je	 $LN15@z900_divid

; 3024 :     {
; 3025 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002de	33 c0		 xor	 eax, eax
  002e0	83 f8 01	 cmp	 eax, 1
  002e3	74 45		 je	 SHORT $LN16@z900_divid
  002e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ea	8b c0		 mov	 eax, eax
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00303	83 e0 10	 and	 eax, 16
  00306	85 c0		 test	 eax, eax
  00308	74 20		 je	 SHORT $LN16@z900_divid
  0030a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0030f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00315	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0031a	85 c0		 test	 eax, eax
  0031c	74 0c		 je	 SHORT $LN16@z900_divid
  0031e	b2 80		 mov	 dl, 128			; 00000080H
  00320	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00325	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_divid:

; 3026 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  0032a	33 c0		 xor	 eax, eax
  0032c	83 f8 01	 cmp	 eax, 1
  0032f	74 45		 je	 SHORT $LN17@z900_divid
  00331	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00336	8b c0		 mov	 eax, eax
  00338	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0033e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00347	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0034b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034f	83 e0 08	 and	 eax, 8
  00352	85 c0		 test	 eax, eax
  00354	74 20		 je	 SHORT $LN17@z900_divid
  00356	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0035b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00361	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00366	85 c0		 test	 eax, eax
  00368	74 0c		 je	 SHORT $LN17@z900_divid
  0036a	b2 40		 mov	 dl, 64			; 00000040H
  0036c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00371	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_divid:

; 3027 : 
; 3028 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00376	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0037b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00380	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3029 : 
; 3030 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00384	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00388	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0038d	85 c0		 test	 eax, eax
  0038f	74 2d		 je	 SHORT $LN18@z900_divid

; 3031 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00391	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00395	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0039a	85 c0		 test	 eax, eax
  0039c	74 0a		 je	 SHORT $LN21@z900_divid
  0039e	c7 44 24 38 00
	fa ff ff	 mov	 DWORD PTR tv250[rsp], -1536 ; fffffffffffffa00H
  003a6	eb 08		 jmp	 SHORT $LN22@z900_divid
$LN21@z900_divid:
  003a8	c7 44 24 38 00
	06 00 00	 mov	 DWORD PTR tv250[rsp], 1536 ; 00000600H
$LN22@z900_divid:
  003b0	8b 4c 24 38	 mov	 ecx, DWORD PTR tv250[rsp]
  003b4	e8 00 00 00 00	 call	 f64_scaledResult
  003b9	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN18@z900_divid:
$LN15@z900_divid:

; 3032 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 3033 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 3034 :     }
; 3035 : 
; 3036 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  003be	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  003c2	d1 e0		 shl	 eax, 1
  003c4	48 98		 cdqe
  003c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003cb	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003d3	48 8b d0	 mov	 rdx, rax
  003d6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  003db	e8 00 00 00 00	 call	 z900_put_float64

; 3037 : 
; 3038 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003e0	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003e4	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003e9	85 c0		 test	 eax, eax
  003eb	74 0e		 je	 SHORT $LN19@z900_divid
  003ed	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f6	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_divid:

; 3039 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3040 : }

  003fb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003ff	c3		 ret	 0
z900_divide_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv238 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
ans$ = 128
op2$ = 144
op1$ = 160
__$ArrayPad$ = 176
inst$ = 224
regs$ = 232
z900_divide_bfp_ext_reg PROC

; 2925 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2926 :     int         r1, r2;
; 2927 :     float128_t  op1, op2, ans;
; 2928 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2929 : 
; 2930 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_divid:
  0005f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN11@z900_divid
  00082	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_divid:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@z900_divid
$LN7@z900_divid:

; 2931 :     TXF_FLOAT_INSTR_CHECK( regs );

  00097	33 c0		 xor	 eax, eax
  00099	83 f8 01	 cmp	 eax, 1
  0009c	0f 84 81 00 00
	00		 je	 $LN12@z900_divid
  000a2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b1	85 c0		 test	 eax, eax
  000b3	74 6e		 je	 SHORT $LN12@z900_divid
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 29		 jne	 SHORT $LN13@z900_divid
  000bb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000ca	85 c0		 test	 eax, eax
  000cc	75 16		 jne	 SHORT $LN13@z900_divid
  000ce	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000dd	83 e0 04	 and	 eax, 4
  000e0	85 c0		 test	 eax, eax
  000e2	75 3f		 jne	 SHORT $LN12@z900_divid
$LN13@z900_divid:
  000e4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f2	0f ba e8 0b	 bts	 eax, 11
  000f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00104	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199680
  0010b	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_divid:
  00123	33 c0		 xor	 eax, eax
  00125	85 c0		 test	 eax, eax
  00127	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_divid

; 2932 :     BFPINST_CHECK( regs );

  0012d	b8 08 00 00 00	 mov	 eax, 8
  00132	48 6b c0 01	 imul	 rax, rax, 1
  00136	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00146	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014c	48 85 c0	 test	 rax, rax
  0014f	74 42		 je	 SHORT $LN15@z900_divid
  00151	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015f	d1 e8		 shr	 eax, 1
  00161	83 e0 01	 and	 eax, 1
  00164	85 c0		 test	 eax, eax
  00166	74 58		 je	 SHORT $LN14@z900_divid
  00168	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00177	b9 08 00 00 00	 mov	 ecx, 8
  0017c	48 6b c9 01	 imul	 rcx, rcx, 1
  00180	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00188	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018e	48 85 c0	 test	 rax, rax
  00191	75 2d		 jne	 SHORT $LN14@z900_divid
$LN15@z900_divid:
  00193	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001a5	ba 07 00 00 00	 mov	 edx, 7
  001aa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_divid:

; 2933 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001c0	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001c4	83 e0 02	 and	 eax, 2
  001c7	85 c0		 test	 eax, eax
  001c9	75 0b		 jne	 SHORT $LN17@z900_divid
  001cb	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001cf	83 e0 02	 and	 eax, 2
  001d2	85 c0		 test	 eax, eax
  001d4	74 1b		 je	 SHORT $LN16@z900_divid
$LN17@z900_divid:
  001d6	ba 06 00 00 00	 mov	 edx, 6
  001db	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_divid:
$LN10@z900_divid:

; 2934 : 
; 2935 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  001f1	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001f5	d1 e0		 shl	 eax, 1
  001f7	48 98		 cdqe
  001f9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00209	48 8b d0	 mov	 rdx, rax
  0020c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00214	e8 00 00 00 00	 call	 z900_get_float128
  00219	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0021d	d1 e0		 shl	 eax, 1
  0021f	48 98		 cdqe
  00221	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00231	48 8b d0	 mov	 rdx, rax
  00234	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0023c	e8 00 00 00 00	 call	 z900_get_float128
  00241	33 c0		 xor	 eax, eax
  00243	85 c0		 test	 eax, eax
  00245	75 aa		 jne	 SHORT $LN10@z900_divid

; 2936 : 
; 2937 :     softfloat_exceptionFlags = 0;

  00247	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0024c	8b c0		 mov	 eax, eax
  0024e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00254	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00261	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2938 :     SET_SF_RM_FROM_FPC;

  00265	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00273	83 e0 07	 and	 eax, 7
  00276	8b c0		 mov	 eax, eax
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0027f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00284	8b d2		 mov	 edx, edx
  00286	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028d	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00296	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029e	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 2939 : 
; 2940 :     ans = f128_div( op1, op2 );

  002a2	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  002a7	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  002af	48 8b f8	 mov	 rdi, rax
  002b2	48 8b f1	 mov	 rsi, rcx
  002b5	b9 10 00 00 00	 mov	 ecx, 16
  002ba	f3 a4		 rep movsb
  002bc	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  002c1	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  002c9	48 8b f8	 mov	 rdi, rax
  002cc	48 8b f1	 mov	 rsi, rcx
  002cf	b9 10 00 00 00	 mov	 ecx, 16
  002d4	f3 a4		 rep movsb
  002d6	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  002db	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  002e0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  002e5	e8 00 00 00 00	 call	 f128_div
  002ea	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  002f2	48 8b f9	 mov	 rdi, rcx
  002f5	48 8b f0	 mov	 rsi, rax
  002f8	b9 10 00 00 00	 mov	 ecx, 16
  002fd	f3 a4		 rep movsb

; 2941 : 
; 2942 :     if (softfloat_exceptionFlags)

  002ff	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00304	8b c0		 mov	 eax, eax
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00315	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00319	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031d	85 c0		 test	 eax, eax
  0031f	0f 84 04 01 00
	00		 je	 $LN18@z900_divid

; 2943 :     {
; 2944 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00325	33 c0		 xor	 eax, eax
  00327	83 f8 01	 cmp	 eax, 1
  0032a	74 4b		 je	 SHORT $LN19@z900_divid
  0032c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00331	8b c0		 mov	 eax, eax
  00333	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00339	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00342	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00346	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034a	83 e0 10	 and	 eax, 16
  0034d	85 c0		 test	 eax, eax
  0034f	74 26		 je	 SHORT $LN19@z900_divid
  00351	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00359	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0035f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00364	85 c0		 test	 eax, eax
  00366	74 0f		 je	 SHORT $LN19@z900_divid
  00368	b2 80		 mov	 dl, 128			; 00000080H
  0036a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00372	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_divid:

; 2945 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00377	33 c0		 xor	 eax, eax
  00379	83 f8 01	 cmp	 eax, 1
  0037c	74 4b		 je	 SHORT $LN20@z900_divid
  0037e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00383	8b c0		 mov	 eax, eax
  00385	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0038b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00394	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00398	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039c	83 e0 08	 and	 eax, 8
  0039f	85 c0		 test	 eax, eax
  003a1	74 26		 je	 SHORT $LN20@z900_divid
  003a3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ab	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003b1	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  003b6	85 c0		 test	 eax, eax
  003b8	74 0f		 je	 SHORT $LN20@z900_divid
  003ba	b2 40		 mov	 dl, 64			; 00000040H
  003bc	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c4	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_divid:

; 2946 : 
; 2947 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  003c9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d1	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003d6	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2948 : 
; 2949 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  003da	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003de	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  003e3	85 c0		 test	 eax, eax
  003e5	74 42		 je	 SHORT $LN21@z900_divid

; 2950 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  003e7	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003eb	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003f0	85 c0		 test	 eax, eax
  003f2	74 0a		 je	 SHORT $LN24@z900_divid
  003f4	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv238[rsp], -24576 ; ffffffffffffa000H
  003fc	eb 08		 jmp	 SHORT $LN25@z900_divid
$LN24@z900_divid:
  003fe	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv238[rsp], 24576 ; 00006000H
$LN25@z900_divid:
  00406	8b 54 24 30	 mov	 edx, DWORD PTR tv238[rsp]
  0040a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  0040f	e8 00 00 00 00	 call	 f128_scaledResult
  00414	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0041c	48 8b f9	 mov	 rdi, rcx
  0041f	48 8b f0	 mov	 rsi, rax
  00422	b9 10 00 00 00	 mov	 ecx, 16
  00427	f3 a4		 rep movsb
$LN21@z900_divid:
$LN18@z900_divid:

; 2951 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 2952 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 2953 :     }
; 2954 : 
; 2955 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  00429	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0042d	d1 e0		 shl	 eax, 1
  0042f	48 98		 cdqe
  00431	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00439	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00441	48 8b d0	 mov	 rdx, rax
  00444	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0044c	e8 00 00 00 00	 call	 z900_put_float128

; 2956 : 
; 2957 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00451	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00455	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0045a	85 c0		 test	 eax, eax
  0045c	74 11		 je	 SHORT $LN22@z900_divid
  0045e	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00462	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	e8 00 00 00 00	 call	 ieee_cond_trap
$LN22@z900_divid:

; 2958 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 2959 : }

  0046f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00477	48 33 cc	 xor	 rcx, rsp
  0047a	e8 00 00 00 00	 call	 __security_check_cookie
  0047f	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00486	5f		 pop	 rdi
  00487	5e		 pop	 rsi
  00488	c3		 ret	 0
z900_divide_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv189 = 44
r2$ = 48
r1$ = 52
op1$ = 56
op2$ = 64
inst$ = 96
regs$ = 104
z900_convert_fix64_to_bfp_short_reg PROC

; 1879 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1880 :     int        r1, r2;
; 1881 :     BYTE       m3, m4;
; 1882 :     S64        op2;
; 1883 :     float32_t  op1;
; 1884 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1885 : 
; 1886 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1887 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199064
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 1888 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 1889 : 
; 1890 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1891 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0018c	b8 01 00 00 00	 mov	 eax, 1
  00191	48 6b c0 04	 imul	 rax, rax, 4
  00195	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001a2	83 e0 04	 and	 eax, 4
  001a5	85 c0		 test	 eax, eax
  001a7	74 11		 je	 SHORT $LN13@z900_conve

; 1892 :         BFPRM_CHECK( m3, regs );

  001a9	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  001ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	e8 00 00 00 00	 call	 z900_BFP_RM_check
  001b8	eb 25		 jmp	 SHORT $LN14@z900_conve
$LN13@z900_conve:

; 1893 :     else
; 1894 : #endif
; 1895 :     {
; 1896 :         if (m3 | m4)

  001ba	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001bf	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  001c4	0b c1		 or	 eax, ecx
  001c6	85 c0		 test	 eax, eax
  001c8	74 15		 je	 SHORT $LN15@z900_conve

; 1897 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001ca	ba 06 00 00 00	 mov	 edx, 6
  001cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_conve:
$LN14@z900_conve:

; 1898 :     }
; 1899 : 
; 1900 :     SET_SF_RM_FROM_MASK( m3 );

  001df	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001e4	85 c0		 test	 eax, eax
  001e6	74 16		 je	 SHORT $LN19@z900_conve
  001e8	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
  001fc	eb 1f		 jmp	 SHORT $LN20@z900_conve
$LN19@z900_conve:
  001fe	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00203	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00209	83 e0 07	 and	 eax, 7
  0020c	8b c0		 mov	 eax, eax
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00215	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00219	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
$LN20@z900_conve:
  0021d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00222	8b c0		 mov	 eax, eax
  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00233	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00237	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv189[rsp]
  0023c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1901 :     op2 = regs->GR_G( r2 );

  0023f	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00244	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00251	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 1902 :     softfloat_exceptionFlags = 0;

  00256	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0025b	8b c0		 mov	 eax, eax
  0025d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00263	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00270	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1903 :     op1 = i64_to_f32( op2 );

  00274	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  00279	e8 00 00 00 00	 call	 i64_to_f32
  0027e	89 44 24 38	 mov	 DWORD PTR op1$[rsp], eax

; 1904 : 
; 1905 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  00282	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00286	d1 e0		 shl	 eax, 1
  00288	48 98		 cdqe
  0028a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00297	48 8b d0	 mov	 rdx, rax
  0029a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  0029f	e8 00 00 00 00	 call	 z900_put_float32

; 1906 : 
; 1907 :     /* Inexact occurred and not masked by m4? */
; 1908 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  002a4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a9	8b c0		 mov	 eax, eax
  002ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ba	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002be	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c2	85 c0		 test	 eax, eax
  002c4	74 35		 je	 SHORT $LN16@z900_conve
  002c6	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002cb	83 e0 04	 and	 eax, 4
  002ce	85 c0		 test	 eax, eax
  002d0	75 29		 jne	 SHORT $LN16@z900_conve

; 1909 :     {
; 1910 :         /* Yes, set FPC flags and test for a trap */
; 1911 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002d7	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002dc	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1912 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002e0	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002e9	85 c0		 test	 eax, eax
  002eb	74 0e		 je	 SHORT $LN17@z900_conve
  002ed	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f6	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@z900_conve:
$LN16@z900_conve:

; 1913 :     }
; 1914 : 
; 1915 : }

  002fb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002ff	c3		 ret	 0
z900_convert_fix64_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv189 = 44
r2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
z900_convert_fix64_to_bfp_long_reg PROC

; 1829 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1830 :     int        r1, r2;
; 1831 :     BYTE       m3, m4;
; 1832 :     S64        op2;
; 1833 :     float64_t  op1;
; 1834 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1835 : 
; 1836 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1837 : 
; 1838 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199034
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 1839 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 1840 : 
; 1841 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1842 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0018c	b8 01 00 00 00	 mov	 eax, 1
  00191	48 6b c0 04	 imul	 rax, rax, 4
  00195	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001a2	83 e0 04	 and	 eax, 4
  001a5	85 c0		 test	 eax, eax
  001a7	74 11		 je	 SHORT $LN13@z900_conve

; 1843 :         BFPRM_CHECK( m3, regs );

  001a9	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  001ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	e8 00 00 00 00	 call	 z900_BFP_RM_check
  001b8	eb 25		 jmp	 SHORT $LN14@z900_conve
$LN13@z900_conve:

; 1844 :     else
; 1845 : #endif
; 1846 :     {
; 1847 :         if (m3 | m4)

  001ba	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001bf	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  001c4	0b c1		 or	 eax, ecx
  001c6	85 c0		 test	 eax, eax
  001c8	74 15		 je	 SHORT $LN15@z900_conve

; 1848 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001ca	ba 06 00 00 00	 mov	 edx, 6
  001cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_conve:
$LN14@z900_conve:

; 1849 :     }
; 1850 : 
; 1851 :     SET_SF_RM_FROM_MASK( m3 );

  001df	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001e4	85 c0		 test	 eax, eax
  001e6	74 16		 je	 SHORT $LN19@z900_conve
  001e8	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
  001fc	eb 1f		 jmp	 SHORT $LN20@z900_conve
$LN19@z900_conve:
  001fe	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00203	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00209	83 e0 07	 and	 eax, 7
  0020c	8b c0		 mov	 eax, eax
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00215	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00219	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
$LN20@z900_conve:
  0021d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00222	8b c0		 mov	 eax, eax
  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00233	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00237	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv189[rsp]
  0023c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1852 :     op2 = regs->GR_G( r2 );

  0023f	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00244	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00251	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 1853 :     softfloat_exceptionFlags = 0;

  00256	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0025b	8b c0		 mov	 eax, eax
  0025d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00263	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00270	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1854 :     op1 = i64_to_f64( op2 );

  00274	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  00279	e8 00 00 00 00	 call	 i64_to_f64
  0027e	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 1855 : 
; 1856 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00283	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00287	d1 e0		 shl	 eax, 1
  00289	48 98		 cdqe
  0028b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00290	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00298	48 8b d0	 mov	 rdx, rax
  0029b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  002a0	e8 00 00 00 00	 call	 z900_put_float64

; 1857 : 
; 1858 :     /* Inexact occurred and not masked by m4? */
; 1859 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  002a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002aa	8b c0		 mov	 eax, eax
  002ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c3	85 c0		 test	 eax, eax
  002c5	74 35		 je	 SHORT $LN16@z900_conve
  002c7	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002cc	83 e0 04	 and	 eax, 4
  002cf	85 c0		 test	 eax, eax
  002d1	75 29		 jne	 SHORT $LN16@z900_conve

; 1860 :     {
; 1861 :         /* Yes, set FPC flags and test for a trap */
; 1862 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002d3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002d8	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002dd	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1863 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002e1	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e5	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002ea	85 c0		 test	 eax, eax
  002ec	74 0e		 je	 SHORT $LN17@z900_conve
  002ee	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@z900_conve:
$LN16@z900_conve:

; 1864 :     }
; 1865 : }

  002fc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00300	c3		 ret	 0
z900_convert_fix64_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
tv194 = 40
r1$ = 44
r2$ = 48
op2$ = 56
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
z900_convert_fix64_to_bfp_ext_reg PROC

; 1788 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1789 :     int         r1, r2;
; 1790 :     BYTE        m3, m4;
; 1791 :     S64         op2;
; 1792 :     float128_t  op1;
; 1793 : 
; 1794 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 04	 shr	 eax, 4
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 08	 shr	 eax, 8
  00057	83 e0 0f	 and	 eax, 15
  0005a	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 0c	 shr	 eax, 12
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0006c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00088	33 c0		 xor	 eax, eax
  0008a	83 f8 04	 cmp	 eax, 4
  0008d	74 0f		 je	 SHORT $LN8@z900_conve
  0008f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1795 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a4	33 c0		 xor	 eax, eax
  000a6	83 f8 01	 cmp	 eax, 1
  000a9	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b7	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000be	85 c0		 test	 eax, eax
  000c0	74 6e		 je	 SHORT $LN9@z900_conve
  000c2	33 c0		 xor	 eax, eax
  000c4	85 c0		 test	 eax, eax
  000c6	75 29		 jne	 SHORT $LN10@z900_conve
  000c8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000d7	85 c0		 test	 eax, eax
  000d9	75 16		 jne	 SHORT $LN10@z900_conve
  000db	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ea	83 e0 04	 and	 eax, 4
  000ed	85 c0		 test	 eax, eax
  000ef	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ff	0f ba e8 0b	 bts	 eax, 11
  00103	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00111	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199005
  00118	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0011e	ba 02 00 00 00	 mov	 edx, 2
  00123	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00130	33 c0		 xor	 eax, eax
  00132	85 c0		 test	 eax, eax
  00134	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 1796 :     BFPINST_CHECK( regs );

  0013a	b8 08 00 00 00	 mov	 eax, 8
  0013f	48 6b c0 01	 imul	 rax, rax, 1
  00143	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00153	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00159	48 85 c0	 test	 rax, rax
  0015c	74 42		 je	 SHORT $LN12@z900_conve
  0015e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0016c	d1 e8		 shr	 eax, 1
  0016e	83 e0 01	 and	 eax, 1
  00171	85 c0		 test	 eax, eax
  00173	74 58		 je	 SHORT $LN11@z900_conve
  00175	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00184	b9 08 00 00 00	 mov	 ecx, 8
  00189	48 6b c9 01	 imul	 rcx, rcx, 1
  0018d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00195	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019b	48 85 c0	 test	 rax, rax
  0019e	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001b2	ba 07 00 00 00	 mov	 edx, 7
  001b7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 1797 :     BFPREGPAIR_CHECK( r1, regs );

  001cd	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001d1	83 e0 02	 and	 eax, 2
  001d4	85 c0		 test	 eax, eax
  001d6	74 1b		 je	 SHORT $LN13@z900_conve
  001d8	ba 06 00 00 00	 mov	 edx, 6
  001dd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 1798 : 
; 1799 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1800 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  001f3	b8 01 00 00 00	 mov	 eax, 1
  001f8	48 6b c0 04	 imul	 rax, rax, 4
  001fc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0020c	83 e0 04	 and	 eax, 4
  0020f	85 c0		 test	 eax, eax
  00211	74 14		 je	 SHORT $LN14@z900_conve

; 1801 :         BFPRM_CHECK( m3, regs );

  00213	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00218	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00220	e8 00 00 00 00	 call	 z900_BFP_RM_check
  00225	eb 2b		 jmp	 SHORT $LN15@z900_conve
$LN14@z900_conve:

; 1802 :     else
; 1803 : #endif
; 1804 :     {
; 1805 :         if (m3 | m4)

  00227	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0022c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  00231	0b c1		 or	 eax, ecx
  00233	85 c0		 test	 eax, eax
  00235	74 1b		 je	 SHORT $LN16@z900_conve

; 1806 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00237	ba 06 00 00 00	 mov	 edx, 6
  0023c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00244	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_conve:
$LN15@z900_conve:

; 1807 :     }
; 1808 : 
; 1809 :     SET_SF_RM_FROM_MASK( m3 );

  00252	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00257	85 c0		 test	 eax, eax
  00259	74 16		 je	 SHORT $LN18@z900_conve
  0025b	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00267	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026b	89 44 24 28	 mov	 DWORD PTR tv194[rsp], eax
  0026f	eb 22		 jmp	 SHORT $LN19@z900_conve
$LN18@z900_conve:
  00271	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00279	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0027f	83 e0 07	 and	 eax, 7
  00282	8b c0		 mov	 eax, eax
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0028b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028f	89 44 24 28	 mov	 DWORD PTR tv194[rsp], eax
$LN19@z900_conve:
  00293	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00298	8b c0		 mov	 eax, eax
  0029a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ad	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv194[rsp]
  002b2	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1810 :     op2 = regs->GR_G( r2 );

  002b5	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  002ba	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c2	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  002ca	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 1811 :     softfloat_exceptionFlags = 0;

  002cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d4	8b c0		 mov	 eax, eax
  002d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e9	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1812 :     op1 = i64_to_f128( op2 );

  002ed	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  002f2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  002f7	e8 00 00 00 00	 call	 i64_to_f128
  002fc	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  00301	48 8b f9	 mov	 rdi, rcx
  00304	48 8b f0	 mov	 rsi, rax
  00307	b9 10 00 00 00	 mov	 ecx, 16
  0030c	f3 a4		 rep movsb

; 1813 : 
; 1814 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0030e	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00312	d1 e0		 shl	 eax, 1
  00314	48 98		 cdqe
  00316	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00326	48 8b d0	 mov	 rdx, rax
  00329	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0032e	e8 00 00 00 00	 call	 z900_put_float128

; 1815 : }

  00333	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00338	48 33 cc	 xor	 rcx, rsp
  0033b	e8 00 00 00 00	 call	 __security_check_cookie
  00340	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00344	5f		 pop	 rdi
  00345	5e		 pop	 rsi
  00346	c3		 ret	 0
z900_convert_fix64_to_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv189 = 44
r2$ = 48
op2$ = 52
r1$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
z900_convert_fix32_to_bfp_short_reg PROC

; 1743 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1744 :     int        r1, r2;
; 1745 :     BYTE       m3, m4;
; 1746 :     S32        op2;
; 1747 :     float32_t  op1;
; 1748 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1749 : 
; 1750 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1751 : 
; 1752 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198976
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 1753 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 1754 : 
; 1755 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1756 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0018c	b8 01 00 00 00	 mov	 eax, 1
  00191	48 6b c0 04	 imul	 rax, rax, 4
  00195	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001a2	83 e0 04	 and	 eax, 4
  001a5	85 c0		 test	 eax, eax
  001a7	74 11		 je	 SHORT $LN13@z900_conve

; 1757 :         BFPRM_CHECK( m3, regs );

  001a9	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  001ae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	e8 00 00 00 00	 call	 z900_BFP_RM_check
  001b8	eb 25		 jmp	 SHORT $LN14@z900_conve
$LN13@z900_conve:

; 1758 :     else
; 1759 : #endif
; 1760 :     {
; 1761 :         if (m3 | m4)

  001ba	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001bf	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  001c4	0b c1		 or	 eax, ecx
  001c6	85 c0		 test	 eax, eax
  001c8	74 15		 je	 SHORT $LN15@z900_conve

; 1762 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001ca	ba 06 00 00 00	 mov	 edx, 6
  001cf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_conve:
$LN14@z900_conve:

; 1763 :     }
; 1764 : 
; 1765 :     SET_SF_RM_FROM_MASK( m3 );

  001df	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001e4	85 c0		 test	 eax, eax
  001e6	74 16		 je	 SHORT $LN19@z900_conve
  001e8	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
  001fc	eb 1f		 jmp	 SHORT $LN20@z900_conve
$LN19@z900_conve:
  001fe	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00203	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00209	83 e0 07	 and	 eax, 7
  0020c	8b c0		 mov	 eax, eax
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00215	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00219	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
$LN20@z900_conve:
  0021d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00222	8b c0		 mov	 eax, eax
  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00233	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00237	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv189[rsp]
  0023c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1766 :     op2 = regs->GR_L( r2 );

  0023f	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00244	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00250	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 1767 :     softfloat_exceptionFlags = 0;

  00254	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00259	8b c0		 mov	 eax, eax
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00261	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026e	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1768 :     op1 = i32_to_f32( op2 );

  00272	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  00276	e8 00 00 00 00	 call	 i32_to_f32
  0027b	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 1769 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  0027f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00283	d1 e0		 shl	 eax, 1
  00285	48 98		 cdqe
  00287	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00294	48 8b d0	 mov	 rdx, rax
  00297	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0029c	e8 00 00 00 00	 call	 z900_put_float32

; 1770 : 
; 1771 :     /* Inexact occurred and not masked by m4? */
; 1772 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  002a1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a6	8b c0		 mov	 eax, eax
  002a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ae	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002bb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002bf	85 c0		 test	 eax, eax
  002c1	74 35		 je	 SHORT $LN16@z900_conve
  002c3	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002c8	83 e0 04	 and	 eax, 4
  002cb	85 c0		 test	 eax, eax
  002cd	75 29		 jne	 SHORT $LN16@z900_conve

; 1773 :     {
; 1774 :         /* Yes, set FPC flags and test for a trap */
; 1775 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002cf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002d4	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002d9	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1776 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002dd	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002e6	85 c0		 test	 eax, eax
  002e8	74 0e		 je	 SHORT $LN17@z900_conve
  002ea	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002ee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002f3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@z900_conve:
$LN16@z900_conve:

; 1777 :     }
; 1778 : }

  002f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002fc	c3		 ret	 0
z900_convert_fix32_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
tv189 = 40
r2$ = 44
op2$ = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
z900_convert_fix32_to_bfp_long_reg PROC

; 1705 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1706 :     int        r1, r2;
; 1707 :     BYTE       m3, m4;
; 1708 :     S32        op2;
; 1709 :     float64_t  op1;
; 1710 : 
; 1711 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 08	 shr	 eax, 8
  00043	83 e0 0f	 and	 eax, 15
  00046	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 0c	 shr	 eax, 12
  00051	83 e0 0f	 and	 eax, 15
  00054	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 04	 cmp	 eax, 4
  00073	74 0c		 je	 SHORT $LN8@z900_conve
  00075	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1712 :     TXF_FLOAT_INSTR_CHECK( regs );

  00087	33 c0		 xor	 eax, eax
  00089	83 f8 01	 cmp	 eax, 1
  0008c	74 6f		 je	 SHORT $LN9@z900_conve
  0008e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00093	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0009a	85 c0		 test	 eax, eax
  0009c	74 5f		 je	 SHORT $LN9@z900_conve
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 23		 jne	 SHORT $LN10@z900_conve
  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b0	85 c0		 test	 eax, eax
  000b2	75 13		 jne	 SHORT $LN10@z900_conve
  000b4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c0	83 e0 04	 and	 eax, 4
  000c3	85 c0		 test	 eax, eax
  000c5	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000c7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d2	0f ba e8 0b	 bts	 eax, 11
  000d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000db	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198948
  000e8	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ee	ba 02 00 00 00	 mov	 edx, 2
  000f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  000fd	33 c0		 xor	 eax, eax
  000ff	85 c0		 test	 eax, eax
  00101	75 84		 jne	 SHORT $LN7@z900_conve

; 1713 :     BFPINST_CHECK( regs );

  00103	b8 08 00 00 00	 mov	 eax, 8
  00108	48 6b c0 01	 imul	 rax, rax, 1
  0010c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00111	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00119	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0011f	48 85 c0	 test	 rax, rax
  00122	74 3c		 je	 SHORT $LN12@z900_conve
  00124	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00129	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0012f	d1 e8		 shr	 eax, 1
  00131	83 e0 01	 and	 eax, 1
  00134	85 c0		 test	 eax, eax
  00136	74 4c		 je	 SHORT $LN11@z900_conve
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00144	b9 08 00 00 00	 mov	 ecx, 8
  00149	48 6b c9 01	 imul	 rcx, rcx, 1
  0014d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00155	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015b	48 85 c0	 test	 rax, rax
  0015e	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00160	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00165	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0016f	ba 07 00 00 00	 mov	 edx, 7
  00174	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 1714 : 
; 1715 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1716 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00184	b8 01 00 00 00	 mov	 eax, 1
  00189	48 6b c0 04	 imul	 rax, rax, 4
  0018d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0019a	83 e0 04	 and	 eax, 4
  0019d	85 c0		 test	 eax, eax
  0019f	74 11		 je	 SHORT $LN13@z900_conve

; 1717 :         BFPRM_CHECK( m3, regs );

  001a1	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  001a6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 z900_BFP_RM_check
  001b0	eb 25		 jmp	 SHORT $LN14@z900_conve
$LN13@z900_conve:

; 1718 :     else
; 1719 : #endif
; 1720 :     {
; 1721 :         if (m3 | m4)

  001b2	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001b7	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  001bc	0b c1		 or	 eax, ecx
  001be	85 c0		 test	 eax, eax
  001c0	74 15		 je	 SHORT $LN15@z900_conve

; 1722 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001c2	ba 06 00 00 00	 mov	 edx, 6
  001c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001cc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_conve:
$LN14@z900_conve:

; 1723 :     }
; 1724 : 
; 1725 :     SET_SF_RM_FROM_MASK( m3 );

  001d7	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001dc	85 c0		 test	 eax, eax
  001de	74 16		 je	 SHORT $LN17@z900_conve
  001e0	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	89 44 24 28	 mov	 DWORD PTR tv189[rsp], eax
  001f4	eb 1f		 jmp	 SHORT $LN18@z900_conve
$LN17@z900_conve:
  001f6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00201	83 e0 07	 and	 eax, 7
  00204	8b c0		 mov	 eax, eax
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0020d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00211	89 44 24 28	 mov	 DWORD PTR tv189[rsp], eax
$LN18@z900_conve:
  00215	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0021a	8b c0		 mov	 eax, eax
  0021c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00222	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022f	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv189[rsp]
  00234	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1726 :     op2 = regs->GR_L( r2 );

  00237	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0023c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00241	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00248	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 1727 :     softfloat_exceptionFlags = 0;

  0024c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00251	8b c0		 mov	 eax, eax
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00259	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00262	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00266	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1728 :     op1 = i32_to_f64( op2 );

  0026a	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  0026e	e8 00 00 00 00	 call	 i32_to_f64
  00273	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 1729 : 
; 1730 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00278	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0027c	d1 e0		 shl	 eax, 1
  0027e	48 98		 cdqe
  00280	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0028d	48 8b d0	 mov	 rdx, rax
  00290	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00295	e8 00 00 00 00	 call	 z900_put_float64

; 1731 : }

  0029a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0029e	c3		 ret	 0
z900_convert_fix32_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
tv199 = 40
r1$ = 44
r2$ = 48
op2$ = 52
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
z900_convert_fix32_to_bfp_ext_reg PROC

; 1669 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1670 :     int         r1, r2;
; 1671 :     BYTE        m3, m4;
; 1672 :     S32         op2;
; 1673 :     float128_t  op1;
; 1674 : 
; 1675 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 04	 shr	 eax, 4
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 08	 shr	 eax, 8
  00057	83 e0 0f	 and	 eax, 15
  0005a	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 0c	 shr	 eax, 12
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00088	33 c0		 xor	 eax, eax
  0008a	83 f8 04	 cmp	 eax, 4
  0008d	74 0f		 je	 SHORT $LN8@z900_conve
  0008f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1676 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a4	33 c0		 xor	 eax, eax
  000a6	83 f8 01	 cmp	 eax, 1
  000a9	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000af	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b7	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000be	85 c0		 test	 eax, eax
  000c0	74 6e		 je	 SHORT $LN9@z900_conve
  000c2	33 c0		 xor	 eax, eax
  000c4	85 c0		 test	 eax, eax
  000c6	75 29		 jne	 SHORT $LN10@z900_conve
  000c8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000d7	85 c0		 test	 eax, eax
  000d9	75 16		 jne	 SHORT $LN10@z900_conve
  000db	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ea	83 e0 04	 and	 eax, 4
  000ed	85 c0		 test	 eax, eax
  000ef	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ff	0f ba e8 0b	 bts	 eax, 11
  00103	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00111	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198920
  00118	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0011e	ba 02 00 00 00	 mov	 edx, 2
  00123	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00130	33 c0		 xor	 eax, eax
  00132	85 c0		 test	 eax, eax
  00134	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 1677 :     BFPINST_CHECK( regs );

  0013a	b8 08 00 00 00	 mov	 eax, 8
  0013f	48 6b c0 01	 imul	 rax, rax, 1
  00143	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00153	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00159	48 85 c0	 test	 rax, rax
  0015c	74 42		 je	 SHORT $LN12@z900_conve
  0015e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0016c	d1 e8		 shr	 eax, 1
  0016e	83 e0 01	 and	 eax, 1
  00171	85 c0		 test	 eax, eax
  00173	74 58		 je	 SHORT $LN11@z900_conve
  00175	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00184	b9 08 00 00 00	 mov	 ecx, 8
  00189	48 6b c9 01	 imul	 rcx, rcx, 1
  0018d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00195	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019b	48 85 c0	 test	 rax, rax
  0019e	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001b2	ba 07 00 00 00	 mov	 edx, 7
  001b7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 1678 :     BFPREGPAIR_CHECK( r1, regs );

  001cd	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001d1	83 e0 02	 and	 eax, 2
  001d4	85 c0		 test	 eax, eax
  001d6	74 1b		 je	 SHORT $LN13@z900_conve
  001d8	ba 06 00 00 00	 mov	 edx, 6
  001dd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 1679 : 
; 1680 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1681 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  001f3	b8 01 00 00 00	 mov	 eax, 1
  001f8	48 6b c0 04	 imul	 rax, rax, 4
  001fc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0020c	83 e0 04	 and	 eax, 4
  0020f	85 c0		 test	 eax, eax
  00211	74 14		 je	 SHORT $LN14@z900_conve

; 1682 :         BFPRM_CHECK( m3, regs );

  00213	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00218	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00220	e8 00 00 00 00	 call	 z900_BFP_RM_check
  00225	eb 2b		 jmp	 SHORT $LN15@z900_conve
$LN14@z900_conve:

; 1683 :     else
; 1684 : #endif
; 1685 :     {
; 1686 :         if (m3 | m4)

  00227	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0022c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  00231	0b c1		 or	 eax, ecx
  00233	85 c0		 test	 eax, eax
  00235	74 1b		 je	 SHORT $LN16@z900_conve

; 1687 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00237	ba 06 00 00 00	 mov	 edx, 6
  0023c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00244	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_conve:
$LN15@z900_conve:

; 1688 :     }
; 1689 : 
; 1690 :     op2 = regs->GR_L( r2 );

  00252	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00257	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00266	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 1691 :     SET_SF_RM_FROM_MASK( m3 );

  0026a	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0026f	85 c0		 test	 eax, eax
  00271	74 16		 je	 SHORT $LN18@z900_conve
  00273	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0027f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00283	89 44 24 28	 mov	 DWORD PTR tv199[rsp], eax
  00287	eb 22		 jmp	 SHORT $LN19@z900_conve
$LN18@z900_conve:
  00289	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00291	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00297	83 e0 07	 and	 eax, 7
  0029a	8b c0		 mov	 eax, eax
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a7	89 44 24 28	 mov	 DWORD PTR tv199[rsp], eax
$LN19@z900_conve:
  002ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002b0	8b c0		 mov	 eax, eax
  002b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c5	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv199[rsp]
  002ca	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1692 :     softfloat_exceptionFlags = 0;

  002cd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d2	8b c0		 mov	 eax, eax
  002d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002da	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e7	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1693 :     op1 = i32_to_f128( op2 );

  002eb	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  002ef	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  002f4	e8 00 00 00 00	 call	 i32_to_f128
  002f9	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  002fe	48 8b f9	 mov	 rdi, rcx
  00301	48 8b f0	 mov	 rsi, rax
  00304	b9 10 00 00 00	 mov	 ecx, 16
  00309	f3 a4		 rep movsb

; 1694 : 
; 1695 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0030b	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0030f	d1 e0		 shl	 eax, 1
  00311	48 98		 cdqe
  00313	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00323	48 8b d0	 mov	 rdx, rax
  00326	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0032b	e8 00 00 00 00	 call	 z900_put_float128

; 1696 : }

  00330	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00335	48 33 cc	 xor	 rcx, rsp
  00338	e8 00 00 00 00	 call	 __security_check_cookie
  0033d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00341	5f		 pop	 rdi
  00342	5e		 pop	 rsi
  00343	c3		 ret	 0
z900_convert_fix32_to_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op2_dataclass$ = 40
op2$ = 44
ieee_trap_conds$ = 48
tv200 = 52
tv222 = 56
tv228 = 60
op1$ = 64
r2$ = 72
r1$ = 76
inst$ = 96
regs$ = 104
z900_convert_bfp_short_to_fix64_reg PROC

; 2319 : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2320 :     int        r1, r2;
; 2321 :     BYTE       m3, m4, newcc;
; 2322 :     S64        op1;
; 2323 :     float32_t  op2;
; 2324 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2325 :     U32        op2_dataclass;
; 2326 : 
; 2327 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2328 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199288
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2329 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2330 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2331 : 
; 2332 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2333 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0019b	b8 01 00 00 00	 mov	 eax, 1
  001a0	48 6b c0 04	 imul	 rax, rax, 4
  001a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001b1	83 e0 04	 and	 eax, 4
  001b4	85 c0		 test	 eax, eax
  001b6	75 05		 jne	 SHORT $LN13@z900_conve

; 2334 : #endif
; 2335 :         m4 = 0;

  001b8	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN13@z900_conve:

; 2336 : 
; 2337 :     GET_FLOAT32_OP( op2, r2, regs );

  001bd	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  001c1	d1 e0		 shl	 eax, 1
  001c3	48 98		 cdqe
  001c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR op2$[rsp]
  001da	e8 00 00 00 00	 call	 z900_get_float32

; 2338 :     op2_dataclass = float32_class( op2 );

  001df	8b 4c 24 2c	 mov	 ecx, DWORD PTR op2$[rsp]
  001e3	e8 00 00 00 00	 call	 float32_class
  001e8	89 44 24 28	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2339 :     softfloat_exceptionFlags = 0;

  001ec	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f1	8b c0		 mov	 eax, eax
  001f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00202	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00206	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2340 : 
; 2341 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  0020a	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0020e	83 e0 0f	 and	 eax, 15
  00211	85 c0		 test	 eax, eax
  00213	74 5a		 je	 SHORT $LN14@z900_conve

; 2342 :                          float_class_pos_signaling_nan |
; 2343 :                          float_class_neg_quiet_nan     |
; 2344 :                          float_class_pos_quiet_nan ))
; 2345 :     {
; 2346 :         /* NaN input always returns maximum negative integer,
; 2347 :            cc3, and IEEE invalid exception */
; 2348 :         op1 = -(0x7FFFFFFFFFFFFFFFULL) - 1;

  00215	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0021f	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 2349 :         newcc = 3;

  00224	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2350 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00229	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022e	8b c0		 mov	 eax, eax
  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00236	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00243	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00247	83 c8 10	 or	 eax, 16
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00250	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00259	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0025f	45 8b c0	 mov	 r8d, r8d
  00262	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00266	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2351 :     }

  0026a	e9 13 01 00 00	 jmp	 $LN15@z900_conve
$LN14@z900_conve:

; 2352 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  0026f	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00273	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00278	85 c0		 test	 eax, eax
  0027a	74 13		 je	 SHORT $LN16@z900_conve

; 2353 :     {
; 2354 :         newcc = 0;

  0027c	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2355 :         op1 = 0;

  00281	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2356 :     }

  0028a	e9 f3 00 00 00	 jmp	 $LN17@z900_conve
$LN16@z900_conve:

; 2357 :     else
; 2358 :     {
; 2359 :         newcc = (op2.v & 0x80000000) ? 1 : 2;

  0028f	8b 44 24 2c	 mov	 eax, DWORD PTR op2$[rsp]
  00293	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00298	85 c0		 test	 eax, eax
  0029a	74 0a		 je	 SHORT $LN25@z900_conve
  0029c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  002a4	eb 08		 jmp	 SHORT $LN26@z900_conve
$LN25@z900_conve:
  002a6	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv200[rsp], 2
$LN26@z900_conve:
  002ae	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv200[rsp]
  002b3	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2360 : 
; 2361 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  002b7	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  002bb	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002c0	85 c0		 test	 eax, eax
  002c2	74 0e		 je	 SHORT $LN18@z900_conve

; 2362 :             op1 = 0;

  002c4	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0
  002cd	e9 b0 00 00 00	 jmp	 $LN19@z900_conve
$LN18@z900_conve:

; 2363 :         else
; 2364 :         {
; 2365 :             SET_SF_RM_FROM_MASK( m3 );

  002d2	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002d7	85 c0		 test	 eax, eax
  002d9	74 16		 je	 SHORT $LN27@z900_conve
  002db	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  002e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002eb	89 44 24 38	 mov	 DWORD PTR tv222[rsp], eax
  002ef	eb 1f		 jmp	 SHORT $LN28@z900_conve
$LN27@z900_conve:
  002f1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002f6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002fc	83 e0 07	 and	 eax, 7
  002ff	8b c0		 mov	 eax, eax
  00301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00308	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0030c	89 44 24 38	 mov	 DWORD PTR tv222[rsp], eax
$LN28@z900_conve:
  00310	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00315	8b c0		 mov	 eax, eax
  00317	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0031d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00326	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0032a	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv222[rsp]
  0032f	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2366 :             op1 = f32_to_i64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00332	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00337	83 e0 04	 and	 eax, 4
  0033a	85 c0		 test	 eax, eax
  0033c	75 0a		 jne	 SHORT $LN29@z900_conve
  0033e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv228[rsp], 1
  00346	eb 08		 jmp	 SHORT $LN30@z900_conve
$LN29@z900_conve:
  00348	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
$LN30@z900_conve:
  00350	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00355	8b c0		 mov	 eax, eax
  00357	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0035d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00366	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0036a	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv228[rsp]
  00370	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00374	8b 4c 24 2c	 mov	 ecx, DWORD PTR op2$[rsp]
  00378	e8 00 00 00 00	 call	 f32_to_i64
  0037d	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax
$LN19@z900_conve:
$LN17@z900_conve:
$LN15@z900_conve:

; 2367 :         }
; 2368 :     }
; 2369 : 
; 2370 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00382	33 c0		 xor	 eax, eax
  00384	83 f8 01	 cmp	 eax, 1
  00387	74 45		 je	 SHORT $LN20@z900_conve
  00389	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0038e	8b c0		 mov	 eax, eax
  00390	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00396	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0039f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a7	83 e0 10	 and	 eax, 16
  003aa	85 c0		 test	 eax, eax
  003ac	74 20		 je	 SHORT $LN20@z900_conve
  003ae	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  003b3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003b9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003be	85 c0		 test	 eax, eax
  003c0	74 0c		 je	 SHORT $LN20@z900_conve
  003c2	b2 80		 mov	 dl, 128			; 00000080H
  003c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_conve:

; 2371 : 
; 2372 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  003ce	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003d3	8b c0		 mov	 eax, eax
  003d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003db	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003e4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003e8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ec	83 e0 10	 and	 eax, 16
  003ef	85 c0		 test	 eax, eax
  003f1	74 52		 je	 SHORT $LN21@z900_conve

; 2373 :     {
; 2374 :         newcc = 3;

  003f3	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2375 : 
; 2376 :         if (!SUPPRESS_INEXACT( m4 ))

  003f8	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  003fd	83 e0 04	 and	 eax, 4
  00400	85 c0		 test	 eax, eax
  00402	75 41		 jne	 SHORT $LN22@z900_conve

; 2377 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00404	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00409	8b c0		 mov	 eax, eax
  0040b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00411	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0041a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0041e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00422	83 c8 01	 or	 eax, 1
  00425	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0042b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00434	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0043a	45 8b c0	 mov	 r8d, r8d
  0043d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00441	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN22@z900_conve:
$LN21@z900_conve:

; 2378 :     }
; 2379 : 
; 2380 :     regs->GR_G( r1 ) = op1;

  00445	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0044a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0044f	48 8b 54 24 40	 mov	 rdx, QWORD PTR op1$[rsp]
  00454	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2381 :     regs->psw.cc = newcc;

  0045c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00461	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00466	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2382 : 
; 2383 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00469	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0046e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00473	89 44 24 30	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2384 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00477	8b 44 24 30	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0047b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00480	85 c0		 test	 eax, eax
  00482	74 0e		 je	 SHORT $LN23@z900_conve
  00484	8b 54 24 30	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00488	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0048d	e8 00 00 00 00	 call	 ieee_cond_trap
$LN23@z900_conve:

; 2385 : }

  00492	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00496	c3		 ret	 0
z900_convert_bfp_short_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
op2$ = 48
ieee_trap_conds$ = 52
tv200 = 56
tv222 = 60
tv228 = 64
r2$ = 68
r1$ = 72
inst$ = 96
regs$ = 104
z900_convert_bfp_short_to_fix32_reg PROC

; 2098 : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2099 :     int        r1, r2;
; 2100 :     BYTE       m3, m4, newcc;
; 2101 :     S32        op1;
; 2102 :     float32_t  op2;
; 2103 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2104 :     U32        op2_dataclass;
; 2105 : 
; 2106 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2107 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199173
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2108 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2109 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2110 : 
; 2111 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2112 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0019b	b8 01 00 00 00	 mov	 eax, 1
  001a0	48 6b c0 04	 imul	 rax, rax, 4
  001a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001b1	83 e0 04	 and	 eax, 4
  001b4	85 c0		 test	 eax, eax
  001b6	75 05		 jne	 SHORT $LN13@z900_conve

; 2113 : #endif
; 2114 :         m4 = 0;

  001b8	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN13@z900_conve:

; 2115 : 
; 2116 :     GET_FLOAT32_OP( op2, r2, regs );

  001bd	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  001c1	d1 e0		 shl	 eax, 1
  001c3	48 98		 cdqe
  001c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  001da	e8 00 00 00 00	 call	 z900_get_float32

; 2117 :     op2_dataclass = float32_class( op2 );

  001df	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  001e3	e8 00 00 00 00	 call	 float32_class
  001e8	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2118 :     softfloat_exceptionFlags = 0;

  001ec	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f1	8b c0		 mov	 eax, eax
  001f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00202	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00206	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2119 : 
; 2120 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  0020a	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0020e	83 e0 0f	 and	 eax, 15
  00211	85 c0		 test	 eax, eax
  00213	74 53		 je	 SHORT $LN14@z900_conve

; 2121 :                          float_class_pos_signaling_nan |
; 2122 :                          float_class_neg_quiet_nan     |
; 2123 :                          float_class_pos_quiet_nan ))
; 2124 :     {
; 2125 :         /* NaN input always returns maximum negative integer,
; 2126 :            cc3, and IEEE invalid exception */
; 2127 :         op1 = -0x7FFFFFFF - 1;

  00215	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 2128 :         newcc = 3;

  0021d	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2129 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00222	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00227	8b c0		 mov	 eax, eax
  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00238	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00240	83 c8 10	 or	 eax, 16
  00243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00249	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00252	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00258	45 8b c0	 mov	 r8d, r8d
  0025b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025f	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2130 :     }

  00263	e9 10 01 00 00	 jmp	 $LN15@z900_conve
$LN14@z900_conve:

; 2131 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  00268	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0026c	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00271	85 c0		 test	 eax, eax
  00273	74 12		 je	 SHORT $LN16@z900_conve

; 2132 :     {
; 2133 :         newcc = 0;

  00275	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2134 :         op1 = 0;

  0027a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2135 :     }

  00282	e9 f1 00 00 00	 jmp	 $LN17@z900_conve
$LN16@z900_conve:

; 2136 :     else
; 2137 :     {
; 2138 :         newcc = (op2.v & 0x80000000) ? 1 : 2;

  00287	8b 44 24 30	 mov	 eax, DWORD PTR op2$[rsp]
  0028b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00290	85 c0		 test	 eax, eax
  00292	74 0a		 je	 SHORT $LN25@z900_conve
  00294	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  0029c	eb 08		 jmp	 SHORT $LN26@z900_conve
$LN25@z900_conve:
  0029e	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv200[rsp], 2
$LN26@z900_conve:
  002a6	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv200[rsp]
  002ab	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2139 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  002af	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  002b3	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002b8	85 c0		 test	 eax, eax
  002ba	74 0d		 je	 SHORT $LN18@z900_conve

; 2140 :             op1 = 0;

  002bc	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  002c4	e9 af 00 00 00	 jmp	 $LN19@z900_conve
$LN18@z900_conve:

; 2141 :         else
; 2142 :         {
; 2143 :             SET_SF_RM_FROM_MASK( m3 );

  002c9	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002ce	85 c0		 test	 eax, eax
  002d0	74 16		 je	 SHORT $LN27@z900_conve
  002d2	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  002de	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e2	89 44 24 3c	 mov	 DWORD PTR tv222[rsp], eax
  002e6	eb 1f		 jmp	 SHORT $LN28@z900_conve
$LN27@z900_conve:
  002e8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002ed	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002f3	83 e0 07	 and	 eax, 7
  002f6	8b c0		 mov	 eax, eax
  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00303	89 44 24 3c	 mov	 DWORD PTR tv222[rsp], eax
$LN28@z900_conve:
  00307	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0030c	8b c0		 mov	 eax, eax
  0030e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00314	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0031d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00321	0f b6 54 24 3c	 movzx	 edx, BYTE PTR tv222[rsp]
  00326	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2144 :             op1 = f32_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00329	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  0032e	83 e0 04	 and	 eax, 4
  00331	85 c0		 test	 eax, eax
  00333	75 0a		 jne	 SHORT $LN29@z900_conve
  00335	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv228[rsp], 1
  0033d	eb 08		 jmp	 SHORT $LN30@z900_conve
$LN29@z900_conve:
  0033f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
$LN30@z900_conve:
  00347	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0034c	8b c0		 mov	 eax, eax
  0034e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00354	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0035d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00361	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR tv228[rsp]
  00367	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0036b	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  0036f	e8 00 00 00 00	 call	 f32_to_i32
  00374	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN19@z900_conve:
$LN17@z900_conve:
$LN15@z900_conve:

; 2145 :         }
; 2146 :     }
; 2147 : 
; 2148 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00378	33 c0		 xor	 eax, eax
  0037a	83 f8 01	 cmp	 eax, 1
  0037d	74 45		 je	 SHORT $LN20@z900_conve
  0037f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00384	8b c0		 mov	 eax, eax
  00386	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0038c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00395	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00399	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039d	83 e0 10	 and	 eax, 16
  003a0	85 c0		 test	 eax, eax
  003a2	74 20		 je	 SHORT $LN20@z900_conve
  003a4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  003a9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003af	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003b4	85 c0		 test	 eax, eax
  003b6	74 0c		 je	 SHORT $LN20@z900_conve
  003b8	b2 80		 mov	 dl, 128			; 00000080H
  003ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003bf	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_conve:

; 2149 : 
; 2150 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  003c4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003c9	8b c0		 mov	 eax, eax
  003cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003d1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003da	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003de	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e2	83 e0 10	 and	 eax, 16
  003e5	85 c0		 test	 eax, eax
  003e7	74 52		 je	 SHORT $LN21@z900_conve

; 2151 :     {
; 2152 :         newcc = 3;

  003e9	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2153 : 
; 2154 :         if (!SUPPRESS_INEXACT( m4 ))

  003ee	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  003f3	83 e0 04	 and	 eax, 4
  003f6	85 c0		 test	 eax, eax
  003f8	75 41		 jne	 SHORT $LN22@z900_conve

; 2155 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  003fa	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003ff	8b c0		 mov	 eax, eax
  00401	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00407	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00410	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00414	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00418	83 c8 01	 or	 eax, 1
  0041b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00421	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0042a	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00430	45 8b c0	 mov	 r8d, r8d
  00433	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00437	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN22@z900_conve:
$LN21@z900_conve:

; 2156 :     }
; 2157 : 
; 2158 :     regs->GR_L( r1 ) = op1;

  0043b	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00440	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00445	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  00449	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2159 :     regs->psw.cc = newcc;

  00450	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00455	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0045a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2160 : 
; 2161 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  0045d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00462	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00467	89 44 24 34	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2162 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0046b	8b 44 24 34	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0046f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00474	85 c0		 test	 eax, eax
  00476	74 0e		 je	 SHORT $LN23@z900_conve
  00478	8b 54 24 34	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0047c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00481	e8 00 00 00 00	 call	 ieee_cond_trap
$LN23@z900_conve:

; 2163 : }

  00486	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0048a	c3		 ret	 0
z900_convert_bfp_short_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op2_dataclass$ = 40
ieee_trap_conds$ = 44
tv200 = 48
tv222 = 52
tv228 = 56
op1$ = 64
r2$ = 72
r1$ = 76
op2$ = 80
inst$ = 112
regs$ = 120
z900_convert_bfp_long_to_fix64_reg PROC

; 2245 : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2246 :     int        r1, r2;
; 2247 :     BYTE       m3, m4, newcc;
; 2248 :     S64        op1;
; 2249 :     float64_t  op2;
; 2250 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2251 :     U32        op2_dataclass;
; 2252 : 
; 2253 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2254 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199250
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2255 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2256 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2257 : 
; 2258 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2259 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0019b	b8 01 00 00 00	 mov	 eax, 1
  001a0	48 6b c0 04	 imul	 rax, rax, 4
  001a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001b1	83 e0 04	 and	 eax, 4
  001b4	85 c0		 test	 eax, eax
  001b6	75 05		 jne	 SHORT $LN13@z900_conve

; 2260 : #endif
; 2261 :         m4 = 0;

  001b8	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN13@z900_conve:

; 2262 : 
; 2263 :     GET_FLOAT64_OP( op2, r2, regs );

  001bd	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  001c1	d1 e0		 shl	 eax, 1
  001c3	48 98		 cdqe
  001c5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001da	e8 00 00 00 00	 call	 z900_get_float64

; 2264 :     op2_dataclass = float64_class( op2 );

  001df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  001e4	e8 00 00 00 00	 call	 float64_class
  001e9	89 44 24 28	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2265 :     softfloat_exceptionFlags = 0;

  001ed	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f2	8b c0		 mov	 eax, eax
  001f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001fa	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00203	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00207	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2266 : 
; 2267 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  0020b	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0020f	83 e0 0f	 and	 eax, 15
  00212	85 c0		 test	 eax, eax
  00214	74 5a		 je	 SHORT $LN14@z900_conve

; 2268 :                          float_class_pos_signaling_nan |
; 2269 :                          float_class_neg_quiet_nan     |
; 2270 :                          float_class_pos_quiet_nan ))
; 2271 :     {
; 2272 :         /* NaN input always returns maximum negative integer,
; 2273 :            cc3, and IEEE invalid exception */
; 2274 :         op1 = -(0x7FFFFFFFFFFFFFFFULL) - 1;

  00216	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00220	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 2275 :         newcc = 3;

  00225	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2276 :         softfloat_raiseFlags( softfloat_flag_invalid );

  0022a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022f	8b c0		 mov	 eax, eax
  00231	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00237	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00240	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00244	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00248	83 c8 10	 or	 eax, 16
  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00251	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025a	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00260	45 8b c0	 mov	 r8d, r8d
  00263	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00267	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2277 :     }

  0026b	e9 21 01 00 00	 jmp	 $LN15@z900_conve
$LN14@z900_conve:

; 2278 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  00270	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00274	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00279	85 c0		 test	 eax, eax
  0027b	74 13		 je	 SHORT $LN16@z900_conve

; 2279 :     {
; 2280 :         newcc = 0;

  0027d	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2281 :         op1 = 0;

  00282	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2282 :     }

  0028b	e9 01 01 00 00	 jmp	 $LN17@z900_conve
$LN16@z900_conve:

; 2283 :     else
; 2284 :     {
; 2285 :         newcc = (op2.v & 0x8000000000000000ULL) ? 1 : 2;

  00290	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0029a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  0029f	48 23 c8	 and	 rcx, rax
  002a2	48 8b c1	 mov	 rax, rcx
  002a5	48 85 c0	 test	 rax, rax
  002a8	74 0a		 je	 SHORT $LN25@z900_conve
  002aa	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  002b2	eb 08		 jmp	 SHORT $LN26@z900_conve
$LN25@z900_conve:
  002b4	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv200[rsp], 2
$LN26@z900_conve:
  002bc	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv200[rsp]
  002c1	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2286 : 
; 2287 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  002c5	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  002c9	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002ce	85 c0		 test	 eax, eax
  002d0	74 0e		 je	 SHORT $LN18@z900_conve

; 2288 :             op1 = 0;

  002d2	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0
  002db	e9 b1 00 00 00	 jmp	 $LN19@z900_conve
$LN18@z900_conve:

; 2289 :         else
; 2290 :         {
; 2291 :             SET_SF_RM_FROM_MASK( m3 );

  002e0	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002e5	85 c0		 test	 eax, eax
  002e7	74 16		 je	 SHORT $LN27@z900_conve
  002e9	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  002f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f9	89 44 24 34	 mov	 DWORD PTR tv222[rsp], eax
  002fd	eb 1f		 jmp	 SHORT $LN28@z900_conve
$LN27@z900_conve:
  002ff	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00304	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0030a	83 e0 07	 and	 eax, 7
  0030d	8b c0		 mov	 eax, eax
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00316	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031a	89 44 24 34	 mov	 DWORD PTR tv222[rsp], eax
$LN28@z900_conve:
  0031e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00323	8b c0		 mov	 eax, eax
  00325	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0032b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00334	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00338	0f b6 54 24 34	 movzx	 edx, BYTE PTR tv222[rsp]
  0033d	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2292 :             op1 = f64_to_i64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00340	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00345	83 e0 04	 and	 eax, 4
  00348	85 c0		 test	 eax, eax
  0034a	75 0a		 jne	 SHORT $LN29@z900_conve
  0034c	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv228[rsp], 1
  00354	eb 08		 jmp	 SHORT $LN30@z900_conve
$LN29@z900_conve:
  00356	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
$LN30@z900_conve:
  0035e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00363	8b c0		 mov	 eax, eax
  00365	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0036b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00374	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00378	44 0f b6 44 24
	38		 movzx	 r8d, BYTE PTR tv228[rsp]
  0037e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00382	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  00387	e8 00 00 00 00	 call	 f64_to_i64
  0038c	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax
$LN19@z900_conve:
$LN17@z900_conve:
$LN15@z900_conve:

; 2293 :         }
; 2294 :     }
; 2295 : 
; 2296 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00391	33 c0		 xor	 eax, eax
  00393	83 f8 01	 cmp	 eax, 1
  00396	74 45		 je	 SHORT $LN20@z900_conve
  00398	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0039d	8b c0		 mov	 eax, eax
  0039f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003ae	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b6	83 e0 10	 and	 eax, 16
  003b9	85 c0		 test	 eax, eax
  003bb	74 20		 je	 SHORT $LN20@z900_conve
  003bd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c2	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003c8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003cd	85 c0		 test	 eax, eax
  003cf	74 0c		 je	 SHORT $LN20@z900_conve
  003d1	b2 80		 mov	 dl, 128			; 00000080H
  003d3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003d8	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_conve:

; 2297 : 
; 2298 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  003dd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003e2	8b c0		 mov	 eax, eax
  003e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003ea	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003f3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003f7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003fb	83 e0 10	 and	 eax, 16
  003fe	85 c0		 test	 eax, eax
  00400	74 52		 je	 SHORT $LN21@z900_conve

; 2299 :     {
; 2300 :         newcc = 3;

  00402	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2301 : 
; 2302 :         if (!SUPPRESS_INEXACT( m4 ))

  00407	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  0040c	83 e0 04	 and	 eax, 4
  0040f	85 c0		 test	 eax, eax
  00411	75 41		 jne	 SHORT $LN22@z900_conve

; 2303 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00413	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00418	8b c0		 mov	 eax, eax
  0041a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00420	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00429	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0042d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00431	83 c8 01	 or	 eax, 1
  00434	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0043a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00443	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00449	45 8b c0	 mov	 r8d, r8d
  0044c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00450	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN22@z900_conve:
$LN21@z900_conve:

; 2304 :     }
; 2305 : 
; 2306 :     regs->GR_G( r1 ) = op1;

  00454	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00459	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0045e	48 8b 54 24 40	 mov	 rdx, QWORD PTR op1$[rsp]
  00463	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2307 :     regs->psw.cc = newcc;

  0046b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00470	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00475	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2308 : 
; 2309 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00478	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0047d	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00482	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2310 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00486	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0048a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0048f	85 c0		 test	 eax, eax
  00491	74 0e		 je	 SHORT $LN23@z900_conve
  00493	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00497	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0049c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN23@z900_conve:

; 2311 : }

  004a1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004a5	c3		 ret	 0
z900_convert_bfp_long_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
ieee_trap_conds$ = 48
tv200 = 52
tv222 = 56
tv228 = 60
r2$ = 64
r1$ = 68
op2$ = 72
inst$ = 96
regs$ = 104
z900_convert_bfp_long_to_fix32_reg PROC

; 2027 : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2028 :     int        r1, r2;
; 2029 :     BYTE       m3, m4, newcc;
; 2030 :     S32        op1;
; 2031 :     float64_t  op2;
; 2032 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2033 :     U32        op2_dataclass;
; 2034 : 
; 2035 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 40	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2036 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199135
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2037 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2038 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2039 : 
; 2040 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2041 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0019b	b8 01 00 00 00	 mov	 eax, 1
  001a0	48 6b c0 04	 imul	 rax, rax, 4
  001a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001b1	83 e0 04	 and	 eax, 4
  001b4	85 c0		 test	 eax, eax
  001b6	75 05		 jne	 SHORT $LN13@z900_conve

; 2042 : #endif
; 2043 :         m4 = 0;

  001b8	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN13@z900_conve:

; 2044 : 
; 2045 :     GET_FLOAT64_OP( op2, r2, regs );

  001bd	8b 44 24 40	 mov	 eax, DWORD PTR r2$[rsp]
  001c1	d1 e0		 shl	 eax, 1
  001c3	48 98		 cdqe
  001c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  001da	e8 00 00 00 00	 call	 z900_get_float64

; 2046 :     op2_dataclass = float64_class( op2 );

  001df	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  001e4	e8 00 00 00 00	 call	 float64_class
  001e9	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2047 :     softfloat_exceptionFlags = 0;

  001ed	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f2	8b c0		 mov	 eax, eax
  001f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001fa	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00203	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00207	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2048 : 
; 2049 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  0020b	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0020f	83 e0 0f	 and	 eax, 15
  00212	85 c0		 test	 eax, eax
  00214	74 53		 je	 SHORT $LN14@z900_conve

; 2050 :                          float_class_pos_signaling_nan |
; 2051 :                          float_class_neg_quiet_nan     |
; 2052 :                          float_class_pos_quiet_nan ))
; 2053 :     {
; 2054 :         /* NaN input always returns maximum negative integer,
; 2055 :            cc3, and IEEE invalid exception */
; 2056 :         op1 = -0x7FFFFFFF - 1;

  00216	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 2057 :         newcc = 3;

  0021e	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2058 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00223	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00228	8b c0		 mov	 eax, eax
  0022a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00230	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00239	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00241	83 c8 10	 or	 eax, 16
  00244	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0024a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00253	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00259	45 8b c0	 mov	 r8d, r8d
  0025c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00260	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2059 :     }

  00264	e9 1e 01 00 00	 jmp	 $LN15@z900_conve
$LN14@z900_conve:

; 2060 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  00269	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0026d	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00272	85 c0		 test	 eax, eax
  00274	74 12		 je	 SHORT $LN16@z900_conve

; 2061 :     {
; 2062 :         newcc = 0;

  00276	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2063 :         op1 = 0;

  0027b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2064 :     }

  00283	e9 ff 00 00 00	 jmp	 $LN17@z900_conve
$LN16@z900_conve:

; 2065 :     else
; 2066 :     {
; 2067 :         newcc = (op2.v & 0x8000000000000000ULL) ? 1 : 2;

  00288	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00292	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00297	48 23 c8	 and	 rcx, rax
  0029a	48 8b c1	 mov	 rax, rcx
  0029d	48 85 c0	 test	 rax, rax
  002a0	74 0a		 je	 SHORT $LN25@z900_conve
  002a2	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  002aa	eb 08		 jmp	 SHORT $LN26@z900_conve
$LN25@z900_conve:
  002ac	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv200[rsp], 2
$LN26@z900_conve:
  002b4	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv200[rsp]
  002b9	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2068 : 
; 2069 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  002bd	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  002c1	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002c6	85 c0		 test	 eax, eax
  002c8	74 0d		 je	 SHORT $LN18@z900_conve

; 2070 :             op1 = 0;

  002ca	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  002d2	e9 b0 00 00 00	 jmp	 $LN19@z900_conve
$LN18@z900_conve:

; 2071 :         else
; 2072 :         {
; 2073 :             SET_SF_RM_FROM_MASK( m3 );

  002d7	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002dc	85 c0		 test	 eax, eax
  002de	74 16		 je	 SHORT $LN27@z900_conve
  002e0	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  002ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f0	89 44 24 38	 mov	 DWORD PTR tv222[rsp], eax
  002f4	eb 1f		 jmp	 SHORT $LN28@z900_conve
$LN27@z900_conve:
  002f6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002fb	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00301	83 e0 07	 and	 eax, 7
  00304	8b c0		 mov	 eax, eax
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0030d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00311	89 44 24 38	 mov	 DWORD PTR tv222[rsp], eax
$LN28@z900_conve:
  00315	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0031a	8b c0		 mov	 eax, eax
  0031c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00322	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0032b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0032f	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv222[rsp]
  00334	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2074 :             op1 = f64_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00337	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  0033c	83 e0 04	 and	 eax, 4
  0033f	85 c0		 test	 eax, eax
  00341	75 0a		 jne	 SHORT $LN29@z900_conve
  00343	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv228[rsp], 1
  0034b	eb 08		 jmp	 SHORT $LN30@z900_conve
$LN29@z900_conve:
  0034d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
$LN30@z900_conve:
  00355	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0035a	8b c0		 mov	 eax, eax
  0035c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00362	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0036b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0036f	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv228[rsp]
  00375	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00379	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  0037e	e8 00 00 00 00	 call	 f64_to_i32
  00383	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN19@z900_conve:
$LN17@z900_conve:
$LN15@z900_conve:

; 2075 :         }
; 2076 :     }
; 2077 : 
; 2078 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00387	33 c0		 xor	 eax, eax
  00389	83 f8 01	 cmp	 eax, 1
  0038c	74 45		 je	 SHORT $LN20@z900_conve
  0038e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00393	8b c0		 mov	 eax, eax
  00395	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0039b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003a4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ac	83 e0 10	 and	 eax, 16
  003af	85 c0		 test	 eax, eax
  003b1	74 20		 je	 SHORT $LN20@z900_conve
  003b3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003be	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003c3	85 c0		 test	 eax, eax
  003c5	74 0c		 je	 SHORT $LN20@z900_conve
  003c7	b2 80		 mov	 dl, 128			; 00000080H
  003c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003ce	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_conve:

; 2079 : 
; 2080 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  003d3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003d8	8b c0		 mov	 eax, eax
  003da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003e0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003e9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003ed	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003f1	83 e0 10	 and	 eax, 16
  003f4	85 c0		 test	 eax, eax
  003f6	74 52		 je	 SHORT $LN21@z900_conve

; 2081 :     {
; 2082 :         newcc = 3;

  003f8	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2083 :         if (!SUPPRESS_INEXACT( m4 ))

  003fd	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00402	83 e0 04	 and	 eax, 4
  00405	85 c0		 test	 eax, eax
  00407	75 41		 jne	 SHORT $LN22@z900_conve

; 2084 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00409	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0040e	8b c0		 mov	 eax, eax
  00410	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00416	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0041f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00423	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00427	83 c8 01	 or	 eax, 1
  0042a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00430	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00439	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0043f	45 8b c0	 mov	 r8d, r8d
  00442	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00446	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN22@z900_conve:
$LN21@z900_conve:

; 2085 :     }
; 2086 : 
; 2087 :     regs->GR_L( r1 ) = op1;

  0044a	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  0044f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00454	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  00458	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2088 :     regs->psw.cc = newcc;

  0045f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00464	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00469	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2089 : 
; 2090 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  0046c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00471	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00476	89 44 24 30	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2091 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0047a	8b 44 24 30	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0047e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00483	85 c0		 test	 eax, eax
  00485	74 0e		 je	 SHORT $LN23@z900_conve
  00487	8b 54 24 30	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0048b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00490	e8 00 00 00 00	 call	 ieee_cond_trap
$LN23@z900_conve:

; 2092 : }

  00495	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00499	c3		 ret	 0
z900_convert_bfp_long_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op2_dataclass$ = 40
ieee_trap_conds$ = 44
r2$ = 48
tv207 = 52
tv229 = 56
tv235 = 60
op1$ = 64
r1$ = 72
tv387 = 80
tv306 = 88
$T2 = 96
$T3 = 112
op2$ = 128
__$ArrayPad$ = 144
inst$ = 192
regs$ = 200
z900_convert_bfp_ext_to_fix64_reg PROC

; 2170 : {

$LN32:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2171 :     int         r1, r2;
; 2172 :     BYTE        m3, m4, newcc;
; 2173 :     S64         op1;
; 2174 :     float128_t  op2;
; 2175 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2176 :     U32         op2_dataclass;
; 2177 : 
; 2178 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0007a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN8@z900_conve
  0009d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2179 :     TXF_FLOAT_INSTR_CHECK( regs );

  000b2	33 c0		 xor	 eax, eax
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000bd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000cc	85 c0		 test	 eax, eax
  000ce	74 6e		 je	 SHORT $LN9@z900_conve
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 29		 jne	 SHORT $LN10@z900_conve
  000d6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000e5	85 c0		 test	 eax, eax
  000e7	75 16		 jne	 SHORT $LN10@z900_conve
  000e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000f8	83 e0 04	 and	 eax, 4
  000fb	85 c0		 test	 eax, eax
  000fd	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000ff	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010d	0f ba e8 0b	 bts	 eax, 11
  00111	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199211
  00126	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012c	ba 02 00 00 00	 mov	 edx, 2
  00131	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2180 :     BFPINST_CHECK( regs );

  00148	b8 08 00 00 00	 mov	 eax, 8
  0014d	48 6b c0 01	 imul	 rax, rax, 1
  00151	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00161	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00167	48 85 c0	 test	 rax, rax
  0016a	74 42		 je	 SHORT $LN12@z900_conve
  0016c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017a	d1 e8		 shr	 eax, 1
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 58		 je	 SHORT $LN11@z900_conve
  00183	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00192	b9 08 00 00 00	 mov	 ecx, 8
  00197	48 6b c9 01	 imul	 rcx, rcx, 1
  0019b	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001a3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a9	48 85 c0	 test	 rax, rax
  001ac	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001ae	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001c0	ba 07 00 00 00	 mov	 edx, 7
  001c5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2181 :     BFPREGPAIR_CHECK( r2, regs );

  001db	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  001df	83 e0 02	 and	 eax, 2
  001e2	85 c0		 test	 eax, eax
  001e4	74 1b		 je	 SHORT $LN13@z900_conve
  001e6	ba 06 00 00 00	 mov	 edx, 6
  001eb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2182 :     BFPRM_CHECK( m3, regs );

  00201	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  00206	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020e	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2183 : 
; 2184 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2185 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 04	 imul	 rax, rax, 4
  0021c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00224	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0022c	83 e0 04	 and	 eax, 4
  0022f	85 c0		 test	 eax, eax
  00231	75 05		 jne	 SHORT $LN14@z900_conve

; 2186 : #endif
; 2187 :         m4 = 0;

  00233	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN14@z900_conve:

; 2188 : 
; 2189 :     GET_FLOAT128_OP( op2, r2, regs );

  00238	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0023c	d1 e0		 shl	 eax, 1
  0023e	48 98		 cdqe
  00240	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00248	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00250	48 8b d0	 mov	 rdx, rax
  00253	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0025b	e8 00 00 00 00	 call	 z900_get_float128

; 2190 :     op2_dataclass = float128_class( op2 );

  00260	48 8d 44 24 60	 lea	 rax, QWORD PTR $T2[rsp]
  00265	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0026d	48 8b f8	 mov	 rdi, rax
  00270	48 8b f1	 mov	 rsi, rcx
  00273	b9 10 00 00 00	 mov	 ecx, 16
  00278	f3 a4		 rep movsb
  0027a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  0027f	e8 00 00 00 00	 call	 float128_class
  00284	89 44 24 28	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2191 :     softfloat_exceptionFlags = 0;

  00288	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0028d	8b c0		 mov	 eax, eax
  0028f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00295	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a2	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2192 : 
; 2193 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  002a6	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  002aa	83 e0 0f	 and	 eax, 15
  002ad	85 c0		 test	 eax, eax
  002af	74 57		 je	 SHORT $LN15@z900_conve

; 2194 :                          float_class_pos_signaling_nan |
; 2195 :                          float_class_neg_quiet_nan     |
; 2196 :                          float_class_pos_quiet_nan ))
; 2197 :     {
; 2198 :         /* NaN input always returns maximum negative integer,
; 2199 :            cc3, and IEEE invalid exception */
; 2200 :         op1 = -(0x7FFFFFFFFFFFFFFFULL) - 1;

  002b1	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  002bb	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 2201 :         newcc = 3;

  002c0	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2202 :         softfloat_raiseFlags( softfloat_flag_invalid );

  002c5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ca	8b c0		 mov	 eax, eax
  002cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002db	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e3	83 c8 10	 or	 eax, 16
  002e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ec	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f5	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  002fa	8b ff		 mov	 edi, edi
  002fc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00300	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 2203 :     }

  00303	e9 5b 01 00 00	 jmp	 $LN16@z900_conve
$LN15@z900_conve:

; 2204 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  00308	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0030c	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00311	85 c0		 test	 eax, eax
  00313	74 13		 je	 SHORT $LN17@z900_conve

; 2205 :     {
; 2206 :         newcc = 0;

  00315	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2207 :         op1 = 0;

  0031a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2208 :     }

  00323	e9 3b 01 00 00	 jmp	 $LN18@z900_conve
$LN17@z900_conve:

; 2209 :     else
; 2210 :     {
; 2211 :         newcc = (op2.v[FLOAT128_HI] & 0x8000000000000000ULL) ? 1 : 2;

  00328	b8 08 00 00 00	 mov	 eax, 8
  0032d	48 6b c0 01	 imul	 rax, rax, 1
  00331	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0033b	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00343	48 23 c1	 and	 rax, rcx
  00346	48 85 c0	 test	 rax, rax
  00349	74 0a		 je	 SHORT $LN26@z900_conve
  0034b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  00353	eb 08		 jmp	 SHORT $LN27@z900_conve
$LN26@z900_conve:
  00355	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv207[rsp], 2
$LN27@z900_conve:
  0035d	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv207[rsp]
  00362	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2212 : 
; 2213 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  00366	8b 44 24 28	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0036a	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0036f	85 c0		 test	 eax, eax
  00371	74 0e		 je	 SHORT $LN19@z900_conve

; 2214 :             op1 = 0;

  00373	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0
  0037c	e9 e2 00 00 00	 jmp	 $LN20@z900_conve
$LN19@z900_conve:

; 2215 :         else
; 2216 :         {
; 2217 :             SET_SF_RM_FROM_MASK( m3 );

  00381	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  00386	85 c0		 test	 eax, eax
  00388	74 16		 je	 SHORT $LN28@z900_conve
  0038a	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  0038f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00396	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039a	89 44 24 38	 mov	 DWORD PTR tv229[rsp], eax
  0039e	eb 22		 jmp	 SHORT $LN29@z900_conve
$LN28@z900_conve:
  003a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003ae	83 e0 07	 and	 eax, 7
  003b1	8b c0		 mov	 eax, eax
  003b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  003ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003be	89 44 24 38	 mov	 DWORD PTR tv229[rsp], eax
$LN29@z900_conve:
  003c2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  003c7	8b c0		 mov	 eax, eax
  003c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003cf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003d8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003dc	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv229[rsp]
  003e1	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2218 :             op1 = f128_to_i64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  003e4	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  003e9	83 e0 04	 and	 eax, 4
  003ec	85 c0		 test	 eax, eax
  003ee	75 0a		 jne	 SHORT $LN30@z900_conve
  003f0	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv235[rsp], 1
  003f8	eb 08		 jmp	 SHORT $LN31@z900_conve
$LN30@z900_conve:
  003fa	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv235[rsp], 0
$LN31@z900_conve:
  00402	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00407	8b c0		 mov	 eax, eax
  00409	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0040f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00418	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0041c	48 89 4c 24 58	 mov	 QWORD PTR tv306[rsp], rcx
  00421	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T3[rsp]
  00426	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR op2$[rsp]
  0042e	48 89 7c 24 50	 mov	 QWORD PTR tv387[rsp], rdi
  00433	48 8b fa	 mov	 rdi, rdx
  00436	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv387[rsp]
  0043b	48 8b f2	 mov	 rsi, rdx
  0043e	b9 10 00 00 00	 mov	 ecx, 16
  00443	f3 a4		 rep movsb
  00445	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv235[rsp]
  0044b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv306[rsp]
  00450	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00454	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T3[rsp]
  00459	e8 00 00 00 00	 call	 f128_to_i64
  0045e	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax
$LN20@z900_conve:
$LN18@z900_conve:
$LN16@z900_conve:

; 2219 :         }
; 2220 :     }
; 2221 : 
; 2222 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00463	33 c0		 xor	 eax, eax
  00465	83 f8 01	 cmp	 eax, 1
  00468	74 4b		 je	 SHORT $LN21@z900_conve
  0046a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0046f	8b c0		 mov	 eax, eax
  00471	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00477	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00480	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00484	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00488	83 e0 10	 and	 eax, 16
  0048b	85 c0		 test	 eax, eax
  0048d	74 26		 je	 SHORT $LN21@z900_conve
  0048f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00497	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0049d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  004a2	85 c0		 test	 eax, eax
  004a4	74 0f		 je	 SHORT $LN21@z900_conve
  004a6	b2 80		 mov	 dl, 128			; 00000080H
  004a8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b0	e8 00 00 00 00	 call	 ieee_trap
$LN21@z900_conve:

; 2223 : 
; 2224 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  004b5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  004ba	8b c0		 mov	 eax, eax
  004bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004c2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004cb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d3	83 e0 10	 and	 eax, 16
  004d6	85 c0		 test	 eax, eax
  004d8	74 4f		 je	 SHORT $LN22@z900_conve

; 2225 :     {
; 2226 :         newcc = 3;

  004da	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2227 : 
; 2228 :         if (!SUPPRESS_INEXACT( m4 ))

  004df	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  004e4	83 e0 04	 and	 eax, 4
  004e7	85 c0		 test	 eax, eax
  004e9	75 3e		 jne	 SHORT $LN23@z900_conve

; 2229 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  004eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  004f0	8b c0		 mov	 eax, eax
  004f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004f8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00501	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00505	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00509	83 c8 01	 or	 eax, 1
  0050c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00512	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0051b	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00520	8b ff		 mov	 edi, edi
  00522	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00526	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN23@z900_conve:
$LN22@z900_conve:

; 2230 :     }
; 2231 : 
; 2232 :     regs->GR_G( r1 ) = op1;

  00529	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0052e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00536	48 8b 54 24 40	 mov	 rdx, QWORD PTR op1$[rsp]
  0053b	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2233 :     regs->psw.cc = newcc;

  00543	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00550	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2234 : 
; 2235 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00553	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00560	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2236 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00564	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00568	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0056d	85 c0		 test	 eax, eax
  0056f	74 11		 je	 SHORT $LN24@z900_conve
  00571	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00575	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057d	e8 00 00 00 00	 call	 ieee_cond_trap
$LN24@z900_conve:

; 2237 : }

  00582	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0058a	48 33 cc	 xor	 rcx, rsp
  0058d	e8 00 00 00 00	 call	 __security_check_cookie
  00592	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00599	5f		 pop	 rdi
  0059a	5e		 pop	 rsi
  0059b	c3		 ret	 0
z900_convert_bfp_ext_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
ieee_trap_conds$ = 48
r2$ = 52
tv207 = 56
tv229 = 60
tv235 = 64
r1$ = 68
tv387 = 72
tv306 = 80
$T2 = 96
$T3 = 112
op2$ = 128
__$ArrayPad$ = 144
inst$ = 192
regs$ = 200
z900_convert_bfp_ext_to_fix32_reg PROC

; 1952 : {

$LN32:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1953 :     int         r1, r2;
; 1954 :     BYTE        m3, m4, newcc;
; 1955 :     S32         op1;
; 1956 :     float128_t  op2;
; 1957 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1958 :     U32         op2_dataclass;
; 1959 : 
; 1960 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0007a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN8@z900_conve
  0009d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 1961 :     TXF_FLOAT_INSTR_CHECK( regs );

  000b2	33 c0		 xor	 eax, eax
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000bd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000cc	85 c0		 test	 eax, eax
  000ce	74 6e		 je	 SHORT $LN9@z900_conve
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 29		 jne	 SHORT $LN10@z900_conve
  000d6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000e5	85 c0		 test	 eax, eax
  000e7	75 16		 jne	 SHORT $LN10@z900_conve
  000e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000f8	83 e0 04	 and	 eax, 4
  000fb	85 c0		 test	 eax, eax
  000fd	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000ff	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010d	0f ba e8 0b	 bts	 eax, 11
  00111	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199096
  00126	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012c	ba 02 00 00 00	 mov	 edx, 2
  00131	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 1962 :     BFPINST_CHECK( regs );

  00148	b8 08 00 00 00	 mov	 eax, 8
  0014d	48 6b c0 01	 imul	 rax, rax, 1
  00151	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00161	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00167	48 85 c0	 test	 rax, rax
  0016a	74 42		 je	 SHORT $LN12@z900_conve
  0016c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017a	d1 e8		 shr	 eax, 1
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 58		 je	 SHORT $LN11@z900_conve
  00183	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00192	b9 08 00 00 00	 mov	 ecx, 8
  00197	48 6b c9 01	 imul	 rcx, rcx, 1
  0019b	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001a3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a9	48 85 c0	 test	 rax, rax
  001ac	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001ae	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001c0	ba 07 00 00 00	 mov	 edx, 7
  001c5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 1963 :     BFPREGPAIR_CHECK( r2, regs );

  001db	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  001df	83 e0 02	 and	 eax, 2
  001e2	85 c0		 test	 eax, eax
  001e4	74 1b		 je	 SHORT $LN13@z900_conve
  001e6	ba 06 00 00 00	 mov	 edx, 6
  001eb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 1964 :     BFPRM_CHECK( m3, regs );

  00201	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  00206	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020e	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 1965 : 
; 1966 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1967 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 04	 imul	 rax, rax, 4
  0021c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00224	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0022c	83 e0 04	 and	 eax, 4
  0022f	85 c0		 test	 eax, eax
  00231	75 05		 jne	 SHORT $LN14@z900_conve

; 1968 : #endif
; 1969 :         m4 = 0;

  00233	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN14@z900_conve:

; 1970 : 
; 1971 :     GET_FLOAT128_OP( op2, r2, regs );

  00238	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0023c	d1 e0		 shl	 eax, 1
  0023e	48 98		 cdqe
  00240	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00248	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00250	48 8b d0	 mov	 rdx, rax
  00253	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0025b	e8 00 00 00 00	 call	 z900_get_float128

; 1972 :     op2_dataclass = float128_class( op2 );

  00260	48 8d 44 24 60	 lea	 rax, QWORD PTR $T2[rsp]
  00265	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0026d	48 8b f8	 mov	 rdi, rax
  00270	48 8b f1	 mov	 rsi, rcx
  00273	b9 10 00 00 00	 mov	 ecx, 16
  00278	f3 a4		 rep movsb
  0027a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  0027f	e8 00 00 00 00	 call	 float128_class
  00284	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 1973 :     softfloat_exceptionFlags = 0;

  00288	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0028d	8b c0		 mov	 eax, eax
  0028f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00295	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a2	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1974 : 
; 1975 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  002a6	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  002aa	83 e0 0f	 and	 eax, 15
  002ad	85 c0		 test	 eax, eax
  002af	74 50		 je	 SHORT $LN15@z900_conve

; 1976 :                          float_class_pos_signaling_nan |
; 1977 :                          float_class_neg_quiet_nan     |
; 1978 :                          float_class_pos_quiet_nan ))
; 1979 :     {
; 1980 :         /* NaN input always returns maximum negative integer,
; 1981 :            cc3, and IEEE invalid exception */
; 1982 :         op1 = -0x7FFFFFFF - 1;

  002b1	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 1983 :         newcc = 3;

  002b9	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 1984 :         softfloat_raiseFlags( softfloat_flag_invalid );

  002be	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c3	8b c0		 mov	 eax, eax
  002c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002cb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002dc	83 c8 10	 or	 eax, 16
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ee	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  002f3	8b ff		 mov	 edi, edi
  002f5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002f9	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 1985 :     }

  002fc	e9 58 01 00 00	 jmp	 $LN16@z900_conve
$LN15@z900_conve:

; 1986 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  00301	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00305	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  0030a	85 c0		 test	 eax, eax
  0030c	74 12		 je	 SHORT $LN17@z900_conve

; 1987 :     {
; 1988 :         newcc = 0;

  0030e	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 1989 :         op1 = 0;

  00313	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 1990 :     }

  0031b	e9 39 01 00 00	 jmp	 $LN18@z900_conve
$LN17@z900_conve:

; 1991 :     else
; 1992 :     {
; 1993 :         newcc = (op2.v[FLOAT128_HI] & 0x8000000000000000ULL) ? 1 : 2;

  00320	b8 08 00 00 00	 mov	 eax, 8
  00325	48 6b c0 01	 imul	 rax, rax, 1
  00329	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00333	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0033b	48 23 c1	 and	 rax, rcx
  0033e	48 85 c0	 test	 rax, rax
  00341	74 0a		 je	 SHORT $LN26@z900_conve
  00343	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  0034b	eb 08		 jmp	 SHORT $LN27@z900_conve
$LN26@z900_conve:
  0034d	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv207[rsp], 2
$LN27@z900_conve:
  00355	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv207[rsp]
  0035a	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1994 : 
; 1995 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  0035e	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00362	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00367	85 c0		 test	 eax, eax
  00369	74 0d		 je	 SHORT $LN19@z900_conve

; 1996 :             op1 = 0;

  0036b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  00373	e9 e1 00 00 00	 jmp	 $LN20@z900_conve
$LN19@z900_conve:

; 1997 :         else
; 1998 :         {
; 1999 :             SET_SF_RM_FROM_MASK( m3 );

  00378	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  0037d	85 c0		 test	 eax, eax
  0037f	74 16		 je	 SHORT $LN28@z900_conve
  00381	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  00386	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0038d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00391	89 44 24 3c	 mov	 DWORD PTR tv229[rsp], eax
  00395	eb 22		 jmp	 SHORT $LN29@z900_conve
$LN28@z900_conve:
  00397	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003a5	83 e0 07	 and	 eax, 7
  003a8	8b c0		 mov	 eax, eax
  003aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  003b1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b5	89 44 24 3c	 mov	 DWORD PTR tv229[rsp], eax
$LN29@z900_conve:
  003b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  003be	8b c0		 mov	 eax, eax
  003c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003c6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003cf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003d3	0f b6 54 24 3c	 movzx	 edx, BYTE PTR tv229[rsp]
  003d8	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2000 :             op1 = f128_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  003db	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  003e0	83 e0 04	 and	 eax, 4
  003e3	85 c0		 test	 eax, eax
  003e5	75 0a		 jne	 SHORT $LN30@z900_conve
  003e7	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv235[rsp], 1
  003ef	eb 08		 jmp	 SHORT $LN31@z900_conve
$LN30@z900_conve:
  003f1	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv235[rsp], 0
$LN31@z900_conve:
  003f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  003fe	8b c0		 mov	 eax, eax
  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00406	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0040f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00413	48 89 4c 24 50	 mov	 QWORD PTR tv306[rsp], rcx
  00418	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T3[rsp]
  0041d	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR op2$[rsp]
  00425	48 89 7c 24 48	 mov	 QWORD PTR tv387[rsp], rdi
  0042a	48 8b fa	 mov	 rdi, rdx
  0042d	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv387[rsp]
  00432	48 8b f2	 mov	 rsi, rdx
  00435	b9 10 00 00 00	 mov	 ecx, 16
  0043a	f3 a4		 rep movsb
  0043c	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR tv235[rsp]
  00442	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv306[rsp]
  00447	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0044b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T3[rsp]
  00450	e8 00 00 00 00	 call	 f128_to_i32
  00455	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN20@z900_conve:
$LN18@z900_conve:
$LN16@z900_conve:

; 2001 :         }
; 2002 :     }
; 2003 : 
; 2004 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00459	33 c0		 xor	 eax, eax
  0045b	83 f8 01	 cmp	 eax, 1
  0045e	74 4b		 je	 SHORT $LN21@z900_conve
  00460	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00465	8b c0		 mov	 eax, eax
  00467	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0046d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00476	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0047a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0047e	83 e0 10	 and	 eax, 16
  00481	85 c0		 test	 eax, eax
  00483	74 26		 je	 SHORT $LN21@z900_conve
  00485	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0048d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00493	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00498	85 c0		 test	 eax, eax
  0049a	74 0f		 je	 SHORT $LN21@z900_conve
  0049c	b2 80		 mov	 dl, 128			; 00000080H
  0049e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a6	e8 00 00 00 00	 call	 ieee_trap
$LN21@z900_conve:

; 2005 : 
; 2006 :     /* Non-trappable Invalid exception? */
; 2007 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  004ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  004b0	8b c0		 mov	 eax, eax
  004b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004c5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004c9	83 e0 10	 and	 eax, 16
  004cc	85 c0		 test	 eax, eax
  004ce	74 4f		 je	 SHORT $LN22@z900_conve

; 2008 :     {
; 2009 :         newcc = 3;

  004d0	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2010 : 
; 2011 :         /* Inexact not suppressed? */
; 2012 :         if (!SUPPRESS_INEXACT( m4 ))

  004d5	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  004da	83 e0 04	 and	 eax, 4
  004dd	85 c0		 test	 eax, eax
  004df	75 3e		 jne	 SHORT $LN23@z900_conve

; 2013 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  004e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  004e6	8b c0		 mov	 eax, eax
  004e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004f7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004ff	83 c8 01	 or	 eax, 1
  00502	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00508	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00511	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00516	8b ff		 mov	 edi, edi
  00518	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0051c	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN23@z900_conve:
$LN22@z900_conve:

; 2014 :     }
; 2015 : 
; 2016 :     regs->GR_L( r1 ) = op1;

  0051f	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  00524	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052c	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  00530	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2017 :     regs->psw.cc = newcc;

  00537	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00544	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2018 : 
; 2019 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00547	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054f	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00554	89 44 24 30	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2020 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00558	8b 44 24 30	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0055c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00561	85 c0		 test	 eax, eax
  00563	74 11		 je	 SHORT $LN24@z900_conve
  00565	8b 54 24 30	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00569	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00571	e8 00 00 00 00	 call	 ieee_cond_trap
$LN24@z900_conve:

; 2021 : }

  00576	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0057e	48 33 cc	 xor	 rcx, rsp
  00581	e8 00 00 00 00	 call	 __security_check_cookie
  00586	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0058d	5f		 pop	 rdi
  0058e	5e		 pop	 rsi
  0058f	c3		 ret	 0
z900_convert_bfp_ext_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
z900_compare_bfp_short_reg PROC

; 1471 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1472 :     int        r1, r2;
; 1473 :     float32_t  op1, op2;
; 1474 :     BYTE       newcc;
; 1475 : 
; 1476 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1477 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_compa
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_compa
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_compa
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_compa
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_compa
$LN13@z900_compa:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198722
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_compa:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_compa

; 1478 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_compa
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_compa
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_compa
$LN15@z900_compa:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_compa:
$LN10@z900_compa:

; 1479 : 
; 1480 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00169	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float32
  0018b	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0018f	d1 e0		 shl	 eax, 1
  00191	48 98		 cdqe
  00193	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a0	48 8b d0	 mov	 rdx, rax
  001a3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  001a8	e8 00 00 00 00	 call	 z900_get_float32
  001ad	33 c0		 xor	 eax, eax
  001af	85 c0		 test	 eax, eax
  001b1	75 b6		 jne	 SHORT $LN10@z900_compa

; 1481 : 
; 1482 :     softfloat_exceptionFlags = 0;

  001b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b8	8b c0		 mov	 eax, eax
  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001cd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1483 :     newcc = FLOAT32_COMPARE( op1, op2 );

  001d1	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  001d5	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  001d9	e8 00 00 00 00	 call	 z900_float32_compare
  001de	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1484 : 
; 1485 :     /* Xi is only trap that suppresses result, no return */
; 1486 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001e2	33 c0		 xor	 eax, eax
  001e4	83 f8 01	 cmp	 eax, 1
  001e7	74 45		 je	 SHORT $LN16@z900_compa
  001e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ee	8b c0		 mov	 eax, eax
  001f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ff	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00203	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00207	83 e0 10	 and	 eax, 16
  0020a	85 c0		 test	 eax, eax
  0020c	74 20		 je	 SHORT $LN16@z900_compa
  0020e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00213	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00219	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0021e	85 c0		 test	 eax, eax
  00220	74 0c		 je	 SHORT $LN16@z900_compa
  00222	b2 80		 mov	 dl, 128			; 00000080H
  00224	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_compa:

; 1487 :     SET_FPC_FLAGS_FROM_SF( regs );

  0022e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00233	8b c0		 mov	 eax, eax
  00235	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00244	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00248	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024c	c1 e0 13	 shl	 eax, 19
  0024f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00254	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0025a	c1 e9 08	 shr	 ecx, 8
  0025d	f7 d1		 not	 ecx
  0025f	23 c1		 and	 eax, ecx
  00261	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00266	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0026b	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00271	0b c8		 or	 ecx, eax
  00273	8b c1		 mov	 eax, ecx
  00275	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0027a	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1488 :     regs->psw.cc = newcc;

  00280	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00285	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0028a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1489 : }

  0028d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00291	c3		 ret	 0
z900_compare_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
r1$ = 48
op2$ = 52
op1$ = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_compare_bfp_short PROC

; 1495 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1496 :     int        r1, x2, b2;
; 1497 :     VADR       effective_addr2;
; 1498 :     float32_t  op1, op2;
; 1499 :     BYTE       newcc;
; 1500 : 
; 1501 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00041	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00045	c1 e8 14	 shr	 eax, 20
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004f	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00054	74 22		 je	 SHORT $LN8@z900_compa
  00056	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_compa:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 22		 je	 SHORT $LN9@z900_compa
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_compa:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c0	48 23 c8	 and	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_compa:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 06	 add	 rax, 6
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e1	33 c0		 xor	 eax, eax
  000e3	83 f8 06	 cmp	 eax, 6
  000e6	74 0c		 je	 SHORT $LN10@z900_compa
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_compa:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 d1		 jne	 SHORT $LN4@z900_compa

; 1502 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  000fa	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  000ff	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_compa:

; 1503 :     TXF_FLOAT_INSTR_CHECK( regs );

  0010d	33 c0		 xor	 eax, eax
  0010f	83 f8 01	 cmp	 eax, 1
  00112	74 6f		 je	 SHORT $LN11@z900_compa
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00120	85 c0		 test	 eax, eax
  00122	74 5f		 je	 SHORT $LN11@z900_compa
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 23		 jne	 SHORT $LN12@z900_compa
  0012a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00136	85 c0		 test	 eax, eax
  00138	75 13		 jne	 SHORT $LN12@z900_compa
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00146	83 e0 04	 and	 eax, 4
  00149	85 c0		 test	 eax, eax
  0014b	75 36		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00158	0f ba e8 0b	 bts	 eax, 11
  0015c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00167	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198751
  0016e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00174	ba 02 00 00 00	 mov	 edx, 2
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_compa:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 84		 jne	 SHORT $LN7@z900_compa

; 1504 :     BFPINST_CHECK( regs );

  00189	b8 08 00 00 00	 mov	 eax, 8
  0018e	48 6b c0 01	 imul	 rax, rax, 1
  00192	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0019f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 3c		 je	 SHORT $LN14@z900_compa
  001aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b5	d1 e8		 shr	 eax, 1
  001b7	83 e0 01	 and	 eax, 1
  001ba	85 c0		 test	 eax, eax
  001bc	74 4c		 je	 SHORT $LN13@z900_compa
  001be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001ca	b9 08 00 00 00	 mov	 ecx, 8
  001cf	48 6b c9 01	 imul	 rcx, rcx, 1
  001d3	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001db	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e1	48 85 c0	 test	 rax, rax
  001e4	75 24		 jne	 SHORT $LN13@z900_compa
$LN14@z900_compa:
  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001f5	ba 07 00 00 00	 mov	 edx, 7
  001fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_compa:

; 1505 : 
; 1506 :     GET_FLOAT32_OP( op1, r1, regs );

  0020a	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0020e	d1 e0		 shl	 eax, 1
  00210	48 98		 cdqe
  00212	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00217	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0021f	48 8b d0	 mov	 rdx, rax
  00222	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00227	e8 00 00 00 00	 call	 z900_get_float32

; 1507 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0022c	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00231	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00235	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0023a	e8 00 00 00 00	 call	 z900_vfetch4
  0023f	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 1508 : 
; 1509 :     softfloat_exceptionFlags = 0;

  00243	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00248	8b c0		 mov	 eax, eax
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00250	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00259	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025d	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1510 :     newcc = FLOAT32_COMPARE( op1, op2 );

  00261	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  00265	8b 4c 24 38	 mov	 ecx, DWORD PTR op1$[rsp]
  00269	e8 00 00 00 00	 call	 z900_float32_compare
  0026e	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1511 : 
; 1512 :     /* Xi is only trap that suppresses result, no return */
; 1513 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00272	33 c0		 xor	 eax, eax
  00274	83 f8 01	 cmp	 eax, 1
  00277	74 45		 je	 SHORT $LN15@z900_compa
  00279	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0027e	8b c0		 mov	 eax, eax
  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00286	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0028f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00293	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00297	83 e0 10	 and	 eax, 16
  0029a	85 c0		 test	 eax, eax
  0029c	74 20		 je	 SHORT $LN15@z900_compa
  0029e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002a3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002a9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002ae	85 c0		 test	 eax, eax
  002b0	74 0c		 je	 SHORT $LN15@z900_compa
  002b2	b2 80		 mov	 dl, 128			; 00000080H
  002b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002b9	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_compa:

; 1514 :     SET_FPC_FLAGS_FROM_SF( regs );

  002be	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c3	8b c0		 mov	 eax, eax
  002c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002cb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002dc	c1 e0 13	 shl	 eax, 19
  002df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e4	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002ea	c1 e9 08	 shr	 ecx, 8
  002ed	f7 d1		 not	 ecx
  002ef	23 c1		 and	 eax, ecx
  002f1	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fb	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00301	0b c8		 or	 ecx, eax
  00303	8b c1		 mov	 eax, ecx
  00305	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0030a	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1515 :     regs->psw.cc = newcc;

  00310	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00315	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0031a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1516 : }

  0031d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00321	c3		 ret	 0
z900_compare_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
z900_compare_bfp_long_reg PROC

; 1419 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1420 :     int        r1, r2;
; 1421 :     float64_t  op1, op2;
; 1422 :     BYTE       newcc;
; 1423 : 
; 1424 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1425 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_compa
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_compa
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_compa
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_compa
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_compa
$LN13@z900_compa:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198665
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_compa:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_compa

; 1426 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_compa
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_compa
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_compa
$LN15@z900_compa:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_compa:
$LN10@z900_compa:

; 1427 : 
; 1428 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00169	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float64
  0018b	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0018f	d1 e0		 shl	 eax, 1
  00191	48 98		 cdqe
  00193	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a0	48 8b d0	 mov	 rdx, rax
  001a3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  001a8	e8 00 00 00 00	 call	 z900_get_float64
  001ad	33 c0		 xor	 eax, eax
  001af	85 c0		 test	 eax, eax
  001b1	75 b6		 jne	 SHORT $LN10@z900_compa

; 1429 : 
; 1430 :     softfloat_exceptionFlags = 0;

  001b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b8	8b c0		 mov	 eax, eax
  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001cd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1431 :     newcc = FLOAT64_COMPARE( op1, op2 );

  001d1	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  001d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op1$[rsp]
  001db	e8 00 00 00 00	 call	 z900_float64_compare
  001e0	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1432 : 
; 1433 :     /* Xi is only trap that suppresses result, no return */
; 1434 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001e4	33 c0		 xor	 eax, eax
  001e6	83 f8 01	 cmp	 eax, 1
  001e9	74 45		 je	 SHORT $LN16@z900_compa
  001eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f0	8b c0		 mov	 eax, eax
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00201	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00205	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00209	83 e0 10	 and	 eax, 16
  0020c	85 c0		 test	 eax, eax
  0020e	74 20		 je	 SHORT $LN16@z900_compa
  00210	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00215	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0021b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00220	85 c0		 test	 eax, eax
  00222	74 0c		 je	 SHORT $LN16@z900_compa
  00224	b2 80		 mov	 dl, 128			; 00000080H
  00226	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0022b	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_compa:

; 1435 :     SET_FPC_FLAGS_FROM_SF( regs );

  00230	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00235	8b c0		 mov	 eax, eax
  00237	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00246	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024e	c1 e0 13	 shl	 eax, 19
  00251	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0025c	c1 e9 08	 shr	 ecx, 8
  0025f	f7 d1		 not	 ecx
  00261	23 c1		 and	 eax, ecx
  00263	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00268	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0026d	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00273	0b c8		 or	 ecx, eax
  00275	8b c1		 mov	 eax, ecx
  00277	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0027c	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1436 :     regs->psw.cc = newcc;

  00282	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00287	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0028c	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1437 : }

  0028f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00293	c3		 ret	 0
z900_compare_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
r1$ = 48
effective_addr2$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
z900_compare_bfp_long PROC

; 1443 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1444 :     int        r1, x2, b2;
; 1445 :     VADR       effective_addr2;
; 1446 :     float64_t  op1, op2;
; 1447 :     BYTE       newcc;
; 1448 : 
; 1449 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00041	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00045	c1 e8 14	 shr	 eax, 20
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004f	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00054	74 22		 je	 SHORT $LN8@z900_compa
  00056	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00068	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_compa:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 22		 je	 SHORT $LN9@z900_compa
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_compa:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c0	48 23 c8	 and	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_compa:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 06	 add	 rax, 6
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e1	33 c0		 xor	 eax, eax
  000e3	83 f8 06	 cmp	 eax, 6
  000e6	74 0c		 je	 SHORT $LN10@z900_compa
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_compa:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 d1		 jne	 SHORT $LN4@z900_compa

; 1450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  000fa	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  000ff	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_compa:

; 1451 : 
; 1452 :     TXF_FLOAT_INSTR_CHECK( regs );

  0010d	33 c0		 xor	 eax, eax
  0010f	83 f8 01	 cmp	 eax, 1
  00112	74 6f		 je	 SHORT $LN11@z900_compa
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00120	85 c0		 test	 eax, eax
  00122	74 5f		 je	 SHORT $LN11@z900_compa
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 23		 jne	 SHORT $LN12@z900_compa
  0012a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00136	85 c0		 test	 eax, eax
  00138	75 13		 jne	 SHORT $LN12@z900_compa
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00146	83 e0 04	 and	 eax, 4
  00149	85 c0		 test	 eax, eax
  0014b	75 36		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00158	0f ba e8 0b	 bts	 eax, 11
  0015c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00167	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198694
  0016e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00174	ba 02 00 00 00	 mov	 edx, 2
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_compa:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 84		 jne	 SHORT $LN7@z900_compa

; 1453 :     BFPINST_CHECK( regs );

  00189	b8 08 00 00 00	 mov	 eax, 8
  0018e	48 6b c0 01	 imul	 rax, rax, 1
  00192	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0019f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 3c		 je	 SHORT $LN14@z900_compa
  001aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b5	d1 e8		 shr	 eax, 1
  001b7	83 e0 01	 and	 eax, 1
  001ba	85 c0		 test	 eax, eax
  001bc	74 4c		 je	 SHORT $LN13@z900_compa
  001be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001ca	b9 08 00 00 00	 mov	 ecx, 8
  001cf	48 6b c9 01	 imul	 rcx, rcx, 1
  001d3	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001db	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e1	48 85 c0	 test	 rax, rax
  001e4	75 24		 jne	 SHORT $LN13@z900_compa
$LN14@z900_compa:
  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001f5	ba 07 00 00 00	 mov	 edx, 7
  001fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_compa:

; 1454 :     GET_FLOAT64_OP( op1, r1, regs );

  0020a	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0020e	d1 e0		 shl	 eax, 1
  00210	48 98		 cdqe
  00212	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00217	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0021f	48 8b d0	 mov	 rdx, rax
  00222	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00227	e8 00 00 00 00	 call	 z900_get_float64

; 1455 : 
; 1456 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0022c	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00231	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00235	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0023a	e8 00 00 00 00	 call	 z900_vfetch8
  0023f	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 1457 : 
; 1458 :     softfloat_exceptionFlags = 0;

  00244	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00249	8b c0		 mov	 eax, eax
  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00251	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025e	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1459 :     newcc = FLOAT64_COMPARE( op1, op2 );

  00262	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00267	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0026c	e8 00 00 00 00	 call	 z900_float64_compare
  00271	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1460 : 
; 1461 :     /* Xi is only trap that suppresses result, no return */
; 1462 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00275	33 c0		 xor	 eax, eax
  00277	83 f8 01	 cmp	 eax, 1
  0027a	74 45		 je	 SHORT $LN15@z900_compa
  0027c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00281	8b c0		 mov	 eax, eax
  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00289	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00292	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00296	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029a	83 e0 10	 and	 eax, 16
  0029d	85 c0		 test	 eax, eax
  0029f	74 20		 je	 SHORT $LN15@z900_compa
  002a1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002a6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ac	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002b1	85 c0		 test	 eax, eax
  002b3	74 0c		 je	 SHORT $LN15@z900_compa
  002b5	b2 80		 mov	 dl, 128			; 00000080H
  002b7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_compa:

; 1463 :     SET_FPC_FLAGS_FROM_SF( regs );

  002c1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c6	8b c0		 mov	 eax, eax
  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ce	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002db	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002df	c1 e0 13	 shl	 eax, 19
  002e2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e7	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002ed	c1 e9 08	 shr	 ecx, 8
  002f0	f7 d1		 not	 ecx
  002f2	23 c1		 and	 eax, ecx
  002f4	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fe	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00304	0b c8		 or	 ecx, eax
  00306	8b c1		 mov	 eax, ecx
  00308	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1464 :     regs->psw.cc = newcc;

  00313	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00318	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0031d	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1465 : }

  00320	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00324	c3		 ret	 0
z900_compare_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
z900_compare_bfp_ext_reg PROC

; 1391 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1392 :     int         r1, r2;
; 1393 :     float128_t  op1, op2;
; 1394 :     BYTE        newcc;
; 1395 : 
; 1396 :     RRE( inst, regs, r1, r2 );

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 03	 imul	 rax, rax, 3
  0002b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00033	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00037	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	c1 f8 04	 sar	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00054	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00060	48 83 c0 04	 add	 rax, 4
  00064	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00070	33 c0		 xor	 eax, eax
  00072	83 f8 04	 cmp	 eax, 4
  00075	74 0f		 je	 SHORT $LN11@z900_compa
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_compa:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 c8		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1397 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 01	 cmp	 eax, 1
  00091	0f 84 81 00 00
	00		 je	 $LN12@z900_compa
  00097	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a6	85 c0		 test	 eax, eax
  000a8	74 6e		 je	 SHORT $LN12@z900_compa
  000aa	33 c0		 xor	 eax, eax
  000ac	85 c0		 test	 eax, eax
  000ae	75 29		 jne	 SHORT $LN13@z900_compa
  000b0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000bf	85 c0		 test	 eax, eax
  000c1	75 16		 jne	 SHORT $LN13@z900_compa
  000c3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d2	83 e0 04	 and	 eax, 4
  000d5	85 c0		 test	 eax, eax
  000d7	75 3f		 jne	 SHORT $LN12@z900_compa
$LN13@z900_compa:
  000d9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e7	0f ba e8 0b	 bts	 eax, 11
  000eb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000f9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198635
  00100	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00106	ba 02 00 00 00	 mov	 edx, 2
  0010b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_compa:
  00118	33 c0		 xor	 eax, eax
  0011a	85 c0		 test	 eax, eax
  0011c	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_compa

; 1398 :     BFPINST_CHECK( regs );

  00122	b8 08 00 00 00	 mov	 eax, 8
  00127	48 6b c0 01	 imul	 rax, rax, 1
  0012b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00133	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00141	48 85 c0	 test	 rax, rax
  00144	74 42		 je	 SHORT $LN15@z900_compa
  00146	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00154	d1 e8		 shr	 eax, 1
  00156	83 e0 01	 and	 eax, 1
  00159	85 c0		 test	 eax, eax
  0015b	74 58		 je	 SHORT $LN14@z900_compa
  0015d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016c	b9 08 00 00 00	 mov	 ecx, 8
  00171	48 6b c9 01	 imul	 rcx, rcx, 1
  00175	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00183	48 85 c0	 test	 rax, rax
  00186	75 2d		 jne	 SHORT $LN14@z900_compa
$LN15@z900_compa:
  00188	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00190	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0019a	ba 07 00 00 00	 mov	 edx, 7
  0019f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001af	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_compa:

; 1399 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001b5	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001b9	83 e0 02	 and	 eax, 2
  001bc	85 c0		 test	 eax, eax
  001be	75 0b		 jne	 SHORT $LN17@z900_compa
  001c0	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001c4	83 e0 02	 and	 eax, 2
  001c7	85 c0		 test	 eax, eax
  001c9	74 1b		 je	 SHORT $LN16@z900_compa
$LN17@z900_compa:
  001cb	ba 06 00 00 00	 mov	 edx, 6
  001d0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_compa:
$LN10@z900_compa:

; 1400 : 
; 1401 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  001e6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001ea	d1 e0		 shl	 eax, 1
  001ec	48 98		 cdqe
  001ee	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f6	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001fe	48 8b d0	 mov	 rdx, rax
  00201	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  00206	e8 00 00 00 00	 call	 z900_get_float128
  0020b	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0020f	d1 e0		 shl	 eax, 1
  00211	48 98		 cdqe
  00213	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00223	48 8b d0	 mov	 rdx, rax
  00226	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0022b	e8 00 00 00 00	 call	 z900_get_float128
  00230	33 c0		 xor	 eax, eax
  00232	85 c0		 test	 eax, eax
  00234	75 b0		 jne	 SHORT $LN10@z900_compa

; 1402 : 
; 1403 :     softfloat_exceptionFlags = 0;

  00236	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023b	8b c0		 mov	 eax, eax
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00243	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00250	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1404 :     newcc = FLOAT128_COMPARE( op1, op2 );

  00254	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00259	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0025e	48 8b f8	 mov	 rdi, rax
  00261	48 8b f1	 mov	 rsi, rcx
  00264	b9 10 00 00 00	 mov	 ecx, 16
  00269	f3 a4		 rep movsb
  0026b	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  00270	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  00275	48 8b f8	 mov	 rdi, rax
  00278	48 8b f1	 mov	 rsi, rcx
  0027b	b9 10 00 00 00	 mov	 ecx, 16
  00280	f3 a4		 rep movsb
  00282	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  00287	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0028c	e8 00 00 00 00	 call	 z900_float128_compare
  00291	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1405 : 
; 1406 :     /* Xi is only trap that suppresses result, no return */
; 1407 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00295	33 c0		 xor	 eax, eax
  00297	83 f8 01	 cmp	 eax, 1
  0029a	74 4b		 je	 SHORT $LN18@z900_compa
  0029c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a1	8b c0		 mov	 eax, eax
  002a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ba	83 e0 10	 and	 eax, 16
  002bd	85 c0		 test	 eax, eax
  002bf	74 26		 je	 SHORT $LN18@z900_compa
  002c1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002cf	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002d4	85 c0		 test	 eax, eax
  002d6	74 0f		 je	 SHORT $LN18@z900_compa
  002d8	b2 80		 mov	 dl, 128			; 00000080H
  002da	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	e8 00 00 00 00	 call	 ieee_trap
$LN18@z900_compa:

; 1408 : 
; 1409 :     SET_FPC_FLAGS_FROM_SF( regs );

  002e7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ec	8b c0		 mov	 eax, eax
  002ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002fd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00301	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00305	c1 e0 13	 shl	 eax, 19
  00308	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00310	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00316	c1 e9 08	 shr	 ecx, 8
  00319	f7 d1		 not	 ecx
  0031b	23 c1		 and	 eax, ecx
  0031d	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00322	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032a	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00330	0b c8		 or	 ecx, eax
  00332	8b c1		 mov	 eax, ecx
  00334	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033c	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1410 : 
; 1411 :     /* Xi is only possible exception detected for Compare   */
; 1412 :     regs->psw.cc = newcc;

  00342	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0034f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1413 : }

  00352	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00357	48 33 cc	 xor	 rcx, rsp
  0035a	e8 00 00 00 00	 call	 __security_check_cookie
  0035f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00366	5f		 pop	 rdi
  00367	5e		 pop	 rsi
  00368	c3		 ret	 0
z900_compare_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
z900_compare_and_signal_bfp_short_reg PROC

; 1598 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1599 :     int        r1, r2;
; 1600 :     float32_t  op1, op2;
; 1601 :     BYTE       newcc;
; 1602 : 
; 1603 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1604 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_compa
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_compa
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_compa
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_compa
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_compa
$LN13@z900_compa:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198866
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_compa:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_compa

; 1605 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_compa
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_compa
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_compa
$LN15@z900_compa:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_compa:
$LN10@z900_compa:

; 1606 : 
; 1607 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00169	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float32
  0018b	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0018f	d1 e0		 shl	 eax, 1
  00191	48 98		 cdqe
  00193	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a0	48 8b d0	 mov	 rdx, rax
  001a3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  001a8	e8 00 00 00 00	 call	 z900_get_float32
  001ad	33 c0		 xor	 eax, eax
  001af	85 c0		 test	 eax, eax
  001b1	75 b6		 jne	 SHORT $LN10@z900_compa

; 1608 : 
; 1609 :     softfloat_exceptionFlags = 0;

  001b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b8	8b c0		 mov	 eax, eax
  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001cd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1610 :     newcc = FLOAT32_COMPARE_AND_SIGNAL( op1, op2 );

  001d1	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  001d5	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  001d9	e8 00 00 00 00	 call	 z900_float32_signaling_compare
  001de	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1611 : 
; 1612 :     /* Xi is only trap that suppresses result, no return */
; 1613 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001e2	33 c0		 xor	 eax, eax
  001e4	83 f8 01	 cmp	 eax, 1
  001e7	74 45		 je	 SHORT $LN16@z900_compa
  001e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ee	8b c0		 mov	 eax, eax
  001f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ff	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00203	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00207	83 e0 10	 and	 eax, 16
  0020a	85 c0		 test	 eax, eax
  0020c	74 20		 je	 SHORT $LN16@z900_compa
  0020e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00213	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00219	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0021e	85 c0		 test	 eax, eax
  00220	74 0c		 je	 SHORT $LN16@z900_compa
  00222	b2 80		 mov	 dl, 128			; 00000080H
  00224	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_compa:

; 1614 :     SET_FPC_FLAGS_FROM_SF( regs );

  0022e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00233	8b c0		 mov	 eax, eax
  00235	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00244	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00248	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024c	c1 e0 13	 shl	 eax, 19
  0024f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00254	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0025a	c1 e9 08	 shr	 ecx, 8
  0025d	f7 d1		 not	 ecx
  0025f	23 c1		 and	 eax, ecx
  00261	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00266	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0026b	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00271	0b c8		 or	 ecx, eax
  00273	8b c1		 mov	 eax, ecx
  00275	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0027a	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1615 :     regs->psw.cc = newcc;

  00280	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00285	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0028a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1616 : }

  0028d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00291	c3		 ret	 0
z900_compare_and_signal_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
r1$ = 48
op2$ = 52
op1$ = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_compare_and_signal_bfp_short PROC

; 1622 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1623 :     int        r1, x2, b2;
; 1624 :     VADR       effective_addr2;
; 1625 :     float32_t  op1, op2;
; 1626 :     BYTE       newcc;
; 1627 : 
; 1628 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00041	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00045	c1 e8 14	 shr	 eax, 20
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004f	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00054	74 22		 je	 SHORT $LN8@z900_compa
  00056	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_compa:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 22		 je	 SHORT $LN9@z900_compa
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_compa:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c0	48 23 c8	 and	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_compa:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 06	 add	 rax, 6
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e1	33 c0		 xor	 eax, eax
  000e3	83 f8 06	 cmp	 eax, 6
  000e6	74 0c		 je	 SHORT $LN10@z900_compa
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_compa:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 d1		 jne	 SHORT $LN4@z900_compa

; 1629 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  000fa	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  000ff	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_compa:

; 1630 :     TXF_FLOAT_INSTR_CHECK( regs );

  0010d	33 c0		 xor	 eax, eax
  0010f	83 f8 01	 cmp	 eax, 1
  00112	74 6f		 je	 SHORT $LN11@z900_compa
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00120	85 c0		 test	 eax, eax
  00122	74 5f		 je	 SHORT $LN11@z900_compa
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 23		 jne	 SHORT $LN12@z900_compa
  0012a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00136	85 c0		 test	 eax, eax
  00138	75 13		 jne	 SHORT $LN12@z900_compa
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00146	83 e0 04	 and	 eax, 4
  00149	85 c0		 test	 eax, eax
  0014b	75 36		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00158	0f ba e8 0b	 bts	 eax, 11
  0015c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00167	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198895
  0016e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00174	ba 02 00 00 00	 mov	 edx, 2
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_compa:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 84		 jne	 SHORT $LN7@z900_compa

; 1631 :     BFPINST_CHECK( regs );

  00189	b8 08 00 00 00	 mov	 eax, 8
  0018e	48 6b c0 01	 imul	 rax, rax, 1
  00192	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0019f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 3c		 je	 SHORT $LN14@z900_compa
  001aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b5	d1 e8		 shr	 eax, 1
  001b7	83 e0 01	 and	 eax, 1
  001ba	85 c0		 test	 eax, eax
  001bc	74 4c		 je	 SHORT $LN13@z900_compa
  001be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001ca	b9 08 00 00 00	 mov	 ecx, 8
  001cf	48 6b c9 01	 imul	 rcx, rcx, 1
  001d3	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001db	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e1	48 85 c0	 test	 rax, rax
  001e4	75 24		 jne	 SHORT $LN13@z900_compa
$LN14@z900_compa:
  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001f5	ba 07 00 00 00	 mov	 edx, 7
  001fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_compa:

; 1632 : 
; 1633 :     GET_FLOAT32_OP( op1, r1, regs );

  0020a	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0020e	d1 e0		 shl	 eax, 1
  00210	48 98		 cdqe
  00212	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00217	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0021f	48 8b d0	 mov	 rdx, rax
  00222	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00227	e8 00 00 00 00	 call	 z900_get_float32

; 1634 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0022c	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00231	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00235	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0023a	e8 00 00 00 00	 call	 z900_vfetch4
  0023f	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 1635 : 
; 1636 :     softfloat_exceptionFlags = 0;

  00243	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00248	8b c0		 mov	 eax, eax
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00250	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00259	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025d	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1637 :     newcc = FLOAT32_COMPARE_AND_SIGNAL( op1, op2 );

  00261	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  00265	8b 4c 24 38	 mov	 ecx, DWORD PTR op1$[rsp]
  00269	e8 00 00 00 00	 call	 z900_float32_signaling_compare
  0026e	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1638 : 
; 1639 :     /* Xi is only trap that suppresses result, no return */
; 1640 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00272	33 c0		 xor	 eax, eax
  00274	83 f8 01	 cmp	 eax, 1
  00277	74 45		 je	 SHORT $LN15@z900_compa
  00279	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0027e	8b c0		 mov	 eax, eax
  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00286	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0028f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00293	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00297	83 e0 10	 and	 eax, 16
  0029a	85 c0		 test	 eax, eax
  0029c	74 20		 je	 SHORT $LN15@z900_compa
  0029e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002a3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002a9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002ae	85 c0		 test	 eax, eax
  002b0	74 0c		 je	 SHORT $LN15@z900_compa
  002b2	b2 80		 mov	 dl, 128			; 00000080H
  002b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002b9	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_compa:

; 1641 :     SET_FPC_FLAGS_FROM_SF( regs );

  002be	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c3	8b c0		 mov	 eax, eax
  002c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002cb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002dc	c1 e0 13	 shl	 eax, 19
  002df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e4	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002ea	c1 e9 08	 shr	 ecx, 8
  002ed	f7 d1		 not	 ecx
  002ef	23 c1		 and	 eax, ecx
  002f1	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fb	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00301	0b c8		 or	 ecx, eax
  00303	8b c1		 mov	 eax, ecx
  00305	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0030a	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1642 :     regs->psw.cc = newcc;

  00310	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00315	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0031a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1643 : }

  0031d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00321	c3		 ret	 0
z900_compare_and_signal_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
z900_compare_and_signal_bfp_long_reg PROC

; 1547 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1548 :     int        r1, r2;
; 1549 :     float64_t  op1, op2;
; 1550 :     BYTE       newcc;
; 1551 : 
; 1552 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1553 : 
; 1554 :     TXF_FLOAT_INSTR_CHECK( regs );

  0006c	33 c0		 xor	 eax, eax
  0006e	83 f8 01	 cmp	 eax, 1
  00071	74 6f		 je	 SHORT $LN12@z900_compa
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00078	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0007f	85 c0		 test	 eax, eax
  00081	74 5f		 je	 SHORT $LN12@z900_compa
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 23		 jne	 SHORT $LN13@z900_compa
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00095	85 c0		 test	 eax, eax
  00097	75 13		 jne	 SHORT $LN13@z900_compa
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000a5	83 e0 04	 and	 eax, 4
  000a8	85 c0		 test	 eax, eax
  000aa	75 36		 jne	 SHORT $LN12@z900_compa
$LN13@z900_compa:
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000b7	0f ba e8 0b	 bts	 eax, 11
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198809
  000cd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_compa:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 84		 jne	 SHORT $LN7@z900_compa

; 1555 :     BFPINST_CHECK(regs);

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000fe	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 3c		 je	 SHORT $LN15@z900_compa
  00109	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	74 4c		 je	 SHORT $LN14@z900_compa
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00122	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00129	b9 08 00 00 00	 mov	 ecx, 8
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0013a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00140	48 85 c0	 test	 rax, rax
  00143	75 24		 jne	 SHORT $LN14@z900_compa
$LN15@z900_compa:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00154	ba 07 00 00 00	 mov	 edx, 7
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00163	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_compa:
$LN10@z900_compa:

; 1556 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00169	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	48 98		 cdqe
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00186	e8 00 00 00 00	 call	 z900_get_float64
  0018b	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0018f	d1 e0		 shl	 eax, 1
  00191	48 98		 cdqe
  00193	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a0	48 8b d0	 mov	 rdx, rax
  001a3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  001a8	e8 00 00 00 00	 call	 z900_get_float64
  001ad	33 c0		 xor	 eax, eax
  001af	85 c0		 test	 eax, eax
  001b1	75 b6		 jne	 SHORT $LN10@z900_compa

; 1557 : 
; 1558 :     softfloat_exceptionFlags = 0;

  001b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b8	8b c0		 mov	 eax, eax
  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001cd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1559 :     newcc = FLOAT64_COMPARE_AND_SIGNAL( op1, op2 );

  001d1	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  001d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op1$[rsp]
  001db	e8 00 00 00 00	 call	 z900_float64_signaling_compare
  001e0	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1560 : 
; 1561 :     /* Xi is only trap that suppresses result, no return */
; 1562 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001e4	33 c0		 xor	 eax, eax
  001e6	83 f8 01	 cmp	 eax, 1
  001e9	74 45		 je	 SHORT $LN16@z900_compa
  001eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f0	8b c0		 mov	 eax, eax
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00201	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00205	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00209	83 e0 10	 and	 eax, 16
  0020c	85 c0		 test	 eax, eax
  0020e	74 20		 je	 SHORT $LN16@z900_compa
  00210	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00215	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0021b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00220	85 c0		 test	 eax, eax
  00222	74 0c		 je	 SHORT $LN16@z900_compa
  00224	b2 80		 mov	 dl, 128			; 00000080H
  00226	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0022b	e8 00 00 00 00	 call	 ieee_trap
$LN16@z900_compa:

; 1563 :     SET_FPC_FLAGS_FROM_SF( regs );

  00230	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00235	8b c0		 mov	 eax, eax
  00237	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00246	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024e	c1 e0 13	 shl	 eax, 19
  00251	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0025c	c1 e9 08	 shr	 ecx, 8
  0025f	f7 d1		 not	 ecx
  00261	23 c1		 and	 eax, ecx
  00263	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00268	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0026d	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00273	0b c8		 or	 ecx, eax
  00275	8b c1		 mov	 eax, ecx
  00277	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0027c	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1564 :     regs->psw.cc = newcc;

  00282	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00287	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0028c	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1565 : }

  0028f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00293	c3		 ret	 0
z900_compare_and_signal_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
r1$ = 48
effective_addr2$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
z900_compare_and_signal_bfp_long PROC

; 1571 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1572 :     int        r1, x2, b2;
; 1573 :     VADR       effective_addr2;
; 1574 :     float64_t  op1, op2;
; 1575 :     BYTE       newcc;
; 1576 : 
; 1577 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00041	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00045	c1 e8 14	 shr	 eax, 20
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004f	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00054	74 22		 je	 SHORT $LN8@z900_compa
  00056	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00068	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_compa:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 22		 je	 SHORT $LN9@z900_compa
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_compa:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c0	48 23 c8	 and	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_compa:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 06	 add	 rax, 6
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e1	33 c0		 xor	 eax, eax
  000e3	83 f8 06	 cmp	 eax, 6
  000e6	74 0c		 je	 SHORT $LN10@z900_compa
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_compa:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 d1		 jne	 SHORT $LN4@z900_compa

; 1578 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  000fa	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  000ff	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_compa:

; 1579 :     TXF_FLOAT_INSTR_CHECK( regs );

  0010d	33 c0		 xor	 eax, eax
  0010f	83 f8 01	 cmp	 eax, 1
  00112	74 6f		 je	 SHORT $LN11@z900_compa
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00120	85 c0		 test	 eax, eax
  00122	74 5f		 je	 SHORT $LN11@z900_compa
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 23		 jne	 SHORT $LN12@z900_compa
  0012a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00136	85 c0		 test	 eax, eax
  00138	75 13		 jne	 SHORT $LN12@z900_compa
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00146	83 e0 04	 and	 eax, 4
  00149	85 c0		 test	 eax, eax
  0014b	75 36		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00158	0f ba e8 0b	 bts	 eax, 11
  0015c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00167	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198838
  0016e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00174	ba 02 00 00 00	 mov	 edx, 2
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_compa:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 84		 jne	 SHORT $LN7@z900_compa

; 1580 :     BFPINST_CHECK( regs );

  00189	b8 08 00 00 00	 mov	 eax, 8
  0018e	48 6b c0 01	 imul	 rax, rax, 1
  00192	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0019f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 3c		 je	 SHORT $LN14@z900_compa
  001aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b5	d1 e8		 shr	 eax, 1
  001b7	83 e0 01	 and	 eax, 1
  001ba	85 c0		 test	 eax, eax
  001bc	74 4c		 je	 SHORT $LN13@z900_compa
  001be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001ca	b9 08 00 00 00	 mov	 ecx, 8
  001cf	48 6b c9 01	 imul	 rcx, rcx, 1
  001d3	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001db	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e1	48 85 c0	 test	 rax, rax
  001e4	75 24		 jne	 SHORT $LN13@z900_compa
$LN14@z900_compa:
  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001f5	ba 07 00 00 00	 mov	 edx, 7
  001fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_compa:

; 1581 : 
; 1582 :     GET_FLOAT64_OP( op1, r1, regs );

  0020a	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0020e	d1 e0		 shl	 eax, 1
  00210	48 98		 cdqe
  00212	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00217	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0021f	48 8b d0	 mov	 rdx, rax
  00222	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00227	e8 00 00 00 00	 call	 z900_get_float64

; 1583 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0022c	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00231	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00235	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0023a	e8 00 00 00 00	 call	 z900_vfetch8
  0023f	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 1584 : 
; 1585 :     softfloat_exceptionFlags = 0;

  00244	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00249	8b c0		 mov	 eax, eax
  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00251	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025e	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1586 :     newcc = FLOAT64_COMPARE_AND_SIGNAL( op1, op2 );

  00262	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00267	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0026c	e8 00 00 00 00	 call	 z900_float64_signaling_compare
  00271	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1587 : 
; 1588 :     /* Xi is only trap that suppresses result, no return */
; 1589 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00275	33 c0		 xor	 eax, eax
  00277	83 f8 01	 cmp	 eax, 1
  0027a	74 45		 je	 SHORT $LN15@z900_compa
  0027c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00281	8b c0		 mov	 eax, eax
  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00289	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00292	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00296	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029a	83 e0 10	 and	 eax, 16
  0029d	85 c0		 test	 eax, eax
  0029f	74 20		 je	 SHORT $LN15@z900_compa
  002a1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002a6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ac	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002b1	85 c0		 test	 eax, eax
  002b3	74 0c		 je	 SHORT $LN15@z900_compa
  002b5	b2 80		 mov	 dl, 128			; 00000080H
  002b7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_compa:

; 1590 :     SET_FPC_FLAGS_FROM_SF( regs );

  002c1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c6	8b c0		 mov	 eax, eax
  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ce	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002db	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002df	c1 e0 13	 shl	 eax, 19
  002e2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e7	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002ed	c1 e9 08	 shr	 ecx, 8
  002f0	f7 d1		 not	 ecx
  002f2	23 c1		 and	 eax, ecx
  002f4	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fe	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00304	0b c8		 or	 ecx, eax
  00306	8b c1		 mov	 eax, ecx
  00308	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1591 :     regs->psw.cc = newcc;

  00313	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00318	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0031d	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1592 : }

  00320	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00324	c3		 ret	 0
z900_compare_and_signal_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
z900_compare_and_signal_bfp_ext_reg PROC

; 1522 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1523 :     int         r1, r2;
; 1524 :     float128_t  op1, op2;
; 1525 :     BYTE        newcc;
; 1526 : 
; 1527 :     RRE( inst, regs, r1, r2 );

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 03	 imul	 rax, rax, 3
  0002b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00033	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00037	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	c1 f8 04	 sar	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00054	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00060	48 83 c0 04	 add	 rax, 4
  00064	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00070	33 c0		 xor	 eax, eax
  00072	83 f8 04	 cmp	 eax, 4
  00075	74 0f		 je	 SHORT $LN11@z900_compa
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_compa:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 c8		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1528 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 01	 cmp	 eax, 1
  00091	0f 84 81 00 00
	00		 je	 $LN12@z900_compa
  00097	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a6	85 c0		 test	 eax, eax
  000a8	74 6e		 je	 SHORT $LN12@z900_compa
  000aa	33 c0		 xor	 eax, eax
  000ac	85 c0		 test	 eax, eax
  000ae	75 29		 jne	 SHORT $LN13@z900_compa
  000b0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000bf	85 c0		 test	 eax, eax
  000c1	75 16		 jne	 SHORT $LN13@z900_compa
  000c3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d2	83 e0 04	 and	 eax, 4
  000d5	85 c0		 test	 eax, eax
  000d7	75 3f		 jne	 SHORT $LN12@z900_compa
$LN13@z900_compa:
  000d9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e7	0f ba e8 0b	 bts	 eax, 11
  000eb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000f9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198779
  00100	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00106	ba 02 00 00 00	 mov	 edx, 2
  0010b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_compa:
  00118	33 c0		 xor	 eax, eax
  0011a	85 c0		 test	 eax, eax
  0011c	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_compa

; 1529 :     BFPINST_CHECK( regs );

  00122	b8 08 00 00 00	 mov	 eax, 8
  00127	48 6b c0 01	 imul	 rax, rax, 1
  0012b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00133	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00141	48 85 c0	 test	 rax, rax
  00144	74 42		 je	 SHORT $LN15@z900_compa
  00146	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00154	d1 e8		 shr	 eax, 1
  00156	83 e0 01	 and	 eax, 1
  00159	85 c0		 test	 eax, eax
  0015b	74 58		 je	 SHORT $LN14@z900_compa
  0015d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016c	b9 08 00 00 00	 mov	 ecx, 8
  00171	48 6b c9 01	 imul	 rcx, rcx, 1
  00175	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00183	48 85 c0	 test	 rax, rax
  00186	75 2d		 jne	 SHORT $LN14@z900_compa
$LN15@z900_compa:
  00188	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00190	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0019a	ba 07 00 00 00	 mov	 edx, 7
  0019f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001af	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_compa:

; 1530 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001b5	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001b9	83 e0 02	 and	 eax, 2
  001bc	85 c0		 test	 eax, eax
  001be	75 0b		 jne	 SHORT $LN17@z900_compa
  001c0	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001c4	83 e0 02	 and	 eax, 2
  001c7	85 c0		 test	 eax, eax
  001c9	74 1b		 je	 SHORT $LN16@z900_compa
$LN17@z900_compa:
  001cb	ba 06 00 00 00	 mov	 edx, 6
  001d0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_compa:
$LN10@z900_compa:

; 1531 : 
; 1532 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  001e6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001ea	d1 e0		 shl	 eax, 1
  001ec	48 98		 cdqe
  001ee	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f6	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001fe	48 8b d0	 mov	 rdx, rax
  00201	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  00206	e8 00 00 00 00	 call	 z900_get_float128
  0020b	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0020f	d1 e0		 shl	 eax, 1
  00211	48 98		 cdqe
  00213	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00223	48 8b d0	 mov	 rdx, rax
  00226	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0022b	e8 00 00 00 00	 call	 z900_get_float128
  00230	33 c0		 xor	 eax, eax
  00232	85 c0		 test	 eax, eax
  00234	75 b0		 jne	 SHORT $LN10@z900_compa

; 1533 : 
; 1534 :     softfloat_exceptionFlags = 0;

  00236	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023b	8b c0		 mov	 eax, eax
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00243	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00250	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1535 :     newcc = FLOAT128_COMPARE_AND_SIGNAL( op1, op2 );

  00254	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00259	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0025e	48 8b f8	 mov	 rdi, rax
  00261	48 8b f1	 mov	 rsi, rcx
  00264	b9 10 00 00 00	 mov	 ecx, 16
  00269	f3 a4		 rep movsb
  0026b	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  00270	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  00275	48 8b f8	 mov	 rdi, rax
  00278	48 8b f1	 mov	 rsi, rcx
  0027b	b9 10 00 00 00	 mov	 ecx, 16
  00280	f3 a4		 rep movsb
  00282	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  00287	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0028c	e8 00 00 00 00	 call	 z900_float128_signaling_compare
  00291	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1536 : 
; 1537 :     /* Xi is only trap that suppresses result, no return */
; 1538 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00295	33 c0		 xor	 eax, eax
  00297	83 f8 01	 cmp	 eax, 1
  0029a	74 4b		 je	 SHORT $LN18@z900_compa
  0029c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a1	8b c0		 mov	 eax, eax
  002a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ba	83 e0 10	 and	 eax, 16
  002bd	85 c0		 test	 eax, eax
  002bf	74 26		 je	 SHORT $LN18@z900_compa
  002c1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002cf	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002d4	85 c0		 test	 eax, eax
  002d6	74 0f		 je	 SHORT $LN18@z900_compa
  002d8	b2 80		 mov	 dl, 128			; 00000080H
  002da	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	e8 00 00 00 00	 call	 ieee_trap
$LN18@z900_compa:

; 1539 :     SET_FPC_FLAGS_FROM_SF( regs );

  002e7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ec	8b c0		 mov	 eax, eax
  002ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002fd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00301	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00305	c1 e0 13	 shl	 eax, 19
  00308	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00310	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00316	c1 e9 08	 shr	 ecx, 8
  00319	f7 d1		 not	 ecx
  0031b	23 c1		 and	 eax, ecx
  0031d	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00322	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032a	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00330	0b c8		 or	 ecx, eax
  00332	8b c1		 mov	 eax, ecx
  00334	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033c	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1540 :     regs->psw.cc = newcc;

  00342	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0034f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1541 : }

  00352	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00357	48 33 cc	 xor	 rcx, rsp
  0035a	e8 00 00 00 00	 call	 __security_check_cookie
  0035f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00366	5f		 pop	 rdi
  00367	5e		 pop	 rsi
  00368	c3		 ret	 0
z900_compare_and_signal_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ans$ = 32
ieee_trap_conds$ = 36
i$1 = 40
tv214 = 44
r1$ = 48
tv230 = 52
tv233 = 56
tv235 = 60
tv236 = 64
r2$ = 68
op2$ = 72
op1$ = 76
inst$ = 96
regs$ = 104
z900_add_bfp_short_reg PROC

; 1314 : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1315 :     int        r1, r2;
; 1316 :     float32_t  op1, op2, ans;
; 1317 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1318 : 
; 1319 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_b:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN14@z900_add_b
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN14@z900_add_b:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_add_b
$LN7@z900_add_b:

; 1320 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN15@z900_add_b
  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN15@z900_add_b
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN16@z900_add_b
  00091	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN16@z900_add_b
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN15@z900_add_b
$LN16@z900_add_b:
  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198569
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN15@z900_add_b:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_add_b

; 1321 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN18@z900_add_b
  00111	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN17@z900_add_b
  00125	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN17@z900_add_b
$LN18@z900_add_b:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_add_b:
$LN10@z900_add_b:

; 1322 : 
; 1323 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00171	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR op1$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float32
  00193	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00197	d1 e0		 shl	 eax, 1
  00199	48 98		 cdqe
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_get_float32
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 b6		 jne	 SHORT $LN10@z900_add_b

; 1324 : 
; 1325 :     softfloat_exceptionFlags = 0;

  001bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c0	8b c0		 mov	 eax, eax
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1326 :     SET_SF_RM_FROM_FPC;

  001d9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001de	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e4	83 e0 07	 and	 eax, 7
  001e7	8b c0		 mov	 eax, eax
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001f0	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001f5	8b d2		 mov	 edx, edx
  001f7	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001fe	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00207	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1327 : 
; 1328 :     ans = f32_add( op1, op2 );

  00213	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00217	8b 4c 24 4c	 mov	 ecx, DWORD PTR op1$[rsp]
  0021b	e8 00 00 00 00	 call	 f32_add
  00220	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax

; 1329 : 
; 1330 :     if (softfloat_exceptionFlags)

  00224	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00229	8b c0		 mov	 eax, eax
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00231	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00242	85 c0		 test	 eax, eax
  00244	0f 84 93 00 00
	00		 je	 $LN19@z900_add_b

; 1331 :     {
; 1332 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0024a	33 c0		 xor	 eax, eax
  0024c	83 f8 01	 cmp	 eax, 1
  0024f	74 45		 je	 SHORT $LN20@z900_add_b
  00251	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00256	8b c0		 mov	 eax, eax
  00258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0025e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00267	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026f	83 e0 10	 and	 eax, 16
  00272	85 c0		 test	 eax, eax
  00274	74 20		 je	 SHORT $LN20@z900_add_b
  00276	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0027b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00281	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00286	85 c0		 test	 eax, eax
  00288	74 0c		 je	 SHORT $LN20@z900_add_b
  0028a	b2 80		 mov	 dl, 128			; 00000080H
  0028c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00291	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_add_b:

; 1333 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00296	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002a0	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1334 : 
; 1335 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002a4	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002a8	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002ad	85 c0		 test	 eax, eax
  002af	74 2c		 je	 SHORT $LN21@z900_add_b

; 1336 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002b1	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b5	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002ba	85 c0		 test	 eax, eax
  002bc	74 0a		 je	 SHORT $LN24@z900_add_b
  002be	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv214[rsp], -192 ; ffffffffffffff40H
  002c6	eb 08		 jmp	 SHORT $LN25@z900_add_b
$LN24@z900_add_b:
  002c8	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv214[rsp], 192 ; 000000c0H
$LN25@z900_add_b:
  002d0	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv214[rsp]
  002d4	e8 00 00 00 00	 call	 f32_scaledResult
  002d9	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax
$LN21@z900_add_b:
$LN19@z900_add_b:
$LN13@z900_add_b:

; 1337 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 1338 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 1339 :     }
; 1340 : 
; 1341 :     PUT_FLOAT32_CC( ans, r1, regs );

  002dd	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  002e1	d1 e0		 shl	 eax, 1
  002e3	48 98		 cdqe
  002e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ea	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002f2	48 8b d0	 mov	 rdx, rax
  002f5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ans$[rsp]
  002fa	e8 00 00 00 00	 call	 z900_put_float32
  002ff	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00303	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00308	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0030d	75 17		 jne	 SHORT $LN26@z900_add_b
  0030f	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00313	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00318	85 c0		 test	 eax, eax
  0031a	74 0a		 je	 SHORT $LN26@z900_add_b
  0031c	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv236[rsp], 3
  00324	eb 5e		 jmp	 SHORT $LN33@z900_add_b
$LN26@z900_add_b:
  00326	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  0032a	0f ba f0 1f	 btr	 eax, 31
  0032e	85 c0		 test	 eax, eax
  00330	75 0a		 jne	 SHORT $LN27@z900_add_b
  00332	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
  0033a	eb 08		 jmp	 SHORT $LN28@z900_add_b
$LN27@z900_add_b:
  0033c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv230[rsp], 0
$LN28@z900_add_b:
  00344	83 7c 24 34 00	 cmp	 DWORD PTR tv230[rsp], 0
  00349	74 0a		 je	 SHORT $LN31@z900_add_b
  0034b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv235[rsp], 0
  00353	eb 27		 jmp	 SHORT $LN32@z900_add_b
$LN31@z900_add_b:
  00355	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00359	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0035e	85 c0		 test	 eax, eax
  00360	74 0a		 je	 SHORT $LN29@z900_add_b
  00362	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  0036a	eb 08		 jmp	 SHORT $LN30@z900_add_b
$LN29@z900_add_b:
  0036c	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv233[rsp], 2
$LN30@z900_add_b:
  00374	8b 44 24 38	 mov	 eax, DWORD PTR tv233[rsp]
  00378	89 44 24 3c	 mov	 DWORD PTR tv235[rsp], eax
$LN32@z900_add_b:
  0037c	8b 44 24 3c	 mov	 eax, DWORD PTR tv235[rsp]
  00380	89 44 24 40	 mov	 DWORD PTR tv236[rsp], eax
$LN33@z900_add_b:
  00384	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00389	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv236[rsp]
  0038e	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00391	33 c0		 xor	 eax, eax
  00393	85 c0		 test	 eax, eax
  00395	0f 85 42 ff ff
	ff		 jne	 $LN13@z900_add_b

; 1342 : 
; 1343 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0039b	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0039f	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003a4	85 c0		 test	 eax, eax
  003a6	74 0e		 je	 SHORT $LN22@z900_add_b
  003a8	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN22@z900_add_b:

; 1344 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1345 : }

  003b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003ba	c3		 ret	 0
z900_add_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ans$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
effective_addr2$ = 56
tv235 = 64
r1$ = 68
tv251 = 72
tv254 = 76
tv256 = 80
tv257 = 84
op2$ = 88
op1$ = 92
inst$ = 112
regs$ = 120
z900_add_bfp_short PROC

; 1351 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1352 :     int         r1, x2, b2;
; 1353 :     VADR       effective_addr2;
; 1354 :     float32_t  op1, op2, ans;
; 1355 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1356 : 
; 1357 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	8b c0		 mov	 eax, eax
  00036	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 22		 je	 SHORT $LN11@z900_add_b
  0005e	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_add_b:
  00080	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0008e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00093	74 22		 je	 SHORT $LN12@z900_add_b
  00095	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_add_b:
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c8	48 23 c8	 and	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_add_b:
  000d3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000dc	48 83 c0 06	 add	 rax, 6
  000e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0c		 je	 SHORT $LN13@z900_add_b
  000f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_add_b:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 d1		 jne	 SHORT $LN4@z900_add_b

; 1358 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00102	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b2$[rsp]
  00107	8b 54 24 30	 mov	 edx, DWORD PTR x2$[rsp]
  0010b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_add_b:

; 1359 :     TXF_FLOAT_INSTR_CHECK( regs );

  00115	33 c0		 xor	 eax, eax
  00117	83 f8 01	 cmp	 eax, 1
  0011a	74 6f		 je	 SHORT $LN14@z900_add_b
  0011c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00128	85 c0		 test	 eax, eax
  0012a	74 5f		 je	 SHORT $LN14@z900_add_b
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 23		 jne	 SHORT $LN15@z900_add_b
  00132	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0013e	85 c0		 test	 eax, eax
  00140	75 13		 jne	 SHORT $LN15@z900_add_b
  00142	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00147	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0014e	83 e0 04	 and	 eax, 4
  00151	85 c0		 test	 eax, eax
  00153	75 36		 jne	 SHORT $LN14@z900_add_b
$LN15@z900_add_b:
  00155	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00160	0f ba e8 0b	 bts	 eax, 11
  00164	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0016f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198604
  00176	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0017c	ba 02 00 00 00	 mov	 edx, 2
  00181	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_add_b:
  0018b	33 c0		 xor	 eax, eax
  0018d	85 c0		 test	 eax, eax
  0018f	75 84		 jne	 SHORT $LN7@z900_add_b

; 1360 :     BFPINST_CHECK( regs );

  00191	b8 08 00 00 00	 mov	 eax, 8
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001a7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 3c		 je	 SHORT $LN17@z900_add_b
  001b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bd	d1 e8		 shr	 eax, 1
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	74 4c		 je	 SHORT $LN16@z900_add_b
  001c6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d2	b9 08 00 00 00	 mov	 ecx, 8
  001d7	48 6b c9 01	 imul	 rcx, rcx, 1
  001db	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001e3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e9	48 85 c0	 test	 rax, rax
  001ec	75 24		 jne	 SHORT $LN16@z900_add_b
$LN17@z900_add_b:
  001ee	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001f3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001fd	ba 07 00 00 00	 mov	 edx, 7
  00202	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_add_b:

; 1361 : 
; 1362 :     GET_FLOAT32_OP( op1, r1, regs );

  00212	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  00216	d1 e0		 shl	 eax, 1
  00218	48 98		 cdqe
  0021a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00227	48 8b d0	 mov	 rdx, rax
  0022a	48 8d 4c 24 5c	 lea	 rcx, QWORD PTR op1$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_get_float32

; 1363 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00234	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00239	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0023d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00242	e8 00 00 00 00	 call	 z900_vfetch4
  00247	89 44 24 58	 mov	 DWORD PTR op2$[rsp], eax

; 1364 : 
; 1365 :     softfloat_exceptionFlags = 0;

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1366 :     SET_SF_RM_FROM_FPC;

  00269	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0026e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00274	83 e0 07	 and	 eax, 7
  00277	8b c0		 mov	 eax, eax
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00280	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00285	8b d2		 mov	 edx, edx
  00287	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00297	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1367 : 
; 1368 :     ans = f32_add( op1, op2 );

  002a3	8b 54 24 58	 mov	 edx, DWORD PTR op2$[rsp]
  002a7	8b 4c 24 5c	 mov	 ecx, DWORD PTR op1$[rsp]
  002ab	e8 00 00 00 00	 call	 f32_add
  002b0	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax

; 1369 : 
; 1370 :     if (softfloat_exceptionFlags)

  002b4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b9	8b c0		 mov	 eax, eax
  002bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ca	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d2	85 c0		 test	 eax, eax
  002d4	0f 84 93 00 00
	00		 je	 $LN18@z900_add_b

; 1371 :     {
; 1372 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002da	33 c0		 xor	 eax, eax
  002dc	83 f8 01	 cmp	 eax, 1
  002df	74 45		 je	 SHORT $LN19@z900_add_b
  002e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e6	8b c0		 mov	 eax, eax
  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ff	83 e0 10	 and	 eax, 16
  00302	85 c0		 test	 eax, eax
  00304	74 20		 je	 SHORT $LN19@z900_add_b
  00306	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0030b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00311	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00316	85 c0		 test	 eax, eax
  00318	74 0c		 je	 SHORT $LN19@z900_add_b
  0031a	b2 80		 mov	 dl, 128			; 00000080H
  0031c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_add_b:

; 1373 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00326	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00330	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1374 : 
; 1375 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00334	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00338	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0033d	85 c0		 test	 eax, eax
  0033f	74 2c		 je	 SHORT $LN20@z900_add_b

; 1376 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00341	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00345	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0034a	85 c0		 test	 eax, eax
  0034c	74 0a		 je	 SHORT $LN23@z900_add_b
  0034e	c7 44 24 40 40
	ff ff ff	 mov	 DWORD PTR tv235[rsp], -192 ; ffffffffffffff40H
  00356	eb 08		 jmp	 SHORT $LN24@z900_add_b
$LN23@z900_add_b:
  00358	c7 44 24 40 c0
	00 00 00	 mov	 DWORD PTR tv235[rsp], 192 ; 000000c0H
$LN24@z900_add_b:
  00360	8b 4c 24 40	 mov	 ecx, DWORD PTR tv235[rsp]
  00364	e8 00 00 00 00	 call	 f32_scaledResult
  00369	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax
$LN20@z900_add_b:
$LN18@z900_add_b:
$LN10@z900_add_b:

; 1377 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 1378 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 1379 :     }
; 1380 : 
; 1381 :     PUT_FLOAT32_CC( ans, r1, regs );

  0036d	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  00371	d1 e0		 shl	 eax, 1
  00373	48 98		 cdqe
  00375	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0037a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00382	48 8b d0	 mov	 rdx, rax
  00385	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ans$[rsp]
  0038a	e8 00 00 00 00	 call	 z900_put_float32
  0038f	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00393	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00398	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0039d	75 17		 jne	 SHORT $LN25@z900_add_b
  0039f	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  003a3	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  003a8	85 c0		 test	 eax, eax
  003aa	74 0a		 je	 SHORT $LN25@z900_add_b
  003ac	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR tv257[rsp], 3
  003b4	eb 5e		 jmp	 SHORT $LN32@z900_add_b
$LN25@z900_add_b:
  003b6	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  003ba	0f ba f0 1f	 btr	 eax, 31
  003be	85 c0		 test	 eax, eax
  003c0	75 0a		 jne	 SHORT $LN26@z900_add_b
  003c2	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv251[rsp], 1
  003ca	eb 08		 jmp	 SHORT $LN27@z900_add_b
$LN26@z900_add_b:
  003cc	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN27@z900_add_b:
  003d4	83 7c 24 48 00	 cmp	 DWORD PTR tv251[rsp], 0
  003d9	74 0a		 je	 SHORT $LN30@z900_add_b
  003db	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv256[rsp], 0
  003e3	eb 27		 jmp	 SHORT $LN31@z900_add_b
$LN30@z900_add_b:
  003e5	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  003e9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003ee	85 c0		 test	 eax, eax
  003f0	74 0a		 je	 SHORT $LN28@z900_add_b
  003f2	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv254[rsp], 1
  003fa	eb 08		 jmp	 SHORT $LN29@z900_add_b
$LN28@z900_add_b:
  003fc	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv254[rsp], 2
$LN29@z900_add_b:
  00404	8b 44 24 4c	 mov	 eax, DWORD PTR tv254[rsp]
  00408	89 44 24 50	 mov	 DWORD PTR tv256[rsp], eax
$LN31@z900_add_b:
  0040c	8b 44 24 50	 mov	 eax, DWORD PTR tv256[rsp]
  00410	89 44 24 54	 mov	 DWORD PTR tv257[rsp], eax
$LN32@z900_add_b:
  00414	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00419	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR tv257[rsp]
  0041e	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00421	33 c0		 xor	 eax, eax
  00423	85 c0		 test	 eax, eax
  00425	0f 85 42 ff ff
	ff		 jne	 $LN10@z900_add_b

; 1382 : 
; 1383 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0042b	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0042f	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00434	85 c0		 test	 eax, eax
  00436	74 0e		 je	 SHORT $LN21@z900_add_b
  00438	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0043c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00441	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_add_b:

; 1384 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1385 : }

  00446	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0044a	c3		 ret	 0
z900_add_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
ans$ = 40
i$1 = 48
tv214 = 52
r1$ = 56
tv230 = 60
tv233 = 64
tv235 = 68
tv236 = 72
r2$ = 76
op2$ = 80
op1$ = 88
inst$ = 112
regs$ = 120
z900_add_bfp_long_reg PROC

; 1237 : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1238 :     int        r1, r2;
; 1239 :     float64_t  op1, op2, ans;
; 1240 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1241 : 
; 1242 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_b:
  00045	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN14@z900_add_b
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN14@z900_add_b:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@z900_add_b
$LN7@z900_add_b:

; 1243 :     TXF_FLOAT_INSTR_CHECK( regs );

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 6f		 je	 SHORT $LN15@z900_add_b
  0007b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00087	85 c0		 test	 eax, eax
  00089	74 5f		 je	 SHORT $LN15@z900_add_b
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 23		 jne	 SHORT $LN16@z900_add_b
  00091	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009d	85 c0		 test	 eax, eax
  0009f	75 13		 jne	 SHORT $LN16@z900_add_b
  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ad	83 e0 04	 and	 eax, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 36		 jne	 SHORT $LN15@z900_add_b
$LN16@z900_add_b:
  000b4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000bf	0f ba e8 0b	 bts	 eax, 11
  000c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198500
  000d5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN15@z900_add_b:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 84		 jne	 SHORT $LN7@z900_add_b

; 1244 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00106	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 3c		 je	 SHORT $LN18@z900_add_b
  00111	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	d1 e8		 shr	 eax, 1
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 4c		 je	 SHORT $LN17@z900_add_b
  00125	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00131	b9 08 00 00 00	 mov	 ecx, 8
  00136	48 6b c9 01	 imul	 rcx, rcx, 1
  0013a	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00142	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00148	48 85 c0	 test	 rax, rax
  0014b	75 24		 jne	 SHORT $LN17@z900_add_b
$LN18@z900_add_b:
  0014d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0015c	ba 07 00 00 00	 mov	 edx, 7
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_add_b:
$LN10@z900_add_b:

; 1245 : 
; 1246 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00171	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00175	d1 e0		 shl	 eax, 1
  00177	48 98		 cdqe
  00179	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_get_float64
  00193	8b 44 24 4c	 mov	 eax, DWORD PTR r2$[rsp]
  00197	d1 e0		 shl	 eax, 1
  00199	48 98		 cdqe
  0019b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_get_float64
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 b6		 jne	 SHORT $LN10@z900_add_b

; 1247 : 
; 1248 :     softfloat_exceptionFlags = 0;

  001bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c0	8b c0		 mov	 eax, eax
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1249 :     SET_SF_RM_FROM_FPC;

  001d9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001de	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e4	83 e0 07	 and	 eax, 7
  001e7	8b c0		 mov	 eax, eax
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001f0	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001f5	8b d2		 mov	 edx, edx
  001f7	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001fe	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00207	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1250 : 
; 1251 :     ans = f64_add( op1, op2 );

  00213	48 8b 54 24 50	 mov	 rdx, QWORD PTR op2$[rsp]
  00218	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op1$[rsp]
  0021d	e8 00 00 00 00	 call	 f64_add
  00222	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax

; 1252 : 
; 1253 :     if (softfloat_exceptionFlags)

  00227	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022c	8b c0		 mov	 eax, eax
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00234	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00241	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00245	85 c0		 test	 eax, eax
  00247	0f 84 94 00 00
	00		 je	 $LN19@z900_add_b

; 1254 :     {
; 1255 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0024d	33 c0		 xor	 eax, eax
  0024f	83 f8 01	 cmp	 eax, 1
  00252	74 45		 je	 SHORT $LN20@z900_add_b
  00254	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00259	8b c0		 mov	 eax, eax
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00261	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00272	83 e0 10	 and	 eax, 16
  00275	85 c0		 test	 eax, eax
  00277	74 20		 je	 SHORT $LN20@z900_add_b
  00279	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0027e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00284	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00289	85 c0		 test	 eax, eax
  0028b	74 0c		 je	 SHORT $LN20@z900_add_b
  0028d	b2 80		 mov	 dl, 128			; 00000080H
  0028f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	e8 00 00 00 00	 call	 ieee_trap
$LN20@z900_add_b:

; 1256 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00299	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002a3	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1257 : 
; 1258 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002a7	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ab	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002b0	85 c0		 test	 eax, eax
  002b2	74 2d		 je	 SHORT $LN21@z900_add_b

; 1259 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002b4	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b8	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002bd	85 c0		 test	 eax, eax
  002bf	74 0a		 je	 SHORT $LN24@z900_add_b
  002c1	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv214[rsp], -1536 ; fffffffffffffa00H
  002c9	eb 08		 jmp	 SHORT $LN25@z900_add_b
$LN24@z900_add_b:
  002cb	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv214[rsp], 1536 ; 00000600H
$LN25@z900_add_b:
  002d3	8b 4c 24 34	 mov	 ecx, DWORD PTR tv214[rsp]
  002d7	e8 00 00 00 00	 call	 f64_scaledResult
  002dc	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax
$LN21@z900_add_b:
$LN19@z900_add_b:
$LN13@z900_add_b:

; 1260 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 1261 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 1262 :     }
; 1263 : 
; 1264 :     PUT_FLOAT64_CC( ans, r1, regs );

  002e1	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002e5	d1 e0		 shl	 eax, 1
  002e7	48 98		 cdqe
  002e9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002ee	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002f6	48 8b d0	 mov	 rdx, rax
  002f9	48 8d 4c 24 28	 lea	 rcx, QWORD PTR ans$[rsp]
  002fe	e8 00 00 00 00	 call	 z900_put_float64
  00303	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0030d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00312	48 23 c8	 and	 rcx, rax
  00315	48 8b c1	 mov	 rax, rcx
  00318	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00322	48 3b c1	 cmp	 rax, rcx
  00325	75 24		 jne	 SHORT $LN26@z900_add_b
  00327	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00331	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00336	48 23 c8	 and	 rcx, rax
  00339	48 8b c1	 mov	 rax, rcx
  0033c	48 85 c0	 test	 rax, rax
  0033f	74 0a		 je	 SHORT $LN26@z900_add_b
  00341	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR tv236[rsp], 3
  00349	eb 79		 jmp	 SHORT $LN33@z900_add_b
$LN26@z900_add_b:
  0034b	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00355	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  0035a	48 23 c8	 and	 rcx, rax
  0035d	48 8b c1	 mov	 rax, rcx
  00360	48 85 c0	 test	 rax, rax
  00363	75 0a		 jne	 SHORT $LN27@z900_add_b
  00365	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
  0036d	eb 08		 jmp	 SHORT $LN28@z900_add_b
$LN27@z900_add_b:
  0036f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv230[rsp], 0
$LN28@z900_add_b:
  00377	83 7c 24 3c 00	 cmp	 DWORD PTR tv230[rsp], 0
  0037c	74 0a		 je	 SHORT $LN31@z900_add_b
  0037e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv235[rsp], 0
  00386	eb 34		 jmp	 SHORT $LN32@z900_add_b
$LN31@z900_add_b:
  00388	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00392	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00397	48 23 c8	 and	 rcx, rax
  0039a	48 8b c1	 mov	 rax, rcx
  0039d	48 85 c0	 test	 rax, rax
  003a0	74 0a		 je	 SHORT $LN29@z900_add_b
  003a2	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  003aa	eb 08		 jmp	 SHORT $LN30@z900_add_b
$LN29@z900_add_b:
  003ac	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv233[rsp], 2
$LN30@z900_add_b:
  003b4	8b 44 24 40	 mov	 eax, DWORD PTR tv233[rsp]
  003b8	89 44 24 44	 mov	 DWORD PTR tv235[rsp], eax
$LN32@z900_add_b:
  003bc	8b 44 24 44	 mov	 eax, DWORD PTR tv235[rsp]
  003c0	89 44 24 48	 mov	 DWORD PTR tv236[rsp], eax
$LN33@z900_add_b:
  003c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c9	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv236[rsp]
  003ce	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  003d1	33 c0		 xor	 eax, eax
  003d3	85 c0		 test	 eax, eax
  003d5	0f 85 06 ff ff
	ff		 jne	 $LN13@z900_add_b

; 1265 : 
; 1266 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003db	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003df	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003e4	85 c0		 test	 eax, eax
  003e6	74 0e		 je	 SHORT $LN22@z900_add_b
  003e8	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN22@z900_add_b:

; 1267 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1268 : }

  003f6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003fa	c3		 ret	 0
z900_add_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
effective_addr2$ = 48
ans$ = 56
tv235 = 64
r1$ = 68
tv251 = 72
tv254 = 76
tv256 = 80
tv257 = 84
op2$ = 88
op1$ = 96
inst$ = 128
regs$ = 136
z900_add_bfp_long PROC

; 1274 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1275 :     int        r1, x2, b2;
; 1276 :     VADR       effective_addr2;
; 1277 :     float64_t  op1, op2, ans;
; 1278 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1279 : 
; 1280 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00037	8b c0		 mov	 eax, eax
  00039	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 10	 shr	 eax, 16
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  0004c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00050	c1 e8 14	 shr	 eax, 20
  00053	83 e0 0f	 and	 eax, 15
  00056	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  0005a	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005f	74 25		 je	 SHORT $LN11@z900_add_b
  00061	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00066	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 03 c8	 add	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_add_b:
  00086	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008a	c1 e8 0c	 shr	 eax, 12
  0008d	83 e0 0f	 and	 eax, 15
  00090	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00094	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 25		 je	 SHORT $LN12@z900_add_b
  0009b	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b5	48 03 c8	 add	 rcx, rax
  000b8	48 8b c1	 mov	 rax, rcx
  000bb	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_add_b:
  000c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d4	48 23 c8	 and	 rcx, rax
  000d7	48 8b c1	 mov	 rax, rcx
  000da	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_add_b:
  000df	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000eb	48 83 c0 06	 add	 rax, 6
  000ef	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fb	33 c0		 xor	 eax, eax
  000fd	83 f8 06	 cmp	 eax, 6
  00100	74 0f		 je	 SHORT $LN13@z900_add_b
  00102	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_add_b:
  00111	33 c0		 xor	 eax, eax
  00113	85 c0		 test	 eax, eax
  00115	75 c8		 jne	 SHORT $LN4@z900_add_b

; 1281 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00117	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0011c	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  00120	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_add_b:

; 1282 :     TXF_FLOAT_INSTR_CHECK( regs );

  0012d	33 c0		 xor	 eax, eax
  0012f	83 f8 01	 cmp	 eax, 1
  00132	0f 84 81 00 00
	00		 je	 $LN14@z900_add_b
  00138	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00140	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00147	85 c0		 test	 eax, eax
  00149	74 6e		 je	 SHORT $LN14@z900_add_b
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	75 29		 jne	 SHORT $LN15@z900_add_b
  00151	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00160	85 c0		 test	 eax, eax
  00162	75 16		 jne	 SHORT $LN15@z900_add_b
  00164	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00173	83 e0 04	 and	 eax, 4
  00176	85 c0		 test	 eax, eax
  00178	75 3f		 jne	 SHORT $LN14@z900_add_b
$LN15@z900_add_b:
  0017a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00188	0f ba e8 0b	 bts	 eax, 11
  0018c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0019a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198535
  001a1	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a7	ba 02 00 00 00	 mov	 edx, 2
  001ac	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b4	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_add_b:
  001b9	33 c0		 xor	 eax, eax
  001bb	85 c0		 test	 eax, eax
  001bd	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_add_b

; 1283 :     BFPINST_CHECK( regs );

  001c3	b8 08 00 00 00	 mov	 eax, 8
  001c8	48 6b c0 01	 imul	 rax, rax, 1
  001cc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001dc	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e2	48 85 c0	 test	 rax, rax
  001e5	74 42		 je	 SHORT $LN17@z900_add_b
  001e7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f5	d1 e8		 shr	 eax, 1
  001f7	83 e0 01	 and	 eax, 1
  001fa	85 c0		 test	 eax, eax
  001fc	74 58		 je	 SHORT $LN16@z900_add_b
  001fe	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00206	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020d	b9 08 00 00 00	 mov	 ecx, 8
  00212	48 6b c9 01	 imul	 rcx, rcx, 1
  00216	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00224	48 85 c0	 test	 rax, rax
  00227	75 2d		 jne	 SHORT $LN16@z900_add_b
$LN17@z900_add_b:
  00229	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00231	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0023b	ba 07 00 00 00	 mov	 edx, 7
  00240	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00248	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00250	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_add_b:

; 1284 : 
; 1285 :     GET_FLOAT64_OP( op1, r1, regs );

  00256	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  0025a	d1 e0		 shl	 eax, 1
  0025c	48 98		 cdqe
  0025e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00266	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0026e	48 8b d0	 mov	 rdx, rax
  00271	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  00276	e8 00 00 00 00	 call	 z900_get_float64

; 1286 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0027b	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00283	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00287	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0028c	e8 00 00 00 00	 call	 z900_vfetch8
  00291	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 1287 : 
; 1288 :     softfloat_exceptionFlags = 0;

  00296	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0029b	8b c0		 mov	 eax, eax
  0029d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ac	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b0	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1289 :     SET_SF_RM_FROM_FPC;

  002b4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c2	83 e0 07	 and	 eax, 7
  002c5	8b c0		 mov	 eax, eax
  002c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  002d3	8b d2		 mov	 edx, edx
  002d5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  002dc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  002e5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  002e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ed	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1290 : 
; 1291 :     ans = f64_add( op1, op2 );

  002f1	48 8b 54 24 58	 mov	 rdx, QWORD PTR op2$[rsp]
  002f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  002fb	e8 00 00 00 00	 call	 f64_add
  00300	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 1292 : 
; 1293 :     if (softfloat_exceptionFlags)

  00305	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0030a	8b c0		 mov	 eax, eax
  0030c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00312	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0031b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00323	85 c0		 test	 eax, eax
  00325	0f 84 9d 00 00
	00		 je	 $LN18@z900_add_b

; 1294 :     {
; 1295 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0032b	33 c0		 xor	 eax, eax
  0032d	83 f8 01	 cmp	 eax, 1
  00330	74 4b		 je	 SHORT $LN19@z900_add_b
  00332	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00337	8b c0		 mov	 eax, eax
  00339	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0033f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00348	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0034c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00350	83 e0 10	 and	 eax, 16
  00353	85 c0		 test	 eax, eax
  00355	74 26		 je	 SHORT $LN19@z900_add_b
  00357	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00365	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0036a	85 c0		 test	 eax, eax
  0036c	74 0f		 je	 SHORT $LN19@z900_add_b
  0036e	b2 80		 mov	 dl, 128			; 00000080H
  00370	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	e8 00 00 00 00	 call	 ieee_trap
$LN19@z900_add_b:

; 1296 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0037d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00385	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0038a	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1297 : 
; 1298 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0038e	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00392	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00397	85 c0		 test	 eax, eax
  00399	74 2d		 je	 SHORT $LN20@z900_add_b

; 1299 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0039b	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0039f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003a4	85 c0		 test	 eax, eax
  003a6	74 0a		 je	 SHORT $LN23@z900_add_b
  003a8	c7 44 24 40 00
	fa ff ff	 mov	 DWORD PTR tv235[rsp], -1536 ; fffffffffffffa00H
  003b0	eb 08		 jmp	 SHORT $LN24@z900_add_b
$LN23@z900_add_b:
  003b2	c7 44 24 40 00
	06 00 00	 mov	 DWORD PTR tv235[rsp], 1536 ; 00000600H
$LN24@z900_add_b:
  003ba	8b 4c 24 40	 mov	 ecx, DWORD PTR tv235[rsp]
  003be	e8 00 00 00 00	 call	 f64_scaledResult
  003c3	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN20@z900_add_b:
$LN18@z900_add_b:
$LN10@z900_add_b:

; 1300 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 1301 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 1302 :     }
; 1303 : 
; 1304 :     PUT_FLOAT64_CC( ans, r1, regs );

  003c8	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  003cc	d1 e0		 shl	 eax, 1
  003ce	48 98		 cdqe
  003d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003e0	48 8b d0	 mov	 rdx, rax
  003e3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  003e8	e8 00 00 00 00	 call	 z900_put_float64
  003ed	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  003f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ans$[rsp]
  003fc	48 23 c8	 and	 rcx, rax
  003ff	48 8b c1	 mov	 rax, rcx
  00402	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0040c	48 3b c1	 cmp	 rax, rcx
  0040f	75 24		 jne	 SHORT $LN25@z900_add_b
  00411	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0041b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ans$[rsp]
  00420	48 23 c8	 and	 rcx, rax
  00423	48 8b c1	 mov	 rax, rcx
  00426	48 85 c0	 test	 rax, rax
  00429	74 0a		 je	 SHORT $LN25@z900_add_b
  0042b	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR tv257[rsp], 3
  00433	eb 79		 jmp	 SHORT $LN32@z900_add_b
$LN25@z900_add_b:
  00435	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0043f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ans$[rsp]
  00444	48 23 c8	 and	 rcx, rax
  00447	48 8b c1	 mov	 rax, rcx
  0044a	48 85 c0	 test	 rax, rax
  0044d	75 0a		 jne	 SHORT $LN26@z900_add_b
  0044f	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv251[rsp], 1
  00457	eb 08		 jmp	 SHORT $LN27@z900_add_b
$LN26@z900_add_b:
  00459	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN27@z900_add_b:
  00461	83 7c 24 48 00	 cmp	 DWORD PTR tv251[rsp], 0
  00466	74 0a		 je	 SHORT $LN30@z900_add_b
  00468	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv256[rsp], 0
  00470	eb 34		 jmp	 SHORT $LN31@z900_add_b
$LN30@z900_add_b:
  00472	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0047c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ans$[rsp]
  00481	48 23 c8	 and	 rcx, rax
  00484	48 8b c1	 mov	 rax, rcx
  00487	48 85 c0	 test	 rax, rax
  0048a	74 0a		 je	 SHORT $LN28@z900_add_b
  0048c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv254[rsp], 1
  00494	eb 08		 jmp	 SHORT $LN29@z900_add_b
$LN28@z900_add_b:
  00496	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv254[rsp], 2
$LN29@z900_add_b:
  0049e	8b 44 24 4c	 mov	 eax, DWORD PTR tv254[rsp]
  004a2	89 44 24 50	 mov	 DWORD PTR tv256[rsp], eax
$LN31@z900_add_b:
  004a6	8b 44 24 50	 mov	 eax, DWORD PTR tv256[rsp]
  004aa	89 44 24 54	 mov	 DWORD PTR tv257[rsp], eax
$LN32@z900_add_b:
  004ae	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b6	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR tv257[rsp]
  004bb	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  004be	33 c0		 xor	 eax, eax
  004c0	85 c0		 test	 eax, eax
  004c2	0f 85 00 ff ff
	ff		 jne	 $LN10@z900_add_b

; 1305 : 
; 1306 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  004c8	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004cc	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  004d1	85 c0		 test	 eax, eax
  004d3	74 11		 je	 SHORT $LN21@z900_add_b
  004d5	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_add_b:

; 1307 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1308 : }

  004e6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004ea	c3		 ret	 0
z900_add_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv223 = 48
tv253 = 52
tv258 = 56
tv260 = 60
tv261 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
ans$ = 144
op2$ = 160
op1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
z900_add_bfp_ext_reg PROC

; 1198 : {

$LN37:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1199 :     int         r1, r2;
; 1200 :     float128_t  op1, op2, ans;
; 1201 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1202 : 
; 1203 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_b:
  0005f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN14@z900_add_b
  00082	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN14@z900_add_b:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@z900_add_b
$LN7@z900_add_b:

; 1204 :     TXF_FLOAT_INSTR_CHECK( regs );

  00097	33 c0		 xor	 eax, eax
  00099	83 f8 01	 cmp	 eax, 1
  0009c	0f 84 81 00 00
	00		 je	 $LN15@z900_add_b
  000a2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b1	85 c0		 test	 eax, eax
  000b3	74 6e		 je	 SHORT $LN15@z900_add_b
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 29		 jne	 SHORT $LN16@z900_add_b
  000bb	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000ca	85 c0		 test	 eax, eax
  000cc	75 16		 jne	 SHORT $LN16@z900_add_b
  000ce	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000dd	83 e0 04	 and	 eax, 4
  000e0	85 c0		 test	 eax, eax
  000e2	75 3f		 jne	 SHORT $LN15@z900_add_b
$LN16@z900_add_b:
  000e4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f2	0f ba e8 0b	 bts	 eax, 11
  000f6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00104	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198464
  0010b	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN15@z900_add_b:
  00123	33 c0		 xor	 eax, eax
  00125	85 c0		 test	 eax, eax
  00127	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_add_b

; 1205 :     BFPINST_CHECK( regs );

  0012d	b8 08 00 00 00	 mov	 eax, 8
  00132	48 6b c0 01	 imul	 rax, rax, 1
  00136	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00146	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014c	48 85 c0	 test	 rax, rax
  0014f	74 42		 je	 SHORT $LN18@z900_add_b
  00151	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015f	d1 e8		 shr	 eax, 1
  00161	83 e0 01	 and	 eax, 1
  00164	85 c0		 test	 eax, eax
  00166	74 58		 je	 SHORT $LN17@z900_add_b
  00168	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00177	b9 08 00 00 00	 mov	 ecx, 8
  0017c	48 6b c9 01	 imul	 rcx, rcx, 1
  00180	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00188	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018e	48 85 c0	 test	 rax, rax
  00191	75 2d		 jne	 SHORT $LN17@z900_add_b
$LN18@z900_add_b:
  00193	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001a5	ba 07 00 00 00	 mov	 edx, 7
  001aa	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_add_b:

; 1206 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  001c0	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001c4	83 e0 02	 and	 eax, 2
  001c7	85 c0		 test	 eax, eax
  001c9	75 0b		 jne	 SHORT $LN20@z900_add_b
  001cb	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001cf	83 e0 02	 and	 eax, 2
  001d2	85 c0		 test	 eax, eax
  001d4	74 1b		 je	 SHORT $LN19@z900_add_b
$LN20@z900_add_b:
  001d6	ba 06 00 00 00	 mov	 edx, 6
  001db	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_add_b:
$LN10@z900_add_b:

; 1207 : 
; 1208 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  001f1	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001f5	d1 e0		 shl	 eax, 1
  001f7	48 98		 cdqe
  001f9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00209	48 8b d0	 mov	 rdx, rax
  0020c	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00214	e8 00 00 00 00	 call	 z900_get_float128
  00219	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0021d	d1 e0		 shl	 eax, 1
  0021f	48 98		 cdqe
  00221	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00231	48 8b d0	 mov	 rdx, rax
  00234	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0023c	e8 00 00 00 00	 call	 z900_get_float128
  00241	33 c0		 xor	 eax, eax
  00243	85 c0		 test	 eax, eax
  00245	75 aa		 jne	 SHORT $LN10@z900_add_b

; 1209 : 
; 1210 :     softfloat_exceptionFlags = 0;

  00247	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0024c	8b c0		 mov	 eax, eax
  0024e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00254	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00261	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1211 :     SET_SF_RM_FROM_FPC;

  00265	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00273	83 e0 07	 and	 eax, 7
  00276	8b c0		 mov	 eax, eax
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0027f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00284	8b d2		 mov	 edx, edx
  00286	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0028d	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00296	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0029a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029e	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1212 : 
; 1213 :     ans = f128_add( op1, op2 );

  002a2	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  002a7	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  002af	48 8b f8	 mov	 rdi, rax
  002b2	48 8b f1	 mov	 rsi, rcx
  002b5	b9 10 00 00 00	 mov	 ecx, 16
  002ba	f3 a4		 rep movsb
  002bc	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  002c1	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  002c9	48 8b f8	 mov	 rdi, rax
  002cc	48 8b f1	 mov	 rsi, rcx
  002cf	b9 10 00 00 00	 mov	 ecx, 16
  002d4	f3 a4		 rep movsb
  002d6	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  002db	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  002e0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  002e5	e8 00 00 00 00	 call	 f128_add
  002ea	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  002f2	48 8b f9	 mov	 rdi, rcx
  002f5	48 8b f0	 mov	 rsi, rax
  002f8	b9 10 00 00 00	 mov	 ecx, 16
  002fd	f3 a4		 rep movsb

; 1214 : 
; 1215 :     if (softfloat_exceptionFlags)

  002ff	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00304	8b c0		 mov	 eax, eax
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00315	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00319	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031d	85 c0		 test	 eax, eax
  0031f	0f 84 b5 00 00
	00		 je	 $LN21@z900_add_b

; 1216 :     {
; 1217 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00325	33 c0		 xor	 eax, eax
  00327	83 f8 01	 cmp	 eax, 1
  0032a	74 4b		 je	 SHORT $LN22@z900_add_b
  0032c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00331	8b c0		 mov	 eax, eax
  00333	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00339	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00342	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00346	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034a	83 e0 10	 and	 eax, 16
  0034d	85 c0		 test	 eax, eax
  0034f	74 26		 je	 SHORT $LN22@z900_add_b
  00351	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00359	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0035f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00364	85 c0		 test	 eax, eax
  00366	74 0f		 je	 SHORT $LN22@z900_add_b
  00368	b2 80		 mov	 dl, 128			; 00000080H
  0036a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00372	e8 00 00 00 00	 call	 ieee_trap
$LN22@z900_add_b:

; 1218 : 
; 1219 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00377	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037f	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00384	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1220 : 
; 1221 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00388	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0038c	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00391	85 c0		 test	 eax, eax
  00393	74 45		 je	 SHORT $LN23@z900_add_b

; 1222 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00395	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00399	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0039e	85 c0		 test	 eax, eax
  003a0	74 0a		 je	 SHORT $LN26@z900_add_b
  003a2	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv223[rsp], -24576 ; ffffffffffffa000H
  003aa	eb 08		 jmp	 SHORT $LN27@z900_add_b
$LN26@z900_add_b:
  003ac	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv223[rsp], 24576 ; 00006000H
$LN27@z900_add_b:
  003b4	8b 54 24 30	 mov	 edx, DWORD PTR tv223[rsp]
  003b8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  003c0	e8 00 00 00 00	 call	 f128_scaledResult
  003c5	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  003cd	48 8b f9	 mov	 rdi, rcx
  003d0	48 8b f0	 mov	 rsi, rax
  003d3	b9 10 00 00 00	 mov	 ecx, 16
  003d8	f3 a4		 rep movsb
$LN23@z900_add_b:
$LN21@z900_add_b:
$LN13@z900_add_b:

; 1223 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 1224 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 1225 :     }
; 1226 : 
; 1227 :     PUT_FLOAT128_CC( ans, r1, regs );

  003da	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  003de	d1 e0		 shl	 eax, 1
  003e0	48 98		 cdqe
  003e2	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ea	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003f2	48 8b d0	 mov	 rdx, rax
  003f5	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  003fd	e8 00 00 00 00	 call	 z900_put_float128
  00402	b8 08 00 00 00	 mov	 eax, 8
  00407	48 6b c0 01	 imul	 rax, rax, 1
  0040b	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00415	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  0041d	48 23 c1	 and	 rax, rcx
  00420	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0042a	48 3b c1	 cmp	 rax, rcx
  0042d	75 44		 jne	 SHORT $LN29@z900_add_b
  0042f	b8 08 00 00 00	 mov	 eax, 8
  00434	48 6b c0 01	 imul	 rax, rax, 1
  00438	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  00442	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  0044a	48 23 c1	 and	 rax, rcx
  0044d	48 85 c0	 test	 rax, rax
  00450	75 14		 jne	 SHORT $LN28@z900_add_b
  00452	b8 08 00 00 00	 mov	 eax, 8
  00457	48 6b c0 00	 imul	 rax, rax, 0
  0045b	48 83 bc 04 90
	00 00 00 00	 cmp	 QWORD PTR ans$[rsp+rax], 0
  00464	74 0d		 je	 SHORT $LN29@z900_add_b
$LN28@z900_add_b:
  00466	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv261[rsp], 3
  0046e	e9 9c 00 00 00	 jmp	 $LN36@z900_add_b
$LN29@z900_add_b:
  00473	b8 08 00 00 00	 mov	 eax, 8
  00478	48 6b c0 01	 imul	 rax, rax, 1
  0047c	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00486	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  0048e	48 23 c1	 and	 rax, rcx
  00491	b9 08 00 00 00	 mov	 ecx, 8
  00496	48 6b c9 00	 imul	 rcx, rcx, 0
  0049a	48 0b 84 0c 90
	00 00 00	 or	 rax, QWORD PTR ans$[rsp+rcx]
  004a2	48 85 c0	 test	 rax, rax
  004a5	75 0a		 jne	 SHORT $LN30@z900_add_b
  004a7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv253[rsp], 1
  004af	eb 08		 jmp	 SHORT $LN31@z900_add_b
$LN30@z900_add_b:
  004b1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN31@z900_add_b:
  004b9	83 7c 24 34 00	 cmp	 DWORD PTR tv253[rsp], 0
  004be	74 0a		 je	 SHORT $LN34@z900_add_b
  004c0	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv260[rsp], 0
  004c8	eb 3d		 jmp	 SHORT $LN35@z900_add_b
$LN34@z900_add_b:
  004ca	b8 08 00 00 00	 mov	 eax, 8
  004cf	48 6b c0 01	 imul	 rax, rax, 1
  004d3	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  004dd	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  004e5	48 23 c1	 and	 rax, rcx
  004e8	48 85 c0	 test	 rax, rax
  004eb	74 0a		 je	 SHORT $LN32@z900_add_b
  004ed	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv258[rsp], 1
  004f5	eb 08		 jmp	 SHORT $LN33@z900_add_b
$LN32@z900_add_b:
  004f7	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv258[rsp], 2
$LN33@z900_add_b:
  004ff	8b 44 24 38	 mov	 eax, DWORD PTR tv258[rsp]
  00503	89 44 24 3c	 mov	 DWORD PTR tv260[rsp], eax
$LN35@z900_add_b:
  00507	8b 44 24 3c	 mov	 eax, DWORD PTR tv260[rsp]
  0050b	89 44 24 40	 mov	 DWORD PTR tv261[rsp], eax
$LN36@z900_add_b:
  0050f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00517	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv261[rsp]
  0051c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0051f	33 c0		 xor	 eax, eax
  00521	85 c0		 test	 eax, eax
  00523	0f 85 b1 fe ff
	ff		 jne	 $LN13@z900_add_b

; 1228 : 
; 1229 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00529	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0052d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00532	85 c0		 test	 eax, eax
  00534	74 11		 je	 SHORT $LN24@z900_add_b
  00536	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0053a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00542	e8 00 00 00 00	 call	 ieee_cond_trap
$LN24@z900_add_b:

; 1230 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1231 : }

  00547	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0054f	48 33 cc	 xor	 rcx, rsp
  00552	e8 00 00 00 00	 call	 __security_check_cookie
  00557	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0055e	5f		 pop	 rdi
  0055f	5e		 pop	 rsi
  00560	c3		 ret	 0
z900_add_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
op2$ = 36
temp$1 = 40
ieee_trap_conds$ = 44
tv208 = 48
tv214 = 52
tv273 = 56
tv276 = 60
tv278 = 64
tv279 = 68
r2$ = 72
r1$ = 76
op1$ = 80
inst$ = 112
regs$ = 120
z900_convert_bfp_short_to_u64_reg PROC

; 2875 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2876 :     int        r1, r2;
; 2877 :     BYTE       m3, m4, newcc;
; 2878 :     U64        op1;
; 2879 :     float32_t  op2;
; 2880 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2881 : 
; 2882 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2883 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199646
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2884 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2885 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2886 : 
; 2887 :     GET_FLOAT32_OP( op2, r2, regs );

  0019b	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  0019f	d1 e0		 shl	 eax, 1
  001a1	48 98		 cdqe
  001a3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b0	48 8b d0	 mov	 rdx, rax
  001b3	48 8d 4c 24 24	 lea	 rcx, QWORD PTR op2$[rsp]
  001b8	e8 00 00 00 00	 call	 z900_get_float32

; 2888 :     softfloat_exceptionFlags = 0;

  001bd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c2	8b c0		 mov	 eax, eax
  001c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ca	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d7	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2889 : 
; 2890 :     if (FLOAT32_ISNAN( op2 ))

  001db	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  001df	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  001e4	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  001e9	75 5c		 jne	 SHORT $LN13@z900_conve
  001eb	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  001ef	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001f4	85 c0		 test	 eax, eax
  001f6	74 4f		 je	 SHORT $LN13@z900_conve

; 2891 :     {
; 2892 :         op1 = 0;

  001f8	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2893 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00201	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00206	8b c0		 mov	 eax, eax
  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00217	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021f	83 c8 10	 or	 eax, 16
  00222	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00228	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00231	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00237	45 8b c0	 mov	 r8d, r8d
  0023a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023e	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2894 :     }

  00242	e9 b0 00 00 00	 jmp	 $LN14@z900_conve
$LN13@z900_conve:

; 2895 :     else
; 2896 :     {
; 2897 :         SET_SF_RM_FROM_MASK( m3 );

  00247	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0024c	85 c0		 test	 eax, eax
  0024e	74 16		 je	 SHORT $LN21@z900_conve
  00250	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0025c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00260	89 44 24 30	 mov	 DWORD PTR tv208[rsp], eax
  00264	eb 1f		 jmp	 SHORT $LN22@z900_conve
$LN21@z900_conve:
  00266	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00271	83 e0 07	 and	 eax, 7
  00274	8b c0		 mov	 eax, eax
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	89 44 24 30	 mov	 DWORD PTR tv208[rsp], eax
$LN22@z900_conve:
  00285	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0028a	8b c0		 mov	 eax, eax
  0028c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00292	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029f	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv208[rsp]
  002a4	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2898 :         op1 = f32_to_ui64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002a7	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002ac	83 e0 04	 and	 eax, 4
  002af	85 c0		 test	 eax, eax
  002b1	75 0a		 jne	 SHORT $LN23@z900_conve
  002b3	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
  002bb	eb 08		 jmp	 SHORT $LN24@z900_conve
$LN23@z900_conve:
  002bd	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN24@z900_conve:
  002c5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002ca	8b c0		 mov	 eax, eax
  002cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002db	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002df	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv214[rsp]
  002e5	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002e9	8b 4c 24 24	 mov	 ecx, DWORD PTR op2$[rsp]
  002ed	e8 00 00 00 00	 call	 f32_to_ui64
  002f2	48 89 44 24 50	 mov	 QWORD PTR op1$[rsp], rax
$LN14@z900_conve:

; 2899 :     }
; 2900 : 
; 2901 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002f7	33 c0		 xor	 eax, eax
  002f9	83 f8 01	 cmp	 eax, 1
  002fc	74 45		 je	 SHORT $LN15@z900_conve
  002fe	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00303	8b c0		 mov	 eax, eax
  00305	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00314	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00318	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031c	83 e0 10	 and	 eax, 16
  0031f	85 c0		 test	 eax, eax
  00321	74 20		 je	 SHORT $LN15@z900_conve
  00323	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00328	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0032e	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00333	85 c0		 test	 eax, eax
  00335	74 0c		 je	 SHORT $LN15@z900_conve
  00337	b2 80		 mov	 dl, 128			; 00000080H
  00339	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0033e	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_conve:

; 2902 : 
; 2903 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00343	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00348	8b c0		 mov	 eax, eax
  0034a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00350	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00359	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0035d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00361	83 e0 10	 and	 eax, 16
  00364	85 c0		 test	 eax, eax
  00366	74 57		 je	 SHORT $LN16@z900_conve

; 2904 :     {
; 2905 :         newcc = 3;

  00368	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2906 : 
; 2907 :         if (!SUPPRESS_INEXACT( m4 ))

  0036d	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00372	83 e0 04	 and	 eax, 4
  00375	85 c0		 test	 eax, eax
  00377	75 41		 jne	 SHORT $LN18@z900_conve

; 2908 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00379	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0037e	8b c0		 mov	 eax, eax
  00380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00386	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	83 c8 01	 or	 eax, 1
  0039a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003a9	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  003af	45 8b c0	 mov	 r8d, r8d
  003b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b6	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN18@z900_conve:

; 2909 :     }

  003ba	e9 8e 00 00 00	 jmp	 $LN17@z900_conve
$LN16@z900_conve:

; 2910 :     else
; 2911 :         newcc = FLOAT32_CC( op2 );

  003bf	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  003c3	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  003c8	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  003cd	75 17		 jne	 SHORT $LN25@z900_conve
  003cf	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  003d3	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  003d8	85 c0		 test	 eax, eax
  003da	74 0a		 je	 SHORT $LN25@z900_conve
  003dc	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR tv279[rsp], 3
  003e4	eb 5e		 jmp	 SHORT $LN32@z900_conve
$LN25@z900_conve:
  003e6	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  003ea	0f ba f0 1f	 btr	 eax, 31
  003ee	85 c0		 test	 eax, eax
  003f0	75 0a		 jne	 SHORT $LN26@z900_conve
  003f2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv273[rsp], 1
  003fa	eb 08		 jmp	 SHORT $LN27@z900_conve
$LN26@z900_conve:
  003fc	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv273[rsp], 0
$LN27@z900_conve:
  00404	83 7c 24 38 00	 cmp	 DWORD PTR tv273[rsp], 0
  00409	74 0a		 je	 SHORT $LN30@z900_conve
  0040b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv278[rsp], 0
  00413	eb 27		 jmp	 SHORT $LN31@z900_conve
$LN30@z900_conve:
  00415	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  00419	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0041e	85 c0		 test	 eax, eax
  00420	74 0a		 je	 SHORT $LN28@z900_conve
  00422	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv276[rsp], 1
  0042a	eb 08		 jmp	 SHORT $LN29@z900_conve
$LN28@z900_conve:
  0042c	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tv276[rsp], 2
$LN29@z900_conve:
  00434	8b 44 24 3c	 mov	 eax, DWORD PTR tv276[rsp]
  00438	89 44 24 40	 mov	 DWORD PTR tv278[rsp], eax
$LN31@z900_conve:
  0043c	8b 44 24 40	 mov	 eax, DWORD PTR tv278[rsp]
  00440	89 44 24 44	 mov	 DWORD PTR tv279[rsp], eax
$LN32@z900_conve:
  00444	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv279[rsp]
  00449	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN17@z900_conve:

; 2912 : 
; 2913 :     regs->GR_G( r1 ) = op1;

  0044d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00452	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00457	48 8b 54 24 50	 mov	 rdx, QWORD PTR op1$[rsp]
  0045c	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2914 :     regs->psw.cc = newcc;

  00464	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00469	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0046e	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2915 : 
; 2916 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00471	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00476	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0047b	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2917 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0047f	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00483	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00488	85 c0		 test	 eax, eax
  0048a	74 0e		 je	 SHORT $LN19@z900_conve
  0048c	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00490	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00495	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_conve:

; 2918 : }

  0049a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0049e	c3		 ret	 0
z900_convert_bfp_short_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
temp$1 = 36
ieee_trap_conds$ = 40
op2$ = 48
tv208 = 56
tv214 = 60
tv273 = 64
tv276 = 68
tv278 = 72
tv279 = 76
r2$ = 80
r1$ = 84
op1$ = 88
inst$ = 112
regs$ = 120
z900_convert_bfp_long_to_u64_reg PROC

; 2825 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2826 :     int        r1, r2;
; 2827 :     BYTE       m3, m4, newcc;
; 2828 :     U64        op1;
; 2829 :     float64_t  op2;
; 2830 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2831 : 
; 2832 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 50	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 54	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2833 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199613
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2834 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2835 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2836 : 
; 2837 :     GET_FLOAT64_OP( op2, r2, regs );

  0019b	8b 44 24 50	 mov	 eax, DWORD PTR r2$[rsp]
  0019f	d1 e0		 shl	 eax, 1
  001a1	48 98		 cdqe
  001a3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b0	48 8b d0	 mov	 rdx, rax
  001b3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  001b8	e8 00 00 00 00	 call	 z900_get_float64

; 2838 :     softfloat_exceptionFlags = 0;

  001bd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c2	8b c0		 mov	 eax, eax
  001c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ca	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d7	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2839 : 
; 2840 :     if (FLOAT64_ISNAN( op2 ))

  001db	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  001e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  001ea	48 23 c8	 and	 rcx, rax
  001ed	48 8b c1	 mov	 rax, rcx
  001f0	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001fa	48 3b c1	 cmp	 rax, rcx
  001fd	75 69		 jne	 SHORT $LN13@z900_conve
  001ff	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00209	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0020e	48 23 c8	 and	 rcx, rax
  00211	48 8b c1	 mov	 rax, rcx
  00214	48 85 c0	 test	 rax, rax
  00217	74 4f		 je	 SHORT $LN13@z900_conve

; 2841 :     {
; 2842 :         op1 = 0;

  00219	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2843 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00222	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00227	8b c0		 mov	 eax, eax
  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00238	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00240	83 c8 10	 or	 eax, 16
  00243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00249	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00252	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00258	45 8b c0	 mov	 r8d, r8d
  0025b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025f	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2844 :     }

  00263	e9 b1 00 00 00	 jmp	 $LN14@z900_conve
$LN13@z900_conve:

; 2845 :     else
; 2846 :     {
; 2847 :         SET_SF_RM_FROM_MASK( m3 );

  00268	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0026d	85 c0		 test	 eax, eax
  0026f	74 16		 je	 SHORT $LN21@z900_conve
  00271	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	89 44 24 38	 mov	 DWORD PTR tv208[rsp], eax
  00285	eb 1f		 jmp	 SHORT $LN22@z900_conve
$LN21@z900_conve:
  00287	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0028c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00292	83 e0 07	 and	 eax, 7
  00295	8b c0		 mov	 eax, eax
  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0029e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a2	89 44 24 38	 mov	 DWORD PTR tv208[rsp], eax
$LN22@z900_conve:
  002a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002ab	8b c0		 mov	 eax, eax
  002ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002bc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c0	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv208[rsp]
  002c5	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2848 :         op1 = f64_to_ui64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002c8	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002cd	83 e0 04	 and	 eax, 4
  002d0	85 c0		 test	 eax, eax
  002d2	75 0a		 jne	 SHORT $LN23@z900_conve
  002d4	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
  002dc	eb 08		 jmp	 SHORT $LN24@z900_conve
$LN23@z900_conve:
  002de	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN24@z900_conve:
  002e6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002eb	8b c0		 mov	 eax, eax
  002ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002fc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00300	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv214[rsp]
  00306	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0030a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0030f	e8 00 00 00 00	 call	 f64_to_ui64
  00314	48 89 44 24 58	 mov	 QWORD PTR op1$[rsp], rax
$LN14@z900_conve:

; 2849 :     }
; 2850 : 
; 2851 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00319	33 c0		 xor	 eax, eax
  0031b	83 f8 01	 cmp	 eax, 1
  0031e	74 45		 je	 SHORT $LN15@z900_conve
  00320	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00325	8b c0		 mov	 eax, eax
  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0032d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00336	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0033a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0033e	83 e0 10	 and	 eax, 16
  00341	85 c0		 test	 eax, eax
  00343	74 20		 je	 SHORT $LN15@z900_conve
  00345	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0034a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00350	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00355	85 c0		 test	 eax, eax
  00357	74 0c		 je	 SHORT $LN15@z900_conve
  00359	b2 80		 mov	 dl, 128			; 00000080H
  0035b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00360	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_conve:

; 2852 : 
; 2853 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00365	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0036a	8b c0		 mov	 eax, eax
  0036c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00372	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0037b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0037f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00383	83 e0 10	 and	 eax, 16
  00386	85 c0		 test	 eax, eax
  00388	74 57		 je	 SHORT $LN16@z900_conve

; 2854 :     {
; 2855 :         newcc = 3;

  0038a	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2856 : 
; 2857 :         if (!SUPPRESS_INEXACT( m4 ))

  0038f	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00394	83 e0 04	 and	 eax, 4
  00397	85 c0		 test	 eax, eax
  00399	75 41		 jne	 SHORT $LN18@z900_conve

; 2858 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  0039b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003a0	8b c0		 mov	 eax, eax
  003a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003b1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b9	83 c8 01	 or	 eax, 1
  003bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003c2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003cb	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  003d1	45 8b c0	 mov	 r8d, r8d
  003d4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003d8	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN18@z900_conve:

; 2859 :     }

  003dc	e9 ca 00 00 00	 jmp	 $LN17@z900_conve
$LN16@z900_conve:

; 2860 :     else
; 2861 :         newcc = FLOAT64_CC( op2 );

  003e1	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  003eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  003f0	48 23 c8	 and	 rcx, rax
  003f3	48 8b c1	 mov	 rax, rcx
  003f6	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00400	48 3b c1	 cmp	 rax, rcx
  00403	75 24		 jne	 SHORT $LN25@z900_conve
  00405	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0040f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00414	48 23 c8	 and	 rcx, rax
  00417	48 8b c1	 mov	 rax, rcx
  0041a	48 85 c0	 test	 rax, rax
  0041d	74 0a		 je	 SHORT $LN25@z900_conve
  0041f	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv279[rsp], 3
  00427	eb 79		 jmp	 SHORT $LN32@z900_conve
$LN25@z900_conve:
  00429	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00433	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00438	48 23 c8	 and	 rcx, rax
  0043b	48 8b c1	 mov	 rax, rcx
  0043e	48 85 c0	 test	 rax, rax
  00441	75 0a		 jne	 SHORT $LN26@z900_conve
  00443	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv273[rsp], 1
  0044b	eb 08		 jmp	 SHORT $LN27@z900_conve
$LN26@z900_conve:
  0044d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv273[rsp], 0
$LN27@z900_conve:
  00455	83 7c 24 40 00	 cmp	 DWORD PTR tv273[rsp], 0
  0045a	74 0a		 je	 SHORT $LN30@z900_conve
  0045c	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv278[rsp], 0
  00464	eb 34		 jmp	 SHORT $LN31@z900_conve
$LN30@z900_conve:
  00466	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00470	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00475	48 23 c8	 and	 rcx, rax
  00478	48 8b c1	 mov	 rax, rcx
  0047b	48 85 c0	 test	 rax, rax
  0047e	74 0a		 je	 SHORT $LN28@z900_conve
  00480	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv276[rsp], 1
  00488	eb 08		 jmp	 SHORT $LN29@z900_conve
$LN28@z900_conve:
  0048a	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv276[rsp], 2
$LN29@z900_conve:
  00492	8b 44 24 44	 mov	 eax, DWORD PTR tv276[rsp]
  00496	89 44 24 48	 mov	 DWORD PTR tv278[rsp], eax
$LN31@z900_conve:
  0049a	8b 44 24 48	 mov	 eax, DWORD PTR tv278[rsp]
  0049e	89 44 24 4c	 mov	 DWORD PTR tv279[rsp], eax
$LN32@z900_conve:
  004a2	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv279[rsp]
  004a7	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN17@z900_conve:

; 2862 : 
; 2863 :     regs->GR_G( r1 ) = op1;

  004ab	48 63 44 24 54	 movsxd	 rax, DWORD PTR r1$[rsp]
  004b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004b5	48 8b 54 24 58	 mov	 rdx, QWORD PTR op1$[rsp]
  004ba	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2864 :     regs->psw.cc = newcc;

  004c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004c7	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  004cc	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2865 : 
; 2866 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  004cf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004d4	e8 00 00 00 00	 call	 ieee_exception_test_oux
  004d9	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2867 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  004dd	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004e1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004e6	85 c0		 test	 eax, eax
  004e8	74 0e		 je	 SHORT $LN19@z900_conve
  004ea	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004ee	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004f3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_conve:

; 2868 : }

  004f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004fc	c3		 ret	 0
z900_convert_bfp_long_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
temp$1 = 36
ieee_trap_conds$ = 40
r2$ = 44
tv220 = 48
tv226 = 52
tv297 = 56
tv302 = 60
tv304 = 64
tv305 = 68
r1$ = 72
op1$ = 80
tv325 = 88
$T2 = 96
op2$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
z900_convert_bfp_ext_to_u64_reg PROC

; 2774 : {

$LN36:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2775 :     int         r1, r2;
; 2776 :     BYTE        m3, m4, newcc;
; 2777 :     U64         op1;
; 2778 :     float128_t  op2;
; 2779 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2780 : 
; 2781 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN8@z900_conve
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2782 :     TXF_FLOAT_INSTR_CHECK( regs );

  000b2	33 c0		 xor	 eax, eax
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000cc	85 c0		 test	 eax, eax
  000ce	74 6e		 je	 SHORT $LN9@z900_conve
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 29		 jne	 SHORT $LN10@z900_conve
  000d6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000e5	85 c0		 test	 eax, eax
  000e7	75 16		 jne	 SHORT $LN10@z900_conve
  000e9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000f8	83 e0 04	 and	 eax, 4
  000fb	85 c0		 test	 eax, eax
  000fd	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000ff	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010d	0f ba e8 0b	 bts	 eax, 11
  00111	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199578
  00126	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012c	ba 02 00 00 00	 mov	 edx, 2
  00131	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2783 :     BFPINST_CHECK( regs );

  00148	b8 08 00 00 00	 mov	 eax, 8
  0014d	48 6b c0 01	 imul	 rax, rax, 1
  00151	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00161	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00167	48 85 c0	 test	 rax, rax
  0016a	74 42		 je	 SHORT $LN12@z900_conve
  0016c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017a	d1 e8		 shr	 eax, 1
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 58		 je	 SHORT $LN11@z900_conve
  00183	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00192	b9 08 00 00 00	 mov	 ecx, 8
  00197	48 6b c9 01	 imul	 rcx, rcx, 1
  0019b	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001a3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a9	48 85 c0	 test	 rax, rax
  001ac	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001c0	ba 07 00 00 00	 mov	 edx, 7
  001c5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2784 :     BFPREGPAIR_CHECK( r2, regs );

  001db	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001df	83 e0 02	 and	 eax, 2
  001e2	85 c0		 test	 eax, eax
  001e4	74 1b		 je	 SHORT $LN13@z900_conve
  001e6	ba 06 00 00 00	 mov	 edx, 6
  001eb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2785 :     BFPRM_CHECK( m3, regs );

  00201	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00206	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020e	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2786 : 
; 2787 :     GET_FLOAT128_OP( op2, r2, regs );

  00213	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00217	d1 e0		 shl	 eax, 1
  00219	48 98		 cdqe
  0021b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00223	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0022b	48 8b d0	 mov	 rdx, rax
  0022e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  00233	e8 00 00 00 00	 call	 z900_get_float128

; 2788 :     softfloat_exceptionFlags = 0;

  00238	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023d	8b c0		 mov	 eax, eax
  0023f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00245	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00252	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2789 : 
; 2790 :     if (FLOAT128_ISNAN( op2 ))

  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 01	 imul	 rax, rax, 1
  0025f	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00269	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0026e	48 23 c1	 and	 rax, rcx
  00271	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0027b	48 3b c1	 cmp	 rax, rcx
  0027e	0f 85 80 00 00
	00		 jne	 $LN14@z900_conve
  00284	b8 08 00 00 00	 mov	 eax, 8
  00289	48 6b c0 01	 imul	 rax, rax, 1
  0028d	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  00297	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0029c	48 23 c1	 and	 rax, rcx
  0029f	48 85 c0	 test	 rax, rax
  002a2	75 11		 jne	 SHORT $LN16@z900_conve
  002a4	b8 08 00 00 00	 mov	 eax, 8
  002a9	48 6b c0 00	 imul	 rax, rax, 0
  002ad	48 83 7c 04 70
	00		 cmp	 QWORD PTR op2$[rsp+rax], 0
  002b3	74 4f		 je	 SHORT $LN14@z900_conve
$LN16@z900_conve:

; 2791 :     {
; 2792 :         op1 = 0;

  002b5	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2793 :         softfloat_raiseFlags( softfloat_flag_invalid );

  002be	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c3	8b c0		 mov	 eax, eax
  002c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002cb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002dc	83 c8 10	 or	 eax, 16
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ee	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  002f4	45 8b c0	 mov	 r8d, r8d
  002f7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fb	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2794 :     }

  002ff	e9 d5 00 00 00	 jmp	 $LN15@z900_conve
$LN14@z900_conve:

; 2795 :     else
; 2796 :     {
; 2797 :         SET_SF_RM_FROM_MASK( m3 );

  00304	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00309	85 c0		 test	 eax, eax
  0030b	74 16		 je	 SHORT $LN23@z900_conve
  0030d	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00312	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00319	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031d	89 44 24 30	 mov	 DWORD PTR tv220[rsp], eax
  00321	eb 22		 jmp	 SHORT $LN24@z900_conve
$LN23@z900_conve:
  00323	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00331	83 e0 07	 and	 eax, 7
  00334	8b c0		 mov	 eax, eax
  00336	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0033d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00341	89 44 24 30	 mov	 DWORD PTR tv220[rsp], eax
$LN24@z900_conve:
  00345	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0034a	8b c0		 mov	 eax, eax
  0034c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00352	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0035b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0035f	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv220[rsp]
  00364	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2798 :         op1 = f128_to_ui64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00367	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  0036c	83 e0 04	 and	 eax, 4
  0036f	85 c0		 test	 eax, eax
  00371	75 0a		 jne	 SHORT $LN25@z900_conve
  00373	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  0037b	eb 08		 jmp	 SHORT $LN26@z900_conve
$LN25@z900_conve:
  0037d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN26@z900_conve:
  00385	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0038a	8b c0		 mov	 eax, eax
  0038c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00392	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0039b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0039f	48 89 4c 24 58	 mov	 QWORD PTR tv325[rsp], rcx
  003a4	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T2[rsp]
  003a9	4c 8d 44 24 70	 lea	 r8, QWORD PTR op2$[rsp]
  003ae	48 8b fa	 mov	 rdi, rdx
  003b1	49 8b f0	 mov	 rsi, r8
  003b4	b9 10 00 00 00	 mov	 ecx, 16
  003b9	f3 a4		 rep movsb
  003bb	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv226[rsp]
  003c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv325[rsp]
  003c6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  003ca	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  003cf	e8 00 00 00 00	 call	 f128_to_ui64
  003d4	48 89 44 24 50	 mov	 QWORD PTR op1$[rsp], rax
$LN15@z900_conve:

; 2799 :     }
; 2800 : 
; 2801 :     IEEE_EXCEPTION_TRAP_XI( regs );

  003d9	33 c0		 xor	 eax, eax
  003db	83 f8 01	 cmp	 eax, 1
  003de	74 4b		 je	 SHORT $LN17@z900_conve
  003e0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003e5	8b c0		 mov	 eax, eax
  003e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003ed	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003f6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003fe	83 e0 10	 and	 eax, 16
  00401	85 c0		 test	 eax, eax
  00403	74 26		 je	 SHORT $LN17@z900_conve
  00405	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00413	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00418	85 c0		 test	 eax, eax
  0041a	74 0f		 je	 SHORT $LN17@z900_conve
  0041c	b2 80		 mov	 dl, 128			; 00000080H
  0041e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00426	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_conve:

; 2802 : 
; 2803 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0042b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00430	8b c0		 mov	 eax, eax
  00432	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00438	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00441	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00445	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00449	83 e0 10	 and	 eax, 16
  0044c	85 c0		 test	 eax, eax
  0044e	74 54		 je	 SHORT $LN18@z900_conve

; 2804 :     {
; 2805 :         newcc = 3;

  00450	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2806 : 
; 2807 :         if (!SUPPRESS_INEXACT( m4 ))

  00455	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  0045a	83 e0 04	 and	 eax, 4
  0045d	85 c0		 test	 eax, eax
  0045f	75 3e		 jne	 SHORT $LN20@z900_conve

; 2808 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00461	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00466	8b c0		 mov	 eax, eax
  00468	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0046e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00477	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0047b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0047f	83 c8 01	 or	 eax, 1
  00482	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00488	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00491	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00496	8b ff		 mov	 edi, edi
  00498	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0049c	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN20@z900_conve:

; 2809 :     }

  0049f	e9 04 01 00 00	 jmp	 $LN19@z900_conve
$LN18@z900_conve:

; 2810 :     else
; 2811 :         newcc = FLOAT128_CC( op2 );

  004a4	b8 08 00 00 00	 mov	 eax, 8
  004a9	48 6b c0 01	 imul	 rax, rax, 1
  004ad	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  004b7	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  004bc	48 23 c1	 and	 rax, rcx
  004bf	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  004c9	48 3b c1	 cmp	 rax, rcx
  004cc	75 3e		 jne	 SHORT $LN28@z900_conve
  004ce	b8 08 00 00 00	 mov	 eax, 8
  004d3	48 6b c0 01	 imul	 rax, rax, 1
  004d7	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  004e1	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  004e6	48 23 c1	 and	 rax, rcx
  004e9	48 85 c0	 test	 rax, rax
  004ec	75 11		 jne	 SHORT $LN27@z900_conve
  004ee	b8 08 00 00 00	 mov	 eax, 8
  004f3	48 6b c0 00	 imul	 rax, rax, 0
  004f7	48 83 7c 04 70
	00		 cmp	 QWORD PTR op2$[rsp+rax], 0
  004fd	74 0d		 je	 SHORT $LN28@z900_conve
$LN27@z900_conve:
  004ff	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR tv305[rsp], 3
  00507	e9 93 00 00 00	 jmp	 $LN35@z900_conve
$LN28@z900_conve:
  0050c	b8 08 00 00 00	 mov	 eax, 8
  00511	48 6b c0 01	 imul	 rax, rax, 1
  00515	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0051f	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00524	48 23 c1	 and	 rax, rcx
  00527	b9 08 00 00 00	 mov	 ecx, 8
  0052c	48 6b c9 00	 imul	 rcx, rcx, 0
  00530	48 0b 44 0c 70	 or	 rax, QWORD PTR op2$[rsp+rcx]
  00535	48 85 c0	 test	 rax, rax
  00538	75 0a		 jne	 SHORT $LN29@z900_conve
  0053a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv297[rsp], 1
  00542	eb 08		 jmp	 SHORT $LN30@z900_conve
$LN29@z900_conve:
  00544	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv297[rsp], 0
$LN30@z900_conve:
  0054c	83 7c 24 38 00	 cmp	 DWORD PTR tv297[rsp], 0
  00551	74 0a		 je	 SHORT $LN33@z900_conve
  00553	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv304[rsp], 0
  0055b	eb 3a		 jmp	 SHORT $LN34@z900_conve
$LN33@z900_conve:
  0055d	b8 08 00 00 00	 mov	 eax, 8
  00562	48 6b c0 01	 imul	 rax, rax, 1
  00566	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00570	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00575	48 23 c1	 and	 rax, rcx
  00578	48 85 c0	 test	 rax, rax
  0057b	74 0a		 je	 SHORT $LN31@z900_conve
  0057d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv302[rsp], 1
  00585	eb 08		 jmp	 SHORT $LN32@z900_conve
$LN31@z900_conve:
  00587	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tv302[rsp], 2
$LN32@z900_conve:
  0058f	8b 44 24 3c	 mov	 eax, DWORD PTR tv302[rsp]
  00593	89 44 24 40	 mov	 DWORD PTR tv304[rsp], eax
$LN34@z900_conve:
  00597	8b 44 24 40	 mov	 eax, DWORD PTR tv304[rsp]
  0059b	89 44 24 44	 mov	 DWORD PTR tv305[rsp], eax
$LN35@z900_conve:
  0059f	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv305[rsp]
  005a4	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN19@z900_conve:

; 2812 : 
; 2813 :     regs->GR_G( r1 ) = op1;

  005a8	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  005ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b5	48 8b 54 24 50	 mov	 rdx, QWORD PTR op1$[rsp]
  005ba	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2814 :     regs->psw.cc = newcc;

  005c2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ca	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  005cf	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2815 : 
; 2816 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  005d2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005da	e8 00 00 00 00	 call	 ieee_exception_test_oux
  005df	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2817 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  005e3	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  005e7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  005ec	85 c0		 test	 eax, eax
  005ee	74 11		 je	 SHORT $LN21@z900_conve
  005f0	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  005f4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005fc	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_conve:

; 2818 : }

  00601	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00609	48 33 cc	 xor	 rcx, rsp
  0060c	e8 00 00 00 00	 call	 __security_check_cookie
  00611	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00618	5f		 pop	 rdi
  00619	5e		 pop	 rsi
  0061a	c3		 ret	 0
z900_convert_bfp_ext_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
op2$ = 36
temp$1 = 40
ieee_trap_conds$ = 44
tv208 = 48
tv214 = 52
tv273 = 56
tv276 = 60
tv278 = 64
tv279 = 68
op1$ = 72
r2$ = 76
r1$ = 80
inst$ = 112
regs$ = 120
z900_convert_bfp_short_to_u32_reg PROC

; 2725 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2726 :     int        r1, r2;
; 2727 :     BYTE       m3, m4, newcc;
; 2728 :     U32        op1;
; 2729 :     float32_t  op2;
; 2730 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2731 : 
; 2732 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 50	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2733 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199545
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2734 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2735 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2736 : 
; 2737 :     GET_FLOAT32_OP( op2, r2, regs );

  0019b	8b 44 24 4c	 mov	 eax, DWORD PTR r2$[rsp]
  0019f	d1 e0		 shl	 eax, 1
  001a1	48 98		 cdqe
  001a3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b0	48 8b d0	 mov	 rdx, rax
  001b3	48 8d 4c 24 24	 lea	 rcx, QWORD PTR op2$[rsp]
  001b8	e8 00 00 00 00	 call	 z900_get_float32

; 2738 :     softfloat_exceptionFlags = 0;

  001bd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c2	8b c0		 mov	 eax, eax
  001c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ca	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d7	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2739 : 
; 2740 :     if (FLOAT32_ISNAN( op2 ))

  001db	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  001df	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  001e4	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  001e9	75 5b		 jne	 SHORT $LN13@z900_conve
  001eb	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  001ef	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001f4	85 c0		 test	 eax, eax
  001f6	74 4e		 je	 SHORT $LN13@z900_conve

; 2741 :     {
; 2742 :         op1 = 0;

  001f8	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2743 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00200	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00205	8b c0		 mov	 eax, eax
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00216	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021e	83 c8 10	 or	 eax, 16
  00221	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00227	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00230	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00236	45 8b c0	 mov	 r8d, r8d
  00239	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023d	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2744 :     }

  00241	e9 af 00 00 00	 jmp	 $LN14@z900_conve
$LN13@z900_conve:

; 2745 :     else
; 2746 :     {
; 2747 :         SET_SF_RM_FROM_MASK( m3 );

  00246	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0024b	85 c0		 test	 eax, eax
  0024d	74 16		 je	 SHORT $LN21@z900_conve
  0024f	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00254	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0025b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025f	89 44 24 30	 mov	 DWORD PTR tv208[rsp], eax
  00263	eb 1f		 jmp	 SHORT $LN22@z900_conve
$LN21@z900_conve:
  00265	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0026a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00270	83 e0 07	 and	 eax, 7
  00273	8b c0		 mov	 eax, eax
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0027c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00280	89 44 24 30	 mov	 DWORD PTR tv208[rsp], eax
$LN22@z900_conve:
  00284	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00289	8b c0		 mov	 eax, eax
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00291	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029e	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv208[rsp]
  002a3	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2748 :         op1 = f32_to_ui32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002a6	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002ab	83 e0 04	 and	 eax, 4
  002ae	85 c0		 test	 eax, eax
  002b0	75 0a		 jne	 SHORT $LN23@z900_conve
  002b2	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
  002ba	eb 08		 jmp	 SHORT $LN24@z900_conve
$LN23@z900_conve:
  002bc	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN24@z900_conve:
  002c4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002c9	8b c0		 mov	 eax, eax
  002cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002da	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002de	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv214[rsp]
  002e4	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002e8	8b 4c 24 24	 mov	 ecx, DWORD PTR op2$[rsp]
  002ec	e8 00 00 00 00	 call	 f32_to_ui32
  002f1	89 44 24 48	 mov	 DWORD PTR op1$[rsp], eax
$LN14@z900_conve:

; 2749 :     }
; 2750 : 
; 2751 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002f5	33 c0		 xor	 eax, eax
  002f7	83 f8 01	 cmp	 eax, 1
  002fa	74 45		 je	 SHORT $LN15@z900_conve
  002fc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00301	8b c0		 mov	 eax, eax
  00303	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00309	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00312	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00316	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031a	83 e0 10	 and	 eax, 16
  0031d	85 c0		 test	 eax, eax
  0031f	74 20		 je	 SHORT $LN15@z900_conve
  00321	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00326	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0032c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00331	85 c0		 test	 eax, eax
  00333	74 0c		 je	 SHORT $LN15@z900_conve
  00335	b2 80		 mov	 dl, 128			; 00000080H
  00337	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0033c	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_conve:

; 2752 : 
; 2753 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00341	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00346	8b c0		 mov	 eax, eax
  00348	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0034e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00357	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0035b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035f	83 e0 10	 and	 eax, 16
  00362	85 c0		 test	 eax, eax
  00364	74 57		 je	 SHORT $LN16@z900_conve

; 2754 :     {
; 2755 :         newcc = 3;

  00366	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2756 : 
; 2757 :         if (!SUPPRESS_INEXACT( m4 ))

  0036b	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00370	83 e0 04	 and	 eax, 4
  00373	85 c0		 test	 eax, eax
  00375	75 41		 jne	 SHORT $LN18@z900_conve

; 2758 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00377	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0037c	8b c0		 mov	 eax, eax
  0037e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00384	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00391	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00395	83 c8 01	 or	 eax, 1
  00398	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0039e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003a7	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  003ad	45 8b c0	 mov	 r8d, r8d
  003b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b4	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN18@z900_conve:

; 2759 :     }

  003b8	e9 8e 00 00 00	 jmp	 $LN17@z900_conve
$LN16@z900_conve:

; 2760 :     else
; 2761 :         newcc = FLOAT32_CC( op2 );

  003bd	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  003c1	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  003c6	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  003cb	75 17		 jne	 SHORT $LN25@z900_conve
  003cd	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  003d1	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  003d6	85 c0		 test	 eax, eax
  003d8	74 0a		 je	 SHORT $LN25@z900_conve
  003da	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR tv279[rsp], 3
  003e2	eb 5e		 jmp	 SHORT $LN32@z900_conve
$LN25@z900_conve:
  003e4	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  003e8	0f ba f0 1f	 btr	 eax, 31
  003ec	85 c0		 test	 eax, eax
  003ee	75 0a		 jne	 SHORT $LN26@z900_conve
  003f0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv273[rsp], 1
  003f8	eb 08		 jmp	 SHORT $LN27@z900_conve
$LN26@z900_conve:
  003fa	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv273[rsp], 0
$LN27@z900_conve:
  00402	83 7c 24 38 00	 cmp	 DWORD PTR tv273[rsp], 0
  00407	74 0a		 je	 SHORT $LN30@z900_conve
  00409	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv278[rsp], 0
  00411	eb 27		 jmp	 SHORT $LN31@z900_conve
$LN30@z900_conve:
  00413	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  00417	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0041c	85 c0		 test	 eax, eax
  0041e	74 0a		 je	 SHORT $LN28@z900_conve
  00420	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv276[rsp], 1
  00428	eb 08		 jmp	 SHORT $LN29@z900_conve
$LN28@z900_conve:
  0042a	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tv276[rsp], 2
$LN29@z900_conve:
  00432	8b 44 24 3c	 mov	 eax, DWORD PTR tv276[rsp]
  00436	89 44 24 40	 mov	 DWORD PTR tv278[rsp], eax
$LN31@z900_conve:
  0043a	8b 44 24 40	 mov	 eax, DWORD PTR tv278[rsp]
  0043e	89 44 24 44	 mov	 DWORD PTR tv279[rsp], eax
$LN32@z900_conve:
  00442	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv279[rsp]
  00447	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN17@z900_conve:

; 2762 : 
; 2763 :     regs->GR_L( r1 ) = op1;

  0044b	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00450	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00455	8b 54 24 48	 mov	 edx, DWORD PTR op1$[rsp]
  00459	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2764 :     regs->psw.cc = newcc;

  00460	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00465	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0046a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2765 : 
; 2766 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  0046d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00472	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00477	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2767 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0047b	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0047f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00484	85 c0		 test	 eax, eax
  00486	74 0e		 je	 SHORT $LN19@z900_conve
  00488	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0048c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00491	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_conve:

; 2768 : }

  00496	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0049a	c3		 ret	 0
z900_convert_bfp_short_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
temp$1 = 36
ieee_trap_conds$ = 40
op2$ = 48
tv208 = 56
tv214 = 60
tv273 = 64
tv276 = 68
tv278 = 72
tv279 = 76
op1$ = 80
r2$ = 84
r1$ = 88
inst$ = 112
regs$ = 120
z900_convert_bfp_long_to_u32_reg PROC

; 2676 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2677 :     int        r1, r2;
; 2678 :     BYTE       m3, m4, newcc;
; 2679 :     U32        op1;
; 2680 :     float64_t  op2;
; 2681 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2682 : 
; 2683 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 54	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 58	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2684 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199512
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2685 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2686 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2687 : 
; 2688 :     GET_FLOAT64_OP( op2, r2, regs );

  0019b	8b 44 24 54	 mov	 eax, DWORD PTR r2$[rsp]
  0019f	d1 e0		 shl	 eax, 1
  001a1	48 98		 cdqe
  001a3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b0	48 8b d0	 mov	 rdx, rax
  001b3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  001b8	e8 00 00 00 00	 call	 z900_get_float64

; 2689 :     softfloat_exceptionFlags = 0;

  001bd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c2	8b c0		 mov	 eax, eax
  001c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ca	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d7	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2690 : 
; 2691 :     if (FLOAT64_ISNAN( op2 ))

  001db	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  001e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  001ea	48 23 c8	 and	 rcx, rax
  001ed	48 8b c1	 mov	 rax, rcx
  001f0	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001fa	48 3b c1	 cmp	 rax, rcx
  001fd	75 68		 jne	 SHORT $LN13@z900_conve
  001ff	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00209	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0020e	48 23 c8	 and	 rcx, rax
  00211	48 8b c1	 mov	 rax, rcx
  00214	48 85 c0	 test	 rax, rax
  00217	74 4e		 je	 SHORT $LN13@z900_conve

; 2692 :     {
; 2693 :         op1 = 0x00000000;

  00219	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2694 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00221	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00226	8b c0		 mov	 eax, eax
  00228	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00237	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023f	83 c8 10	 or	 eax, 16
  00242	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00248	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00251	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00257	45 8b c0	 mov	 r8d, r8d
  0025a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025e	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2695 :     }

  00262	e9 b0 00 00 00	 jmp	 $LN14@z900_conve
$LN13@z900_conve:

; 2696 :     else
; 2697 :     {
; 2698 :         SET_SF_RM_FROM_MASK( m3 );

  00267	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0026c	85 c0		 test	 eax, eax
  0026e	74 16		 je	 SHORT $LN21@z900_conve
  00270	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0027c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00280	89 44 24 38	 mov	 DWORD PTR tv208[rsp], eax
  00284	eb 1f		 jmp	 SHORT $LN22@z900_conve
$LN21@z900_conve:
  00286	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0028b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00291	83 e0 07	 and	 eax, 7
  00294	8b c0		 mov	 eax, eax
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0029d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a1	89 44 24 38	 mov	 DWORD PTR tv208[rsp], eax
$LN22@z900_conve:
  002a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002aa	8b c0		 mov	 eax, eax
  002ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002bf	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv208[rsp]
  002c4	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2699 :         op1 = f64_to_ui32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002c7	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002cc	83 e0 04	 and	 eax, 4
  002cf	85 c0		 test	 eax, eax
  002d1	75 0a		 jne	 SHORT $LN23@z900_conve
  002d3	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
  002db	eb 08		 jmp	 SHORT $LN24@z900_conve
$LN23@z900_conve:
  002dd	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN24@z900_conve:
  002e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002ea	8b c0		 mov	 eax, eax
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ff	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv214[rsp]
  00305	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00309	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0030e	e8 00 00 00 00	 call	 f64_to_ui32
  00313	89 44 24 50	 mov	 DWORD PTR op1$[rsp], eax
$LN14@z900_conve:

; 2700 :     }
; 2701 : 
; 2702 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00317	33 c0		 xor	 eax, eax
  00319	83 f8 01	 cmp	 eax, 1
  0031c	74 45		 je	 SHORT $LN15@z900_conve
  0031e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00323	8b c0		 mov	 eax, eax
  00325	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0032b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00334	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00338	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0033c	83 e0 10	 and	 eax, 16
  0033f	85 c0		 test	 eax, eax
  00341	74 20		 je	 SHORT $LN15@z900_conve
  00343	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00348	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0034e	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00353	85 c0		 test	 eax, eax
  00355	74 0c		 je	 SHORT $LN15@z900_conve
  00357	b2 80		 mov	 dl, 128			; 00000080H
  00359	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0035e	e8 00 00 00 00	 call	 ieee_trap
$LN15@z900_conve:

; 2703 : 
; 2704 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00363	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00368	8b c0		 mov	 eax, eax
  0036a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00370	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00379	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0037d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00381	83 e0 10	 and	 eax, 16
  00384	85 c0		 test	 eax, eax
  00386	74 57		 je	 SHORT $LN16@z900_conve

; 2705 :     {
; 2706 :         newcc = 3;

  00388	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2707 : 
; 2708 :         if (!SUPPRESS_INEXACT( m4 ))

  0038d	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00392	83 e0 04	 and	 eax, 4
  00395	85 c0		 test	 eax, eax
  00397	75 41		 jne	 SHORT $LN18@z900_conve

; 2709 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00399	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0039e	8b c0		 mov	 eax, eax
  003a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b7	83 c8 01	 or	 eax, 1
  003ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003c9	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  003cf	45 8b c0	 mov	 r8d, r8d
  003d2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003d6	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN18@z900_conve:

; 2710 :     }

  003da	e9 ca 00 00 00	 jmp	 $LN17@z900_conve
$LN16@z900_conve:

; 2711 :     else
; 2712 :         newcc = FLOAT64_CC( op2 );

  003df	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  003e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  003ee	48 23 c8	 and	 rcx, rax
  003f1	48 8b c1	 mov	 rax, rcx
  003f4	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  003fe	48 3b c1	 cmp	 rax, rcx
  00401	75 24		 jne	 SHORT $LN25@z900_conve
  00403	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0040d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00412	48 23 c8	 and	 rcx, rax
  00415	48 8b c1	 mov	 rax, rcx
  00418	48 85 c0	 test	 rax, rax
  0041b	74 0a		 je	 SHORT $LN25@z900_conve
  0041d	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv279[rsp], 3
  00425	eb 79		 jmp	 SHORT $LN32@z900_conve
$LN25@z900_conve:
  00427	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00431	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00436	48 23 c8	 and	 rcx, rax
  00439	48 8b c1	 mov	 rax, rcx
  0043c	48 85 c0	 test	 rax, rax
  0043f	75 0a		 jne	 SHORT $LN26@z900_conve
  00441	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv273[rsp], 1
  00449	eb 08		 jmp	 SHORT $LN27@z900_conve
$LN26@z900_conve:
  0044b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv273[rsp], 0
$LN27@z900_conve:
  00453	83 7c 24 40 00	 cmp	 DWORD PTR tv273[rsp], 0
  00458	74 0a		 je	 SHORT $LN30@z900_conve
  0045a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv278[rsp], 0
  00462	eb 34		 jmp	 SHORT $LN31@z900_conve
$LN30@z900_conve:
  00464	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0046e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00473	48 23 c8	 and	 rcx, rax
  00476	48 8b c1	 mov	 rax, rcx
  00479	48 85 c0	 test	 rax, rax
  0047c	74 0a		 je	 SHORT $LN28@z900_conve
  0047e	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv276[rsp], 1
  00486	eb 08		 jmp	 SHORT $LN29@z900_conve
$LN28@z900_conve:
  00488	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv276[rsp], 2
$LN29@z900_conve:
  00490	8b 44 24 44	 mov	 eax, DWORD PTR tv276[rsp]
  00494	89 44 24 48	 mov	 DWORD PTR tv278[rsp], eax
$LN31@z900_conve:
  00498	8b 44 24 48	 mov	 eax, DWORD PTR tv278[rsp]
  0049c	89 44 24 4c	 mov	 DWORD PTR tv279[rsp], eax
$LN32@z900_conve:
  004a0	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv279[rsp]
  004a5	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN17@z900_conve:

; 2713 : 
; 2714 :     regs->GR_L( r1 ) = op1;

  004a9	48 63 44 24 58	 movsxd	 rax, DWORD PTR r1$[rsp]
  004ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004b3	8b 54 24 50	 mov	 edx, DWORD PTR op1$[rsp]
  004b7	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2715 :     regs->psw.cc = newcc;

  004be	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004c3	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  004c8	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2716 : 
; 2717 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  004cb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004d0	e8 00 00 00 00	 call	 ieee_exception_test_oux
  004d5	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2718 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  004d9	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004dd	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004e2	85 c0		 test	 eax, eax
  004e4	74 0e		 je	 SHORT $LN19@z900_conve
  004e6	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004ea	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004ef	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@z900_conve:

; 2719 : }

  004f4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004f8	c3		 ret	 0
z900_convert_bfp_long_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
temp$1 = 36
ieee_trap_conds$ = 40
r2$ = 44
tv220 = 48
tv226 = 52
tv297 = 56
tv302 = 60
tv304 = 64
tv305 = 68
op1$ = 72
r1$ = 76
tv325 = 80
$T2 = 96
op2$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
z900_convert_bfp_ext_to_u32_reg PROC

; 2626 : {

$LN36:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2627 :     int         r1, r2;
; 2628 :     BYTE        m3, m4, newcc;
; 2629 :     U32         op1;
; 2630 :     float128_t  op2;
; 2631 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2632 : 
; 2633 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN8@z900_conve
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2634 :     TXF_FLOAT_INSTR_CHECK( regs );

  000b2	33 c0		 xor	 eax, eax
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000cc	85 c0		 test	 eax, eax
  000ce	74 6e		 je	 SHORT $LN9@z900_conve
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 29		 jne	 SHORT $LN10@z900_conve
  000d6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000e5	85 c0		 test	 eax, eax
  000e7	75 16		 jne	 SHORT $LN10@z900_conve
  000e9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000f8	83 e0 04	 and	 eax, 4
  000fb	85 c0		 test	 eax, eax
  000fd	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000ff	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010d	0f ba e8 0b	 bts	 eax, 11
  00111	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199477
  00126	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012c	ba 02 00 00 00	 mov	 edx, 2
  00131	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2635 :     BFPINST_CHECK( regs );

  00148	b8 08 00 00 00	 mov	 eax, 8
  0014d	48 6b c0 01	 imul	 rax, rax, 1
  00151	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00161	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00167	48 85 c0	 test	 rax, rax
  0016a	74 42		 je	 SHORT $LN12@z900_conve
  0016c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017a	d1 e8		 shr	 eax, 1
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 58		 je	 SHORT $LN11@z900_conve
  00183	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00192	b9 08 00 00 00	 mov	 ecx, 8
  00197	48 6b c9 01	 imul	 rcx, rcx, 1
  0019b	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001a3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001a9	48 85 c0	 test	 rax, rax
  001ac	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001c0	ba 07 00 00 00	 mov	 edx, 7
  001c5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2636 :     BFPREGPAIR_CHECK( r2, regs );

  001db	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001df	83 e0 02	 and	 eax, 2
  001e2	85 c0		 test	 eax, eax
  001e4	74 1b		 je	 SHORT $LN13@z900_conve
  001e6	ba 06 00 00 00	 mov	 edx, 6
  001eb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2637 :     BFPRM_CHECK( m3, regs );

  00201	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00206	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020e	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2638 : 
; 2639 :     GET_FLOAT128_OP( op2, r2, regs );

  00213	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00217	d1 e0		 shl	 eax, 1
  00219	48 98		 cdqe
  0021b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00223	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0022b	48 8b d0	 mov	 rdx, rax
  0022e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  00233	e8 00 00 00 00	 call	 z900_get_float128

; 2640 :     softfloat_exceptionFlags = 0;

  00238	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023d	8b c0		 mov	 eax, eax
  0023f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00245	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00252	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2641 : 
; 2642 :     if (FLOAT128_ISNAN( op2 ))

  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 01	 imul	 rax, rax, 1
  0025f	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00269	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0026e	48 23 c1	 and	 rax, rcx
  00271	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0027b	48 3b c1	 cmp	 rax, rcx
  0027e	75 7f		 jne	 SHORT $LN14@z900_conve
  00280	b8 08 00 00 00	 mov	 eax, 8
  00285	48 6b c0 01	 imul	 rax, rax, 1
  00289	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  00293	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00298	48 23 c1	 and	 rax, rcx
  0029b	48 85 c0	 test	 rax, rax
  0029e	75 11		 jne	 SHORT $LN16@z900_conve
  002a0	b8 08 00 00 00	 mov	 eax, 8
  002a5	48 6b c0 00	 imul	 rax, rax, 0
  002a9	48 83 7c 04 70
	00		 cmp	 QWORD PTR op2$[rsp+rax], 0
  002af	74 4e		 je	 SHORT $LN14@z900_conve
$LN16@z900_conve:

; 2643 :     {
; 2644 :         op1 = 0;

  002b1	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2645 :         softfloat_raiseFlags( softfloat_flag_invalid );

  002b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002be	8b c0		 mov	 eax, eax
  002c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002cf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d7	83 c8 10	 or	 eax, 16
  002da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e9	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  002ef	45 8b c0	 mov	 r8d, r8d
  002f2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002f6	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2646 :     }

  002fa	e9 d4 00 00 00	 jmp	 $LN15@z900_conve
$LN14@z900_conve:

; 2647 :     else
; 2648 :     {
; 2649 :         SET_SF_RM_FROM_MASK( m3 );

  002ff	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00304	85 c0		 test	 eax, eax
  00306	74 16		 je	 SHORT $LN23@z900_conve
  00308	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00314	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00318	89 44 24 30	 mov	 DWORD PTR tv220[rsp], eax
  0031c	eb 22		 jmp	 SHORT $LN24@z900_conve
$LN23@z900_conve:
  0031e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00326	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0032c	83 e0 07	 and	 eax, 7
  0032f	8b c0		 mov	 eax, eax
  00331	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00338	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0033c	89 44 24 30	 mov	 DWORD PTR tv220[rsp], eax
$LN24@z900_conve:
  00340	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00345	8b c0		 mov	 eax, eax
  00347	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0034d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00356	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0035a	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv220[rsp]
  0035f	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2650 :         op1 = f128_to_ui32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00362	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00367	83 e0 04	 and	 eax, 4
  0036a	85 c0		 test	 eax, eax
  0036c	75 0a		 jne	 SHORT $LN25@z900_conve
  0036e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  00376	eb 08		 jmp	 SHORT $LN26@z900_conve
$LN25@z900_conve:
  00378	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN26@z900_conve:
  00380	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00385	8b c0		 mov	 eax, eax
  00387	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0038d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00396	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0039a	48 89 4c 24 50	 mov	 QWORD PTR tv325[rsp], rcx
  0039f	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T2[rsp]
  003a4	4c 8d 44 24 70	 lea	 r8, QWORD PTR op2$[rsp]
  003a9	48 8b fa	 mov	 rdi, rdx
  003ac	49 8b f0	 mov	 rsi, r8
  003af	b9 10 00 00 00	 mov	 ecx, 16
  003b4	f3 a4		 rep movsb
  003b6	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv226[rsp]
  003bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv325[rsp]
  003c1	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  003c5	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  003ca	e8 00 00 00 00	 call	 f128_to_ui32
  003cf	89 44 24 48	 mov	 DWORD PTR op1$[rsp], eax
$LN15@z900_conve:

; 2651 :     }
; 2652 : 
; 2653 :     IEEE_EXCEPTION_TRAP_XI( regs );

  003d3	33 c0		 xor	 eax, eax
  003d5	83 f8 01	 cmp	 eax, 1
  003d8	74 4b		 je	 SHORT $LN17@z900_conve
  003da	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003df	8b c0		 mov	 eax, eax
  003e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003e7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003f0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003f8	83 e0 10	 and	 eax, 16
  003fb	85 c0		 test	 eax, eax
  003fd	74 26		 je	 SHORT $LN17@z900_conve
  003ff	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00407	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0040d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00412	85 c0		 test	 eax, eax
  00414	74 0f		 je	 SHORT $LN17@z900_conve
  00416	b2 80		 mov	 dl, 128			; 00000080H
  00418	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00420	e8 00 00 00 00	 call	 ieee_trap
$LN17@z900_conve:

; 2654 : 
; 2655 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00425	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0042a	8b c0		 mov	 eax, eax
  0042c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00432	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0043b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0043f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00443	83 e0 10	 and	 eax, 16
  00446	85 c0		 test	 eax, eax
  00448	74 54		 je	 SHORT $LN18@z900_conve

; 2656 :     {
; 2657 :         newcc = 3;

  0044a	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2658 : 
; 2659 :         if (!SUPPRESS_INEXACT( m4 ))

  0044f	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00454	83 e0 04	 and	 eax, 4
  00457	85 c0		 test	 eax, eax
  00459	75 3e		 jne	 SHORT $LN20@z900_conve

; 2660 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  0045b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00460	8b c0		 mov	 eax, eax
  00462	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00468	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00471	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00475	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00479	83 c8 01	 or	 eax, 1
  0047c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00482	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0048b	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00490	8b ff		 mov	 edi, edi
  00492	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00496	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN20@z900_conve:

; 2661 :     }

  00499	e9 04 01 00 00	 jmp	 $LN19@z900_conve
$LN18@z900_conve:

; 2662 :     else
; 2663 :         newcc = FLOAT128_CC( op2 );

  0049e	b8 08 00 00 00	 mov	 eax, 8
  004a3	48 6b c0 01	 imul	 rax, rax, 1
  004a7	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  004b1	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  004b6	48 23 c1	 and	 rax, rcx
  004b9	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  004c3	48 3b c1	 cmp	 rax, rcx
  004c6	75 3e		 jne	 SHORT $LN28@z900_conve
  004c8	b8 08 00 00 00	 mov	 eax, 8
  004cd	48 6b c0 01	 imul	 rax, rax, 1
  004d1	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  004db	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  004e0	48 23 c1	 and	 rax, rcx
  004e3	48 85 c0	 test	 rax, rax
  004e6	75 11		 jne	 SHORT $LN27@z900_conve
  004e8	b8 08 00 00 00	 mov	 eax, 8
  004ed	48 6b c0 00	 imul	 rax, rax, 0
  004f1	48 83 7c 04 70
	00		 cmp	 QWORD PTR op2$[rsp+rax], 0
  004f7	74 0d		 je	 SHORT $LN28@z900_conve
$LN27@z900_conve:
  004f9	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR tv305[rsp], 3
  00501	e9 93 00 00 00	 jmp	 $LN35@z900_conve
$LN28@z900_conve:
  00506	b8 08 00 00 00	 mov	 eax, 8
  0050b	48 6b c0 01	 imul	 rax, rax, 1
  0050f	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00519	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0051e	48 23 c1	 and	 rax, rcx
  00521	b9 08 00 00 00	 mov	 ecx, 8
  00526	48 6b c9 00	 imul	 rcx, rcx, 0
  0052a	48 0b 44 0c 70	 or	 rax, QWORD PTR op2$[rsp+rcx]
  0052f	48 85 c0	 test	 rax, rax
  00532	75 0a		 jne	 SHORT $LN29@z900_conve
  00534	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv297[rsp], 1
  0053c	eb 08		 jmp	 SHORT $LN30@z900_conve
$LN29@z900_conve:
  0053e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv297[rsp], 0
$LN30@z900_conve:
  00546	83 7c 24 38 00	 cmp	 DWORD PTR tv297[rsp], 0
  0054b	74 0a		 je	 SHORT $LN33@z900_conve
  0054d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv304[rsp], 0
  00555	eb 3a		 jmp	 SHORT $LN34@z900_conve
$LN33@z900_conve:
  00557	b8 08 00 00 00	 mov	 eax, 8
  0055c	48 6b c0 01	 imul	 rax, rax, 1
  00560	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0056a	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0056f	48 23 c1	 and	 rax, rcx
  00572	48 85 c0	 test	 rax, rax
  00575	74 0a		 je	 SHORT $LN31@z900_conve
  00577	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv302[rsp], 1
  0057f	eb 08		 jmp	 SHORT $LN32@z900_conve
$LN31@z900_conve:
  00581	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tv302[rsp], 2
$LN32@z900_conve:
  00589	8b 44 24 3c	 mov	 eax, DWORD PTR tv302[rsp]
  0058d	89 44 24 40	 mov	 DWORD PTR tv304[rsp], eax
$LN34@z900_conve:
  00591	8b 44 24 40	 mov	 eax, DWORD PTR tv304[rsp]
  00595	89 44 24 44	 mov	 DWORD PTR tv305[rsp], eax
$LN35@z900_conve:
  00599	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv305[rsp]
  0059e	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN19@z900_conve:

; 2664 : 
; 2665 :     regs->GR_L( r1 ) = op1;

  005a2	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r1$[rsp]
  005a7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005af	8b 54 24 48	 mov	 edx, DWORD PTR op1$[rsp]
  005b3	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2666 :     regs->psw.cc = newcc;

  005ba	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c2	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  005c7	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2667 : 
; 2668 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  005ca	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d2	e8 00 00 00 00	 call	 ieee_exception_test_oux
  005d7	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2669 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  005db	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  005df	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  005e4	85 c0		 test	 eax, eax
  005e6	74 11		 je	 SHORT $LN21@z900_conve
  005e8	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  005ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f4	e8 00 00 00 00	 call	 ieee_cond_trap
$LN21@z900_conve:

; 2670 : }

  005f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00601	48 33 cc	 xor	 rcx, rsp
  00604	e8 00 00 00 00	 call	 __security_check_cookie
  00609	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00610	5f		 pop	 rdi
  00611	5e		 pop	 rsi
  00612	c3		 ret	 0
z900_convert_bfp_ext_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv176 = 44
r2$ = 48
r1$ = 52
op1$ = 56
op2$ = 64
inst$ = 96
regs$ = 104
z900_convert_u64_to_bfp_short_reg PROC

; 2568 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2569 :     int        r1, r2;
; 2570 :     BYTE       m3, m4;
; 2571 :     U64        op2;
; 2572 :     float32_t  op1;
; 2573 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2574 : 
; 2575 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2576 : 
; 2577 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199449
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2578 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2579 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2580 : 
; 2581 :     SET_SF_RM_FROM_MASK( m3 );

  0019b	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001a0	85 c0		 test	 eax, eax
  001a2	74 16		 je	 SHORT $LN16@z900_conve
  001a4	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b4	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
  001b8	eb 1f		 jmp	 SHORT $LN17@z900_conve
$LN16@z900_conve:
  001ba	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001bf	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c5	83 e0 07	 and	 eax, 7
  001c8	8b c0		 mov	 eax, eax
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d5	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
$LN17@z900_conve:
  001d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001de	8b c0		 mov	 eax, eax
  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ef	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f3	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv176[rsp]
  001f8	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2582 :     op2 = regs->GR_G( r2 );

  001fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00200	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00205	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0020d	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 2583 :     softfloat_exceptionFlags = 0;

  00212	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00217	8b c0		 mov	 eax, eax
  00219	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00228	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022c	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2584 : 
; 2585 :     op1 = ui64_to_f32( op2 );

  00230	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  00235	e8 00 00 00 00	 call	 ui64_to_f32
  0023a	89 44 24 38	 mov	 DWORD PTR op1$[rsp], eax

; 2586 : 
; 2587 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  0023e	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00242	d1 e0		 shl	 eax, 1
  00244	48 98		 cdqe
  00246	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0024b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00253	48 8b d0	 mov	 rdx, rax
  00256	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  0025b	e8 00 00 00 00	 call	 z900_put_float32

; 2588 : 
; 2589 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  00260	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00265	8b c0		 mov	 eax, eax
  00267	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00276	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027e	85 c0		 test	 eax, eax
  00280	74 35		 je	 SHORT $LN13@z900_conve
  00282	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00287	83 e0 04	 and	 eax, 4
  0028a	85 c0		 test	 eax, eax
  0028c	75 29		 jne	 SHORT $LN13@z900_conve

; 2590 :     {
; 2591 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0028e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00298	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2592 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0029c	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002a0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002a5	85 c0		 test	 eax, eax
  002a7	74 0e		 je	 SHORT $LN14@z900_conve
  002a9	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002b2	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@z900_conve:
$LN13@z900_conve:

; 2593 :     }
; 2594 : }

  002b7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002bb	c3		 ret	 0
z900_convert_u64_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv176 = 44
r2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
z900_convert_u64_to_bfp_long_reg PROC

; 2531 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2532 :     int        r1, r2;
; 2533 :     BYTE       m3, m4;
; 2534 :     U64        op2;
; 2535 :     float64_t  op1;
; 2536 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2537 : 
; 2538 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2539 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199422
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2540 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2541 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2542 : 
; 2543 :     SET_SF_RM_FROM_MASK( m3 );

  0019b	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001a0	85 c0		 test	 eax, eax
  001a2	74 16		 je	 SHORT $LN16@z900_conve
  001a4	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b4	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
  001b8	eb 1f		 jmp	 SHORT $LN17@z900_conve
$LN16@z900_conve:
  001ba	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001bf	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c5	83 e0 07	 and	 eax, 7
  001c8	8b c0		 mov	 eax, eax
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d5	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
$LN17@z900_conve:
  001d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001de	8b c0		 mov	 eax, eax
  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ef	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f3	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv176[rsp]
  001f8	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2544 :     op2 = regs->GR_G( r2 );

  001fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00200	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00205	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0020d	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 2545 :     softfloat_exceptionFlags = 0;

  00212	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00217	8b c0		 mov	 eax, eax
  00219	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00228	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022c	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2546 : 
; 2547 :     op1 = ui64_to_f64( op2 );

  00230	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  00235	e8 00 00 00 00	 call	 ui64_to_f64
  0023a	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 2548 : 
; 2549 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  0023f	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00243	d1 e0		 shl	 eax, 1
  00245	48 98		 cdqe
  00247	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0024c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00254	48 8b d0	 mov	 rdx, rax
  00257	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  0025c	e8 00 00 00 00	 call	 z900_put_float64

; 2550 : 
; 2551 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  00261	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00266	8b c0		 mov	 eax, eax
  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00277	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027f	85 c0		 test	 eax, eax
  00281	74 35		 je	 SHORT $LN13@z900_conve
  00283	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00288	83 e0 04	 and	 eax, 4
  0028b	85 c0		 test	 eax, eax
  0028d	75 29		 jne	 SHORT $LN13@z900_conve

; 2552 :     {
; 2553 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0028f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00299	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2554 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0029d	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002a1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002a6	85 c0		 test	 eax, eax
  002a8	74 0e		 je	 SHORT $LN14@z900_conve
  002aa	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@z900_conve:
$LN13@z900_conve:

; 2555 :     }
; 2556 : }

  002b8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002bc	c3		 ret	 0
z900_convert_u64_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
temp$1 = 36
tv178 = 40
r1$ = 44
r2$ = 48
op2$ = 56
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
z900_convert_u64_to_bfp_ext_reg PROC

; 2500 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2501 :     int         r1, r2;
; 2502 :     BYTE        m3;
; 2503 :     U64         op2;
; 2504 :     float128_t  op1;
; 2505 : 
; 2506 :     RRF_M( inst, regs, r1, r2, m3 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 04	 shr	 eax, 4
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 0c	 shr	 eax, 12
  00057	83 e0 0f	 and	 eax, 15
  0005a	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0005e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00066	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006a	48 83 c0 04	 add	 rax, 4
  0006e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007a	33 c0		 xor	 eax, eax
  0007c	83 f8 04	 cmp	 eax, 4
  0007f	74 0f		 je	 SHORT $LN8@z900_conve
  00081	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2507 :     TXF_FLOAT_INSTR_CHECK( regs );

  00096	33 c0		 xor	 eax, eax
  00098	83 f8 01	 cmp	 eax, 1
  0009b	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000a1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b0	85 c0		 test	 eax, eax
  000b2	74 6e		 je	 SHORT $LN9@z900_conve
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 29		 jne	 SHORT $LN10@z900_conve
  000ba	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c9	85 c0		 test	 eax, eax
  000cb	75 16		 jne	 SHORT $LN10@z900_conve
  000cd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000dc	83 e0 04	 and	 eax, 4
  000df	85 c0		 test	 eax, eax
  000e1	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f1	0f ba e8 0b	 bts	 eax, 11
  000f5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fd	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00103	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199396
  0010a	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00110	ba 02 00 00 00	 mov	 edx, 2
  00115	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2508 :     BFPINST_CHECK( regs );

  0012c	b8 08 00 00 00	 mov	 eax, 8
  00131	48 6b c0 01	 imul	 rax, rax, 1
  00135	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00145	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014b	48 85 c0	 test	 rax, rax
  0014e	74 42		 je	 SHORT $LN12@z900_conve
  00150	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015e	d1 e8		 shr	 eax, 1
  00160	83 e0 01	 and	 eax, 1
  00163	85 c0		 test	 eax, eax
  00165	74 58		 je	 SHORT $LN11@z900_conve
  00167	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00176	b9 08 00 00 00	 mov	 ecx, 8
  0017b	48 6b c9 01	 imul	 rcx, rcx, 1
  0017f	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00187	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018d	48 85 c0	 test	 rax, rax
  00190	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00192	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001a4	ba 07 00 00 00	 mov	 edx, 7
  001a9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2509 :     BFPREGPAIR_CHECK( r1, regs );

  001bf	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001c3	83 e0 02	 and	 eax, 2
  001c6	85 c0		 test	 eax, eax
  001c8	74 1b		 je	 SHORT $LN13@z900_conve
  001ca	ba 06 00 00 00	 mov	 edx, 6
  001cf	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001df	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2510 :     BFPRM_CHECK( m3, regs );

  001e5	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  001ea	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f2	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2511 : 
; 2512 :     SET_SF_RM_FROM_MASK( m3 );

  001f7	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001fc	85 c0		 test	 eax, eax
  001fe	74 16		 je	 SHORT $LN15@z900_conve
  00200	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0020c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00210	89 44 24 28	 mov	 DWORD PTR tv178[rsp], eax
  00214	eb 22		 jmp	 SHORT $LN16@z900_conve
$LN15@z900_conve:
  00216	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00224	83 e0 07	 and	 eax, 7
  00227	8b c0		 mov	 eax, eax
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00230	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00234	89 44 24 28	 mov	 DWORD PTR tv178[rsp], eax
$LN16@z900_conve:
  00238	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0023d	8b c0		 mov	 eax, eax
  0023f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00245	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00252	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv178[rsp]
  00257	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2513 :     op2 = regs->GR_G( r2 );

  0025a	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  0025f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00267	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0026f	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 2514 :     softfloat_exceptionFlags = 0;

  00274	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00279	8b c0		 mov	 eax, eax
  0027b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00281	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0028a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0028e	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2515 : 
; 2516 :     op1 = ui64_to_f128( op2 );

  00292	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  00297	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  0029c	e8 00 00 00 00	 call	 ui64_to_f128
  002a1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  002a6	48 8b f9	 mov	 rdi, rcx
  002a9	48 8b f0	 mov	 rsi, rax
  002ac	b9 10 00 00 00	 mov	 ecx, 16
  002b1	f3 a4		 rep movsb

; 2517 : 
; 2518 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  002b3	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002b7	d1 e0		 shl	 eax, 1
  002b9	48 98		 cdqe
  002bb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c3	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002cb	48 8b d0	 mov	 rdx, rax
  002ce	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  002d3	e8 00 00 00 00	 call	 z900_put_float128

; 2519 : }

  002d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002dd	48 33 cc	 xor	 rcx, rsp
  002e0	e8 00 00 00 00	 call	 __security_check_cookie
  002e5	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002e9	5f		 pop	 rdi
  002ea	5e		 pop	 rsi
  002eb	c3		 ret	 0
z900_convert_u64_to_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv176 = 44
r2$ = 48
op2$ = 52
r1$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
z900_convert_u32_to_bfp_short_reg PROC

; 2467 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2468 :     int        r1, r2;
; 2469 :     BYTE       m3, m4;
; 2470 :     U32        op2;
; 2471 :     float32_t  op1;
; 2472 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2473 : 
; 2474 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN8@z900_conve
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2475 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 6f		 je	 SHORT $LN9@z900_conve
  00096	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a2	85 c0		 test	 eax, eax
  000a4	74 5f		 je	 SHORT $LN9@z900_conve
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 23		 jne	 SHORT $LN10@z900_conve
  000ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@z900_conve
  000bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000c8	83 e0 04	 and	 eax, 4
  000cb	85 c0		 test	 eax, eax
  000cd	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000cf	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	0f ba e8 0b	 bts	 eax, 11
  000de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199371
  000f0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 84		 jne	 SHORT $LN7@z900_conve

; 2476 :     BFPINST_CHECK( regs );

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00121	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00127	48 85 c0	 test	 rax, rax
  0012a	74 3c		 je	 SHORT $LN12@z900_conve
  0012c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00131	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00137	d1 e8		 shr	 eax, 1
  00139	83 e0 01	 and	 eax, 1
  0013c	85 c0		 test	 eax, eax
  0013e	74 4c		 je	 SHORT $LN11@z900_conve
  00140	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0015d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00163	48 85 c0	 test	 rax, rax
  00166	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00168	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00186	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2477 :     BFPRM_CHECK( m3, regs );

  0018c	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00191	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2478 : 
; 2479 :     SET_SF_RM_FROM_MASK( m3 );

  0019b	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001a0	85 c0		 test	 eax, eax
  001a2	74 16		 je	 SHORT $LN16@z900_conve
  001a4	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b4	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
  001b8	eb 1f		 jmp	 SHORT $LN17@z900_conve
$LN16@z900_conve:
  001ba	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001bf	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c5	83 e0 07	 and	 eax, 7
  001c8	8b c0		 mov	 eax, eax
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d5	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
$LN17@z900_conve:
  001d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001de	8b c0		 mov	 eax, eax
  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ef	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f3	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv176[rsp]
  001f8	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2480 :     op2 = regs->GR_L( r2 );

  001fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00200	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00205	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0020c	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 2481 :     softfloat_exceptionFlags = 0;

  00210	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00215	8b c0		 mov	 eax, eax
  00217	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00226	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022a	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2482 : 
; 2483 :     op1 = ui32_to_f32( op2 );

  0022e	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  00232	e8 00 00 00 00	 call	 ui32_to_f32
  00237	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 2484 : 
; 2485 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  0023b	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0023f	d1 e0		 shl	 eax, 1
  00241	48 98		 cdqe
  00243	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00248	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00250	48 8b d0	 mov	 rdx, rax
  00253	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  00258	e8 00 00 00 00	 call	 z900_put_float32

; 2486 : 
; 2487 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  0025d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00262	8b c0		 mov	 eax, eax
  00264	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00273	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00277	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027b	85 c0		 test	 eax, eax
  0027d	74 35		 je	 SHORT $LN13@z900_conve
  0027f	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00284	83 e0 04	 and	 eax, 4
  00287	85 c0		 test	 eax, eax
  00289	75 29		 jne	 SHORT $LN13@z900_conve

; 2488 :     {
; 2489 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0028b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00290	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00295	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2490 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00299	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0029d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002a2	85 c0		 test	 eax, eax
  002a4	74 0e		 je	 SHORT $LN14@z900_conve
  002a6	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002af	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@z900_conve:
$LN13@z900_conve:

; 2491 :     }
; 2492 : }

  002b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002b8	c3		 ret	 0
z900_convert_u32_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
temp$1 = 36
tv178 = 40
r2$ = 44
op2$ = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
z900_convert_u32_to_bfp_long_reg PROC

; 2438 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2439 :     int        r1, r2;
; 2440 :     BYTE       m3;
; 2441 :     U32        op2;
; 2442 :     float64_t  op1;
; 2443 : 
; 2444 :     RRF_M( inst, regs, r1, r2, m3 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN8@z900_conve
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2445 :     TXF_FLOAT_INSTR_CHECK( regs );

  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 01	 cmp	 eax, 1
  0007e	74 6f		 je	 SHORT $LN9@z900_conve
  00080	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00085	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0008c	85 c0		 test	 eax, eax
  0008e	74 5f		 je	 SHORT $LN9@z900_conve
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 23		 jne	 SHORT $LN10@z900_conve
  00096	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a2	85 c0		 test	 eax, eax
  000a4	75 13		 jne	 SHORT $LN10@z900_conve
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000b2	83 e0 04	 and	 eax, 4
  000b5	85 c0		 test	 eax, eax
  000b7	75 36		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000be	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c4	0f ba e8 0b	 bts	 eax, 11
  000c8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000cd	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199346
  000da	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e0	ba 02 00 00 00	 mov	 edx, 2
  000e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  000ef	33 c0		 xor	 eax, eax
  000f1	85 c0		 test	 eax, eax
  000f3	75 84		 jne	 SHORT $LN7@z900_conve

; 2446 :     BFPINST_CHECK( regs );

  000f5	b8 08 00 00 00	 mov	 eax, 8
  000fa	48 6b c0 01	 imul	 rax, rax, 1
  000fe	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00103	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0010b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00111	48 85 c0	 test	 rax, rax
  00114	74 3c		 je	 SHORT $LN12@z900_conve
  00116	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00121	d1 e8		 shr	 eax, 1
  00123	83 e0 01	 and	 eax, 1
  00126	85 c0		 test	 eax, eax
  00128	74 4c		 je	 SHORT $LN11@z900_conve
  0012a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00136	b9 08 00 00 00	 mov	 ecx, 8
  0013b	48 6b c9 01	 imul	 rcx, rcx, 1
  0013f	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00147	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014d	48 85 c0	 test	 rax, rax
  00150	75 24		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00152	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00157	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00161	ba 07 00 00 00	 mov	 edx, 7
  00166	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00170	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2447 :     BFPRM_CHECK( m3, regs );

  00176	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0017b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00180	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2448 : 
; 2449 :     op2 = regs->GR_L( r2 );

  00185	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0018a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00196	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 2450 :     SET_SF_RM_FROM_MASK( m3 );

  0019a	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0019f	85 c0		 test	 eax, eax
  001a1	74 16		 je	 SHORT $LN14@z900_conve
  001a3	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001af	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b3	89 44 24 28	 mov	 DWORD PTR tv178[rsp], eax
  001b7	eb 1f		 jmp	 SHORT $LN15@z900_conve
$LN14@z900_conve:
  001b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001be	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c4	83 e0 07	 and	 eax, 7
  001c7	8b c0		 mov	 eax, eax
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d4	89 44 24 28	 mov	 DWORD PTR tv178[rsp], eax
$LN15@z900_conve:
  001d8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001dd	8b c0		 mov	 eax, eax
  001df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ee	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f2	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv178[rsp]
  001f7	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2451 :     softfloat_exceptionFlags = 0;

  001fa	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ff	8b c0		 mov	 eax, eax
  00201	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00207	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00210	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00214	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2452 : 
; 2453 :     op1 = ui32_to_f64( op2 );

  00218	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  0021c	e8 00 00 00 00	 call	 ui32_to_f64
  00221	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 2454 : 
; 2455 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00226	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0022a	d1 e0		 shl	 eax, 1
  0022c	48 98		 cdqe
  0022e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00233	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0023b	48 8b d0	 mov	 rdx, rax
  0023e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00243	e8 00 00 00 00	 call	 z900_put_float64

; 2456 : }

  00248	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0024c	c3		 ret	 0
z900_convert_u32_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
temp$1 = 36
tv183 = 40
r1$ = 44
r2$ = 48
op2$ = 52
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
z900_convert_u32_to_bfp_ext_reg PROC

; 2410 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2411 :     int         r1, r2;
; 2412 :     BYTE        m3;
; 2413 :     U32         op2;
; 2414 :     float128_t  op1;
; 2415 : 
; 2416 :     RRF_M( inst, regs, r1, r2, m3 );

  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 04	 shr	 eax, 4
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 0c	 shr	 eax, 12
  00057	83 e0 0f	 and	 eax, 15
  0005a	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_conve:
  0005e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00066	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006a	48 83 c0 04	 add	 rax, 4
  0006e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007a	33 c0		 xor	 eax, eax
  0007c	83 f8 04	 cmp	 eax, 4
  0007f	74 0f		 je	 SHORT $LN8@z900_conve
  00081	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2417 :     TXF_FLOAT_INSTR_CHECK( regs );

  00096	33 c0		 xor	 eax, eax
  00098	83 f8 01	 cmp	 eax, 1
  0009b	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000a1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b0	85 c0		 test	 eax, eax
  000b2	74 6e		 je	 SHORT $LN9@z900_conve
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 29		 jne	 SHORT $LN10@z900_conve
  000ba	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c9	85 c0		 test	 eax, eax
  000cb	75 16		 jne	 SHORT $LN10@z900_conve
  000cd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000dc	83 e0 04	 and	 eax, 4
  000df	85 c0		 test	 eax, eax
  000e1	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000e3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f1	0f ba e8 0b	 bts	 eax, 11
  000f5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fd	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00103	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG199322
  0010a	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00110	ba 02 00 00 00	 mov	 edx, 2
  00115	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2418 :     BFPINST_CHECK( regs );

  0012c	b8 08 00 00 00	 mov	 eax, 8
  00131	48 6b c0 01	 imul	 rax, rax, 1
  00135	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00145	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014b	48 85 c0	 test	 rax, rax
  0014e	74 42		 je	 SHORT $LN12@z900_conve
  00150	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015e	d1 e8		 shr	 eax, 1
  00160	83 e0 01	 and	 eax, 1
  00163	85 c0		 test	 eax, eax
  00165	74 58		 je	 SHORT $LN11@z900_conve
  00167	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00176	b9 08 00 00 00	 mov	 ecx, 8
  0017b	48 6b c9 01	 imul	 rcx, rcx, 1
  0017f	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00187	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018d	48 85 c0	 test	 rax, rax
  00190	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00192	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  001a4	ba 07 00 00 00	 mov	 edx, 7
  001a9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2419 :     BFPREGPAIR_CHECK( r1, regs );

  001bf	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001c3	83 e0 02	 and	 eax, 2
  001c6	85 c0		 test	 eax, eax
  001c8	74 1b		 je	 SHORT $LN13@z900_conve
  001ca	ba 06 00 00 00	 mov	 edx, 6
  001cf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001df	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2420 :     BFPRM_CHECK( m3, regs );

  001e5	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  001ea	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f2	e8 00 00 00 00	 call	 z900_BFP_RM_check

; 2421 : 
; 2422 :     op2 = regs->GR_L( r2 );

  001f7	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  001fc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0020b	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 2423 :     SET_SF_RM_FROM_MASK( m3 );

  0020f	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00214	85 c0		 test	 eax, eax
  00216	74 16		 je	 SHORT $LN15@z900_conve
  00218	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 28	 mov	 DWORD PTR tv183[rsp], eax
  0022c	eb 22		 jmp	 SHORT $LN16@z900_conve
$LN15@z900_conve:
  0022e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00236	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0023c	83 e0 07	 and	 eax, 7
  0023f	8b c0		 mov	 eax, eax
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00248	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024c	89 44 24 28	 mov	 DWORD PTR tv183[rsp], eax
$LN16@z900_conve:
  00250	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00255	8b c0		 mov	 eax, eax
  00257	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0025d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00266	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026a	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv183[rsp]
  0026f	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2424 :     softfloat_exceptionFlags = 0;

  00272	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00277	8b c0		 mov	 eax, eax
  00279	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0027f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00288	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0028c	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2425 : 
; 2426 :     op1 = ui32_to_f128( op2 );

  00290	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  00294	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  00299	e8 00 00 00 00	 call	 ui32_to_f128
  0029e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  002a3	48 8b f9	 mov	 rdi, rcx
  002a6	48 8b f0	 mov	 rsi, rax
  002a9	b9 10 00 00 00	 mov	 ecx, 16
  002ae	f3 a4		 rep movsb

; 2427 : 
; 2428 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  002b0	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002b4	d1 e0		 shl	 eax, 1
  002b6	48 98		 cdqe
  002b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002c8	48 8b d0	 mov	 rdx, rax
  002cb	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  002d0	e8 00 00 00 00	 call	 z900_put_float128

; 2429 : }

  002d5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002da	48 33 cc	 xor	 rcx, rsp
  002dd	e8 00 00 00 00	 call	 __security_check_cookie
  002e2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002e6	5f		 pop	 rdi
  002e7	5e		 pop	 rsi
  002e8	c3		 ret	 0
z900_convert_u32_to_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
expo$ = 0
sign$ = 4
fract$ = 8
roundup$ = 16
tv82 = 20
tv85 = 24
tv92 = 28
cc$ = 32
b$ = 40
tv250 = 48
tv260 = 56
fpr$ = 80
rounding$ = 88
bfp_fractbits$ = 96
bfp_emax$ = 104
bfp_ebias$ = 112
result_sign$ = 120
result_exp$ = 128
result_fract$ = 136
cnvt_hfp_to_bfp PROC

; 977  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 978  :     BYTE   sign;
; 979  :     short  expo;
; 980  :     U64    fract;
; 981  :     int    roundup = 0;

  00017	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR roundup$[rsp], 0

; 982  :     int    cc;
; 983  :     U64    b;
; 984  : 
; 985  :     /* Break the source operand into sign, characteristic, fraction */
; 986  :     sign  =        fpr[0] >> 31;

  0001f	b8 04 00 00 00	 mov	 eax, 4
  00024	48 6b c0 00	 imul	 rax, rax, 0
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fpr$[rsp]
  0002d	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00030	c1 e8 1f	 shr	 eax, 31
  00033	88 44 24 04	 mov	 BYTE PTR sign$[rsp], al

; 987  :     expo  =       (fpr[0] >> 24) & 0x007F;

  00037	b8 04 00 00 00	 mov	 eax, 4
  0003c	48 6b c0 00	 imul	 rax, rax, 0
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fpr$[rsp]
  00045	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00048	c1 e8 18	 shr	 eax, 24
  0004b	83 e0 7f	 and	 eax, 127		; 0000007fH
  0004e	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax

; 988  :     fract = ((U64)(fpr[0] & 0x00FFFFFF) << 32) | fpr[1];

  00052	b8 04 00 00 00	 mov	 eax, 4
  00057	48 6b c0 00	 imul	 rax, rax, 0
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fpr$[rsp]
  00060	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00063	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00068	8b c0		 mov	 eax, eax
  0006a	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0006e	b9 04 00 00 00	 mov	 ecx, 4
  00073	48 6b c9 01	 imul	 rcx, rcx, 1
  00077	48 8b 54 24 50	 mov	 rdx, QWORD PTR fpr$[rsp]
  0007c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0007f	48 0b c1	 or	 rax, rcx
  00082	48 89 44 24 08	 mov	 QWORD PTR fract$[rsp], rax

; 989  : 
; 990  :     /* Determine whether to round up or down */
; 991  :     switch (rounding)

  00087	8b 44 24 58	 mov	 eax, DWORD PTR rounding$[rsp]
  0008b	89 44 24 14	 mov	 DWORD PTR tv82[rsp], eax
  0008f	83 7c 24 14 07	 cmp	 DWORD PTR tv82[rsp], 7
  00094	77 5a		 ja	 SHORT $LN2@cnvt_hfp_t
  00096	48 63 44 24 14	 movsxd	 rax, DWORD PTR tv82[rsp]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a2	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN31@cnvt_hfp_t[rcx+rax*4]
  000a9	48 03 c1	 add	 rax, rcx
  000ac	ff e0		 jmp	 rax
$LN6@cnvt_hfp_t:
$LN7@cnvt_hfp_t:

; 992  :     {
; 993  :         case RM_BIASED_ROUND_TO_NEAREST:
; 994  :         case RM_ROUND_TO_NEAREST:     roundup =         0;      break;

  000ae	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR roundup$[rsp], 0
  000b6	eb 38		 jmp	 SHORT $LN2@cnvt_hfp_t
$LN8@cnvt_hfp_t:
$LN9@cnvt_hfp_t:

; 995  : 
; 996  :         case RM_DEFAULT_ROUNDING:
; 997  :         case RM_ROUND_TOWARD_ZERO:    roundup =         0;      break;

  000b8	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR roundup$[rsp], 0
  000c0	eb 2e		 jmp	 SHORT $LN2@cnvt_hfp_t
$LN10@cnvt_hfp_t:

; 998  :         case RM_ROUND_TOWARD_POS_INF: roundup = (sign ? 0 : 1); break;

  000c2	0f b6 44 24 04	 movzx	 eax, BYTE PTR sign$[rsp]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN27@cnvt_hfp_t
  000cb	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
  000d3	eb 08		 jmp	 SHORT $LN28@cnvt_hfp_t
$LN27@cnvt_hfp_t:
  000d5	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
$LN28@cnvt_hfp_t:
  000dd	8b 44 24 18	 mov	 eax, DWORD PTR tv85[rsp]
  000e1	89 44 24 10	 mov	 DWORD PTR roundup$[rsp], eax
  000e5	eb 09		 jmp	 SHORT $LN2@cnvt_hfp_t
$LN11@cnvt_hfp_t:

; 999  :         case RM_ROUND_TOWARD_NEG_INF: roundup =  sign;          break;

  000e7	0f b6 44 24 04	 movzx	 eax, BYTE PTR sign$[rsp]
  000ec	89 44 24 10	 mov	 DWORD PTR roundup$[rsp], eax
$LN2@cnvt_hfp_t:

; 1000 :     }
; 1001 : 
; 1002 :     /* Convert HFP zero to BFP zero and return cond code 0 */
; 1003 :     if (fract == 0) /* a = -0 or +0 */

  000f0	48 83 7c 24 08
	00		 cmp	 QWORD PTR fract$[rsp], 0
  000f6	75 30		 jne	 SHORT $LN12@cnvt_hfp_t

; 1004 :     {
; 1005 :         *result_sign  = sign;

  000f8	0f b6 44 24 04	 movzx	 eax, BYTE PTR sign$[rsp]
  000fd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR result_sign$[rsp]
  00102	89 01		 mov	 DWORD PTR [rcx], eax

; 1006 :         *result_exp   = 0;

  00104	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result_exp$[rsp]
  0010c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1007 :         *result_fract = 0;

  00112	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR result_fract$[rsp]
  0011a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1008 :         return 0;

  00121	33 c0		 xor	 eax, eax
  00123	e9 63 02 00 00	 jmp	 $LN1@cnvt_hfp_t
$LN12@cnvt_hfp_t:

; 1009 :     }
; 1010 : 
; 1011 :     /* Set the condition code */
; 1012 :     cc = sign ? 1 : 2;

  00128	0f b6 44 24 04	 movzx	 eax, BYTE PTR sign$[rsp]
  0012d	85 c0		 test	 eax, eax
  0012f	74 0a		 je	 SHORT $LN29@cnvt_hfp_t
  00131	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00139	eb 08		 jmp	 SHORT $LN30@cnvt_hfp_t
$LN29@cnvt_hfp_t:
  0013b	c7 44 24 1c 02
	00 00 00	 mov	 DWORD PTR tv92[rsp], 2
$LN30@cnvt_hfp_t:
  00143	8b 44 24 1c	 mov	 eax, DWORD PTR tv92[rsp]
  00147	89 44 24 20	 mov	 DWORD PTR cc$[rsp], eax

; 1013 : 
; 1014 :     /* Convert the HFP characteristic to a true binary exponent */
; 1015 :     expo = (expo - 64) * 4;

  0014b	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  0014f	8d 04 85 00 ff
	ff ff		 lea	 eax, DWORD PTR [rax*4-256]
  00156	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax

; 1016 : 
; 1017 :     /* Convert true binary exponent to a biased exponent */
; 1018 :     expo += bfp_ebias;

  0015a	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  0015e	03 44 24 70	 add	 eax, DWORD PTR bfp_ebias$[rsp]
  00162	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax
$LN4@cnvt_hfp_t:

; 1019 : 
; 1020 :     /* Shift the fraction left until leftmost 1 is in bit 8 */
; 1021 :     while ((fract & 0x0080000000000000ULL) == 0)

  00166	48 b8 00 00 00
	00 00 00 80 00	 mov	 rax, 36028797018963968	; 0080000000000000H
  00170	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fract$[rsp]
  00175	48 23 c8	 and	 rcx, rax
  00178	48 8b c1	 mov	 rax, rcx
  0017b	48 85 c0	 test	 rax, rax
  0017e	75 19		 jne	 SHORT $LN5@cnvt_hfp_t

; 1022 :     {
; 1023 :         fract <<= 1;

  00180	48 8b 44 24 08	 mov	 rax, QWORD PTR fract$[rsp]
  00185	48 d1 e0	 shl	 rax, 1
  00188	48 89 44 24 08	 mov	 QWORD PTR fract$[rsp], rax

; 1024 :         expo  -=  1;

  0018d	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  00191	ff c8		 dec	 eax
  00193	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax

; 1025 :     }

  00197	eb cd		 jmp	 SHORT $LN4@cnvt_hfp_t
$LN5@cnvt_hfp_t:

; 1026 : 
; 1027 :     /* Convert 56-bit fraction to 55-bit with implied 1 */
; 1028 :     expo--;

  00199	0f b7 04 24	 movzx	 eax, WORD PTR expo$[rsp]
  0019d	66 ff c8	 dec	 ax
  001a0	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax

; 1029 :     fract &= 0x007FFFFFFFFFFFFFULL;

  001a4	48 b8 ff ff ff
	ff ff ff 7f 00	 mov	 rax, 36028797018963967	; 007fffffffffffffH
  001ae	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fract$[rsp]
  001b3	48 23 c8	 and	 rcx, rax
  001b6	48 8b c1	 mov	 rax, rcx
  001b9	48 89 44 24 08	 mov	 QWORD PTR fract$[rsp], rax

; 1030 : 
; 1031 :     if (expo < -(bfp_fractbits-1)) /* |a| < Dmin */

  001be	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR bfp_fractbits$[rsp]
  001c6	ff c9		 dec	 ecx
  001c8	f7 d9		 neg	 ecx
  001ca	3b c1		 cmp	 eax, ecx
  001cc	7d 5a		 jge	 SHORT $LN13@cnvt_hfp_t

; 1032 :     {
; 1033 :         if (expo == -(bfp_fractbits-1) - 1)

  001ce	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  001d2	8b 4c 24 60	 mov	 ecx, DWORD PTR bfp_fractbits$[rsp]
  001d6	ff c9		 dec	 ecx
  001d8	f7 d9		 neg	 ecx
  001da	ff c9		 dec	 ecx
  001dc	3b c1		 cmp	 eax, ecx
  001de	75 1c		 jne	 SHORT $LN15@cnvt_hfp_t

; 1034 :         {
; 1035 :             if (0
; 1036 :                 || rounding == RM_BIASED_ROUND_TO_NEAREST
; 1037 :                 || rounding == RM_ROUND_TO_NEAREST

  001e0	33 c0		 xor	 eax, eax
  001e2	85 c0		 test	 eax, eax
  001e4	75 0e		 jne	 SHORT $LN17@cnvt_hfp_t
  001e6	83 7c 24 58 01	 cmp	 DWORD PTR rounding$[rsp], 1
  001eb	74 07		 je	 SHORT $LN17@cnvt_hfp_t
  001ed	83 7c 24 58 04	 cmp	 DWORD PTR rounding$[rsp], 4
  001f2	75 08		 jne	 SHORT $LN16@cnvt_hfp_t
$LN17@cnvt_hfp_t:

; 1038 :             )
; 1039 :                 roundup = 1;

  001f4	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR roundup$[rsp], 1
$LN16@cnvt_hfp_t:
$LN15@cnvt_hfp_t:

; 1040 :         }
; 1041 : 
; 1042 :         if (roundup) { expo = 0; fract = 1; }   /* Dmin */

  001fc	83 7c 24 10 00	 cmp	 DWORD PTR roundup$[rsp], 0
  00201	74 11		 je	 SHORT $LN18@cnvt_hfp_t
  00203	33 c0		 xor	 eax, eax
  00205	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax
  00209	48 c7 44 24 08
	01 00 00 00	 mov	 QWORD PTR fract$[rsp], 1
  00212	eb 0f		 jmp	 SHORT $LN19@cnvt_hfp_t
$LN18@cnvt_hfp_t:

; 1043 :         else         { expo = 0; fract = 0; }   /* Zero */

  00214	33 c0		 xor	 eax, eax
  00216	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax
  0021a	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR fract$[rsp], 0
$LN19@cnvt_hfp_t:

; 1044 :     }

  00223	e9 d2 00 00 00	 jmp	 $LN14@cnvt_hfp_t
$LN13@cnvt_hfp_t:

; 1045 :     else if (expo < 1)                          /* Dmin <= |a| < Nmin */

  00228	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  0022c	83 f8 01	 cmp	 eax, 1
  0022f	7d 43		 jge	 SHORT $LN20@cnvt_hfp_t

; 1046 :     {
; 1047 :         /* Reinstate implied 1 in preparation for denormalization */
; 1048 :         fract |= 0x0080000000000000ULL;

  00231	48 b8 00 00 00
	00 00 00 80 00	 mov	 rax, 36028797018963968	; 0080000000000000H
  0023b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fract$[rsp]
  00240	48 0b c8	 or	 rcx, rax
  00243	48 8b c1	 mov	 rax, rcx
  00246	48 89 44 24 08	 mov	 QWORD PTR fract$[rsp], rax

; 1049 : 
; 1050 :         /* Denormalize to get exponent back in range */
; 1051 :         fract >>= (expo + (bfp_fractbits-1));

  0024b	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  0024f	8b 4c 24 60	 mov	 ecx, DWORD PTR bfp_fractbits$[rsp]
  00253	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00257	48 98		 cdqe
  00259	0f b6 c8	 movzx	 ecx, al
  0025c	48 8b 44 24 08	 mov	 rax, QWORD PTR fract$[rsp]
  00261	48 d3 e8	 shr	 rax, cl
  00264	48 89 44 24 08	 mov	 QWORD PTR fract$[rsp], rax

; 1052 :         expo    =  0;

  00269	33 c0		 xor	 eax, eax
  0026b	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax

; 1053 :     }

  0026f	e9 86 00 00 00	 jmp	 $LN21@cnvt_hfp_t
$LN20@cnvt_hfp_t:

; 1054 :     else if (expo > (bfp_emax+bfp_ebias))       /* |a| > Nmax */

  00274	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  00278	8b 4c 24 70	 mov	 ecx, DWORD PTR bfp_ebias$[rsp]
  0027c	8b 54 24 68	 mov	 edx, DWORD PTR bfp_emax$[rsp]
  00280	03 d1		 add	 edx, ecx
  00282	8b ca		 mov	 ecx, edx
  00284	3b c1		 cmp	 eax, ecx
  00286	7e 72		 jle	 SHORT $LN22@cnvt_hfp_t

; 1055 :     {
; 1056 :         cc = 3;

  00288	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 1057 : 
; 1058 :         if (roundup)    /* Inf */

  00290	83 7c 24 10 00	 cmp	 DWORD PTR roundup$[rsp], 0
  00295	74 1b		 je	 SHORT $LN23@cnvt_hfp_t

; 1059 :         {
; 1060 :             expo  = (bfp_emax+bfp_ebias) + 1;

  00297	8b 44 24 68	 mov	 eax, DWORD PTR bfp_emax$[rsp]
  0029b	8b 4c 24 70	 mov	 ecx, DWORD PTR bfp_ebias$[rsp]
  0029f	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  002a3	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax

; 1061 :             fract = 0;

  002a7	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR fract$[rsp], 0

; 1062 :         }

  002b0	eb 48		 jmp	 SHORT $LN24@cnvt_hfp_t
$LN23@cnvt_hfp_t:

; 1063 :         else            /* Nmax */
; 1064 :         {
; 1065 :             expo  = (bfp_emax+bfp_ebias);

  002b2	8b 44 24 70	 mov	 eax, DWORD PTR bfp_ebias$[rsp]
  002b6	8b 4c 24 68	 mov	 ecx, DWORD PTR bfp_emax$[rsp]
  002ba	03 c8		 add	 ecx, eax
  002bc	8b c1		 mov	 eax, ecx
  002be	66 89 04 24	 mov	 WORD PTR expo$[rsp], ax

; 1066 :             fract = 0x007FFFFFFFFFFFFFULL - (((U64)1<<(1+(55-bfp_fractbits)))-1);

  002c2	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  002c7	2b 44 24 60	 sub	 eax, DWORD PTR bfp_fractbits$[rsp]
  002cb	ff c0		 inc	 eax
  002cd	b9 01 00 00 00	 mov	 ecx, 1
  002d2	48 89 4c 24 30	 mov	 QWORD PTR tv250[rsp], rcx
  002d7	0f b6 c8	 movzx	 ecx, al
  002da	48 8b 44 24 30	 mov	 rax, QWORD PTR tv250[rsp]
  002df	48 d3 e0	 shl	 rax, cl
  002e2	48 ff c8	 dec	 rax
  002e5	48 b9 ff ff ff
	ff ff ff 7f 00	 mov	 rcx, 36028797018963967	; 007fffffffffffffH
  002ef	48 2b c8	 sub	 rcx, rax
  002f2	48 8b c1	 mov	 rax, rcx
  002f5	48 89 44 24 08	 mov	 QWORD PTR fract$[rsp], rax
$LN24@cnvt_hfp_t:
$LN22@cnvt_hfp_t:
$LN21@cnvt_hfp_t:
$LN14@cnvt_hfp_t:

; 1067 :         }
; 1068 :     }
; 1069 : 
; 1070 :     /* Set the result sign and exponent */
; 1071 :     *result_sign = sign;

  002fa	0f b6 44 24 04	 movzx	 eax, BYTE PTR sign$[rsp]
  002ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR result_sign$[rsp]
  00304	89 01		 mov	 DWORD PTR [rcx], eax

; 1072 :     *result_exp  = expo;

  00306	0f bf 04 24	 movsx	 eax, WORD PTR expo$[rsp]
  0030a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR result_exp$[rsp]
  00312	89 01		 mov	 DWORD PTR [rcx], eax

; 1073 : 
; 1074 :     /* Apply rounding before truncating to final fraction length */
; 1075 :     b = ( (U64)1 ) << ( 55 - bfp_fractbits);

  00314	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  00319	2b 44 24 60	 sub	 eax, DWORD PTR bfp_fractbits$[rsp]
  0031d	b9 01 00 00 00	 mov	 ecx, 1
  00322	48 89 4c 24 38	 mov	 QWORD PTR tv260[rsp], rcx
  00327	0f b6 c8	 movzx	 ecx, al
  0032a	48 8b 44 24 38	 mov	 rax, QWORD PTR tv260[rsp]
  0032f	48 d3 e0	 shl	 rax, cl
  00332	48 89 44 24 28	 mov	 QWORD PTR b$[rsp], rax

; 1076 : 
; 1077 :     if (roundup && (fract & b))

  00337	83 7c 24 10 00	 cmp	 DWORD PTR roundup$[rsp], 0
  0033c	74 2a		 je	 SHORT $LN25@cnvt_hfp_t
  0033e	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00343	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fract$[rsp]
  00348	48 23 c8	 and	 rcx, rax
  0034b	48 8b c1	 mov	 rax, rcx
  0034e	48 85 c0	 test	 rax, rax
  00351	74 15		 je	 SHORT $LN25@cnvt_hfp_t

; 1078 :         fract += b;

  00353	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00358	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fract$[rsp]
  0035d	48 03 c8	 add	 rcx, rax
  00360	48 8b c1	 mov	 rax, rcx
  00363	48 89 44 24 08	 mov	 QWORD PTR fract$[rsp], rax
$LN25@cnvt_hfp_t:

; 1079 : 
; 1080 :     /* Convert 55-bit fraction to result fraction length */
; 1081 :     *result_fract = fract >> (55-bfp_fractbits);

  00368	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  0036d	2b 44 24 60	 sub	 eax, DWORD PTR bfp_fractbits$[rsp]
  00371	0f b6 c8	 movzx	 ecx, al
  00374	48 8b 44 24 08	 mov	 rax, QWORD PTR fract$[rsp]
  00379	48 d3 e8	 shr	 rax, cl
  0037c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR result_fract$[rsp]
  00384	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1082 : 
; 1083 :     return cc;

  00387	8b 44 24 20	 mov	 eax, DWORD PTR cc$[rsp]
$LN1@cnvt_hfp_t:

; 1084 : } /* end function cnvt_hfp_to_bfp */

  0038b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0038f	c3		 ret	 0
$LN31@cnvt_hfp_t:
  00390	00 00 00 00	 DD	 $LN8@cnvt_hfp_t
  00394	00 00 00 00	 DD	 $LN6@cnvt_hfp_t
  00398	00 00 00 00	 DD	 $LN2@cnvt_hfp_t
  0039c	00 00 00 00	 DD	 $LN2@cnvt_hfp_t
  003a0	00 00 00 00	 DD	 $LN7@cnvt_hfp_t
  003a4	00 00 00 00	 DD	 $LN9@cnvt_hfp_t
  003a8	00 00 00 00	 DD	 $LN10@cnvt_hfp_t
  003ac	00 00 00 00	 DD	 $LN11@cnvt_hfp_t
cnvt_hfp_to_bfp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
exp$ = 0
r0$ = 4
r1$ = 8
cc$ = 12
tv64 = 16
tv67 = 20
tv70 = 24
tv73 = 28
tv76 = 32
tv91 = 36
tv94 = 40
tv130 = 44
tv134 = 48
tv145 = 52
fract$ = 56
op$ = 80
fpclass$ = 88
fpr$ = 96
cnvt_bfp_to_hfp PROC

; 864  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 865  :     int exp;
; 866  :     U64 fract;
; 867  :     U32 r0, r1;
; 868  :     int cc;
; 869  : 
; 870  :     switch (fpclass) {

  00012	8b 44 24 58	 mov	 eax, DWORD PTR fpclass$[rsp]
  00016	89 44 24 10	 mov	 DWORD PTR tv64[rsp], eax
  0001a	83 7c 24 10 fe	 cmp	 DWORD PTR tv64[rsp], -2
  0001f	0f 84 a8 00 00
	00		 je	 $LN10@cnvt_bfp_t
  00025	83 7c 24 10 ff	 cmp	 DWORD PTR tv64[rsp], -1
  0002a	0f 84 f2 00 00
	00		 je	 $LN11@cnvt_bfp_t
  00030	83 7c 24 10 00	 cmp	 DWORD PTR tv64[rsp], 0
  00035	74 5d		 je	 SHORT $LN9@cnvt_bfp_t
  00037	83 7c 24 10 01	 cmp	 DWORD PTR tv64[rsp], 1
  0003c	74 1d		 je	 SHORT $LN8@cnvt_bfp_t

; 871  :     default:
; 872  :     case FP_NAN:
; 873  :         r0 = 0x7FFFFFFF;

  0003e	c7 44 24 04 ff
	ff ff 7f	 mov	 DWORD PTR r0$[rsp], 2147483647 ; 7fffffffH

; 874  :         r1 = 0xFFFFFFFF;

  00046	c7 44 24 08 ff
	ff ff ff	 mov	 DWORD PTR r1$[rsp], -1	; ffffffffH

; 875  :         cc = 3;

  0004e	c7 44 24 0c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 876  :         break;

  00056	e9 34 02 00 00	 jmp	 $LN2@cnvt_bfp_t
$LN8@cnvt_bfp_t:

; 877  :     case FP_INFINITE:
; 878  :         r0 = op->sign ? 0xFFFFFFFF : 0x7FFFFFFF;

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00060	83 38 00	 cmp	 DWORD PTR [rax], 0
  00063	74 0a		 je	 SHORT $LN15@cnvt_bfp_t
  00065	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR tv67[rsp], -1	; ffffffffH
  0006d	eb 08		 jmp	 SHORT $LN16@cnvt_bfp_t
$LN15@cnvt_bfp_t:
  0006f	c7 44 24 14 ff
	ff ff 7f	 mov	 DWORD PTR tv67[rsp], 2147483647 ; 7fffffffH
$LN16@cnvt_bfp_t:
  00077	8b 44 24 14	 mov	 eax, DWORD PTR tv67[rsp]
  0007b	89 44 24 04	 mov	 DWORD PTR r0$[rsp], eax

; 879  :         r1 = 0xFFFFFFFF;

  0007f	c7 44 24 08 ff
	ff ff ff	 mov	 DWORD PTR r1$[rsp], -1	; ffffffffH

; 880  :         cc = 3;

  00087	c7 44 24 0c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 881  :         break;

  0008f	e9 fb 01 00 00	 jmp	 $LN2@cnvt_bfp_t
$LN9@cnvt_bfp_t:

; 882  :     case FP_ZERO:
; 883  :         r0 = op->sign ? 0x80000000 : 0;

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00099	83 38 00	 cmp	 DWORD PTR [rax], 0
  0009c	74 0a		 je	 SHORT $LN17@cnvt_bfp_t
  0009e	c7 44 24 18 00
	00 00 80	 mov	 DWORD PTR tv70[rsp], -2147483648 ; 80000000H
  000a6	eb 08		 jmp	 SHORT $LN18@cnvt_bfp_t
$LN17@cnvt_bfp_t:
  000a8	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN18@cnvt_bfp_t:
  000b0	8b 44 24 18	 mov	 eax, DWORD PTR tv70[rsp]
  000b4	89 44 24 04	 mov	 DWORD PTR r0$[rsp], eax

; 884  :         r1 = 0;

  000b8	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR r1$[rsp], 0

; 885  :         cc = 0;

  000c0	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 886  :         break;

  000c8	e9 c2 01 00 00	 jmp	 $LN2@cnvt_bfp_t
$LN10@cnvt_bfp_t:

; 887  :     case FP_SUBNORMAL:
; 888  :         r0 = op->sign ? 0x80000000 : 0;

  000cd	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d2	83 38 00	 cmp	 DWORD PTR [rax], 0
  000d5	74 0a		 je	 SHORT $LN19@cnvt_bfp_t
  000d7	c7 44 24 1c 00
	00 00 80	 mov	 DWORD PTR tv73[rsp], -2147483648 ; 80000000H
  000df	eb 08		 jmp	 SHORT $LN20@cnvt_bfp_t
$LN19@cnvt_bfp_t:
  000e1	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN20@cnvt_bfp_t:
  000e9	8b 44 24 1c	 mov	 eax, DWORD PTR tv73[rsp]
  000ed	89 44 24 04	 mov	 DWORD PTR r0$[rsp], eax

; 889  :         r1 = 0;

  000f1	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR r1$[rsp], 0

; 890  :         cc = op->sign ? 1 : 2;

  000f9	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000fe	83 38 00	 cmp	 DWORD PTR [rax], 0
  00101	74 0a		 je	 SHORT $LN21@cnvt_bfp_t
  00103	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0010b	eb 08		 jmp	 SHORT $LN22@cnvt_bfp_t
$LN21@cnvt_bfp_t:
  0010d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv76[rsp], 2
$LN22@cnvt_bfp_t:
  00115	8b 44 24 20	 mov	 eax, DWORD PTR tv76[rsp]
  00119	89 44 24 0c	 mov	 DWORD PTR cc$[rsp], eax

; 891  :         break;

  0011d	e9 6d 01 00 00	 jmp	 $LN2@cnvt_bfp_t
$LN11@cnvt_bfp_t:

; 892  :     case FP_NORMAL:
; 893  :         //logmsg("ieee: exp=%d (X\'%3.3x\')\tfract=%16.16"PRIx64"\n",
; 894  :         //        op->exp, op->exp, op->fract);
; 895  :         /* Insert an implied 1. in front of the 52 bit binary
; 896  :            fraction and lengthen the result to 56 bits */
; 897  :         fract = (U64)(op->fract | 0x10000000000000ULL) << 3;

  00122	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00127	48 b9 00 00 00
	00 00 00 10 00	 mov	 rcx, 4503599627370496	; 0010000000000000H
  00131	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00135	48 0b c1	 or	 rax, rcx
  00138	48 c1 e0 03	 shl	 rax, 3
  0013c	48 89 44 24 38	 mov	 QWORD PTR fract$[rsp], rax

; 898  : 
; 899  :         /* The binary exponent is equal to the biased exponent - 1023
; 900  :            adjusted by 1 to move the point before the 56 bit fraction */
; 901  :         exp = op->exp - 1023 + 1;

  00141	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00146	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00149	2d fe 03 00 00	 sub	 eax, 1022		; 000003feH
  0014e	89 04 24	 mov	 DWORD PTR exp$[rsp], eax
$LN4@cnvt_bfp_t:

; 902  : 
; 903  :         //logmsg("ieee: adjusted exp=%d\tfract=%16.16"PRIx64"\n", exp, fract);
; 904  :         /* Shift the fraction right one bit at a time until
; 905  :            the binary exponent becomes a multiple of 4 */
; 906  :         while (exp & 3)

  00151	8b 04 24	 mov	 eax, DWORD PTR exp$[rsp]
  00154	83 e0 03	 and	 eax, 3
  00157	85 c0		 test	 eax, eax
  00159	74 17		 je	 SHORT $LN5@cnvt_bfp_t

; 907  :         {
; 908  :             exp++;

  0015b	8b 04 24	 mov	 eax, DWORD PTR exp$[rsp]
  0015e	ff c0		 inc	 eax
  00160	89 04 24	 mov	 DWORD PTR exp$[rsp], eax

; 909  :             fract >>= 1;

  00163	48 8b 44 24 38	 mov	 rax, QWORD PTR fract$[rsp]
  00168	48 d1 e8	 shr	 rax, 1
  0016b	48 89 44 24 38	 mov	 QWORD PTR fract$[rsp], rax

; 910  :         }

  00170	eb df		 jmp	 SHORT $LN4@cnvt_bfp_t
$LN5@cnvt_bfp_t:

; 911  :         //logmsg("ieee:  shifted exp=%d\tfract=%16.16"PRIx64"\n", exp, fract);
; 912  : 
; 913  :         /* Convert the binary exponent into a hexadecimal exponent
; 914  :            by dropping the last two bits (which are now zero) */
; 915  :         exp >>= 2;

  00172	8b 04 24	 mov	 eax, DWORD PTR exp$[rsp]
  00175	c1 f8 02	 sar	 eax, 2
  00178	89 04 24	 mov	 DWORD PTR exp$[rsp], eax

; 916  : 
; 917  :         /* If the hexadecimal exponent is less than -64 then return
; 918  :            a signed zero result with a non-zero condition code */
; 919  :         if (exp < -64) {

  0017b	83 3c 24 c0	 cmp	 DWORD PTR exp$[rsp], -64 ; ffffffffffffffc0H
  0017f	7d 55		 jge	 SHORT $LN12@cnvt_bfp_t

; 920  :             r0 = op->sign ? 0x80000000 : 0;

  00181	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00186	83 38 00	 cmp	 DWORD PTR [rax], 0
  00189	74 0a		 je	 SHORT $LN23@cnvt_bfp_t
  0018b	c7 44 24 24 00
	00 00 80	 mov	 DWORD PTR tv91[rsp], -2147483648 ; 80000000H
  00193	eb 08		 jmp	 SHORT $LN24@cnvt_bfp_t
$LN23@cnvt_bfp_t:
  00195	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN24@cnvt_bfp_t:
  0019d	8b 44 24 24	 mov	 eax, DWORD PTR tv91[rsp]
  001a1	89 44 24 04	 mov	 DWORD PTR r0$[rsp], eax

; 921  :             r1 = 0;

  001a5	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR r1$[rsp], 0

; 922  :             cc = op->sign ? 1 : 2;

  001ad	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  001b2	83 38 00	 cmp	 DWORD PTR [rax], 0
  001b5	74 0a		 je	 SHORT $LN25@cnvt_bfp_t
  001b7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  001bf	eb 08		 jmp	 SHORT $LN26@cnvt_bfp_t
$LN25@cnvt_bfp_t:
  001c1	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv94[rsp], 2
$LN26@cnvt_bfp_t:
  001c9	8b 44 24 28	 mov	 eax, DWORD PTR tv94[rsp]
  001cd	89 44 24 0c	 mov	 DWORD PTR cc$[rsp], eax

; 923  :             break;

  001d1	e9 b9 00 00 00	 jmp	 $LN2@cnvt_bfp_t
$LN12@cnvt_bfp_t:

; 924  :         }
; 925  : 
; 926  :         /* If the hexadecimal exponent exceeds +63 then return
; 927  :            a signed maximum result with condition code 3 */
; 928  :         if (exp > 63) {

  001d6	83 3c 24 3f	 cmp	 DWORD PTR exp$[rsp], 63	; 0000003fH
  001da	7e 36		 jle	 SHORT $LN13@cnvt_bfp_t

; 929  :             r0 = op->sign ? 0xFFFFFFFF : 0x7FFFFFFF;

  001dc	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  001e1	83 38 00	 cmp	 DWORD PTR [rax], 0
  001e4	74 0a		 je	 SHORT $LN27@cnvt_bfp_t
  001e6	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR tv130[rsp], -1 ; ffffffffH
  001ee	eb 08		 jmp	 SHORT $LN28@cnvt_bfp_t
$LN27@cnvt_bfp_t:
  001f0	c7 44 24 2c ff
	ff ff 7f	 mov	 DWORD PTR tv130[rsp], 2147483647 ; 7fffffffH
$LN28@cnvt_bfp_t:
  001f8	8b 44 24 2c	 mov	 eax, DWORD PTR tv130[rsp]
  001fc	89 44 24 04	 mov	 DWORD PTR r0$[rsp], eax

; 930  :             r1 = 0xFFFFFFFF;

  00200	c7 44 24 08 ff
	ff ff ff	 mov	 DWORD PTR r1$[rsp], -1	; ffffffffH

; 931  :             cc = 3;

  00208	c7 44 24 0c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 932  :             break;

  00210	eb 7d		 jmp	 SHORT $LN2@cnvt_bfp_t
$LN13@cnvt_bfp_t:

; 933  :         }
; 934  : 
; 935  :         /* Convert the hexadecimal exponent to a characteristic
; 936  :            by adding 64 */
; 937  :         exp += 64;

  00212	8b 04 24	 mov	 eax, DWORD PTR exp$[rsp]
  00215	83 c0 40	 add	 eax, 64			; 00000040H
  00218	89 04 24	 mov	 DWORD PTR exp$[rsp], eax

; 938  : 
; 939  :         /* Pack the exponent and the fraction into the result */
; 940  :         r0 = (op->sign ? 1 << 31 : 0) | (exp << 24) | (fract >> 32);

  0021b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00220	83 38 00	 cmp	 DWORD PTR [rax], 0
  00223	74 0a		 je	 SHORT $LN29@cnvt_bfp_t
  00225	c7 44 24 30 00
	00 00 80	 mov	 DWORD PTR tv134[rsp], -2147483648 ; ffffffff80000000H
  0022d	eb 08		 jmp	 SHORT $LN30@cnvt_bfp_t
$LN29@cnvt_bfp_t:
  0022f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN30@cnvt_bfp_t:
  00237	8b 04 24	 mov	 eax, DWORD PTR exp$[rsp]
  0023a	c1 e0 18	 shl	 eax, 24
  0023d	8b 4c 24 30	 mov	 ecx, DWORD PTR tv134[rsp]
  00241	0b c8		 or	 ecx, eax
  00243	8b c1		 mov	 eax, ecx
  00245	48 98		 cdqe
  00247	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fract$[rsp]
  0024c	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  00250	48 0b c1	 or	 rax, rcx
  00253	89 44 24 04	 mov	 DWORD PTR r0$[rsp], eax

; 941  :         r1 = fract & 0xFFFFFFFF;

  00257	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0025c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fract$[rsp]
  00261	48 23 c8	 and	 rcx, rax
  00264	48 8b c1	 mov	 rax, rcx
  00267	89 44 24 08	 mov	 DWORD PTR r1$[rsp], eax

; 942  :         cc = op->sign ? 1 : 2;

  0026b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00270	83 38 00	 cmp	 DWORD PTR [rax], 0
  00273	74 0a		 je	 SHORT $LN31@cnvt_bfp_t
  00275	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  0027d	eb 08		 jmp	 SHORT $LN32@cnvt_bfp_t
$LN31@cnvt_bfp_t:
  0027f	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv145[rsp], 2
$LN32@cnvt_bfp_t:
  00287	8b 44 24 34	 mov	 eax, DWORD PTR tv145[rsp]
  0028b	89 44 24 0c	 mov	 DWORD PTR cc$[rsp], eax
$LN2@cnvt_bfp_t:

; 943  :         break;
; 944  :     }
; 945  :     /* Store high and low halves of result into fp register array
; 946  :        and return condition code */
; 947  :     fpr[0] = r0;

  0028f	b8 04 00 00 00	 mov	 eax, 4
  00294	48 6b c0 00	 imul	 rax, rax, 0
  00298	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fpr$[rsp]
  0029d	8b 54 24 04	 mov	 edx, DWORD PTR r0$[rsp]
  002a1	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 948  :     fpr[1] = r1;

  002a4	b8 04 00 00 00	 mov	 eax, 4
  002a9	48 6b c0 01	 imul	 rax, rax, 1
  002ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fpr$[rsp]
  002b2	8b 54 24 08	 mov	 edx, DWORD PTR r1$[rsp]
  002b6	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 949  :     return cc;

  002b9	8b 44 24 0c	 mov	 eax, DWORD PTR cc$[rsp]

; 950  : } /* end function cnvt_bfp_to_hfp */

  002bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002c1	c3		 ret	 0
cnvt_bfp_to_hfp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
s390_float32_signaling_compare PROC

; 689  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 690  :     if (FLOAT32_ISNAN( op1 ) ||

  0000c	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00010	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00015	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0001a	75 0d		 jne	 SHORT $LN4@s390_float
  0001c	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00020	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00025	85 c0		 test	 eax, eax
  00027	75 1d		 jne	 SHORT $LN3@s390_float
$LN4@s390_float:
  00029	8b 44 24 38	 mov	 eax, DWORD PTR op2$[rsp]
  0002d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00032	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00037	75 4e		 jne	 SHORT $LN2@s390_float
  00039	8b 44 24 38	 mov	 eax, DWORD PTR op2$[rsp]
  0003d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00042	85 c0		 test	 eax, eax
  00044	74 41		 je	 SHORT $LN2@s390_float
$LN3@s390_float:

; 691  :         FLOAT32_ISNAN( op2 ))
; 692  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00046	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0004b	8b c0		 mov	 eax, eax
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00053	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00060	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00064	83 c8 10	 or	 eax, 16
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0006d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00076	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0007c	45 8b c0	 mov	 r8d, r8d
  0007f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00083	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s390_float:

; 693  :     return ARCH_DEP( float32_cc_quiet )( op1, op2 );

  00087	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  0008f	e8 00 00 00 00	 call	 s390_float32_cc_quiet

; 694  : }

  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	c3		 ret	 0
s390_float32_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
s390_float32_compare PROC

; 681  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 682  :     if (f32_isSignalingNaN( op1 ) ||

  0000c	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00010	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	75 10		 jne	 SHORT $LN3@s390_float
  0001c	8b 4c 24 38	 mov	 ecx, DWORD PTR op2$[rsp]
  00020	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 41		 je	 SHORT $LN2@s390_float
$LN3@s390_float:

; 683  :         f32_isSignalingNaN( op2 ))
; 684  :         softfloat_raiseFlags( softfloat_flag_invalid );

  0002c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00031	8b c0		 mov	 eax, eax
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00039	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00042	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00046	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004a	83 c8 10	 or	 eax, 16
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00053	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005c	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00062	45 8b c0	 mov	 r8d, r8d
  00065	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00069	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s390_float:

; 685  :     return ARCH_DEP( float32_cc_quiet )( op1, op2 );

  0006d	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00071	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00075	e8 00 00 00 00	 call	 s390_float32_cc_quiet

; 686  : }

  0007a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007e	c3		 ret	 0
s390_float32_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv81 = 32
tv83 = 36
tv84 = 40
op1$ = 64
op2$ = 72
s390_float32_cc_quiet PROC

; 673  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 674  :     return FLOAT32_ISNAN( op1      ) ||

  0000c	8b 44 24 40	 mov	 eax, DWORD PTR op1$[rsp]
  00010	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00015	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0001a	75 0d		 jne	 SHORT $LN3@s390_float
  0001c	8b 44 24 40	 mov	 eax, DWORD PTR op1$[rsp]
  00020	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00025	85 c0		 test	 eax, eax
  00027	75 73		 jne	 SHORT $LN5@s390_float
$LN3@s390_float:
  00029	8b 44 24 48	 mov	 eax, DWORD PTR op2$[rsp]
  0002d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00032	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00037	75 0d		 jne	 SHORT $LN4@s390_float
  00039	8b 44 24 48	 mov	 eax, DWORD PTR op2$[rsp]
  0003d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00042	85 c0		 test	 eax, eax
  00044	75 56		 jne	 SHORT $LN5@s390_float
$LN4@s390_float:
  00046	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  0004a	8b 4c 24 40	 mov	 ecx, DWORD PTR op1$[rsp]
  0004e	e8 00 00 00 00	 call	 f32_eq
  00053	0f b6 c0	 movzx	 eax, al
  00056	85 c0		 test	 eax, eax
  00058	74 0a		 je	 SHORT $LN8@s390_float
  0005a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  00062	eb 2e		 jmp	 SHORT $LN9@s390_float
$LN8@s390_float:
  00064	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00068	8b 4c 24 40	 mov	 ecx, DWORD PTR op1$[rsp]
  0006c	e8 00 00 00 00	 call	 f32_lt_quiet
  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	74 0a		 je	 SHORT $LN6@s390_float
  00078	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00080	eb 08		 jmp	 SHORT $LN7@s390_float
$LN6@s390_float:
  00082	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv81[rsp], 2
$LN7@s390_float:
  0008a	8b 44 24 20	 mov	 eax, DWORD PTR tv81[rsp]
  0008e	89 44 24 24	 mov	 DWORD PTR tv83[rsp], eax
$LN9@s390_float:
  00092	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  00096	89 44 24 28	 mov	 DWORD PTR tv84[rsp], eax
  0009a	eb 08		 jmp	 SHORT $LN10@s390_float
$LN5@s390_float:
  0009c	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv84[rsp], 3
$LN10@s390_float:
  000a4	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv84[rsp]

; 675  :            FLOAT32_ISNAN(      op2 ) ? 3 :
; 676  :            f32_eq(        op1, op2 ) ? 0 :
; 677  :            f32_lt_quiet(  op1, op2 ) ? 1 : 2;
; 678  : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
s390_float32_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
s390_float64_signaling_compare PROC

; 665  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 666  :     if (FLOAT64_ISNAN( op1 ) ||

  0000e	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 23 c8	 and	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	75 1a		 jne	 SHORT $LN4@s390_float
  00032	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00041	48 23 c8	 and	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 85 c0	 test	 rax, rax
  0004a	75 3e		 jne	 SHORT $LN3@s390_float
$LN4@s390_float:
  0004c	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00056	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  0005b	48 23 c8	 and	 rcx, rax
  0005e	48 8b c1	 mov	 rax, rcx
  00061	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0006b	48 3b c1	 cmp	 rax, rcx
  0006e	75 5b		 jne	 SHORT $LN2@s390_float
  00070	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0007a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  0007f	48 23 c8	 and	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 85 c0	 test	 rax, rax
  00088	74 41		 je	 SHORT $LN2@s390_float
$LN3@s390_float:

; 667  :         FLOAT64_ISNAN( op2 ))
; 668  :         softfloat_raiseFlags( softfloat_flag_invalid );

  0008a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0008f	8b c0		 mov	 eax, eax
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00097	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000a0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a8	83 c8 10	 or	 eax, 16
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000ba	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  000c0	45 8b c0	 mov	 r8d, r8d
  000c3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000c7	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s390_float:

; 669  :     return ARCH_DEP( float64_cc_quiet )( op1, op2 );

  000cb	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  000d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  000d5	e8 00 00 00 00	 call	 s390_float64_cc_quiet

; 670  : }

  000da	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000de	c3		 ret	 0
s390_float64_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
s390_float64_compare PROC

; 657  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 658  :     if (f64_isSignalingNaN( op1 ) ||

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00013	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 11		 jne	 SHORT $LN3@s390_float
  0001f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  00024	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	74 41		 je	 SHORT $LN2@s390_float
$LN3@s390_float:

; 659  :         f64_isSignalingNaN( op2 ))
; 660  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00030	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00035	8b c0		 mov	 eax, eax
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00046	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0004a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004e	83 c8 10	 or	 eax, 16
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00057	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00060	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00066	45 8b c0	 mov	 r8d, r8d
  00069	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0006d	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s390_float:

; 661  :     return ARCH_DEP( float64_cc_quiet )( op1, op2 );

  00071	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  0007b	e8 00 00 00 00	 call	 s390_float64_cc_quiet

; 662  : }

  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	c3		 ret	 0
s390_float64_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv81 = 32
tv83 = 36
tv84 = 40
op1$ = 64
op2$ = 72
s390_float64_cc_quiet PROC

; 649  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 650  :     return FLOAT64_ISNAN( op1      ) ||

  0000e	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 23 c8	 and	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	75 1e		 jne	 SHORT $LN3@s390_float
  00032	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00041	48 23 c8	 and	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 85 c0	 test	 rax, rax
  0004a	0f 85 98 00 00
	00		 jne	 $LN5@s390_float
$LN3@s390_float:
  00050	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  0005f	48 23 c8	 and	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0006f	48 3b c1	 cmp	 rax, rcx
  00072	75 1a		 jne	 SHORT $LN4@s390_float
  00074	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0007e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00083	48 23 c8	 and	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	48 85 c0	 test	 rax, rax
  0008c	75 5a		 jne	 SHORT $LN5@s390_float
$LN4@s390_float:
  0008e	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00098	e8 00 00 00 00	 call	 f64_eq
  0009d	0f b6 c0	 movzx	 eax, al
  000a0	85 c0		 test	 eax, eax
  000a2	74 0a		 je	 SHORT $LN8@s390_float
  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000ac	eb 30		 jmp	 SHORT $LN9@s390_float
$LN8@s390_float:
  000ae	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  000b8	e8 00 00 00 00	 call	 f64_lt_quiet
  000bd	0f b6 c0	 movzx	 eax, al
  000c0	85 c0		 test	 eax, eax
  000c2	74 0a		 je	 SHORT $LN6@s390_float
  000c4	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  000cc	eb 08		 jmp	 SHORT $LN7@s390_float
$LN6@s390_float:
  000ce	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv81[rsp], 2
$LN7@s390_float:
  000d6	8b 44 24 20	 mov	 eax, DWORD PTR tv81[rsp]
  000da	89 44 24 24	 mov	 DWORD PTR tv83[rsp], eax
$LN9@s390_float:
  000de	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  000e2	89 44 24 28	 mov	 DWORD PTR tv84[rsp], eax
  000e6	eb 08		 jmp	 SHORT $LN10@s390_float
$LN5@s390_float:
  000e8	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv84[rsp], 3
$LN10@s390_float:
  000f0	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv84[rsp]

; 651  :            FLOAT64_ISNAN(      op2 ) ? 3 :
; 652  :            f64_eq(        op1, op2 ) ? 0 :
; 653  :            f64_lt_quiet(  op1, op2 ) ? 1 : 2;
; 654  : }

  000f5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f9	c3		 ret	 0
s390_float64_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
op1$ = 96
op2$ = 104
s390_float128_signaling_compare PROC

; 641  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 642  :     if (FLOAT128_ISNAN( op1 ) ||

  00010	b8 08 00 00 00	 mov	 eax, 8
  00015	48 6b c0 01	 imul	 rax, rax, 1
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  0001e	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  00028	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0002c	48 23 c2	 and	 rax, rdx
  0002f	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00039	48 3b c1	 cmp	 rax, rcx
  0003c	75 39		 jne	 SHORT $LN4@s390_float
  0003e	b8 08 00 00 00	 mov	 eax, 8
  00043	48 6b c0 01	 imul	 rax, rax, 1
  00047	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  0004c	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  00056	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0005a	48 23 c2	 and	 rax, rdx
  0005d	48 85 c0	 test	 rax, rax
  00060	75 7c		 jne	 SHORT $LN3@s390_float
  00062	b8 08 00 00 00	 mov	 eax, 8
  00067	48 6b c0 00	 imul	 rax, rax, 0
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  00070	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00075	75 67		 jne	 SHORT $LN3@s390_float
$LN4@s390_float:
  00077	b8 08 00 00 00	 mov	 eax, 8
  0007c	48 6b c0 01	 imul	 rax, rax, 1
  00080	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  00085	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  0008f	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00093	48 23 c2	 and	 rax, rdx
  00096	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  000a0	48 3b c1	 cmp	 rax, rcx
  000a3	75 7a		 jne	 SHORT $LN2@s390_float
  000a5	b8 08 00 00 00	 mov	 eax, 8
  000aa	48 6b c0 01	 imul	 rax, rax, 1
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  000b3	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  000bd	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000c1	48 23 c2	 and	 rax, rdx
  000c4	48 85 c0	 test	 rax, rax
  000c7	75 15		 jne	 SHORT $LN5@s390_float
  000c9	b8 08 00 00 00	 mov	 eax, 8
  000ce	48 6b c0 00	 imul	 rax, rax, 0
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  000d7	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000dc	74 41		 je	 SHORT $LN2@s390_float
$LN5@s390_float:
$LN3@s390_float:

; 643  :         FLOAT128_ISNAN( op2 ))
; 644  :         softfloat_raiseFlags( softfloat_flag_invalid );

  000de	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  000e3	8b c0		 mov	 eax, eax
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000eb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000f4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000f8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fc	83 c8 10	 or	 eax, 16
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00105	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0010e	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00114	45 8b c0	 mov	 r8d, r8d
  00117	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0011b	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s390_float:

; 645  :     return ARCH_DEP( float128_cc_quiet )( op1, op2 );

  0011f	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00124	48 8b f8	 mov	 rdi, rax
  00127	48 8b 74 24 68	 mov	 rsi, QWORD PTR op2$[rsp]
  0012c	b9 10 00 00 00	 mov	 ecx, 16
  00131	f3 a4		 rep movsb
  00133	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00138	48 8b f8	 mov	 rdi, rax
  0013b	48 8b 74 24 60	 mov	 rsi, QWORD PTR op1$[rsp]
  00140	b9 10 00 00 00	 mov	 ecx, 16
  00145	f3 a4		 rep movsb
  00147	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0014c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00151	e8 00 00 00 00	 call	 s390_float128_cc_quiet

; 646  : }

  00156	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015a	5f		 pop	 rdi
  0015b	5e		 pop	 rsi
  0015c	c3		 ret	 0
s390_float128_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
op1$ = 128
op2$ = 136
s390_float128_compare PROC

; 633  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 634  :     if (f128_isSignalingNaN( op1 ) ||

  00010	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00015	48 8b f8	 mov	 rdi, rax
  00018	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00020	b9 10 00 00 00	 mov	 ecx, 16
  00025	f3 a4		 rep movsb
  00027	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0002c	e8 00 00 00 00	 call	 f128_isSignalingNaN
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 28		 jne	 SHORT $LN3@s390_float
  00038	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0003d	48 8b f8	 mov	 rdi, rax
  00040	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  00048	b9 10 00 00 00	 mov	 ecx, 16
  0004d	f3 a4		 rep movsb
  0004f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00054	e8 00 00 00 00	 call	 f128_isSignalingNaN
  00059	0f b6 c0	 movzx	 eax, al
  0005c	85 c0		 test	 eax, eax
  0005e	74 3e		 je	 SHORT $LN2@s390_float
$LN3@s390_float:

; 635  :         f128_isSignalingNaN( op2 ))
; 636  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00060	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00065	8b c0		 mov	 eax, eax
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0006d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00076	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0007a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007e	83 c8 10	 or	 eax, 16
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00087	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00090	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00095	8b ff		 mov	 edi, edi
  00097	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0009b	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN2@s390_float:

; 637  :     return ARCH_DEP( float128_cc_quiet )( op1, op2 );

  0009e	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  000a3	48 8b f8	 mov	 rdi, rax
  000a6	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  000ae	b9 10 00 00 00	 mov	 ecx, 16
  000b3	f3 a4		 rep movsb
  000b5	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  000ba	48 8b f8	 mov	 rdi, rax
  000bd	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  000c5	b9 10 00 00 00	 mov	 ecx, 16
  000ca	f3 a4		 rep movsb
  000cc	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  000d1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  000d6	e8 00 00 00 00	 call	 s390_float128_cc_quiet

; 638  : }

  000db	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
s390_float128_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv133 = 32
tv135 = 36
tv136 = 40
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
op1$ = 144
op2$ = 152
s390_float128_cc_quiet PROC

; 625  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 626  :     return FLOAT128_ISNAN( op1      ) ||

  00010	b8 08 00 00 00	 mov	 eax, 8
  00015	48 6b c0 01	 imul	 rax, rax, 1
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  00021	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  0002b	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0002f	48 23 c2	 and	 rax, rdx
  00032	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	75 47		 jne	 SHORT $LN4@s390_float
  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	48 6b c0 01	 imul	 rax, rax, 1
  0004a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  00052	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  0005c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00060	48 23 c2	 and	 rax, rdx
  00063	48 85 c0	 test	 rax, rax
  00066	0f 85 4a 01 00
	00		 jne	 $LN3@s390_float
  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 00	 imul	 rax, rax, 0
  00075	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  0007d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00082	0f 85 2e 01 00
	00		 jne	 $LN3@s390_float
$LN4@s390_float:
  00088	b8 08 00 00 00	 mov	 eax, 8
  0008d	48 6b c0 01	 imul	 rax, rax, 1
  00091	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  00099	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  000a3	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a7	48 23 c2	 and	 rax, rdx
  000aa	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  000b4	48 3b c1	 cmp	 rax, rcx
  000b7	75 47		 jne	 SHORT $LN6@s390_float
  000b9	b8 08 00 00 00	 mov	 eax, 8
  000be	48 6b c0 01	 imul	 rax, rax, 1
  000c2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  000ca	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  000d4	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000d8	48 23 c2	 and	 rax, rdx
  000db	48 85 c0	 test	 rax, rax
  000de	0f 85 d2 00 00
	00		 jne	 $LN5@s390_float
  000e4	b8 08 00 00 00	 mov	 eax, 8
  000e9	48 6b c0 00	 imul	 rax, rax, 0
  000ed	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  000f5	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000fa	0f 85 b6 00 00
	00		 jne	 $LN3@s390_float
$LN6@s390_float:
  00100	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00105	48 8b f8	 mov	 rdi, rax
  00108	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  00110	b9 10 00 00 00	 mov	 ecx, 16
  00115	f3 a4		 rep movsb
  00117	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0011c	48 8b f8	 mov	 rdi, rax
  0011f	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00127	b9 10 00 00 00	 mov	 ecx, 16
  0012c	f3 a4		 rep movsb
  0012e	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00133	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00138	e8 00 00 00 00	 call	 f128_eq
  0013d	0f b6 c0	 movzx	 eax, al
  00140	85 c0		 test	 eax, eax
  00142	74 0a		 je	 SHORT $LN9@s390_float
  00144	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
  0014c	eb 5e		 jmp	 SHORT $LN10@s390_float
$LN9@s390_float:
  0014e	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00153	48 8b f8	 mov	 rdi, rax
  00156	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  0015e	b9 10 00 00 00	 mov	 ecx, 16
  00163	f3 a4		 rep movsb
  00165	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  0016a	48 8b f8	 mov	 rdi, rax
  0016d	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00175	b9 10 00 00 00	 mov	 ecx, 16
  0017a	f3 a4		 rep movsb
  0017c	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  00181	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  00186	e8 00 00 00 00	 call	 f128_lt_quiet
  0018b	0f b6 c0	 movzx	 eax, al
  0018e	85 c0		 test	 eax, eax
  00190	74 0a		 je	 SHORT $LN7@s390_float
  00192	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  0019a	eb 08		 jmp	 SHORT $LN8@s390_float
$LN7@s390_float:
  0019c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
$LN8@s390_float:
  001a4	8b 44 24 20	 mov	 eax, DWORD PTR tv133[rsp]
  001a8	89 44 24 24	 mov	 DWORD PTR tv135[rsp], eax
$LN10@s390_float:
  001ac	8b 44 24 24	 mov	 eax, DWORD PTR tv135[rsp]
  001b0	89 44 24 28	 mov	 DWORD PTR tv136[rsp], eax
  001b4	eb 08		 jmp	 SHORT $LN11@s390_float
$LN3@s390_float:
$LN5@s390_float:
  001b6	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv136[rsp], 3
$LN11@s390_float:
  001be	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv136[rsp]

; 627  :            FLOAT128_ISNAN(      op2 ) ? 3 :
; 628  :            f128_eq(        op1, op2 ) ? 0 :
; 629  :            f128_lt_quiet(  op1, op2 ) ? 1 : 2;
; 630  : }

  001c3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001c7	5f		 pop	 rdi
  001c8	5e		 pop	 rsi
  001c9	c3		 ret	 0
s390_float128_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s390_put_float32 PROC

; 584  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 585  :     *fpr = op->v;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR fpr$[rsp]
  0000f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00014	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00016	89 08		 mov	 DWORD PTR [rax], ecx

; 586  : }

  00018	c3		 ret	 0
s390_put_float32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s390_get_float32 PROC

; 579  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 580  :     op->v = *fpr;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00014	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00016	89 08		 mov	 DWORD PTR [rax], ecx

; 581  : }

  00018	c3		 ret	 0
s390_get_float32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s390_put_float64 PROC

; 573  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 574  :     fpr[0] = (U32) (op->v >> 32);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00016	b9 04 00 00 00	 mov	 ecx, 4
  0001b	48 6b c9 00	 imul	 rcx, rcx, 0
  0001f	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00024	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 575  :     fpr[1] = (U32) (op->v & 0xFFFFFFFF);

  00027	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0002c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 23 c1	 and	 rax, rcx
  00037	b9 04 00 00 00	 mov	 ecx, 4
  0003c	48 6b c9 01	 imul	 rcx, rcx, 1
  00040	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00045	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 576  : }

  00048	c3		 ret	 0
s390_put_float64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s390_get_float64 PROC

; 568  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 569  :     op->v = ((U64)fpr[0] << 32) | fpr[1];

  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	48 6b c0 00	 imul	 rax, rax, 0
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00018	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0001b	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	48 6b c9 01	 imul	 rcx, rcx, 1
  00028	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00030	48 0b c1	 or	 rax, rcx
  00033	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00038	48 89 01	 mov	 QWORD PTR [rcx], rax

; 570  : }

  0003b	c3		 ret	 0
s390_get_float64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s390_put_float128 PROC

; 560  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 561  :     fpr[0]       = (U32) (op->v[FLOAT128_HI] >> 32);

  0000a	b8 08 00 00 00	 mov	 eax, 8
  0000f	48 6b c0 01	 imul	 rax, rax, 1
  00013	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00018	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0001c	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00020	b9 04 00 00 00	 mov	 ecx, 4
  00025	48 6b c9 00	 imul	 rcx, rcx, 0
  00029	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002e	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 562  :     fpr[1]       = (U32) (op->v[FLOAT128_HI] & 0xFFFFFFFF);

  00031	b8 08 00 00 00	 mov	 eax, 8
  00036	48 6b c0 01	 imul	 rax, rax, 1
  0003a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  0003f	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00044	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00048	48 23 c2	 and	 rax, rdx
  0004b	b9 04 00 00 00	 mov	 ecx, 4
  00050	48 6b c9 01	 imul	 rcx, rcx, 1
  00054	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00059	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 563  :     fpr[FPREX]   = (U32) (op->v[FLOAT128_LO] >> 32);

  0005c	b8 08 00 00 00	 mov	 eax, 8
  00061	48 6b c0 00	 imul	 rax, rax, 0
  00065	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  0006a	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0006e	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00072	b9 04 00 00 00	 mov	 ecx, 4
  00077	48 6b c9 04	 imul	 rcx, rcx, 4
  0007b	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00080	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 564  :     fpr[FPREX+1] = (U32) (op->v[FLOAT128_LO] & 0xFFFFFFFF);

  00083	b8 08 00 00 00	 mov	 eax, 8
  00088	48 6b c0 00	 imul	 rax, rax, 0
  0008c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00091	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00096	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0009a	48 23 c2	 and	 rax, rdx
  0009d	b9 04 00 00 00	 mov	 ecx, 4
  000a2	48 6b c9 05	 imul	 rcx, rcx, 5
  000a6	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  000ab	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 565  : }

  000ae	c3		 ret	 0
s390_put_float128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s390_get_float128 PROC

; 553  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 554  :                                                       /* high order bits in v[1], low order in v[0]  */
; 555  :     op->v[FLOAT128_HI] = ((U64)fpr[0]     << 32) | fpr[1];               /* *****  Possible endian concern  ******* */

  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	48 6b c0 00	 imul	 rax, rax, 0
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00018	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0001b	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	48 6b c9 01	 imul	 rcx, rcx, 1
  00028	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00030	48 0b c1	 or	 rax, rcx
  00033	b9 08 00 00 00	 mov	 ecx, 8
  00038	48 6b c9 01	 imul	 rcx, rcx, 1
  0003c	48 8b 54 24 08	 mov	 rdx, QWORD PTR op$[rsp]
  00041	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 556  :     op->v[FLOAT128_LO] = ((U64)fpr[FPREX] << 32) | fpr[FPREX+1];

  00045	b8 04 00 00 00	 mov	 eax, 4
  0004a	48 6b c0 04	 imul	 rax, rax, 4
  0004e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00053	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00056	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0005a	b9 04 00 00 00	 mov	 ecx, 4
  0005f	48 6b c9 05	 imul	 rcx, rcx, 5
  00063	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00068	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0006b	48 0b c1	 or	 rax, rcx
  0006e	b9 08 00 00 00	 mov	 ecx, 8
  00073	48 6b c9 00	 imul	 rcx, rcx, 0
  00077	48 8b 54 24 08	 mov	 rdx, QWORD PTR op$[rsp]
  0007c	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 557  : }

  00080	c3		 ret	 0
s390_get_float128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
regs$ = 48
mask$ = 56
s390_BFP_RM_check PROC

; 534  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 535  : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 536  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 537  :     {
; 538  :         if (mask > 7 || !map_valid_m3_values_FPX[ (mask & 0x7) ]) 
; 539  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );
; 540  :     }
; 541  :     else
; 542  : #endif
; 543  :     {
; 544  :         if (mask > 7 || !map_valid_m3_values_NOFPX[ (mask & 0x7) ])

  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  00012	83 f8 07	 cmp	 eax, 7
  00015	7f 19		 jg	 SHORT $LN3@s390_BFP_R
  00017	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  0001c	83 e0 07	 and	 eax, 7
  0001f	48 98		 cdqe
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_valid_m3_values_NOFPX
  00028	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002c	85 c0		 test	 eax, eax
  0002e	75 15		 jne	 SHORT $LN2@s390_BFP_R
$LN3@s390_BFP_R:

; 545  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00030	ba 06 00 00 00	 mov	 edx, 6
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@s390_BFP_R:

; 546  :     }
; 547  : }

  00045	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00049	c3		 ret	 0
s390_BFP_RM_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0001a	3d f8 0f 00 00	 cmp	 eax, 4088		; 00000ff8H
  0001f	77 0a		 ja	 SHORT $LN6@s390_vfetc
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vfetc
$LN6@s390_vfetc:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@s390_vfetc:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00038	74 46		 je	 SHORT $LN2@s390_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00043	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00047	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0004f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00054	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00059	ba 08 00 00 00	 mov	 edx, 8
  0005e	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  0006c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00071	e8 00 00 00 00	 call	 fetch_dw_noswap
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 _byteswap_uint64
  0007e	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00080	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  00085	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  00089	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0008d	e8 00 00 00 00	 call	 s390_vfetch8_full
$LN1@s390_vfetc:

; 737  : }

  00092	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00096	c3		 ret	 0
s390_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  0005c	77 45		 ja	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 04 00 00 00	 mov	 edx, 4
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_fw_noswap
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 _byteswap_ulong
  000a1	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000a3	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a8	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ac	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b0	e8 00 00 00 00	 call	 s390_vfetch4_full
$LN1@s390_vfetc:

; 705  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
s390_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00029	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	2b c8		 sub	 ecx, eax
  00035	8b c1		 mov	 eax, ecx
  00037	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00040	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00050	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00058	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00060	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00068	48 8b d0	 mov	 rdx, rax
  0006b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00072	e8 00 00 00 00	 call	 s390_maddr_l
  00077	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  0007c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00081	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00086	48 8b f9	 mov	 rdi, rcx
  00089	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00093	b8 08 00 00 00	 mov	 eax, 8
  00098	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009c	48 98		 cdqe
  0009e	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a2	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000a9	03 d1		 add	 edx, ecx
  000ab	8b ca		 mov	 ecx, edx
  000ad	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b5	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000bb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c3	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c7	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000cb	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d3	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000db	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e3	48 8b d0	 mov	 rdx, rax
  000e6	e8 00 00 00 00	 call	 s390_maddr_l
  000eb	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000f0	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  000fa	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000fd	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  00102	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 fetch_dw_noswap
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  00114	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s390_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s390_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000af	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bb	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000c7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000cf	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000d4	48 8b d0	 mov	 rdx, rax
  000d7	e8 00 00 00 00	 call	 s390_maddr_l
  000dc	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000ea	48 98		 cdqe
  000ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000f1	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000f6	48 8b f9	 mov	 rdi, rcx
  000f9	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000fe	48 8b c8	 mov	 rcx, rax
  00101	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  00103	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00108	e8 00 00 00 00	 call	 fetch_fw_noswap
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 64
r2$ = 68
m3$ = 72
r1$ = 76
fract$ = 80
op1$ = 88
__$ArrayPad$ = 104
inst$ = 128
regs$ = 136
s390_convert_float_long_to_bfp_short_reg PROC

; 1172 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1173 :     int r1, r2, m3;
; 1174 :     struct sbfp op1;
; 1175 :     U64 fract;
; 1176 : 
; 1177 :     RRF_M(inst, regs, r1, r2, m3);

  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	83 e0 0f	 and	 eax, 15
  0003c	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00040	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	c1 e8 04	 shr	 eax, 4
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  0004e	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00052	c1 e8 0c	 shr	 eax, 12
  00055	83 e0 0f	 and	 eax, 15
  00058	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s390_conve:
  0005c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0f		 je	 SHORT $LN5@s390_conve
  0007f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  0008e	33 c0		 xor	 eax, eax
  00090	85 c0		 test	 eax, eax
  00092	75 c8		 jne	 SHORT $LN4@s390_conve

; 1178 :     TXFC_INSTR_CHECK( regs );
; 1179 :     //logmsg("TBEDR r1=%d r2=%d\n", r1, r2);
; 1180 :     HFPREG2_CHECK(r1, r2, regs);

  00094	b8 08 00 00 00	 mov	 eax, 8
  00099	48 6b c0 01	 imul	 rax, rax, 1
  0009d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ac	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b1	85 c0		 test	 eax, eax
  000b3	74 3f		 je	 SHORT $LN7@s390_conve
  000b5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c3	d1 e8		 shr	 eax, 1
  000c5	83 e0 01	 and	 eax, 1
  000c8	85 c0		 test	 eax, eax
  000ca	74 6b		 je	 SHORT $LN6@s390_conve
  000cc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000db	b9 08 00 00 00	 mov	 ecx, 8
  000e0	48 6b c9 01	 imul	 rcx, rcx, 1
  000e4	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000eb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f0	85 c0		 test	 eax, eax
  000f2	75 43		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  000f4	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  000f8	83 e0 09	 and	 eax, 9
  000fb	85 c0		 test	 eax, eax
  000fd	75 0b		 jne	 SHORT $LN9@s390_conve
  000ff	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00103	83 e0 09	 and	 eax, 9
  00106	85 c0		 test	 eax, eax
  00108	74 2d		 je	 SHORT $LN8@s390_conve
$LN9@s390_conve:
  0010a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00112	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0011c	ba 07 00 00 00	 mov	 edx, 7
  00121	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00129	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_conve:
$LN6@s390_conve:

; 1181 :     BFPRM_CHECK(m3,regs);

  00137	0f b6 54 24 48	 movzx	 edx, BYTE PTR m3$[rsp]
  0013c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 1182 : 
; 1183 :     regs->psw.cc =

  00149	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  0014d	d1 e0		 shl	 eax, 1
  0014f	48 98		 cdqe
  00151	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00161	48 8d 4c 24 50	 lea	 rcx, QWORD PTR fract$[rsp]
  00166	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0016b	48 8d 4c 24 5c	 lea	 rcx, QWORD PTR op1$[rsp+4]
  00170	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00175	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  0017a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017f	c7 44 24 20 7f
	00 00 00	 mov	 DWORD PTR [rsp+32], 127	; 0000007fH
  00187	41 b9 7f 00 00
	00		 mov	 r9d, 127		; 0000007fH
  0018d	41 b8 17 00 00
	00		 mov	 r8d, 23
  00193	8b 54 24 48	 mov	 edx, DWORD PTR m3$[rsp]
  00197	48 8b c8	 mov	 rcx, rax
  0019a	e8 00 00 00 00	 call	 cnvt_hfp_to_bfp
  0019f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1184 :         cnvt_hfp_to_bfp (regs->fpr + FPR2I(r2), m3,
; 1185 :             /*fractbits*/23, /*emax*/127, /*ebias*/127,
; 1186 :             &(op1.sign), &(op1.exp), &fract);
; 1187 :     op1.fract = (U32)fract;

  001aa	8b 44 24 50	 mov	 eax, DWORD PTR fract$[rsp]
  001ae	89 44 24 60	 mov	 DWORD PTR op1$[rsp+8], eax

; 1188 : 
; 1189 :     put_sbfp(&op1, regs->fpr + FPR2I(r1));

  001b2	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  001b6	d1 e0		 shl	 eax, 1
  001b8	48 98		 cdqe
  001ba	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001ca	48 8b d0	 mov	 rdx, rax
  001cd	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  001d2	e8 00 00 00 00	 call	 put_sbfp

; 1190 : 
; 1191 : } /* end DEF_INST(convert_float_long_to_bfp_short_reg) */

  001d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001dc	48 33 cc	 xor	 rcx, rsp
  001df	e8 00 00 00 00	 call	 __security_check_cookie
  001e4	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001e8	c3		 ret	 0
s390_convert_float_long_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
temp$1 = 64
r2$ = 68
m3$ = 72
r1$ = 76
op1$ = 80
__$ArrayPad$ = 104
inst$ = 128
regs$ = 136
s390_convert_float_long_to_bfp_long_reg PROC

; 1149 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1150 :     int r1, r2, m3;
; 1151 :     struct lbfp op1;
; 1152 : 
; 1153 :     RRF_M(inst, regs, r1, r2, m3);

  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	83 e0 0f	 and	 eax, 15
  0003c	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00040	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	c1 e8 04	 shr	 eax, 4
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  0004e	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00052	c1 e8 0c	 shr	 eax, 12
  00055	83 e0 0f	 and	 eax, 15
  00058	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s390_conve:
  0005c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0f		 je	 SHORT $LN5@s390_conve
  0007f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  0008e	33 c0		 xor	 eax, eax
  00090	85 c0		 test	 eax, eax
  00092	75 c8		 jne	 SHORT $LN4@s390_conve

; 1154 :     TXFC_INSTR_CHECK( regs );
; 1155 :     //logmsg("TBDR r1=%d r2=%d\n", r1, r2);
; 1156 :     HFPREG2_CHECK(r1, r2, regs);

  00094	b8 08 00 00 00	 mov	 eax, 8
  00099	48 6b c0 01	 imul	 rax, rax, 1
  0009d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ac	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b1	85 c0		 test	 eax, eax
  000b3	74 3f		 je	 SHORT $LN7@s390_conve
  000b5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c3	d1 e8		 shr	 eax, 1
  000c5	83 e0 01	 and	 eax, 1
  000c8	85 c0		 test	 eax, eax
  000ca	74 6b		 je	 SHORT $LN6@s390_conve
  000cc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000db	b9 08 00 00 00	 mov	 ecx, 8
  000e0	48 6b c9 01	 imul	 rcx, rcx, 1
  000e4	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000eb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f0	85 c0		 test	 eax, eax
  000f2	75 43		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  000f4	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  000f8	83 e0 09	 and	 eax, 9
  000fb	85 c0		 test	 eax, eax
  000fd	75 0b		 jne	 SHORT $LN9@s390_conve
  000ff	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00103	83 e0 09	 and	 eax, 9
  00106	85 c0		 test	 eax, eax
  00108	74 2d		 je	 SHORT $LN8@s390_conve
$LN9@s390_conve:
  0010a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00112	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0011c	ba 07 00 00 00	 mov	 edx, 7
  00121	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00129	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_conve:
$LN6@s390_conve:

; 1157 :     BFPRM_CHECK(m3,regs);

  00137	0f b6 54 24 48	 movzx	 edx, BYTE PTR m3$[rsp]
  0013c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 1158 : 
; 1159 :     regs->psw.cc =

  00149	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  0014d	d1 e0		 shl	 eax, 1
  0014f	48 98		 cdqe
  00151	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00161	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp+8]
  00166	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0016b	48 8d 4c 24 54	 lea	 rcx, QWORD PTR op1$[rsp+4]
  00170	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00175	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0017a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017f	c7 44 24 20 ff
	03 00 00	 mov	 DWORD PTR [rsp+32], 1023 ; 000003ffH
  00187	41 b9 ff 03 00
	00		 mov	 r9d, 1023		; 000003ffH
  0018d	41 b8 34 00 00
	00		 mov	 r8d, 52			; 00000034H
  00193	8b 54 24 48	 mov	 edx, DWORD PTR m3$[rsp]
  00197	48 8b c8	 mov	 rcx, rax
  0019a	e8 00 00 00 00	 call	 cnvt_hfp_to_bfp
  0019f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1160 :         cnvt_hfp_to_bfp (regs->fpr + FPR2I(r2), m3,
; 1161 :             /*fractbits*/52, /*emax*/1023, /*ebias*/1023,
; 1162 :             &(op1.sign), &(op1.exp), &(op1.fract));
; 1163 : 
; 1164 :     put_lbfp(&op1, regs->fpr + FPR2I(r1));

  001aa	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  001ae	d1 e0		 shl	 eax, 1
  001b0	48 98		 cdqe
  001b2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ba	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001c2	48 8b d0	 mov	 rdx, rax
  001c5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  001ca	e8 00 00 00 00	 call	 put_lbfp

; 1165 : 
; 1166 : } /* end DEF_INST(convert_float_long_to_bfp_long_reg) */

  001cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d4	48 33 cc	 xor	 rcx, rsp
  001d7	e8 00 00 00 00	 call	 __security_check_cookie
  001dc	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001e0	c3		 ret	 0
s390_convert_float_long_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv150 = 48
op2$ = 56
lbfp_op2$ = 72
__$ArrayPad$ = 96
inst$ = 128
regs$ = 136
s390_convert_bfp_short_to_float_long_reg PROC

; 1119 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1120 :     int r1, r2;
; 1121 :     struct sbfp op2;
; 1122 :     struct lbfp lbfp_op2;
; 1123 : 
; 1124 :     RRE(inst, regs, r1, r2);

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00032	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00036	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00041	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00045	c1 f8 04	 sar	 eax, 4
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_conve:
  0004f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00067	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006b	33 c0		 xor	 eax, eax
  0006d	83 f8 04	 cmp	 eax, 4
  00070	74 0f		 je	 SHORT $LN5@s390_conve
  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 c8		 jne	 SHORT $LN4@s390_conve

; 1125 :     TXFC_INSTR_CHECK( regs );
; 1126 :     //logmsg("THDER r1=%d r2=%d\n", r1, r2);
; 1127 :     HFPREG2_CHECK(r1, r2, regs);

  00087	b8 08 00 00 00	 mov	 eax, 8
  0008c	48 6b c0 01	 imul	 rax, rax, 1
  00090	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0009f	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a4	85 c0		 test	 eax, eax
  000a6	74 3f		 je	 SHORT $LN7@s390_conve
  000a8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b6	d1 e8		 shr	 eax, 1
  000b8	83 e0 01	 and	 eax, 1
  000bb	85 c0		 test	 eax, eax
  000bd	74 6b		 je	 SHORT $LN6@s390_conve
  000bf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ce	b9 08 00 00 00	 mov	 ecx, 8
  000d3	48 6b c9 01	 imul	 rcx, rcx, 1
  000d7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000de	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e3	85 c0		 test	 eax, eax
  000e5	75 43		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	83 e0 09	 and	 eax, 9
  000ee	85 c0		 test	 eax, eax
  000f0	75 0b		 jne	 SHORT $LN9@s390_conve
  000f2	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  000f6	83 e0 09	 and	 eax, 9
  000f9	85 c0		 test	 eax, eax
  000fb	74 2d		 je	 SHORT $LN8@s390_conve
$LN9@s390_conve:
  000fd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00105	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0010f	ba 07 00 00 00	 mov	 edx, 7
  00114	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_conve:
$LN6@s390_conve:

; 1128 : 
; 1129 :     /* Load sbfp operand from R2 register */
; 1130 :     get_sbfp(&op2, regs->fpr + FPR2I(r2));

  0012a	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  0012e	d1 e0		 shl	 eax, 1
  00130	48 98		 cdqe
  00132	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00142	48 8b d0	 mov	 rdx, rax
  00145	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  0014a	e8 00 00 00 00	 call	 get_sbfp

; 1131 : 
; 1132 :     /* Lengthen sbfp operand to lbfp */
; 1133 :     lbfp_op2.sign = op2.sign;

  0014f	8b 44 24 38	 mov	 eax, DWORD PTR op2$[rsp]
  00153	89 44 24 48	 mov	 DWORD PTR lbfp_op2$[rsp], eax

; 1134 :     lbfp_op2.exp = op2.exp - 127 + 1023;

  00157	8b 44 24 3c	 mov	 eax, DWORD PTR op2$[rsp+4]
  0015b	05 80 03 00 00	 add	 eax, 896		; 00000380H
  00160	89 44 24 4c	 mov	 DWORD PTR lbfp_op2$[rsp+4], eax

; 1135 :     lbfp_op2.fract = (U64)op2.fract << (52 - 23);

  00164	48 63 44 24 40	 movsxd	 rax, DWORD PTR op2$[rsp+8]
  00169	48 c1 e0 1d	 shl	 rax, 29
  0016d	48 89 44 24 50	 mov	 QWORD PTR lbfp_op2$[rsp+8], rax

; 1136 : 
; 1137 :     /* Convert lbfp to hfp register and set condition code */
; 1138 :     regs->psw.cc =

  00172	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00176	d1 e0		 shl	 eax, 1
  00178	48 98		 cdqe
  0017a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0018a	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
  0018f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  00194	e8 00 00 00 00	 call	 sbfpclassify
  00199	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv150[rsp]
  0019e	4c 8b c1	 mov	 r8, rcx
  001a1	8b d0		 mov	 edx, eax
  001a3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR lbfp_op2$[rsp]
  001a8	e8 00 00 00 00	 call	 cnvt_bfp_to_hfp
  001ad	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1139 :         cnvt_bfp_to_hfp (&lbfp_op2,
; 1140 :                          sbfpclassify(&op2),
; 1141 :                          regs->fpr + FPR2I(r1));
; 1142 : 
; 1143 : } /* end DEF_INST(convert_bfp_short_to_float_long_reg) */

  001b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bd	48 33 cc	 xor	 rcx, rsp
  001c0	e8 00 00 00 00	 call	 __security_check_cookie
  001c5	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001c9	c3		 ret	 0
s390_convert_bfp_short_to_float_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv146 = 48
op2$ = 56
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
s390_convert_bfp_long_to_float_long_reg PROC

; 1094 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1095 :     int r1, r2;
; 1096 :     struct lbfp op2;
; 1097 : 
; 1098 :     RRE(inst, regs, r1, r2);

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_conve:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN5@s390_conve
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@s390_conve

; 1099 :     TXFC_INSTR_CHECK( regs );
; 1100 :     //logmsg("THDR r1=%d r2=%d\n", r1, r2);
; 1101 :     HFPREG2_CHECK(r1, r2, regs);

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00090	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00095	85 c0		 test	 eax, eax
  00097	74 39		 je	 SHORT $LN7@s390_conve
  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a4	d1 e8		 shr	 eax, 1
  000a6	83 e0 01	 and	 eax, 1
  000a9	85 c0		 test	 eax, eax
  000ab	74 5f		 je	 SHORT $LN6@s390_conve
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b9	b9 08 00 00 00	 mov	 ecx, 8
  000be	48 6b c9 01	 imul	 rcx, rcx, 1
  000c2	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ce	85 c0		 test	 eax, eax
  000d0	75 3a		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  000d2	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000d6	83 e0 09	 and	 eax, 9
  000d9	85 c0		 test	 eax, eax
  000db	75 0b		 jne	 SHORT $LN9@s390_conve
  000dd	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  000e1	83 e0 09	 and	 eax, 9
  000e4	85 c0		 test	 eax, eax
  000e6	74 24		 je	 SHORT $LN8@s390_conve
$LN9@s390_conve:
  000e8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  000f7	ba 07 00 00 00	 mov	 edx, 7
  000fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00106	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_conve:
$LN6@s390_conve:

; 1102 : 
; 1103 :     /* Load lbfp operand from R2 register */
; 1104 :     get_lbfp(&op2, regs->fpr + FPR2I(r2));

  0010c	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00110	d1 e0		 shl	 eax, 1
  00112	48 98		 cdqe
  00114	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00121	48 8b d0	 mov	 rdx, rax
  00124	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  00129	e8 00 00 00 00	 call	 get_lbfp

; 1105 : 
; 1106 :     /* Convert to hfp register and set condition code */
; 1107 :     regs->psw.cc =

  0012e	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00132	d1 e0		 shl	 eax, 1
  00134	48 98		 cdqe
  00136	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00143	48 89 44 24 30	 mov	 QWORD PTR tv146[rsp], rax
  00148	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  0014d	e8 00 00 00 00	 call	 lbfpclassify
  00152	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv146[rsp]
  00157	4c 8b c1	 mov	 r8, rcx
  0015a	8b d0		 mov	 edx, eax
  0015c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  00161	e8 00 00 00 00	 call	 cnvt_bfp_to_hfp
  00166	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1108 :         cnvt_bfp_to_hfp (&op2,
; 1109 :                          lbfpclassify(&op2),
; 1110 :                          regs->fpr + FPR2I(r1));
; 1111 : 
; 1112 : } /* end DEF_INST(convert_bfp_long_to_float_long_reg) */

  0016e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00173	48 33 cc	 xor	 rcx, rsp
  00176	e8 00 00 00 00	 call	 __security_check_cookie
  0017b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017f	c3		 ret	 0
s390_convert_bfp_long_to_float_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
tv162 = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s390_test_data_class_bfp_short PROC

; 5027 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5028 :     int        r1, x2, b2;
; 5029 :     VADR       effective_addr2;
; 5030 :     float32_t  op1;
; 5031 : 
; 5032 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s390_test_
  00053	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_test_:
  00070	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s390_test_
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_test_:
  000a2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b1	23 c8		 and	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_test_:
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 83 c0 06	 add	 rax, 6
  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cf	33 c0		 xor	 eax, eax
  000d1	83 f8 06	 cmp	 eax, 6
  000d4	74 0c		 je	 SHORT $LN7@s390_test_
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_test_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 d1		 jne	 SHORT $LN4@s390_test_

; 5033 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5034 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00102	85 c0		 test	 eax, eax
  00104	74 39		 je	 SHORT $LN9@s390_test_
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 49		 je	 SHORT $LN8@s390_test_
  0011a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00126	b9 08 00 00 00	 mov	 ecx, 8
  0012b	48 6b c9 01	 imul	 rcx, rcx, 1
  0012f	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00136	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 24		 jne	 SHORT $LN8@s390_test_
$LN9@s390_test_:
  0013f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014e	ba 07 00 00 00	 mov	 edx, 7
  00153	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_test_:

; 5035 : 
; 5036 :     GET_FLOAT32_OP( op1, r1, regs );

  00163	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00167	d1 e0		 shl	 eax, 1
  00169	48 98		 cdqe
  0016b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00178	48 8b d0	 mov	 rdx, rax
  0017b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00180	e8 00 00 00 00	 call	 s390_get_float32

; 5037 : 
; 5038 :     regs->psw.cc = !!(((U32)effective_addr2) & float32_class( op1 ));

  00185	8b 4c 24 38	 mov	 ecx, DWORD PTR op1$[rsp]
  00189	e8 00 00 00 00	 call	 float32_class
  0018e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00192	23 c8		 and	 ecx, eax
  00194	8b c1		 mov	 eax, ecx
  00196	85 c0		 test	 eax, eax
  00198	74 0a		 je	 SHORT $LN11@s390_test_
  0019a	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv162[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN12@s390_test_
$LN11@s390_test_:
  001a4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN12@s390_test_:
  001ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001b1	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv162[rsp]
  001b6	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5039 : }

  001b9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001bd	c3		 ret	 0
s390_test_data_class_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
tv162 = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s390_test_data_class_bfp_long PROC

; 5046 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5047 :     int        r1, x2, b2;
; 5048 :     VADR       effective_addr2;
; 5049 :     float64_t  op1;
; 5050 : 
; 5051 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s390_test_
  00053	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_test_:
  00070	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s390_test_
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_test_:
  000a2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b1	23 c8		 and	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_test_:
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 83 c0 06	 add	 rax, 6
  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cf	33 c0		 xor	 eax, eax
  000d1	83 f8 06	 cmp	 eax, 6
  000d4	74 0c		 je	 SHORT $LN7@s390_test_
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_test_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 d1		 jne	 SHORT $LN4@s390_test_

; 5052 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5053 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00102	85 c0		 test	 eax, eax
  00104	74 39		 je	 SHORT $LN9@s390_test_
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 49		 je	 SHORT $LN8@s390_test_
  0011a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00126	b9 08 00 00 00	 mov	 ecx, 8
  0012b	48 6b c9 01	 imul	 rcx, rcx, 1
  0012f	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00136	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 24		 jne	 SHORT $LN8@s390_test_
$LN9@s390_test_:
  0013f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014e	ba 07 00 00 00	 mov	 edx, 7
  00153	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_test_:

; 5054 : 
; 5055 :     GET_FLOAT64_OP( op1, r1, regs );

  00163	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00167	d1 e0		 shl	 eax, 1
  00169	48 98		 cdqe
  0016b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00178	48 8b d0	 mov	 rdx, rax
  0017b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00180	e8 00 00 00 00	 call	 s390_get_float64

; 5056 : 
; 5057 :     regs->psw.cc = !!(((U32)effective_addr2) & float64_class( op1 ));

  00185	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op1$[rsp]
  0018a	e8 00 00 00 00	 call	 float64_class
  0018f	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00193	23 c8		 and	 ecx, eax
  00195	8b c1		 mov	 eax, ecx
  00197	85 c0		 test	 eax, eax
  00199	74 0a		 je	 SHORT $LN11@s390_test_
  0019b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv162[rsp], 1
  001a3	eb 08		 jmp	 SHORT $LN12@s390_test_
$LN11@s390_test_:
  001a5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN12@s390_test_:
  001ad	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001b2	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv162[rsp]
  001b7	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5058 : }

  001ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001be	c3		 ret	 0
s390_test_data_class_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r1$ = 48
tv167 = 52
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
s390_test_data_class_bfp_ext PROC

; 5065 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5066 :     int         r1, x2, b2;
; 5067 :     VADR        effective_addr2;
; 5068 :     float128_t  op1;
; 5069 : 
; 5070 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 10	 shr	 eax, 16
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 14	 shr	 eax, 20
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00060	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00065	74 20		 je	 SHORT $LN5@s390_test_
  00067	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_test_:
  00087	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 0c	 shr	 eax, 12
  0008e	83 e0 0f	 and	 eax, 15
  00091	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00095	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009a	74 20		 je	 SHORT $LN6@s390_test_
  0009c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b4	03 c8		 add	 ecx, eax
  000b6	8b c1		 mov	 eax, ecx
  000b8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_test_:
  000bc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ca	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ce	23 c8		 and	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_test_:
  000d6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e2	48 83 c0 06	 add	 rax, 6
  000e6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f2	33 c0		 xor	 eax, eax
  000f4	83 f8 06	 cmp	 eax, 6
  000f7	74 0f		 je	 SHORT $LN7@s390_test_
  000f9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00101	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_test_:
  00108	33 c0		 xor	 eax, eax
  0010a	85 c0		 test	 eax, eax
  0010c	75 c8		 jne	 SHORT $LN4@s390_test_

; 5071 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5072 :     BFPINST_CHECK( regs );

  0010e	b8 08 00 00 00	 mov	 eax, 8
  00113	48 6b c0 01	 imul	 rax, rax, 1
  00117	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00126	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0012b	85 c0		 test	 eax, eax
  0012d	74 3f		 je	 SHORT $LN9@s390_test_
  0012f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0013d	d1 e8		 shr	 eax, 1
  0013f	83 e0 01	 and	 eax, 1
  00142	85 c0		 test	 eax, eax
  00144	74 55		 je	 SHORT $LN8@s390_test_
  00146	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00155	b9 08 00 00 00	 mov	 ecx, 8
  0015a	48 6b c9 01	 imul	 rcx, rcx, 1
  0015e	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00165	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0016a	85 c0		 test	 eax, eax
  0016c	75 2d		 jne	 SHORT $LN8@s390_test_
$LN9@s390_test_:
  0016e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00176	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00180	ba 07 00 00 00	 mov	 edx, 7
  00185	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_test_:

; 5073 :     BFPREGPAIR_CHECK( r1, regs );

  0019b	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0019f	83 e0 02	 and	 eax, 2
  001a2	85 c0		 test	 eax, eax
  001a4	74 1b		 je	 SHORT $LN10@s390_test_
  001a6	ba 06 00 00 00	 mov	 edx, 6
  001ab	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s390_test_:

; 5074 : 
; 5075 :     GET_FLOAT128_OP( op1, r1, regs );

  001c1	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001c5	d1 e0		 shl	 eax, 1
  001c7	48 98		 cdqe
  001c9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d1	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d9	48 8b d0	 mov	 rdx, rax
  001dc	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  001e1	e8 00 00 00 00	 call	 s390_get_float128

; 5076 : 
; 5077 :     regs->psw.cc = !!(((U32)effective_addr2) & float128_class( op1 ));

  001e6	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  001eb	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  001f0	48 8b f8	 mov	 rdi, rax
  001f3	48 8b f1	 mov	 rsi, rcx
  001f6	b9 10 00 00 00	 mov	 ecx, 16
  001fb	f3 a4		 rep movsb
  001fd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00202	e8 00 00 00 00	 call	 float128_class
  00207	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0020b	23 c8		 and	 ecx, eax
  0020d	8b c1		 mov	 eax, ecx
  0020f	85 c0		 test	 eax, eax
  00211	74 0a		 je	 SHORT $LN12@s390_test_
  00213	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  0021b	eb 08		 jmp	 SHORT $LN13@s390_test_
$LN12@s390_test_:
  0021d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN13@s390_test_:
  00225	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv167[rsp]
  00232	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5078 : }

  00235	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023a	48 33 cc	 xor	 rcx, rsp
  0023d	e8 00 00 00 00	 call	 __security_check_cookie
  00242	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00246	5f		 pop	 rdi
  00247	5e		 pop	 rsi
  00248	c3		 ret	 0
s390_test_data_class_bfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ans$ = 32
ieee_trap_conds$ = 36
i$1 = 40
tv194 = 44
r1$ = 48
tv210 = 52
tv213 = 56
tv215 = 60
tv216 = 64
r2$ = 68
op2$ = 72
op1$ = 76
inst$ = 96
regs$ = 104
s390_subtract_bfp_short_reg PROC

; 4949 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4950 :     int        r1, r2;
; 4951 :     float32_t  op1, op2, ans;
; 4952 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4953 : 
; 4954 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_subtr:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@s390_subtr
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s390_subtr:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_subtr

; 4955 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4956 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN13@s390_subtr
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN12@s390_subtr
  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN12@s390_subtr
$LN13@s390_subtr:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_subtr:
$LN7@s390_subtr:

; 4957 : 
; 4958 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float32
  00111	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s390_get_float32
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s390_subtr

; 4959 : 
; 4960 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4961 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4962 : 
; 4963 :     ans = f32_sub( op1, op2 );

  00191	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00195	8b 4c 24 4c	 mov	 ecx, DWORD PTR op1$[rsp]
  00199	e8 00 00 00 00	 call	 f32_sub
  0019e	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax

; 4964 : 
; 4965 :     if (softfloat_exceptionFlags)

  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a7	8b c0		 mov	 eax, eax
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 93 00 00
	00		 je	 $LN14@s390_subtr

; 4966 :     {
; 4967 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001c8	33 c0		 xor	 eax, eax
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	74 45		 je	 SHORT $LN15@s390_subtr
  001cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d4	8b c0		 mov	 eax, eax
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	83 e0 10	 and	 eax, 16
  001f0	85 c0		 test	 eax, eax
  001f2	74 20		 je	 SHORT $LN15@s390_subtr
  001f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ff	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00204	85 c0		 test	 eax, eax
  00206	74 0c		 je	 SHORT $LN15@s390_subtr
  00208	b2 80		 mov	 dl, 128			; 00000080H
  0020a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	e8 00 00 00 00	 call	 ieee_trap
$LN15@s390_subtr:

; 4968 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00214	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0021e	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4969 : 
; 4970 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00222	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00226	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022b	85 c0		 test	 eax, eax
  0022d	74 2c		 je	 SHORT $LN16@s390_subtr

; 4971 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0022f	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00233	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN19@s390_subtr
  0023c	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv194[rsp], -192 ; ffffffffffffff40H
  00244	eb 08		 jmp	 SHORT $LN20@s390_subtr
$LN19@s390_subtr:
  00246	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv194[rsp], 192 ; 000000c0H
$LN20@s390_subtr:
  0024e	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv194[rsp]
  00252	e8 00 00 00 00	 call	 f32_scaledResult
  00257	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax
$LN16@s390_subtr:
$LN14@s390_subtr:
$LN10@s390_subtr:

; 4972 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4973 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4974 :     }
; 4975 : 
; 4976 :     PUT_FLOAT32_CC( ans, r1, regs );

  0025b	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0025f	d1 e0		 shl	 eax, 1
  00261	48 98		 cdqe
  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00270	48 8b d0	 mov	 rdx, rax
  00273	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ans$[rsp]
  00278	e8 00 00 00 00	 call	 s390_put_float32
  0027d	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00281	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00286	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0028b	75 17		 jne	 SHORT $LN21@s390_subtr
  0028d	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00291	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00296	85 c0		 test	 eax, eax
  00298	74 0a		 je	 SHORT $LN21@s390_subtr
  0029a	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv216[rsp], 3
  002a2	eb 5e		 jmp	 SHORT $LN28@s390_subtr
$LN21@s390_subtr:
  002a4	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  002a8	0f ba f0 1f	 btr	 eax, 31
  002ac	85 c0		 test	 eax, eax
  002ae	75 0a		 jne	 SHORT $LN22@s390_subtr
  002b0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  002b8	eb 08		 jmp	 SHORT $LN23@s390_subtr
$LN22@s390_subtr:
  002ba	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN23@s390_subtr:
  002c2	83 7c 24 34 00	 cmp	 DWORD PTR tv210[rsp], 0
  002c7	74 0a		 je	 SHORT $LN26@s390_subtr
  002c9	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  002d1	eb 27		 jmp	 SHORT $LN27@s390_subtr
$LN26@s390_subtr:
  002d3	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  002d7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002dc	85 c0		 test	 eax, eax
  002de	74 0a		 je	 SHORT $LN24@s390_subtr
  002e0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  002e8	eb 08		 jmp	 SHORT $LN25@s390_subtr
$LN24@s390_subtr:
  002ea	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv213[rsp], 2
$LN25@s390_subtr:
  002f2	8b 44 24 38	 mov	 eax, DWORD PTR tv213[rsp]
  002f6	89 44 24 3c	 mov	 DWORD PTR tv215[rsp], eax
$LN27@s390_subtr:
  002fa	8b 44 24 3c	 mov	 eax, DWORD PTR tv215[rsp]
  002fe	89 44 24 40	 mov	 DWORD PTR tv216[rsp], eax
$LN28@s390_subtr:
  00302	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00307	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv216[rsp]
  0030c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0030f	33 c0		 xor	 eax, eax
  00311	85 c0		 test	 eax, eax
  00313	0f 85 42 ff ff
	ff		 jne	 $LN10@s390_subtr

; 4977 : 
; 4978 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00319	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0031d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00322	85 c0		 test	 eax, eax
  00324	74 0e		 je	 SHORT $LN17@s390_subtr
  00326	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0032a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0032f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s390_subtr:

; 4979 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4980 : }

  00334	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00338	c3		 ret	 0
s390_subtract_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ans$ = 36
ieee_trap_conds$ = 40
temp$1 = 44
b2$ = 48
x2$ = 52
tv211 = 56
r1$ = 60
tv227 = 64
tv230 = 68
tv232 = 72
tv233 = 76
op2$ = 80
op1$ = 84
inst$ = 112
regs$ = 120
s390_subtract_bfp_short PROC

; 4986 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4987 :     int        r1, x2, b2;
; 4988 :     VADR       effective_addr2;
; 4989 :     float32_t  op1, op2, ans;
; 4990 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4991 : 
; 4992 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 34 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN8@s390_subtr
  0005b	48 63 44 24 34	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s390_subtr:
  00078	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN9@s390_subtr
  0008d	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_subtr:
  000aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_subtr:
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ca	48 83 c0 06	 add	 rax, 6
  000ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 06	 cmp	 eax, 6
  000dc	74 0c		 je	 SHORT $LN10@s390_subtr
  000de	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_subtr:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 d1		 jne	 SHORT $LN4@s390_subtr

; 4993 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4994 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4995 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00105	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $LN12@s390_subtr
  0010e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00113	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00119	d1 e8		 shr	 eax, 1
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 49		 je	 SHORT $LN11@s390_subtr
  00122	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	48 6b c9 01	 imul	 rcx, rcx, 1
  00137	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0013e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN11@s390_subtr
$LN12@s390_subtr:
  00147	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00156	ba 07 00 00 00	 mov	 edx, 7
  0015b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00165	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_subtr:

; 4996 : 
; 4997 :     GET_FLOAT32_OP( op1, r1, regs );

  0016b	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0016f	d1 e0		 shl	 eax, 1
  00171	48 98		 cdqe
  00173	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00180	48 8b d0	 mov	 rdx, rax
  00183	48 8d 4c 24 54	 lea	 rcx, QWORD PTR op1$[rsp]
  00188	e8 00 00 00 00	 call	 s390_get_float32

; 4998 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0018d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00192	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  00196	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019a	e8 00 00 00 00	 call	 s390_vfetch4
  0019f	89 44 24 50	 mov	 DWORD PTR op2$[rsp], eax

; 4999 : 
; 5000 :     softfloat_exceptionFlags = 0;

  001a3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a8	8b c0		 mov	 eax, eax
  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5001 :     SET_SF_RM_FROM_FPC;

  001c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cc	83 e0 07	 and	 eax, 7
  001cf	8b c0		 mov	 eax, eax
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001dd	8b d2		 mov	 edx, edx
  001df	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001e6	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001ef	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f7	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5002 : 
; 5003 :     ans = f32_sub( op1, op2 );

  001fb	8b 54 24 50	 mov	 edx, DWORD PTR op2$[rsp]
  001ff	8b 4c 24 54	 mov	 ecx, DWORD PTR op1$[rsp]
  00203	e8 00 00 00 00	 call	 f32_sub
  00208	89 44 24 24	 mov	 DWORD PTR ans$[rsp], eax

; 5004 : 
; 5005 :     if (softfloat_exceptionFlags)

  0020c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00211	8b c0		 mov	 eax, eax
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00219	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00222	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00226	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022a	85 c0		 test	 eax, eax
  0022c	0f 84 93 00 00
	00		 je	 $LN13@s390_subtr

; 5006 :     {
; 5007 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00232	33 c0		 xor	 eax, eax
  00234	83 f8 01	 cmp	 eax, 1
  00237	74 45		 je	 SHORT $LN14@s390_subtr
  00239	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023e	8b c0		 mov	 eax, eax
  00240	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00246	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00253	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00257	83 e0 10	 and	 eax, 16
  0025a	85 c0		 test	 eax, eax
  0025c	74 20		 je	 SHORT $LN14@s390_subtr
  0025e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00263	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00269	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0026e	85 c0		 test	 eax, eax
  00270	74 0c		 je	 SHORT $LN14@s390_subtr
  00272	b2 80		 mov	 dl, 128			; 00000080H
  00274	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_subtr:

; 5008 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0027e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00283	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00288	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5009 : 
; 5010 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0028c	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00290	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00295	85 c0		 test	 eax, eax
  00297	74 2c		 je	 SHORT $LN15@s390_subtr

; 5011 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00299	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0029d	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002a2	85 c0		 test	 eax, eax
  002a4	74 0a		 je	 SHORT $LN18@s390_subtr
  002a6	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv211[rsp], -192 ; ffffffffffffff40H
  002ae	eb 08		 jmp	 SHORT $LN19@s390_subtr
$LN18@s390_subtr:
  002b0	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv211[rsp], 192 ; 000000c0H
$LN19@s390_subtr:
  002b8	8b 4c 24 38	 mov	 ecx, DWORD PTR tv211[rsp]
  002bc	e8 00 00 00 00	 call	 f32_scaledResult
  002c1	89 44 24 24	 mov	 DWORD PTR ans$[rsp], eax
$LN15@s390_subtr:
$LN13@s390_subtr:
$LN7@s390_subtr:

; 5012 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 5013 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 5014 :     }
; 5015 : 
; 5016 :     PUT_FLOAT32_CC( ans, r1, regs );

  002c5	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  002c9	d1 e0		 shl	 eax, 1
  002cb	48 98		 cdqe
  002cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002da	48 8b d0	 mov	 rdx, rax
  002dd	48 8d 4c 24 24	 lea	 rcx, QWORD PTR ans$[rsp]
  002e2	e8 00 00 00 00	 call	 s390_put_float32
  002e7	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  002eb	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  002f0	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  002f5	75 17		 jne	 SHORT $LN20@s390_subtr
  002f7	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  002fb	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00300	85 c0		 test	 eax, eax
  00302	74 0a		 je	 SHORT $LN20@s390_subtr
  00304	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv233[rsp], 3
  0030c	eb 5e		 jmp	 SHORT $LN27@s390_subtr
$LN20@s390_subtr:
  0030e	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  00312	0f ba f0 1f	 btr	 eax, 31
  00316	85 c0		 test	 eax, eax
  00318	75 0a		 jne	 SHORT $LN21@s390_subtr
  0031a	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv227[rsp], 1
  00322	eb 08		 jmp	 SHORT $LN22@s390_subtr
$LN21@s390_subtr:
  00324	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv227[rsp], 0
$LN22@s390_subtr:
  0032c	83 7c 24 40 00	 cmp	 DWORD PTR tv227[rsp], 0
  00331	74 0a		 je	 SHORT $LN25@s390_subtr
  00333	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
  0033b	eb 27		 jmp	 SHORT $LN26@s390_subtr
$LN25@s390_subtr:
  0033d	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  00341	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00346	85 c0		 test	 eax, eax
  00348	74 0a		 je	 SHORT $LN23@s390_subtr
  0034a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
  00352	eb 08		 jmp	 SHORT $LN24@s390_subtr
$LN23@s390_subtr:
  00354	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv230[rsp], 2
$LN24@s390_subtr:
  0035c	8b 44 24 44	 mov	 eax, DWORD PTR tv230[rsp]
  00360	89 44 24 48	 mov	 DWORD PTR tv232[rsp], eax
$LN26@s390_subtr:
  00364	8b 44 24 48	 mov	 eax, DWORD PTR tv232[rsp]
  00368	89 44 24 4c	 mov	 DWORD PTR tv233[rsp], eax
$LN27@s390_subtr:
  0036c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00371	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv233[rsp]
  00376	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00379	33 c0		 xor	 eax, eax
  0037b	85 c0		 test	 eax, eax
  0037d	0f 85 42 ff ff
	ff		 jne	 $LN7@s390_subtr

; 5017 : 
; 5018 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00383	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00387	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0038c	85 c0		 test	 eax, eax
  0038e	74 0e		 je	 SHORT $LN16@s390_subtr
  00390	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00394	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00399	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_subtr:

; 5019 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 5020 : }

  0039e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003a2	c3		 ret	 0
s390_subtract_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
ans$ = 40
i$1 = 48
tv194 = 52
r1$ = 56
tv210 = 60
tv213 = 64
tv215 = 68
tv216 = 72
r2$ = 76
op2$ = 80
op1$ = 88
inst$ = 112
regs$ = 120
s390_subtract_bfp_long_reg PROC

; 4872 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4873 :     int        r1, r2;
; 4874 :     float64_t  op1, op2, ans;
; 4875 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4876 : 
; 4877 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_subtr:
  00045	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@s390_subtr
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s390_subtr:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_subtr

; 4878 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4879 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN13@s390_subtr
  00092	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN12@s390_subtr
  000a6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN12@s390_subtr
$LN13@s390_subtr:
  000cb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_subtr:
$LN7@s390_subtr:

; 4880 : 
; 4881 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float64
  00111	8b 44 24 4c	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s390_get_float64
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s390_subtr

; 4882 : 
; 4883 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4884 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4885 : 
; 4886 :     ans = f64_sub( op1, op2 );

  00191	48 8b 54 24 50	 mov	 rdx, QWORD PTR op2$[rsp]
  00196	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 f64_sub
  001a0	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax

; 4887 : 
; 4888 :     if (softfloat_exceptionFlags)

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 94 00 00
	00		 je	 $LN14@s390_subtr

; 4889 :     {
; 4890 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001cb	33 c0		 xor	 eax, eax
  001cd	83 f8 01	 cmp	 eax, 1
  001d0	74 45		 je	 SHORT $LN15@s390_subtr
  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	83 e0 10	 and	 eax, 16
  001f3	85 c0		 test	 eax, eax
  001f5	74 20		 je	 SHORT $LN15@s390_subtr
  001f7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00202	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00207	85 c0		 test	 eax, eax
  00209	74 0c		 je	 SHORT $LN15@s390_subtr
  0020b	b2 80		 mov	 dl, 128			; 00000080H
  0020d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_trap
$LN15@s390_subtr:

; 4891 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00217	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00221	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4892 : 
; 4893 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00225	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00229	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022e	85 c0		 test	 eax, eax
  00230	74 2d		 je	 SHORT $LN16@s390_subtr

; 4894 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00232	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00236	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0023b	85 c0		 test	 eax, eax
  0023d	74 0a		 je	 SHORT $LN19@s390_subtr
  0023f	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv194[rsp], -1536 ; fffffffffffffa00H
  00247	eb 08		 jmp	 SHORT $LN20@s390_subtr
$LN19@s390_subtr:
  00249	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv194[rsp], 1536 ; 00000600H
$LN20@s390_subtr:
  00251	8b 4c 24 34	 mov	 ecx, DWORD PTR tv194[rsp]
  00255	e8 00 00 00 00	 call	 f64_scaledResult
  0025a	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax
$LN16@s390_subtr:
$LN14@s390_subtr:
$LN10@s390_subtr:

; 4895 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4896 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4897 :     }
; 4898 : 
; 4899 :     PUT_FLOAT64_CC( ans, r1, regs );

  0025f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00263	d1 e0		 shl	 eax, 1
  00265	48 98		 cdqe
  00267	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00274	48 8b d0	 mov	 rdx, rax
  00277	48 8d 4c 24 28	 lea	 rcx, QWORD PTR ans$[rsp]
  0027c	e8 00 00 00 00	 call	 s390_put_float64
  00281	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0028b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00290	48 23 c8	 and	 rcx, rax
  00293	48 8b c1	 mov	 rax, rcx
  00296	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  002a0	48 3b c1	 cmp	 rax, rcx
  002a3	75 24		 jne	 SHORT $LN21@s390_subtr
  002a5	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  002af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  002b4	48 23 c8	 and	 rcx, rax
  002b7	48 8b c1	 mov	 rax, rcx
  002ba	48 85 c0	 test	 rax, rax
  002bd	74 0a		 je	 SHORT $LN21@s390_subtr
  002bf	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR tv216[rsp], 3
  002c7	eb 79		 jmp	 SHORT $LN28@s390_subtr
$LN21@s390_subtr:
  002c9	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  002d8	48 23 c8	 and	 rcx, rax
  002db	48 8b c1	 mov	 rax, rcx
  002de	48 85 c0	 test	 rax, rax
  002e1	75 0a		 jne	 SHORT $LN22@s390_subtr
  002e3	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  002eb	eb 08		 jmp	 SHORT $LN23@s390_subtr
$LN22@s390_subtr:
  002ed	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN23@s390_subtr:
  002f5	83 7c 24 3c 00	 cmp	 DWORD PTR tv210[rsp], 0
  002fa	74 0a		 je	 SHORT $LN26@s390_subtr
  002fc	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  00304	eb 34		 jmp	 SHORT $LN27@s390_subtr
$LN26@s390_subtr:
  00306	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00310	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00315	48 23 c8	 and	 rcx, rax
  00318	48 8b c1	 mov	 rax, rcx
  0031b	48 85 c0	 test	 rax, rax
  0031e	74 0a		 je	 SHORT $LN24@s390_subtr
  00320	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  00328	eb 08		 jmp	 SHORT $LN25@s390_subtr
$LN24@s390_subtr:
  0032a	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv213[rsp], 2
$LN25@s390_subtr:
  00332	8b 44 24 40	 mov	 eax, DWORD PTR tv213[rsp]
  00336	89 44 24 44	 mov	 DWORD PTR tv215[rsp], eax
$LN27@s390_subtr:
  0033a	8b 44 24 44	 mov	 eax, DWORD PTR tv215[rsp]
  0033e	89 44 24 48	 mov	 DWORD PTR tv216[rsp], eax
$LN28@s390_subtr:
  00342	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00347	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv216[rsp]
  0034c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0034f	33 c0		 xor	 eax, eax
  00351	85 c0		 test	 eax, eax
  00353	0f 85 06 ff ff
	ff		 jne	 $LN10@s390_subtr

; 4900 : 
; 4901 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00359	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0035d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00362	85 c0		 test	 eax, eax
  00364	74 0e		 je	 SHORT $LN17@s390_subtr
  00366	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0036a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0036f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s390_subtr:

; 4902 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4903 : }

  00374	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00378	c3		 ret	 0
s390_subtract_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
ans$ = 48
x2$ = 56
tv211 = 60
r1$ = 64
tv227 = 68
tv230 = 72
tv232 = 76
tv233 = 80
op2$ = 88
op1$ = 96
inst$ = 128
regs$ = 136
s390_subtract_bfp_long PROC

; 4909 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4910 :     int        r1, x2, b2;
; 4911 :     VADR       effective_addr2;
; 4912 :     float64_t  op1, op2, ans;
; 4913 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4914 : 
; 4915 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00037	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 20		 je	 SHORT $LN8@s390_subtr
  0005e	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00072	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00076	03 c8		 add	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s390_subtr:
  0007e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 20		 je	 SHORT $LN9@s390_subtr
  00093	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ab	03 c8		 add	 ecx, eax
  000ad	8b c1		 mov	 eax, ecx
  000af	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_subtr:
  000b3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000c1	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000c5	23 c8		 and	 ecx, eax
  000c7	8b c1		 mov	 eax, ecx
  000c9	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_subtr:
  000cd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0f		 je	 SHORT $LN10@s390_subtr
  000f0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_subtr:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 c8		 jne	 SHORT $LN4@s390_subtr

; 4916 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4917 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4918 :     BFPINST_CHECK( regs );

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00122	85 c0		 test	 eax, eax
  00124	74 3f		 je	 SHORT $LN12@s390_subtr
  00126	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	d1 e8		 shr	 eax, 1
  00136	83 e0 01	 and	 eax, 1
  00139	85 c0		 test	 eax, eax
  0013b	74 55		 je	 SHORT $LN11@s390_subtr
  0013d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00161	85 c0		 test	 eax, eax
  00163	75 2d		 jne	 SHORT $LN11@s390_subtr
$LN12@s390_subtr:
  00165	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_subtr:

; 4919 : 
; 4920 :     GET_FLOAT64_OP( op1, r1, regs );

  00192	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  00196	d1 e0		 shl	 eax, 1
  00198	48 98		 cdqe
  0019a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001aa	48 8b d0	 mov	 rdx, rax
  001ad	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001b2	e8 00 00 00 00	 call	 s390_get_float64

; 4921 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001b7	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001bf	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001c3	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001c7	e8 00 00 00 00	 call	 s390_vfetch8
  001cc	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 4922 : 
; 4923 :     softfloat_exceptionFlags = 0;

  001d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d6	8b c0		 mov	 eax, eax
  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001de	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001eb	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4924 :     SET_SF_RM_FROM_FPC;

  001ef	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001fd	83 e0 07	 and	 eax, 7
  00200	8b c0		 mov	 eax, eax
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00209	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0020e	8b d2		 mov	 edx, edx
  00210	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00217	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00220	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4925 : 
; 4926 :     ans = f64_sub( op1, op2 );

  0022c	48 8b 54 24 58	 mov	 rdx, QWORD PTR op2$[rsp]
  00231	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  00236	e8 00 00 00 00	 call	 f64_sub
  0023b	48 89 44 24 30	 mov	 QWORD PTR ans$[rsp], rax

; 4927 : 
; 4928 :     if (softfloat_exceptionFlags)

  00240	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00245	8b c0		 mov	 eax, eax
  00247	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0024d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00256	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025e	85 c0		 test	 eax, eax
  00260	0f 84 9d 00 00
	00		 je	 $LN13@s390_subtr

; 4929 :     {
; 4930 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00266	33 c0		 xor	 eax, eax
  00268	83 f8 01	 cmp	 eax, 1
  0026b	74 4b		 je	 SHORT $LN14@s390_subtr
  0026d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00272	8b c0		 mov	 eax, eax
  00274	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0027a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00283	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00287	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028b	83 e0 10	 and	 eax, 16
  0028e	85 c0		 test	 eax, eax
  00290	74 26		 je	 SHORT $LN14@s390_subtr
  00292	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002a0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002a5	85 c0		 test	 eax, eax
  002a7	74 0f		 je	 SHORT $LN14@s390_subtr
  002a9	b2 80		 mov	 dl, 128			; 00000080H
  002ab	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_subtr:

; 4931 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c0	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002c5	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4932 : 
; 4933 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002c9	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cd	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002d2	85 c0		 test	 eax, eax
  002d4	74 2d		 je	 SHORT $LN15@s390_subtr

; 4934 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002d6	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002da	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002df	85 c0		 test	 eax, eax
  002e1	74 0a		 je	 SHORT $LN18@s390_subtr
  002e3	c7 44 24 3c 00
	fa ff ff	 mov	 DWORD PTR tv211[rsp], -1536 ; fffffffffffffa00H
  002eb	eb 08		 jmp	 SHORT $LN19@s390_subtr
$LN18@s390_subtr:
  002ed	c7 44 24 3c 00
	06 00 00	 mov	 DWORD PTR tv211[rsp], 1536 ; 00000600H
$LN19@s390_subtr:
  002f5	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv211[rsp]
  002f9	e8 00 00 00 00	 call	 f64_scaledResult
  002fe	48 89 44 24 30	 mov	 QWORD PTR ans$[rsp], rax
$LN15@s390_subtr:
$LN13@s390_subtr:
$LN7@s390_subtr:

; 4935 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4936 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4937 :     }
; 4938 : 
; 4939 :     PUT_FLOAT64_CC( ans, r1, regs );

  00303	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  00307	d1 e0		 shl	 eax, 1
  00309	48 98		 cdqe
  0030b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00313	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0031b	48 8b d0	 mov	 rdx, rax
  0031e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  00323	e8 00 00 00 00	 call	 s390_put_float64
  00328	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00332	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  00337	48 23 c8	 and	 rcx, rax
  0033a	48 8b c1	 mov	 rax, rcx
  0033d	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00347	48 3b c1	 cmp	 rax, rcx
  0034a	75 24		 jne	 SHORT $LN20@s390_subtr
  0034c	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00356	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  0035b	48 23 c8	 and	 rcx, rax
  0035e	48 8b c1	 mov	 rax, rcx
  00361	48 85 c0	 test	 rax, rax
  00364	74 0a		 je	 SHORT $LN20@s390_subtr
  00366	c7 44 24 50 03
	00 00 00	 mov	 DWORD PTR tv233[rsp], 3
  0036e	eb 79		 jmp	 SHORT $LN27@s390_subtr
$LN20@s390_subtr:
  00370	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0037a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  0037f	48 23 c8	 and	 rcx, rax
  00382	48 8b c1	 mov	 rax, rcx
  00385	48 85 c0	 test	 rax, rax
  00388	75 0a		 jne	 SHORT $LN21@s390_subtr
  0038a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv227[rsp], 1
  00392	eb 08		 jmp	 SHORT $LN22@s390_subtr
$LN21@s390_subtr:
  00394	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv227[rsp], 0
$LN22@s390_subtr:
  0039c	83 7c 24 44 00	 cmp	 DWORD PTR tv227[rsp], 0
  003a1	74 0a		 je	 SHORT $LN25@s390_subtr
  003a3	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
  003ab	eb 34		 jmp	 SHORT $LN26@s390_subtr
$LN25@s390_subtr:
  003ad	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  003b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  003bc	48 23 c8	 and	 rcx, rax
  003bf	48 8b c1	 mov	 rax, rcx
  003c2	48 85 c0	 test	 rax, rax
  003c5	74 0a		 je	 SHORT $LN23@s390_subtr
  003c7	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
  003cf	eb 08		 jmp	 SHORT $LN24@s390_subtr
$LN23@s390_subtr:
  003d1	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv230[rsp], 2
$LN24@s390_subtr:
  003d9	8b 44 24 48	 mov	 eax, DWORD PTR tv230[rsp]
  003dd	89 44 24 4c	 mov	 DWORD PTR tv232[rsp], eax
$LN26@s390_subtr:
  003e1	8b 44 24 4c	 mov	 eax, DWORD PTR tv232[rsp]
  003e5	89 44 24 50	 mov	 DWORD PTR tv233[rsp], eax
$LN27@s390_subtr:
  003e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f1	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv233[rsp]
  003f6	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  003f9	33 c0		 xor	 eax, eax
  003fb	85 c0		 test	 eax, eax
  003fd	0f 85 00 ff ff
	ff		 jne	 $LN7@s390_subtr

; 4940 : 
; 4941 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00403	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00407	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0040c	85 c0		 test	 eax, eax
  0040e	74 11		 je	 SHORT $LN16@s390_subtr
  00410	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00414	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_subtr:

; 4942 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4943 : }

  00421	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00425	c3		 ret	 0
s390_subtract_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv214 = 48
tv244 = 52
tv249 = 56
tv251 = 60
tv252 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
ans$ = 144
op2$ = 160
op1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
s390_subtract_bfp_ext_reg PROC

; 4833 : {

$LN32:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4834 :     int         r1, r2;
; 4835 :     float128_t  op1, op2, ans;
; 4836 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4837 : 
; 4838 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_subtr:
  0005f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN11@s390_subtr
  00082	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s390_subtr:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@s390_subtr

; 4839 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4840 :     BFPINST_CHECK( regs );

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 3f		 je	 SHORT $LN13@s390_subtr
  000b8	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c6	d1 e8		 shr	 eax, 1
  000c8	83 e0 01	 and	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 55		 je	 SHORT $LN12@s390_subtr
  000cf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	b9 08 00 00 00	 mov	 ecx, 8
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ee	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f3	85 c0		 test	 eax, eax
  000f5	75 2d		 jne	 SHORT $LN12@s390_subtr
$LN13@s390_subtr:
  000f7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00109	ba 07 00 00 00	 mov	 edx, 7
  0010e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_subtr:

; 4841 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00124	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN15@s390_subtr
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 02	 and	 eax, 2
  00136	85 c0		 test	 eax, eax
  00138	74 1b		 je	 SHORT $LN14@s390_subtr
$LN15@s390_subtr:
  0013a	ba 06 00 00 00	 mov	 edx, 6
  0013f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@s390_subtr:
$LN7@s390_subtr:

; 4842 : 
; 4843 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  00155	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00159	d1 e0		 shl	 eax, 1
  0015b	48 98		 cdqe
  0015d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00178	e8 00 00 00 00	 call	 s390_get_float128
  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00181	d1 e0		 shl	 eax, 1
  00183	48 98		 cdqe
  00185	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001a0	e8 00 00 00 00	 call	 s390_get_float128
  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 aa		 jne	 SHORT $LN7@s390_subtr

; 4844 : 
; 4845 :     SET_SF_RM_FROM_FPC;

  001ab	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001b9	83 e0 07	 and	 eax, 7
  001bc	8b c0		 mov	 eax, eax
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001c5	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001ca	8b d2		 mov	 edx, edx
  001cc	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001d3	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001dc	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e4	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4846 :     softfloat_exceptionFlags = 0;

  001e8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ed	8b c0		 mov	 eax, eax
  001ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001fe	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00202	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4847 :     SET_SF_RM_FROM_FPC;

  00206	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00214	83 e0 07	 and	 eax, 7
  00217	8b c0		 mov	 eax, eax
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00220	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00225	8b d2		 mov	 edx, edx
  00227	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0022e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00237	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0023b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4848 : 
; 4849 :     ans = f128_sub( op1, op2 );

  00243	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  00248	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  00250	48 8b f8	 mov	 rdi, rax
  00253	48 8b f1	 mov	 rsi, rcx
  00256	b9 10 00 00 00	 mov	 ecx, 16
  0025b	f3 a4		 rep movsb
  0025d	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  00262	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  0026a	48 8b f8	 mov	 rdi, rax
  0026d	48 8b f1	 mov	 rsi, rcx
  00270	b9 10 00 00 00	 mov	 ecx, 16
  00275	f3 a4		 rep movsb
  00277	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  0027c	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  00281	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  00286	e8 00 00 00 00	 call	 f128_sub
  0028b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00293	48 8b f9	 mov	 rdi, rcx
  00296	48 8b f0	 mov	 rsi, rax
  00299	b9 10 00 00 00	 mov	 ecx, 16
  0029e	f3 a4		 rep movsb

; 4850 : 
; 4851 :     if (softfloat_exceptionFlags)

  002a0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a5	8b c0		 mov	 eax, eax
  002a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ad	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002be	85 c0		 test	 eax, eax
  002c0	0f 84 b5 00 00
	00		 je	 $LN16@s390_subtr

; 4852 :     {
; 4853 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002c6	33 c0		 xor	 eax, eax
  002c8	83 f8 01	 cmp	 eax, 1
  002cb	74 4b		 je	 SHORT $LN17@s390_subtr
  002cd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d2	8b c0		 mov	 eax, eax
  002d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002da	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002eb	83 e0 10	 and	 eax, 16
  002ee	85 c0		 test	 eax, eax
  002f0	74 26		 je	 SHORT $LN17@s390_subtr
  002f2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fa	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00300	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00305	85 c0		 test	 eax, eax
  00307	74 0f		 je	 SHORT $LN17@s390_subtr
  00309	b2 80		 mov	 dl, 128			; 00000080H
  0030b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00313	e8 00 00 00 00	 call	 ieee_trap
$LN17@s390_subtr:

; 4854 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00318	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00325	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4855 : 
; 4856 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00329	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0032d	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00332	85 c0		 test	 eax, eax
  00334	74 45		 je	 SHORT $LN18@s390_subtr

; 4857 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00336	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0033a	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0033f	85 c0		 test	 eax, eax
  00341	74 0a		 je	 SHORT $LN21@s390_subtr
  00343	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv214[rsp], -24576 ; ffffffffffffa000H
  0034b	eb 08		 jmp	 SHORT $LN22@s390_subtr
$LN21@s390_subtr:
  0034d	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv214[rsp], 24576 ; 00006000H
$LN22@s390_subtr:
  00355	8b 54 24 30	 mov	 edx, DWORD PTR tv214[rsp]
  00359	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00361	e8 00 00 00 00	 call	 f128_scaledResult
  00366	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0036e	48 8b f9	 mov	 rdi, rcx
  00371	48 8b f0	 mov	 rsi, rax
  00374	b9 10 00 00 00	 mov	 ecx, 16
  00379	f3 a4		 rep movsb
$LN18@s390_subtr:
$LN16@s390_subtr:
$LN10@s390_subtr:

; 4858 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 4859 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 4860 :     }
; 4861 : 
; 4862 :     PUT_FLOAT128_CC( ans, r1, regs );

  0037b	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0037f	d1 e0		 shl	 eax, 1
  00381	48 98		 cdqe
  00383	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00393	48 8b d0	 mov	 rdx, rax
  00396	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0039e	e8 00 00 00 00	 call	 s390_put_float128
  003a3	b8 08 00 00 00	 mov	 eax, 8
  003a8	48 6b c0 01	 imul	 rax, rax, 1
  003ac	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  003b6	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  003be	48 23 c1	 and	 rax, rcx
  003c1	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  003cb	48 3b c1	 cmp	 rax, rcx
  003ce	75 44		 jne	 SHORT $LN24@s390_subtr
  003d0	b8 08 00 00 00	 mov	 eax, 8
  003d5	48 6b c0 01	 imul	 rax, rax, 1
  003d9	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  003e3	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  003eb	48 23 c1	 and	 rax, rcx
  003ee	48 85 c0	 test	 rax, rax
  003f1	75 14		 jne	 SHORT $LN23@s390_subtr
  003f3	b8 08 00 00 00	 mov	 eax, 8
  003f8	48 6b c0 00	 imul	 rax, rax, 0
  003fc	48 83 bc 04 90
	00 00 00 00	 cmp	 QWORD PTR ans$[rsp+rax], 0
  00405	74 0d		 je	 SHORT $LN24@s390_subtr
$LN23@s390_subtr:
  00407	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv252[rsp], 3
  0040f	e9 9c 00 00 00	 jmp	 $LN31@s390_subtr
$LN24@s390_subtr:
  00414	b8 08 00 00 00	 mov	 eax, 8
  00419	48 6b c0 01	 imul	 rax, rax, 1
  0041d	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00427	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  0042f	48 23 c1	 and	 rax, rcx
  00432	b9 08 00 00 00	 mov	 ecx, 8
  00437	48 6b c9 00	 imul	 rcx, rcx, 0
  0043b	48 0b 84 0c 90
	00 00 00	 or	 rax, QWORD PTR ans$[rsp+rcx]
  00443	48 85 c0	 test	 rax, rax
  00446	75 0a		 jne	 SHORT $LN25@s390_subtr
  00448	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv244[rsp], 1
  00450	eb 08		 jmp	 SHORT $LN26@s390_subtr
$LN25@s390_subtr:
  00452	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv244[rsp], 0
$LN26@s390_subtr:
  0045a	83 7c 24 34 00	 cmp	 DWORD PTR tv244[rsp], 0
  0045f	74 0a		 je	 SHORT $LN29@s390_subtr
  00461	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
  00469	eb 3d		 jmp	 SHORT $LN30@s390_subtr
$LN29@s390_subtr:
  0046b	b8 08 00 00 00	 mov	 eax, 8
  00470	48 6b c0 01	 imul	 rax, rax, 1
  00474	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0047e	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  00486	48 23 c1	 and	 rax, rcx
  00489	48 85 c0	 test	 rax, rax
  0048c	74 0a		 je	 SHORT $LN27@s390_subtr
  0048e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv249[rsp], 1
  00496	eb 08		 jmp	 SHORT $LN28@s390_subtr
$LN27@s390_subtr:
  00498	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv249[rsp], 2
$LN28@s390_subtr:
  004a0	8b 44 24 38	 mov	 eax, DWORD PTR tv249[rsp]
  004a4	89 44 24 3c	 mov	 DWORD PTR tv251[rsp], eax
$LN30@s390_subtr:
  004a8	8b 44 24 3c	 mov	 eax, DWORD PTR tv251[rsp]
  004ac	89 44 24 40	 mov	 DWORD PTR tv252[rsp], eax
$LN31@s390_subtr:
  004b0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b8	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv252[rsp]
  004bd	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  004c0	33 c0		 xor	 eax, eax
  004c2	85 c0		 test	 eax, eax
  004c4	0f 85 b1 fe ff
	ff		 jne	 $LN10@s390_subtr

; 4863 : 
; 4864 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  004ca	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004ce	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  004d3	85 c0		 test	 eax, eax
  004d5	74 11		 je	 SHORT $LN19@s390_subtr
  004d7	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004db	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@s390_subtr:

; 4865 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4866 : }

  004e8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f0	48 33 cc	 xor	 rcx, rsp
  004f3	e8 00 00 00 00	 call	 __security_check_cookie
  004f8	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  004ff	5f		 pop	 rdi
  00500	5e		 pop	 rsi
  00501	c3		 ret	 0
s390_subtract_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
op2$ = 44
r1$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
s390_squareroot_bfp_short_reg PROC

; 4766 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4767 :     int        r1, r2;
; 4768 :     float32_t  op1, op2;
; 4769 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4770 : 
; 4771 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_squar:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN5@s390_squar
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_squar:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_squar

; 4772 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4773 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN7@s390_squar
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN6@s390_squar
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN6@s390_squar
$LN7@s390_squar:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_squar:

; 4774 : 
; 4775 :     GET_FLOAT32_OP( op2, r2, regs );

  000ef	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR op2$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float32

; 4776 : 
; 4777 :     softfloat_exceptionFlags = 0;

  00111	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00116	8b c0		 mov	 eax, eax
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0011e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00127	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0012b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4778 :     SET_SF_RM_FROM_FPC;

  0012f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00134	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0013a	83 e0 07	 and	 eax, 7
  0013d	8b c0		 mov	 eax, eax
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00146	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0014b	8b d2		 mov	 edx, edx
  0014d	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00154	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  0015d	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00161	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00165	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4779 : 
; 4780 :     op1 = f32_sqrt( op2 );

  00169	8b 4c 24 2c	 mov	 ecx, DWORD PTR op2$[rsp]
  0016d	e8 00 00 00 00	 call	 f32_sqrt
  00172	89 44 24 34	 mov	 DWORD PTR op1$[rsp], eax

; 4781 : 
; 4782 :     if (softfloat_exceptionFlags)

  00176	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017b	8b c0		 mov	 eax, eax
  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00183	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00190	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00194	85 c0		 test	 eax, eax
  00196	0f 84 88 00 00
	00		 je	 $LN8@s390_squar

; 4783 :     {
; 4784 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0019c	33 c0		 xor	 eax, eax
  0019e	83 f8 01	 cmp	 eax, 1
  001a1	74 45		 je	 SHORT $LN9@s390_squar
  001a3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a8	8b c0		 mov	 eax, eax
  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c1	83 e0 10	 and	 eax, 16
  001c4	85 c0		 test	 eax, eax
  001c6	74 20		 je	 SHORT $LN9@s390_squar
  001c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001cd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001d8	85 c0		 test	 eax, eax
  001da	74 0c		 je	 SHORT $LN9@s390_squar
  001dc	b2 80		 mov	 dl, 128			; 00000080H
  001de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	e8 00 00 00 00	 call	 ieee_trap
$LN9@s390_squar:

; 4785 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  001e8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f3	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  001f8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  001fd	8b c9		 mov	 ecx, ecx
  001ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00205	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  0020e	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00212	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00216	c1 e1 1b	 shl	 ecx, 27
  00219	23 c1		 and	 eax, ecx
  0021b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00220	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN8@s390_squar:

; 4786 :     }
; 4787 : 
; 4788 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  00224	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00228	d1 e0		 shl	 eax, 1
  0022a	48 98		 cdqe
  0022c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00231	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00239	48 8b d0	 mov	 rdx, rax
  0023c	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00241	e8 00 00 00 00	 call	 s390_put_float32

; 4789 : 
; 4790 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00246	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0024a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0024f	85 c0		 test	 eax, eax
  00251	74 0e		 je	 SHORT $LN10@s390_squar
  00253	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00257	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0025c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN10@s390_squar:

; 4791 :     SET_FPC_FLAGS_FROM_SF( regs );

  00261	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00266	8b c0		 mov	 eax, eax
  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00277	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027f	c1 e0 13	 shl	 eax, 19
  00282	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00287	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0028d	c1 e9 08	 shr	 ecx, 8
  00290	f7 d1		 not	 ecx
  00292	23 c1		 and	 eax, ecx
  00294	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00299	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002a4	0b c8		 or	 ecx, eax
  002a6	8b c1		 mov	 eax, ecx
  002a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002ad	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4792 : }

  002b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002b7	c3		 ret	 0
s390_squareroot_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
ieee_trap_conds$ = 44
x2$ = 48
op2$ = 52
r1$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s390_squareroot_bfp_short PROC

; 4798 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4799 :     int        r1, x2, b2;
; 4800 :     VADR       effective_addr2;
; 4801 :     float32_t  op1, op2;
; 4802 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4803 : 
; 4804 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s390_squar
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_squar:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s390_squar
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_squar:
  000aa	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_squar:
  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ca	48 83 c0 06	 add	 rax, 6
  000ce	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 06	 cmp	 eax, 6
  000dc	74 0c		 je	 SHORT $LN7@s390_squar
  000de	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_squar:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 d1		 jne	 SHORT $LN4@s390_squar

; 4805 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4806 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4807 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00105	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $LN9@s390_squar
  0010e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00113	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00119	d1 e8		 shr	 eax, 1
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 49		 je	 SHORT $LN8@s390_squar
  00122	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	48 6b c9 01	 imul	 rcx, rcx, 1
  00137	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0013e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN8@s390_squar
$LN9@s390_squar:
  00147	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00156	ba 07 00 00 00	 mov	 edx, 7
  0015b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00165	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_squar:

; 4808 : 
; 4809 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0016b	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00170	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00174	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00178	e8 00 00 00 00	 call	 s390_vfetch4
  0017d	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 4810 : 
; 4811 :     softfloat_exceptionFlags = 0;

  00181	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00186	8b c0		 mov	 eax, eax
  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0018e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00197	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0019b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4812 :     SET_SF_RM_FROM_FPC;

  0019f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001a4	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001aa	83 e0 07	 and	 eax, 7
  001ad	8b c0		 mov	 eax, eax
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001b6	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001bb	8b d2		 mov	 edx, edx
  001bd	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001c4	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001cd	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d5	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4813 : 
; 4814 :     op1 = f32_sqrt( op2 );

  001d9	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  001dd	e8 00 00 00 00	 call	 f32_sqrt
  001e2	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 4815 : 
; 4816 :     if (softfloat_exceptionFlags)

  001e6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001eb	8b c0		 mov	 eax, eax
  001ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001fc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00200	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00204	85 c0		 test	 eax, eax
  00206	0f 84 88 00 00
	00		 je	 $LN10@s390_squar

; 4817 :     {
; 4818 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0020c	33 c0		 xor	 eax, eax
  0020e	83 f8 01	 cmp	 eax, 1
  00211	74 45		 je	 SHORT $LN11@s390_squar
  00213	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00218	8b c0		 mov	 eax, eax
  0021a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00220	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00229	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00231	83 e0 10	 and	 eax, 16
  00234	85 c0		 test	 eax, eax
  00236	74 20		 je	 SHORT $LN11@s390_squar
  00238	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0023d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00243	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00248	85 c0		 test	 eax, eax
  0024a	74 0c		 je	 SHORT $LN11@s390_squar
  0024c	b2 80		 mov	 dl, 128			; 00000080H
  0024e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00253	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_squar:

; 4819 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  00258	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0025d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00263	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00268	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  0026d	8b c9		 mov	 ecx, ecx
  0026f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00275	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  0027e	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00282	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00286	c1 e1 1b	 shl	 ecx, 27
  00289	23 c1		 and	 eax, ecx
  0028b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00290	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN10@s390_squar:

; 4820 :     }
; 4821 : 
; 4822 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  00294	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00298	d1 e0		 shl	 eax, 1
  0029a	48 98		 cdqe
  0029c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002a1	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002a9	48 8b d0	 mov	 rdx, rax
  002ac	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  002b1	e8 00 00 00 00	 call	 s390_put_float32

; 4823 : 
; 4824 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002b6	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ba	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002bf	85 c0		 test	 eax, eax
  002c1	74 0e		 je	 SHORT $LN12@s390_squar
  002c3	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	e8 00 00 00 00	 call	 ieee_cond_trap
$LN12@s390_squar:

; 4825 :     SET_FPC_FLAGS_FROM_SF( regs );

  002d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d6	8b c0		 mov	 eax, eax
  002d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002de	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ef	c1 e0 13	 shl	 eax, 19
  002f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002fd	c1 e9 08	 shr	 ecx, 8
  00300	f7 d1		 not	 ecx
  00302	23 c1		 and	 eax, ecx
  00304	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00309	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0030e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00314	0b c8		 or	 ecx, eax
  00316	8b c1		 mov	 eax, ecx
  00318	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0031d	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4826 : }

  00323	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00327	c3		 ret	 0
s390_squareroot_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
s390_squareroot_bfp_long_reg PROC

; 4700 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4701 :     int        r1, r2;
; 4702 :     float64_t  op1, op2;
; 4703 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4704 : 
; 4705 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_squar:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN5@s390_squar
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_squar:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_squar

; 4706 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4707 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN7@s390_squar
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN6@s390_squar
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN6@s390_squar
$LN7@s390_squar:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_squar:

; 4708 : 
; 4709 :     GET_FLOAT64_OP( op2, r2, regs );

  000ef	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float64

; 4710 : 
; 4711 :     softfloat_exceptionFlags = 0;

  00111	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00116	8b c0		 mov	 eax, eax
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0011e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00127	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0012b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4712 :     SET_SF_RM_FROM_FPC;

  0012f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00134	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0013a	83 e0 07	 and	 eax, 7
  0013d	8b c0		 mov	 eax, eax
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00146	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0014b	8b d2		 mov	 edx, edx
  0014d	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00154	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  0015d	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00161	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00165	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4713 : 
; 4714 :     op1 = f64_sqrt( op2 );

  00169	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0016e	e8 00 00 00 00	 call	 f64_sqrt
  00173	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 4715 : 
; 4716 :     if (softfloat_exceptionFlags)

  00178	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017d	8b c0		 mov	 eax, eax
  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00185	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00192	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00196	85 c0		 test	 eax, eax
  00198	0f 84 88 00 00
	00		 je	 $LN8@s390_squar

; 4717 :     {
; 4718 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0019e	33 c0		 xor	 eax, eax
  001a0	83 f8 01	 cmp	 eax, 1
  001a3	74 45		 je	 SHORT $LN9@s390_squar
  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	83 e0 10	 and	 eax, 16
  001c6	85 c0		 test	 eax, eax
  001c8	74 20		 je	 SHORT $LN9@s390_squar
  001ca	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d5	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001da	85 c0		 test	 eax, eax
  001dc	74 0c		 je	 SHORT $LN9@s390_squar
  001de	b2 80		 mov	 dl, 128			; 00000080H
  001e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e5	e8 00 00 00 00	 call	 ieee_trap
$LN9@s390_squar:

; 4719 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  001ea	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f5	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  001fa	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  001ff	8b c9		 mov	 ecx, ecx
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00207	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00210	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00214	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00218	c1 e1 1b	 shl	 ecx, 27
  0021b	23 c1		 and	 eax, ecx
  0021d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00222	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN8@s390_squar:

; 4720 :     }
; 4721 : 
; 4722 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00226	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0022a	d1 e0		 shl	 eax, 1
  0022c	48 98		 cdqe
  0022e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00233	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0023b	48 8b d0	 mov	 rdx, rax
  0023e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00243	e8 00 00 00 00	 call	 s390_put_float64

; 4723 : 
; 4724 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00248	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0024c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00251	85 c0		 test	 eax, eax
  00253	74 0e		 je	 SHORT $LN10@s390_squar
  00255	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00259	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	e8 00 00 00 00	 call	 ieee_cond_trap
$LN10@s390_squar:

; 4725 :     SET_FPC_FLAGS_FROM_SF( regs );

  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	c1 e0 13	 shl	 eax, 19
  00284	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00289	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0028f	c1 e9 08	 shr	 ecx, 8
  00292	f7 d1		 not	 ecx
  00294	23 c1		 and	 eax, ecx
  00296	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0029b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002a6	0b c8		 or	 ecx, eax
  002a8	8b c1		 mov	 eax, ecx
  002aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002af	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4726 : }

  002b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002b9	c3		 ret	 0
s390_squareroot_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
ieee_trap_conds$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
s390_squareroot_bfp_long PROC

; 4732 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4733 :     int        r1, x2, b2;
; 4734 :     VADR       effective_addr2;
; 4735 :     float64_t  op1, op2;
; 4736 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4737 : 
; 4738 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s390_squar
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_squar:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s390_squar
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_squar:
  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_squar:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ca	48 83 c0 06	 add	 rax, 6
  000ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 06	 cmp	 eax, 6
  000dc	74 0c		 je	 SHORT $LN7@s390_squar
  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_squar:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 d1		 jne	 SHORT $LN4@s390_squar

; 4739 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4740 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4741 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00105	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $LN9@s390_squar
  0010e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00113	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00119	d1 e8		 shr	 eax, 1
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 49		 je	 SHORT $LN8@s390_squar
  00122	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	48 6b c9 01	 imul	 rcx, rcx, 1
  00137	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0013e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN8@s390_squar
$LN9@s390_squar:
  00147	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00156	ba 07 00 00 00	 mov	 edx, 7
  0015b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00165	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_squar:

; 4742 : 
; 4743 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0016b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00170	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00174	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00178	e8 00 00 00 00	 call	 s390_vfetch8
  0017d	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 4744 : 
; 4745 :     softfloat_exceptionFlags = 0;

  00182	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00187	8b c0		 mov	 eax, eax
  00189	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0018f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00198	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0019c	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4746 :     SET_SF_RM_FROM_FPC;

  001a0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001a5	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ab	83 e0 07	 and	 eax, 7
  001ae	8b c0		 mov	 eax, eax
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001b7	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001bc	8b d2		 mov	 edx, edx
  001be	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001c5	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001ce	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d6	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4747 : 
; 4748 :     op1 = f64_sqrt( op2 );

  001da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  001df	e8 00 00 00 00	 call	 f64_sqrt
  001e4	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 4749 : 
; 4750 :     if (softfloat_exceptionFlags)

  001e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ee	8b c0		 mov	 eax, eax
  001f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ff	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00203	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00207	85 c0		 test	 eax, eax
  00209	0f 84 88 00 00
	00		 je	 $LN10@s390_squar

; 4751 :     {
; 4752 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0020f	33 c0		 xor	 eax, eax
  00211	83 f8 01	 cmp	 eax, 1
  00214	74 45		 je	 SHORT $LN11@s390_squar
  00216	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021b	8b c0		 mov	 eax, eax
  0021d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00223	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00230	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00234	83 e0 10	 and	 eax, 16
  00237	85 c0		 test	 eax, eax
  00239	74 20		 je	 SHORT $LN11@s390_squar
  0023b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00240	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00246	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0024b	85 c0		 test	 eax, eax
  0024d	74 0c		 je	 SHORT $LN11@s390_squar
  0024f	b2 80		 mov	 dl, 128			; 00000080H
  00251	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_squar:

; 4753 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  0025b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00260	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00266	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  0026b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  00270	8b c9		 mov	 ecx, ecx
  00272	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00278	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00281	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00285	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00289	c1 e1 1b	 shl	 ecx, 27
  0028c	23 c1		 and	 eax, ecx
  0028e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00293	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN10@s390_squar:

; 4754 :     }
; 4755 : 
; 4756 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00297	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0029b	d1 e0		 shl	 eax, 1
  0029d	48 98		 cdqe
  0029f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002a4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002ac	48 8b d0	 mov	 rdx, rax
  002af	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  002b4	e8 00 00 00 00	 call	 s390_put_float64

; 4757 : 
; 4758 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002b9	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002bd	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002c2	85 c0		 test	 eax, eax
  002c4	74 0e		 je	 SHORT $LN12@s390_squar
  002c6	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002cf	e8 00 00 00 00	 call	 ieee_cond_trap
$LN12@s390_squar:

; 4759 :     SET_FPC_FLAGS_FROM_SF( regs );

  002d4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d9	8b c0		 mov	 eax, eax
  002db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ea	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f2	c1 e0 13	 shl	 eax, 19
  002f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fa	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00300	c1 e9 08	 shr	 ecx, 8
  00303	f7 d1		 not	 ecx
  00305	23 c1		 and	 eax, ecx
  00307	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0030c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00311	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00317	0b c8		 or	 ecx, eax
  00319	8b c1		 mov	 eax, ecx
  0031b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4760 : }

  00326	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0032a	c3		 ret	 0
s390_squareroot_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s390_squareroot_bfp_ext_reg PROC

; 4667 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4668 :     int         r1, r2;
; 4669 :     float128_t  op1, op2;
; 4670 :     U32         ieee_trap_conds = 0;

  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4671 : 
; 4672 :     RRE( inst, regs, r1, r2 );

  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 03	 imul	 rax, rax, 3
  00033	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003f	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0004e	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00052	c1 f8 04	 sar	 eax, 4
  00055	83 e0 0f	 and	 eax, 15
  00058	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_squar:
  0005c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0f		 je	 SHORT $LN5@s390_squar
  0007f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_squar:
  0008e	33 c0		 xor	 eax, eax
  00090	85 c0		 test	 eax, eax
  00092	75 c8		 jne	 SHORT $LN4@s390_squar

; 4673 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4674 :     BFPINST_CHECK( regs );

  00094	b8 08 00 00 00	 mov	 eax, 8
  00099	48 6b c0 01	 imul	 rax, rax, 1
  0009d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ac	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b1	85 c0		 test	 eax, eax
  000b3	74 3f		 je	 SHORT $LN7@s390_squar
  000b5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c3	d1 e8		 shr	 eax, 1
  000c5	83 e0 01	 and	 eax, 1
  000c8	85 c0		 test	 eax, eax
  000ca	74 55		 je	 SHORT $LN6@s390_squar
  000cc	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000db	b9 08 00 00 00	 mov	 ecx, 8
  000e0	48 6b c9 01	 imul	 rcx, rcx, 1
  000e4	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000eb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f0	85 c0		 test	 eax, eax
  000f2	75 2d		 jne	 SHORT $LN6@s390_squar
$LN7@s390_squar:
  000f4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00106	ba 07 00 00 00	 mov	 edx, 7
  0010b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_squar:

; 4675 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00121	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00125	83 e0 02	 and	 eax, 2
  00128	85 c0		 test	 eax, eax
  0012a	75 0b		 jne	 SHORT $LN9@s390_squar
  0012c	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00130	83 e0 02	 and	 eax, 2
  00133	85 c0		 test	 eax, eax
  00135	74 1b		 je	 SHORT $LN8@s390_squar
$LN9@s390_squar:
  00137	ba 06 00 00 00	 mov	 edx, 6
  0013c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_squar:

; 4676 : 
; 4677 :     GET_FLOAT128_OP( op2, r2, regs );

  00152	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00156	d1 e0		 shl	 eax, 1
  00158	48 98		 cdqe
  0015a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016a	48 8b d0	 mov	 rdx, rax
  0016d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  00172	e8 00 00 00 00	 call	 s390_get_float128

; 4678 : 
; 4679 :     softfloat_exceptionFlags = 0;

  00177	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017c	8b c0		 mov	 eax, eax
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00184	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00191	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4680 :     SET_SF_RM_FROM_FPC;

  00195	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001a3	83 e0 07	 and	 eax, 7
  001a6	8b c0		 mov	 eax, eax
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001af	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001b4	8b d2		 mov	 edx, edx
  001b6	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001bd	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001c6	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ce	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4681 : 
; 4682 :     op1 = f128_sqrt( op2 );

  001d2	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  001d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001dc	48 8b f8	 mov	 rdi, rax
  001df	48 8b f1	 mov	 rsi, rcx
  001e2	b9 10 00 00 00	 mov	 ecx, 16
  001e7	f3 a4		 rep movsb
  001e9	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  001ee	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  001f3	e8 00 00 00 00	 call	 f128_sqrt
  001f8	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001fd	48 8b f9	 mov	 rdi, rcx
  00200	48 8b f0	 mov	 rsi, rax
  00203	b9 10 00 00 00	 mov	 ecx, 16
  00208	f3 a4		 rep movsb

; 4683 : 
; 4684 :     if (softfloat_exceptionFlags)

  0020a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020f	8b c0		 mov	 eax, eax
  00211	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00217	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00220	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	85 c0		 test	 eax, eax
  0022a	0f 84 91 00 00
	00		 je	 $LN10@s390_squar

; 4685 :     {
; 4686 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00230	33 c0		 xor	 eax, eax
  00232	83 f8 01	 cmp	 eax, 1
  00235	74 4b		 je	 SHORT $LN11@s390_squar
  00237	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023c	8b c0		 mov	 eax, eax
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00244	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00251	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00255	83 e0 10	 and	 eax, 16
  00258	85 c0		 test	 eax, eax
  0025a	74 26		 je	 SHORT $LN11@s390_squar
  0025c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00264	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0026a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0026f	85 c0		 test	 eax, eax
  00271	74 0f		 je	 SHORT $LN11@s390_squar
  00273	b2 80		 mov	 dl, 128			; 00000080H
  00275	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_squar:

; 4687 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  00282	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00290	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00295	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  0029a	8b c9		 mov	 ecx, ecx
  0029c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  002a2	65 48 8b 3c 25
	58 00 00 00	 mov	 rdi, QWORD PTR gs:88
  002ab	48 8b 14 d7	 mov	 rdx, QWORD PTR [rdi+rdx*8]
  002af	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002b3	c1 e1 1b	 shl	 ecx, 27
  002b6	23 c1		 and	 eax, ecx
  002b8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002bd	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN10@s390_squar:

; 4688 :     }
; 4689 : 
; 4690 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  002c1	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002c5	d1 e0		 shl	 eax, 1
  002c7	48 98		 cdqe
  002c9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d1	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d9	48 8b d0	 mov	 rdx, rax
  002dc	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  002e1	e8 00 00 00 00	 call	 s390_put_float128

; 4691 : 
; 4692 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002e6	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ea	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002ef	85 c0		 test	 eax, eax
  002f1	74 11		 je	 SHORT $LN12@s390_squar
  002f3	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002f7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ff	e8 00 00 00 00	 call	 ieee_cond_trap
$LN12@s390_squar:

; 4693 :     SET_FPC_FLAGS_FROM_SF( regs );

  00304	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00309	8b c0		 mov	 eax, eax
  0030b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00311	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0031a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00322	c1 e0 13	 shl	 eax, 19
  00325	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00333	c1 e9 08	 shr	 ecx, 8
  00336	f7 d1		 not	 ecx
  00338	23 c1		 and	 eax, ecx
  0033a	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0033f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00347	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0034d	0b c8		 or	 ecx, eax
  0034f	8b c1		 mov	 eax, ecx
  00351	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00359	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4694 : }

  0035f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00364	48 33 cc	 xor	 rcx, rsp
  00367	e8 00 00 00 00	 call	 __security_check_cookie
  0036c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00373	5f		 pop	 rdi
  00374	5e		 pop	 rsi
  00375	c3		 ret	 0
s390_squareroot_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
tv212 = 44
r1$ = 48
ans$ = 52
r3$ = 56
r2$ = 60
op3$ = 64
op2$ = 68
inst$ = 96
regs$ = 104
s390_multiply_subtract_bfp_short_reg PROC

; 4575 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4576 :     int        r1, r2, r3;
; 4577 :     float32_t  op1, op2, op3, ans;
; 4578 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4579 : 
; 4580 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 3c	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN8@s390_multi
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@s390_multi

; 4581 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4582 :     BFPINST_CHECK( regs );

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00096	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009b	85 c0		 test	 eax, eax
  0009d	74 39		 je	 SHORT $LN10@s390_multi
  0009f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000aa	d1 e8		 shr	 eax, 1
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 49		 je	 SHORT $LN9@s390_multi
  000b3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000d4	85 c0		 test	 eax, eax
  000d6	75 24		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000d8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e7	ba 07 00 00 00	 mov	 edx, 7
  000ec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:
$LN7@s390_multi:

; 4583 : 
; 4584 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  000fc	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00100	d1 e0		 shl	 eax, 1
  00102	48 98		 cdqe
  00104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op1$[rsp]
  00119	e8 00 00 00 00	 call	 s390_get_float32
  0011e	8b 44 24 38	 mov	 eax, DWORD PTR r3$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op3$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_get_float32
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 b6		 jne	 SHORT $LN7@s390_multi

; 4585 :     GET_FLOAT32_OP( op2, r2, regs );

  00146	8b 44 24 3c	 mov	 eax, DWORD PTR r2$[rsp]
  0014a	d1 e0		 shl	 eax, 1
  0014c	48 98		 cdqe
  0014e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op2$[rsp]
  00163	e8 00 00 00 00	 call	 s390_get_float32

; 4586 : 
; 4587 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4588 :     if (0
; 4589 :         || !(op1.v & 0x007FFFFF)
; 4590 :         || ((op1.v & 0x7F800000) ^ 0x7F800000)

  00168	33 c0		 xor	 eax, eax
  0016a	85 c0		 test	 eax, eax
  0016c	75 1f		 jne	 SHORT $LN12@s390_multi
  0016e	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  00172	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00177	85 c0		 test	 eax, eax
  00179	74 12		 je	 SHORT $LN12@s390_multi
  0017b	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  0017f	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00184	35 00 00 80 7f	 xor	 eax, 2139095040		; 7f800000H
  00189	85 c0		 test	 eax, eax
  0018b	74 0c		 je	 SHORT $LN11@s390_multi
$LN12@s390_multi:

; 4591 :     )
; 4592 :         op1.v ^= 0x80000000;

  0018d	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  00191	0f ba f8 1f	 btc	 eax, 31
  00195	89 44 24 20	 mov	 DWORD PTR op1$[rsp], eax
$LN11@s390_multi:

; 4593 : 
; 4594 :     softfloat_exceptionFlags = 0;

  00199	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019e	8b c0		 mov	 eax, eax
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4595 :     SET_SF_RM_FROM_FPC;

  001b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c2	83 e0 07	 and	 eax, 7
  001c5	8b c0		 mov	 eax, eax
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001d3	8b d2		 mov	 edx, edx
  001d5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001dc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001e5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4596 : 
; 4597 :     ans = f32_mulAdd( op2, op3, op1 );

  001f1	44 8b 44 24 20	 mov	 r8d, DWORD PTR op1$[rsp]
  001f6	8b 54 24 40	 mov	 edx, DWORD PTR op3$[rsp]
  001fa	8b 4c 24 44	 mov	 ecx, DWORD PTR op2$[rsp]
  001fe	e8 00 00 00 00	 call	 f32_mulAdd
  00203	89 44 24 34	 mov	 DWORD PTR ans$[rsp], eax

; 4598 : 
; 4599 :     if (softfloat_exceptionFlags)

  00207	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020c	8b c0		 mov	 eax, eax
  0020e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00214	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00221	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00225	85 c0		 test	 eax, eax
  00227	0f 84 93 00 00
	00		 je	 $LN13@s390_multi

; 4600 :     {
; 4601 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0022d	33 c0		 xor	 eax, eax
  0022f	83 f8 01	 cmp	 eax, 1
  00232	74 45		 je	 SHORT $LN14@s390_multi
  00234	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00239	8b c0		 mov	 eax, eax
  0023b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00241	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00252	83 e0 10	 and	 eax, 16
  00255	85 c0		 test	 eax, eax
  00257	74 20		 je	 SHORT $LN14@s390_multi
  00259	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0025e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00264	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00269	85 c0		 test	 eax, eax
  0026b	74 0c		 je	 SHORT $LN14@s390_multi
  0026d	b2 80		 mov	 dl, 128			; 00000080H
  0026f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_multi:

; 4602 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00279	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0027e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00283	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4603 : 
; 4604 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00287	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0028b	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00290	85 c0		 test	 eax, eax
  00292	74 2c		 je	 SHORT $LN15@s390_multi

; 4605 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00294	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00298	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0029d	85 c0		 test	 eax, eax
  0029f	74 0a		 je	 SHORT $LN18@s390_multi
  002a1	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv212[rsp], -192 ; ffffffffffffff40H
  002a9	eb 08		 jmp	 SHORT $LN19@s390_multi
$LN18@s390_multi:
  002ab	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv212[rsp], 192 ; 000000c0H
$LN19@s390_multi:
  002b3	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv212[rsp]
  002b7	e8 00 00 00 00	 call	 f32_scaledResult
  002bc	89 44 24 34	 mov	 DWORD PTR ans$[rsp], eax
$LN15@s390_multi:
$LN13@s390_multi:

; 4606 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4607 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4608 :     }
; 4609 : 
; 4610 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  002c0	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  002c4	d1 e0		 shl	 eax, 1
  002c6	48 98		 cdqe
  002c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d5	48 8b d0	 mov	 rdx, rax
  002d8	48 8d 4c 24 34	 lea	 rcx, QWORD PTR ans$[rsp]
  002dd	e8 00 00 00 00	 call	 s390_put_float32

; 4611 : 
; 4612 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002e2	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e6	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002eb	85 c0		 test	 eax, eax
  002ed	74 0e		 je	 SHORT $LN16@s390_multi
  002ef	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f8	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_multi:

; 4613 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4614 : }

  002fd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00301	c3		 ret	 0
s390_multiply_subtract_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
op1$ = 36
ieee_trap_conds$ = 40
temp$1 = 44
b2$ = 48
x2$ = 52
tv231 = 56
r1$ = 60
ans$ = 64
r3$ = 68
op3$ = 72
op2$ = 76
inst$ = 96
regs$ = 104
s390_multiply_subtract_bfp_short PROC

; 4620 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4621 :     int        x2, r1, r3, b2;
; 4622 :     VADR       effective_addr2;
; 4623 :     float32_t  op1, op2, op3, ans;
; 4624 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4625 : 
; 4626 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 04	 imul	 rax, rax, 4
  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	c1 f8 04	 sar	 eax, 4
  00040	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 10	 shr	 eax, 16
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 34	 mov	 DWORD PTR x2$[rsp], eax
  0005f	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 14	 shr	 eax, 20
  00066	83 e0 0f	 and	 eax, 15
  00069	89 44 24 44	 mov	 DWORD PTR r3$[rsp], eax
  0006d	83 7c 24 34 00	 cmp	 DWORD PTR x2$[rsp], 0
  00072	74 1d		 je	 SHORT $LN8@s390_multi
  00074	48 63 44 24 34	 movsxd	 rax, DWORD PTR x2$[rsp]
  00079	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00085	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00089	03 c8		 add	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s390_multi:
  00091	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00095	c1 e8 0c	 shr	 eax, 12
  00098	83 e0 0f	 and	 eax, 15
  0009b	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  0009f	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a4	74 1d		 je	 SHORT $LN9@s390_multi
  000a6	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bb	03 c8		 add	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_multi:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ce	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d2	23 c8		 and	 ecx, eax
  000d4	8b c1		 mov	 eax, ecx
  000d6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_multi:
  000da	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000df	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e3	48 83 c0 06	 add	 rax, 6
  000e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f0	33 c0		 xor	 eax, eax
  000f2	83 f8 06	 cmp	 eax, 6
  000f5	74 0c		 je	 SHORT $LN10@s390_multi
  000f7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_multi:
  00103	33 c0		 xor	 eax, eax
  00105	85 c0		 test	 eax, eax
  00107	75 d1		 jne	 SHORT $LN4@s390_multi

; 4627 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4628 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4629 :     BFPINST_CHECK( regs );

  00109	b8 08 00 00 00	 mov	 eax, 8
  0010e	48 6b c0 01	 imul	 rax, rax, 1
  00112	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00123	85 c0		 test	 eax, eax
  00125	74 39		 je	 SHORT $LN12@s390_multi
  00127	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00132	d1 e8		 shr	 eax, 1
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	74 49		 je	 SHORT $LN11@s390_multi
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00147	b9 08 00 00 00	 mov	 ecx, 8
  0014c	48 6b c9 01	 imul	 rcx, rcx, 1
  00150	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00157	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0015c	85 c0		 test	 eax, eax
  0015e	75 24		 jne	 SHORT $LN11@s390_multi
$LN12@s390_multi:
  00160	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00165	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0016f	ba 07 00 00 00	 mov	 edx, 7
  00174	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_multi:
$LN7@s390_multi:

; 4630 : 
; 4631 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  00184	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00188	d1 e0		 shl	 eax, 1
  0018a	48 98		 cdqe
  0018c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00191	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00199	48 8b d0	 mov	 rdx, rax
  0019c	48 8d 4c 24 24	 lea	 rcx, QWORD PTR op1$[rsp]
  001a1	e8 00 00 00 00	 call	 s390_get_float32
  001a6	8b 44 24 44	 mov	 eax, DWORD PTR r3$[rsp]
  001aa	d1 e0		 shl	 eax, 1
  001ac	48 98		 cdqe
  001ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001bb	48 8b d0	 mov	 rdx, rax
  001be	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  001c3	e8 00 00 00 00	 call	 s390_get_float32
  001c8	33 c0		 xor	 eax, eax
  001ca	85 c0		 test	 eax, eax
  001cc	75 b6		 jne	 SHORT $LN7@s390_multi

; 4632 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  001ce	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001d3	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  001d7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001db	e8 00 00 00 00	 call	 s390_vfetch4
  001e0	89 44 24 4c	 mov	 DWORD PTR op2$[rsp], eax

; 4633 : 
; 4634 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4635 :     if (0
; 4636 :         || !(op1.v & 0x007FFFFF)
; 4637 :         || ((op1.v & 0x7F800000) ^ 0x7F800000)

  001e4	33 c0		 xor	 eax, eax
  001e6	85 c0		 test	 eax, eax
  001e8	75 1f		 jne	 SHORT $LN14@s390_multi
  001ea	8b 44 24 24	 mov	 eax, DWORD PTR op1$[rsp]
  001ee	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001f3	85 c0		 test	 eax, eax
  001f5	74 12		 je	 SHORT $LN14@s390_multi
  001f7	8b 44 24 24	 mov	 eax, DWORD PTR op1$[rsp]
  001fb	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00200	35 00 00 80 7f	 xor	 eax, 2139095040		; 7f800000H
  00205	85 c0		 test	 eax, eax
  00207	74 0c		 je	 SHORT $LN13@s390_multi
$LN14@s390_multi:

; 4638 :     )
; 4639 :         op1.v ^= 0x80000000;

  00209	8b 44 24 24	 mov	 eax, DWORD PTR op1$[rsp]
  0020d	0f ba f8 1f	 btc	 eax, 31
  00211	89 44 24 24	 mov	 DWORD PTR op1$[rsp], eax
$LN13@s390_multi:

; 4640 : 
; 4641 :     softfloat_exceptionFlags = 0;

  00215	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021a	8b c0		 mov	 eax, eax
  0021c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00222	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022f	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4642 :     SET_SF_RM_FROM_FPC;

  00233	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00238	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0023e	83 e0 07	 and	 eax, 7
  00241	8b c0		 mov	 eax, eax
  00243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0024a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0024f	8b d2		 mov	 edx, edx
  00251	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00258	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00261	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00265	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00269	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4643 : 
; 4644 :     ans = f32_mulAdd( op2, op3, op1 );

  0026d	44 8b 44 24 24	 mov	 r8d, DWORD PTR op1$[rsp]
  00272	8b 54 24 48	 mov	 edx, DWORD PTR op3$[rsp]
  00276	8b 4c 24 4c	 mov	 ecx, DWORD PTR op2$[rsp]
  0027a	e8 00 00 00 00	 call	 f32_mulAdd
  0027f	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax

; 4645 : 
; 4646 :     if (softfloat_exceptionFlags)

  00283	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00288	8b c0		 mov	 eax, eax
  0028a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00290	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00299	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a1	85 c0		 test	 eax, eax
  002a3	0f 84 93 00 00
	00		 je	 $LN15@s390_multi

; 4647 :     {
; 4648 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002a9	33 c0		 xor	 eax, eax
  002ab	83 f8 01	 cmp	 eax, 1
  002ae	74 45		 je	 SHORT $LN16@s390_multi
  002b0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002b5	8b c0		 mov	 eax, eax
  002b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002bd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002c6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ce	83 e0 10	 and	 eax, 16
  002d1	85 c0		 test	 eax, eax
  002d3	74 20		 je	 SHORT $LN16@s390_multi
  002d5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002da	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002e0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002e5	85 c0		 test	 eax, eax
  002e7	74 0c		 je	 SHORT $LN16@s390_multi
  002e9	b2 80		 mov	 dl, 128			; 00000080H
  002eb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	e8 00 00 00 00	 call	 ieee_trap
$LN16@s390_multi:

; 4649 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fa	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002ff	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4650 : 
; 4651 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00303	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00307	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0030c	85 c0		 test	 eax, eax
  0030e	74 2c		 je	 SHORT $LN17@s390_multi

; 4652 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00310	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00314	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00319	85 c0		 test	 eax, eax
  0031b	74 0a		 je	 SHORT $LN20@s390_multi
  0031d	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv231[rsp], -192 ; ffffffffffffff40H
  00325	eb 08		 jmp	 SHORT $LN21@s390_multi
$LN20@s390_multi:
  00327	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv231[rsp], 192 ; 000000c0H
$LN21@s390_multi:
  0032f	8b 4c 24 38	 mov	 ecx, DWORD PTR tv231[rsp]
  00333	e8 00 00 00 00	 call	 f32_scaledResult
  00338	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax
$LN17@s390_multi:
$LN15@s390_multi:

; 4653 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4654 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4655 :     }
; 4656 : 
; 4657 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  0033c	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00340	d1 e0		 shl	 eax, 1
  00342	48 98		 cdqe
  00344	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00349	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00351	48 8b d0	 mov	 rdx, rax
  00354	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  00359	e8 00 00 00 00	 call	 s390_put_float32

; 4658 : 
; 4659 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0035e	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00362	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00367	85 c0		 test	 eax, eax
  00369	74 0e		 je	 SHORT $LN18@s390_multi
  0036b	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0036f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00374	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@s390_multi:

; 4660 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4661 : }

  00379	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0037d	c3		 ret	 0
s390_multiply_subtract_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv212 = 40
r1$ = 44
op1$ = 48
r3$ = 56
r2$ = 60
ans$ = 64
op3$ = 72
op2$ = 80
inst$ = 112
regs$ = 120
s390_multiply_subtract_bfp_long_reg PROC

; 4483 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4484 :     int        r1, r2, r3;
; 4485 :     float64_t  op1, op2, op3, ans;
; 4486 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4487 : 
; 4488 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 3c	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  00052	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN8@s390_multi
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@s390_multi

; 4489 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4490 :     BFPINST_CHECK( regs );

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00096	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009b	85 c0		 test	 eax, eax
  0009d	74 39		 je	 SHORT $LN10@s390_multi
  0009f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000aa	d1 e8		 shr	 eax, 1
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 49		 je	 SHORT $LN9@s390_multi
  000b3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000d4	85 c0		 test	 eax, eax
  000d6	75 24		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e7	ba 07 00 00 00	 mov	 edx, 7
  000ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:
$LN7@s390_multi:

; 4491 : 
; 4492 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  000fc	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00100	d1 e0		 shl	 eax, 1
  00102	48 98		 cdqe
  00104	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00119	e8 00 00 00 00	 call	 s390_get_float64
  0011e	8b 44 24 38	 mov	 eax, DWORD PTR r3$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_get_float64
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 b6		 jne	 SHORT $LN7@s390_multi

; 4493 :     GET_FLOAT64_OP( op2, r2, regs );

  00146	8b 44 24 3c	 mov	 eax, DWORD PTR r2$[rsp]
  0014a	d1 e0		 shl	 eax, 1
  0014c	48 98		 cdqe
  0014e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  00163	e8 00 00 00 00	 call	 s390_get_float64

; 4494 : 
; 4495 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4496 :     if (0
; 4497 :         || !(op1.v & 0x000FFFFFFFFFFFFF)
; 4498 :         || ((op1.v & 0x7FF0000000000000) ^ 0x7FF0000000000000)

  00168	33 c0		 xor	 eax, eax
  0016a	85 c0		 test	 eax, eax
  0016c	75 41		 jne	 SHORT $LN12@s390_multi
  0016e	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00178	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  0017d	48 23 c8	 and	 rcx, rax
  00180	48 8b c1	 mov	 rax, rcx
  00183	48 85 c0	 test	 rax, rax
  00186	74 27		 je	 SHORT $LN12@s390_multi
  00188	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00192	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00197	48 23 c8	 and	 rcx, rax
  0019a	48 8b c1	 mov	 rax, rcx
  0019d	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001a7	48 33 c1	 xor	 rax, rcx
  001aa	48 85 c0	 test	 rax, rax
  001ad	74 1a		 je	 SHORT $LN11@s390_multi
$LN12@s390_multi:

; 4499 :     )
; 4500 :         op1.v ^= 0x8000000000000000ULL;

  001af	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  001be	48 33 c8	 xor	 rcx, rax
  001c1	48 8b c1	 mov	 rax, rcx
  001c4	48 89 44 24 30	 mov	 QWORD PTR op1$[rsp], rax
$LN11@s390_multi:

; 4501 : 
; 4502 :     softfloat_exceptionFlags = 0;

  001c9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ce	8b c0		 mov	 eax, eax
  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001df	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4503 :     SET_SF_RM_FROM_FPC;

  001e7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ec	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f2	83 e0 07	 and	 eax, 7
  001f5	8b c0		 mov	 eax, eax
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001fe	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00203	8b d2		 mov	 edx, edx
  00205	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0020c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00215	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00219	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4504 : 
; 4505 :     ans = f64_mulAdd( op2, op3, op1 );

  00221	4c 8b 44 24 30	 mov	 r8, QWORD PTR op1$[rsp]
  00226	48 8b 54 24 48	 mov	 rdx, QWORD PTR op3$[rsp]
  0022b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  00230	e8 00 00 00 00	 call	 f64_mulAdd
  00235	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 4506 : 
; 4507 :     if (softfloat_exceptionFlags)

  0023a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023f	8b c0		 mov	 eax, eax
  00241	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00247	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00250	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00254	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00258	85 c0		 test	 eax, eax
  0025a	0f 84 94 00 00
	00		 je	 $LN13@s390_multi

; 4508 :     {
; 4509 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00260	33 c0		 xor	 eax, eax
  00262	83 f8 01	 cmp	 eax, 1
  00265	74 45		 je	 SHORT $LN14@s390_multi
  00267	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0026c	8b c0		 mov	 eax, eax
  0026e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00274	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00281	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00285	83 e0 10	 and	 eax, 16
  00288	85 c0		 test	 eax, eax
  0028a	74 20		 je	 SHORT $LN14@s390_multi
  0028c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00291	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00297	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0029c	85 c0		 test	 eax, eax
  0029e	74 0c		 je	 SHORT $LN14@s390_multi
  002a0	b2 80		 mov	 dl, 128			; 00000080H
  002a2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002a7	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_multi:

; 4510 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ac	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002b1	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002b6	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4511 : 
; 4512 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ba	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002be	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002c3	85 c0		 test	 eax, eax
  002c5	74 2d		 je	 SHORT $LN15@s390_multi

; 4513 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002c7	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cb	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002d0	85 c0		 test	 eax, eax
  002d2	74 0a		 je	 SHORT $LN18@s390_multi
  002d4	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv212[rsp], -1536 ; fffffffffffffa00H
  002dc	eb 08		 jmp	 SHORT $LN19@s390_multi
$LN18@s390_multi:
  002de	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv212[rsp], 1536 ; 00000600H
$LN19@s390_multi:
  002e6	8b 4c 24 28	 mov	 ecx, DWORD PTR tv212[rsp]
  002ea	e8 00 00 00 00	 call	 f64_scaledResult
  002ef	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN15@s390_multi:
$LN13@s390_multi:

; 4514 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4515 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4516 :     }
; 4517 : 
; 4518 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  002f4	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002f8	d1 e0		 shl	 eax, 1
  002fa	48 98		 cdqe
  002fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00301	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00309	48 8b d0	 mov	 rdx, rax
  0030c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  00311	e8 00 00 00 00	 call	 s390_put_float64

; 4519 : 
; 4520 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00316	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0031a	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0031f	85 c0		 test	 eax, eax
  00321	74 0e		 je	 SHORT $LN16@s390_multi
  00323	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00327	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0032c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_multi:

; 4521 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4522 : }

  00331	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00335	c3		 ret	 0
s390_multiply_subtract_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv231 = 52
r1$ = 56
op1$ = 64
r3$ = 72
ans$ = 80
op3$ = 88
op2$ = 96
inst$ = 128
regs$ = 136
s390_multiply_subtract_bfp_long PROC

; 4528 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4529 :     int        x2, r1, r3, b2;
; 4530 :     VADR       effective_addr2;
; 4531 :     float64_t  op1, op2, op3, ans;
; 4532 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4533 : 
; 4534 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 04	 imul	 rax, rax, 4
  00037	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00043	c1 f8 04	 sar	 eax, 4
  00046	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  0004a	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00053	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00057	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	c1 e8 10	 shr	 eax, 16
  0005e	83 e0 0f	 and	 eax, 15
  00061	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00065	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00069	c1 e8 14	 shr	 eax, 20
  0006c	83 e0 0f	 and	 eax, 15
  0006f	89 44 24 48	 mov	 DWORD PTR r3$[rsp], eax
  00073	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00078	74 20		 je	 SHORT $LN8@s390_multi
  0007a	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0007f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0008e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00092	03 c8		 add	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s390_multi:
  0009a	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0009e	c1 e8 0c	 shr	 eax, 12
  000a1	83 e0 0f	 and	 eax, 15
  000a4	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  000a8	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ad	74 20		 je	 SHORT $LN9@s390_multi
  000af	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c3	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000c7	03 c8		 add	 ecx, eax
  000c9	8b c1		 mov	 eax, ecx
  000cb	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_multi:
  000cf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000dd	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000e1	23 c8		 and	 ecx, eax
  000e3	8b c1		 mov	 eax, ecx
  000e5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_multi:
  000e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f5	48 83 c0 06	 add	 rax, 6
  000f9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00105	33 c0		 xor	 eax, eax
  00107	83 f8 06	 cmp	 eax, 6
  0010a	74 0f		 je	 SHORT $LN10@s390_multi
  0010c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_multi:
  0011b	33 c0		 xor	 eax, eax
  0011d	85 c0		 test	 eax, eax
  0011f	75 c8		 jne	 SHORT $LN4@s390_multi

; 4535 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4536 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4537 :     BFPINST_CHECK( regs );

  00121	b8 08 00 00 00	 mov	 eax, 8
  00126	48 6b c0 01	 imul	 rax, rax, 1
  0012a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00139	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013e	85 c0		 test	 eax, eax
  00140	74 3f		 je	 SHORT $LN12@s390_multi
  00142	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00150	d1 e8		 shr	 eax, 1
  00152	83 e0 01	 and	 eax, 1
  00155	85 c0		 test	 eax, eax
  00157	74 55		 je	 SHORT $LN11@s390_multi
  00159	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00161	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00168	b9 08 00 00 00	 mov	 ecx, 8
  0016d	48 6b c9 01	 imul	 rcx, rcx, 1
  00171	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00178	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0017d	85 c0		 test	 eax, eax
  0017f	75 2d		 jne	 SHORT $LN11@s390_multi
$LN12@s390_multi:
  00181	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00189	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00193	ba 07 00 00 00	 mov	 edx, 7
  00198	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_multi:
$LN7@s390_multi:

; 4538 : 
; 4539 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  001ae	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001b2	d1 e0		 shl	 eax, 1
  001b4	48 98		 cdqe
  001b6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001be	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001c6	48 8b d0	 mov	 rdx, rax
  001c9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  001ce	e8 00 00 00 00	 call	 s390_get_float64
  001d3	8b 44 24 48	 mov	 eax, DWORD PTR r3$[rsp]
  001d7	d1 e0		 shl	 eax, 1
  001d9	48 98		 cdqe
  001db	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001eb	48 8b d0	 mov	 rdx, rax
  001ee	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op3$[rsp]
  001f3	e8 00 00 00 00	 call	 s390_get_float64
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	75 b0		 jne	 SHORT $LN7@s390_multi

; 4540 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001fe	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00206	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0020a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0020e	e8 00 00 00 00	 call	 s390_vfetch8
  00213	48 89 44 24 60	 mov	 QWORD PTR op2$[rsp], rax

; 4541 : 
; 4542 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4543 :     if (0
; 4544 :         || !(op1.v & 0x000FFFFFFFFFFFFF)
; 4545 :         || ((op1.v & 0x7FF0000000000000) ^ 0x7FF0000000000000)

  00218	33 c0		 xor	 eax, eax
  0021a	85 c0		 test	 eax, eax
  0021c	75 41		 jne	 SHORT $LN14@s390_multi
  0021e	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00228	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0022d	48 23 c8	 and	 rcx, rax
  00230	48 8b c1	 mov	 rax, rcx
  00233	48 85 c0	 test	 rax, rax
  00236	74 27		 je	 SHORT $LN14@s390_multi
  00238	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00242	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00247	48 23 c8	 and	 rcx, rax
  0024a	48 8b c1	 mov	 rax, rcx
  0024d	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00257	48 33 c1	 xor	 rax, rcx
  0025a	48 85 c0	 test	 rax, rax
  0025d	74 1a		 je	 SHORT $LN13@s390_multi
$LN14@s390_multi:

; 4546 :     )
; 4547 :         op1.v ^= 0x8000000000000000ULL;

  0025f	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00269	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0026e	48 33 c8	 xor	 rcx, rax
  00271	48 8b c1	 mov	 rax, rcx
  00274	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax
$LN13@s390_multi:

; 4548 : 
; 4549 :     softfloat_exceptionFlags = 0;

  00279	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0027e	8b c0		 mov	 eax, eax
  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00286	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0028f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00293	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4550 :     SET_SF_RM_FROM_FPC;

  00297	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002a5	83 e0 07	 and	 eax, 7
  002a8	8b c0		 mov	 eax, eax
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002b1	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  002b6	8b d2		 mov	 edx, edx
  002b8	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  002bf	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  002c8	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  002cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d0	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4551 : 
; 4552 :     ans = f64_mulAdd( op2, op3, op1 );

  002d4	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  002d9	48 8b 54 24 58	 mov	 rdx, QWORD PTR op3$[rsp]
  002de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op2$[rsp]
  002e3	e8 00 00 00 00	 call	 f64_mulAdd
  002e8	48 89 44 24 50	 mov	 QWORD PTR ans$[rsp], rax

; 4553 : 
; 4554 :     if (softfloat_exceptionFlags)

  002ed	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002f2	8b c0		 mov	 eax, eax
  002f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002fa	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00303	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00307	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0030b	85 c0		 test	 eax, eax
  0030d	0f 84 9d 00 00
	00		 je	 $LN15@s390_multi

; 4555 :     {
; 4556 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00313	33 c0		 xor	 eax, eax
  00315	83 f8 01	 cmp	 eax, 1
  00318	74 4b		 je	 SHORT $LN16@s390_multi
  0031a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0031f	8b c0		 mov	 eax, eax
  00321	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00327	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00330	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00334	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00338	83 e0 10	 and	 eax, 16
  0033b	85 c0		 test	 eax, eax
  0033d	74 26		 je	 SHORT $LN16@s390_multi
  0033f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00347	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0034d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00352	85 c0		 test	 eax, eax
  00354	74 0f		 je	 SHORT $LN16@s390_multi
  00356	b2 80		 mov	 dl, 128			; 00000080H
  00358	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00360	e8 00 00 00 00	 call	 ieee_trap
$LN16@s390_multi:

; 4557 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00365	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036d	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00372	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4558 : 
; 4559 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00376	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0037a	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0037f	85 c0		 test	 eax, eax
  00381	74 2d		 je	 SHORT $LN17@s390_multi

; 4560 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00383	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00387	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0038c	85 c0		 test	 eax, eax
  0038e	74 0a		 je	 SHORT $LN20@s390_multi
  00390	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv231[rsp], -1536 ; fffffffffffffa00H
  00398	eb 08		 jmp	 SHORT $LN21@s390_multi
$LN20@s390_multi:
  0039a	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv231[rsp], 1536 ; 00000600H
$LN21@s390_multi:
  003a2	8b 4c 24 34	 mov	 ecx, DWORD PTR tv231[rsp]
  003a6	e8 00 00 00 00	 call	 f64_scaledResult
  003ab	48 89 44 24 50	 mov	 QWORD PTR ans$[rsp], rax
$LN17@s390_multi:
$LN15@s390_multi:

; 4561 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4562 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4563 :     }
; 4564 : 
; 4565 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  003b0	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  003b4	d1 e0		 shl	 eax, 1
  003b6	48 98		 cdqe
  003b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003c8	48 8b d0	 mov	 rdx, rax
  003cb	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ans$[rsp]
  003d0	e8 00 00 00 00	 call	 s390_put_float64

; 4566 : 
; 4567 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003d5	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003d9	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003de	85 c0		 test	 eax, eax
  003e0	74 11		 je	 SHORT $LN18@s390_multi
  003e2	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003e6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ee	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@s390_multi:

; 4568 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4569 : }

  003f3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003f7	c3		 ret	 0
s390_multiply_subtract_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
op1$ = 44
op2$ = 48
ans$ = 56
iop2$ = 64
iop1$ = 72
inst$ = 96
regs$ = 104
s390_multiply_bfp_short_to_long_reg PROC

; 4145 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4146 :     int        r1, r2;
; 4147 :     float32_t  op1, op2;
; 4148 :     float64_t  iop1, iop2, ans;
; 4149 : 
; 4150 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_multi
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_multi

; 4151 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4152 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_multi
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_multi
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:
$LN7@s390_multi:

; 4153 : 
; 4154 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float32
  00109	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s390_get_float32
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s390_multi

; 4155 : 
; 4156 :     /* f32_to_f64 will, if presented with a SNaN, convert it to quiet
; 4157 :        and raise softfloat_flags_invalid.  Unfortunately, if one of
; 4158 :        the operands is an SNaN and the other a QNaN, f64_mul() will be
; 4159 :        unable to do NaN propagation correctly because it will see only
; 4160 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 4161 :        input operands, that becomes the answer.  If both operands are
; 4162 :        QNaNs, then f64_mul() will be able to do NaN propagation correctly.
; 4163 :     */
; 4164 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4165 :     softfloat_roundingMode = softfloat_round_near_even;

  0014f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00154	8b c0		 mov	 eax, eax
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0015c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00165	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00169	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4166 : 
; 4167 :     iop1 = f32_to_f64( op1 );

  0016d	8b 4c 24 2c	 mov	 ecx, DWORD PTR op1$[rsp]
  00171	e8 00 00 00 00	 call	 f32_to_f64
  00176	48 89 44 24 48	 mov	 QWORD PTR iop1$[rsp], rax

; 4168 : 
; 4169 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0017b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00180	8b c0		 mov	 eax, eax
  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00188	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00191	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00195	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00199	83 e0 10	 and	 eax, 16
  0019c	85 c0		 test	 eax, eax
  0019e	74 0c		 je	 SHORT $LN11@s390_multi

; 4170 :         ans = iop1;

  001a0	48 8b 44 24 48	 mov	 rax, QWORD PTR iop1$[rsp]
  001a5	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
  001aa	eb 53		 jmp	 SHORT $LN12@s390_multi
$LN11@s390_multi:

; 4171 :     else
; 4172 :     {
; 4173 :         iop2 = f32_to_f64( op2 );

  001ac	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 f32_to_f64
  001b5	48 89 44 24 40	 mov	 QWORD PTR iop2$[rsp], rax

; 4174 : 
; 4175 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  001ba	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001bf	8b c0		 mov	 eax, eax
  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d8	83 e0 10	 and	 eax, 16
  001db	85 c0		 test	 eax, eax
  001dd	74 0c		 je	 SHORT $LN13@s390_multi

; 4176 :             ans = iop2;

  001df	48 8b 44 24 40	 mov	 rax, QWORD PTR iop2$[rsp]
  001e4	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
  001e9	eb 14		 jmp	 SHORT $LN14@s390_multi
$LN13@s390_multi:

; 4177 :         else
; 4178 :             ans = f64_mul( iop1, iop2 );

  001eb	48 8b 54 24 40	 mov	 rdx, QWORD PTR iop2$[rsp]
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR iop1$[rsp]
  001f5	e8 00 00 00 00	 call	 f64_mul
  001fa	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN14@s390_multi:
$LN12@s390_multi:

; 4179 :     }
; 4180 : 
; 4181 :     if (softfloat_exceptionFlags)

  001ff	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00204	8b c0		 mov	 eax, eax
  00206	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00215	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00219	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021d	85 c0		 test	 eax, eax
  0021f	0f 84 9e 00 00
	00		 je	 $LN15@s390_multi

; 4182 :     {
; 4183 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00225	33 c0		 xor	 eax, eax
  00227	83 f8 01	 cmp	 eax, 1
  0022a	74 45		 je	 SHORT $LN16@s390_multi
  0022c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00231	8b c0		 mov	 eax, eax
  00233	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00239	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00242	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00246	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024a	83 e0 10	 and	 eax, 16
  0024d	85 c0		 test	 eax, eax
  0024f	74 20		 je	 SHORT $LN16@s390_multi
  00251	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00256	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0025c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00261	85 c0		 test	 eax, eax
  00263	74 0c		 je	 SHORT $LN16@s390_multi
  00265	b2 80		 mov	 dl, 128			; 00000080H
  00267	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	e8 00 00 00 00	 call	 ieee_trap
$LN16@s390_multi:

; 4184 :         SET_FPC_FLAGS_FROM_SF( regs );

  00271	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00276	8b c0		 mov	 eax, eax
  00278	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0027e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00287	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0028b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028f	c1 e0 13	 shl	 eax, 19
  00292	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00297	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0029d	c1 e9 08	 shr	 ecx, 8
  002a0	f7 d1		 not	 ecx
  002a2	23 c1		 and	 eax, ecx
  002a4	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ae	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002b4	0b c8		 or	 ecx, eax
  002b6	8b c1		 mov	 eax, ecx
  002b8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN15@s390_multi:

; 4185 :     }
; 4186 : 
; 4187 :     PUT_FLOAT64_NOCC(ans, r1, regs);

  002c3	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  002c7	d1 e0		 shl	 eax, 1
  002c9	48 98		 cdqe
  002cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002d0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d8	48 8b d0	 mov	 rdx, rax
  002db	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  002e0	e8 00 00 00 00	 call	 s390_put_float64

; 4188 : }

  002e5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002e9	c3		 ret	 0
s390_multiply_bfp_short_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
r1$ = 48
op1$ = 52
op2$ = 56
ans$ = 64
iop2$ = 72
iop1$ = 80
inst$ = 112
regs$ = 120
s390_multiply_bfp_short_to_long PROC

; 4198 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4199 :     int        r1, x2, b2;
; 4200 :     VADR       effective_addr2;
; 4201 :     float32_t  op1, op2;
; 4202 :     float64_t  iop1, iop2, ans;
; 4203 : 
; 4204 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s390_multi
  00053	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_multi:
  00070	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s390_multi
  00085	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_multi:
  000a2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b1	23 c8		 and	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_multi:
  000b9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 83 c0 06	 add	 rax, 6
  000c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cf	33 c0		 xor	 eax, eax
  000d1	83 f8 06	 cmp	 eax, 6
  000d4	74 0c		 je	 SHORT $LN7@s390_multi
  000d6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_multi:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 d1		 jne	 SHORT $LN4@s390_multi

; 4205 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4206 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4207 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00102	85 c0		 test	 eax, eax
  00104	74 39		 je	 SHORT $LN9@s390_multi
  00106	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 49		 je	 SHORT $LN8@s390_multi
  0011a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00126	b9 08 00 00 00	 mov	 ecx, 8
  0012b	48 6b c9 01	 imul	 rcx, rcx, 1
  0012f	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00136	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 24		 jne	 SHORT $LN8@s390_multi
$LN9@s390_multi:
  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014e	ba 07 00 00 00	 mov	 edx, 7
  00153	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_multi:

; 4208 : 
; 4209 :     GET_FLOAT32_OP( op1, r1, regs );

  00163	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00167	d1 e0		 shl	 eax, 1
  00169	48 98		 cdqe
  0016b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00178	48 8b d0	 mov	 rdx, rax
  0017b	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00180	e8 00 00 00 00	 call	 s390_get_float32

; 4210 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00185	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0018a	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  0018e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00192	e8 00 00 00 00	 call	 s390_vfetch4
  00197	89 44 24 38	 mov	 DWORD PTR op2$[rsp], eax

; 4211 : 
; 4212 :     /* f32_to_f64 will, if presented with a SNaN, convert it to quiet
; 4213 :        and raise softfloat_flags_invalid.  Unfortunately, if one of the
; 4214 :        operands is an SNaN and the other a QNaN, f64_mul() will be
; 4215 :        unable to do NaN propagation correctly because it will see only
; 4216 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 4217 :        input operands, that becomes the answer.  If both operands are
; 4218 :        QNaNs, then f64_mul() will be able to do NaN propagation correctly.
; 4219 :     */
; 4220 :     softfloat_exceptionFlags = 0;

  0019b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a0	8b c0		 mov	 eax, eax
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4221 :     softfloat_roundingMode = softfloat_round_near_even;

  001b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001be	8b c0		 mov	 eax, eax
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001cf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4222 : 
; 4223 :     iop1 = f32_to_f64( op1 );

  001d7	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  001db	e8 00 00 00 00	 call	 f32_to_f64
  001e0	48 89 44 24 50	 mov	 QWORD PTR iop1$[rsp], rax

; 4224 : 
; 4225 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  001e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ea	8b c0		 mov	 eax, eax
  001ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00203	83 e0 10	 and	 eax, 16
  00206	85 c0		 test	 eax, eax
  00208	74 0c		 je	 SHORT $LN10@s390_multi

; 4226 :         ans = iop1;

  0020a	48 8b 44 24 50	 mov	 rax, QWORD PTR iop1$[rsp]
  0020f	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
  00214	eb 53		 jmp	 SHORT $LN11@s390_multi
$LN10@s390_multi:

; 4227 :     else
; 4228 :     {
; 4229 :         iop2 = f32_to_f64( op2 );

  00216	8b 4c 24 38	 mov	 ecx, DWORD PTR op2$[rsp]
  0021a	e8 00 00 00 00	 call	 f32_to_f64
  0021f	48 89 44 24 48	 mov	 QWORD PTR iop2$[rsp], rax

; 4230 : 
; 4231 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00224	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00229	8b c0		 mov	 eax, eax
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00231	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00242	83 e0 10	 and	 eax, 16
  00245	85 c0		 test	 eax, eax
  00247	74 0c		 je	 SHORT $LN12@s390_multi

; 4232 :             ans = iop2;

  00249	48 8b 44 24 48	 mov	 rax, QWORD PTR iop2$[rsp]
  0024e	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
  00253	eb 14		 jmp	 SHORT $LN13@s390_multi
$LN12@s390_multi:

; 4233 :         else
; 4234 :             ans = f64_mul( iop1, iop2 );

  00255	48 8b 54 24 48	 mov	 rdx, QWORD PTR iop2$[rsp]
  0025a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR iop1$[rsp]
  0025f	e8 00 00 00 00	 call	 f64_mul
  00264	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN13@s390_multi:
$LN11@s390_multi:

; 4235 :     }
; 4236 : 
; 4237 :     if (softfloat_exceptionFlags)

  00269	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0026e	8b c0		 mov	 eax, eax
  00270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00276	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00283	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00287	85 c0		 test	 eax, eax
  00289	0f 84 9e 00 00
	00		 je	 $LN14@s390_multi

; 4238 :     {
; 4239 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0028f	33 c0		 xor	 eax, eax
  00291	83 f8 01	 cmp	 eax, 1
  00294	74 45		 je	 SHORT $LN15@s390_multi
  00296	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0029b	8b c0		 mov	 eax, eax
  0029d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ac	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b4	83 e0 10	 and	 eax, 16
  002b7	85 c0		 test	 eax, eax
  002b9	74 20		 je	 SHORT $LN15@s390_multi
  002bb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002c0	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002cb	85 c0		 test	 eax, eax
  002cd	74 0c		 je	 SHORT $LN15@s390_multi
  002cf	b2 80		 mov	 dl, 128			; 00000080H
  002d1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 ieee_trap
$LN15@s390_multi:

; 4240 :         SET_FPC_FLAGS_FROM_SF( regs );

  002db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e0	8b c0		 mov	 eax, eax
  002e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f9	c1 e0 13	 shl	 eax, 19
  002fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00301	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00307	c1 e9 08	 shr	 ecx, 8
  0030a	f7 d1		 not	 ecx
  0030c	23 c1		 and	 eax, ecx
  0030e	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00313	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00318	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0031e	0b c8		 or	 ecx, eax
  00320	8b c1		 mov	 eax, ecx
  00322	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00327	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN14@s390_multi:

; 4241 :     }
; 4242 : 
; 4243 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  0032d	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00331	d1 e0		 shl	 eax, 1
  00333	48 98		 cdqe
  00335	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0033a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00342	48 8b d0	 mov	 rdx, rax
  00345	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  0034a	e8 00 00 00 00	 call	 s390_put_float64

; 4244 : }

  0034f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00353	c3		 ret	 0
s390_multiply_bfp_short_to_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv194 = 40
r1$ = 44
ans$ = 48
r2$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s390_multiply_bfp_short_reg PROC

; 4250 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4251 :     int        r1, r2;
; 4252 :     float32_t  op1, op2, ans;
; 4253 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4254 : 
; 4255 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@s390_multi
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_multi

; 4256 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4257 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN10@s390_multi
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN9@s390_multi
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:
$LN7@s390_multi:

; 4258 : 
; 4259 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float32
  00111	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s390_get_float32
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s390_multi

; 4260 : 
; 4261 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4262 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4263 : 
; 4264 :     ans = f32_mul( op1, op2 );

  00191	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00195	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  00199	e8 00 00 00 00	 call	 f32_mul
  0019e	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 4265 : 
; 4266 :     if (softfloat_exceptionFlags)

  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a7	8b c0		 mov	 eax, eax
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 93 00 00
	00		 je	 $LN11@s390_multi

; 4267 :     {
; 4268 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001c8	33 c0		 xor	 eax, eax
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	74 45		 je	 SHORT $LN12@s390_multi
  001cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d4	8b c0		 mov	 eax, eax
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	83 e0 10	 and	 eax, 16
  001f0	85 c0		 test	 eax, eax
  001f2	74 20		 je	 SHORT $LN12@s390_multi
  001f4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ff	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00204	85 c0		 test	 eax, eax
  00206	74 0c		 je	 SHORT $LN12@s390_multi
  00208	b2 80		 mov	 dl, 128			; 00000080H
  0020a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_multi:

; 4269 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00214	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0021e	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4270 : 
; 4271 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00222	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00226	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022b	85 c0		 test	 eax, eax
  0022d	74 2c		 je	 SHORT $LN13@s390_multi

; 4272 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0022f	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00233	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN16@s390_multi
  0023c	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv194[rsp], -192 ; ffffffffffffff40H
  00244	eb 08		 jmp	 SHORT $LN17@s390_multi
$LN16@s390_multi:
  00246	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv194[rsp], 192 ; 000000c0H
$LN17@s390_multi:
  0024e	8b 4c 24 28	 mov	 ecx, DWORD PTR tv194[rsp]
  00252	e8 00 00 00 00	 call	 f32_scaledResult
  00257	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN13@s390_multi:
$LN11@s390_multi:

; 4273 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4274 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4275 :     }
; 4276 : 
; 4277 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  0025b	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0025f	d1 e0		 shl	 eax, 1
  00261	48 98		 cdqe
  00263	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00270	48 8b d0	 mov	 rdx, rax
  00273	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  00278	e8 00 00 00 00	 call	 s390_put_float32

; 4278 : 
; 4279 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0027d	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00281	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00286	85 c0		 test	 eax, eax
  00288	74 0e		 je	 SHORT $LN14@s390_multi
  0028a	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0028e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s390_multi:

; 4280 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4281 : }

  00298	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0029c	c3		 ret	 0
s390_multiply_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv211 = 52
r1$ = 56
ans$ = 60
op2$ = 64
op1$ = 68
inst$ = 96
regs$ = 104
s390_multiply_bfp_short PROC

; 4287 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4288 :     int        r1, x2, b2;
; 4289 :     VADR       effective_addr2;
; 4290 :     float32_t  op1, op2, ans;
; 4291 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4292 : 
; 4293 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s390_multi
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_multi:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s390_multi
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_multi:
  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_multi:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ca	48 83 c0 06	 add	 rax, 6
  000ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 06	 cmp	 eax, 6
  000dc	74 0c		 je	 SHORT $LN7@s390_multi
  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_multi:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 d1		 jne	 SHORT $LN4@s390_multi

; 4294 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4295 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4296 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00105	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $LN9@s390_multi
  0010e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00113	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00119	d1 e8		 shr	 eax, 1
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 49		 je	 SHORT $LN8@s390_multi
  00122	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	48 6b c9 01	 imul	 rcx, rcx, 1
  00137	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0013e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN8@s390_multi
$LN9@s390_multi:
  00147	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00156	ba 07 00 00 00	 mov	 edx, 7
  0015b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00165	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_multi:

; 4297 : 
; 4298 :     GET_FLOAT32_OP( op1, r1, regs );

  0016b	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0016f	d1 e0		 shl	 eax, 1
  00171	48 98		 cdqe
  00173	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00180	48 8b d0	 mov	 rdx, rax
  00183	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op1$[rsp]
  00188	e8 00 00 00 00	 call	 s390_get_float32

; 4299 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0018d	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00192	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00196	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019a	e8 00 00 00 00	 call	 s390_vfetch4
  0019f	89 44 24 40	 mov	 DWORD PTR op2$[rsp], eax

; 4300 : 
; 4301 :     softfloat_exceptionFlags = 0;

  001a3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a8	8b c0		 mov	 eax, eax
  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4302 :     SET_SF_RM_FROM_FPC;

  001c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cc	83 e0 07	 and	 eax, 7
  001cf	8b c0		 mov	 eax, eax
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001dd	8b d2		 mov	 edx, edx
  001df	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001e6	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001ef	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f7	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4303 : 
; 4304 :     ans = f32_mul( op1, op2 );

  001fb	8b 54 24 40	 mov	 edx, DWORD PTR op2$[rsp]
  001ff	8b 4c 24 44	 mov	 ecx, DWORD PTR op1$[rsp]
  00203	e8 00 00 00 00	 call	 f32_mul
  00208	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax

; 4305 : 
; 4306 :     if (softfloat_exceptionFlags)

  0020c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00211	8b c0		 mov	 eax, eax
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00219	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00222	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00226	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022a	85 c0		 test	 eax, eax
  0022c	0f 84 93 00 00
	00		 je	 $LN10@s390_multi

; 4307 :     {
; 4308 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00232	33 c0		 xor	 eax, eax
  00234	83 f8 01	 cmp	 eax, 1
  00237	74 45		 je	 SHORT $LN11@s390_multi
  00239	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023e	8b c0		 mov	 eax, eax
  00240	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00246	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00253	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00257	83 e0 10	 and	 eax, 16
  0025a	85 c0		 test	 eax, eax
  0025c	74 20		 je	 SHORT $LN11@s390_multi
  0025e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00263	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00269	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0026e	85 c0		 test	 eax, eax
  00270	74 0c		 je	 SHORT $LN11@s390_multi
  00272	b2 80		 mov	 dl, 128			; 00000080H
  00274	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_multi:

; 4309 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0027e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00283	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00288	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4310 : 
; 4311 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0028c	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00290	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00295	85 c0		 test	 eax, eax
  00297	74 2c		 je	 SHORT $LN12@s390_multi

; 4312 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00299	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0029d	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002a2	85 c0		 test	 eax, eax
  002a4	74 0a		 je	 SHORT $LN15@s390_multi
  002a6	c7 44 24 34 40
	ff ff ff	 mov	 DWORD PTR tv211[rsp], -192 ; ffffffffffffff40H
  002ae	eb 08		 jmp	 SHORT $LN16@s390_multi
$LN15@s390_multi:
  002b0	c7 44 24 34 c0
	00 00 00	 mov	 DWORD PTR tv211[rsp], 192 ; 000000c0H
$LN16@s390_multi:
  002b8	8b 4c 24 34	 mov	 ecx, DWORD PTR tv211[rsp]
  002bc	e8 00 00 00 00	 call	 f32_scaledResult
  002c1	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax
$LN12@s390_multi:
$LN10@s390_multi:

; 4313 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4314 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4315 :     }
; 4316 : 
; 4317 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  002c5	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002c9	d1 e0		 shl	 eax, 1
  002cb	48 98		 cdqe
  002cd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002da	48 8b d0	 mov	 rdx, rax
  002dd	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR ans$[rsp]
  002e2	e8 00 00 00 00	 call	 s390_put_float32

; 4318 : 
; 4319 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002e7	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002eb	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002f0	85 c0		 test	 eax, eax
  002f2	74 0e		 je	 SHORT $LN13@s390_multi
  002f4	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002f8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fd	e8 00 00 00 00	 call	 ieee_cond_trap
$LN13@s390_multi:

; 4320 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4321 : }

  00302	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00306	c3		 ret	 0
s390_multiply_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
r1$ = 32
i$1 = 36
r2$ = 40
op1$ = 48
op2$ = 56
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
ans$ = 144
iop2$ = 160
iop1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
s390_multiply_bfp_long_to_ext_reg PROC

; 3958 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3959 :     int         r1, r2;
; 3960 :     float64_t   op1, op2;
; 3961 :     float128_t  iop1, iop2, ans;
; 3962 : 
; 3963 :     RRE( inst, regs, r1, r2 );

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	48 6b c0 03	 imul	 rax, rax, 3
  0002e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00036	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003a	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004d	c1 f8 04	 sar	 eax, 4
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  00057	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00063	48 83 c0 04	 add	 rax, 4
  00067	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00073	33 c0		 xor	 eax, eax
  00075	83 f8 04	 cmp	 eax, 4
  00078	74 0f		 je	 SHORT $LN8@s390_multi
  0007a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 c8		 jne	 SHORT $LN4@s390_multi

; 3964 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3965 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a0	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a7	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ac	85 c0		 test	 eax, eax
  000ae	74 3f		 je	 SHORT $LN10@s390_multi
  000b0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000be	d1 e8		 shr	 eax, 1
  000c0	83 e0 01	 and	 eax, 1
  000c3	85 c0		 test	 eax, eax
  000c5	74 55		 je	 SHORT $LN9@s390_multi
  000c7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d6	b9 08 00 00 00	 mov	 ecx, 8
  000db	48 6b c9 01	 imul	 rcx, rcx, 1
  000df	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e6	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000eb	85 c0		 test	 eax, eax
  000ed	75 2d		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000ef	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00101	ba 07 00 00 00	 mov	 edx, 7
  00106	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00116	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:

; 3966 :     BFPREGPAIR_CHECK( r1, regs );

  0011c	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  00120	83 e0 02	 and	 eax, 2
  00123	85 c0		 test	 eax, eax
  00125	74 1b		 je	 SHORT $LN11@s390_multi
  00127	ba 06 00 00 00	 mov	 edx, 6
  0012c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_multi:
$LN7@s390_multi:

; 3967 : 
; 3968 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00142	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  00146	d1 e0		 shl	 eax, 1
  00148	48 98		 cdqe
  0014a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00152	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015a	48 8b d0	 mov	 rdx, rax
  0015d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00162	e8 00 00 00 00	 call	 s390_get_float64
  00167	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0016b	d1 e0		 shl	 eax, 1
  0016d	48 98		 cdqe
  0016f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017f	48 8b d0	 mov	 rdx, rax
  00182	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  00187	e8 00 00 00 00	 call	 s390_get_float64
  0018c	33 c0		 xor	 eax, eax
  0018e	85 c0		 test	 eax, eax
  00190	75 b0		 jne	 SHORT $LN7@s390_multi

; 3969 : 
; 3970 :     /* f64_to_f128 will, if presented with a SNaN, convert it to quiet
; 3971 :        and raise softfloat_flags_invalid. Unfortunately, if one of the
; 3972 :        operands is an SNaN and the other a QNaN, f128_mul() will be
; 3973 :        unable to do NaN propagation correctly because it will see only
; 3974 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 3975 :        input operands, that becomes the answer.  If both operands are
; 3976 :        QNaNs, then f128_mul() will be able to do NaN propagation correctly.
; 3977 :     */
; 3978 :     softfloat_exceptionFlags = 0;

  00192	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00197	8b c0		 mov	 eax, eax
  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ac	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3979 :     softfloat_roundingMode = softfloat_round_near_even;

  001b0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001b5	8b c0		 mov	 eax, eax
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001bd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ca	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3980 : 
; 3981 :     iop1 = f64_to_f128( op1 );

  001ce	48 8b 54 24 30	 mov	 rdx, QWORD PTR op1$[rsp]
  001d3	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  001d8	e8 00 00 00 00	 call	 f64_to_f128
  001dd	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  001e5	48 8b f9	 mov	 rdi, rcx
  001e8	48 8b f0	 mov	 rsi, rax
  001eb	b9 10 00 00 00	 mov	 ecx, 16
  001f0	f3 a4		 rep movsb

; 3982 : 
; 3983 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  001f2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f7	8b c0		 mov	 eax, eax
  001f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ff	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00208	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0020c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00210	83 e0 10	 and	 eax, 16
  00213	85 c0		 test	 eax, eax
  00215	74 22		 je	 SHORT $LN12@s390_multi

; 3984 :         ans = iop1;

  00217	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  0021f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  00227	48 8b f8	 mov	 rdi, rax
  0022a	48 8b f1	 mov	 rsi, rcx
  0022d	b9 10 00 00 00	 mov	 ecx, 16
  00232	f3 a4		 rep movsb
  00234	e9 c8 00 00 00	 jmp	 $LN13@s390_multi
$LN12@s390_multi:

; 3985 :     else
; 3986 :     {
; 3987 :         iop2 = f64_to_f128( op2 );

  00239	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  0023e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  00243	e8 00 00 00 00	 call	 f64_to_f128
  00248	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  00250	48 8b f9	 mov	 rdi, rcx
  00253	48 8b f0	 mov	 rsi, rax
  00256	b9 10 00 00 00	 mov	 ecx, 16
  0025b	f3 a4		 rep movsb

; 3988 : 
; 3989 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0025d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00262	8b c0		 mov	 eax, eax
  00264	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00273	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00277	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027b	83 e0 10	 and	 eax, 16
  0027e	85 c0		 test	 eax, eax
  00280	74 1f		 je	 SHORT $LN14@s390_multi

; 3990 :             ans = iop2;

  00282	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  0028a	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  00292	48 8b f8	 mov	 rdi, rax
  00295	48 8b f1	 mov	 rsi, rcx
  00298	b9 10 00 00 00	 mov	 ecx, 16
  0029d	f3 a4		 rep movsb
  0029f	eb 60		 jmp	 SHORT $LN15@s390_multi
$LN14@s390_multi:

; 3991 :         else
; 3992 :             ans = f128_mul( iop1, iop2 );

  002a1	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  002a6	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  002ae	48 8b f8	 mov	 rdi, rax
  002b1	48 8b f1	 mov	 rsi, rcx
  002b4	b9 10 00 00 00	 mov	 ecx, 16
  002b9	f3 a4		 rep movsb
  002bb	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  002c0	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  002c8	48 8b f8	 mov	 rdi, rax
  002cb	48 8b f1	 mov	 rsi, rcx
  002ce	b9 10 00 00 00	 mov	 ecx, 16
  002d3	f3 a4		 rep movsb
  002d5	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  002da	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  002df	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  002e7	e8 00 00 00 00	 call	 f128_mul
  002ec	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  002f4	48 8b f9	 mov	 rdi, rcx
  002f7	48 8b f0	 mov	 rsi, rax
  002fa	b9 10 00 00 00	 mov	 ecx, 16
  002ff	f3 a4		 rep movsb
$LN15@s390_multi:
$LN13@s390_multi:

; 3993 :     }
; 3994 : 
; 3995 :     if (softfloat_exceptionFlags)

  00301	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00306	8b c0		 mov	 eax, eax
  00308	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00317	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031f	85 c0		 test	 eax, eax
  00321	0f 84 ad 00 00
	00		 je	 $LN16@s390_multi

; 3996 :     {
; 3997 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00327	33 c0		 xor	 eax, eax
  00329	83 f8 01	 cmp	 eax, 1
  0032c	74 4b		 je	 SHORT $LN17@s390_multi
  0032e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00333	8b c0		 mov	 eax, eax
  00335	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0033b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00344	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00348	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034c	83 e0 10	 and	 eax, 16
  0034f	85 c0		 test	 eax, eax
  00351	74 26		 je	 SHORT $LN17@s390_multi
  00353	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00361	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00366	85 c0		 test	 eax, eax
  00368	74 0f		 je	 SHORT $LN17@s390_multi
  0036a	b2 80		 mov	 dl, 128			; 00000080H
  0036c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00374	e8 00 00 00 00	 call	 ieee_trap
$LN17@s390_multi:

; 3998 :         SET_FPC_FLAGS_FROM_SF( regs );

  00379	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0037e	8b c0		 mov	 eax, eax
  00380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00386	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	c1 e0 13	 shl	 eax, 19
  0039a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a2	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003a8	c1 e9 08	 shr	 ecx, 8
  003ab	f7 d1		 not	 ecx
  003ad	23 c1		 and	 eax, ecx
  003af	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  003b4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bc	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003c2	0b c8		 or	 ecx, eax
  003c4	8b c1		 mov	 eax, ecx
  003c6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ce	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN16@s390_multi:

; 3999 :     }
; 4000 : 
; 4001 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  003d4	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  003d8	d1 e0		 shl	 eax, 1
  003da	48 98		 cdqe
  003dc	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003ec	48 8b d0	 mov	 rdx, rax
  003ef	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  003f7	e8 00 00 00 00	 call	 s390_put_float128

; 4002 : }

  003fc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00404	48 33 cc	 xor	 rcx, rsp
  00407	e8 00 00 00 00	 call	 __security_check_cookie
  0040c	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00413	5f		 pop	 rdi
  00414	5e		 pop	 rsi
  00415	c3		 ret	 0
s390_multiply_bfp_long_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
r1$ = 44
x2$ = 48
op1$ = 56
op2$ = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
ans$ = 160
iop2$ = 176
iop1$ = 192
__$ArrayPad$ = 208
inst$ = 256
regs$ = 264
s390_multiply_bfp_long_to_ext PROC

; 4012 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4013 :     int         r1, x2, b2;
; 4014 :     VADR        effective_addr2;
; 4015 :     float64_t   op1, op2;
; 4016 :     float128_t  iop1, iop2, ans;
; 4017 : 
; 4018 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00025	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 _byteswap_ulong
  00039	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003d	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00041	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00046	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 10	 shr	 eax, 16
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00058	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 14	 shr	 eax, 20
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00066	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006b	74 20		 je	 SHORT $LN5@s390_multi
  0006d	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00072	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00085	03 c8		 add	 ecx, eax
  00087	8b c1		 mov	 eax, ecx
  00089	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_multi:
  0008d	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00091	c1 e8 0c	 shr	 eax, 12
  00094	83 e0 0f	 and	 eax, 15
  00097	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0009b	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a0	74 20		 je	 SHORT $LN6@s390_multi
  000a2	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b6	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ba	03 c8		 add	 ecx, eax
  000bc	8b c1		 mov	 eax, ecx
  000be	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_multi:
  000c2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d4	23 c8		 and	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_multi:
  000dc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e8	48 83 c0 06	 add	 rax, 6
  000ec	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f8	33 c0		 xor	 eax, eax
  000fa	83 f8 06	 cmp	 eax, 6
  000fd	74 0f		 je	 SHORT $LN7@s390_multi
  000ff	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_multi:
  0010e	33 c0		 xor	 eax, eax
  00110	85 c0		 test	 eax, eax
  00112	75 c8		 jne	 SHORT $LN4@s390_multi

; 4019 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4020 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4021 :     BFPINST_CHECK( regs );

  00114	b8 08 00 00 00	 mov	 eax, 8
  00119	48 6b c0 01	 imul	 rax, rax, 1
  0011d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	74 3f		 je	 SHORT $LN9@s390_multi
  00135	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00143	d1 e8		 shr	 eax, 1
  00145	83 e0 01	 and	 eax, 1
  00148	85 c0		 test	 eax, eax
  0014a	74 55		 je	 SHORT $LN8@s390_multi
  0014c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00154	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0015b	b9 08 00 00 00	 mov	 ecx, 8
  00160	48 6b c9 01	 imul	 rcx, rcx, 1
  00164	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0016b	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00170	85 c0		 test	 eax, eax
  00172	75 2d		 jne	 SHORT $LN8@s390_multi
$LN9@s390_multi:
  00174	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00186	ba 07 00 00 00	 mov	 edx, 7
  0018b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00193	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_multi:

; 4022 :     BFPREGPAIR_CHECK( r1, regs );

  001a1	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001a5	83 e0 02	 and	 eax, 2
  001a8	85 c0		 test	 eax, eax
  001aa	74 1b		 je	 SHORT $LN10@s390_multi
  001ac	ba 06 00 00 00	 mov	 edx, 6
  001b1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s390_multi:

; 4023 : 
; 4024 :     GET_FLOAT64_OP( op1, r1, regs );

  001c7	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001cb	d1 e0		 shl	 eax, 1
  001cd	48 98		 cdqe
  001cf	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d7	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001df	48 8b d0	 mov	 rdx, rax
  001e2	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  001e7	e8 00 00 00 00	 call	 s390_get_float64

; 4025 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001ec	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f4	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001f8	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001fc	e8 00 00 00 00	 call	 s390_vfetch8
  00201	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 4026 : 
; 4027 :     /* f64_to_f128 will, if presented with a SNaN, convert it to quiet
; 4028 :        and raise softfloat_flags_invalid.  Unfortunately, if one of
; 4029 :        the operands is an SNaN and the other a QNaN, f128_mul() will
; 4030 :        be unable to do NaN propagation correctly because it will see
; 4031 :        only two QNaNs.  So if we encounter an SNaN while upconverting
; 4032 :        the input operands, that becomes the answer.  If both operands
; 4033 :        are QNaNs, then f128_mul() will be able to do NaN propagation correctly.
; 4034 :     */
; 4035 :     softfloat_exceptionFlags = 0;

  00206	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020b	8b c0		 mov	 eax, eax
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00213	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00220	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4036 :     softfloat_roundingMode = softfloat_round_near_even;

  00224	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00229	8b c0		 mov	 eax, eax
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00231	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023e	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4037 : 
; 4038 :     iop1 = f64_to_f128( op1 );

  00242	48 8b 54 24 38	 mov	 rdx, QWORD PTR op1$[rsp]
  00247	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  0024c	e8 00 00 00 00	 call	 f64_to_f128
  00251	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  00259	48 8b f9	 mov	 rdi, rcx
  0025c	48 8b f0	 mov	 rsi, rax
  0025f	b9 10 00 00 00	 mov	 ecx, 16
  00264	f3 a4		 rep movsb

; 4039 : 
; 4040 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00266	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0026b	8b c0		 mov	 eax, eax
  0026d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00273	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00280	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00284	83 e0 10	 and	 eax, 16
  00287	85 c0		 test	 eax, eax
  00289	74 22		 je	 SHORT $LN11@s390_multi

; 4041 :         ans = iop1;

  0028b	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  00293	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  0029b	48 8b f8	 mov	 rdi, rax
  0029e	48 8b f1	 mov	 rsi, rcx
  002a1	b9 10 00 00 00	 mov	 ecx, 16
  002a6	f3 a4		 rep movsb
  002a8	e9 cb 00 00 00	 jmp	 $LN12@s390_multi
$LN11@s390_multi:

; 4042 :     else
; 4043 :     {
; 4044 :         iop2 = f64_to_f128( op2 );

  002ad	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  002b2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  002ba	e8 00 00 00 00	 call	 f64_to_f128
  002bf	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  002c7	48 8b f9	 mov	 rdi, rcx
  002ca	48 8b f0	 mov	 rsi, rax
  002cd	b9 10 00 00 00	 mov	 ecx, 16
  002d2	f3 a4		 rep movsb

; 4045 : 
; 4046 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  002d4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d9	8b c0		 mov	 eax, eax
  002db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ea	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f2	83 e0 10	 and	 eax, 16
  002f5	85 c0		 test	 eax, eax
  002f7	74 1f		 je	 SHORT $LN13@s390_multi

; 4047 :             ans = iop2;

  002f9	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  00301	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  00309	48 8b f8	 mov	 rdi, rax
  0030c	48 8b f1	 mov	 rsi, rcx
  0030f	b9 10 00 00 00	 mov	 ecx, 16
  00314	f3 a4		 rep movsb
  00316	eb 60		 jmp	 SHORT $LN14@s390_multi
$LN13@s390_multi:

; 4048 :         else
; 4049 :             ans = f128_mul( iop1, iop2 );

  00318	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  0031d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  00325	48 8b f8	 mov	 rdi, rax
  00328	48 8b f1	 mov	 rsi, rcx
  0032b	b9 10 00 00 00	 mov	 ecx, 16
  00330	f3 a4		 rep movsb
  00332	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  00337	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  0033f	48 8b f8	 mov	 rdi, rax
  00342	48 8b f1	 mov	 rsi, rcx
  00345	b9 10 00 00 00	 mov	 ecx, 16
  0034a	f3 a4		 rep movsb
  0034c	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  00351	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  00356	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  0035e	e8 00 00 00 00	 call	 f128_mul
  00363	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0036b	48 8b f9	 mov	 rdi, rcx
  0036e	48 8b f0	 mov	 rsi, rax
  00371	b9 10 00 00 00	 mov	 ecx, 16
  00376	f3 a4		 rep movsb
$LN14@s390_multi:
$LN12@s390_multi:

; 4050 :     }
; 4051 : 
; 4052 :     if (softfloat_exceptionFlags)

  00378	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0037d	8b c0		 mov	 eax, eax
  0037f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00385	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00392	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00396	85 c0		 test	 eax, eax
  00398	0f 84 ad 00 00
	00		 je	 $LN15@s390_multi

; 4053 :     {
; 4054 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0039e	33 c0		 xor	 eax, eax
  003a0	83 f8 01	 cmp	 eax, 1
  003a3	74 4b		 je	 SHORT $LN16@s390_multi
  003a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003aa	8b c0		 mov	 eax, eax
  003ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003c3	83 e0 10	 and	 eax, 16
  003c6	85 c0		 test	 eax, eax
  003c8	74 26		 je	 SHORT $LN16@s390_multi
  003ca	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d2	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003d8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003dd	85 c0		 test	 eax, eax
  003df	74 0f		 je	 SHORT $LN16@s390_multi
  003e1	b2 80		 mov	 dl, 128			; 00000080H
  003e3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003eb	e8 00 00 00 00	 call	 ieee_trap
$LN16@s390_multi:

; 4055 :         SET_FPC_FLAGS_FROM_SF( regs );

  003f0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003f5	8b c0		 mov	 eax, eax
  003f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003fd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00406	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0040a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0040e	c1 e0 13	 shl	 eax, 19
  00411	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00419	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0041f	c1 e9 08	 shr	 ecx, 8
  00422	f7 d1		 not	 ecx
  00424	23 c1		 and	 eax, ecx
  00426	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0042b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00433	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00439	0b c8		 or	 ecx, eax
  0043b	8b c1		 mov	 eax, ecx
  0043d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00445	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN15@s390_multi:

; 4056 :     }
; 4057 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  0044b	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0044f	d1 e0		 shl	 eax, 1
  00451	48 98		 cdqe
  00453	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00463	48 8b d0	 mov	 rdx, rax
  00466	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0046e	e8 00 00 00 00	 call	 s390_put_float128

; 4058 : }

  00473	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0047b	48 33 cc	 xor	 rcx, rsp
  0047e	e8 00 00 00 00	 call	 __security_check_cookie
  00483	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0048a	5f		 pop	 rdi
  0048b	5e		 pop	 rsi
  0048c	c3		 ret	 0
s390_multiply_bfp_long_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv194 = 40
r1$ = 44
r2$ = 48
ans$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
s390_multiply_bfp_long_reg PROC

; 4064 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4065 :     int        r1, r2;
; 4066 :     float64_t  op1, op2, ans;
; 4067 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4068 : 
; 4069 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@s390_multi
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_multi

; 4070 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4071 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN10@s390_multi
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN9@s390_multi
  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:
$LN7@s390_multi:

; 4072 : 
; 4073 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float64
  00111	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s390_get_float64
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s390_multi

; 4074 : 
; 4075 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4076 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4077 : 
; 4078 :     ans = f64_mul( op1, op2 );

  00191	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00196	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 f64_mul
  001a0	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 4079 : 
; 4080 :     if (softfloat_exceptionFlags)

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 94 00 00
	00		 je	 $LN11@s390_multi

; 4081 :     {
; 4082 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001cb	33 c0		 xor	 eax, eax
  001cd	83 f8 01	 cmp	 eax, 1
  001d0	74 45		 je	 SHORT $LN12@s390_multi
  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	83 e0 10	 and	 eax, 16
  001f3	85 c0		 test	 eax, eax
  001f5	74 20		 je	 SHORT $LN12@s390_multi
  001f7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00202	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00207	85 c0		 test	 eax, eax
  00209	74 0c		 je	 SHORT $LN12@s390_multi
  0020b	b2 80		 mov	 dl, 128			; 00000080H
  0020d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_multi:

; 4083 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00217	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00221	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4084 : 
; 4085 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00225	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00229	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022e	85 c0		 test	 eax, eax
  00230	74 2d		 je	 SHORT $LN13@s390_multi

; 4086 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00232	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00236	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0023b	85 c0		 test	 eax, eax
  0023d	74 0a		 je	 SHORT $LN16@s390_multi
  0023f	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv194[rsp], -1536 ; fffffffffffffa00H
  00247	eb 08		 jmp	 SHORT $LN17@s390_multi
$LN16@s390_multi:
  00249	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv194[rsp], 1536 ; 00000600H
$LN17@s390_multi:
  00251	8b 4c 24 28	 mov	 ecx, DWORD PTR tv194[rsp]
  00255	e8 00 00 00 00	 call	 f64_scaledResult
  0025a	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN13@s390_multi:
$LN11@s390_multi:

; 4087 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4088 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4089 :     }
; 4090 : 
; 4091 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  0025f	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00263	d1 e0		 shl	 eax, 1
  00265	48 98		 cdqe
  00267	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00274	48 8b d0	 mov	 rdx, rax
  00277	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  0027c	e8 00 00 00 00	 call	 s390_put_float64

; 4092 : 
; 4093 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00281	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00285	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0028a	85 c0		 test	 eax, eax
  0028c	74 0e		 je	 SHORT $LN14@s390_multi
  0028e	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00292	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00297	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s390_multi:

; 4094 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4095 : }

  0029c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002a0	c3		 ret	 0
s390_multiply_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv211 = 52
r1$ = 56
ans$ = 64
op2$ = 72
op1$ = 80
inst$ = 112
regs$ = 120
s390_multiply_bfp_long PROC

; 4101 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4102 :     int        r1, x2, b2;
; 4103 :     VADR       effective_addr2;
; 4104 :     float64_t  op1, op2, ans;
; 4105 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4106 : 
; 4107 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s390_multi
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_multi:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s390_multi
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_multi:
  000aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_multi:
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ca	48 83 c0 06	 add	 rax, 6
  000ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 06	 cmp	 eax, 6
  000dc	74 0c		 je	 SHORT $LN7@s390_multi
  000de	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_multi:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 d1		 jne	 SHORT $LN4@s390_multi

; 4108 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4109 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4110 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00105	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $LN9@s390_multi
  0010e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00113	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00119	d1 e8		 shr	 eax, 1
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 49		 je	 SHORT $LN8@s390_multi
  00122	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	48 6b c9 01	 imul	 rcx, rcx, 1
  00137	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0013e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN8@s390_multi
$LN9@s390_multi:
  00147	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00156	ba 07 00 00 00	 mov	 edx, 7
  0015b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00165	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_multi:

; 4111 : 
; 4112 :     GET_FLOAT64_OP( op1, r1, regs );

  0016b	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0016f	d1 e0		 shl	 eax, 1
  00171	48 98		 cdqe
  00173	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00180	48 8b d0	 mov	 rdx, rax
  00183	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  00188	e8 00 00 00 00	 call	 s390_get_float64

; 4113 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0018d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00192	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00196	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019a	e8 00 00 00 00	 call	 s390_vfetch8
  0019f	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 4114 : 
; 4115 :     softfloat_exceptionFlags = 0;

  001a4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a9	8b c0		 mov	 eax, eax
  001ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ba	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001be	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4116 :     SET_SF_RM_FROM_FPC;

  001c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cd	83 e0 07	 and	 eax, 7
  001d0	8b c0		 mov	 eax, eax
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001de	8b d2		 mov	 edx, edx
  001e0	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001e7	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001f0	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4117 : 
; 4118 :     ans = f64_mul( op1, op2 );

  001fc	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00201	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op1$[rsp]
  00206	e8 00 00 00 00	 call	 f64_mul
  0020b	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 4119 : 
; 4120 :     if (softfloat_exceptionFlags)

  00210	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00215	8b c0		 mov	 eax, eax
  00217	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00226	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022e	85 c0		 test	 eax, eax
  00230	0f 84 94 00 00
	00		 je	 $LN10@s390_multi

; 4121 :     {
; 4122 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00236	33 c0		 xor	 eax, eax
  00238	83 f8 01	 cmp	 eax, 1
  0023b	74 45		 je	 SHORT $LN11@s390_multi
  0023d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00242	8b c0		 mov	 eax, eax
  00244	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0024a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00253	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00257	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025b	83 e0 10	 and	 eax, 16
  0025e	85 c0		 test	 eax, eax
  00260	74 20		 je	 SHORT $LN11@s390_multi
  00262	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00267	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0026d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00272	85 c0		 test	 eax, eax
  00274	74 0c		 je	 SHORT $LN11@s390_multi
  00276	b2 80		 mov	 dl, 128			; 00000080H
  00278	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_multi:

; 4123 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00282	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00287	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0028c	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4124 : 
; 4125 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00290	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00294	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00299	85 c0		 test	 eax, eax
  0029b	74 2d		 je	 SHORT $LN12@s390_multi

; 4126 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0029d	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002a1	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002a6	85 c0		 test	 eax, eax
  002a8	74 0a		 je	 SHORT $LN15@s390_multi
  002aa	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv211[rsp], -1536 ; fffffffffffffa00H
  002b2	eb 08		 jmp	 SHORT $LN16@s390_multi
$LN15@s390_multi:
  002b4	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv211[rsp], 1536 ; 00000600H
$LN16@s390_multi:
  002bc	8b 4c 24 34	 mov	 ecx, DWORD PTR tv211[rsp]
  002c0	e8 00 00 00 00	 call	 f64_scaledResult
  002c5	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN12@s390_multi:
$LN10@s390_multi:

; 4127 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4128 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4129 :     }
; 4130 : 
; 4131 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  002ca	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002ce	d1 e0		 shl	 eax, 1
  002d0	48 98		 cdqe
  002d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d7	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002df	48 8b d0	 mov	 rdx, rax
  002e2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  002e7	e8 00 00 00 00	 call	 s390_put_float64

; 4132 : 
; 4133 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002ec	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f0	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002f5	85 c0		 test	 eax, eax
  002f7	74 0e		 je	 SHORT $LN13@s390_multi
  002f9	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002fd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00302	e8 00 00 00 00	 call	 ieee_cond_trap
$LN13@s390_multi:

; 4134 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4135 : }

  00307	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0030b	c3		 ret	 0
s390_multiply_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv203 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
ans$ = 128
op2$ = 144
op1$ = 160
__$ArrayPad$ = 176
inst$ = 224
regs$ = 232
s390_multiply_bfp_ext_reg PROC

; 3916 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3917 :     int         r1, r2;
; 3918 :     float128_t  op1, op2, ans;
; 3919 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3920 : 
; 3921 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  0005f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN8@s390_multi
  00082	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@s390_multi

; 3922 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3923 :     BFPINST_CHECK( regs );

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 3f		 je	 SHORT $LN10@s390_multi
  000b8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c6	d1 e8		 shr	 eax, 1
  000c8	83 e0 01	 and	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 55		 je	 SHORT $LN9@s390_multi
  000cf	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	b9 08 00 00 00	 mov	 ecx, 8
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ee	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f3	85 c0		 test	 eax, eax
  000f5	75 2d		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000f7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00109	ba 07 00 00 00	 mov	 edx, 7
  0010e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:

; 3924 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00124	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN12@s390_multi
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 02	 and	 eax, 2
  00136	85 c0		 test	 eax, eax
  00138	74 1b		 je	 SHORT $LN11@s390_multi
$LN12@s390_multi:
  0013a	ba 06 00 00 00	 mov	 edx, 6
  0013f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_multi:
$LN7@s390_multi:

; 3925 : 
; 3926 :     GET_FLOAT128_OPS(op1, r1, op2, r2, regs);

  00155	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00159	d1 e0		 shl	 eax, 1
  0015b	48 98		 cdqe
  0015d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00178	e8 00 00 00 00	 call	 s390_get_float128
  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00181	d1 e0		 shl	 eax, 1
  00183	48 98		 cdqe
  00185	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001a0	e8 00 00 00 00	 call	 s390_get_float128
  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 aa		 jne	 SHORT $LN7@s390_multi

; 3927 : 
; 3928 :     softfloat_exceptionFlags = 0;

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b0	8b c0		 mov	 eax, eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3929 :     SET_SF_RM_FROM_FPC;

  001c9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d7	83 e0 07	 and	 eax, 7
  001da	8b c0		 mov	 eax, eax
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001e8	8b d2		 mov	 edx, edx
  001ea	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001f1	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001fa	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00202	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3930 : 
; 3931 :     ans = f128_mul( op1, op2 );

  00206	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0020b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  00213	48 8b f8	 mov	 rdi, rax
  00216	48 8b f1	 mov	 rsi, rcx
  00219	b9 10 00 00 00	 mov	 ecx, 16
  0021e	f3 a4		 rep movsb
  00220	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00225	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  0022d	48 8b f8	 mov	 rdi, rax
  00230	48 8b f1	 mov	 rsi, rcx
  00233	b9 10 00 00 00	 mov	 ecx, 16
  00238	f3 a4		 rep movsb
  0023a	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  0023f	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  00244	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  00249	e8 00 00 00 00	 call	 f128_mul
  0024e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00256	48 8b f9	 mov	 rdi, rcx
  00259	48 8b f0	 mov	 rsi, rax
  0025c	b9 10 00 00 00	 mov	 ecx, 16
  00261	f3 a4		 rep movsb

; 3932 : 
; 3933 :     if (softfloat_exceptionFlags)

  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	85 c0		 test	 eax, eax
  00283	0f 84 b2 00 00
	00		 je	 $LN13@s390_multi

; 3934 :     {
; 3935 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00289	33 c0		 xor	 eax, eax
  0028b	83 f8 01	 cmp	 eax, 1
  0028e	74 4b		 je	 SHORT $LN14@s390_multi
  00290	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00295	8b c0		 mov	 eax, eax
  00297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ae	83 e0 10	 and	 eax, 16
  002b1	85 c0		 test	 eax, eax
  002b3	74 26		 je	 SHORT $LN14@s390_multi
  002b5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002c8	85 c0		 test	 eax, eax
  002ca	74 0f		 je	 SHORT $LN14@s390_multi
  002cc	b2 80		 mov	 dl, 128			; 00000080H
  002ce	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_multi:

; 3936 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002db	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002e8	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3937 : 
; 3938 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ec	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002f5	85 c0		 test	 eax, eax
  002f7	74 42		 je	 SHORT $LN15@s390_multi

; 3939 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002f9	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002fd	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00302	85 c0		 test	 eax, eax
  00304	74 0a		 je	 SHORT $LN18@s390_multi
  00306	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv203[rsp], -24576 ; ffffffffffffa000H
  0030e	eb 08		 jmp	 SHORT $LN19@s390_multi
$LN18@s390_multi:
  00310	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv203[rsp], 24576 ; 00006000H
$LN19@s390_multi:
  00318	8b 54 24 30	 mov	 edx, DWORD PTR tv203[rsp]
  0031c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  00321	e8 00 00 00 00	 call	 f128_scaledResult
  00326	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0032e	48 8b f9	 mov	 rdi, rcx
  00331	48 8b f0	 mov	 rsi, rax
  00334	b9 10 00 00 00	 mov	 ecx, 16
  00339	f3 a4		 rep movsb
$LN15@s390_multi:
$LN13@s390_multi:

; 3940 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 3941 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 3942 :     }
; 3943 : 
; 3944 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  0033b	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0033f	d1 e0		 shl	 eax, 1
  00341	48 98		 cdqe
  00343	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00353	48 8b d0	 mov	 rdx, rax
  00356	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0035e	e8 00 00 00 00	 call	 s390_put_float128

; 3945 : 
; 3946 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00363	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00367	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0036c	85 c0		 test	 eax, eax
  0036e	74 11		 je	 SHORT $LN16@s390_multi
  00370	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00374	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_multi:

; 3947 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3948 : }

  00381	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00389	48 33 cc	 xor	 rcx, rsp
  0038c	e8 00 00 00 00	 call	 __security_check_cookie
  00391	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00398	5f		 pop	 rdi
  00399	5e		 pop	 rsi
  0039a	c3		 ret	 0
s390_multiply_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv205 = 40
r1$ = 44
ans$ = 48
r3$ = 52
r2$ = 56
op1$ = 60
op3$ = 64
op2$ = 68
inst$ = 96
regs$ = 104
s390_multiply_add_bfp_short_reg PROC

; 4405 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4406 :     int        r1, r2, r3;
; 4407 :     float32_t  op1, op2, op3, ans;
; 4408 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4409 : 
; 4410 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN8@s390_multi
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@s390_multi

; 4411 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4412 :     BFPINST_CHECK( regs );

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00096	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009b	85 c0		 test	 eax, eax
  0009d	74 39		 je	 SHORT $LN10@s390_multi
  0009f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000aa	d1 e8		 shr	 eax, 1
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 49		 je	 SHORT $LN9@s390_multi
  000b3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000d4	85 c0		 test	 eax, eax
  000d6	75 24		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000d8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e7	ba 07 00 00 00	 mov	 edx, 7
  000ec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:
$LN7@s390_multi:

; 4413 : 
; 4414 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  000fc	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00100	d1 e0		 shl	 eax, 1
  00102	48 98		 cdqe
  00104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  00119	e8 00 00 00 00	 call	 s390_get_float32
  0011e	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op3$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_get_float32
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 b6		 jne	 SHORT $LN7@s390_multi

; 4415 :     GET_FLOAT32_OP( op2, r2, regs );

  00146	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  0014a	d1 e0		 shl	 eax, 1
  0014c	48 98		 cdqe
  0014e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op2$[rsp]
  00163	e8 00 00 00 00	 call	 s390_get_float32

; 4416 : 
; 4417 :     softfloat_exceptionFlags = 0;

  00168	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016d	8b c0		 mov	 eax, eax
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00175	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00182	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4418 :     SET_SF_RM_FROM_FPC;

  00186	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00191	83 e0 07	 and	 eax, 7
  00194	8b c0		 mov	 eax, eax
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0019d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001a2	8b d2		 mov	 edx, edx
  001a4	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001ab	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001b4	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001bc	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4419 : 
; 4420 :     ans = f32_mulAdd( op2, op3, op1 );

  001c0	44 8b 44 24 3c	 mov	 r8d, DWORD PTR op1$[rsp]
  001c5	8b 54 24 40	 mov	 edx, DWORD PTR op3$[rsp]
  001c9	8b 4c 24 44	 mov	 ecx, DWORD PTR op2$[rsp]
  001cd	e8 00 00 00 00	 call	 f32_mulAdd
  001d2	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 4421 : 
; 4422 :     if (softfloat_exceptionFlags)

  001d6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001db	8b c0		 mov	 eax, eax
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ec	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f4	85 c0		 test	 eax, eax
  001f6	0f 84 93 00 00
	00		 je	 $LN11@s390_multi

; 4423 :     {
; 4424 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001fc	33 c0		 xor	 eax, eax
  001fe	83 f8 01	 cmp	 eax, 1
  00201	74 45		 je	 SHORT $LN12@s390_multi
  00203	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00208	8b c0		 mov	 eax, eax
  0020a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00210	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00219	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00221	83 e0 10	 and	 eax, 16
  00224	85 c0		 test	 eax, eax
  00226	74 20		 je	 SHORT $LN12@s390_multi
  00228	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00233	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0c		 je	 SHORT $LN12@s390_multi
  0023c	b2 80		 mov	 dl, 128			; 00000080H
  0023e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00243	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_multi:

; 4425 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00248	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0024d	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00252	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4426 : 
; 4427 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00256	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0025a	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0025f	85 c0		 test	 eax, eax
  00261	74 2c		 je	 SHORT $LN13@s390_multi

; 4428 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00263	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00267	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0026c	85 c0		 test	 eax, eax
  0026e	74 0a		 je	 SHORT $LN16@s390_multi
  00270	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv205[rsp], -192 ; ffffffffffffff40H
  00278	eb 08		 jmp	 SHORT $LN17@s390_multi
$LN16@s390_multi:
  0027a	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv205[rsp], 192 ; 000000c0H
$LN17@s390_multi:
  00282	8b 4c 24 28	 mov	 ecx, DWORD PTR tv205[rsp]
  00286	e8 00 00 00 00	 call	 f32_scaledResult
  0028b	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN13@s390_multi:
$LN11@s390_multi:

; 4429 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4430 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4431 :     }
; 4432 : 
; 4433 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  0028f	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00293	d1 e0		 shl	 eax, 1
  00295	48 98		 cdqe
  00297	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002a4	48 8b d0	 mov	 rdx, rax
  002a7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  002ac	e8 00 00 00 00	 call	 s390_put_float32

; 4434 : 
; 4435 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002b1	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b5	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002ba	85 c0		 test	 eax, eax
  002bc	74 0e		 je	 SHORT $LN14@s390_multi
  002be	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c7	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s390_multi:

; 4436 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4437 : }

  002cc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d0	c3		 ret	 0
s390_multiply_add_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv224 = 52
r1$ = 56
ans$ = 60
r3$ = 64
op1$ = 68
op3$ = 72
op2$ = 76
inst$ = 96
regs$ = 104
s390_multiply_add_bfp_short PROC

; 4443 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4444 :     int        x2, r1, r3, b2;
; 4445 :     VADR       effective_addr2;
; 4446 :     float32_t  op1, op2, op3, ans;
; 4447 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4448 : 
; 4449 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 04	 imul	 rax, rax, 4
  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	c1 f8 04	 sar	 eax, 4
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 10	 shr	 eax, 16
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0005f	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 14	 shr	 eax, 20
  00066	83 e0 0f	 and	 eax, 15
  00069	89 44 24 40	 mov	 DWORD PTR r3$[rsp], eax
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00072	74 1d		 je	 SHORT $LN8@s390_multi
  00074	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00079	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00085	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00089	03 c8		 add	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s390_multi:
  00091	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00095	c1 e8 0c	 shr	 eax, 12
  00098	83 e0 0f	 and	 eax, 15
  0009b	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0009f	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a4	74 1d		 je	 SHORT $LN9@s390_multi
  000a6	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bb	03 c8		 add	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_multi:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ce	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d2	23 c8		 and	 ecx, eax
  000d4	8b c1		 mov	 eax, ecx
  000d6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_multi:
  000da	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000df	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e3	48 83 c0 06	 add	 rax, 6
  000e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f0	33 c0		 xor	 eax, eax
  000f2	83 f8 06	 cmp	 eax, 6
  000f5	74 0c		 je	 SHORT $LN10@s390_multi
  000f7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_multi:
  00103	33 c0		 xor	 eax, eax
  00105	85 c0		 test	 eax, eax
  00107	75 d1		 jne	 SHORT $LN4@s390_multi

; 4450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4451 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4452 :     BFPINST_CHECK( regs );

  00109	b8 08 00 00 00	 mov	 eax, 8
  0010e	48 6b c0 01	 imul	 rax, rax, 1
  00112	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00123	85 c0		 test	 eax, eax
  00125	74 39		 je	 SHORT $LN12@s390_multi
  00127	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00132	d1 e8		 shr	 eax, 1
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	74 49		 je	 SHORT $LN11@s390_multi
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00147	b9 08 00 00 00	 mov	 ecx, 8
  0014c	48 6b c9 01	 imul	 rcx, rcx, 1
  00150	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00157	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0015c	85 c0		 test	 eax, eax
  0015e	75 24		 jne	 SHORT $LN11@s390_multi
$LN12@s390_multi:
  00160	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00165	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0016f	ba 07 00 00 00	 mov	 edx, 7
  00174	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_multi:
$LN7@s390_multi:

; 4453 : 
; 4454 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  00184	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00188	d1 e0		 shl	 eax, 1
  0018a	48 98		 cdqe
  0018c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00191	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00199	48 8b d0	 mov	 rdx, rax
  0019c	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op1$[rsp]
  001a1	e8 00 00 00 00	 call	 s390_get_float32
  001a6	8b 44 24 40	 mov	 eax, DWORD PTR r3$[rsp]
  001aa	d1 e0		 shl	 eax, 1
  001ac	48 98		 cdqe
  001ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001bb	48 8b d0	 mov	 rdx, rax
  001be	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  001c3	e8 00 00 00 00	 call	 s390_get_float32
  001c8	33 c0		 xor	 eax, eax
  001ca	85 c0		 test	 eax, eax
  001cc	75 b6		 jne	 SHORT $LN7@s390_multi

; 4455 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  001ce	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001d3	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001d7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001db	e8 00 00 00 00	 call	 s390_vfetch4
  001e0	89 44 24 4c	 mov	 DWORD PTR op2$[rsp], eax

; 4456 : 
; 4457 :     softfloat_exceptionFlags = 0;

  001e4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e9	8b c0		 mov	 eax, eax
  001eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001fa	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001fe	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4458 :     SET_SF_RM_FROM_FPC;

  00202	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00207	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0020d	83 e0 07	 and	 eax, 7
  00210	8b c0		 mov	 eax, eax
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00219	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0021e	8b d2		 mov	 edx, edx
  00220	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00227	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00230	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00234	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00238	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4459 : 
; 4460 :     ans = f32_mulAdd( op2, op3, op1 );

  0023c	44 8b 44 24 44	 mov	 r8d, DWORD PTR op1$[rsp]
  00241	8b 54 24 48	 mov	 edx, DWORD PTR op3$[rsp]
  00245	8b 4c 24 4c	 mov	 ecx, DWORD PTR op2$[rsp]
  00249	e8 00 00 00 00	 call	 f32_mulAdd
  0024e	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax

; 4461 : 
; 4462 :     if (softfloat_exceptionFlags)

  00252	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00257	8b c0		 mov	 eax, eax
  00259	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0025f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00268	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0026c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00270	85 c0		 test	 eax, eax
  00272	0f 84 93 00 00
	00		 je	 $LN13@s390_multi

; 4463 :     {
; 4464 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00278	33 c0		 xor	 eax, eax
  0027a	83 f8 01	 cmp	 eax, 1
  0027d	74 45		 je	 SHORT $LN14@s390_multi
  0027f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00284	8b c0		 mov	 eax, eax
  00286	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0028c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00295	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00299	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029d	83 e0 10	 and	 eax, 16
  002a0	85 c0		 test	 eax, eax
  002a2	74 20		 je	 SHORT $LN14@s390_multi
  002a4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002a9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002af	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002b4	85 c0		 test	 eax, eax
  002b6	74 0c		 je	 SHORT $LN14@s390_multi
  002b8	b2 80		 mov	 dl, 128			; 00000080H
  002ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_multi:

; 4465 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002ce	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4466 : 
; 4467 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002d2	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002d6	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002db	85 c0		 test	 eax, eax
  002dd	74 2c		 je	 SHORT $LN15@s390_multi

; 4468 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002df	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e3	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002e8	85 c0		 test	 eax, eax
  002ea	74 0a		 je	 SHORT $LN18@s390_multi
  002ec	c7 44 24 34 40
	ff ff ff	 mov	 DWORD PTR tv224[rsp], -192 ; ffffffffffffff40H
  002f4	eb 08		 jmp	 SHORT $LN19@s390_multi
$LN18@s390_multi:
  002f6	c7 44 24 34 c0
	00 00 00	 mov	 DWORD PTR tv224[rsp], 192 ; 000000c0H
$LN19@s390_multi:
  002fe	8b 4c 24 34	 mov	 ecx, DWORD PTR tv224[rsp]
  00302	e8 00 00 00 00	 call	 f32_scaledResult
  00307	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax
$LN15@s390_multi:
$LN13@s390_multi:

; 4469 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4470 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4471 :     }
; 4472 : 
; 4473 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  0030b	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0030f	d1 e0		 shl	 eax, 1
  00311	48 98		 cdqe
  00313	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00318	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00320	48 8b d0	 mov	 rdx, rax
  00323	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR ans$[rsp]
  00328	e8 00 00 00 00	 call	 s390_put_float32

; 4474 : 
; 4475 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0032d	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00331	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00336	85 c0		 test	 eax, eax
  00338	74 0e		 je	 SHORT $LN16@s390_multi
  0033a	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0033e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00343	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_multi:

; 4476 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4477 : }

  00348	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0034c	c3		 ret	 0
s390_multiply_add_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv205 = 40
r1$ = 44
r3$ = 48
r2$ = 52
ans$ = 56
op1$ = 64
op3$ = 72
op2$ = 80
inst$ = 112
regs$ = 120
s390_multiply_add_bfp_long_reg PROC

; 4327 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4328 :     int        r1, r2, r3;
; 4329 :     float64_t  op1, op2, op3, ans;
; 4330 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4331 : 
; 4332 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_multi:
  00052	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN8@s390_multi
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@s390_multi

; 4333 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4334 :     BFPINST_CHECK( regs );

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00096	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009b	85 c0		 test	 eax, eax
  0009d	74 39		 je	 SHORT $LN10@s390_multi
  0009f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000aa	d1 e8		 shr	 eax, 1
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 49		 je	 SHORT $LN9@s390_multi
  000b3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000d4	85 c0		 test	 eax, eax
  000d6	75 24		 jne	 SHORT $LN9@s390_multi
$LN10@s390_multi:
  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e7	ba 07 00 00 00	 mov	 edx, 7
  000ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_multi:
$LN7@s390_multi:

; 4335 : 
; 4336 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  000fc	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00100	d1 e0		 shl	 eax, 1
  00102	48 98		 cdqe
  00104	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00119	e8 00 00 00 00	 call	 s390_get_float64
  0011e	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_get_float64
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 b6		 jne	 SHORT $LN7@s390_multi

; 4337 :     GET_FLOAT64_OP( op2, r2, regs );

  00146	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0014a	d1 e0		 shl	 eax, 1
  0014c	48 98		 cdqe
  0014e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  00163	e8 00 00 00 00	 call	 s390_get_float64

; 4338 : 
; 4339 :     softfloat_exceptionFlags = 0;

  00168	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016d	8b c0		 mov	 eax, eax
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00175	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00182	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4340 :     SET_SF_RM_FROM_FPC;

  00186	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00191	83 e0 07	 and	 eax, 7
  00194	8b c0		 mov	 eax, eax
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0019d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001a2	8b d2		 mov	 edx, edx
  001a4	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001ab	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001b4	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001bc	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4341 : 
; 4342 :     ans = f64_mulAdd( op2, op3, op1 );

  001c0	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  001c5	48 8b 54 24 48	 mov	 rdx, QWORD PTR op3$[rsp]
  001ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  001cf	e8 00 00 00 00	 call	 f64_mulAdd
  001d4	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 4343 : 
; 4344 :     if (softfloat_exceptionFlags)

  001d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001de	8b c0		 mov	 eax, eax
  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ef	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f7	85 c0		 test	 eax, eax
  001f9	0f 84 94 00 00
	00		 je	 $LN11@s390_multi

; 4345 :     {
; 4346 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001ff	33 c0		 xor	 eax, eax
  00201	83 f8 01	 cmp	 eax, 1
  00204	74 45		 je	 SHORT $LN12@s390_multi
  00206	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020b	8b c0		 mov	 eax, eax
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00213	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00220	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00224	83 e0 10	 and	 eax, 16
  00227	85 c0		 test	 eax, eax
  00229	74 20		 je	 SHORT $LN12@s390_multi
  0022b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00230	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00236	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0023b	85 c0		 test	 eax, eax
  0023d	74 0c		 je	 SHORT $LN12@s390_multi
  0023f	b2 80		 mov	 dl, 128			; 00000080H
  00241	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_multi:

; 4347 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0024b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00250	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00255	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4348 : 
; 4349 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00259	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0025d	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00262	85 c0		 test	 eax, eax
  00264	74 2d		 je	 SHORT $LN13@s390_multi

; 4350 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00266	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0026a	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0026f	85 c0		 test	 eax, eax
  00271	74 0a		 je	 SHORT $LN16@s390_multi
  00273	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv205[rsp], -1536 ; fffffffffffffa00H
  0027b	eb 08		 jmp	 SHORT $LN17@s390_multi
$LN16@s390_multi:
  0027d	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv205[rsp], 1536 ; 00000600H
$LN17@s390_multi:
  00285	8b 4c 24 28	 mov	 ecx, DWORD PTR tv205[rsp]
  00289	e8 00 00 00 00	 call	 f64_scaledResult
  0028e	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN13@s390_multi:
$LN11@s390_multi:

; 4351 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4352 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4353 :     }
; 4354 : 
; 4355 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00293	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00297	d1 e0		 shl	 eax, 1
  00299	48 98		 cdqe
  0029b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002a8	48 8b d0	 mov	 rdx, rax
  002ab	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  002b0	e8 00 00 00 00	 call	 s390_put_float64

; 4356 : 
; 4357 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002b5	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b9	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002be	85 c0		 test	 eax, eax
  002c0	74 0e		 je	 SHORT $LN14@s390_multi
  002c2	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s390_multi:

; 4358 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4359 : }

  002d0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002d4	c3		 ret	 0
s390_multiply_add_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv224 = 52
r1$ = 56
r3$ = 60
ans$ = 64
op1$ = 72
op3$ = 80
op2$ = 88
inst$ = 112
regs$ = 120
s390_multiply_add_bfp_long PROC

; 4365 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4366 :     int        x2, r1, r3, b2;
; 4367 :     VADR       effective_addr2;
; 4368 :     float64_t  op1, op2, op3, ans;
; 4369 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4370 : 
; 4371 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 04	 imul	 rax, rax, 4
  00034	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	c1 f8 04	 sar	 eax, 4
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 10	 shr	 eax, 16
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0005f	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 14	 shr	 eax, 20
  00066	83 e0 0f	 and	 eax, 15
  00069	89 44 24 3c	 mov	 DWORD PTR r3$[rsp], eax
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00072	74 1d		 je	 SHORT $LN8@s390_multi
  00074	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00079	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00085	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00089	03 c8		 add	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s390_multi:
  00091	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00095	c1 e8 0c	 shr	 eax, 12
  00098	83 e0 0f	 and	 eax, 15
  0009b	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0009f	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a4	74 1d		 je	 SHORT $LN9@s390_multi
  000a6	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bb	03 c8		 add	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_multi:
  000c3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ce	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d2	23 c8		 and	 ecx, eax
  000d4	8b c1		 mov	 eax, ecx
  000d6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_multi:
  000da	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000df	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e3	48 83 c0 06	 add	 rax, 6
  000e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f0	33 c0		 xor	 eax, eax
  000f2	83 f8 06	 cmp	 eax, 6
  000f5	74 0c		 je	 SHORT $LN10@s390_multi
  000f7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_multi:
  00103	33 c0		 xor	 eax, eax
  00105	85 c0		 test	 eax, eax
  00107	75 d1		 jne	 SHORT $LN4@s390_multi

; 4372 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4373 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4374 :     BFPINST_CHECK( regs );

  00109	b8 08 00 00 00	 mov	 eax, 8
  0010e	48 6b c0 01	 imul	 rax, rax, 1
  00112	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00123	85 c0		 test	 eax, eax
  00125	74 39		 je	 SHORT $LN12@s390_multi
  00127	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00132	d1 e8		 shr	 eax, 1
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	74 49		 je	 SHORT $LN11@s390_multi
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00147	b9 08 00 00 00	 mov	 ecx, 8
  0014c	48 6b c9 01	 imul	 rcx, rcx, 1
  00150	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00157	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0015c	85 c0		 test	 eax, eax
  0015e	75 24		 jne	 SHORT $LN11@s390_multi
$LN12@s390_multi:
  00160	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00165	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0016f	ba 07 00 00 00	 mov	 edx, 7
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_multi:
$LN7@s390_multi:

; 4375 : 
; 4376 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  00184	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00188	d1 e0		 shl	 eax, 1
  0018a	48 98		 cdqe
  0018c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00191	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00199	48 8b d0	 mov	 rdx, rax
  0019c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  001a1	e8 00 00 00 00	 call	 s390_get_float64
  001a6	8b 44 24 3c	 mov	 eax, DWORD PTR r3$[rsp]
  001aa	d1 e0		 shl	 eax, 1
  001ac	48 98		 cdqe
  001ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001bb	48 8b d0	 mov	 rdx, rax
  001be	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op3$[rsp]
  001c3	e8 00 00 00 00	 call	 s390_get_float64
  001c8	33 c0		 xor	 eax, eax
  001ca	85 c0		 test	 eax, eax
  001cc	75 b6		 jne	 SHORT $LN7@s390_multi

; 4377 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001ce	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001d3	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001d7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001db	e8 00 00 00 00	 call	 s390_vfetch8
  001e0	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 4378 : 
; 4379 :     softfloat_exceptionFlags = 0;

  001e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ea	8b c0		 mov	 eax, eax
  001ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ff	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4380 :     SET_SF_RM_FROM_FPC;

  00203	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00208	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0020e	83 e0 07	 and	 eax, 7
  00211	8b c0		 mov	 eax, eax
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0021a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0021f	8b d2		 mov	 edx, edx
  00221	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00228	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00231	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00235	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00239	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4381 : 
; 4382 :     ans = f64_mulAdd( op2, op3, op1 );

  0023d	4c 8b 44 24 48	 mov	 r8, QWORD PTR op1$[rsp]
  00242	48 8b 54 24 50	 mov	 rdx, QWORD PTR op3$[rsp]
  00247	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op2$[rsp]
  0024c	e8 00 00 00 00	 call	 f64_mulAdd
  00251	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 4383 : 
; 4384 :     if (softfloat_exceptionFlags)

  00256	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0025b	8b c0		 mov	 eax, eax
  0025d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00263	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00270	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00274	85 c0		 test	 eax, eax
  00276	0f 84 94 00 00
	00		 je	 $LN13@s390_multi

; 4385 :     {
; 4386 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0027c	33 c0		 xor	 eax, eax
  0027e	83 f8 01	 cmp	 eax, 1
  00281	74 45		 je	 SHORT $LN14@s390_multi
  00283	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00288	8b c0		 mov	 eax, eax
  0028a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00290	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00299	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a1	83 e0 10	 and	 eax, 16
  002a4	85 c0		 test	 eax, eax
  002a6	74 20		 je	 SHORT $LN14@s390_multi
  002a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002b3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002b8	85 c0		 test	 eax, eax
  002ba	74 0c		 je	 SHORT $LN14@s390_multi
  002bc	b2 80		 mov	 dl, 128			; 00000080H
  002be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c3	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_multi:

; 4387 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002d2	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4388 : 
; 4389 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002d6	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002da	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002df	85 c0		 test	 eax, eax
  002e1	74 2d		 je	 SHORT $LN15@s390_multi

; 4390 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002e3	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e7	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002ec	85 c0		 test	 eax, eax
  002ee	74 0a		 je	 SHORT $LN18@s390_multi
  002f0	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv224[rsp], -1536 ; fffffffffffffa00H
  002f8	eb 08		 jmp	 SHORT $LN19@s390_multi
$LN18@s390_multi:
  002fa	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv224[rsp], 1536 ; 00000600H
$LN19@s390_multi:
  00302	8b 4c 24 34	 mov	 ecx, DWORD PTR tv224[rsp]
  00306	e8 00 00 00 00	 call	 f64_scaledResult
  0030b	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN15@s390_multi:
$LN13@s390_multi:

; 4391 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4392 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4393 :     }
; 4394 : 
; 4395 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00310	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00314	d1 e0		 shl	 eax, 1
  00316	48 98		 cdqe
  00318	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0031d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00325	48 8b d0	 mov	 rdx, rax
  00328	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  0032d	e8 00 00 00 00	 call	 s390_put_float64

; 4396 : 
; 4397 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00332	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00336	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0033b	85 c0		 test	 eax, eax
  0033d	74 0e		 je	 SHORT $LN16@s390_multi
  0033f	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00343	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00348	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_multi:

; 4398 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4399 : }

  0034d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00351	c3		 ret	 0
s390_multiply_add_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
tv206 = 44
r1$ = 48
r2$ = 52
op1$ = 56
op2$ = 64
inst$ = 96
regs$ = 104
s390_load_rounded_bfp_long_to_short_reg PROC

; 3726 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3727 :     int        r1, r2;
; 3728 :     BYTE       m3, m4;
; 3729 :     float64_t  op2;
; 3730 :     float32_t  op1;
; 3731 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3732 : 
; 3733 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_load_:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s390_load_
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s390_load_

; 3734 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3735 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s390_load_
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s390_load_
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3736 : 
; 3737 :     GET_FLOAT64_OP( op2, r2, regs );

  0010a	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0010e	d1 e0		 shl	 eax, 1
  00110	48 98		 cdqe
  00112	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011f	48 8b d0	 mov	 rdx, rax
  00122	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  00127	e8 00 00 00 00	 call	 s390_get_float64

; 3738 : 
; 3739 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3740 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3741 :         SET_SF_RM_FROM_MASK( m3 );
; 3742 :     else
; 3743 : #endif
; 3744 :     {
; 3745 :         if (m3 || m4)

  0012c	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00131	85 c0		 test	 eax, eax
  00133	75 09		 jne	 SHORT $LN9@s390_load_
  00135	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  0013a	85 c0		 test	 eax, eax
  0013c	74 15		 je	 SHORT $LN8@s390_load_
$LN9@s390_load_:

; 3746 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0013e	ba 06 00 00 00	 mov	 edx, 6
  00143	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3747 :         SET_SF_RM_FROM_FPC;

  00153	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00158	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0015e	83 e0 07	 and	 eax, 7
  00161	8b c0		 mov	 eax, eax
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0016f	8b d2		 mov	 edx, edx
  00171	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00178	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00181	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00185	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00189	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3748 :     }
; 3749 : 
; 3750 :     softfloat_exceptionFlags = 0;

  0018d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00192	8b c0		 mov	 eax, eax
  00194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001a7	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3751 : 
; 3752 :     op1 = f64_to_f32( op2 );

  001ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 f64_to_f32
  001b5	89 44 24 38	 mov	 DWORD PTR op1$[rsp], eax

; 3753 : 
; 3754 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3755 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3756 :     {
; 3757 :         if (SUPPRESS_INEXACT( m4 ))
; 3758 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;
; 3759 :     }
; 3760 : #endif
; 3761 : 
; 3762 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001b9	33 c0		 xor	 eax, eax
  001bb	83 f8 01	 cmp	 eax, 1
  001be	74 45		 je	 SHORT $LN10@s390_load_
  001c0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c5	8b c0		 mov	 eax, eax
  001c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001cd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001de	83 e0 10	 and	 eax, 16
  001e1	85 c0		 test	 eax, eax
  001e3	74 20		 je	 SHORT $LN10@s390_load_
  001e5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ea	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001f5	85 c0		 test	 eax, eax
  001f7	74 0c		 je	 SHORT $LN10@s390_load_
  001f9	b2 80		 mov	 dl, 128			; 00000080H
  001fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00200	e8 00 00 00 00	 call	 ieee_trap
$LN10@s390_load_:

; 3763 : 
; 3764 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  00205	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00209	d1 e0		 shl	 eax, 1
  0020b	48 98		 cdqe
  0020d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0021a	48 8b d0	 mov	 rdx, rax
  0021d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00222	e8 00 00 00 00	 call	 s390_put_float32

; 3765 : 
; 3766 :     if (softfloat_exceptionFlags)

  00227	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0022c	8b c0		 mov	 eax, eax
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00234	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00241	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00245	85 c0		 test	 eax, eax
  00247	0f 84 85 00 00
	00		 je	 $LN11@s390_load_

; 3767 :     {
; 3768 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0024d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00252	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00257	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3769 : 
; 3770 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0025b	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0025f	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00264	85 c0		 test	 eax, eax
  00266	74 4f		 je	 SHORT $LN12@s390_load_

; 3771 :         {
; 3772 :             op2 = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00268	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0026c	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00271	85 c0		 test	 eax, eax
  00273	74 0a		 je	 SHORT $LN15@s390_load_
  00275	c7 44 24 2c 00
	fe ff ff	 mov	 DWORD PTR tv206[rsp], -512 ; fffffffffffffe00H
  0027d	eb 08		 jmp	 SHORT $LN16@s390_load_
$LN15@s390_load_:
  0027f	c7 44 24 2c 00
	02 00 00	 mov	 DWORD PTR tv206[rsp], 512 ; 00000200H
$LN16@s390_load_:
  00287	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv206[rsp]
  0028b	e8 00 00 00 00	 call	 f64_scaledResult
  00290	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 3773 :                 SCALE_FACTOR_LOADR_OFLOW_LONG :
; 3774 :                 SCALE_FACTOR_LOADR_UFLOW_LONG );
; 3775 : 
; 3776 :             PUT_FLOAT64_NOCC( op2, r1, regs );

  00295	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00299	d1 e0		 shl	 eax, 1
  0029b	48 98		 cdqe
  0029d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002aa	48 8b d0	 mov	 rdx, rax
  002ad	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  002b2	e8 00 00 00 00	 call	 s390_put_float64
$LN12@s390_load_:

; 3777 :         }
; 3778 : 
; 3779 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002b7	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002bb	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002c0	85 c0		 test	 eax, eax
  002c2	74 0e		 je	 SHORT $LN13@s390_load_
  002c4	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	e8 00 00 00 00	 call	 ieee_cond_trap
$LN13@s390_load_:
$LN11@s390_load_:

; 3780 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3781 :     }
; 3782 : }

  002d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d6	c3		 ret	 0
s390_load_rounded_bfp_long_to_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
r1$ = 44
r2$ = 48
tv213 = 52
op1$ = 56
$T2 = 64
$T3 = 80
op2$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s390_load_rounded_bfp_ext_to_short_reg PROC

; 3853 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3854 :     int         r1, r2;
; 3855 :     BYTE        m3, m4;
; 3856 :     float128_t  op2;
; 3857 :     float32_t   op1;
; 3858 :     U32         ieee_trap_conds = 0;

  00022	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3859 : 
; 3860 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  0004d	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 04	 shr	 eax, 4
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0005b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 08	 shr	 eax, 8
  00062	83 e0 0f	 and	 eax, 15
  00065	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00069	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 0c	 shr	 eax, 12
  00070	83 e0 0f	 and	 eax, 15
  00073	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_load_:
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00083	48 83 c0 04	 add	 rax, 4
  00087	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00093	33 c0		 xor	 eax, eax
  00095	83 f8 04	 cmp	 eax, 4
  00098	74 0f		 je	 SHORT $LN5@s390_load_
  0009a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 c8		 jne	 SHORT $LN4@s390_load_

; 3861 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3862 :     BFPINST_CHECK( regs );

  000af	b8 08 00 00 00	 mov	 eax, 8
  000b4	48 6b c0 01	 imul	 rax, rax, 1
  000b8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c7	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cc	85 c0		 test	 eax, eax
  000ce	74 3f		 je	 SHORT $LN7@s390_load_
  000d0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000de	d1 e8		 shr	 eax, 1
  000e0	83 e0 01	 and	 eax, 1
  000e3	85 c0		 test	 eax, eax
  000e5	74 55		 je	 SHORT $LN6@s390_load_
  000e7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f6	b9 08 00 00 00	 mov	 ecx, 8
  000fb	48 6b c9 01	 imul	 rcx, rcx, 1
  000ff	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00106	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010b	85 c0		 test	 eax, eax
  0010d	75 2d		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  0010f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00121	ba 07 00 00 00	 mov	 edx, 7
  00126	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3863 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  0013c	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00140	83 e0 02	 and	 eax, 2
  00143	85 c0		 test	 eax, eax
  00145	75 0b		 jne	 SHORT $LN9@s390_load_
  00147	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0014b	83 e0 02	 and	 eax, 2
  0014e	85 c0		 test	 eax, eax
  00150	74 1b		 je	 SHORT $LN8@s390_load_
$LN9@s390_load_:
  00152	ba 06 00 00 00	 mov	 edx, 6
  00157	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00167	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3864 : 
; 3865 :     GET_FLOAT128_OP( op2, r2, regs );

  0016d	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00171	d1 e0		 shl	 eax, 1
  00173	48 98		 cdqe
  00175	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00185	48 8b d0	 mov	 rdx, rax
  00188	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  0018d	e8 00 00 00 00	 call	 s390_get_float128

; 3866 : 
; 3867 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3868 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3869 :         SET_SF_RM_FROM_MASK( m3 );
; 3870 :     else
; 3871 : #endif
; 3872 :     {
; 3873 :         if (m3 || m4)

  00192	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00197	85 c0		 test	 eax, eax
  00199	75 09		 jne	 SHORT $LN11@s390_load_
  0019b	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  001a0	85 c0		 test	 eax, eax
  001a2	74 1b		 je	 SHORT $LN10@s390_load_
$LN11@s390_load_:

; 3874 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001a4	ba 06 00 00 00	 mov	 edx, 6
  001a9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s390_load_:

; 3875 :         SET_SF_RM_FROM_FPC;

  001bf	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cd	83 e0 07	 and	 eax, 7
  001d0	8b c0		 mov	 eax, eax
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001de	8b d2		 mov	 edx, edx
  001e0	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001e7	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001f0	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3876 :     }
; 3877 : 
; 3878 :     softfloat_exceptionFlags = 0;

  001fc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00201	8b c0		 mov	 eax, eax
  00203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00209	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00212	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00216	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3879 : 
; 3880 :     op1 = f128_to_f32( op2 );

  0021a	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0021f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  00224	48 8b f8	 mov	 rdi, rax
  00227	48 8b f1	 mov	 rsi, rcx
  0022a	b9 10 00 00 00	 mov	 ecx, 16
  0022f	f3 a4		 rep movsb
  00231	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00236	e8 00 00 00 00	 call	 f128_to_f32
  0023b	89 44 24 38	 mov	 DWORD PTR op1$[rsp], eax

; 3881 : 
; 3882 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3883 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3884 :     {
; 3885 :         if (SUPPRESS_INEXACT( m4 ))
; 3886 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;
; 3887 :     }
; 3888 : #endif
; 3889 : 
; 3890 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0023f	33 c0		 xor	 eax, eax
  00241	83 f8 01	 cmp	 eax, 1
  00244	74 4b		 je	 SHORT $LN12@s390_load_
  00246	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0024b	8b c0		 mov	 eax, eax
  0024d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00253	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00260	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00264	83 e0 10	 and	 eax, 16
  00267	85 c0		 test	 eax, eax
  00269	74 26		 je	 SHORT $LN12@s390_load_
  0026b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00273	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00279	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0027e	85 c0		 test	 eax, eax
  00280	74 0f		 je	 SHORT $LN12@s390_load_
  00282	b2 80		 mov	 dl, 128			; 00000080H
  00284	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_load_:

; 3891 : 
; 3892 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  00291	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00295	d1 e0		 shl	 eax, 1
  00297	48 98		 cdqe
  00299	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a1	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002a9	48 8b d0	 mov	 rdx, rax
  002ac	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  002b1	e8 00 00 00 00	 call	 s390_put_float32

; 3893 : 
; 3894 :     if (softfloat_exceptionFlags)

  002b6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002bb	8b c0		 mov	 eax, eax
  002bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002cc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d4	85 c0		 test	 eax, eax
  002d6	0f 84 a0 00 00
	00		 je	 $LN13@s390_load_

; 3895 :     {
; 3896 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002dc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e4	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002e9	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3897 : 
; 3898 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ed	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f1	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002f6	85 c0		 test	 eax, eax
  002f8	74 64		 je	 SHORT $LN14@s390_load_

; 3899 :         {
; 3900 :             op2 = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002fa	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002fe	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00303	85 c0		 test	 eax, eax
  00305	74 0a		 je	 SHORT $LN17@s390_load_
  00307	c7 44 24 34 00
	e0 ff ff	 mov	 DWORD PTR tv213[rsp], -8192 ; ffffffffffffe000H
  0030f	eb 08		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  00311	c7 44 24 34 00
	20 00 00	 mov	 DWORD PTR tv213[rsp], 8192 ; 00002000H
$LN18@s390_load_:
  00319	8b 54 24 34	 mov	 edx, DWORD PTR tv213[rsp]
  0031d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  00322	e8 00 00 00 00	 call	 f128_scaledResult
  00327	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  0032c	48 8b f9	 mov	 rdi, rcx
  0032f	48 8b f0	 mov	 rsi, rax
  00332	b9 10 00 00 00	 mov	 ecx, 16
  00337	f3 a4		 rep movsb

; 3901 :                 SCALE_FACTOR_LOADR_OFLOW_EXTD :
; 3902 :                 SCALE_FACTOR_LOADR_UFLOW_EXTD );
; 3903 : 
; 3904 :             PUT_FLOAT128_NOCC( op2, r1, regs );

  00339	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0033d	d1 e0		 shl	 eax, 1
  0033f	48 98		 cdqe
  00341	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00349	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00351	48 8b d0	 mov	 rdx, rax
  00354	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  00359	e8 00 00 00 00	 call	 s390_put_float128
$LN14@s390_load_:

; 3905 :         }
; 3906 : 
; 3907 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0035e	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00362	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00367	85 c0		 test	 eax, eax
  00369	74 11		 je	 SHORT $LN15@s390_load_
  0036b	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0036f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00377	e8 00 00 00 00	 call	 ieee_cond_trap
$LN15@s390_load_:
$LN13@s390_load_:

; 3908 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3909 :     }
; 3910 : }

  0037c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00381	48 33 cc	 xor	 rcx, rsp
  00384	e8 00 00 00 00	 call	 __security_check_cookie
  00389	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00390	5f		 pop	 rdi
  00391	5e		 pop	 rsi
  00392	c3		 ret	 0
s390_load_rounded_bfp_ext_to_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
r1$ = 44
r2$ = 48
tv213 = 52
op1$ = 56
$T2 = 64
$T3 = 80
op2$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s390_load_rounded_bfp_ext_to_long_reg PROC

; 3789 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3790 :     int         r1, r2;
; 3791 :     BYTE        m3, m4;
; 3792 :     float128_t  op2;
; 3793 :     float64_t   op1;
; 3794 :     U32         ieee_trap_conds = 0;

  00022	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3795 : 
; 3796 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  0004d	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 04	 shr	 eax, 4
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0005b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 08	 shr	 eax, 8
  00062	83 e0 0f	 and	 eax, 15
  00065	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00069	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 0c	 shr	 eax, 12
  00070	83 e0 0f	 and	 eax, 15
  00073	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_load_:
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00083	48 83 c0 04	 add	 rax, 4
  00087	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00093	33 c0		 xor	 eax, eax
  00095	83 f8 04	 cmp	 eax, 4
  00098	74 0f		 je	 SHORT $LN5@s390_load_
  0009a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 c8		 jne	 SHORT $LN4@s390_load_

; 3797 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3798 :     BFPINST_CHECK( regs );

  000af	b8 08 00 00 00	 mov	 eax, 8
  000b4	48 6b c0 01	 imul	 rax, rax, 1
  000b8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c7	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cc	85 c0		 test	 eax, eax
  000ce	74 3f		 je	 SHORT $LN7@s390_load_
  000d0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000de	d1 e8		 shr	 eax, 1
  000e0	83 e0 01	 and	 eax, 1
  000e3	85 c0		 test	 eax, eax
  000e5	74 55		 je	 SHORT $LN6@s390_load_
  000e7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f6	b9 08 00 00 00	 mov	 ecx, 8
  000fb	48 6b c9 01	 imul	 rcx, rcx, 1
  000ff	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00106	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010b	85 c0		 test	 eax, eax
  0010d	75 2d		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  0010f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00121	ba 07 00 00 00	 mov	 edx, 7
  00126	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3799 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  0013c	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00140	83 e0 02	 and	 eax, 2
  00143	85 c0		 test	 eax, eax
  00145	75 0b		 jne	 SHORT $LN9@s390_load_
  00147	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0014b	83 e0 02	 and	 eax, 2
  0014e	85 c0		 test	 eax, eax
  00150	74 1b		 je	 SHORT $LN8@s390_load_
$LN9@s390_load_:
  00152	ba 06 00 00 00	 mov	 edx, 6
  00157	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00167	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3800 : 
; 3801 :     GET_FLOAT128_OP( op2, r2, regs );

  0016d	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00171	d1 e0		 shl	 eax, 1
  00173	48 98		 cdqe
  00175	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00185	48 8b d0	 mov	 rdx, rax
  00188	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  0018d	e8 00 00 00 00	 call	 s390_get_float128

; 3802 : 
; 3803 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3804 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3805 :         SET_SF_RM_FROM_MASK( m3 );
; 3806 :     else
; 3807 : #endif
; 3808 :     {
; 3809 :         if (m3 || m4)

  00192	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00197	85 c0		 test	 eax, eax
  00199	75 09		 jne	 SHORT $LN11@s390_load_
  0019b	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  001a0	85 c0		 test	 eax, eax
  001a2	74 1b		 je	 SHORT $LN10@s390_load_
$LN11@s390_load_:

; 3810 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001a4	ba 06 00 00 00	 mov	 edx, 6
  001a9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s390_load_:

; 3811 :         SET_SF_RM_FROM_FPC;

  001bf	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cd	83 e0 07	 and	 eax, 7
  001d0	8b c0		 mov	 eax, eax
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001de	8b d2		 mov	 edx, edx
  001e0	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001e7	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001f0	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3812 :     }
; 3813 : 
; 3814 :     softfloat_exceptionFlags = 0;

  001fc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00201	8b c0		 mov	 eax, eax
  00203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00209	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00212	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00216	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3815 : 
; 3816 :     op1 = f128_to_f64( op2 );

  0021a	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0021f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  00224	48 8b f8	 mov	 rdi, rax
  00227	48 8b f1	 mov	 rsi, rcx
  0022a	b9 10 00 00 00	 mov	 ecx, 16
  0022f	f3 a4		 rep movsb
  00231	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00236	e8 00 00 00 00	 call	 f128_to_f64
  0023b	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 3817 : 
; 3818 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3819 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3820 :     {
; 3821 :         if (SUPPRESS_INEXACT( m4 ))
; 3822 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;
; 3823 :     }
; 3824 : #endif
; 3825 : 
; 3826 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00240	33 c0		 xor	 eax, eax
  00242	83 f8 01	 cmp	 eax, 1
  00245	74 4b		 je	 SHORT $LN12@s390_load_
  00247	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0024c	8b c0		 mov	 eax, eax
  0024e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00254	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00261	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00265	83 e0 10	 and	 eax, 16
  00268	85 c0		 test	 eax, eax
  0026a	74 26		 je	 SHORT $LN12@s390_load_
  0026c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00274	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0027a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0027f	85 c0		 test	 eax, eax
  00281	74 0f		 je	 SHORT $LN12@s390_load_
  00283	b2 80		 mov	 dl, 128			; 00000080H
  00285	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028d	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_load_:

; 3827 : 
; 3828 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00292	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00296	d1 e0		 shl	 eax, 1
  00298	48 98		 cdqe
  0029a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002aa	48 8b d0	 mov	 rdx, rax
  002ad	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  002b2	e8 00 00 00 00	 call	 s390_put_float64

; 3829 : 
; 3830 :     if (softfloat_exceptionFlags)

  002b7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002bc	8b c0		 mov	 eax, eax
  002be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002cd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d5	85 c0		 test	 eax, eax
  002d7	0f 84 a0 00 00
	00		 je	 $LN13@s390_load_

; 3831 :     {
; 3832 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e5	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002ea	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3833 : 
; 3834 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ee	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f2	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002f7	85 c0		 test	 eax, eax
  002f9	74 64		 je	 SHORT $LN14@s390_load_

; 3835 :         {
; 3836 :             op2 = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002fb	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ff	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00304	85 c0		 test	 eax, eax
  00306	74 0a		 je	 SHORT $LN17@s390_load_
  00308	c7 44 24 34 00
	e0 ff ff	 mov	 DWORD PTR tv213[rsp], -8192 ; ffffffffffffe000H
  00310	eb 08		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  00312	c7 44 24 34 00
	20 00 00	 mov	 DWORD PTR tv213[rsp], 8192 ; 00002000H
$LN18@s390_load_:
  0031a	8b 54 24 34	 mov	 edx, DWORD PTR tv213[rsp]
  0031e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  00323	e8 00 00 00 00	 call	 f128_scaledResult
  00328	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  0032d	48 8b f9	 mov	 rdi, rcx
  00330	48 8b f0	 mov	 rsi, rax
  00333	b9 10 00 00 00	 mov	 ecx, 16
  00338	f3 a4		 rep movsb

; 3837 :                 SCALE_FACTOR_LOADR_OFLOW_EXTD :
; 3838 :                 SCALE_FACTOR_LOADR_UFLOW_EXTD );
; 3839 : 
; 3840 :             PUT_FLOAT128_NOCC( op2, r1, regs );

  0033a	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0033e	d1 e0		 shl	 eax, 1
  00340	48 98		 cdqe
  00342	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00352	48 8b d0	 mov	 rdx, rax
  00355	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  0035a	e8 00 00 00 00	 call	 s390_put_float128
$LN14@s390_load_:

; 3841 :         }
; 3842 : 
; 3843 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0035f	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00363	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00368	85 c0		 test	 eax, eax
  0036a	74 11		 je	 SHORT $LN15@s390_load_
  0036c	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00370	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	e8 00 00 00 00	 call	 ieee_cond_trap
$LN15@s390_load_:
$LN13@s390_load_:

; 3844 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3845 :     }
; 3846 : }

  0037d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00382	48 33 cc	 xor	 rcx, rsp
  00385	e8 00 00 00 00	 call	 __security_check_cookie
  0038a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00391	5f		 pop	 rdi
  00392	5e		 pop	 rsi
  00393	c3		 ret	 0
s390_load_rounded_bfp_ext_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv151 = 40
tv154 = 44
tv156 = 48
tv157 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s390_load_positive_bfp_short_reg PROC

; 3686 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3687 :     int        r1, r2;
; 3688 :     float32_t  op;
; 3689 : 
; 3690 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3691 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3692 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3693 : 
; 3694 :     GET_FLOAT32_OP( op, r2, regs );

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float32

; 3695 :     op.v &= ~0x80000000;

  00109	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0010d	0f ba f0 1f	 btr	 eax, 31
  00111	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN7@s390_load_:

; 3696 : 
; 3697 :     PUT_FLOAT32_CC( op, r1, regs );

  00115	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00119	d1 e0		 shl	 eax, 1
  0011b	48 98		 cdqe
  0011d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00132	e8 00 00 00 00	 call	 s390_put_float32
  00137	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0013b	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00140	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00145	75 17		 jne	 SHORT $LN12@s390_load_
  00147	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0014b	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00150	85 c0		 test	 eax, eax
  00152	74 0a		 je	 SHORT $LN12@s390_load_
  00154	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0015c	eb 5e		 jmp	 SHORT $LN19@s390_load_
$LN12@s390_load_:
  0015e	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00162	0f ba f0 1f	 btr	 eax, 31
  00166	85 c0		 test	 eax, eax
  00168	75 0a		 jne	 SHORT $LN13@s390_load_
  0016a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00172	eb 08		 jmp	 SHORT $LN14@s390_load_
$LN13@s390_load_:
  00174	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s390_load_:
  0017c	83 7c 24 28 00	 cmp	 DWORD PTR tv151[rsp], 0
  00181	74 0a		 je	 SHORT $LN17@s390_load_
  00183	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  0018b	eb 27		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  0018d	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00191	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00196	85 c0		 test	 eax, eax
  00198	74 0a		 je	 SHORT $LN15@s390_load_
  0019a	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN16@s390_load_
$LN15@s390_load_:
  001a4	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s390_load_:
  001ac	8b 44 24 2c	 mov	 eax, DWORD PTR tv154[rsp]
  001b0	89 44 24 30	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s390_load_:
  001b4	8b 44 24 30	 mov	 eax, DWORD PTR tv156[rsp]
  001b8	89 44 24 34	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s390_load_:
  001bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv157[rsp]
  001c6	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  001c9	33 c0		 xor	 eax, eax
  001cb	85 c0		 test	 eax, eax
  001cd	0f 85 42 ff ff
	ff		 jne	 $LN7@s390_load_

; 3698 : }

  001d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d7	c3		 ret	 0
s390_load_positive_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv151 = 36
tv154 = 40
tv156 = 44
tv157 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s390_load_positive_bfp_long_reg PROC

; 3667 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3668 :     int        r1, r2;
; 3669 :     float64_t  op;
; 3670 : 
; 3671 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3672 : 
; 3673 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3674 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_load_
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_load_
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3675 : 
; 3676 :     GET_FLOAT64_OP( op, r2, regs );

  000e7	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float64

; 3677 :     op.v  &= ~0x8000000000000000ULL;

  00109	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00118	48 23 c8	 and	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN7@s390_load_:

; 3678 : 
; 3679 :     PUT_FLOAT64_CC( op, r1, regs );

  00123	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00127	d1 e0		 shl	 eax, 1
  00129	48 98		 cdqe
  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00138	48 8b d0	 mov	 rdx, rax
  0013b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00140	e8 00 00 00 00	 call	 s390_put_float64
  00145	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0014f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00154	48 23 c8	 and	 rcx, rax
  00157	48 8b c1	 mov	 rax, rcx
  0015a	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00164	48 3b c1	 cmp	 rax, rcx
  00167	75 24		 jne	 SHORT $LN12@s390_load_
  00169	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00178	48 23 c8	 and	 rcx, rax
  0017b	48 8b c1	 mov	 rax, rcx
  0017e	48 85 c0	 test	 rax, rax
  00181	74 0a		 je	 SHORT $LN12@s390_load_
  00183	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0018b	eb 79		 jmp	 SHORT $LN19@s390_load_
$LN12@s390_load_:
  0018d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00197	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019c	48 23 c8	 and	 rcx, rax
  0019f	48 8b c1	 mov	 rax, rcx
  001a2	48 85 c0	 test	 rax, rax
  001a5	75 0a		 jne	 SHORT $LN13@s390_load_
  001a7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN14@s390_load_
$LN13@s390_load_:
  001b1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s390_load_:
  001b9	83 7c 24 24 00	 cmp	 DWORD PTR tv151[rsp], 0
  001be	74 0a		 je	 SHORT $LN17@s390_load_
  001c0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  001c8	eb 34		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  001ca	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d9	48 23 c8	 and	 rcx, rax
  001dc	48 8b c1	 mov	 rax, rcx
  001df	48 85 c0	 test	 rax, rax
  001e2	74 0a		 je	 SHORT $LN15@s390_load_
  001e4	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001ec	eb 08		 jmp	 SHORT $LN16@s390_load_
$LN15@s390_load_:
  001ee	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s390_load_:
  001f6	8b 44 24 28	 mov	 eax, DWORD PTR tv154[rsp]
  001fa	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s390_load_:
  001fe	8b 44 24 2c	 mov	 eax, DWORD PTR tv156[rsp]
  00202	89 44 24 30	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s390_load_:
  00206	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv157[rsp]
  00210	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 06 ff ff
	ff		 jne	 $LN7@s390_load_

; 3680 : }

  0021d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00221	c3		 ret	 0
s390_load_positive_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv174 = 44
tv179 = 48
tv181 = 52
tv182 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
s390_load_positive_bfp_ext_reg PROC

; 3647 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3648 :     int         r1, r2;
; 3649 :     float128_t  op;
; 3650 : 
; 3651 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN8@s390_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@s390_load_

; 3652 : 
; 3653 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3654 :     BFPINST_CHECK( regs );

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00090	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00095	85 c0		 test	 eax, eax
  00097	74 39		 je	 SHORT $LN10@s390_load_
  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a4	d1 e8		 shr	 eax, 1
  000a6	83 e0 01	 and	 eax, 1
  000a9	85 c0		 test	 eax, eax
  000ab	74 49		 je	 SHORT $LN9@s390_load_
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b9	b9 08 00 00 00	 mov	 ecx, 8
  000be	48 6b c9 01	 imul	 rcx, rcx, 1
  000c2	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ce	85 c0		 test	 eax, eax
  000d0	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000d2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e1	ba 07 00 00 00	 mov	 edx, 7
  000e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3655 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  000f6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000fa	83 e0 02	 and	 eax, 2
  000fd	85 c0		 test	 eax, eax
  000ff	75 0b		 jne	 SHORT $LN12@s390_load_
  00101	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00105	83 e0 02	 and	 eax, 2
  00108	85 c0		 test	 eax, eax
  0010a	74 15		 je	 SHORT $LN11@s390_load_
$LN12@s390_load_:
  0010c	ba 06 00 00 00	 mov	 edx, 6
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_load_:

; 3656 : 
; 3657 :     GET_FLOAT128_OP( op, r2, regs );

  00121	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00125	d1 e0		 shl	 eax, 1
  00127	48 98		 cdqe
  00129	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00136	48 8b d0	 mov	 rdx, rax
  00139	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0013e	e8 00 00 00 00	 call	 s390_get_float128

; 3658 :     op.v[FLOAT128_HI] &= ~0x8000000000000000ULL;

  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 01	 imul	 rax, rax, 1
  0014c	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00156	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0015b	48 23 c1	 and	 rax, rcx
  0015e	b9 08 00 00 00	 mov	 ecx, 8
  00163	48 6b c9 01	 imul	 rcx, rcx, 1
  00167	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN7@s390_load_:

; 3659 : 
; 3660 :     PUT_FLOAT128_CC( op, r1, regs );

  0016c	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00170	d1 e0		 shl	 eax, 1
  00172	48 98		 cdqe
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00181	48 8b d0	 mov	 rdx, rax
  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00189	e8 00 00 00 00	 call	 s390_put_float128
  0018e	b8 08 00 00 00	 mov	 eax, 8
  00193	48 6b c0 01	 imul	 rax, rax, 1
  00197	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001a1	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001a6	48 23 c1	 and	 rax, rcx
  001a9	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001b3	48 3b c1	 cmp	 rax, rcx
  001b6	75 3e		 jne	 SHORT $LN15@s390_load_
  001b8	b8 08 00 00 00	 mov	 eax, 8
  001bd	48 6b c0 01	 imul	 rax, rax, 1
  001c1	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001cb	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001d0	48 23 c1	 and	 rax, rcx
  001d3	48 85 c0	 test	 rax, rax
  001d6	75 11		 jne	 SHORT $LN14@s390_load_
  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 00	 imul	 rax, rax, 0
  001e1	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  001e7	74 0d		 je	 SHORT $LN15@s390_load_
$LN14@s390_load_:
  001e9	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv182[rsp], 3
  001f1	e9 93 00 00 00	 jmp	 $LN22@s390_load_
$LN15@s390_load_:
  001f6	b8 08 00 00 00	 mov	 eax, 8
  001fb	48 6b c0 01	 imul	 rax, rax, 1
  001ff	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00209	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0020e	48 23 c1	 and	 rax, rcx
  00211	b9 08 00 00 00	 mov	 ecx, 8
  00216	48 6b c9 00	 imul	 rcx, rcx, 0
  0021a	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  0021f	48 85 c0	 test	 rax, rax
  00222	75 0a		 jne	 SHORT $LN16@s390_load_
  00224	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0022c	eb 08		 jmp	 SHORT $LN17@s390_load_
$LN16@s390_load_:
  0022e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN17@s390_load_:
  00236	83 7c 24 2c 00	 cmp	 DWORD PTR tv174[rsp], 0
  0023b	74 0a		 je	 SHORT $LN20@s390_load_
  0023d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
  00245	eb 3a		 jmp	 SHORT $LN21@s390_load_
$LN20@s390_load_:
  00247	b8 08 00 00 00	 mov	 eax, 8
  0024c	48 6b c0 01	 imul	 rax, rax, 1
  00250	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025a	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0025f	48 23 c1	 and	 rax, rcx
  00262	48 85 c0	 test	 rax, rax
  00265	74 0a		 je	 SHORT $LN18@s390_load_
  00267	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  0026f	eb 08		 jmp	 SHORT $LN19@s390_load_
$LN18@s390_load_:
  00271	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv179[rsp], 2
$LN19@s390_load_:
  00279	8b 44 24 30	 mov	 eax, DWORD PTR tv179[rsp]
  0027d	89 44 24 34	 mov	 DWORD PTR tv181[rsp], eax
$LN21@s390_load_:
  00281	8b 44 24 34	 mov	 eax, DWORD PTR tv181[rsp]
  00285	89 44 24 38	 mov	 DWORD PTR tv182[rsp], eax
$LN22@s390_load_:
  00289	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0028e	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv182[rsp]
  00293	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00296	33 c0		 xor	 eax, eax
  00298	85 c0		 test	 eax, eax
  0029a	0f 85 cc fe ff
	ff		 jne	 $LN7@s390_load_

; 3661 : }

  002a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a5	48 33 cc	 xor	 rcx, rsp
  002a8	e8 00 00 00 00	 call	 __security_check_cookie
  002ad	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b1	c3		 ret	 0
s390_load_positive_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv151 = 40
tv154 = 44
tv156 = 48
tv157 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s390_load_negative_bfp_short_reg PROC

; 3574 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3575 :     int        r1, r2;
; 3576 :     float32_t  op;
; 3577 : 
; 3578 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3579 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3580 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3581 : 
; 3582 :     GET_FLOAT32_OP( op, r2, regs );

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float32

; 3583 :     op.v |= 0x80000000;

  00109	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0010d	0f ba e8 1f	 bts	 eax, 31
  00111	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN7@s390_load_:

; 3584 : 
; 3585 :     PUT_FLOAT32_CC( op, r1, regs );

  00115	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00119	d1 e0		 shl	 eax, 1
  0011b	48 98		 cdqe
  0011d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00132	e8 00 00 00 00	 call	 s390_put_float32
  00137	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0013b	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00140	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00145	75 17		 jne	 SHORT $LN12@s390_load_
  00147	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0014b	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00150	85 c0		 test	 eax, eax
  00152	74 0a		 je	 SHORT $LN12@s390_load_
  00154	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0015c	eb 5e		 jmp	 SHORT $LN19@s390_load_
$LN12@s390_load_:
  0015e	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00162	0f ba f0 1f	 btr	 eax, 31
  00166	85 c0		 test	 eax, eax
  00168	75 0a		 jne	 SHORT $LN13@s390_load_
  0016a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00172	eb 08		 jmp	 SHORT $LN14@s390_load_
$LN13@s390_load_:
  00174	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s390_load_:
  0017c	83 7c 24 28 00	 cmp	 DWORD PTR tv151[rsp], 0
  00181	74 0a		 je	 SHORT $LN17@s390_load_
  00183	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  0018b	eb 27		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  0018d	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00191	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00196	85 c0		 test	 eax, eax
  00198	74 0a		 je	 SHORT $LN15@s390_load_
  0019a	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN16@s390_load_
$LN15@s390_load_:
  001a4	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s390_load_:
  001ac	8b 44 24 2c	 mov	 eax, DWORD PTR tv154[rsp]
  001b0	89 44 24 30	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s390_load_:
  001b4	8b 44 24 30	 mov	 eax, DWORD PTR tv156[rsp]
  001b8	89 44 24 34	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s390_load_:
  001bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv157[rsp]
  001c6	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  001c9	33 c0		 xor	 eax, eax
  001cb	85 c0		 test	 eax, eax
  001cd	0f 85 42 ff ff
	ff		 jne	 $LN7@s390_load_

; 3586 : }

  001d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d7	c3		 ret	 0
s390_load_negative_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv151 = 36
tv154 = 40
tv156 = 44
tv157 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s390_load_negative_bfp_long_reg PROC

; 3556 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3557 :     int        r1, r2;
; 3558 :     float64_t  op;
; 3559 : 
; 3560 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3561 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3562 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_load_
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_load_
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3563 : 
; 3564 :     GET_FLOAT64_OP( op, r2, regs );

  000e7	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float64

; 3565 :     op.v |= 0x8000000000000000ULL;

  00109	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00118	48 0b c8	 or	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN7@s390_load_:

; 3566 : 
; 3567 :     PUT_FLOAT64_CC( op, r1, regs );

  00123	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00127	d1 e0		 shl	 eax, 1
  00129	48 98		 cdqe
  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00138	48 8b d0	 mov	 rdx, rax
  0013b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00140	e8 00 00 00 00	 call	 s390_put_float64
  00145	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0014f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00154	48 23 c8	 and	 rcx, rax
  00157	48 8b c1	 mov	 rax, rcx
  0015a	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00164	48 3b c1	 cmp	 rax, rcx
  00167	75 24		 jne	 SHORT $LN12@s390_load_
  00169	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00178	48 23 c8	 and	 rcx, rax
  0017b	48 8b c1	 mov	 rax, rcx
  0017e	48 85 c0	 test	 rax, rax
  00181	74 0a		 je	 SHORT $LN12@s390_load_
  00183	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0018b	eb 79		 jmp	 SHORT $LN19@s390_load_
$LN12@s390_load_:
  0018d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00197	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019c	48 23 c8	 and	 rcx, rax
  0019f	48 8b c1	 mov	 rax, rcx
  001a2	48 85 c0	 test	 rax, rax
  001a5	75 0a		 jne	 SHORT $LN13@s390_load_
  001a7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN14@s390_load_
$LN13@s390_load_:
  001b1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s390_load_:
  001b9	83 7c 24 24 00	 cmp	 DWORD PTR tv151[rsp], 0
  001be	74 0a		 je	 SHORT $LN17@s390_load_
  001c0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  001c8	eb 34		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  001ca	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d9	48 23 c8	 and	 rcx, rax
  001dc	48 8b c1	 mov	 rax, rcx
  001df	48 85 c0	 test	 rax, rax
  001e2	74 0a		 je	 SHORT $LN15@s390_load_
  001e4	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001ec	eb 08		 jmp	 SHORT $LN16@s390_load_
$LN15@s390_load_:
  001ee	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s390_load_:
  001f6	8b 44 24 28	 mov	 eax, DWORD PTR tv154[rsp]
  001fa	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s390_load_:
  001fe	8b 44 24 2c	 mov	 eax, DWORD PTR tv156[rsp]
  00202	89 44 24 30	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s390_load_:
  00206	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv157[rsp]
  00210	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 06 ff ff
	ff		 jne	 $LN7@s390_load_

; 3568 : }

  0021d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00221	c3		 ret	 0
s390_load_negative_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv174 = 44
tv179 = 48
tv181 = 52
tv182 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
s390_load_negative_bfp_ext_reg PROC

; 3537 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3538 :     int         r1, r2;
; 3539 :     float128_t  op;
; 3540 : 
; 3541 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN8@s390_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@s390_load_

; 3542 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3543 :     BFPINST_CHECK( regs );

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00090	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00095	85 c0		 test	 eax, eax
  00097	74 39		 je	 SHORT $LN10@s390_load_
  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a4	d1 e8		 shr	 eax, 1
  000a6	83 e0 01	 and	 eax, 1
  000a9	85 c0		 test	 eax, eax
  000ab	74 49		 je	 SHORT $LN9@s390_load_
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b9	b9 08 00 00 00	 mov	 ecx, 8
  000be	48 6b c9 01	 imul	 rcx, rcx, 1
  000c2	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ce	85 c0		 test	 eax, eax
  000d0	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000d2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e1	ba 07 00 00 00	 mov	 edx, 7
  000e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3544 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  000f6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000fa	83 e0 02	 and	 eax, 2
  000fd	85 c0		 test	 eax, eax
  000ff	75 0b		 jne	 SHORT $LN12@s390_load_
  00101	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00105	83 e0 02	 and	 eax, 2
  00108	85 c0		 test	 eax, eax
  0010a	74 15		 je	 SHORT $LN11@s390_load_
$LN12@s390_load_:
  0010c	ba 06 00 00 00	 mov	 edx, 6
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_load_:

; 3545 : 
; 3546 :     GET_FLOAT128_OP( op, r2, regs );

  00121	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00125	d1 e0		 shl	 eax, 1
  00127	48 98		 cdqe
  00129	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00136	48 8b d0	 mov	 rdx, rax
  00139	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0013e	e8 00 00 00 00	 call	 s390_get_float128

; 3547 :     op.v[FLOAT128_HI] |= 0x8000000000000000ULL;

  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 01	 imul	 rax, rax, 1
  0014c	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00156	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0015b	48 0b c1	 or	 rax, rcx
  0015e	b9 08 00 00 00	 mov	 ecx, 8
  00163	48 6b c9 01	 imul	 rcx, rcx, 1
  00167	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN7@s390_load_:

; 3548 : 
; 3549 :     PUT_FLOAT128_CC( op, r1, regs );

  0016c	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00170	d1 e0		 shl	 eax, 1
  00172	48 98		 cdqe
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00181	48 8b d0	 mov	 rdx, rax
  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00189	e8 00 00 00 00	 call	 s390_put_float128
  0018e	b8 08 00 00 00	 mov	 eax, 8
  00193	48 6b c0 01	 imul	 rax, rax, 1
  00197	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001a1	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001a6	48 23 c1	 and	 rax, rcx
  001a9	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001b3	48 3b c1	 cmp	 rax, rcx
  001b6	75 3e		 jne	 SHORT $LN15@s390_load_
  001b8	b8 08 00 00 00	 mov	 eax, 8
  001bd	48 6b c0 01	 imul	 rax, rax, 1
  001c1	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001cb	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001d0	48 23 c1	 and	 rax, rcx
  001d3	48 85 c0	 test	 rax, rax
  001d6	75 11		 jne	 SHORT $LN14@s390_load_
  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 00	 imul	 rax, rax, 0
  001e1	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  001e7	74 0d		 je	 SHORT $LN15@s390_load_
$LN14@s390_load_:
  001e9	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv182[rsp], 3
  001f1	e9 93 00 00 00	 jmp	 $LN22@s390_load_
$LN15@s390_load_:
  001f6	b8 08 00 00 00	 mov	 eax, 8
  001fb	48 6b c0 01	 imul	 rax, rax, 1
  001ff	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00209	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0020e	48 23 c1	 and	 rax, rcx
  00211	b9 08 00 00 00	 mov	 ecx, 8
  00216	48 6b c9 00	 imul	 rcx, rcx, 0
  0021a	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  0021f	48 85 c0	 test	 rax, rax
  00222	75 0a		 jne	 SHORT $LN16@s390_load_
  00224	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0022c	eb 08		 jmp	 SHORT $LN17@s390_load_
$LN16@s390_load_:
  0022e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN17@s390_load_:
  00236	83 7c 24 2c 00	 cmp	 DWORD PTR tv174[rsp], 0
  0023b	74 0a		 je	 SHORT $LN20@s390_load_
  0023d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
  00245	eb 3a		 jmp	 SHORT $LN21@s390_load_
$LN20@s390_load_:
  00247	b8 08 00 00 00	 mov	 eax, 8
  0024c	48 6b c0 01	 imul	 rax, rax, 1
  00250	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025a	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0025f	48 23 c1	 and	 rax, rcx
  00262	48 85 c0	 test	 rax, rax
  00265	74 0a		 je	 SHORT $LN18@s390_load_
  00267	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  0026f	eb 08		 jmp	 SHORT $LN19@s390_load_
$LN18@s390_load_:
  00271	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv179[rsp], 2
$LN19@s390_load_:
  00279	8b 44 24 30	 mov	 eax, DWORD PTR tv179[rsp]
  0027d	89 44 24 34	 mov	 DWORD PTR tv181[rsp], eax
$LN21@s390_load_:
  00281	8b 44 24 34	 mov	 eax, DWORD PTR tv181[rsp]
  00285	89 44 24 38	 mov	 DWORD PTR tv182[rsp], eax
$LN22@s390_load_:
  00289	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0028e	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv182[rsp]
  00293	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00296	33 c0		 xor	 eax, eax
  00298	85 c0		 test	 eax, eax
  0029a	0f 85 cc fe ff
	ff		 jne	 $LN7@s390_load_

; 3550 : }

  002a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a5	48 33 cc	 xor	 rcx, rsp
  002a8	e8 00 00 00 00	 call	 __security_check_cookie
  002ad	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b1	c3		 ret	 0
s390_load_negative_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op2$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
op1$ = 48
inst$ = 80
regs$ = 88
s390_load_lengthened_bfp_short_to_long_reg PROC

; 3353 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3354 :     int        r1, r2;
; 3355 :     float32_t  op2;
; 3356 :     float64_t  op1;
; 3357 : 
; 3358 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN5@s390_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3359 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3360 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN7@s390_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN6@s390_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3361 : 
; 3362 :     GET_FLOAT32_OP( op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op2$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float32

; 3363 : 
; 3364 :     if (f32_isSignalingNaN( op2 ))

  00109	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  0010d	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00112	0f b6 c0	 movzx	 eax, al
  00115	85 c0		 test	 eax, eax
  00117	0f 84 c8 00 00
	00		 je	 $LN8@s390_load_

; 3365 :     {
; 3366 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  0011d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00122	8b c0		 mov	 eax, eax
  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0012a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00133	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00137	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3367 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0013b	33 c0		 xor	 eax, eax
  0013d	83 f8 01	 cmp	 eax, 1
  00140	74 45		 je	 SHORT $LN9@s390_load_
  00142	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00147	8b c0		 mov	 eax, eax
  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0014f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00158	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0015c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00160	83 e0 10	 and	 eax, 16
  00163	85 c0		 test	 eax, eax
  00165	74 20		 je	 SHORT $LN9@s390_load_
  00167	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00172	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00177	85 c0		 test	 eax, eax
  00179	74 0c		 je	 SHORT $LN9@s390_load_
  0017b	b2 80		 mov	 dl, 128			; 00000080H
  0017d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	e8 00 00 00 00	 call	 ieee_trap
$LN9@s390_load_:

; 3368 : 
; 3369 :         FLOAT32_MAKE_QNAN( op2 );

  00187	8b 44 24 20	 mov	 eax, DWORD PTR op2$[rsp]
  0018b	0f ba e8 16	 bts	 eax, 22
  0018f	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 3370 :         SET_FPC_FLAGS_FROM_SF( regs );

  00193	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00198	8b c0		 mov	 eax, eax
  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b1	c1 e0 13	 shl	 eax, 19
  001b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001bf	c1 e9 08	 shr	 ecx, 8
  001c2	f7 d1		 not	 ecx
  001c4	23 c1		 and	 eax, ecx
  001c6	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001cb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001d6	0b c8		 or	 ecx, eax
  001d8	8b c1		 mov	 eax, ecx
  001da	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN8@s390_load_:

; 3371 :     }
; 3372 : 
; 3373 :     op1 = f32_to_f64( op2 );

  001e5	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  001e9	e8 00 00 00 00	 call	 f32_to_f64
  001ee	48 89 44 24 30	 mov	 QWORD PTR op1$[rsp], rax

; 3374 : 
; 3375 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  001f3	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001f7	d1 e0		 shl	 eax, 1
  001f9	48 98		 cdqe
  001fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00200	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00208	48 8b d0	 mov	 rdx, rax
  0020b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00210	e8 00 00 00 00	 call	 s390_put_float64

; 3376 : }

  00215	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00219	c3		 ret	 0
s390_load_lengthened_bfp_short_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
op2$ = 40
b2$ = 44
x2$ = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s390_load_lengthened_bfp_short_to_long PROC

; 3382 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3383 :     int        r1, x2, b2;
; 3384 :     VADR       effective_addr2;
; 3385 :     float32_t  op2;
; 3386 :     float64_t  op1;
; 3387 : 
; 3388 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s390_load_
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_load_:
  00070	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s390_load_
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_load_:
  000a2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b1	23 c8		 and	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_load_:
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 83 c0 06	 add	 rax, 6
  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cf	33 c0		 xor	 eax, eax
  000d1	83 f8 06	 cmp	 eax, 6
  000d4	74 0c		 je	 SHORT $LN7@s390_load_
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_load_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 d1		 jne	 SHORT $LN4@s390_load_

; 3389 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3390 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3391 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00102	85 c0		 test	 eax, eax
  00104	74 39		 je	 SHORT $LN9@s390_load_
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 49		 je	 SHORT $LN8@s390_load_
  0011a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00126	b9 08 00 00 00	 mov	 ecx, 8
  0012b	48 6b c9 01	 imul	 rcx, rcx, 1
  0012f	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00136	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 24		 jne	 SHORT $LN8@s390_load_
$LN9@s390_load_:
  0013f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014e	ba 07 00 00 00	 mov	 edx, 7
  00153	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3392 : 
; 3393 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00163	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00168	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0016c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00170	e8 00 00 00 00	 call	 s390_vfetch4
  00175	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3394 : 
; 3395 :     if (f32_isSignalingNaN( op2 ))

  00179	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  0017d	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00182	0f b6 c0	 movzx	 eax, al
  00185	85 c0		 test	 eax, eax
  00187	0f 84 c8 00 00
	00		 je	 $LN10@s390_load_

; 3396 :     {
; 3397 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  0018d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00192	8b c0		 mov	 eax, eax
  00194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001a7	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3398 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001ab	33 c0		 xor	 eax, eax
  001ad	83 f8 01	 cmp	 eax, 1
  001b0	74 45		 je	 SHORT $LN11@s390_load_
  001b2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b7	8b c0		 mov	 eax, eax
  001b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001bf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d0	83 e0 10	 and	 eax, 16
  001d3	85 c0		 test	 eax, eax
  001d5	74 20		 je	 SHORT $LN11@s390_load_
  001d7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e2	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001e7	85 c0		 test	 eax, eax
  001e9	74 0c		 je	 SHORT $LN11@s390_load_
  001eb	b2 80		 mov	 dl, 128			; 00000080H
  001ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001f2	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_load_:

; 3399 : 
; 3400 :         FLOAT32_MAKE_QNAN( op2 );

  001f7	8b 44 24 28	 mov	 eax, DWORD PTR op2$[rsp]
  001fb	0f ba e8 16	 bts	 eax, 22
  001ff	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3401 :         SET_FPC_FLAGS_FROM_SF( regs );

  00203	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00208	8b c0		 mov	 eax, eax
  0020a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00210	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00219	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00221	c1 e0 13	 shl	 eax, 19
  00224	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0022f	c1 e9 08	 shr	 ecx, 8
  00232	f7 d1		 not	 ecx
  00234	23 c1		 and	 eax, ecx
  00236	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0023b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00240	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00246	0b c8		 or	 ecx, eax
  00248	8b c1		 mov	 eax, ecx
  0024a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0024f	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN10@s390_load_:

; 3402 :     }
; 3403 : 
; 3404 :     op1 = f32_to_f64( op2 );

  00255	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  00259	e8 00 00 00 00	 call	 f32_to_f64
  0025e	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 3405 : 
; 3406 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00263	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00267	d1 e0		 shl	 eax, 1
  00269	48 98		 cdqe
  0026b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00278	48 8b d0	 mov	 rdx, rax
  0027b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00280	e8 00 00 00 00	 call	 s390_put_float64

; 3407 : }

  00285	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00289	c3		 ret	 0
s390_load_lengthened_bfp_short_to_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op2$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
op1$ = 64
__$ArrayPad$ = 80
inst$ = 128
regs$ = 136
s390_load_lengthened_bfp_short_to_ext_reg PROC

; 3475 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3476 :     int         r1, r2;
; 3477 :     float32_t   op2;
; 3478 :     float128_t  op1;
; 3479 : 
; 3480 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  00051	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN5@s390_load_
  00074	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@s390_load_

; 3481 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3482 :     BFPINST_CHECK( regs );

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a6	85 c0		 test	 eax, eax
  000a8	74 3f		 je	 SHORT $LN7@s390_load_
  000aa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 55		 je	 SHORT $LN6@s390_load_
  000c1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	b9 08 00 00 00	 mov	 ecx, 8
  000d5	48 6b c9 01	 imul	 rcx, rcx, 1
  000d9	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e5	85 c0		 test	 eax, eax
  000e7	75 2d		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  000e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fb	ba 07 00 00 00	 mov	 edx, 7
  00100	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3483 :     BFPREGPAIR_CHECK( r1, regs );

  00116	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011a	83 e0 02	 and	 eax, 2
  0011d	85 c0		 test	 eax, eax
  0011f	74 1b		 je	 SHORT $LN8@s390_load_
  00121	ba 06 00 00 00	 mov	 edx, 6
  00126	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3484 : 
; 3485 :     GET_FLOAT32_OP( op2, r2, regs );

  0013c	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00140	d1 e0		 shl	 eax, 1
  00142	48 98		 cdqe
  00144	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00154	48 8b d0	 mov	 rdx, rax
  00157	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op2$[rsp]
  0015c	e8 00 00 00 00	 call	 s390_get_float32

; 3486 : 
; 3487 :     if (f32_isSignalingNaN( op2 ))

  00161	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  00165	e8 00 00 00 00	 call	 f32_isSignalingNaN
  0016a	0f b6 c0	 movzx	 eax, al
  0016d	85 c0		 test	 eax, eax
  0016f	0f 84 d7 00 00
	00		 je	 $LN9@s390_load_

; 3488 :     {
; 3489 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  00175	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017a	8b c0		 mov	 eax, eax
  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00182	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0018f	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3490 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00193	33 c0		 xor	 eax, eax
  00195	83 f8 01	 cmp	 eax, 1
  00198	74 4b		 je	 SHORT $LN10@s390_load_
  0019a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019f	8b c0		 mov	 eax, eax
  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b8	83 e0 10	 and	 eax, 16
  001bb	85 c0		 test	 eax, eax
  001bd	74 26		 je	 SHORT $LN10@s390_load_
  001bf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cd	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001d2	85 c0		 test	 eax, eax
  001d4	74 0f		 je	 SHORT $LN10@s390_load_
  001d6	b2 80		 mov	 dl, 128			; 00000080H
  001d8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e0	e8 00 00 00 00	 call	 ieee_trap
$LN10@s390_load_:

; 3491 : 
; 3492 :         FLOAT32_MAKE_QNAN( op2 );

  001e5	8b 44 24 20	 mov	 eax, DWORD PTR op2$[rsp]
  001e9	0f ba e8 16	 bts	 eax, 22
  001ed	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 3493 :         SET_FPC_FLAGS_FROM_SF( regs );

  001f1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f6	8b c0		 mov	 eax, eax
  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001fe	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00207	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	c1 e0 13	 shl	 eax, 19
  00212	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021a	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00220	c1 e9 08	 shr	 ecx, 8
  00223	f7 d1		 not	 ecx
  00225	23 c1		 and	 eax, ecx
  00227	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0022c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00234	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0023a	0b c8		 or	 ecx, eax
  0023c	8b c1		 mov	 eax, ecx
  0023e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN9@s390_load_:

; 3494 :     }
; 3495 : 
; 3496 :     op1 = f32_to_f128( op2 );

  0024c	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  00250	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00255	e8 00 00 00 00	 call	 f32_to_f128
  0025a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  0025f	48 8b f9	 mov	 rdi, rcx
  00262	48 8b f0	 mov	 rsi, rax
  00265	b9 10 00 00 00	 mov	 ecx, 16
  0026a	f3 a4		 rep movsb

; 3497 : 
; 3498 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0026c	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00270	d1 e0		 shl	 eax, 1
  00272	48 98		 cdqe
  00274	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00284	48 8b d0	 mov	 rdx, rax
  00287	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  0028c	e8 00 00 00 00	 call	 s390_put_float128

; 3499 : }

  00291	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00296	48 33 cc	 xor	 rcx, rsp
  00299	e8 00 00 00 00	 call	 __security_check_cookie
  0029e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002a2	5f		 pop	 rdi
  002a3	5e		 pop	 rsi
  002a4	c3		 ret	 0
s390_load_lengthened_bfp_short_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
op2$ = 40
b2$ = 44
x2$ = 48
r1$ = 52
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
s390_load_lengthened_bfp_short_to_ext PROC

; 3505 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3506 :     int         r1, x2, b2;
; 3507 :     VADR        effective_addr2;
; 3508 :     float32_t   op2;
; 3509 :     float128_t  op1;
; 3510 : 
; 3511 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 10	 shr	 eax, 16
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 14	 shr	 eax, 20
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00060	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00065	74 20		 je	 SHORT $LN5@s390_load_
  00067	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_load_:
  00087	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 0c	 shr	 eax, 12
  0008e	83 e0 0f	 and	 eax, 15
  00091	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00095	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009a	74 20		 je	 SHORT $LN6@s390_load_
  0009c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b4	03 c8		 add	 ecx, eax
  000b6	8b c1		 mov	 eax, ecx
  000b8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_load_:
  000bc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ca	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ce	23 c8		 and	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_load_:
  000d6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e2	48 83 c0 06	 add	 rax, 6
  000e6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f2	33 c0		 xor	 eax, eax
  000f4	83 f8 06	 cmp	 eax, 6
  000f7	74 0f		 je	 SHORT $LN7@s390_load_
  000f9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00101	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_load_:
  00108	33 c0		 xor	 eax, eax
  0010a	85 c0		 test	 eax, eax
  0010c	75 c8		 jne	 SHORT $LN4@s390_load_

; 3512 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3513 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3514 :     BFPINST_CHECK( regs );

  0010e	b8 08 00 00 00	 mov	 eax, 8
  00113	48 6b c0 01	 imul	 rax, rax, 1
  00117	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00126	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0012b	85 c0		 test	 eax, eax
  0012d	74 3f		 je	 SHORT $LN9@s390_load_
  0012f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0013d	d1 e8		 shr	 eax, 1
  0013f	83 e0 01	 and	 eax, 1
  00142	85 c0		 test	 eax, eax
  00144	74 55		 je	 SHORT $LN8@s390_load_
  00146	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00155	b9 08 00 00 00	 mov	 ecx, 8
  0015a	48 6b c9 01	 imul	 rcx, rcx, 1
  0015e	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00165	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0016a	85 c0		 test	 eax, eax
  0016c	75 2d		 jne	 SHORT $LN8@s390_load_
$LN9@s390_load_:
  0016e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00176	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00180	ba 07 00 00 00	 mov	 edx, 7
  00185	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3515 :     BFPREGPAIR_CHECK( r1, regs );

  0019b	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0019f	83 e0 02	 and	 eax, 2
  001a2	85 c0		 test	 eax, eax
  001a4	74 1b		 je	 SHORT $LN10@s390_load_
  001a6	ba 06 00 00 00	 mov	 edx, 6
  001ab	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s390_load_:

; 3516 : 
; 3517 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  001c1	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001c9	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001cd	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001d1	e8 00 00 00 00	 call	 s390_vfetch4
  001d6	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3518 : 
; 3519 :     if (f32_isSignalingNaN( op2 ))

  001da	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  001de	e8 00 00 00 00	 call	 f32_isSignalingNaN
  001e3	0f b6 c0	 movzx	 eax, al
  001e6	85 c0		 test	 eax, eax
  001e8	0f 84 d7 00 00
	00		 je	 $LN11@s390_load_

; 3520 :     {
; 3521 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  001ee	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f3	8b c0		 mov	 eax, eax
  001f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001fb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00204	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00208	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3522 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0020c	33 c0		 xor	 eax, eax
  0020e	83 f8 01	 cmp	 eax, 1
  00211	74 4b		 je	 SHORT $LN12@s390_load_
  00213	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00218	8b c0		 mov	 eax, eax
  0021a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00220	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00229	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00231	83 e0 10	 and	 eax, 16
  00234	85 c0		 test	 eax, eax
  00236	74 26		 je	 SHORT $LN12@s390_load_
  00238	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00240	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00246	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0024b	85 c0		 test	 eax, eax
  0024d	74 0f		 je	 SHORT $LN12@s390_load_
  0024f	b2 80		 mov	 dl, 128			; 00000080H
  00251	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00259	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_load_:

; 3523 : 
; 3524 :         FLOAT32_MAKE_QNAN( op2 );

  0025e	8b 44 24 28	 mov	 eax, DWORD PTR op2$[rsp]
  00262	0f ba e8 16	 bts	 eax, 22
  00266	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3525 :         SET_FPC_FLAGS_FROM_SF( regs );

  0026a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0026f	8b c0		 mov	 eax, eax
  00271	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00277	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00280	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00284	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00288	c1 e0 13	 shl	 eax, 19
  0028b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00299	c1 e9 08	 shr	 ecx, 8
  0029c	f7 d1		 not	 ecx
  0029e	23 c1		 and	 eax, ecx
  002a0	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002a5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ad	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002b3	0b c8		 or	 ecx, eax
  002b5	8b c1		 mov	 eax, ecx
  002b7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN11@s390_load_:

; 3526 :     }
; 3527 : 
; 3528 :     op1 = f32_to_f128( op2 );

  002c5	8b 54 24 28	 mov	 edx, DWORD PTR op2$[rsp]
  002c9	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  002ce	e8 00 00 00 00	 call	 f32_to_f128
  002d3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  002d8	48 8b f9	 mov	 rdi, rcx
  002db	48 8b f0	 mov	 rsi, rax
  002de	b9 10 00 00 00	 mov	 ecx, 16
  002e3	f3 a4		 rep movsb

; 3529 : 
; 3530 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  002e5	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  002e9	d1 e0		 shl	 eax, 1
  002eb	48 98		 cdqe
  002ed	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f5	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002fd	48 8b d0	 mov	 rdx, rax
  00300	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00305	e8 00 00 00 00	 call	 s390_put_float128

; 3531 : }

  0030a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030f	48 33 cc	 xor	 rcx, rsp
  00312	e8 00 00 00 00	 call	 __security_check_cookie
  00317	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0031b	5f		 pop	 rdi
  0031c	5e		 pop	 rsi
  0031d	c3		 ret	 0
s390_load_lengthened_bfp_short_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
op2$ = 40
r2$ = 48
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
s390_load_lengthened_bfp_long_to_ext_reg PROC

; 3413 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3414 :     int         r1, r2;
; 3415 :     float64_t   op2;
; 3416 :     float128_t  op1;
; 3417 : 
; 3418 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  00051	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN5@s390_load_
  00074	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@s390_load_

; 3419 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3420 :     BFPINST_CHECK( regs );

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a6	85 c0		 test	 eax, eax
  000a8	74 3f		 je	 SHORT $LN7@s390_load_
  000aa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 55		 je	 SHORT $LN6@s390_load_
  000c1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	b9 08 00 00 00	 mov	 ecx, 8
  000d5	48 6b c9 01	 imul	 rcx, rcx, 1
  000d9	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e5	85 c0		 test	 eax, eax
  000e7	75 2d		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  000e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fb	ba 07 00 00 00	 mov	 edx, 7
  00100	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3421 :     BFPREGPAIR_CHECK( r1, regs );

  00116	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0011a	83 e0 02	 and	 eax, 2
  0011d	85 c0		 test	 eax, eax
  0011f	74 1b		 je	 SHORT $LN8@s390_load_
  00121	ba 06 00 00 00	 mov	 edx, 6
  00126	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3422 : 
; 3423 :     GET_FLOAT64_OP( op2, r2, regs );

  0013c	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00140	d1 e0		 shl	 eax, 1
  00142	48 98		 cdqe
  00144	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00154	48 8b d0	 mov	 rdx, rax
  00157	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op2$[rsp]
  0015c	e8 00 00 00 00	 call	 s390_get_float64

; 3424 : 
; 3425 :     if (f64_isSignalingNaN( op2 ))

  00161	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op2$[rsp]
  00166	e8 00 00 00 00	 call	 f64_isSignalingNaN
  0016b	0f b6 c0	 movzx	 eax, al
  0016e	85 c0		 test	 eax, eax
  00170	0f 84 e5 00 00
	00		 je	 $LN9@s390_load_

; 3426 :     {
; 3427 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  00176	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017b	8b c0		 mov	 eax, eax
  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00183	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00190	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3428 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00194	33 c0		 xor	 eax, eax
  00196	83 f8 01	 cmp	 eax, 1
  00199	74 4b		 je	 SHORT $LN10@s390_load_
  0019b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a0	8b c0		 mov	 eax, eax
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b9	83 e0 10	 and	 eax, 16
  001bc	85 c0		 test	 eax, eax
  001be	74 26		 je	 SHORT $LN10@s390_load_
  001c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ce	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001d3	85 c0		 test	 eax, eax
  001d5	74 0f		 je	 SHORT $LN10@s390_load_
  001d7	b2 80		 mov	 dl, 128			; 00000080H
  001d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	e8 00 00 00 00	 call	 ieee_trap
$LN10@s390_load_:

; 3429 : 
; 3430 :         FLOAT64_MAKE_QNAN( op2 );

  001e6	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  001f0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op2$[rsp]
  001f5	48 0b c8	 or	 rcx, rax
  001f8	48 8b c1	 mov	 rax, rcx
  001fb	48 89 44 24 28	 mov	 QWORD PTR op2$[rsp], rax

; 3431 :         SET_FPC_FLAGS_FROM_SF( regs );

  00200	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00205	8b c0		 mov	 eax, eax
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00216	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021e	c1 e0 13	 shl	 eax, 19
  00221	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0022f	c1 e9 08	 shr	 ecx, 8
  00232	f7 d1		 not	 ecx
  00234	23 c1		 and	 eax, ecx
  00236	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0023b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00243	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00249	0b c8		 or	 ecx, eax
  0024b	8b c1		 mov	 eax, ecx
  0024d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00255	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN9@s390_load_:

; 3432 :     }
; 3433 : 
; 3434 :     op1 = f64_to_f128( op2 );

  0025b	48 8b 54 24 28	 mov	 rdx, QWORD PTR op2$[rsp]
  00260	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  00265	e8 00 00 00 00	 call	 f64_to_f128
  0026a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0026f	48 8b f9	 mov	 rdi, rcx
  00272	48 8b f0	 mov	 rsi, rax
  00275	b9 10 00 00 00	 mov	 ecx, 16
  0027a	f3 a4		 rep movsb

; 3435 : 
; 3436 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0027c	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00280	d1 e0		 shl	 eax, 1
  00282	48 98		 cdqe
  00284	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00294	48 8b d0	 mov	 rdx, rax
  00297	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0029c	e8 00 00 00 00	 call	 s390_put_float128

; 3437 : }

  002a1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a6	48 33 cc	 xor	 rcx, rsp
  002a9	e8 00 00 00 00	 call	 __security_check_cookie
  002ae	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b2	5f		 pop	 rdi
  002b3	5e		 pop	 rsi
  002b4	c3		 ret	 0
s390_load_lengthened_bfp_long_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
r1$ = 48
op2$ = 56
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
s390_load_lengthened_bfp_long_to_ext PROC

; 3443 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3444 :     int         r1, x2, b2;
; 3445 :     VADR        effective_addr2;
; 3446 :     float64_t   op2;
; 3447 :     float128_t  op1;
; 3448 : 
; 3449 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 10	 shr	 eax, 16
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 14	 shr	 eax, 20
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00060	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00065	74 20		 je	 SHORT $LN5@s390_load_
  00067	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_load_:
  00087	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 0c	 shr	 eax, 12
  0008e	83 e0 0f	 and	 eax, 15
  00091	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00095	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009a	74 20		 je	 SHORT $LN6@s390_load_
  0009c	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b4	03 c8		 add	 ecx, eax
  000b6	8b c1		 mov	 eax, ecx
  000b8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_load_:
  000bc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ca	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ce	23 c8		 and	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_load_:
  000d6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e2	48 83 c0 06	 add	 rax, 6
  000e6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f2	33 c0		 xor	 eax, eax
  000f4	83 f8 06	 cmp	 eax, 6
  000f7	74 0f		 je	 SHORT $LN7@s390_load_
  000f9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00101	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_load_:
  00108	33 c0		 xor	 eax, eax
  0010a	85 c0		 test	 eax, eax
  0010c	75 c8		 jne	 SHORT $LN4@s390_load_

; 3450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3451 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3452 :     BFPINST_CHECK( regs );

  0010e	b8 08 00 00 00	 mov	 eax, 8
  00113	48 6b c0 01	 imul	 rax, rax, 1
  00117	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00126	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0012b	85 c0		 test	 eax, eax
  0012d	74 3f		 je	 SHORT $LN9@s390_load_
  0012f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0013d	d1 e8		 shr	 eax, 1
  0013f	83 e0 01	 and	 eax, 1
  00142	85 c0		 test	 eax, eax
  00144	74 55		 je	 SHORT $LN8@s390_load_
  00146	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00155	b9 08 00 00 00	 mov	 ecx, 8
  0015a	48 6b c9 01	 imul	 rcx, rcx, 1
  0015e	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00165	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0016a	85 c0		 test	 eax, eax
  0016c	75 2d		 jne	 SHORT $LN8@s390_load_
$LN9@s390_load_:
  0016e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00176	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00180	ba 07 00 00 00	 mov	 edx, 7
  00185	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3453 :     BFPREGPAIR_CHECK( r1, regs );

  0019b	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0019f	83 e0 02	 and	 eax, 2
  001a2	85 c0		 test	 eax, eax
  001a4	74 1b		 je	 SHORT $LN10@s390_load_
  001a6	ba 06 00 00 00	 mov	 edx, 6
  001ab	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s390_load_:

; 3454 : 
; 3455 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001c1	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001c9	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001cd	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001d1	e8 00 00 00 00	 call	 s390_vfetch8
  001d6	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 3456 : 
; 3457 :     if (f64_isSignalingNaN( op2 ))

  001db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  001e0	e8 00 00 00 00	 call	 f64_isSignalingNaN
  001e5	0f b6 c0	 movzx	 eax, al
  001e8	85 c0		 test	 eax, eax
  001ea	0f 84 e5 00 00
	00		 je	 $LN11@s390_load_

; 3458 :     {
; 3459 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  001f0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f5	8b c0		 mov	 eax, eax
  001f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001fd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00206	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0020a	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3460 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0020e	33 c0		 xor	 eax, eax
  00210	83 f8 01	 cmp	 eax, 1
  00213	74 4b		 je	 SHORT $LN12@s390_load_
  00215	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021a	8b c0		 mov	 eax, eax
  0021c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00222	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00233	83 e0 10	 and	 eax, 16
  00236	85 c0		 test	 eax, eax
  00238	74 26		 je	 SHORT $LN12@s390_load_
  0023a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00242	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00248	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0024d	85 c0		 test	 eax, eax
  0024f	74 0f		 je	 SHORT $LN12@s390_load_
  00251	b2 80		 mov	 dl, 128			; 00000080H
  00253	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_load_:

; 3461 : 
; 3462 :         FLOAT64_MAKE_QNAN( op2 );

  00260	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  0026a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  0026f	48 0b c8	 or	 rcx, rax
  00272	48 8b c1	 mov	 rax, rcx
  00275	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 3463 :         SET_FPC_FLAGS_FROM_SF( regs );

  0027a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0027f	8b c0		 mov	 eax, eax
  00281	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00287	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00290	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00294	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00298	c1 e0 13	 shl	 eax, 19
  0029b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a3	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002a9	c1 e9 08	 shr	 ecx, 8
  002ac	f7 d1		 not	 ecx
  002ae	23 c1		 and	 eax, ecx
  002b0	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002b5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002c3	0b c8		 or	 ecx, eax
  002c5	8b c1		 mov	 eax, ecx
  002c7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cf	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN11@s390_load_:

; 3464 :     }
; 3465 : 
; 3466 :     op1 = f64_to_f128( op2 );

  002d5	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  002da	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  002df	e8 00 00 00 00	 call	 f64_to_f128
  002e4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  002e9	48 8b f9	 mov	 rdi, rcx
  002ec	48 8b f0	 mov	 rsi, rax
  002ef	b9 10 00 00 00	 mov	 ecx, 16
  002f4	f3 a4		 rep movsb

; 3467 : 
; 3468 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  002f6	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  002fa	d1 e0		 shl	 eax, 1
  002fc	48 98		 cdqe
  002fe	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00306	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0030e	48 8b d0	 mov	 rdx, rax
  00311	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  00316	e8 00 00 00 00	 call	 s390_put_float128

; 3469 : }

  0031b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00320	48 33 cc	 xor	 rcx, rsp
  00323	e8 00 00 00 00	 call	 __security_check_cookie
  00328	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0032c	5f		 pop	 rdi
  0032d	5e		 pop	 rsi
  0032e	c3		 ret	 0
s390_load_lengthened_bfp_long_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
op$ = 40
ieee_trap_conds$ = 44
tv169 = 48
tv175 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s390_load_fp_int_bfp_short_reg PROC

; 3224 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3225 :     int        r1, r2;
; 3226 :     BYTE       m3, m4;
; 3227 :     float32_t  op;
; 3228 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3229 : 
; 3230 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_load_:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s390_load_
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s390_load_

; 3231 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3232 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s390_load_
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s390_load_
  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3233 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 3234 : 
; 3235 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3236 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3237 : #endif
; 3238 :         m4 = 0;

  00119	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0

; 3239 : 
; 3240 :     GET_FLOAT32_OP( op, r2, regs );

  0011e	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_get_float32

; 3241 : 
; 3242 :     softfloat_exceptionFlags = 0;

  00140	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00145	8b c0		 mov	 eax, eax
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0014d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00156	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0015a	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3243 :     SET_SF_RM_FROM_MASK( m3 );

  0015e	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00163	85 c0		 test	 eax, eax
  00165	74 16		 je	 SHORT $LN12@s390_load_
  00167	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00173	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00177	89 44 24 30	 mov	 DWORD PTR tv169[rsp], eax
  0017b	eb 1f		 jmp	 SHORT $LN13@s390_load_
$LN12@s390_load_:
  0017d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00188	83 e0 07	 and	 eax, 7
  0018b	8b c0		 mov	 eax, eax
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00194	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00198	89 44 24 30	 mov	 DWORD PTR tv169[rsp], eax
$LN13@s390_load_:
  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001a1	8b c0		 mov	 eax, eax
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b6	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv169[rsp]
  001bb	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3244 : 
; 3245 :     op = f32_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  001be	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  001c3	83 e0 04	 and	 eax, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 0a		 jne	 SHORT $LN14@s390_load_
  001ca	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  001d2	eb 08		 jmp	 SHORT $LN15@s390_load_
$LN14@s390_load_:
  001d4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN15@s390_load_:
  001dc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001e1	8b c0		 mov	 eax, eax
  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f6	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv175[rsp]
  001fc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00200	8b 4c 24 28	 mov	 ecx, DWORD PTR op$[rsp]
  00204	e8 00 00 00 00	 call	 f32_roundToInt
  00209	89 44 24 28	 mov	 DWORD PTR op$[rsp], eax

; 3246 : 
; 3247 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0020d	33 c0		 xor	 eax, eax
  0020f	83 f8 01	 cmp	 eax, 1
  00212	74 45		 je	 SHORT $LN8@s390_load_
  00214	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00219	8b c0		 mov	 eax, eax
  0021b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00221	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00232	83 e0 10	 and	 eax, 16
  00235	85 c0		 test	 eax, eax
  00237	74 20		 je	 SHORT $LN8@s390_load_
  00239	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0023e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00244	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00249	85 c0		 test	 eax, eax
  0024b	74 0c		 je	 SHORT $LN8@s390_load_
  0024d	b2 80		 mov	 dl, 128			; 00000080H
  0024f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00254	e8 00 00 00 00	 call	 ieee_trap
$LN8@s390_load_:

; 3248 : 
; 3249 :     PUT_FLOAT32_NOCC( op, r1, regs );

  00259	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0025d	d1 e0		 shl	 eax, 1
  0025f	48 98		 cdqe
  00261	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00266	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0026e	48 8b d0	 mov	 rdx, rax
  00271	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op$[rsp]
  00276	e8 00 00 00 00	 call	 s390_put_float32

; 3250 : 
; 3251 :     if (softfloat_exceptionFlags)

  0027b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00280	8b c0		 mov	 eax, eax
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00288	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00291	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00295	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00299	85 c0		 test	 eax, eax
  0029b	74 29		 je	 SHORT $LN9@s390_load_

; 3252 :     {
; 3253 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0029d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002a7	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3254 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002ab	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002af	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002b4	85 c0		 test	 eax, eax
  002b6	74 0e		 je	 SHORT $LN10@s390_load_
  002b8	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002c1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN10@s390_load_:
$LN9@s390_load_:

; 3255 :     }
; 3256 : }

  002c6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002ca	c3		 ret	 0
s390_load_fp_int_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv169 = 44
tv175 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s390_load_fp_int_bfp_long_reg PROC

; 3262 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3263 :     int        r1, r2;
; 3264 :     BYTE m3,   m4;
; 3265 :     float64_t  op;
; 3266 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3267 : 
; 3268 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_load_:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s390_load_
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s390_load_

; 3269 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3270 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s390_load_
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s390_load_
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3271 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 3272 : 
; 3273 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3274 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3275 : #endif
; 3276 :         m4 = 0;

  00119	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0

; 3277 : 
; 3278 :     GET_FLOAT64_OP( op, r2, regs );

  0011e	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_get_float64

; 3279 : 
; 3280 :     softfloat_exceptionFlags = 0;

  00140	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00145	8b c0		 mov	 eax, eax
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0014d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00156	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0015a	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3281 :     SET_SF_RM_FROM_MASK( m3 );

  0015e	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00163	85 c0		 test	 eax, eax
  00165	74 16		 je	 SHORT $LN12@s390_load_
  00167	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00173	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00177	89 44 24 2c	 mov	 DWORD PTR tv169[rsp], eax
  0017b	eb 1f		 jmp	 SHORT $LN13@s390_load_
$LN12@s390_load_:
  0017d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00188	83 e0 07	 and	 eax, 7
  0018b	8b c0		 mov	 eax, eax
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00194	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00198	89 44 24 2c	 mov	 DWORD PTR tv169[rsp], eax
$LN13@s390_load_:
  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001a1	8b c0		 mov	 eax, eax
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b6	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv169[rsp]
  001bb	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3282 : 
; 3283 :     op = f64_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  001be	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  001c3	83 e0 04	 and	 eax, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 0a		 jne	 SHORT $LN14@s390_load_
  001ca	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  001d2	eb 08		 jmp	 SHORT $LN15@s390_load_
$LN14@s390_load_:
  001d4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN15@s390_load_:
  001dc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001e1	8b c0		 mov	 eax, eax
  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f6	44 0f b6 44 24
	30		 movzx	 r8d, BYTE PTR tv175[rsp]
  001fc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00205	e8 00 00 00 00	 call	 f64_roundToInt
  0020a	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax

; 3284 : 
; 3285 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0020f	33 c0		 xor	 eax, eax
  00211	83 f8 01	 cmp	 eax, 1
  00214	74 45		 je	 SHORT $LN8@s390_load_
  00216	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021b	8b c0		 mov	 eax, eax
  0021d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00223	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00230	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00234	83 e0 10	 and	 eax, 16
  00237	85 c0		 test	 eax, eax
  00239	74 20		 je	 SHORT $LN8@s390_load_
  0023b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00240	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00246	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0024b	85 c0		 test	 eax, eax
  0024d	74 0c		 je	 SHORT $LN8@s390_load_
  0024f	b2 80		 mov	 dl, 128			; 00000080H
  00251	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	e8 00 00 00 00	 call	 ieee_trap
$LN8@s390_load_:

; 3286 : 
; 3287 :     PUT_FLOAT64_NOCC( op, r1, regs );

  0025b	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0025f	d1 e0		 shl	 eax, 1
  00261	48 98		 cdqe
  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00270	48 8b d0	 mov	 rdx, rax
  00273	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00278	e8 00 00 00 00	 call	 s390_put_float64

; 3288 : 
; 3289 :     if (softfloat_exceptionFlags)

  0027d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00282	8b c0		 mov	 eax, eax
  00284	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0028a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00293	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00297	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029b	85 c0		 test	 eax, eax
  0029d	74 29		 je	 SHORT $LN9@s390_load_

; 3290 :     {
; 3291 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0029f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002a4	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002a9	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3292 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002ad	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002b6	85 c0		 test	 eax, eax
  002b8	74 0e		 je	 SHORT $LN10@s390_load_
  002ba	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN10@s390_load_:
$LN9@s390_load_:

; 3293 :     }
; 3294 : }

  002c8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002cc	c3		 ret	 0
s390_load_fp_int_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
r2$ = 44
tv176 = 48
tv182 = 52
r1$ = 56
tv235 = 64
$T2 = 80
$T3 = 96
op$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
s390_load_fp_int_bfp_ext_reg PROC

; 3300 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3301 :     int         r1, r2;
; 3302 :     BYTE        m3, m4;
; 3303 :     float128_t  op;
; 3304 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3305 : 
; 3306 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_load_:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN5@s390_load_
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_load_:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s390_load_

; 3307 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3308 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN7@s390_load_
  000d3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN6@s390_load_
  000ea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN6@s390_load_
$LN7@s390_load_:
  00112	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_load_:

; 3309 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  0013f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00143	83 e0 02	 and	 eax, 2
  00146	85 c0		 test	 eax, eax
  00148	75 0b		 jne	 SHORT $LN9@s390_load_
  0014a	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0014e	83 e0 02	 and	 eax, 2
  00151	85 c0		 test	 eax, eax
  00153	74 1b		 je	 SHORT $LN8@s390_load_
$LN9@s390_load_:
  00155	ba 06 00 00 00	 mov	 edx, 6
  0015a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_load_:

; 3310 :     BFPRM_CHECK( m3, regs );

  00170	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00175	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 3311 : 
; 3312 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3313 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 3314 : #endif
; 3315 :         m4 = 0;

  00182	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0

; 3316 : 
; 3317 :     GET_FLOAT128_OP( op, r2, regs );

  00187	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0018b	d1 e0		 shl	 eax, 1
  0018d	48 98		 cdqe
  0018f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0019f	48 8b d0	 mov	 rdx, rax
  001a2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  001a7	e8 00 00 00 00	 call	 s390_get_float128

; 3318 : 
; 3319 :     softfloat_exceptionFlags = 0;

  001ac	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b1	8b c0		 mov	 eax, eax
  001b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3320 :     SET_SF_RM_FROM_MASK( m3 );

  001ca	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001cf	85 c0		 test	 eax, eax
  001d1	74 16		 je	 SHORT $LN14@s390_load_
  001d3	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e3	89 44 24 30	 mov	 DWORD PTR tv176[rsp], eax
  001e7	eb 22		 jmp	 SHORT $LN15@s390_load_
$LN14@s390_load_:
  001e9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f7	83 e0 07	 and	 eax, 7
  001fa	8b c0		 mov	 eax, eax
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00203	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00207	89 44 24 30	 mov	 DWORD PTR tv176[rsp], eax
$LN15@s390_load_:
  0020b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00210	8b c0		 mov	 eax, eax
  00212	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00218	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00221	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00225	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv176[rsp]
  0022a	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3321 : 
; 3322 :     op = f128_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  0022d	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00232	83 e0 04	 and	 eax, 4
  00235	85 c0		 test	 eax, eax
  00237	75 0a		 jne	 SHORT $LN16@s390_load_
  00239	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv182[rsp], 1
  00241	eb 08		 jmp	 SHORT $LN17@s390_load_
$LN16@s390_load_:
  00243	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
$LN17@s390_load_:
  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	48 89 4c 24 40	 mov	 QWORD PTR tv235[rsp], rcx
  0026a	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  0026f	4c 8d 44 24 70	 lea	 r8, QWORD PTR op$[rsp]
  00274	48 8b fa	 mov	 rdi, rdx
  00277	49 8b f0	 mov	 rsi, r8
  0027a	b9 10 00 00 00	 mov	 ecx, 16
  0027f	f3 a4		 rep movsb
  00281	44 0f b6 4c 24
	34		 movzx	 r9d, BYTE PTR tv182[rsp]
  00287	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv235[rsp]
  0028c	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00291	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00296	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  0029b	e8 00 00 00 00	 call	 f128_roundToInt
  002a0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  002a5	48 8b f9	 mov	 rdi, rcx
  002a8	48 8b f0	 mov	 rsi, rax
  002ab	b9 10 00 00 00	 mov	 ecx, 16
  002b0	f3 a4		 rep movsb

; 3323 : 
; 3324 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002b2	33 c0		 xor	 eax, eax
  002b4	83 f8 01	 cmp	 eax, 1
  002b7	74 4b		 je	 SHORT $LN10@s390_load_
  002b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002be	8b c0		 mov	 eax, eax
  002c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002cf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d7	83 e0 10	 and	 eax, 16
  002da	85 c0		 test	 eax, eax
  002dc	74 26		 je	 SHORT $LN10@s390_load_
  002de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ec	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002f1	85 c0		 test	 eax, eax
  002f3	74 0f		 je	 SHORT $LN10@s390_load_
  002f5	b2 80		 mov	 dl, 128			; 00000080H
  002f7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ff	e8 00 00 00 00	 call	 ieee_trap
$LN10@s390_load_:

; 3325 : 
; 3326 :     PUT_FLOAT128_NOCC( op, r1, regs );

  00304	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00308	d1 e0		 shl	 eax, 1
  0030a	48 98		 cdqe
  0030c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00314	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0031c	48 8b d0	 mov	 rdx, rax
  0031f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  00324	e8 00 00 00 00	 call	 s390_put_float128

; 3327 : 
; 3328 :     if (softfloat_exceptionFlags)

  00329	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0032e	8b c0		 mov	 eax, eax
  00330	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00336	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0033f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00343	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00347	85 c0		 test	 eax, eax
  00349	74 2f		 je	 SHORT $LN11@s390_load_

; 3329 :     {
; 3330 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0034b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00353	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00358	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3331 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0035c	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00360	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00365	85 c0		 test	 eax, eax
  00367	74 11		 je	 SHORT $LN12@s390_load_
  00369	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0036d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00375	e8 00 00 00 00	 call	 ieee_cond_trap
$LN12@s390_load_:
$LN11@s390_load_:

; 3332 :     }
; 3333 : }

  0037a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00382	48 33 cc	 xor	 rcx, rsp
  00385	e8 00 00 00 00	 call	 __security_check_cookie
  0038a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00391	5f		 pop	 rdi
  00392	5e		 pop	 rsi
  00393	c3		 ret	 0
s390_load_fp_int_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv151 = 40
tv154 = 44
tv156 = 48
tv157 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s390_load_complement_bfp_short_reg PROC

; 3629 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3630 :     int        r1, r2;
; 3631 :     float32_t  op;
; 3632 : 
; 3633 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3634 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3635 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3636 : 
; 3637 :     GET_FLOAT32_OP( op, r2, regs );

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float32

; 3638 :     op.v ^= 0x80000000;

  00109	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0010d	0f ba f8 1f	 btc	 eax, 31
  00111	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN7@s390_load_:

; 3639 : 
; 3640 :     PUT_FLOAT32_CC( op, r1, regs );

  00115	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00119	d1 e0		 shl	 eax, 1
  0011b	48 98		 cdqe
  0011d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00132	e8 00 00 00 00	 call	 s390_put_float32
  00137	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0013b	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00140	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00145	75 17		 jne	 SHORT $LN12@s390_load_
  00147	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0014b	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00150	85 c0		 test	 eax, eax
  00152	74 0a		 je	 SHORT $LN12@s390_load_
  00154	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0015c	eb 5e		 jmp	 SHORT $LN19@s390_load_
$LN12@s390_load_:
  0015e	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00162	0f ba f0 1f	 btr	 eax, 31
  00166	85 c0		 test	 eax, eax
  00168	75 0a		 jne	 SHORT $LN13@s390_load_
  0016a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00172	eb 08		 jmp	 SHORT $LN14@s390_load_
$LN13@s390_load_:
  00174	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s390_load_:
  0017c	83 7c 24 28 00	 cmp	 DWORD PTR tv151[rsp], 0
  00181	74 0a		 je	 SHORT $LN17@s390_load_
  00183	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  0018b	eb 27		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  0018d	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00191	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00196	85 c0		 test	 eax, eax
  00198	74 0a		 je	 SHORT $LN15@s390_load_
  0019a	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN16@s390_load_
$LN15@s390_load_:
  001a4	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s390_load_:
  001ac	8b 44 24 2c	 mov	 eax, DWORD PTR tv154[rsp]
  001b0	89 44 24 30	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s390_load_:
  001b4	8b 44 24 30	 mov	 eax, DWORD PTR tv156[rsp]
  001b8	89 44 24 34	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s390_load_:
  001bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv157[rsp]
  001c6	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  001c9	33 c0		 xor	 eax, eax
  001cb	85 c0		 test	 eax, eax
  001cd	0f 85 42 ff ff
	ff		 jne	 $LN7@s390_load_

; 3641 : }

  001d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d7	c3		 ret	 0
s390_load_complement_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv151 = 36
tv154 = 40
tv156 = 44
tv157 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s390_load_complement_bfp_long_reg PROC

; 3611 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3612 :     int        r1, r2;
; 3613 :     float64_t  op;
; 3614 : 
; 3615 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3616 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3617 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_load_
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_load_
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3618 : 
; 3619 :     GET_FLOAT64_OP( op, r2, regs );

  000e7	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float64

; 3620 :     op.v ^= 0x8000000000000000ULL;

  00109	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00118	48 33 c8	 xor	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN7@s390_load_:

; 3621 : 
; 3622 :     PUT_FLOAT64_CC( op, r1, regs );

  00123	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00127	d1 e0		 shl	 eax, 1
  00129	48 98		 cdqe
  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00138	48 8b d0	 mov	 rdx, rax
  0013b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00140	e8 00 00 00 00	 call	 s390_put_float64
  00145	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0014f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00154	48 23 c8	 and	 rcx, rax
  00157	48 8b c1	 mov	 rax, rcx
  0015a	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00164	48 3b c1	 cmp	 rax, rcx
  00167	75 24		 jne	 SHORT $LN12@s390_load_
  00169	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00178	48 23 c8	 and	 rcx, rax
  0017b	48 8b c1	 mov	 rax, rcx
  0017e	48 85 c0	 test	 rax, rax
  00181	74 0a		 je	 SHORT $LN12@s390_load_
  00183	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0018b	eb 79		 jmp	 SHORT $LN19@s390_load_
$LN12@s390_load_:
  0018d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00197	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019c	48 23 c8	 and	 rcx, rax
  0019f	48 8b c1	 mov	 rax, rcx
  001a2	48 85 c0	 test	 rax, rax
  001a5	75 0a		 jne	 SHORT $LN13@s390_load_
  001a7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN14@s390_load_
$LN13@s390_load_:
  001b1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s390_load_:
  001b9	83 7c 24 24 00	 cmp	 DWORD PTR tv151[rsp], 0
  001be	74 0a		 je	 SHORT $LN17@s390_load_
  001c0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  001c8	eb 34		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  001ca	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d9	48 23 c8	 and	 rcx, rax
  001dc	48 8b c1	 mov	 rax, rcx
  001df	48 85 c0	 test	 rax, rax
  001e2	74 0a		 je	 SHORT $LN15@s390_load_
  001e4	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001ec	eb 08		 jmp	 SHORT $LN16@s390_load_
$LN15@s390_load_:
  001ee	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s390_load_:
  001f6	8b 44 24 28	 mov	 eax, DWORD PTR tv154[rsp]
  001fa	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s390_load_:
  001fe	8b 44 24 2c	 mov	 eax, DWORD PTR tv156[rsp]
  00202	89 44 24 30	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s390_load_:
  00206	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv157[rsp]
  00210	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 06 ff ff
	ff		 jne	 $LN7@s390_load_

; 3623 : }

  0021d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00221	c3		 ret	 0
s390_load_complement_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv174 = 44
tv179 = 48
tv181 = 52
tv182 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
s390_load_complement_bfp_ext_reg PROC

; 3592 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3593 :     int         r1, r2;
; 3594 :     float128_t  op;
; 3595 : 
; 3596 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN8@s390_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@s390_load_

; 3597 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3598 :     BFPINST_CHECK( regs );

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00090	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00095	85 c0		 test	 eax, eax
  00097	74 39		 je	 SHORT $LN10@s390_load_
  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a4	d1 e8		 shr	 eax, 1
  000a6	83 e0 01	 and	 eax, 1
  000a9	85 c0		 test	 eax, eax
  000ab	74 49		 je	 SHORT $LN9@s390_load_
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b9	b9 08 00 00 00	 mov	 ecx, 8
  000be	48 6b c9 01	 imul	 rcx, rcx, 1
  000c2	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ce	85 c0		 test	 eax, eax
  000d0	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000d2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e1	ba 07 00 00 00	 mov	 edx, 7
  000e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3599 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  000f6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000fa	83 e0 02	 and	 eax, 2
  000fd	85 c0		 test	 eax, eax
  000ff	75 0b		 jne	 SHORT $LN12@s390_load_
  00101	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00105	83 e0 02	 and	 eax, 2
  00108	85 c0		 test	 eax, eax
  0010a	74 15		 je	 SHORT $LN11@s390_load_
$LN12@s390_load_:
  0010c	ba 06 00 00 00	 mov	 edx, 6
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_load_:

; 3600 : 
; 3601 :     GET_FLOAT128_OP( op, r2, regs );

  00121	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00125	d1 e0		 shl	 eax, 1
  00127	48 98		 cdqe
  00129	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00136	48 8b d0	 mov	 rdx, rax
  00139	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0013e	e8 00 00 00 00	 call	 s390_get_float128

; 3602 :     op.v[FLOAT128_HI] ^= 0x8000000000000000ULL;

  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 01	 imul	 rax, rax, 1
  0014c	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00156	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0015b	48 33 c1	 xor	 rax, rcx
  0015e	b9 08 00 00 00	 mov	 ecx, 8
  00163	48 6b c9 01	 imul	 rcx, rcx, 1
  00167	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN7@s390_load_:

; 3603 : 
; 3604 :     PUT_FLOAT128_CC( op, r1, regs );

  0016c	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00170	d1 e0		 shl	 eax, 1
  00172	48 98		 cdqe
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00181	48 8b d0	 mov	 rdx, rax
  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00189	e8 00 00 00 00	 call	 s390_put_float128
  0018e	b8 08 00 00 00	 mov	 eax, 8
  00193	48 6b c0 01	 imul	 rax, rax, 1
  00197	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001a1	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001a6	48 23 c1	 and	 rax, rcx
  001a9	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001b3	48 3b c1	 cmp	 rax, rcx
  001b6	75 3e		 jne	 SHORT $LN15@s390_load_
  001b8	b8 08 00 00 00	 mov	 eax, 8
  001bd	48 6b c0 01	 imul	 rax, rax, 1
  001c1	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001cb	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001d0	48 23 c1	 and	 rax, rcx
  001d3	48 85 c0	 test	 rax, rax
  001d6	75 11		 jne	 SHORT $LN14@s390_load_
  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 00	 imul	 rax, rax, 0
  001e1	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  001e7	74 0d		 je	 SHORT $LN15@s390_load_
$LN14@s390_load_:
  001e9	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv182[rsp], 3
  001f1	e9 93 00 00 00	 jmp	 $LN22@s390_load_
$LN15@s390_load_:
  001f6	b8 08 00 00 00	 mov	 eax, 8
  001fb	48 6b c0 01	 imul	 rax, rax, 1
  001ff	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00209	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0020e	48 23 c1	 and	 rax, rcx
  00211	b9 08 00 00 00	 mov	 ecx, 8
  00216	48 6b c9 00	 imul	 rcx, rcx, 0
  0021a	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  0021f	48 85 c0	 test	 rax, rax
  00222	75 0a		 jne	 SHORT $LN16@s390_load_
  00224	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0022c	eb 08		 jmp	 SHORT $LN17@s390_load_
$LN16@s390_load_:
  0022e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN17@s390_load_:
  00236	83 7c 24 2c 00	 cmp	 DWORD PTR tv174[rsp], 0
  0023b	74 0a		 je	 SHORT $LN20@s390_load_
  0023d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
  00245	eb 3a		 jmp	 SHORT $LN21@s390_load_
$LN20@s390_load_:
  00247	b8 08 00 00 00	 mov	 eax, 8
  0024c	48 6b c0 01	 imul	 rax, rax, 1
  00250	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025a	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0025f	48 23 c1	 and	 rax, rcx
  00262	48 85 c0	 test	 rax, rax
  00265	74 0a		 je	 SHORT $LN18@s390_load_
  00267	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  0026f	eb 08		 jmp	 SHORT $LN19@s390_load_
$LN18@s390_load_:
  00271	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv179[rsp], 2
$LN19@s390_load_:
  00279	8b 44 24 30	 mov	 eax, DWORD PTR tv179[rsp]
  0027d	89 44 24 34	 mov	 DWORD PTR tv181[rsp], eax
$LN21@s390_load_:
  00281	8b 44 24 34	 mov	 eax, DWORD PTR tv181[rsp]
  00285	89 44 24 38	 mov	 DWORD PTR tv182[rsp], eax
$LN22@s390_load_:
  00289	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0028e	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv182[rsp]
  00293	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00296	33 c0		 xor	 eax, eax
  00298	85 c0		 test	 eax, eax
  0029a	0f 85 cc fe ff
	ff		 jne	 $LN7@s390_load_

; 3605 : }

  002a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a5	48 33 cc	 xor	 rcx, rsp
  002a8	e8 00 00 00 00	 call	 __security_check_cookie
  002ad	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b1	c3		 ret	 0
s390_load_complement_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv167 = 40
tv170 = 44
tv172 = 48
tv173 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s390_load_and_test_bfp_short_reg PROC

; 3192 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3193 :     int        r1, r2;
; 3194 :     float32_t  op;
; 3195 : 
; 3196 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3197 : 
; 3198 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3199 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3200 : 
; 3201 :     GET_FLOAT32_OP( op, r2, regs );

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float32

; 3202 : 
; 3203 :     if (FLOAT32_ISNAN( op ))

  00109	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0010d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00112	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00117	75 65		 jne	 SHORT $LN11@s390_load_
  00119	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0011d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00122	85 c0		 test	 eax, eax
  00124	74 58		 je	 SHORT $LN11@s390_load_

; 3204 :     {
; 3205 :         if (f32_isSignalingNaN( op ))

  00126	8b 4c 24 20	 mov	 ecx, DWORD PTR op$[rsp]
  0012a	e8 00 00 00 00	 call	 f32_isSignalingNaN
  0012f	0f b6 c0	 movzx	 eax, al
  00132	85 c0		 test	 eax, eax
  00134	74 48		 je	 SHORT $LN12@s390_load_

; 3206 :         {
; 3207 :             if (regs->fpc & FPC_MASK_IMI)

  00136	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00141	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00146	85 c0		 test	 eax, eax
  00148	74 0e		 je	 SHORT $LN13@s390_load_

; 3208 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  0014a	b2 80		 mov	 dl, 128			; 00000080H
  0014c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	e8 00 00 00 00	 call	 ieee_trap
  00156	eb 26		 jmp	 SHORT $LN14@s390_load_
$LN13@s390_load_:

; 3209 :             else
; 3210 :             {
; 3211 :                 regs->fpc |= FPC_FLAG_SFI;

  00158	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00163	0f ba e8 17	 bts	 eax, 23
  00167	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3212 :                 FLOAT32_MAKE_QNAN( op );

  00172	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00176	0f ba e8 16	 bts	 eax, 22
  0017a	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN14@s390_load_:
$LN12@s390_load_:
$LN11@s390_load_:
$LN7@s390_load_:

; 3213 :             }
; 3214 :         }
; 3215 :     }
; 3216 : 
; 3217 :     PUT_FLOAT32_CC( op, r1, regs );

  0017e	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00182	d1 e0		 shl	 eax, 1
  00184	48 98		 cdqe
  00186	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00193	48 8b d0	 mov	 rdx, rax
  00196	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  0019b	e8 00 00 00 00	 call	 s390_put_float32
  001a0	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001a4	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  001a9	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  001ae	75 17		 jne	 SHORT $LN16@s390_load_
  001b0	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001b4	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001b9	85 c0		 test	 eax, eax
  001bb	74 0a		 je	 SHORT $LN16@s390_load_
  001bd	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv173[rsp], 3
  001c5	eb 5e		 jmp	 SHORT $LN23@s390_load_
$LN16@s390_load_:
  001c7	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001cb	0f ba f0 1f	 btr	 eax, 31
  001cf	85 c0		 test	 eax, eax
  001d1	75 0a		 jne	 SHORT $LN17@s390_load_
  001d3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  001db	eb 08		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  001dd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN18@s390_load_:
  001e5	83 7c 24 28 00	 cmp	 DWORD PTR tv167[rsp], 0
  001ea	74 0a		 je	 SHORT $LN21@s390_load_
  001ec	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
  001f4	eb 27		 jmp	 SHORT $LN22@s390_load_
$LN21@s390_load_:
  001f6	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001fa	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001ff	85 c0		 test	 eax, eax
  00201	74 0a		 je	 SHORT $LN19@s390_load_
  00203	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  0020b	eb 08		 jmp	 SHORT $LN20@s390_load_
$LN19@s390_load_:
  0020d	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv170[rsp], 2
$LN20@s390_load_:
  00215	8b 44 24 2c	 mov	 eax, DWORD PTR tv170[rsp]
  00219	89 44 24 30	 mov	 DWORD PTR tv172[rsp], eax
$LN22@s390_load_:
  0021d	8b 44 24 30	 mov	 eax, DWORD PTR tv172[rsp]
  00221	89 44 24 34	 mov	 DWORD PTR tv173[rsp], eax
$LN23@s390_load_:
  00225	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0022a	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv173[rsp]
  0022f	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00232	33 c0		 xor	 eax, eax
  00234	85 c0		 test	 eax, eax
  00236	0f 85 42 ff ff
	ff		 jne	 $LN7@s390_load_

; 3218 : }

  0023c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00240	c3		 ret	 0
s390_load_and_test_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv167 = 36
tv170 = 40
tv172 = 44
tv173 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s390_load_and_test_bfp_long_reg PROC

; 3161 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3162 :     int        r1, r2;
; 3163 :     float64_t  op;
; 3164 : 
; 3165 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_load_

; 3166 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3167 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_load_
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_load_
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3168 : 
; 3169 :     GET_FLOAT64_OP( op, r2, regs );

  000e7	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float64

; 3170 : 
; 3171 :     if (FLOAT64_ISNAN( op ))

  00109	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00118	48 23 c8	 and	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00128	48 3b c1	 cmp	 rax, rcx
  0012b	0f 85 81 00 00
	00		 jne	 $LN11@s390_load_
  00131	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0013b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00140	48 23 c8	 and	 rcx, rax
  00143	48 8b c1	 mov	 rax, rcx
  00146	48 85 c0	 test	 rax, rax
  00149	74 67		 je	 SHORT $LN11@s390_load_

; 3172 :     {
; 3173 :         if (f64_isSignalingNaN( op ))

  0014b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00150	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00155	0f b6 c0	 movzx	 eax, al
  00158	85 c0		 test	 eax, eax
  0015a	74 56		 je	 SHORT $LN12@s390_load_

; 3174 :         {
; 3175 :             if (regs->fpc & FPC_MASK_IMI)

  0015c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00161	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00167	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0016c	85 c0		 test	 eax, eax
  0016e	74 0e		 je	 SHORT $LN13@s390_load_

; 3176 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  00170	b2 80		 mov	 dl, 128			; 00000080H
  00172	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	e8 00 00 00 00	 call	 ieee_trap
  0017c	eb 34		 jmp	 SHORT $LN14@s390_load_
$LN13@s390_load_:

; 3177 :             else
; 3178 :             {
; 3179 :                 regs->fpc |= FPC_FLAG_SFI;

  0017e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00183	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00189	0f ba e8 17	 bts	 eax, 23
  0018d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3180 :                 FLOAT64_MAKE_QNAN( op );

  00198	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001a7	48 0b c8	 or	 rcx, rax
  001aa	48 8b c1	 mov	 rax, rcx
  001ad	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN14@s390_load_:
$LN12@s390_load_:
$LN11@s390_load_:
$LN7@s390_load_:

; 3181 :             }
; 3182 :         }
; 3183 :     }
; 3184 : 
; 3185 :     PUT_FLOAT64_CC( op, r1, regs );

  001b2	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001b6	d1 e0		 shl	 eax, 1
  001b8	48 98		 cdqe
  001ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001c7	48 8b d0	 mov	 rdx, rax
  001ca	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001cf	e8 00 00 00 00	 call	 s390_put_float64
  001d4	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  001de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001e3	48 23 c8	 and	 rcx, rax
  001e6	48 8b c1	 mov	 rax, rcx
  001e9	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001f3	48 3b c1	 cmp	 rax, rcx
  001f6	75 24		 jne	 SHORT $LN16@s390_load_
  001f8	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00202	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00207	48 23 c8	 and	 rcx, rax
  0020a	48 8b c1	 mov	 rax, rcx
  0020d	48 85 c0	 test	 rax, rax
  00210	74 0a		 je	 SHORT $LN16@s390_load_
  00212	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv173[rsp], 3
  0021a	eb 79		 jmp	 SHORT $LN23@s390_load_
$LN16@s390_load_:
  0021c	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00226	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0022b	48 23 c8	 and	 rcx, rax
  0022e	48 8b c1	 mov	 rax, rcx
  00231	48 85 c0	 test	 rax, rax
  00234	75 0a		 jne	 SHORT $LN17@s390_load_
  00236	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  0023e	eb 08		 jmp	 SHORT $LN18@s390_load_
$LN17@s390_load_:
  00240	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN18@s390_load_:
  00248	83 7c 24 24 00	 cmp	 DWORD PTR tv167[rsp], 0
  0024d	74 0a		 je	 SHORT $LN21@s390_load_
  0024f	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
  00257	eb 34		 jmp	 SHORT $LN22@s390_load_
$LN21@s390_load_:
  00259	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00263	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00268	48 23 c8	 and	 rcx, rax
  0026b	48 8b c1	 mov	 rax, rcx
  0026e	48 85 c0	 test	 rax, rax
  00271	74 0a		 je	 SHORT $LN19@s390_load_
  00273	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  0027b	eb 08		 jmp	 SHORT $LN20@s390_load_
$LN19@s390_load_:
  0027d	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv170[rsp], 2
$LN20@s390_load_:
  00285	8b 44 24 28	 mov	 eax, DWORD PTR tv170[rsp]
  00289	89 44 24 2c	 mov	 DWORD PTR tv172[rsp], eax
$LN22@s390_load_:
  0028d	8b 44 24 2c	 mov	 eax, DWORD PTR tv172[rsp]
  00291	89 44 24 30	 mov	 DWORD PTR tv173[rsp], eax
$LN23@s390_load_:
  00295	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv173[rsp]
  0029f	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  002a2	33 c0		 xor	 eax, eax
  002a4	85 c0		 test	 eax, eax
  002a6	0f 85 06 ff ff
	ff		 jne	 $LN7@s390_load_

; 3186 : }

  002ac	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002b0	c3		 ret	 0
s390_load_and_test_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv197 = 44
tv202 = 48
tv204 = 52
tv205 = 56
$T2 = 64
op$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
s390_load_and_test_bfp_ext_reg PROC

; 3129 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3130 :     int         r1, r2;
; 3131 :     float128_t  op;
; 3132 : 
; 3133 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_load_:
  00051	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN8@s390_load_
  00074	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@s390_load_

; 3134 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3135 :     BFPINST_CHECK( regs );

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a6	85 c0		 test	 eax, eax
  000a8	74 3f		 je	 SHORT $LN10@s390_load_
  000aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 55		 je	 SHORT $LN9@s390_load_
  000c1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	b9 08 00 00 00	 mov	 ecx, 8
  000d5	48 6b c9 01	 imul	 rcx, rcx, 1
  000d9	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e5	85 c0		 test	 eax, eax
  000e7	75 2d		 jne	 SHORT $LN9@s390_load_
$LN10@s390_load_:
  000e9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fb	ba 07 00 00 00	 mov	 edx, 7
  00100	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_load_:

; 3136 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00116	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011a	83 e0 02	 and	 eax, 2
  0011d	85 c0		 test	 eax, eax
  0011f	75 0b		 jne	 SHORT $LN12@s390_load_
  00121	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00125	83 e0 02	 and	 eax, 2
  00128	85 c0		 test	 eax, eax
  0012a	74 1b		 je	 SHORT $LN11@s390_load_
$LN12@s390_load_:
  0012c	ba 06 00 00 00	 mov	 edx, 6
  00131	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00141	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_load_:

; 3137 : 
; 3138 :     GET_FLOAT128_OP( op, r2, regs );

  00147	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  0014b	d1 e0		 shl	 eax, 1
  0014d	48 98		 cdqe
  0014f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015f	48 8b d0	 mov	 rdx, rax
  00162	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  00167	e8 00 00 00 00	 call	 s390_get_float128

; 3139 : 
; 3140 :     if (FLOAT128_ISNAN( op ))

  0016c	b8 08 00 00 00	 mov	 eax, 8
  00171	48 6b c0 01	 imul	 rax, rax, 1
  00175	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0017f	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  00184	48 23 c1	 and	 rax, rcx
  00187	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00191	48 3b c1	 cmp	 rax, rcx
  00194	0f 85 ce 00 00
	00		 jne	 $LN13@s390_load_
  0019a	b8 08 00 00 00	 mov	 eax, 8
  0019f	48 6b c0 01	 imul	 rax, rax, 1
  001a3	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001ad	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  001b2	48 23 c1	 and	 rax, rcx
  001b5	48 85 c0	 test	 rax, rax
  001b8	75 15		 jne	 SHORT $LN14@s390_load_
  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 00	 imul	 rax, rax, 0
  001c3	48 83 7c 04 50
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  001c9	0f 84 99 00 00
	00		 je	 $LN13@s390_load_
$LN14@s390_load_:

; 3141 :     {
; 3142 :         if (f128_isSignalingNaN( op ))

  001cf	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  001d4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  001d9	48 8b f8	 mov	 rdi, rax
  001dc	48 8b f1	 mov	 rsi, rcx
  001df	b9 10 00 00 00	 mov	 ecx, 16
  001e4	f3 a4		 rep movsb
  001e6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  001eb	e8 00 00 00 00	 call	 f128_isSignalingNaN
  001f0	0f b6 c0	 movzx	 eax, al
  001f3	85 c0		 test	 eax, eax
  001f5	74 71		 je	 SHORT $LN15@s390_load_

; 3143 :         {
; 3144 :             if (regs->fpc & FPC_MASK_IMI)

  001f7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ff	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00205	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0020a	85 c0		 test	 eax, eax
  0020c	74 11		 je	 SHORT $LN16@s390_load_

; 3145 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  0020e	b2 80		 mov	 dl, 128			; 00000080H
  00210	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	e8 00 00 00 00	 call	 ieee_trap
  0021d	eb 49		 jmp	 SHORT $LN17@s390_load_
$LN16@s390_load_:

; 3146 :             else
; 3147 :             {
; 3148 :                 regs->fpc |= FPC_FLAG_SFI;

  0021f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00227	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0022d	0f ba e8 17	 bts	 eax, 23
  00231	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3149 :                 FLOAT128_MAKE_QNAN( op );

  0023f	b8 08 00 00 00	 mov	 eax, 8
  00244	48 6b c0 01	 imul	 rax, rax, 1
  00248	48 b9 00 00 00
	00 00 80 00 00	 mov	 rcx, 140737488355328	; 0000800000000000H
  00252	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  00257	48 0b c1	 or	 rax, rcx
  0025a	b9 08 00 00 00	 mov	 ecx, 8
  0025f	48 6b c9 01	 imul	 rcx, rcx, 1
  00263	48 89 44 0c 50	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN17@s390_load_:
$LN15@s390_load_:
$LN13@s390_load_:
$LN7@s390_load_:

; 3150 :             }
; 3151 :         }
; 3152 :     }
; 3153 : 
; 3154 :     PUT_FLOAT128_CC( op, r1, regs );

  00268	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0026c	d1 e0		 shl	 eax, 1
  0026e	48 98		 cdqe
  00270	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00278	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00280	48 8b d0	 mov	 rdx, rax
  00283	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  00288	e8 00 00 00 00	 call	 s390_put_float128
  0028d	b8 08 00 00 00	 mov	 eax, 8
  00292	48 6b c0 01	 imul	 rax, rax, 1
  00296	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  002a0	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  002a5	48 23 c1	 and	 rax, rcx
  002a8	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  002b2	48 3b c1	 cmp	 rax, rcx
  002b5	75 3e		 jne	 SHORT $LN20@s390_load_
  002b7	b8 08 00 00 00	 mov	 eax, 8
  002bc	48 6b c0 01	 imul	 rax, rax, 1
  002c0	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  002ca	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  002cf	48 23 c1	 and	 rax, rcx
  002d2	48 85 c0	 test	 rax, rax
  002d5	75 11		 jne	 SHORT $LN19@s390_load_
  002d7	b8 08 00 00 00	 mov	 eax, 8
  002dc	48 6b c0 00	 imul	 rax, rax, 0
  002e0	48 83 7c 04 50
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  002e6	74 0d		 je	 SHORT $LN20@s390_load_
$LN19@s390_load_:
  002e8	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv205[rsp], 3
  002f0	e9 93 00 00 00	 jmp	 $LN27@s390_load_
$LN20@s390_load_:
  002f5	b8 08 00 00 00	 mov	 eax, 8
  002fa	48 6b c0 01	 imul	 rax, rax, 1
  002fe	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00308	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  0030d	48 23 c1	 and	 rax, rcx
  00310	b9 08 00 00 00	 mov	 ecx, 8
  00315	48 6b c9 00	 imul	 rcx, rcx, 0
  00319	48 0b 44 0c 50	 or	 rax, QWORD PTR op$[rsp+rcx]
  0031e	48 85 c0	 test	 rax, rax
  00321	75 0a		 jne	 SHORT $LN21@s390_load_
  00323	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv197[rsp], 1
  0032b	eb 08		 jmp	 SHORT $LN22@s390_load_
$LN21@s390_load_:
  0032d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv197[rsp], 0
$LN22@s390_load_:
  00335	83 7c 24 2c 00	 cmp	 DWORD PTR tv197[rsp], 0
  0033a	74 0a		 je	 SHORT $LN25@s390_load_
  0033c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
  00344	eb 3a		 jmp	 SHORT $LN26@s390_load_
$LN25@s390_load_:
  00346	b8 08 00 00 00	 mov	 eax, 8
  0034b	48 6b c0 01	 imul	 rax, rax, 1
  0034f	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00359	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  0035e	48 23 c1	 and	 rax, rcx
  00361	48 85 c0	 test	 rax, rax
  00364	74 0a		 je	 SHORT $LN23@s390_load_
  00366	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  0036e	eb 08		 jmp	 SHORT $LN24@s390_load_
$LN23@s390_load_:
  00370	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv202[rsp], 2
$LN24@s390_load_:
  00378	8b 44 24 30	 mov	 eax, DWORD PTR tv202[rsp]
  0037c	89 44 24 34	 mov	 DWORD PTR tv204[rsp], eax
$LN26@s390_load_:
  00380	8b 44 24 34	 mov	 eax, DWORD PTR tv204[rsp]
  00384	89 44 24 38	 mov	 DWORD PTR tv205[rsp], eax
$LN27@s390_load_:
  00388	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00390	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv205[rsp]
  00395	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00398	33 c0		 xor	 eax, eax
  0039a	85 c0		 test	 eax, eax
  0039c	0f 85 c6 fe ff
	ff		 jne	 $LN7@s390_load_

; 3155 : }

  003a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a7	48 33 cc	 xor	 rcx, rsp
  003aa	e8 00 00 00 00	 call	 __security_check_cookie
  003af	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003b3	5f		 pop	 rdi
  003b4	5e		 pop	 rsi
  003b5	c3		 ret	 0
s390_load_and_test_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
quo$ = 36
rem$ = 40
m4$ = 44
op1$ = 48
op2$ = 52
temp$1 = 56
op1_data_class$ = 60
op2_data_class$ = 64
r1$ = 68
r2$ = 72
r3$ = 76
tv190 = 80
ieee_trap_conds$ = 84
intquo64$2 = 88
op164$3 = 96
op264$4 = 104
quo64$5 = 112
rem64$6 = 120
inst$ = 144
regs$ = 152
s390_divide_integer_bfp_short_reg PROC

; 5329 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 5330 :     int        r1, r2, r3;
; 5331 :     BYTE       m4, newcc;
; 5332 :     float32_t  op1, op2;
; 5333 :     float32_t  rem, quo;
; 5334 :     U32        ieee_trap_conds = 0;

  00011	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 5335 :     U32        op1_data_class, op2_data_class;
; 5336 : 
; 5337 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00021	e8 00 00 00 00	 call	 fetch_fw_noswap
  00026	8b c8		 mov	 ecx, eax
  00028	e8 00 00 00 00	 call	 _byteswap_ulong
  0002d	89 44 24 38	 mov	 DWORD PTR temp$1[rsp], eax
  00031	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  0003c	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 04	 shr	 eax, 4
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  0004a	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 08	 shr	 eax, 8
  00051	83 e0 0f	 and	 eax, 15
  00054	88 44 24 2c	 mov	 BYTE PTR m4$[rsp], al
  00058	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 0c	 shr	 eax, 12
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 4c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s390_divid:
  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00072	48 83 c0 04	 add	 rax, 4
  00076	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00082	33 c0		 xor	 eax, eax
  00084	83 f8 04	 cmp	 eax, 4
  00087	74 0f		 je	 SHORT $LN8@s390_divid
  00089	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_divid:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 c8		 jne	 SHORT $LN4@s390_divid

; 5338 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5339 :     BFPINST_CHECK( regs );

  0009e	b8 08 00 00 00	 mov	 eax, 8
  000a3	48 6b c0 01	 imul	 rax, rax, 1
  000a7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b6	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bb	85 c0		 test	 eax, eax
  000bd	74 3f		 je	 SHORT $LN10@s390_divid
  000bf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000cd	d1 e8		 shr	 eax, 1
  000cf	83 e0 01	 and	 eax, 1
  000d2	85 c0		 test	 eax, eax
  000d4	74 55		 je	 SHORT $LN9@s390_divid
  000d6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e5	b9 08 00 00 00	 mov	 ecx, 8
  000ea	48 6b c9 01	 imul	 rcx, rcx, 1
  000ee	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000fa	85 c0		 test	 eax, eax
  000fc	75 2d		 jne	 SHORT $LN9@s390_divid
$LN10@s390_divid:
  000fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00106	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00110	ba 07 00 00 00	 mov	 edx, 7
  00115	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00125	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_divid:

; 5340 :     BFPRM_CHECK( m4, regs );

  0012b	0f b6 54 24 2c	 movzx	 edx, BYTE PTR m4$[rsp]
  00130	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 5341 : 
; 5342 :     if (r1 == r2 || r2 == r3 || r1 == r3)

  0013d	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  00141	39 44 24 44	 cmp	 DWORD PTR r1$[rsp], eax
  00145	74 14		 je	 SHORT $LN12@s390_divid
  00147	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  0014b	39 44 24 48	 cmp	 DWORD PTR r2$[rsp], eax
  0014f	74 0a		 je	 SHORT $LN12@s390_divid
  00151	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  00155	39 44 24 44	 cmp	 DWORD PTR r1$[rsp], eax
  00159	75 1b		 jne	 SHORT $LN11@s390_divid
$LN12@s390_divid:

; 5343 :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0015b	ba 06 00 00 00	 mov	 edx, 6
  00160	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_divid:
$LN7@s390_divid:

; 5344 : 
; 5345 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00176	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  0017a	d1 e0		 shl	 eax, 1
  0017c	48 98		 cdqe
  0017e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0018e	48 8b d0	 mov	 rdx, rax
  00191	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00196	e8 00 00 00 00	 call	 s390_get_float32
  0019b	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  0019f	d1 e0		 shl	 eax, 1
  001a1	48 98		 cdqe
  001a3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b3	48 8b d0	 mov	 rdx, rax
  001b6	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op2$[rsp]
  001bb	e8 00 00 00 00	 call	 s390_get_float32
  001c0	33 c0		 xor	 eax, eax
  001c2	85 c0		 test	 eax, eax
  001c4	75 b0		 jne	 SHORT $LN7@s390_divid

; 5346 : 
; 5347 :     op1_data_class = float32_class( op1 );

  001c6	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  001ca	e8 00 00 00 00	 call	 float32_class
  001cf	89 44 24 3c	 mov	 DWORD PTR op1_data_class$[rsp], eax

; 5348 :     op2_data_class = float32_class( op2 );

  001d3	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  001d7	e8 00 00 00 00	 call	 float32_class
  001dc	89 44 24 40	 mov	 DWORD PTR op2_data_class$[rsp], eax

; 5349 : 
; 5350 :     softfloat_exceptionFlags = 0;

  001e0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e5	8b c0		 mov	 eax, eax
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ed	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001fa	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5351 : 
; 5352 :     /************************************************************************************/
; 5353 :     /* Following if / else if / else implements a decision tree based on SA-22-7832-10  */
; 5354 :     /* Table 19-21 parts 1 and 2 on pages 19-29 and 19-30 respectively.                 */
; 5355 :     /*                                                                                  */
; 5356 :     /* ORDER OF TESTS IS IMPORTANT                                                      */
; 5357 :     /*                                                                                  */
; 5358 :     /*  1. Tests for cases that include two non-finite non-zeroes.                      */
; 5359 :     /*  2. Tests for cases that include one or two NaNs as input values                 */
; 5360 :     /*  3. Tests for cases that always generate the default quiet NaN                   */
; 5361 :     /*  4. Tests for cases that generate non-NaN results.                               */
; 5362 :     /*                                                                                  */
; 5363 :     /* When viewed from the perspective of Table 19-21, this order:                     */
; 5364 :     /*                                                                                  */
; 5365 :     /*  1. Addresses what is likely to be the most frequent case first                  */
; 5366 :     /*  2. Removes the bottom two rows and the right-hand two columns                   */
; 5367 :     /*  3. Removes the center two colums and the top and new bottom rows                */
; 5368 :     /*  4. Leaves only those cases that involve returning a zero or operand as a result.*/
; 5369 :     /*                                                                                  */
; 5370 :     /************************************************************************************/
; 5371 : 
; 5372 :     /************************************************************************************/
; 5373 :     /* Group 1: Tests for cases with finite non-zeros for both operands.  This is seen  */
; 5374 :     /* as the most frequent case, and should therefore be tested first.                 */
; 5375 :     /************************************************************************************/
; 5376 : 
; 5377 :                                                                     /* Both operands finite numbers?*/
; 5378 :     if ((op1_data_class & (float_class_neg_normal
; 5379 :                          | float_class_pos_normal
; 5380 :                          | float_class_neg_subnormal
; 5381 :                          | float_class_pos_subnormal))
; 5382 :         &&

  001fe	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00202	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  00207	85 c0		 test	 eax, eax
  00209	0f 84 a5 04 00
	00		 je	 $LN13@s390_divid
  0020f	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00213	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  00218	85 c0		 test	 eax, eax
  0021a	0f 84 94 04 00
	00		 je	 $LN13@s390_divid

; 5383 :         (op2_data_class & (float_class_neg_normal
; 5384 :                          | float_class_pos_normal
; 5385 :                          | float_class_neg_subnormal
; 5386 :                          | float_class_pos_subnormal))
; 5387 :     )
; 5388 :     {                                                               /* ..yes, we can do division */
; 5389 : 
; 5390 :         newcc = 0;                                                  /* Initial cc set to zero    */

  00220	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 5391 :         SET_SF_RM_FROM_MASK( m4 );

  00225	0f b6 44 24 2c	 movzx	 eax, BYTE PTR m4$[rsp]
  0022a	85 c0		 test	 eax, eax
  0022c	74 16		 je	 SHORT $LN37@s390_divid
  0022e	0f b6 44 24 2c	 movzx	 eax, BYTE PTR m4$[rsp]
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0023a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023e	89 44 24 50	 mov	 DWORD PTR tv190[rsp], eax
  00242	eb 22		 jmp	 SHORT $LN38@s390_divid
$LN37@s390_divid:
  00244	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00252	83 e0 07	 and	 eax, 7
  00255	8b c0		 mov	 eax, eax
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0025e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00262	89 44 24 50	 mov	 DWORD PTR tv190[rsp], eax
$LN38@s390_divid:
  00266	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0026b	8b c0		 mov	 eax, eax
  0026d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00273	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00280	0f b6 54 24 50	 movzx	 edx, BYTE PTR tv190[rsp]
  00285	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 5392 : 
; 5393 :         quo = f32_div( op1, op2 );                                  /* calculate precise quotient                       */

  00288	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0028c	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00290	e8 00 00 00 00	 call	 f32_div
  00295	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5394 :         quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode            */

  00299	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0029e	8b c0		 mov	 eax, eax
  002a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b3	41 b0 01	 mov	 r8b, 1
  002b6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002ba	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  002be	e8 00 00 00 00	 call	 f32_roundToInt
  002c3	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5395 : 
; 5396 :         softfloat_exceptionFlags &= softfloat_flag_overflow;        /* Quotient only cares about overflow               */

  002c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002cc	8b c0		 mov	 eax, eax
  002ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e5	83 e0 04	 and	 eax, 4
  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f7	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  002fd	45 8b c0	 mov	 r8d, r8d
  00300	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00304	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5397 :         SET_SF_RM_FROM_FPC;                                         /* Set rounding mode from FPC for final remainder   */

  00308	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00310	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00316	83 e0 07	 and	 eax, 7
  00319	8b c0		 mov	 eax, eax
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00322	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00327	8b d2		 mov	 edx, edx
  00329	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00330	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00339	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0033d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00341	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5398 :         quo.v ^= 0x80000000;                                        /* Reverse sign of integer quotient                 */

  00345	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00349	0f ba f8 1f	 btc	 eax, 31
  0034d	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5399 :         rem = f32_mulAdd(quo, op2, op1);                            /* Calculate remainder                              */

  00351	44 8b 44 24 30	 mov	 r8d, DWORD PTR op1$[rsp]
  00356	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0035a	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0035e	e8 00 00 00 00	 call	 f32_mulAdd
  00363	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5400 :         quo.v ^= 0x80000000;                                        /* Return sign of integer quotient to original value*/

  00367	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0036b	0f ba f8 1f	 btc	 eax, 31
  0036f	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5401 : 
; 5402 :         if (!(rem.v & 0x7fffffff))                                  /* Is remainder zero?                               */

  00373	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  00377	0f ba f0 1f	 btr	 eax, 31
  0037b	85 c0		 test	 eax, eax
  0037d	75 17		 jne	 SHORT $LN15@s390_divid

; 5403 :             rem.v = (op1.v & 0x80000000) | (rem.v & 0x7fffffff);    /* ..yes, ensure remainder sign matches dividend    */

  0037f	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00383	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00388	8b 4c 24 28	 mov	 ecx, DWORD PTR rem$[rsp]
  0038c	0f ba f1 1f	 btr	 ecx, 31
  00390	0b c1		 or	 eax, ecx
  00392	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
$LN15@s390_divid:

; 5404 : 
; 5405 :         if (!softfloat_exceptionFlags)                              /* If no exceptions, check for partial results      */

  00396	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0039b	8b c0		 mov	 eax, eax
  0039d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003ac	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b4	85 c0		 test	 eax, eax
  003b6	0f 85 fb 00 00
	00		 jne	 $LN16@s390_divid

; 5406 :         {
; 5407 :             if (((quo.v & 0x7fffffff) > 0x4B800000) && (rem.v & 0x7fffffff))  /* Quotient > 2^24th & rem <>0?           */

  003bc	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  003c0	0f ba f0 1f	 btr	 eax, 31
  003c4	3d 00 00 80 4b	 cmp	 eax, 1266679808		; 4b800000H
  003c9	0f 86 e3 00 00
	00		 jbe	 $LN18@s390_divid
  003cf	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  003d3	0f ba f0 1f	 btr	 eax, 31
  003d7	85 c0		 test	 eax, eax
  003d9	0f 84 d3 00 00
	00		 je	 $LN18@s390_divid

; 5408 :             {
; 5409 :                 newcc += 2;                                         /* ..yes, indicate partial results in cc            */

  003df	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  003e4	83 c0 02	 add	 eax, 2
  003e7	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5410 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  003eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  003f0	8b c0		 mov	 eax, eax
  003f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003f8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00401	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00405	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5411 :                                                                     /* ..with rounding toward zero                      */
; 5412 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  00409	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0040e	8b c0		 mov	 eax, eax
  00410	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00416	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0041f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00423	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5413 : 
; 5414 :                 quo = f32_div( op1, op2 );                          /* calculate precise quotient                       */

  00427	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0042b	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  0042f	e8 00 00 00 00	 call	 f32_div
  00434	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5415 :                 quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  00438	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0043d	8b c0		 mov	 eax, eax
  0043f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00445	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0044e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00452	41 b0 01	 mov	 r8b, 1
  00455	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00459	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0045d	e8 00 00 00 00	 call	 f32_roundToInt
  00462	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5416 : 
; 5417 :                 quo.v ^= 0x80000000;                                /* Reverse sign of integer quotient                 */

  00466	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0046a	0f ba f8 1f	 btc	 eax, 31
  0046e	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5418 : 
; 5419 :                 rem = f32_mulAdd( quo, op2, op1 );                  /* Calculate remainder                              */

  00472	44 8b 44 24 30	 mov	 r8d, DWORD PTR op1$[rsp]
  00477	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0047b	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0047f	e8 00 00 00 00	 call	 f32_mulAdd
  00484	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5420 : 
; 5421 :                 quo.v ^= 0x80000000;                                /* Return sign of integer quotient to original value*/

  00488	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0048c	0f ba f8 1f	 btc	 eax, 31
  00490	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5422 :                 softfloat_exceptionFlags = 0;                       /* No exceptions or flags on partial results        */

  00494	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00499	8b c0		 mov	 eax, eax
  0049b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004a1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004aa	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004ae	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN18@s390_divid:

; 5423 :             }
; 5424 :         }

  004b2	e9 f8 01 00 00	 jmp	 $LN17@s390_divid
$LN16@s390_divid:

; 5425 :         else                                                        /* Exception flagged...we have work to do.          */
; 5426 :         {                                                                                                          
; 5427 :             if (softfloat_exceptionFlags & softfloat_flag_overflow) /* on oveflow, scale result and set cc=1 or 3       */

  004b7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  004bc	8b c0		 mov	 eax, eax
  004be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004c4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004cd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d5	83 e0 04	 and	 eax, 4
  004d8	85 c0		 test	 eax, eax
  004da	0f 84 85 01 00
	00		 je	 $LN19@s390_divid

; 5428 :                                                                     /* and recalculate the remainder using a scaled     */
; 5429 :                                                                     /* quotient in 64-bit precision                     */
; 5430 :                                                                     /* Note that there is no fractional part to the     */
; 5431 :                                                                     /* quotient when the quotient overflows             */
; 5432 :             {
; 5433 :                 float64_t  quo64, intquo64, rem64;
; 5434 :                 float64_t  op164, op264;
; 5435 : 
; 5436 :                 newcc += 1;                                         /* Set condition code odd for quotient overflow     */

  004e0	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  004e5	ff c0		 inc	 eax
  004e7	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5437 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  004eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  004f0	8b c0		 mov	 eax, eax
  004f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004f8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00501	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00505	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5438 :                                                                     /* ..with rounding toward zero                      */
; 5439 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  00509	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0050e	8b c0		 mov	 eax, eax
  00510	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00516	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0051f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00523	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5440 : 
; 5441 :                 quo = f32_div( op1, op2 );                          /* calculate precise quotient                       */

  00527	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0052b	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  0052f	e8 00 00 00 00	 call	 f32_div
  00534	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5442 :                 quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE ); /* Partial result, round to zero             */

  00538	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0053d	8b c0		 mov	 eax, eax
  0053f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00545	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0054e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00552	41 b0 01	 mov	 r8b, 1
  00555	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00559	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0055d	e8 00 00 00 00	 call	 f32_roundToInt
  00562	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5443 :                 quo = f32_scaledResult( SCALE_FACTOR_ARITH_OFLOW_SHORT );  /* Scale quotient                            */

  00566	b9 40 ff ff ff	 mov	 ecx, -192		; ffffffffffffff40H
  0056b	e8 00 00 00 00	 call	 f32_scaledResult
  00570	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5444 : 
; 5445 :                 op164 = f32_to_f64( op1 );

  00574	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00578	e8 00 00 00 00	 call	 f32_to_f64
  0057d	48 89 44 24 60	 mov	 QWORD PTR op164$3[rsp], rax

; 5446 :                 op264 = f32_to_f64( op2 );

  00582	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  00586	e8 00 00 00 00	 call	 f32_to_f64
  0058b	48 89 44 24 68	 mov	 QWORD PTR op264$4[rsp], rax

; 5447 : 
; 5448 :                 softfloat_roundingMode = softfloat_round_minMag;

  00590	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00595	8b c0		 mov	 eax, eax
  00597	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0059d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005aa	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5449 : 
; 5450 :                 quo64 = f64_div( op164, op264 );

  005ae	48 8b 54 24 68	 mov	 rdx, QWORD PTR op264$4[rsp]
  005b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op164$3[rsp]
  005b8	e8 00 00 00 00	 call	 f64_div
  005bd	48 89 44 24 70	 mov	 QWORD PTR quo64$5[rsp], rax

; 5451 : 
; 5452 :                 intquo64.v = quo64.v & 0xFFFFFFFFE0000000ULL;       /* Truncate significand to BFP Short bits           */

  005c2	48 8b 44 24 70	 mov	 rax, QWORD PTR quo64$5[rsp]
  005c7	48 25 00 00 00
	e0		 and	 rax, -536870912		; ffffffffe0000000H
  005cd	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5453 :                 intquo64.v ^= 0x8000000000000000ULL;                /* flip sign of dividend for fused multiply-add     */

  005d2	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  005dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  005e1	48 33 c8	 xor	 rcx, rax
  005e4	48 8b c1	 mov	 rax, rcx
  005e7	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5454 : 
; 5455 :                 rem64 = f64_mulAdd( intquo64, op264, op164 );       /* -rem = intquo * divisor + (-dividend)            */

  005ec	4c 8b 44 24 60	 mov	 r8, QWORD PTR op164$3[rsp]
  005f1	48 8b 54 24 68	 mov	 rdx, QWORD PTR op264$4[rsp]
  005f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  005fb	e8 00 00 00 00	 call	 f64_mulAdd
  00600	48 89 44 24 78	 mov	 QWORD PTR rem64$6[rsp], rax

; 5456 : 
; 5457 :                 intquo64.v ^= 0x8000000000000000ULL;                /* Restore sign of dividend                         */

  00605	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0060f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  00614	48 33 c8	 xor	 rcx, rax
  00617	48 8b c1	 mov	 rax, rcx
  0061a	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5458 :                 softfloat_exceptionFlags = 0;                       /* clear any prior Softfloat flags                  */

  0061f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00624	8b c0		 mov	 eax, eax
  00626	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0062c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00635	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00639	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5459 : 
; 5460 :                 rem = f64_to_f32( rem64 );                          /* should be exact!?)                               */

  0063d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rem64$6[rsp]
  00642	e8 00 00 00 00	 call	 f64_to_f32
  00647	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5461 : 
; 5462 :                 if (rem.v & 0x7fffffff)                             /* non-zero remainder?                              */

  0064b	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  0064f	0f ba f0 1f	 btr	 eax, 31
  00653	85 c0		 test	 eax, eax
  00655	74 0c		 je	 SHORT $LN21@s390_divid

; 5463 :                     newcc += 2;                                     /* yes, indicate partial results                    */

  00657	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  0065c	83 c0 02	 add	 eax, 2
  0065f	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al
$LN21@s390_divid:

; 5464 :             }

  00663	eb 4a		 jmp	 SHORT $LN20@s390_divid
$LN19@s390_divid:

; 5465 :             else if (softfloat_exceptionFlags & (softfloat_flag_tiny | softfloat_flag_underflow))

  00665	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0066a	8b c0		 mov	 eax, eax
  0066c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00672	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0067b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0067f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00683	83 e0 42	 and	 eax, 66			; 00000042H
  00686	85 c0		 test	 eax, eax
  00688	74 25		 je	 SHORT $LN22@s390_divid

; 5466 :             {
; 5467 :                 /* Inexact and underflow'ed remainder issues and traps are handled by code at the end of Divide To Integer  */
; 5468 :                 /* But because this is the only situation where the remainder might need scaling, we will do it here        */
; 5469 :                 if (regs->fpc & FPC_MASK_IMU)

  0068a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00692	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00698	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0069d	85 c0		 test	 eax, eax
  0069f	74 0e		 je	 SHORT $LN23@s390_divid

; 5470 :                     rem = f32_scaledResult(SCALE_FACTOR_ARITH_UFLOW_SHORT);

  006a1	b9 c0 00 00 00	 mov	 ecx, 192		; 000000c0H
  006a6	e8 00 00 00 00	 call	 f32_scaledResult
  006ab	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
$LN23@s390_divid:
$LN22@s390_divid:
$LN20@s390_divid:
$LN17@s390_divid:

; 5471 :             }
; 5472 :         }
; 5473 :     }

  006af	e9 c2 01 00 00	 jmp	 $LN14@s390_divid
$LN13@s390_divid:

; 5474 : 
; 5475 :     /************************************************************************************/
; 5476 :     /* Group 2: tests for cases with NaNs for one or both operands                      */
; 5477 :     /* The sequence is required to ensure that the generated results match the IBM NaN  */
; 5478 :     /* propagation rules shown in Table 19-21                                           */
; 5479 :     /************************************************************************************/
; 5480 : 
; 5481 :     /* ******* NEXT FOUR TESTS, ALL GROUP 2 TESTS, MUST REMAIN IN SEQUENCE *******      */
; 5482 :     else if (op1_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* first case: op1 an SNaN?  */

  006b4	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  006b8	83 e0 03	 and	 eax, 3
  006bb	85 c0		 test	 eax, eax
  006bd	74 67		 je	 SHORT $LN24@s390_divid

; 5483 :     {
; 5484 :         quo = op1;

  006bf	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  006c3	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5485 :         FLOAT32_MAKE_QNAN( quo );

  006c7	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  006cb	0f ba e8 16	 bts	 eax, 22
  006cf	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5486 :         rem = quo;

  006d3	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  006d7	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5487 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  006db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  006e0	8b c0		 mov	 eax, eax
  006e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  006e8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  006f1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  006f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006f9	83 c8 10	 or	 eax, 16
  006fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00702	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0070b	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00711	45 8b c0	 mov	 r8d, r8d
  00714	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00718	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5488 :         newcc = 1;                                                                               /* Any NaN returns cc=1      */

  0071c	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5489 :     }

  00721	e9 50 01 00 00	 jmp	 $LN25@s390_divid
$LN24@s390_divid:

; 5490 :     else if (op2_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* second case: op2 an SNaN? */

  00726	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  0072a	83 e0 03	 and	 eax, 3
  0072d	85 c0		 test	 eax, eax
  0072f	74 67		 je	 SHORT $LN26@s390_divid

; 5491 :     {
; 5492 :         quo = op2;

  00731	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  00735	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5493 :         FLOAT32_MAKE_QNAN( quo );

  00739	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0073d	0f ba e8 16	 bts	 eax, 22
  00741	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5494 :         rem = quo;

  00745	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00749	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5495 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  0074d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00752	8b c0		 mov	 eax, eax
  00754	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0075a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00763	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00767	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0076b	83 c8 10	 or	 eax, 16
  0076e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00774	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0077d	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00783	45 8b c0	 mov	 r8d, r8d
  00786	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0078a	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5496 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  0078e	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5497 :     }

  00793	e9 de 00 00 00	 jmp	 $LN27@s390_divid
$LN26@s390_divid:

; 5498 :     else if (op1_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* third case: op1 a QNaN?    */

  00798	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  0079c	83 e0 0c	 and	 eax, 12
  0079f	85 c0		 test	 eax, eax
  007a1	74 1a		 je	 SHORT $LN28@s390_divid

; 5499 :     {
; 5500 :         rem = quo = op1;

  007a3	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  007a7	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax
  007ab	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  007af	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5501 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  007b3	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5502 :     }

  007b8	e9 b9 00 00 00	 jmp	 $LN29@s390_divid
$LN28@s390_divid:

; 5503 :     else if (op2_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* fourth case: op2 a QNaN?   */

  007bd	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  007c1	83 e0 0c	 and	 eax, 12
  007c4	85 c0		 test	 eax, eax
  007c6	74 1a		 je	 SHORT $LN30@s390_divid

; 5504 :     {
; 5505 :         rem = quo = op2;

  007c8	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  007cc	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax
  007d0	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  007d4	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5506 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  007d8	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5507 :     }

  007dd	e9 94 00 00 00	 jmp	 $LN31@s390_divid
$LN30@s390_divid:

; 5508 :     /* END OF FOUR TESTS THAT MUST REMAIN IN SEQUENCE                                   */
; 5509 : 
; 5510 :     /************************************************************************************/
; 5511 :     /* NEXT TEST MUST FOLLOW ALL FOUR NAN TESTS                                         */
; 5512 :     /* Group 3: Test cases that generate the default NaN and IEEE exception Invalid     */
; 5513 :     /* If operand 1 is an infinity OR operand two is a zero, and none of the above      */
; 5514 :     /* conditions are met, i.e., neither operand is a NaN, return a default NaN         */
; 5515 :     /************************************************************************************/
; 5516 : 
; 5517 :     else if ((op1_data_class & (float_class_neg_infinity | float_class_pos_infinity))           /* Operand 1 an infinity?     */
; 5518 :          ||  (op2_data_class & (float_class_neg_zero     | float_class_pos_zero))               /* ..or operand 2 a zero?     */

  007e2	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  007e6	83 e0 30	 and	 eax, 48			; 00000030H
  007e9	85 c0		 test	 eax, eax
  007eb	75 0d		 jne	 SHORT $LN34@s390_divid
  007ed	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  007f1	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  007f6	85 c0		 test	 eax, eax
  007f8	74 5a		 je	 SHORT $LN32@s390_divid
$LN34@s390_divid:

; 5519 :     )
; 5520 :     {                                                                                           /* ..yes, return DNaN, raise invalid  */
; 5521 :         quo = rem = float32_default_qnan;

  007fa	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR float32_default_qnan
  00800	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
  00804	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  00808	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5522 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  0080c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00811	8b c0		 mov	 eax, eax
  00813	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00819	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00822	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00826	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0082a	83 c8 10	 or	 eax, 16
  0082d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00833	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0083c	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00842	45 8b c0	 mov	 r8d, r8d
  00845	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00849	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5523 :         newcc = 1;

  0084d	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5524 :     }

  00852	eb 22		 jmp	 SHORT $LN33@s390_divid
$LN32@s390_divid:

; 5525 :     /* ABOVE TEST MUST IMMEDIATELY FOLLOW ALL FOUR NAN TESTS                            */
; 5526 : 
; 5527 :     /************************************************************************************/
; 5528 :     /* Group 4: Tests for cases that generate zero or an operand value as a result.     */
; 5529 :     /*                                                                                  */
; 5530 :     /* At this point, only the remaining operand combinations remain:                   */
; 5531 :     /* - Operand 1 is zero and operand 2 is non-zero (either finite or infinity)        */
; 5532 :     /* - Operand 1 is finite and operand 2 is infinity                                  */
; 5533 :     /*                                                                                  */
; 5534 :     /* The result is the same for each of the above: Operand 1 becomes the remainder,   */
; 5535 :     /* and the quotient is zero with a signed determined by the signs of the operands.  */
; 5536 :     /* Exclusive Or sets the sign correctly.                                            */
; 5537 :     /************************************************************************************/
; 5538 :     else
; 5539 :     {
; 5540 :         rem = op1;                                          /* remainder is operand 1                       */

  00854	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00858	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5541 :         quo.v = (op1.v ^ op2.v) & 0x80000000;               /* quotient zero, sign is exclusive or of operand signs   */

  0085c	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  00860	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00864	33 c8		 xor	 ecx, eax
  00866	8b c1		 mov	 eax, ecx
  00868	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0086d	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5542 :         newcc = 0;

  00871	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0
$LN33@s390_divid:
$LN31@s390_divid:
$LN29@s390_divid:
$LN27@s390_divid:
$LN25@s390_divid:
$LN14@s390_divid:

; 5543 :     }
; 5544 : 
; 5545 :     IEEE_EXCEPTION_TRAP_XI( regs );                         /* IEEE Invalid Exception raised and trappable?         */

  00876	33 c0		 xor	 eax, eax
  00878	83 f8 01	 cmp	 eax, 1
  0087b	74 4b		 je	 SHORT $LN35@s390_divid
  0087d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00882	8b c0		 mov	 eax, eax
  00884	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0088a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00893	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00897	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0089b	83 e0 10	 and	 eax, 16
  0089e	85 c0		 test	 eax, eax
  008a0	74 26		 je	 SHORT $LN35@s390_divid
  008a2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008aa	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  008b0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  008b5	85 c0		 test	 eax, eax
  008b7	74 0f		 je	 SHORT $LN35@s390_divid
  008b9	b2 80		 mov	 dl, 128			; 00000080H
  008bb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008c3	e8 00 00 00 00	 call	 ieee_trap
$LN35@s390_divid:

; 5546 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  008c8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008d0	e8 00 00 00 00	 call	 ieee_exception_test_oux
  008d5	89 44 24 54	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5547 : 
; 5548 :     /* *********** Underflow flag means remainder underflowed.  It has already been scaled if necessary             */
; 5549 : 
; 5550 :     regs->psw.cc = newcc;

  008d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e1	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  008e6	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5551 : 
; 5552 :     PUT_FLOAT32_NOCC( rem, r1, regs );

  008e9	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  008ed	d1 e0		 shl	 eax, 1
  008ef	48 98		 cdqe
  008f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f9	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00901	48 8b d0	 mov	 rdx, rax
  00904	48 8d 4c 24 28	 lea	 rcx, QWORD PTR rem$[rsp]
  00909	e8 00 00 00 00	 call	 s390_put_float32

; 5553 :     PUT_FLOAT32_NOCC( quo, r3, regs );

  0090e	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  00912	d1 e0		 shl	 eax, 1
  00914	48 98		 cdqe
  00916	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0091e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00926	48 8b d0	 mov	 rdx, rax
  00929	48 8d 4c 24 24	 lea	 rcx, QWORD PTR quo$[rsp]
  0092e	e8 00 00 00 00	 call	 s390_put_float32

; 5554 : 
; 5555 :     ieee_cond_trap( regs, ieee_trap_conds );

  00933	8b 54 24 54	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00937	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093f	e8 00 00 00 00	 call	 ieee_cond_trap

; 5556 : }

  00944	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0094b	c3		 ret	 0
s390_divide_integer_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
quo$ = 40
m4$ = 48
rem$ = 56
op1$ = 64
op2$ = 72
temp$1 = 80
op1_data_class$ = 84
op2_data_class$ = 88
r1$ = 92
r2$ = 96
r3$ = 100
tv190 = 104
ieee_trap_conds$ = 108
$T2 = 112
$T3 = 128
$T4 = 144
$T5 = 160
$T6 = 176
$T7 = 192
$T8 = 208
$T9 = 224
$T10 = 240
$T11 = 256
$T12 = 272
$T13 = 288
intquo128$14 = 304
quo128$15 = 320
op1128$16 = 336
op2128$17 = 352
rem128$18 = 368
__$ArrayPad$ = 384
inst$ = 432
regs$ = 440
s390_divide_integer_bfp_long_reg PROC

; 5099 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5100 :     int        r1, r2, r3;
; 5101 :     BYTE       m4, newcc;
; 5102 :     float64_t  op1, op2;
; 5103 :     float64_t  quo, rem;
; 5104 :     U32        ieee_trap_conds = 0;

  00025	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 5105 :     U32        op1_data_class, op2_data_class;
; 5106 : 
; 5107 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  0002d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 60	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 5c	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 30	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	89 44 24 64	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s390_divid:
  0007a	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN8@s390_divid
  0009d	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_divid:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s390_divid

; 5108 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5109 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN10@s390_divid
  000d3	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN9@s390_divid
  000ea	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN9@s390_divid
$LN10@s390_divid:
  00112	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_divid:

; 5110 :     BFPRM_CHECK( m4,regs );

  0013f	0f b6 54 24 30	 movzx	 edx, BYTE PTR m4$[rsp]
  00144	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 5111 : 
; 5112 :     if (r1 == r2 || r2 == r3 || r1 == r3)

  00151	8b 44 24 60	 mov	 eax, DWORD PTR r2$[rsp]
  00155	39 44 24 5c	 cmp	 DWORD PTR r1$[rsp], eax
  00159	74 14		 je	 SHORT $LN12@s390_divid
  0015b	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  0015f	39 44 24 60	 cmp	 DWORD PTR r2$[rsp], eax
  00163	74 0a		 je	 SHORT $LN12@s390_divid
  00165	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  00169	39 44 24 5c	 cmp	 DWORD PTR r1$[rsp], eax
  0016d	75 1b		 jne	 SHORT $LN11@s390_divid
$LN12@s390_divid:

; 5113 :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0016f	ba 06 00 00 00	 mov	 edx, 6
  00174	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017c	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00184	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_divid:
$LN7@s390_divid:

; 5114 : 
; 5115 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  0018a	8b 44 24 5c	 mov	 eax, DWORD PTR r1$[rsp]
  0018e	d1 e0		 shl	 eax, 1
  00190	48 98		 cdqe
  00192	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a2	48 8b d0	 mov	 rdx, rax
  001a5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  001aa	e8 00 00 00 00	 call	 s390_get_float64
  001af	8b 44 24 60	 mov	 eax, DWORD PTR r2$[rsp]
  001b3	d1 e0		 shl	 eax, 1
  001b5	48 98		 cdqe
  001b7	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001c7	48 8b d0	 mov	 rdx, rax
  001ca	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  001cf	e8 00 00 00 00	 call	 s390_get_float64
  001d4	33 c0		 xor	 eax, eax
  001d6	85 c0		 test	 eax, eax
  001d8	75 b0		 jne	 SHORT $LN7@s390_divid

; 5116 : 
; 5117 :     op1_data_class = float64_class( op1 );

  001da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  001df	e8 00 00 00 00	 call	 float64_class
  001e4	89 44 24 54	 mov	 DWORD PTR op1_data_class$[rsp], eax

; 5118 :     op2_data_class = float64_class( op2 );

  001e8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  001ed	e8 00 00 00 00	 call	 float64_class
  001f2	89 44 24 58	 mov	 DWORD PTR op2_data_class$[rsp], eax

; 5119 : 
; 5120 :     softfloat_exceptionFlags = 0;

  001f6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001fb	8b c0		 mov	 eax, eax
  001fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00203	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0020c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00210	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5121 : 
; 5122 :     /************************************************************************************/
; 5123 :     /* Following if / else if / else implements a decision tree based on SA-22-7832-10  */
; 5124 :     /* Table 19-21 parts 1 and 2 on pages 19-29 and 19-30 respectively.                 */
; 5125 :     /*                                                                                  */
; 5126 :     /* ORDER OF TESTS IS IMPORTANT                                                      */
; 5127 :     /*                                                                                  */
; 5128 :     /*  1. Tests for cases that include two non-finite non-zeroes.                      */
; 5129 :     /*  2. Tests for cases that include one or two NaNs as input values                 */
; 5130 :     /*  3. Tests for cases that always generate the default quiet NaN                   */
; 5131 :     /*  4. Tests for cases that generate non-NaN results.                               */
; 5132 :     /*                                                                                  */
; 5133 :     /* When viewed from the perspective of Table 19-21, this order:                     */
; 5134 :     /*                                                                                  */
; 5135 :     /*  1. Addresses what is likely to be the most frequent case first                  */
; 5136 :     /*  2. Removes the bottom two rows and the right-hand two columns                   */
; 5137 :     /*  3. Removes the center two colums and the top and new bottom rows                */
; 5138 :     /*  4. Leaves only those cases that involve returning a zero or operand as a result.*/
; 5139 :     /*                                                                                  */
; 5140 :     /************************************************************************************/
; 5141 : 
; 5142 :     /************************************************************************************/
; 5143 :     /* Group 1: Tests for cases with finite non-zeros for both operands.  This is seen  */
; 5144 :     /* as the most frequent case, and should therefore be tested first.                 */
; 5145 :     /************************************************************************************/
; 5146 : 
; 5147 :                                                                     /* Both operands finite numbers?*/
; 5148 :     if ((op1_data_class & (float_class_neg_normal
; 5149 :                          | float_class_pos_normal
; 5150 :                          | float_class_neg_subnormal
; 5151 :                          | float_class_pos_subnormal))
; 5152 :         &&

  00214	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00218	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  0021d	85 c0		 test	 eax, eax
  0021f	0f 84 1f 07 00
	00		 je	 $LN13@s390_divid
  00225	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00229	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  0022e	85 c0		 test	 eax, eax
  00230	0f 84 0e 07 00
	00		 je	 $LN13@s390_divid

; 5153 :         (op2_data_class & (float_class_neg_normal
; 5154 :                          | float_class_pos_normal
; 5155 :                          | float_class_neg_subnormal
; 5156 :                          | float_class_pos_subnormal))
; 5157 :     )
; 5158 :     {                                                               /* ..yes, we can do division */
; 5159 :         newcc = 0;                                                  /* Initial cc set to zero    */

  00236	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 5160 :         SET_SF_RM_FROM_MASK( m4 );

  0023b	0f b6 44 24 30	 movzx	 eax, BYTE PTR m4$[rsp]
  00240	85 c0		 test	 eax, eax
  00242	74 16		 je	 SHORT $LN37@s390_divid
  00244	0f b6 44 24 30	 movzx	 eax, BYTE PTR m4$[rsp]
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00250	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00254	89 44 24 68	 mov	 DWORD PTR tv190[rsp], eax
  00258	eb 22		 jmp	 SHORT $LN38@s390_divid
$LN37@s390_divid:
  0025a	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00262	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00268	83 e0 07	 and	 eax, 7
  0026b	8b c0		 mov	 eax, eax
  0026d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00274	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00278	89 44 24 68	 mov	 DWORD PTR tv190[rsp], eax
$LN38@s390_divid:
  0027c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00281	8b c0		 mov	 eax, eax
  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00289	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00292	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00296	0f b6 54 24 68	 movzx	 edx, BYTE PTR tv190[rsp]
  0029b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 5161 : 
; 5162 :         quo = f64_div( op1, op2 );                                  /* calculate precise quotient                       */

  0029e	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  002a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  002a8	e8 00 00 00 00	 call	 f64_div
  002ad	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5163 :         quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode            */

  002b2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002b7	8b c0		 mov	 eax, eax
  002b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002bf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002c8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002cc	41 b0 01	 mov	 r8b, 1
  002cf	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  002d8	e8 00 00 00 00	 call	 f64_roundToInt
  002dd	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5164 : 
; 5165 :         softfloat_exceptionFlags &= softfloat_flag_overflow;        /* Quotient only cares about overflow               */

  002e2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e7	8b c0		 mov	 eax, eax
  002e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ef	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00300	83 e0 04	 and	 eax, 4
  00303	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00309	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00312	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00318	45 8b c0	 mov	 r8d, r8d
  0031b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031f	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5166 :         SET_SF_RM_FROM_FPC;                                         /* Set rounding mode from FPC for final remainder   */

  00323	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00331	83 e0 07	 and	 eax, 7
  00334	8b c0		 mov	 eax, eax
  00336	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0033d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00342	8b d2		 mov	 edx, edx
  00344	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0034b	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00354	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00358	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035c	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5167 :         quo.v ^= 0x8000000000000000ULL;                             /* Reverse sign of integer quotient                 */

  00360	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0036a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0036f	48 33 c8	 xor	 rcx, rax
  00372	48 8b c1	 mov	 rax, rcx
  00375	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5168 :         rem = f64_mulAdd( quo, op2, op1 );                          /* Calculate remainder                              */

  0037a	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  0037f	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00384	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00389	e8 00 00 00 00	 call	 f64_mulAdd
  0038e	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5169 :         quo.v ^= 0x8000000000000000ULL;                             /* Return sign of integer quotient to original value*/

  00393	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0039d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  003a2	48 33 c8	 xor	 rcx, rax
  003a5	48 8b c1	 mov	 rax, rcx
  003a8	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5170 : 
; 5171 :         if (!(rem.v & 0x7fffffffffffffffULL))                       /* Is remainder zero?                               */

  003ad	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  003b7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  003bc	48 23 c8	 and	 rcx, rax
  003bf	48 8b c1	 mov	 rax, rcx
  003c2	48 85 c0	 test	 rax, rax
  003c5	75 32		 jne	 SHORT $LN15@s390_divid

; 5172 :             rem.v = (op1.v & 0x8000000000000000ULL) | (rem.v & 0x7fffffffffffffffULL);

  003c7	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  003d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  003d6	48 23 c8	 and	 rcx, rax
  003d9	48 8b c1	 mov	 rax, rcx
  003dc	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  003e6	48 8b 54 24 38	 mov	 rdx, QWORD PTR rem$[rsp]
  003eb	48 23 d1	 and	 rdx, rcx
  003ee	48 8b ca	 mov	 rcx, rdx
  003f1	48 0b c1	 or	 rax, rcx
  003f4	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
$LN15@s390_divid:

; 5173 :                                                                     /* ..yes, ensure remainder sign matches dividend    */
; 5174 :         if (!softfloat_exceptionFlags)                              /* If no exceptions, check for partial results      */

  003f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003fe	8b c0		 mov	 eax, eax
  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00406	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0040f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00413	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00417	85 c0		 test	 eax, eax
  00419	0f 85 42 01 00
	00		 jne	 $LN16@s390_divid

; 5175 :         {
; 5176 :             if (((quo.v & 0x7fffffffffffffffULL) > 0x4340000000000000ULL) && (rem.v & 0x7fffffffffffffffULL))

  0041f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00429	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0042e	48 23 c8	 and	 rcx, rax
  00431	48 8b c1	 mov	 rax, rcx
  00434	48 b9 00 00 00
	00 00 00 40 43	 mov	 rcx, 4845873199050653696 ; 4340000000000000H
  0043e	48 3b c1	 cmp	 rax, rcx
  00441	0f 86 15 01 00
	00		 jbe	 $LN18@s390_divid
  00447	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00451	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  00456	48 23 c8	 and	 rcx, rax
  00459	48 8b c1	 mov	 rax, rcx
  0045c	48 85 c0	 test	 rax, rax
  0045f	0f 84 f7 00 00
	00		 je	 $LN18@s390_divid

; 5177 :             {                                                       /* Quotient > 2^24th & rem <>0?                     */
; 5178 :                 newcc += 2;                                         /* ..yes, indicate partial results in cc            */

  00465	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  0046a	83 c0 02	 add	 eax, 2
  0046d	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5179 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  00471	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00476	8b c0		 mov	 eax, eax
  00478	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0047e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00487	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0048b	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5180 :                                                                     /* ..with rounding toward zero                      */
; 5181 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  0048f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00494	8b c0		 mov	 eax, eax
  00496	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0049c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004a5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004a9	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5182 : 
; 5183 :                 quo = f64_div( op1, op2 );                          /* calculate precise quotient                       */

  004ad	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  004b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  004b7	e8 00 00 00 00	 call	 f64_div
  004bc	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5184 :                 quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  004c1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  004c6	8b c0		 mov	 eax, eax
  004c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004ce	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004d7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004db	41 b0 01	 mov	 r8b, 1
  004de	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  004e2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  004e7	e8 00 00 00 00	 call	 f64_roundToInt
  004ec	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5185 : 
; 5186 :                 quo.v ^= 0x8000000000000000ULL;                     /* Reverse sign of integer quotient                 */

  004f1	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  004fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00500	48 33 c8	 xor	 rcx, rax
  00503	48 8b c1	 mov	 rax, rcx
  00506	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5187 :                 rem = f64_mulAdd( quo, op2, op1 );                  /* Calculate remainder                              */

  0050b	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  00510	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00515	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0051a	e8 00 00 00 00	 call	 f64_mulAdd
  0051f	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5188 :                 quo.v ^= 0x8000000000000000ULL;                     /* Return sign of integer quotient to original value*/

  00524	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0052e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00533	48 33 c8	 xor	 rcx, rax
  00536	48 8b c1	 mov	 rax, rcx
  00539	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5189 :                 softfloat_exceptionFlags = 0;                       /* No exceptions or flags on partial results        */

  0053e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00543	8b c0		 mov	 eax, eax
  00545	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0054b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00554	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00558	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN18@s390_divid:

; 5190 :             }
; 5191 :         }

  0055c	e9 de 03 00 00	 jmp	 $LN17@s390_divid
$LN16@s390_divid:

; 5192 :         else                                                        /* Exception flagged...we have work to do.          */
; 5193 :         {
; 5194 :             if (softfloat_exceptionFlags & softfloat_flag_overflow) /* on oveflow, scale result and set cc=1 or 3       */

  00561	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00566	8b c0		 mov	 eax, eax
  00568	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0056e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00577	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0057b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0057f	83 e0 04	 and	 eax, 4
  00582	85 c0		 test	 eax, eax
  00584	0f 84 6a 03 00
	00		 je	 $LN19@s390_divid

; 5195 :                                                                     /* and recalculate the remainder using a scaled     */
; 5196 :                                                                     /* quotient in 64-bit precision                     */
; 5197 :             {
; 5198 :                 float128_t  quo128, intquo128, rem128;
; 5199 :                 float128_t  op1128, op2128;
; 5200 : 
; 5201 :                 newcc += 1;                                         /* Set condition code odd for quotient overflow     */

  0058a	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  0058f	ff c0		 inc	 eax
  00591	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5202 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  00595	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0059a	8b c0		 mov	 eax, eax
  0059c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005a2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005ab	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005af	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5203 :                                                                     /* ..with rounding toward zero                      */
; 5204 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  005b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  005b8	8b c0		 mov	 eax, eax
  005ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005cd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5205 : 
; 5206 :                 quo = f64_div( op1, op2 );                          /* calculate precise quotient                       */

  005d1	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  005d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  005db	e8 00 00 00 00	 call	 f64_div
  005e0	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5207 :                 quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  005e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  005ea	8b c0		 mov	 eax, eax
  005ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005ff	41 b0 01	 mov	 r8b, 1
  00602	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00606	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0060b	e8 00 00 00 00	 call	 f64_roundToInt
  00610	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5208 :                 quo = f64_scaledResult( SCALE_FACTOR_ARITH_OFLOW_LONG );

  00615	b9 00 fa ff ff	 mov	 ecx, -1536		; fffffffffffffa00H
  0061a	e8 00 00 00 00	 call	 f64_scaledResult
  0061f	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5209 : 
; 5210 :                 op1128 = f64_to_f128( op1 );

  00624	48 8b 54 24 40	 mov	 rdx, QWORD PTR op1$[rsp]
  00629	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00631	e8 00 00 00 00	 call	 f64_to_f128
  00636	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  0063e	48 8b f9	 mov	 rdi, rcx
  00641	48 8b f0	 mov	 rsi, rax
  00644	b9 10 00 00 00	 mov	 ecx, 16
  00649	f3 a4		 rep movsb

; 5211 :                 op2128 = f64_to_f128( op2 );

  0064b	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00650	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  00658	e8 00 00 00 00	 call	 f64_to_f128
  0065d	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  00665	48 8b f9	 mov	 rdi, rcx
  00668	48 8b f0	 mov	 rsi, rax
  0066b	b9 10 00 00 00	 mov	 ecx, 16
  00670	f3 a4		 rep movsb

; 5212 : 
; 5213 :                 softfloat_roundingMode = softfloat_round_minMag;

  00672	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00677	8b c0		 mov	 eax, eax
  00679	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0067f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00688	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0068c	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5214 : 
; 5215 :                 quo128 = f128_div( op1128, op2128 );

  00690	48 8d 44 24 70	 lea	 rax, QWORD PTR $T2[rsp]
  00695	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  0069d	48 8b f8	 mov	 rdi, rax
  006a0	48 8b f1	 mov	 rsi, rcx
  006a3	b9 10 00 00 00	 mov	 ecx, 16
  006a8	f3 a4		 rep movsb
  006aa	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T3[rsp]
  006b2	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  006ba	48 8b f8	 mov	 rdi, rax
  006bd	48 8b f1	 mov	 rsi, rcx
  006c0	b9 10 00 00 00	 mov	 ecx, 16
  006c5	f3 a4		 rep movsb
  006c7	4c 8d 44 24 70	 lea	 r8, QWORD PTR $T2[rsp]
  006cc	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T3[rsp]
  006d4	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  006dc	e8 00 00 00 00	 call	 f128_div
  006e1	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR quo128$15[rsp]
  006e9	48 8b f9	 mov	 rdi, rcx
  006ec	48 8b f0	 mov	 rsi, rax
  006ef	b9 10 00 00 00	 mov	 ecx, 16
  006f4	f3 a4		 rep movsb

; 5216 :                 quo128.v[FLOAT128_LO] &= 0xf000000000000000ULL;     /* truncate to long precision with extended exponent*/

  006f6	b8 08 00 00 00	 mov	 eax, 8
  006fb	48 6b c0 00	 imul	 rax, rax, 0
  006ff	48 b9 00 00 00
	00 00 00 00 f0	 mov	 rcx, -1152921504606846976 ; f000000000000000H
  00709	48 8b 84 04 40
	01 00 00	 mov	 rax, QWORD PTR quo128$15[rsp+rax]
  00711	48 23 c1	 and	 rax, rcx
  00714	b9 08 00 00 00	 mov	 ecx, 8
  00719	48 6b c9 00	 imul	 rcx, rcx, 0
  0071d	48 89 84 0c 40
	01 00 00	 mov	 QWORD PTR quo128$15[rsp+rcx], rax

; 5217 : 
; 5218 :                 intquo128 = f128_roundToInt( quo128, softfloat_round_minMag, FALSE );

  00725	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  0072d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR quo128$15[rsp]
  00735	48 8b f8	 mov	 rdi, rax
  00738	48 8b f1	 mov	 rsi, rcx
  0073b	b9 10 00 00 00	 mov	 ecx, 16
  00740	f3 a4		 rep movsb
  00742	45 33 c9	 xor	 r9d, r9d
  00745	41 b0 01	 mov	 r8b, 1
  00748	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T4[rsp]
  00750	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  00758	e8 00 00 00 00	 call	 f128_roundToInt
  0075d	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR intquo128$14[rsp]
  00765	48 8b f9	 mov	 rdi, rcx
  00768	48 8b f0	 mov	 rsi, rax
  0076b	b9 10 00 00 00	 mov	 ecx, 16
  00770	f3 a4		 rep movsb

; 5219 :                 intquo128.v[FLOAT128_HI] ^= 0x8000000000000000ULL;  /* flip sign of dividend for fused multiply-add     */

  00772	b8 08 00 00 00	 mov	 eax, 8
  00777	48 6b c0 01	 imul	 rax, rax, 1
  0077b	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00785	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR intquo128$14[rsp+rax]
  0078d	48 33 c1	 xor	 rax, rcx
  00790	b9 08 00 00 00	 mov	 ecx, 8
  00795	48 6b c9 01	 imul	 rcx, rcx, 1
  00799	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR intquo128$14[rsp+rcx], rax

; 5220 : 
; 5221 :                 rem128 = f128_mulAdd( intquo128, op2128, op1128 );  /* rem = (-intquo * divisor) + dividend             */

  007a1	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  007a9	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  007b1	48 8b f8	 mov	 rdi, rax
  007b4	48 8b f1	 mov	 rsi, rcx
  007b7	b9 10 00 00 00	 mov	 ecx, 16
  007bc	f3 a4		 rep movsb
  007be	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  007c6	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  007ce	48 8b f8	 mov	 rdi, rax
  007d1	48 8b f1	 mov	 rsi, rcx
  007d4	b9 10 00 00 00	 mov	 ecx, 16
  007d9	f3 a4		 rep movsb
  007db	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  007e3	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR intquo128$14[rsp]
  007eb	48 8b f8	 mov	 rdi, rax
  007ee	48 8b f1	 mov	 rsi, rcx
  007f1	b9 10 00 00 00	 mov	 ecx, 16
  007f6	f3 a4		 rep movsb
  007f8	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR $T5[rsp]
  00800	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR $T6[rsp]
  00808	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  00810	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  00818	e8 00 00 00 00	 call	 f128_mulAdd
  0081d	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR rem128$18[rsp]
  00825	48 8b f9	 mov	 rdi, rcx
  00828	48 8b f0	 mov	 rsi, rax
  0082b	b9 10 00 00 00	 mov	 ecx, 16
  00830	f3 a4		 rep movsb

; 5222 : 
; 5223 :                 intquo128.v[FLOAT128_HI] ^= 0x8000000000000000ULL;  /* Restore sign of dividend                         */

  00832	b8 08 00 00 00	 mov	 eax, 8
  00837	48 6b c0 01	 imul	 rax, rax, 1
  0083b	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00845	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR intquo128$14[rsp+rax]
  0084d	48 33 c1	 xor	 rax, rcx
  00850	b9 08 00 00 00	 mov	 ecx, 8
  00855	48 6b c9 01	 imul	 rcx, rcx, 1
  00859	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR intquo128$14[rsp+rcx], rax

; 5224 :                 softfloat_exceptionFlags = 0;                       /* clear any prior Softfloat flags                  */

  00861	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00866	8b c0		 mov	 eax, eax
  00868	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0086e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00877	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0087b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5225 :                 softfloat_roundingMode = softfloat_round_minMag;    /* round remainder toward zero (but remainder       */

  0087f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00884	8b c0		 mov	 eax, eax
  00886	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0088c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00895	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00899	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5226 : 
; 5227 :                 rem = f128_to_f64( rem128 );                        /* should be exact!?)                               */

  0089d	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  008a5	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR rem128$18[rsp]
  008ad	48 8b f8	 mov	 rdi, rax
  008b0	48 8b f1	 mov	 rsi, rcx
  008b3	b9 10 00 00 00	 mov	 ecx, 16
  008b8	f3 a4		 rep movsb
  008ba	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  008c2	e8 00 00 00 00	 call	 f128_to_f64
  008c7	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5228 : 
; 5229 :                 if (rem.v & 0x7fffffffffffffffULL)                  /* non-zero remainder?                              */

  008cc	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  008d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  008db	48 23 c8	 and	 rcx, rax
  008de	48 8b c1	 mov	 rax, rcx
  008e1	48 85 c0	 test	 rax, rax
  008e4	74 0c		 je	 SHORT $LN21@s390_divid

; 5230 :                     newcc += 2;                                     /* yes, indicate partial results                    */

  008e6	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  008eb	83 c0 02	 add	 eax, 2
  008ee	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al
$LN21@s390_divid:

; 5231 : 
; 5232 :             }

  008f2	eb 4b		 jmp	 SHORT $LN20@s390_divid
$LN19@s390_divid:

; 5233 :             else if (softfloat_exceptionFlags & (softfloat_flag_tiny | softfloat_flag_underflow))

  008f4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  008f9	8b c0		 mov	 eax, eax
  008fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00901	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0090a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0090e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00912	83 e0 42	 and	 eax, 66			; 00000042H
  00915	85 c0		 test	 eax, eax
  00917	74 26		 je	 SHORT $LN22@s390_divid

; 5234 :             {
; 5235 :                 /* Inexact and underflow'ed remainder issues and traps are handled by code at the end of Divide To Integer  */
; 5236 :                 /* But because this is the only situation where the remainder might need scaling, we will do it here        */
; 5237 :                 if (regs->fpc & FPC_MASK_IMU)

  00919	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00921	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00927	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0092c	85 c0		 test	 eax, eax
  0092e	74 0f		 je	 SHORT $LN23@s390_divid

; 5238 :                     rem = f64_scaledResult( SCALE_FACTOR_ARITH_UFLOW_LONG );

  00930	b9 00 06 00 00	 mov	 ecx, 1536		; 00000600H
  00935	e8 00 00 00 00	 call	 f64_scaledResult
  0093a	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
$LN23@s390_divid:
$LN22@s390_divid:
$LN20@s390_divid:
$LN17@s390_divid:

; 5239 :             }
; 5240 :         }
; 5241 :     }

  0093f	e9 f8 01 00 00	 jmp	 $LN14@s390_divid
$LN13@s390_divid:

; 5242 : 
; 5243 :     /************************************************************************************/
; 5244 :     /* Group 2: tests for cases with NaNs for one or both operands                      */
; 5245 :     /* The sequence is required to ensure that the generated results match the IBM NaN  */
; 5246 :     /* propagation rules shown in Table 19-21                                           */
; 5247 :     /************************************************************************************/
; 5248 : 
; 5249 :     /* ******* NEXT FOUR TESTS, ALL GROUP 2 TESTS, MUST REMAIN IN SEQUENCE *******      */
; 5250 :     else if (op1_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* first case: op1 an SNaN?  */

  00944	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00948	83 e0 03	 and	 eax, 3
  0094b	85 c0		 test	 eax, eax
  0094d	74 76		 je	 SHORT $LN24@s390_divid

; 5251 :     {
; 5252 :         quo = op1;

  0094f	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  00954	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5253 :         FLOAT64_MAKE_QNAN( quo );

  00959	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  00963	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00968	48 0b c8	 or	 rcx, rax
  0096b	48 8b c1	 mov	 rax, rcx
  0096e	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5254 :         rem = quo;

  00973	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00978	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5255 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  0097d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00982	8b c0		 mov	 eax, eax
  00984	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0098a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00993	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00997	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0099b	83 c8 10	 or	 eax, 16
  0099e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  009a4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  009ad	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  009b2	8b ff		 mov	 edi, edi
  009b4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  009b8	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5256 :         newcc = 1;                                                                               /* Any NaN returns cc=1      */

  009bb	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5257 :     }

  009c0	e9 77 01 00 00	 jmp	 $LN25@s390_divid
$LN24@s390_divid:

; 5258 :     else if (op2_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* second case: op2 an SNaN? */

  009c5	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  009c9	83 e0 03	 and	 eax, 3
  009cc	85 c0		 test	 eax, eax
  009ce	74 76		 je	 SHORT $LN26@s390_divid

; 5259 :     {
; 5260 :         quo = op2;

  009d0	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  009d5	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5261 :         FLOAT64_MAKE_QNAN( quo );

  009da	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  009e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  009e9	48 0b c8	 or	 rcx, rax
  009ec	48 8b c1	 mov	 rax, rcx
  009ef	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5262 :         rem = quo;

  009f4	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  009f9	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5263 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  009fe	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00a03	8b c0		 mov	 eax, eax
  00a05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00a0b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00a14	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00a18	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a1c	83 c8 10	 or	 eax, 16
  00a1f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00a25	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00a2e	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00a33	8b ff		 mov	 edi, edi
  00a35	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00a39	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5264 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00a3c	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5265 :     }

  00a41	e9 f6 00 00 00	 jmp	 $LN27@s390_divid
$LN26@s390_divid:

; 5266 :     else if (op1_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* third case: op1 a QNaN?    */

  00a46	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00a4a	83 e0 0c	 and	 eax, 12
  00a4d	85 c0		 test	 eax, eax
  00a4f	74 1e		 je	 SHORT $LN28@s390_divid

; 5267 :     {
; 5268 :         rem = quo = op1;

  00a51	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  00a56	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax
  00a5b	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00a60	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5269 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00a65	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5270 :     }

  00a6a	e9 cd 00 00 00	 jmp	 $LN29@s390_divid
$LN28@s390_divid:

; 5271 :     else if (op2_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* fourth case: op2 a QNaN?   */

  00a6f	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00a73	83 e0 0c	 and	 eax, 12
  00a76	85 c0		 test	 eax, eax
  00a78	74 1e		 je	 SHORT $LN30@s390_divid

; 5272 :     {
; 5273 :         rem = quo = op2;

  00a7a	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  00a7f	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax
  00a84	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00a89	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5274 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00a8e	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5275 :     }

  00a93	e9 a4 00 00 00	 jmp	 $LN31@s390_divid
$LN30@s390_divid:

; 5276 :     /* END OF FOUR TESTS THAT MUST REMAIN IN SEQUENCE                                   */
; 5277 : 
; 5278 :     /************************************************************************************/
; 5279 :     /* NEXT TEST MUST FOLLOW ALL FOUR NAN TESTS                                         */
; 5280 :     /* Group 3: Test cases that generate the default NaN and IEEE exception Invalid     */
; 5281 :     /* If operand 1 is an infinity OR operand two is a zero, and none of the above      */
; 5282 :     /* conditions are met, i.e., neither operand is a NaN, return a default NaN         */
; 5283 :     /************************************************************************************/
; 5284 :     else if ((op1_data_class & (float_class_neg_infinity | float_class_pos_infinity))           /* Operand 1 an infinity?             */
; 5285 :          ||  (op2_data_class & (float_class_neg_zero     | float_class_pos_zero))               /* ..or operand 2 a zero?             */

  00a98	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00a9c	83 e0 30	 and	 eax, 48			; 00000030H
  00a9f	85 c0		 test	 eax, eax
  00aa1	75 0d		 jne	 SHORT $LN34@s390_divid
  00aa3	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00aa7	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00aac	85 c0		 test	 eax, eax
  00aae	74 5b		 je	 SHORT $LN32@s390_divid
$LN34@s390_divid:

; 5286 :     )
; 5287 :     {                                                                                           /* ..yes, return DNaN, raise invalid  */
; 5288 :         quo = rem = float64_default_qnan;

  00ab0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR float64_default_qnan
  00ab7	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
  00abc	48 8b 44 24 38	 mov	 rax, QWORD PTR rem$[rsp]
  00ac1	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5289 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  00ac6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00acb	8b c0		 mov	 eax, eax
  00acd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00ad3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00adc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00ae0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ae4	83 c8 10	 or	 eax, 16
  00ae7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00aed	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00af6	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00afb	8b ff		 mov	 edi, edi
  00afd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b01	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5290 :         newcc = 1;

  00b04	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5291 :     }

  00b09	eb 31		 jmp	 SHORT $LN33@s390_divid
$LN32@s390_divid:

; 5292 :     /* ABOVE TEST MUST IMMEDIATELY FOLLOW ALL FOUR NAN TESTS                            */
; 5293 : 
; 5294 :     /************************************************************************************/
; 5295 :     /* Group 4: Tests for cases that generate zero or an operand value as a result.     */
; 5296 :     /*                                                                                  */
; 5297 :     /* At this point, only the remaining operand combinations remain:                   */
; 5298 :     /* - Operand 1 is zero and operand 2 is non-zero (either finite or infinity)        */
; 5299 :     /* - Operand 1 is finite and operand 2 is infinity                                  */
; 5300 :     /*                                                                                  */
; 5301 :     /* The result is the same for each of the above: Operand 1 becomes the remainder,   */
; 5302 :     /* and the quotient is zero with a signed determined by the signs of the operands.  */
; 5303 :     /* Exclusive Or sets the sign correctly.                                            */
; 5304 :     /************************************************************************************/
; 5305 :     else
; 5306 :     {
; 5307 :         rem = op1;                                          /* remainder is operand 1                               */

  00b0b	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  00b10	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5308 :         quo.v = (op1.v ^ op2.v) & 0x8000000000000000ULL;    /* quotient zero, sign is exclusive or of operand signs */

  00b15	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  00b1a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00b1f	48 33 c8	 xor	 rcx, rax
  00b22	48 8b c1	 mov	 rax, rcx
  00b25	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00b2f	48 23 c1	 and	 rax, rcx
  00b32	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5309 :         newcc = 0;

  00b37	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0
$LN33@s390_divid:
$LN31@s390_divid:
$LN29@s390_divid:
$LN27@s390_divid:
$LN25@s390_divid:
$LN14@s390_divid:

; 5310 :     }
; 5311 : 
; 5312 :     IEEE_EXCEPTION_TRAP_XI( regs );                         /* IEEE Invalid Exception raised and trappable?         */

  00b3c	33 c0		 xor	 eax, eax
  00b3e	83 f8 01	 cmp	 eax, 1
  00b41	74 4b		 je	 SHORT $LN35@s390_divid
  00b43	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00b48	8b c0		 mov	 eax, eax
  00b4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00b50	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00b59	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b5d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b61	83 e0 10	 and	 eax, 16
  00b64	85 c0		 test	 eax, eax
  00b66	74 26		 je	 SHORT $LN35@s390_divid
  00b68	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b70	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00b76	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00b7b	85 c0		 test	 eax, eax
  00b7d	74 0f		 je	 SHORT $LN35@s390_divid
  00b7f	b2 80		 mov	 dl, 128			; 00000080H
  00b81	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b89	e8 00 00 00 00	 call	 ieee_trap
$LN35@s390_divid:

; 5313 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00b8e	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b96	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00b9b	89 44 24 6c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5314 : 
; 5315 :     /* *********** Underflow flag means remainder underflowed.  It has already been scaled if necessary             */
; 5316 : 
; 5317 :     regs->psw.cc = newcc;

  00b9f	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba7	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00bac	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5318 : 
; 5319 :     PUT_FLOAT64_NOCC( rem, r1, regs );

  00baf	8b 44 24 5c	 mov	 eax, DWORD PTR r1$[rsp]
  00bb3	d1 e0		 shl	 eax, 1
  00bb5	48 98		 cdqe
  00bb7	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bbf	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00bc7	48 8b d0	 mov	 rdx, rax
  00bca	48 8d 4c 24 38	 lea	 rcx, QWORD PTR rem$[rsp]
  00bcf	e8 00 00 00 00	 call	 s390_put_float64

; 5320 :     PUT_FLOAT64_NOCC( quo, r3, regs );

  00bd4	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  00bd8	d1 e0		 shl	 eax, 1
  00bda	48 98		 cdqe
  00bdc	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00be4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00bec	48 8b d0	 mov	 rdx, rax
  00bef	48 8d 4c 24 28	 lea	 rcx, QWORD PTR quo$[rsp]
  00bf4	e8 00 00 00 00	 call	 s390_put_float64

; 5321 : 
; 5322 :     ieee_cond_trap( regs, ieee_trap_conds );

  00bf9	8b 54 24 6c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00bfd	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c05	e8 00 00 00 00	 call	 ieee_cond_trap

; 5323 : }

  00c0a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c12	48 33 cc	 xor	 rcx, rsp
  00c15	e8 00 00 00 00	 call	 __security_check_cookie
  00c1a	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00c21	5f		 pop	 rdi
  00c22	5e		 pop	 rsi
  00c23	c3		 ret	 0
s390_divide_integer_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv209 = 40
r1$ = 44
ans$ = 48
r2$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s390_divide_bfp_short_reg PROC

; 3047 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3048 :     int        r1, r2;
; 3049 :     float32_t  op1, op2, ans;
; 3050 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3051 : 
; 3052 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_divid:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@s390_divid
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_divid:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_divid

; 3053 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3054 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN10@s390_divid
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN9@s390_divid
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN9@s390_divid
$LN10@s390_divid:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_divid:
$LN7@s390_divid:

; 3055 : 
; 3056 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float32
  00111	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s390_get_float32
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s390_divid

; 3057 : 
; 3058 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3059 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3060 : 
; 3061 :     ans = f32_div( op1, op2 );

  00191	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00195	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  00199	e8 00 00 00 00	 call	 f32_div
  0019e	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 3062 : 
; 3063 :     if (softfloat_exceptionFlags)

  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a7	8b c0		 mov	 eax, eax
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 df 00 00
	00		 je	 $LN11@s390_divid

; 3064 :     {
; 3065 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001c8	33 c0		 xor	 eax, eax
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	74 45		 je	 SHORT $LN12@s390_divid
  001cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d4	8b c0		 mov	 eax, eax
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	83 e0 10	 and	 eax, 16
  001f0	85 c0		 test	 eax, eax
  001f2	74 20		 je	 SHORT $LN12@s390_divid
  001f4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ff	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00204	85 c0		 test	 eax, eax
  00206	74 0c		 je	 SHORT $LN12@s390_divid
  00208	b2 80		 mov	 dl, 128			; 00000080H
  0020a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_divid:

; 3066 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00214	33 c0		 xor	 eax, eax
  00216	83 f8 01	 cmp	 eax, 1
  00219	74 45		 je	 SHORT $LN13@s390_divid
  0021b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00220	8b c0		 mov	 eax, eax
  00222	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00228	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00231	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00235	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00239	83 e0 08	 and	 eax, 8
  0023c	85 c0		 test	 eax, eax
  0023e	74 20		 je	 SHORT $LN13@s390_divid
  00240	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00245	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0024b	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00250	85 c0		 test	 eax, eax
  00252	74 0c		 je	 SHORT $LN13@s390_divid
  00254	b2 40		 mov	 dl, 64			; 00000040H
  00256	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	e8 00 00 00 00	 call	 ieee_trap
$LN13@s390_divid:

; 3067 : 
; 3068 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00260	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0026a	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3069 : 
; 3070 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0026e	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00272	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00277	85 c0		 test	 eax, eax
  00279	74 2c		 je	 SHORT $LN14@s390_divid

; 3071 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0027b	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0027f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00284	85 c0		 test	 eax, eax
  00286	74 0a		 je	 SHORT $LN17@s390_divid
  00288	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv209[rsp], -192 ; ffffffffffffff40H
  00290	eb 08		 jmp	 SHORT $LN18@s390_divid
$LN17@s390_divid:
  00292	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv209[rsp], 192 ; 000000c0H
$LN18@s390_divid:
  0029a	8b 4c 24 28	 mov	 ecx, DWORD PTR tv209[rsp]
  0029e	e8 00 00 00 00	 call	 f32_scaledResult
  002a3	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN14@s390_divid:
$LN11@s390_divid:

; 3072 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 3073 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 3074 :     }
; 3075 : 
; 3076 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  002a7	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002ab	d1 e0		 shl	 eax, 1
  002ad	48 98		 cdqe
  002af	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002b4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002bc	48 8b d0	 mov	 rdx, rax
  002bf	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  002c4	e8 00 00 00 00	 call	 s390_put_float32

; 3077 : 
; 3078 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002c9	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cd	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002d2	85 c0		 test	 eax, eax
  002d4	74 0e		 je	 SHORT $LN15@s390_divid
  002d6	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002da	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	e8 00 00 00 00	 call	 ieee_cond_trap
$LN15@s390_divid:

; 3079 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3080 : }

  002e4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002e8	c3		 ret	 0
s390_divide_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv226 = 52
r1$ = 56
ans$ = 60
op2$ = 64
op1$ = 68
inst$ = 96
regs$ = 104
s390_divide_bfp_short PROC

; 3086 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3087 :     int        r1, x2, b2;
; 3088 :     VADR       effective_addr2;
; 3089 :     float32_t  op1, op2, ans;
; 3090 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3091 : 
; 3092 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s390_divid
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_divid:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s390_divid
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_divid:
  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_divid:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ca	48 83 c0 06	 add	 rax, 6
  000ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 06	 cmp	 eax, 6
  000dc	74 0c		 je	 SHORT $LN7@s390_divid
  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_divid:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 d1		 jne	 SHORT $LN4@s390_divid

; 3093 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3094 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3095 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00105	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $LN9@s390_divid
  0010e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00113	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00119	d1 e8		 shr	 eax, 1
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 49		 je	 SHORT $LN8@s390_divid
  00122	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	48 6b c9 01	 imul	 rcx, rcx, 1
  00137	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0013e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN8@s390_divid
$LN9@s390_divid:
  00147	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00156	ba 07 00 00 00	 mov	 edx, 7
  0015b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00165	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_divid:

; 3096 : 
; 3097 :     GET_FLOAT32_OP( op1, r1, regs );

  0016b	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0016f	d1 e0		 shl	 eax, 1
  00171	48 98		 cdqe
  00173	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00180	48 8b d0	 mov	 rdx, rax
  00183	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op1$[rsp]
  00188	e8 00 00 00 00	 call	 s390_get_float32

; 3098 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0018d	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00192	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00196	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019a	e8 00 00 00 00	 call	 s390_vfetch4
  0019f	89 44 24 40	 mov	 DWORD PTR op2$[rsp], eax

; 3099 : 
; 3100 :     softfloat_exceptionFlags = 0;

  001a3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a8	8b c0		 mov	 eax, eax
  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3101 :     SET_SF_RM_FROM_FPC;

  001c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cc	83 e0 07	 and	 eax, 7
  001cf	8b c0		 mov	 eax, eax
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001dd	8b d2		 mov	 edx, edx
  001df	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001e6	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001ef	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f7	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3102 : 
; 3103 :     ans = f32_div( op1, op2 );

  001fb	8b 54 24 40	 mov	 edx, DWORD PTR op2$[rsp]
  001ff	8b 4c 24 44	 mov	 ecx, DWORD PTR op1$[rsp]
  00203	e8 00 00 00 00	 call	 f32_div
  00208	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax

; 3104 : 
; 3105 :     if (softfloat_exceptionFlags)

  0020c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00211	8b c0		 mov	 eax, eax
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00219	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00222	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00226	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022a	85 c0		 test	 eax, eax
  0022c	0f 84 df 00 00
	00		 je	 $LN10@s390_divid

; 3106 :     {
; 3107 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00232	33 c0		 xor	 eax, eax
  00234	83 f8 01	 cmp	 eax, 1
  00237	74 45		 je	 SHORT $LN11@s390_divid
  00239	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023e	8b c0		 mov	 eax, eax
  00240	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00246	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00253	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00257	83 e0 10	 and	 eax, 16
  0025a	85 c0		 test	 eax, eax
  0025c	74 20		 je	 SHORT $LN11@s390_divid
  0025e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00263	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00269	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0026e	85 c0		 test	 eax, eax
  00270	74 0c		 je	 SHORT $LN11@s390_divid
  00272	b2 80		 mov	 dl, 128			; 00000080H
  00274	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_divid:

; 3108 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  0027e	33 c0		 xor	 eax, eax
  00280	83 f8 01	 cmp	 eax, 1
  00283	74 45		 je	 SHORT $LN12@s390_divid
  00285	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0028a	8b c0		 mov	 eax, eax
  0028c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00292	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a3	83 e0 08	 and	 eax, 8
  002a6	85 c0		 test	 eax, eax
  002a8	74 20		 je	 SHORT $LN12@s390_divid
  002aa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002af	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002b5	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002ba	85 c0		 test	 eax, eax
  002bc	74 0c		 je	 SHORT $LN12@s390_divid
  002be	b2 40		 mov	 dl, 64			; 00000040H
  002c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c5	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_divid:

; 3109 : 
; 3110 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002cf	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002d4	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3111 : 
; 3112 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002d8	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002dc	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002e1	85 c0		 test	 eax, eax
  002e3	74 2c		 je	 SHORT $LN13@s390_divid

; 3113 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002e5	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e9	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002ee	85 c0		 test	 eax, eax
  002f0	74 0a		 je	 SHORT $LN16@s390_divid
  002f2	c7 44 24 34 40
	ff ff ff	 mov	 DWORD PTR tv226[rsp], -192 ; ffffffffffffff40H
  002fa	eb 08		 jmp	 SHORT $LN17@s390_divid
$LN16@s390_divid:
  002fc	c7 44 24 34 c0
	00 00 00	 mov	 DWORD PTR tv226[rsp], 192 ; 000000c0H
$LN17@s390_divid:
  00304	8b 4c 24 34	 mov	 ecx, DWORD PTR tv226[rsp]
  00308	e8 00 00 00 00	 call	 f32_scaledResult
  0030d	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax
$LN13@s390_divid:
$LN10@s390_divid:

; 3114 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 3115 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 3116 :     }
; 3117 : 
; 3118 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  00311	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00315	d1 e0		 shl	 eax, 1
  00317	48 98		 cdqe
  00319	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00326	48 8b d0	 mov	 rdx, rax
  00329	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR ans$[rsp]
  0032e	e8 00 00 00 00	 call	 s390_put_float32

; 3119 : 
; 3120 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00333	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00337	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0033c	85 c0		 test	 eax, eax
  0033e	74 0e		 je	 SHORT $LN14@s390_divid
  00340	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00344	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00349	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s390_divid:

; 3121 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3122 : }

  0034e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00352	c3		 ret	 0
s390_divide_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv209 = 40
r1$ = 44
r2$ = 48
ans$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
s390_divide_bfp_long_reg PROC

; 2965 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2966 :     int        r1, r2;
; 2967 :     float64_t  op1, op2, ans;
; 2968 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2969 : 
; 2970 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_divid:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@s390_divid
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_divid:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_divid

; 2971 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2972 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN10@s390_divid
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN9@s390_divid
  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN9@s390_divid
$LN10@s390_divid:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_divid:
$LN7@s390_divid:

; 2973 : 
; 2974 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float64
  00111	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s390_get_float64
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s390_divid

; 2975 : 
; 2976 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2977 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 2978 : 
; 2979 :     ans = f64_div( op1, op2 );

  00191	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00196	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 f64_div
  001a0	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 2980 : 
; 2981 :     if (softfloat_exceptionFlags)

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 e0 00 00
	00		 je	 $LN11@s390_divid

; 2982 :     {
; 2983 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001cb	33 c0		 xor	 eax, eax
  001cd	83 f8 01	 cmp	 eax, 1
  001d0	74 45		 je	 SHORT $LN12@s390_divid
  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	83 e0 10	 and	 eax, 16
  001f3	85 c0		 test	 eax, eax
  001f5	74 20		 je	 SHORT $LN12@s390_divid
  001f7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00202	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00207	85 c0		 test	 eax, eax
  00209	74 0c		 je	 SHORT $LN12@s390_divid
  0020b	b2 80		 mov	 dl, 128			; 00000080H
  0020d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_divid:

; 2984 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00217	33 c0		 xor	 eax, eax
  00219	83 f8 01	 cmp	 eax, 1
  0021c	74 45		 je	 SHORT $LN13@s390_divid
  0021e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00223	8b c0		 mov	 eax, eax
  00225	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00234	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00238	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023c	83 e0 08	 and	 eax, 8
  0023f	85 c0		 test	 eax, eax
  00241	74 20		 je	 SHORT $LN13@s390_divid
  00243	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00248	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0024e	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00253	85 c0		 test	 eax, eax
  00255	74 0c		 je	 SHORT $LN13@s390_divid
  00257	b2 40		 mov	 dl, 64			; 00000040H
  00259	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	e8 00 00 00 00	 call	 ieee_trap
$LN13@s390_divid:

; 2985 : 
; 2986 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0026d	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2987 : 
; 2988 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00271	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00275	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0027a	85 c0		 test	 eax, eax
  0027c	74 2d		 je	 SHORT $LN14@s390_divid

; 2989 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0027e	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00282	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00287	85 c0		 test	 eax, eax
  00289	74 0a		 je	 SHORT $LN17@s390_divid
  0028b	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv209[rsp], -1536 ; fffffffffffffa00H
  00293	eb 08		 jmp	 SHORT $LN18@s390_divid
$LN17@s390_divid:
  00295	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv209[rsp], 1536 ; 00000600H
$LN18@s390_divid:
  0029d	8b 4c 24 28	 mov	 ecx, DWORD PTR tv209[rsp]
  002a1	e8 00 00 00 00	 call	 f64_scaledResult
  002a6	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN14@s390_divid:
$LN11@s390_divid:

; 2990 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 2991 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 2992 :     }
; 2993 : 
; 2994 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  002ab	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002af	d1 e0		 shl	 eax, 1
  002b1	48 98		 cdqe
  002b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002b8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002c0	48 8b d0	 mov	 rdx, rax
  002c3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  002c8	e8 00 00 00 00	 call	 s390_put_float64

; 2995 : 
; 2996 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002cd	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002d1	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002d6	85 c0		 test	 eax, eax
  002d8	74 0e		 je	 SHORT $LN15@s390_divid
  002da	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN15@s390_divid:

; 2997 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 2998 : }

  002e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002ec	c3		 ret	 0
s390_divide_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv226 = 52
r1$ = 56
ans$ = 64
op2$ = 72
op1$ = 80
inst$ = 112
regs$ = 120
s390_divide_bfp_long PROC

; 3004 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3005 :     int        r1, x2, b2;
; 3006 :     VADR       effective_addr2;
; 3007 :     float64_t  op1, op2, ans;
; 3008 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3009 : 
; 3010 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s390_divid
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_divid:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s390_divid
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_divid:
  000aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_divid:
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ca	48 83 c0 06	 add	 rax, 6
  000ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 06	 cmp	 eax, 6
  000dc	74 0c		 je	 SHORT $LN7@s390_divid
  000de	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_divid:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 d1		 jne	 SHORT $LN4@s390_divid

; 3011 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3012 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3013 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00105	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $LN9@s390_divid
  0010e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00113	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00119	d1 e8		 shr	 eax, 1
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 49		 je	 SHORT $LN8@s390_divid
  00122	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	48 6b c9 01	 imul	 rcx, rcx, 1
  00137	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0013e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN8@s390_divid
$LN9@s390_divid:
  00147	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00156	ba 07 00 00 00	 mov	 edx, 7
  0015b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00165	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_divid:

; 3014 : 
; 3015 :     GET_FLOAT64_OP( op1, r1, regs );

  0016b	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0016f	d1 e0		 shl	 eax, 1
  00171	48 98		 cdqe
  00173	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00180	48 8b d0	 mov	 rdx, rax
  00183	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  00188	e8 00 00 00 00	 call	 s390_get_float64

; 3016 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0018d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00192	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00196	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019a	e8 00 00 00 00	 call	 s390_vfetch8
  0019f	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 3017 : 
; 3018 :     softfloat_exceptionFlags = 0;

  001a4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a9	8b c0		 mov	 eax, eax
  001ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ba	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001be	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3019 :     SET_SF_RM_FROM_FPC;

  001c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cd	83 e0 07	 and	 eax, 7
  001d0	8b c0		 mov	 eax, eax
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001de	8b d2		 mov	 edx, edx
  001e0	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001e7	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001f0	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f8	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3020 : 
; 3021 :     ans = f64_div( op1, op2 );

  001fc	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00201	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op1$[rsp]
  00206	e8 00 00 00 00	 call	 f64_div
  0020b	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 3022 : 
; 3023 :     if (softfloat_exceptionFlags)

  00210	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00215	8b c0		 mov	 eax, eax
  00217	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00226	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0022a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022e	85 c0		 test	 eax, eax
  00230	0f 84 e0 00 00
	00		 je	 $LN10@s390_divid

; 3024 :     {
; 3025 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00236	33 c0		 xor	 eax, eax
  00238	83 f8 01	 cmp	 eax, 1
  0023b	74 45		 je	 SHORT $LN11@s390_divid
  0023d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00242	8b c0		 mov	 eax, eax
  00244	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0024a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00253	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00257	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025b	83 e0 10	 and	 eax, 16
  0025e	85 c0		 test	 eax, eax
  00260	74 20		 je	 SHORT $LN11@s390_divid
  00262	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00267	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0026d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00272	85 c0		 test	 eax, eax
  00274	74 0c		 je	 SHORT $LN11@s390_divid
  00276	b2 80		 mov	 dl, 128			; 00000080H
  00278	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_divid:

; 3026 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00282	33 c0		 xor	 eax, eax
  00284	83 f8 01	 cmp	 eax, 1
  00287	74 45		 je	 SHORT $LN12@s390_divid
  00289	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0028e	8b c0		 mov	 eax, eax
  00290	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00296	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a7	83 e0 08	 and	 eax, 8
  002aa	85 c0		 test	 eax, eax
  002ac	74 20		 je	 SHORT $LN12@s390_divid
  002ae	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002b3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002b9	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002be	85 c0		 test	 eax, eax
  002c0	74 0c		 je	 SHORT $LN12@s390_divid
  002c2	b2 40		 mov	 dl, 64			; 00000040H
  002c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	e8 00 00 00 00	 call	 ieee_trap
$LN12@s390_divid:

; 3027 : 
; 3028 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002d8	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3029 : 
; 3030 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002dc	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002e5	85 c0		 test	 eax, eax
  002e7	74 2d		 je	 SHORT $LN13@s390_divid

; 3031 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002e9	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ed	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002f2	85 c0		 test	 eax, eax
  002f4	74 0a		 je	 SHORT $LN16@s390_divid
  002f6	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv226[rsp], -1536 ; fffffffffffffa00H
  002fe	eb 08		 jmp	 SHORT $LN17@s390_divid
$LN16@s390_divid:
  00300	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv226[rsp], 1536 ; 00000600H
$LN17@s390_divid:
  00308	8b 4c 24 34	 mov	 ecx, DWORD PTR tv226[rsp]
  0030c	e8 00 00 00 00	 call	 f64_scaledResult
  00311	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN13@s390_divid:
$LN10@s390_divid:

; 3032 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 3033 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 3034 :     }
; 3035 : 
; 3036 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00316	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0031a	d1 e0		 shl	 eax, 1
  0031c	48 98		 cdqe
  0031e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00323	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0032b	48 8b d0	 mov	 rdx, rax
  0032e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  00333	e8 00 00 00 00	 call	 s390_put_float64

; 3037 : 
; 3038 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00338	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0033c	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00341	85 c0		 test	 eax, eax
  00343	74 0e		 je	 SHORT $LN14@s390_divid
  00345	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00349	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0034e	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s390_divid:

; 3039 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3040 : }

  00353	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00357	c3		 ret	 0
s390_divide_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv218 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
ans$ = 128
op2$ = 144
op1$ = 160
__$ArrayPad$ = 176
inst$ = 224
regs$ = 232
s390_divide_bfp_ext_reg PROC

; 2925 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2926 :     int         r1, r2;
; 2927 :     float128_t  op1, op2, ans;
; 2928 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2929 : 
; 2930 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_divid:
  0005f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN8@s390_divid
  00082	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_divid:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@s390_divid

; 2931 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2932 :     BFPINST_CHECK( regs );

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 3f		 je	 SHORT $LN10@s390_divid
  000b8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c6	d1 e8		 shr	 eax, 1
  000c8	83 e0 01	 and	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 55		 je	 SHORT $LN9@s390_divid
  000cf	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	b9 08 00 00 00	 mov	 ecx, 8
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ee	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f3	85 c0		 test	 eax, eax
  000f5	75 2d		 jne	 SHORT $LN9@s390_divid
$LN10@s390_divid:
  000f7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00109	ba 07 00 00 00	 mov	 edx, 7
  0010e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_divid:

; 2933 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00124	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN12@s390_divid
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 02	 and	 eax, 2
  00136	85 c0		 test	 eax, eax
  00138	74 1b		 je	 SHORT $LN11@s390_divid
$LN12@s390_divid:
  0013a	ba 06 00 00 00	 mov	 edx, 6
  0013f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_divid:
$LN7@s390_divid:

; 2934 : 
; 2935 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  00155	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00159	d1 e0		 shl	 eax, 1
  0015b	48 98		 cdqe
  0015d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00178	e8 00 00 00 00	 call	 s390_get_float128
  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00181	d1 e0		 shl	 eax, 1
  00183	48 98		 cdqe
  00185	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001a0	e8 00 00 00 00	 call	 s390_get_float128
  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 aa		 jne	 SHORT $LN7@s390_divid

; 2936 : 
; 2937 :     softfloat_exceptionFlags = 0;

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b0	8b c0		 mov	 eax, eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2938 :     SET_SF_RM_FROM_FPC;

  001c9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d7	83 e0 07	 and	 eax, 7
  001da	8b c0		 mov	 eax, eax
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001e8	8b d2		 mov	 edx, edx
  001ea	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001f1	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001fa	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00202	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 2939 : 
; 2940 :     ans = f128_div( op1, op2 );

  00206	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0020b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  00213	48 8b f8	 mov	 rdi, rax
  00216	48 8b f1	 mov	 rsi, rcx
  00219	b9 10 00 00 00	 mov	 ecx, 16
  0021e	f3 a4		 rep movsb
  00220	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00225	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  0022d	48 8b f8	 mov	 rdi, rax
  00230	48 8b f1	 mov	 rsi, rcx
  00233	b9 10 00 00 00	 mov	 ecx, 16
  00238	f3 a4		 rep movsb
  0023a	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  0023f	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  00244	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  00249	e8 00 00 00 00	 call	 f128_div
  0024e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00256	48 8b f9	 mov	 rdi, rcx
  00259	48 8b f0	 mov	 rsi, rax
  0025c	b9 10 00 00 00	 mov	 ecx, 16
  00261	f3 a4		 rep movsb

; 2941 : 
; 2942 :     if (softfloat_exceptionFlags)

  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	85 c0		 test	 eax, eax
  00283	0f 84 04 01 00
	00		 je	 $LN13@s390_divid

; 2943 :     {
; 2944 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00289	33 c0		 xor	 eax, eax
  0028b	83 f8 01	 cmp	 eax, 1
  0028e	74 4b		 je	 SHORT $LN14@s390_divid
  00290	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00295	8b c0		 mov	 eax, eax
  00297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ae	83 e0 10	 and	 eax, 16
  002b1	85 c0		 test	 eax, eax
  002b3	74 26		 je	 SHORT $LN14@s390_divid
  002b5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002c8	85 c0		 test	 eax, eax
  002ca	74 0f		 je	 SHORT $LN14@s390_divid
  002cc	b2 80		 mov	 dl, 128			; 00000080H
  002ce	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_divid:

; 2945 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  002db	33 c0		 xor	 eax, eax
  002dd	83 f8 01	 cmp	 eax, 1
  002e0	74 4b		 je	 SHORT $LN15@s390_divid
  002e2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e7	8b c0		 mov	 eax, eax
  002e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ef	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00300	83 e0 08	 and	 eax, 8
  00303	85 c0		 test	 eax, eax
  00305	74 26		 je	 SHORT $LN15@s390_divid
  00307	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00315	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0031a	85 c0		 test	 eax, eax
  0031c	74 0f		 je	 SHORT $LN15@s390_divid
  0031e	b2 40		 mov	 dl, 64			; 00000040H
  00320	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00328	e8 00 00 00 00	 call	 ieee_trap
$LN15@s390_divid:

; 2946 : 
; 2947 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0032d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00335	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0033a	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2948 : 
; 2949 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0033e	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00342	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00347	85 c0		 test	 eax, eax
  00349	74 42		 je	 SHORT $LN16@s390_divid

; 2950 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0034b	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0034f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00354	85 c0		 test	 eax, eax
  00356	74 0a		 je	 SHORT $LN19@s390_divid
  00358	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv218[rsp], -24576 ; ffffffffffffa000H
  00360	eb 08		 jmp	 SHORT $LN20@s390_divid
$LN19@s390_divid:
  00362	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv218[rsp], 24576 ; 00006000H
$LN20@s390_divid:
  0036a	8b 54 24 30	 mov	 edx, DWORD PTR tv218[rsp]
  0036e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  00373	e8 00 00 00 00	 call	 f128_scaledResult
  00378	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00380	48 8b f9	 mov	 rdi, rcx
  00383	48 8b f0	 mov	 rsi, rax
  00386	b9 10 00 00 00	 mov	 ecx, 16
  0038b	f3 a4		 rep movsb
$LN16@s390_divid:
$LN13@s390_divid:

; 2951 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 2952 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 2953 :     }
; 2954 : 
; 2955 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  0038d	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00391	d1 e0		 shl	 eax, 1
  00393	48 98		 cdqe
  00395	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003a5	48 8b d0	 mov	 rdx, rax
  003a8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  003b0	e8 00 00 00 00	 call	 s390_put_float128

; 2956 : 
; 2957 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003b5	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003b9	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003be	85 c0		 test	 eax, eax
  003c0	74 11		 je	 SHORT $LN17@s390_divid
  003c2	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003c6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ce	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s390_divid:

; 2958 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 2959 : }

  003d3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003db	48 33 cc	 xor	 rcx, rsp
  003de	e8 00 00 00 00	 call	 __security_check_cookie
  003e3	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  003ea	5f		 pop	 rdi
  003eb	5e		 pop	 rsi
  003ec	c3		 ret	 0
s390_divide_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv161 = 44
r2$ = 48
op2$ = 52
r1$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s390_convert_fix32_to_bfp_short_reg PROC

; 1743 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1744 :     int        r1, r2;
; 1745 :     BYTE       m3, m4;
; 1746 :     S32        op2;
; 1747 :     float32_t  op1;
; 1748 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1749 : 
; 1750 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_conve:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s390_conve
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s390_conve

; 1751 : 
; 1752 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1753 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s390_conve
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s390_conve
  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_conve:

; 1754 : 
; 1755 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1756 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 1757 :         BFPRM_CHECK( m3, regs );
; 1758 :     else
; 1759 : #endif
; 1760 :     {
; 1761 :         if (m3 | m4)

  0010a	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0010f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  00114	0b c1		 or	 eax, ecx
  00116	85 c0		 test	 eax, eax
  00118	74 15		 je	 SHORT $LN8@s390_conve

; 1762 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0011a	ba 06 00 00 00	 mov	 edx, 6
  0011f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00129	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_conve:

; 1763 :     }
; 1764 : 
; 1765 :     SET_SF_RM_FROM_MASK( m3 );

  0012f	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00134	85 c0		 test	 eax, eax
  00136	74 16		 je	 SHORT $LN12@s390_conve
  00138	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00144	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00148	89 44 24 2c	 mov	 DWORD PTR tv161[rsp], eax
  0014c	eb 1f		 jmp	 SHORT $LN13@s390_conve
$LN12@s390_conve:
  0014e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00153	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00159	83 e0 07	 and	 eax, 7
  0015c	8b c0		 mov	 eax, eax
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00165	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00169	89 44 24 2c	 mov	 DWORD PTR tv161[rsp], eax
$LN13@s390_conve:
  0016d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00172	8b c0		 mov	 eax, eax
  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0017a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00183	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00187	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv161[rsp]
  0018c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1766 :     op2 = regs->GR_L( r2 );

  0018f	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00194	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001a0	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 1767 :     softfloat_exceptionFlags = 0;

  001a4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a9	8b c0		 mov	 eax, eax
  001ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ba	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001be	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1768 :     op1 = i32_to_f32( op2 );

  001c2	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  001c6	e8 00 00 00 00	 call	 i32_to_f32
  001cb	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 1769 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  001cf	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001d3	d1 e0		 shl	 eax, 1
  001d5	48 98		 cdqe
  001d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001dc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001e4	48 8b d0	 mov	 rdx, rax
  001e7	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  001ec	e8 00 00 00 00	 call	 s390_put_float32

; 1770 : 
; 1771 :     /* Inexact occurred and not masked by m4? */
; 1772 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  001f1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f6	8b c0		 mov	 eax, eax
  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001fe	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00207	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	85 c0		 test	 eax, eax
  00211	74 35		 je	 SHORT $LN9@s390_conve
  00213	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00218	83 e0 04	 and	 eax, 4
  0021b	85 c0		 test	 eax, eax
  0021d	75 29		 jne	 SHORT $LN9@s390_conve

; 1773 :     {
; 1774 :         /* Yes, set FPC flags and test for a trap */
; 1775 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0021f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00224	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00229	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1776 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0022d	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00231	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00236	85 c0		 test	 eax, eax
  00238	74 0e		 je	 SHORT $LN10@s390_conve
  0023a	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0023e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00243	e8 00 00 00 00	 call	 ieee_cond_trap
$LN10@s390_conve:
$LN9@s390_conve:

; 1777 :     }
; 1778 : }

  00248	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0024c	c3		 ret	 0
s390_convert_fix32_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
tv161 = 40
r2$ = 44
op2$ = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s390_convert_fix32_to_bfp_long_reg PROC

; 1705 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1706 :     int        r1, r2;
; 1707 :     BYTE       m3, m4;
; 1708 :     S32        op2;
; 1709 :     float64_t  op1;
; 1710 : 
; 1711 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 08	 shr	 eax, 8
  00043	83 e0 0f	 and	 eax, 15
  00046	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 0c	 shr	 eax, 12
  00051	83 e0 0f	 and	 eax, 15
  00054	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_conve:
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 04	 cmp	 eax, 4
  00073	74 0c		 je	 SHORT $LN5@s390_conve
  00075	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 d1		 jne	 SHORT $LN4@s390_conve

; 1712 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1713 :     BFPINST_CHECK( regs );

  00087	b8 08 00 00 00	 mov	 eax, 8
  0008c	48 6b c0 01	 imul	 rax, rax, 1
  00090	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00095	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0009c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a1	85 c0		 test	 eax, eax
  000a3	74 39		 je	 SHORT $LN7@s390_conve
  000a5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b0	d1 e8		 shr	 eax, 1
  000b2	83 e0 01	 and	 eax, 1
  000b5	85 c0		 test	 eax, eax
  000b7	74 49		 je	 SHORT $LN6@s390_conve
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000c5	b9 08 00 00 00	 mov	 ecx, 8
  000ca	48 6b c9 01	 imul	 rcx, rcx, 1
  000ce	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000d5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000da	85 c0		 test	 eax, eax
  000dc	75 24		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  000de	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000ed	ba 07 00 00 00	 mov	 edx, 7
  000f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_conve:

; 1714 : 
; 1715 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1716 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 1717 :         BFPRM_CHECK( m3, regs );
; 1718 :     else
; 1719 : #endif
; 1720 :     {
; 1721 :         if (m3 | m4)

  00102	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00107	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  0010c	0b c1		 or	 eax, ecx
  0010e	85 c0		 test	 eax, eax
  00110	74 15		 je	 SHORT $LN8@s390_conve

; 1722 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00112	ba 06 00 00 00	 mov	 edx, 6
  00117	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_conve:

; 1723 :     }
; 1724 : 
; 1725 :     SET_SF_RM_FROM_MASK( m3 );

  00127	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0012c	85 c0		 test	 eax, eax
  0012e	74 16		 je	 SHORT $LN10@s390_conve
  00130	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0013c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00140	89 44 24 28	 mov	 DWORD PTR tv161[rsp], eax
  00144	eb 1f		 jmp	 SHORT $LN11@s390_conve
$LN10@s390_conve:
  00146	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00151	83 e0 07	 and	 eax, 7
  00154	8b c0		 mov	 eax, eax
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0015d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00161	89 44 24 28	 mov	 DWORD PTR tv161[rsp], eax
$LN11@s390_conve:
  00165	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0016a	8b c0		 mov	 eax, eax
  0016c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00172	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0017f	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv161[rsp]
  00184	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1726 :     op2 = regs->GR_L( r2 );

  00187	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0018c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00191	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00198	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 1727 :     softfloat_exceptionFlags = 0;

  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a1	8b c0		 mov	 eax, eax
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1728 :     op1 = i32_to_f64( op2 );

  001ba	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  001be	e8 00 00 00 00	 call	 i32_to_f64
  001c3	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 1729 : 
; 1730 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  001c8	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  001cc	d1 e0		 shl	 eax, 1
  001ce	48 98		 cdqe
  001d0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d5	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001dd	48 8b d0	 mov	 rdx, rax
  001e0	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  001e5	e8 00 00 00 00	 call	 s390_put_float64

; 1731 : }

  001ea	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ee	c3		 ret	 0
s390_convert_fix32_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
tv171 = 40
r1$ = 44
r2$ = 48
op2$ = 52
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
s390_convert_fix32_to_bfp_ext_reg PROC

; 1669 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1670 :     int         r1, r2;
; 1671 :     BYTE        m3, m4;
; 1672 :     S32         op2;
; 1673 :     float128_t  op1;
; 1674 : 
; 1675 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 04	 shr	 eax, 4
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 08	 shr	 eax, 8
  00057	83 e0 0f	 and	 eax, 15
  0005a	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 0c	 shr	 eax, 12
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_conve:
  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00088	33 c0		 xor	 eax, eax
  0008a	83 f8 04	 cmp	 eax, 4
  0008d	74 0f		 je	 SHORT $LN5@s390_conve
  0008f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 c8		 jne	 SHORT $LN4@s390_conve

; 1676 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1677 :     BFPINST_CHECK( regs );

  000a4	b8 08 00 00 00	 mov	 eax, 8
  000a9	48 6b c0 01	 imul	 rax, rax, 1
  000ad	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000bc	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c1	85 c0		 test	 eax, eax
  000c3	74 3f		 je	 SHORT $LN7@s390_conve
  000c5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d3	d1 e8		 shr	 eax, 1
  000d5	83 e0 01	 and	 eax, 1
  000d8	85 c0		 test	 eax, eax
  000da	74 55		 je	 SHORT $LN6@s390_conve
  000dc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000eb	b9 08 00 00 00	 mov	 ecx, 8
  000f0	48 6b c9 01	 imul	 rcx, rcx, 1
  000f4	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	75 2d		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00116	ba 07 00 00 00	 mov	 edx, 7
  0011b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_conve:

; 1678 :     BFPREGPAIR_CHECK( r1, regs );

  00131	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00135	83 e0 02	 and	 eax, 2
  00138	85 c0		 test	 eax, eax
  0013a	74 1b		 je	 SHORT $LN8@s390_conve
  0013c	ba 06 00 00 00	 mov	 edx, 6
  00141	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00149	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00151	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_conve:

; 1679 : 
; 1680 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1681 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 1682 :         BFPRM_CHECK( m3, regs );
; 1683 :     else
; 1684 : #endif
; 1685 :     {
; 1686 :         if (m3 | m4)

  00157	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0015c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  00161	0b c1		 or	 eax, ecx
  00163	85 c0		 test	 eax, eax
  00165	74 1b		 je	 SHORT $LN9@s390_conve

; 1687 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00167	ba 06 00 00 00	 mov	 edx, 6
  0016c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_conve:

; 1688 :     }
; 1689 : 
; 1690 :     op2 = regs->GR_L( r2 );

  00182	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00187	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00196	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 1691 :     SET_SF_RM_FROM_MASK( m3 );

  0019a	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0019f	85 c0		 test	 eax, eax
  001a1	74 16		 je	 SHORT $LN11@s390_conve
  001a3	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001af	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b3	89 44 24 28	 mov	 DWORD PTR tv171[rsp], eax
  001b7	eb 22		 jmp	 SHORT $LN12@s390_conve
$LN11@s390_conve:
  001b9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c7	83 e0 07	 and	 eax, 7
  001ca	8b c0		 mov	 eax, eax
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d7	89 44 24 28	 mov	 DWORD PTR tv171[rsp], eax
$LN12@s390_conve:
  001db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001e0	8b c0		 mov	 eax, eax
  001e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f5	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv171[rsp]
  001fa	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1692 :     softfloat_exceptionFlags = 0;

  001fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00202	8b c0		 mov	 eax, eax
  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00213	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00217	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1693 :     op1 = i32_to_f128( op2 );

  0021b	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0021f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  00224	e8 00 00 00 00	 call	 i32_to_f128
  00229	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0022e	48 8b f9	 mov	 rdi, rcx
  00231	48 8b f0	 mov	 rsi, rax
  00234	b9 10 00 00 00	 mov	 ecx, 16
  00239	f3 a4		 rep movsb

; 1694 : 
; 1695 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0023b	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0023f	d1 e0		 shl	 eax, 1
  00241	48 98		 cdqe
  00243	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00253	48 8b d0	 mov	 rdx, rax
  00256	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0025b	e8 00 00 00 00	 call	 s390_put_float128

; 1696 : }

  00260	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00265	48 33 cc	 xor	 rcx, rsp
  00268	e8 00 00 00 00	 call	 __security_check_cookie
  0026d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00271	5f		 pop	 rdi
  00272	5e		 pop	 rsi
  00273	c3		 ret	 0
s390_convert_fix32_to_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
op2$ = 48
ieee_trap_conds$ = 52
tv174 = 56
tv196 = 60
tv202 = 64
r2$ = 68
r1$ = 72
inst$ = 96
regs$ = 104
s390_convert_bfp_short_to_fix32_reg PROC

; 2098 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2099 :     int        r1, r2;
; 2100 :     BYTE       m3, m4, newcc;
; 2101 :     S32        op1;
; 2102 :     float32_t  op2;
; 2103 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2104 :     U32        op2_dataclass;
; 2105 : 
; 2106 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s390_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s390_conve

; 2107 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2108 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s390_conve
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s390_conve
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_conve:

; 2109 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 2110 : 
; 2111 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2112 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 2113 : #endif
; 2114 :         m4 = 0;

  00119	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0

; 2115 : 
; 2116 :     GET_FLOAT32_OP( op2, r2, regs );

  0011e	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_get_float32

; 2117 :     op2_dataclass = float32_class( op2 );

  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  00144	e8 00 00 00 00	 call	 float32_class
  00149	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2118 :     softfloat_exceptionFlags = 0;

  0014d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00152	8b c0		 mov	 eax, eax
  00154	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0015a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00163	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00167	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2119 : 
; 2120 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  0016b	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0016f	83 e0 0f	 and	 eax, 15
  00172	85 c0		 test	 eax, eax
  00174	74 53		 je	 SHORT $LN8@s390_conve

; 2121 :                          float_class_pos_signaling_nan |
; 2122 :                          float_class_neg_quiet_nan     |
; 2123 :                          float_class_pos_quiet_nan ))
; 2124 :     {
; 2125 :         /* NaN input always returns maximum negative integer,
; 2126 :            cc3, and IEEE invalid exception */
; 2127 :         op1 = -0x7FFFFFFF - 1;

  00176	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 2128 :         newcc = 3;

  0017e	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2129 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00183	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00188	8b c0		 mov	 eax, eax
  0018a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00190	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00199	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0019d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a1	83 c8 10	 or	 eax, 16
  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001aa	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b3	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  001b9	45 8b c0	 mov	 r8d, r8d
  001bc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c0	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2130 :     }

  001c4	e9 10 01 00 00	 jmp	 $LN9@s390_conve
$LN8@s390_conve:

; 2131 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  001c9	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  001cd	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  001d2	85 c0		 test	 eax, eax
  001d4	74 12		 je	 SHORT $LN10@s390_conve

; 2132 :     {
; 2133 :         newcc = 0;

  001d6	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2134 :         op1 = 0;

  001db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2135 :     }

  001e3	e9 f1 00 00 00	 jmp	 $LN11@s390_conve
$LN10@s390_conve:

; 2136 :     else
; 2137 :     {
; 2138 :         newcc = (op2.v & 0x80000000) ? 1 : 2;

  001e8	8b 44 24 30	 mov	 eax, DWORD PTR op2$[rsp]
  001ec	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001f1	85 c0		 test	 eax, eax
  001f3	74 0a		 je	 SHORT $LN19@s390_conve
  001f5	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  001fd	eb 08		 jmp	 SHORT $LN20@s390_conve
$LN19@s390_conve:
  001ff	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN20@s390_conve:
  00207	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv174[rsp]
  0020c	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2139 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  00210	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00214	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00219	85 c0		 test	 eax, eax
  0021b	74 0d		 je	 SHORT $LN12@s390_conve

; 2140 :             op1 = 0;

  0021d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  00225	e9 af 00 00 00	 jmp	 $LN13@s390_conve
$LN12@s390_conve:

; 2141 :         else
; 2142 :         {
; 2143 :             SET_SF_RM_FROM_MASK( m3 );

  0022a	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  0022f	85 c0		 test	 eax, eax
  00231	74 16		 je	 SHORT $LN21@s390_conve
  00233	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0023f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00243	89 44 24 3c	 mov	 DWORD PTR tv196[rsp], eax
  00247	eb 1f		 jmp	 SHORT $LN22@s390_conve
$LN21@s390_conve:
  00249	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00254	83 e0 07	 and	 eax, 7
  00257	8b c0		 mov	 eax, eax
  00259	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00260	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00264	89 44 24 3c	 mov	 DWORD PTR tv196[rsp], eax
$LN22@s390_conve:
  00268	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0026d	8b c0		 mov	 eax, eax
  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00275	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00282	0f b6 54 24 3c	 movzx	 edx, BYTE PTR tv196[rsp]
  00287	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2144 :             op1 = f32_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  0028a	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  0028f	83 e0 04	 and	 eax, 4
  00292	85 c0		 test	 eax, eax
  00294	75 0a		 jne	 SHORT $LN23@s390_conve
  00296	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  0029e	eb 08		 jmp	 SHORT $LN24@s390_conve
$LN23@s390_conve:
  002a0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN24@s390_conve:
  002a8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002ad	8b c0		 mov	 eax, eax
  002af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002be	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c2	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR tv202[rsp]
  002c8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002cc	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  002d0	e8 00 00 00 00	 call	 f32_to_i32
  002d5	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN13@s390_conve:
$LN11@s390_conve:
$LN9@s390_conve:

; 2145 :         }
; 2146 :     }
; 2147 : 
; 2148 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002d9	33 c0		 xor	 eax, eax
  002db	83 f8 01	 cmp	 eax, 1
  002de	74 45		 je	 SHORT $LN14@s390_conve
  002e0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e5	8b c0		 mov	 eax, eax
  002e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ed	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002fe	83 e0 10	 and	 eax, 16
  00301	85 c0		 test	 eax, eax
  00303	74 20		 je	 SHORT $LN14@s390_conve
  00305	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0030a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00310	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00315	85 c0		 test	 eax, eax
  00317	74 0c		 je	 SHORT $LN14@s390_conve
  00319	b2 80		 mov	 dl, 128			; 00000080H
  0031b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_conve:

; 2149 : 
; 2150 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00325	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0032a	8b c0		 mov	 eax, eax
  0032c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00332	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0033b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0033f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00343	83 e0 10	 and	 eax, 16
  00346	85 c0		 test	 eax, eax
  00348	74 52		 je	 SHORT $LN15@s390_conve

; 2151 :     {
; 2152 :         newcc = 3;

  0034a	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2153 : 
; 2154 :         if (!SUPPRESS_INEXACT( m4 ))

  0034f	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00354	83 e0 04	 and	 eax, 4
  00357	85 c0		 test	 eax, eax
  00359	75 41		 jne	 SHORT $LN16@s390_conve

; 2155 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  0035b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00360	8b c0		 mov	 eax, eax
  00362	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00368	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00371	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00375	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00379	83 c8 01	 or	 eax, 1
  0037c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00382	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038b	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00391	45 8b c0	 mov	 r8d, r8d
  00394	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00398	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN16@s390_conve:
$LN15@s390_conve:

; 2156 :     }
; 2157 : 
; 2158 :     regs->GR_L( r1 ) = op1;

  0039c	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  003a1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003a6	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  003aa	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2159 :     regs->psw.cc = newcc;

  003b1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  003b6	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  003bb	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2160 : 
; 2161 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  003be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003c3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003c8	89 44 24 34	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2162 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  003cc	8b 44 24 34	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003d0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003d5	85 c0		 test	 eax, eax
  003d7	74 0e		 je	 SHORT $LN17@s390_conve
  003d9	8b 54 24 34	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003dd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003e2	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s390_conve:

; 2163 : }

  003e7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003eb	c3		 ret	 0
s390_convert_bfp_short_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
ieee_trap_conds$ = 48
tv174 = 52
tv196 = 56
tv202 = 60
r2$ = 64
r1$ = 68
op2$ = 72
inst$ = 96
regs$ = 104
s390_convert_bfp_long_to_fix32_reg PROC

; 2027 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2028 :     int        r1, r2;
; 2029 :     BYTE       m3, m4, newcc;
; 2030 :     S32        op1;
; 2031 :     float64_t  op2;
; 2032 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2033 :     U32        op2_dataclass;
; 2034 : 
; 2035 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 40	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s390_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s390_conve

; 2036 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2037 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s390_conve
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s390_conve
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_conve:

; 2038 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 2039 : 
; 2040 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2041 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 2042 : #endif
; 2043 :         m4 = 0;

  00119	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0

; 2044 : 
; 2045 :     GET_FLOAT64_OP( op2, r2, regs );

  0011e	8b 44 24 40	 mov	 eax, DWORD PTR r2$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_get_float64

; 2046 :     op2_dataclass = float64_class( op2 );

  00140	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00145	e8 00 00 00 00	 call	 float64_class
  0014a	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2047 :     softfloat_exceptionFlags = 0;

  0014e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00153	8b c0		 mov	 eax, eax
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0015b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00164	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00168	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2048 : 
; 2049 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  0016c	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00170	83 e0 0f	 and	 eax, 15
  00173	85 c0		 test	 eax, eax
  00175	74 53		 je	 SHORT $LN8@s390_conve

; 2050 :                          float_class_pos_signaling_nan |
; 2051 :                          float_class_neg_quiet_nan     |
; 2052 :                          float_class_pos_quiet_nan ))
; 2053 :     {
; 2054 :         /* NaN input always returns maximum negative integer,
; 2055 :            cc3, and IEEE invalid exception */
; 2056 :         op1 = -0x7FFFFFFF - 1;

  00177	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 2057 :         newcc = 3;

  0017f	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2058 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00184	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00189	8b c0		 mov	 eax, eax
  0018b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00191	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0019a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0019e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a2	83 c8 10	 or	 eax, 16
  001a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ab	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b4	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  001ba	45 8b c0	 mov	 r8d, r8d
  001bd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c1	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2059 :     }

  001c5	e9 1e 01 00 00	 jmp	 $LN9@s390_conve
$LN8@s390_conve:

; 2060 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  001ca	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  001ce	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  001d3	85 c0		 test	 eax, eax
  001d5	74 12		 je	 SHORT $LN10@s390_conve

; 2061 :     {
; 2062 :         newcc = 0;

  001d7	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2063 :         op1 = 0;

  001dc	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2064 :     }

  001e4	e9 ff 00 00 00	 jmp	 $LN11@s390_conve
$LN10@s390_conve:

; 2065 :     else
; 2066 :     {
; 2067 :         newcc = (op2.v & 0x8000000000000000ULL) ? 1 : 2;

  001e9	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001f3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  001f8	48 23 c8	 and	 rcx, rax
  001fb	48 8b c1	 mov	 rax, rcx
  001fe	48 85 c0	 test	 rax, rax
  00201	74 0a		 je	 SHORT $LN19@s390_conve
  00203	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0020b	eb 08		 jmp	 SHORT $LN20@s390_conve
$LN19@s390_conve:
  0020d	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN20@s390_conve:
  00215	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv174[rsp]
  0021a	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2068 : 
; 2069 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  0021e	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00222	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00227	85 c0		 test	 eax, eax
  00229	74 0d		 je	 SHORT $LN12@s390_conve

; 2070 :             op1 = 0;

  0022b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  00233	e9 b0 00 00 00	 jmp	 $LN13@s390_conve
$LN12@s390_conve:

; 2071 :         else
; 2072 :         {
; 2073 :             SET_SF_RM_FROM_MASK( m3 );

  00238	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  0023d	85 c0		 test	 eax, eax
  0023f	74 16		 je	 SHORT $LN21@s390_conve
  00241	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0024d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00251	89 44 24 38	 mov	 DWORD PTR tv196[rsp], eax
  00255	eb 1f		 jmp	 SHORT $LN22@s390_conve
$LN21@s390_conve:
  00257	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0025c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00262	83 e0 07	 and	 eax, 7
  00265	8b c0		 mov	 eax, eax
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0026e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00272	89 44 24 38	 mov	 DWORD PTR tv196[rsp], eax
$LN22@s390_conve:
  00276	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0027b	8b c0		 mov	 eax, eax
  0027d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00283	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0028c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00290	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv196[rsp]
  00295	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2074 :             op1 = f64_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00298	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  0029d	83 e0 04	 and	 eax, 4
  002a0	85 c0		 test	 eax, eax
  002a2	75 0a		 jne	 SHORT $LN23@s390_conve
  002a4	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  002ac	eb 08		 jmp	 SHORT $LN24@s390_conve
$LN23@s390_conve:
  002ae	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN24@s390_conve:
  002b6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002bb	8b c0		 mov	 eax, eax
  002bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002c3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002cc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d0	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv202[rsp]
  002d6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  002df	e8 00 00 00 00	 call	 f64_to_i32
  002e4	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN13@s390_conve:
$LN11@s390_conve:
$LN9@s390_conve:

; 2075 :         }
; 2076 :     }
; 2077 : 
; 2078 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002e8	33 c0		 xor	 eax, eax
  002ea	83 f8 01	 cmp	 eax, 1
  002ed	74 45		 je	 SHORT $LN14@s390_conve
  002ef	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002f4	8b c0		 mov	 eax, eax
  002f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002fc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00305	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00309	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0030d	83 e0 10	 and	 eax, 16
  00310	85 c0		 test	 eax, eax
  00312	74 20		 je	 SHORT $LN14@s390_conve
  00314	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00319	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0031f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00324	85 c0		 test	 eax, eax
  00326	74 0c		 je	 SHORT $LN14@s390_conve
  00328	b2 80		 mov	 dl, 128			; 00000080H
  0032a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0032f	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_conve:

; 2079 : 
; 2080 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00334	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00339	8b c0		 mov	 eax, eax
  0033b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00341	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0034a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0034e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00352	83 e0 10	 and	 eax, 16
  00355	85 c0		 test	 eax, eax
  00357	74 52		 je	 SHORT $LN15@s390_conve

; 2081 :     {
; 2082 :         newcc = 3;

  00359	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2083 :         if (!SUPPRESS_INEXACT( m4 ))

  0035e	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00363	83 e0 04	 and	 eax, 4
  00366	85 c0		 test	 eax, eax
  00368	75 41		 jne	 SHORT $LN16@s390_conve

; 2084 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  0036a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0036f	8b c0		 mov	 eax, eax
  00371	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00377	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00380	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00384	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00388	83 c8 01	 or	 eax, 1
  0038b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00391	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0039a	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  003a0	45 8b c0	 mov	 r8d, r8d
  003a3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003a7	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN16@s390_conve:
$LN15@s390_conve:

; 2085 :     }
; 2086 : 
; 2087 :     regs->GR_L( r1 ) = op1;

  003ab	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  003b0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b5	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  003b9	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2088 :     regs->psw.cc = newcc;

  003c0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  003c5	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  003ca	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2089 : 
; 2090 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  003cd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003d2	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003d7	89 44 24 30	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2091 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  003db	8b 44 24 30	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003df	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003e4	85 c0		 test	 eax, eax
  003e6	74 0e		 je	 SHORT $LN17@s390_conve
  003e8	8b 54 24 30	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003ec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s390_conve:

; 2092 : }

  003f6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003fa	c3		 ret	 0
s390_convert_bfp_long_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
ieee_trap_conds$ = 48
r2$ = 52
tv181 = 56
tv203 = 60
tv209 = 64
r1$ = 68
tv348 = 72
tv280 = 80
$T2 = 96
$T3 = 112
op2$ = 128
__$ArrayPad$ = 144
inst$ = 192
regs$ = 200
s390_convert_bfp_ext_to_fix32_reg PROC

; 1952 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1953 :     int         r1, r2;
; 1954 :     BYTE        m3, m4, newcc;
; 1955 :     S32         op1;
; 1956 :     float128_t  op2;
; 1957 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1958 :     U32         op2_dataclass;
; 1959 : 
; 1960 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@s390_conve:
  0007a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN5@s390_conve
  0009d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_conve:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s390_conve

; 1961 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1962 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN7@s390_conve
  000d3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN6@s390_conve
  000ea	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN6@s390_conve
$LN7@s390_conve:
  00112	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_conve:

; 1963 :     BFPREGPAIR_CHECK( r2, regs );

  0013f	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00143	83 e0 02	 and	 eax, 2
  00146	85 c0		 test	 eax, eax
  00148	74 1b		 je	 SHORT $LN8@s390_conve
  0014a	ba 06 00 00 00	 mov	 edx, 6
  0014f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_conve:

; 1964 :     BFPRM_CHECK( m3, regs );

  00165	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  0016a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00172	e8 00 00 00 00	 call	 s390_BFP_RM_check

; 1965 : 
; 1966 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1967 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))
; 1968 : #endif
; 1969 :         m4 = 0;

  00177	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0

; 1970 : 
; 1971 :     GET_FLOAT128_OP( op2, r2, regs );

  0017c	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00180	d1 e0		 shl	 eax, 1
  00182	48 98		 cdqe
  00184	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00194	48 8b d0	 mov	 rdx, rax
  00197	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  0019f	e8 00 00 00 00	 call	 s390_get_float128

; 1972 :     op2_dataclass = float128_class( op2 );

  001a4	48 8d 44 24 60	 lea	 rax, QWORD PTR $T2[rsp]
  001a9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001b1	48 8b f8	 mov	 rdi, rax
  001b4	48 8b f1	 mov	 rsi, rcx
  001b7	b9 10 00 00 00	 mov	 ecx, 16
  001bc	f3 a4		 rep movsb
  001be	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  001c3	e8 00 00 00 00	 call	 float128_class
  001c8	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 1973 :     softfloat_exceptionFlags = 0;

  001cc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d1	8b c0		 mov	 eax, eax
  001d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1974 : 
; 1975 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  001ea	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  001ee	83 e0 0f	 and	 eax, 15
  001f1	85 c0		 test	 eax, eax
  001f3	74 50		 je	 SHORT $LN9@s390_conve

; 1976 :                          float_class_pos_signaling_nan |
; 1977 :                          float_class_neg_quiet_nan     |
; 1978 :                          float_class_pos_quiet_nan ))
; 1979 :     {
; 1980 :         /* NaN input always returns maximum negative integer,
; 1981 :            cc3, and IEEE invalid exception */
; 1982 :         op1 = -0x7FFFFFFF - 1;

  001f5	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 1983 :         newcc = 3;

  001fd	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 1984 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00202	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00207	8b c0		 mov	 eax, eax
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00218	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00220	83 c8 10	 or	 eax, 16
  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00229	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00232	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00237	8b ff		 mov	 edi, edi
  00239	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023d	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 1985 :     }

  00240	e9 58 01 00 00	 jmp	 $LN10@s390_conve
$LN9@s390_conve:

; 1986 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  00245	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00249	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  0024e	85 c0		 test	 eax, eax
  00250	74 12		 je	 SHORT $LN11@s390_conve

; 1987 :     {
; 1988 :         newcc = 0;

  00252	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 1989 :         op1 = 0;

  00257	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 1990 :     }

  0025f	e9 39 01 00 00	 jmp	 $LN12@s390_conve
$LN11@s390_conve:

; 1991 :     else
; 1992 :     {
; 1993 :         newcc = (op2.v[FLOAT128_HI] & 0x8000000000000000ULL) ? 1 : 2;

  00264	b8 08 00 00 00	 mov	 eax, 8
  00269	48 6b c0 01	 imul	 rax, rax, 1
  0026d	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00277	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0027f	48 23 c1	 and	 rax, rcx
  00282	48 85 c0	 test	 rax, rax
  00285	74 0a		 je	 SHORT $LN20@s390_conve
  00287	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv181[rsp], 1
  0028f	eb 08		 jmp	 SHORT $LN21@s390_conve
$LN20@s390_conve:
  00291	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv181[rsp], 2
$LN21@s390_conve:
  00299	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv181[rsp]
  0029e	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1994 : 
; 1995 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  002a2	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  002a6	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002ab	85 c0		 test	 eax, eax
  002ad	74 0d		 je	 SHORT $LN13@s390_conve

; 1996 :             op1 = 0;

  002af	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  002b7	e9 e1 00 00 00	 jmp	 $LN14@s390_conve
$LN13@s390_conve:

; 1997 :         else
; 1998 :         {
; 1999 :             SET_SF_RM_FROM_MASK( m3 );

  002bc	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002c1	85 c0		 test	 eax, eax
  002c3	74 16		 je	 SHORT $LN22@s390_conve
  002c5	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  002d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d5	89 44 24 3c	 mov	 DWORD PTR tv203[rsp], eax
  002d9	eb 22		 jmp	 SHORT $LN23@s390_conve
$LN22@s390_conve:
  002db	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002e9	83 e0 07	 and	 eax, 7
  002ec	8b c0		 mov	 eax, eax
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f9	89 44 24 3c	 mov	 DWORD PTR tv203[rsp], eax
$LN23@s390_conve:
  002fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00302	8b c0		 mov	 eax, eax
  00304	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00313	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00317	0f b6 54 24 3c	 movzx	 edx, BYTE PTR tv203[rsp]
  0031c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2000 :             op1 = f128_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  0031f	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00324	83 e0 04	 and	 eax, 4
  00327	85 c0		 test	 eax, eax
  00329	75 0a		 jne	 SHORT $LN24@s390_conve
  0032b	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv209[rsp], 1
  00333	eb 08		 jmp	 SHORT $LN25@s390_conve
$LN24@s390_conve:
  00335	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv209[rsp], 0
$LN25@s390_conve:
  0033d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00342	8b c0		 mov	 eax, eax
  00344	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0034a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00353	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00357	48 89 4c 24 50	 mov	 QWORD PTR tv280[rsp], rcx
  0035c	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T3[rsp]
  00361	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR op2$[rsp]
  00369	48 89 7c 24 48	 mov	 QWORD PTR tv348[rsp], rdi
  0036e	48 8b fa	 mov	 rdi, rdx
  00371	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv348[rsp]
  00376	48 8b f2	 mov	 rsi, rdx
  00379	b9 10 00 00 00	 mov	 ecx, 16
  0037e	f3 a4		 rep movsb
  00380	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR tv209[rsp]
  00386	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv280[rsp]
  0038b	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0038f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T3[rsp]
  00394	e8 00 00 00 00	 call	 f128_to_i32
  00399	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN14@s390_conve:
$LN12@s390_conve:
$LN10@s390_conve:

; 2001 :         }
; 2002 :     }
; 2003 : 
; 2004 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0039d	33 c0		 xor	 eax, eax
  0039f	83 f8 01	 cmp	 eax, 1
  003a2	74 4b		 je	 SHORT $LN15@s390_conve
  003a4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003a9	8b c0		 mov	 eax, eax
  003ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003ba	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003be	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003c2	83 e0 10	 and	 eax, 16
  003c5	85 c0		 test	 eax, eax
  003c7	74 26		 je	 SHORT $LN15@s390_conve
  003c9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003d7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003dc	85 c0		 test	 eax, eax
  003de	74 0f		 je	 SHORT $LN15@s390_conve
  003e0	b2 80		 mov	 dl, 128			; 00000080H
  003e2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ea	e8 00 00 00 00	 call	 ieee_trap
$LN15@s390_conve:

; 2005 : 
; 2006 :     /* Non-trappable Invalid exception? */
; 2007 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  003ef	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003f4	8b c0		 mov	 eax, eax
  003f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003fc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00405	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00409	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0040d	83 e0 10	 and	 eax, 16
  00410	85 c0		 test	 eax, eax
  00412	74 4f		 je	 SHORT $LN16@s390_conve

; 2008 :     {
; 2009 :         newcc = 3;

  00414	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2010 : 
; 2011 :         /* Inexact not suppressed? */
; 2012 :         if (!SUPPRESS_INEXACT( m4 ))

  00419	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  0041e	83 e0 04	 and	 eax, 4
  00421	85 c0		 test	 eax, eax
  00423	75 3e		 jne	 SHORT $LN17@s390_conve

; 2013 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00425	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0042a	8b c0		 mov	 eax, eax
  0042c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00432	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0043b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0043f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00443	83 c8 01	 or	 eax, 1
  00446	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0044c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00455	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  0045a	8b ff		 mov	 edi, edi
  0045c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00460	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN17@s390_conve:
$LN16@s390_conve:

; 2014 :     }
; 2015 : 
; 2016 :     regs->GR_L( r1 ) = op1;

  00463	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  00468	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00470	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  00474	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2017 :     regs->psw.cc = newcc;

  0047b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00483	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00488	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2018 : 
; 2019 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  0048b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00493	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00498	89 44 24 30	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2020 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0049c	8b 44 24 30	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004a0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004a5	85 c0		 test	 eax, eax
  004a7	74 11		 je	 SHORT $LN18@s390_conve
  004a9	8b 54 24 30	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004ad	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b5	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@s390_conve:

; 2021 : }

  004ba	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004c2	48 33 cc	 xor	 rcx, rsp
  004c5	e8 00 00 00 00	 call	 __security_check_cookie
  004ca	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  004d1	5f		 pop	 rdi
  004d2	5e		 pop	 rsi
  004d3	c3		 ret	 0
s390_convert_bfp_ext_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
s390_compare_bfp_short_reg PROC

; 1471 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1472 :     int        r1, r2;
; 1473 :     float32_t  op1, op2;
; 1474 :     BYTE       newcc;
; 1475 : 
; 1476 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_compa

; 1477 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1478 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_compa
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_compa
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_compa
$LN10@s390_compa:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_compa:
$LN7@s390_compa:

; 1479 : 
; 1480 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float32
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s390_get_float32
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s390_compa

; 1481 : 
; 1482 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1483 :     newcc = FLOAT32_COMPARE( op1, op2 );

  0014f	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  00153	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  00157	e8 00 00 00 00	 call	 s390_float32_compare
  0015c	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1484 : 
; 1485 :     /* Xi is only trap that suppresses result, no return */
; 1486 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00160	33 c0		 xor	 eax, eax
  00162	83 f8 01	 cmp	 eax, 1
  00165	74 45		 je	 SHORT $LN11@s390_compa
  00167	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016c	8b c0		 mov	 eax, eax
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00174	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00181	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00185	83 e0 10	 and	 eax, 16
  00188	85 c0		 test	 eax, eax
  0018a	74 20		 je	 SHORT $LN11@s390_compa
  0018c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00191	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00197	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019c	85 c0		 test	 eax, eax
  0019e	74 0c		 je	 SHORT $LN11@s390_compa
  001a0	b2 80		 mov	 dl, 128			; 00000080H
  001a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_compa:

; 1487 :     SET_FPC_FLAGS_FROM_SF( regs );

  001ac	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b1	8b c0		 mov	 eax, eax
  001b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ca	c1 e0 13	 shl	 eax, 19
  001cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001d8	c1 e9 08	 shr	 ecx, 8
  001db	f7 d1		 not	 ecx
  001dd	23 c1		 and	 eax, ecx
  001df	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001ef	0b c8		 or	 ecx, eax
  001f1	8b c1		 mov	 eax, ecx
  001f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001f8	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1488 :     regs->psw.cc = newcc;

  001fe	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00203	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00208	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1489 : }

  0020b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0020f	c3		 ret	 0
s390_compare_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
effective_addr2$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s390_compare_bfp_short PROC

; 1495 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1496 :     int        r1, x2, b2;
; 1497 :     VADR       effective_addr2;
; 1498 :     float32_t  op1, op2;
; 1499 :     BYTE       newcc;
; 1500 : 
; 1501 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s390_compa
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_compa:
  00070	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s390_compa
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_compa:
  000a2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ad	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b1	23 c8		 and	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_compa:
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 83 c0 06	 add	 rax, 6
  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cf	33 c0		 xor	 eax, eax
  000d1	83 f8 06	 cmp	 eax, 6
  000d4	74 0c		 je	 SHORT $LN7@s390_compa
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_compa:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 d1		 jne	 SHORT $LN4@s390_compa

; 1502 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1503 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1504 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00102	85 c0		 test	 eax, eax
  00104	74 39		 je	 SHORT $LN9@s390_compa
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 49		 je	 SHORT $LN8@s390_compa
  0011a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00126	b9 08 00 00 00	 mov	 ecx, 8
  0012b	48 6b c9 01	 imul	 rcx, rcx, 1
  0012f	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00136	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 24		 jne	 SHORT $LN8@s390_compa
$LN9@s390_compa:
  0013f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014e	ba 07 00 00 00	 mov	 edx, 7
  00153	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_compa:

; 1505 : 
; 1506 :     GET_FLOAT32_OP( op1, r1, regs );

  00163	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00167	d1 e0		 shl	 eax, 1
  00169	48 98		 cdqe
  0016b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00178	48 8b d0	 mov	 rdx, rax
  0017b	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  00180	e8 00 00 00 00	 call	 s390_get_float32

; 1507 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00185	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0018a	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0018e	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00192	e8 00 00 00 00	 call	 s390_vfetch4
  00197	89 44 24 38	 mov	 DWORD PTR op2$[rsp], eax

; 1508 : 
; 1509 :     softfloat_exceptionFlags = 0;

  0019b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a0	8b c0		 mov	 eax, eax
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1510 :     newcc = FLOAT32_COMPARE( op1, op2 );

  001b9	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  001bd	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  001c1	e8 00 00 00 00	 call	 s390_float32_compare
  001c6	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1511 : 
; 1512 :     /* Xi is only trap that suppresses result, no return */
; 1513 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001ca	33 c0		 xor	 eax, eax
  001cc	83 f8 01	 cmp	 eax, 1
  001cf	74 45		 je	 SHORT $LN10@s390_compa
  001d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d6	8b c0		 mov	 eax, eax
  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001de	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ef	83 e0 10	 and	 eax, 16
  001f2	85 c0		 test	 eax, eax
  001f4	74 20		 je	 SHORT $LN10@s390_compa
  001f6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00201	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00206	85 c0		 test	 eax, eax
  00208	74 0c		 je	 SHORT $LN10@s390_compa
  0020a	b2 80		 mov	 dl, 128			; 00000080H
  0020c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00211	e8 00 00 00 00	 call	 ieee_trap
$LN10@s390_compa:

; 1514 :     SET_FPC_FLAGS_FROM_SF( regs );

  00216	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021b	8b c0		 mov	 eax, eax
  0021d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00223	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00230	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00234	c1 e0 13	 shl	 eax, 19
  00237	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0023c	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00242	c1 e9 08	 shr	 ecx, 8
  00245	f7 d1		 not	 ecx
  00247	23 c1		 and	 eax, ecx
  00249	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0024e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00253	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00259	0b c8		 or	 ecx, eax
  0025b	8b c1		 mov	 eax, ecx
  0025d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00262	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1515 :     regs->psw.cc = newcc;

  00268	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00272	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1516 : }

  00275	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00279	c3		 ret	 0
s390_compare_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
s390_compare_bfp_long_reg PROC

; 1419 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1420 :     int        r1, r2;
; 1421 :     float64_t  op1, op2;
; 1422 :     BYTE       newcc;
; 1423 : 
; 1424 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_compa

; 1425 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1426 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_compa
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_compa
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_compa
$LN10@s390_compa:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_compa:
$LN7@s390_compa:

; 1427 : 
; 1428 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float64
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s390_get_float64
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s390_compa

; 1429 : 
; 1430 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1431 :     newcc = FLOAT64_COMPARE( op1, op2 );

  0014f	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  00154	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op1$[rsp]
  00159	e8 00 00 00 00	 call	 s390_float64_compare
  0015e	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1432 : 
; 1433 :     /* Xi is only trap that suppresses result, no return */
; 1434 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00162	33 c0		 xor	 eax, eax
  00164	83 f8 01	 cmp	 eax, 1
  00167	74 45		 je	 SHORT $LN11@s390_compa
  00169	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016e	8b c0		 mov	 eax, eax
  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00176	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00183	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00187	83 e0 10	 and	 eax, 16
  0018a	85 c0		 test	 eax, eax
  0018c	74 20		 je	 SHORT $LN11@s390_compa
  0018e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00193	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00199	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019e	85 c0		 test	 eax, eax
  001a0	74 0c		 je	 SHORT $LN11@s390_compa
  001a2	b2 80		 mov	 dl, 128			; 00000080H
  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_compa:

; 1435 :     SET_FPC_FLAGS_FROM_SF( regs );

  001ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b3	8b c0		 mov	 eax, eax
  001b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001bb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cc	c1 e0 13	 shl	 eax, 19
  001cf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001da	c1 e9 08	 shr	 ecx, 8
  001dd	f7 d1		 not	 ecx
  001df	23 c1		 and	 eax, ecx
  001e1	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001f1	0b c8		 or	 ecx, eax
  001f3	8b c1		 mov	 eax, ecx
  001f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001fa	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1436 :     regs->psw.cc = newcc;

  00200	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00205	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0020a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1437 : }

  0020d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00211	c3		 ret	 0
s390_compare_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
effective_addr2$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
s390_compare_bfp_long PROC

; 1443 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1444 :     int        r1, x2, b2;
; 1445 :     VADR       effective_addr2;
; 1446 :     float64_t  op1, op2;
; 1447 :     BYTE       newcc;
; 1448 : 
; 1449 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s390_compa
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_compa:
  00070	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s390_compa
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_compa:
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ad	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b1	23 c8		 and	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_compa:
  000b9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 83 c0 06	 add	 rax, 6
  000c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cf	33 c0		 xor	 eax, eax
  000d1	83 f8 06	 cmp	 eax, 6
  000d4	74 0c		 je	 SHORT $LN7@s390_compa
  000d6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_compa:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 d1		 jne	 SHORT $LN4@s390_compa

; 1450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1451 : 
; 1452 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1453 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00102	85 c0		 test	 eax, eax
  00104	74 39		 je	 SHORT $LN9@s390_compa
  00106	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 49		 je	 SHORT $LN8@s390_compa
  0011a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00126	b9 08 00 00 00	 mov	 ecx, 8
  0012b	48 6b c9 01	 imul	 rcx, rcx, 1
  0012f	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00136	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 24		 jne	 SHORT $LN8@s390_compa
$LN9@s390_compa:
  0013f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014e	ba 07 00 00 00	 mov	 edx, 7
  00153	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_compa:

; 1454 :     GET_FLOAT64_OP( op1, r1, regs );

  00163	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00167	d1 e0		 shl	 eax, 1
  00169	48 98		 cdqe
  0016b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00178	48 8b d0	 mov	 rdx, rax
  0017b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00180	e8 00 00 00 00	 call	 s390_get_float64

; 1455 : 
; 1456 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00185	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0018a	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0018e	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00192	e8 00 00 00 00	 call	 s390_vfetch8
  00197	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 1457 : 
; 1458 :     softfloat_exceptionFlags = 0;

  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a1	8b c0		 mov	 eax, eax
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1459 :     newcc = FLOAT64_COMPARE( op1, op2 );

  001ba	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  001bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  001c4	e8 00 00 00 00	 call	 s390_float64_compare
  001c9	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1460 : 
; 1461 :     /* Xi is only trap that suppresses result, no return */
; 1462 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001cd	33 c0		 xor	 eax, eax
  001cf	83 f8 01	 cmp	 eax, 1
  001d2	74 45		 je	 SHORT $LN10@s390_compa
  001d4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d9	8b c0		 mov	 eax, eax
  001db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ea	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f2	83 e0 10	 and	 eax, 16
  001f5	85 c0		 test	 eax, eax
  001f7	74 20		 je	 SHORT $LN10@s390_compa
  001f9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001fe	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00204	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00209	85 c0		 test	 eax, eax
  0020b	74 0c		 je	 SHORT $LN10@s390_compa
  0020d	b2 80		 mov	 dl, 128			; 00000080H
  0020f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00214	e8 00 00 00 00	 call	 ieee_trap
$LN10@s390_compa:

; 1463 :     SET_FPC_FLAGS_FROM_SF( regs );

  00219	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021e	8b c0		 mov	 eax, eax
  00220	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00226	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00233	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00237	c1 e0 13	 shl	 eax, 19
  0023a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00245	c1 e9 08	 shr	 ecx, 8
  00248	f7 d1		 not	 ecx
  0024a	23 c1		 and	 eax, ecx
  0024c	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00251	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0025c	0b c8		 or	 ecx, eax
  0025e	8b c1		 mov	 eax, ecx
  00260	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1464 :     regs->psw.cc = newcc;

  0026b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00270	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00275	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1465 : }

  00278	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027c	c3		 ret	 0
s390_compare_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s390_compare_bfp_ext_reg PROC

; 1391 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1392 :     int         r1, r2;
; 1393 :     float128_t  op1, op2;
; 1394 :     BYTE        newcc;
; 1395 : 
; 1396 :     RRE( inst, regs, r1, r2 );

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 03	 imul	 rax, rax, 3
  0002b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00033	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00037	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	c1 f8 04	 sar	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_compa:
  00054	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00060	48 83 c0 04	 add	 rax, 4
  00064	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00070	33 c0		 xor	 eax, eax
  00072	83 f8 04	 cmp	 eax, 4
  00075	74 0f		 je	 SHORT $LN8@s390_compa
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_compa:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 c8		 jne	 SHORT $LN4@s390_compa

; 1397 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1398 :     BFPINST_CHECK( regs );

  0008c	b8 08 00 00 00	 mov	 eax, 8
  00091	48 6b c0 01	 imul	 rax, rax, 1
  00095	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 3f		 je	 SHORT $LN10@s390_compa
  000ad	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bb	d1 e8		 shr	 eax, 1
  000bd	83 e0 01	 and	 eax, 1
  000c0	85 c0		 test	 eax, eax
  000c2	74 55		 je	 SHORT $LN9@s390_compa
  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d3	b9 08 00 00 00	 mov	 ecx, 8
  000d8	48 6b c9 01	 imul	 rcx, rcx, 1
  000dc	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e8	85 c0		 test	 eax, eax
  000ea	75 2d		 jne	 SHORT $LN9@s390_compa
$LN10@s390_compa:
  000ec	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fe	ba 07 00 00 00	 mov	 edx, 7
  00103	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00113	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_compa:

; 1399 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00119	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011d	83 e0 02	 and	 eax, 2
  00120	85 c0		 test	 eax, eax
  00122	75 0b		 jne	 SHORT $LN12@s390_compa
  00124	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	74 1b		 je	 SHORT $LN11@s390_compa
$LN12@s390_compa:
  0012f	ba 06 00 00 00	 mov	 edx, 6
  00134	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00144	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_compa:
$LN7@s390_compa:

; 1400 : 
; 1401 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  0014a	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0014e	d1 e0		 shl	 eax, 1
  00150	48 98		 cdqe
  00152	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00162	48 8b d0	 mov	 rdx, rax
  00165	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  0016a	e8 00 00 00 00	 call	 s390_get_float128
  0016f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00173	d1 e0		 shl	 eax, 1
  00175	48 98		 cdqe
  00177	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00187	48 8b d0	 mov	 rdx, rax
  0018a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0018f	e8 00 00 00 00	 call	 s390_get_float128
  00194	33 c0		 xor	 eax, eax
  00196	85 c0		 test	 eax, eax
  00198	75 b0		 jne	 SHORT $LN7@s390_compa

; 1402 : 
; 1403 :     softfloat_exceptionFlags = 0;

  0019a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019f	8b c0		 mov	 eax, eax
  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1404 :     newcc = FLOAT128_COMPARE( op1, op2 );

  001b8	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  001bd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001c2	48 8b f8	 mov	 rdi, rax
  001c5	48 8b f1	 mov	 rsi, rcx
  001c8	b9 10 00 00 00	 mov	 ecx, 16
  001cd	f3 a4		 rep movsb
  001cf	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  001d4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001d9	48 8b f8	 mov	 rdi, rax
  001dc	48 8b f1	 mov	 rsi, rcx
  001df	b9 10 00 00 00	 mov	 ecx, 16
  001e4	f3 a4		 rep movsb
  001e6	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  001eb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  001f0	e8 00 00 00 00	 call	 s390_float128_compare
  001f5	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1405 : 
; 1406 :     /* Xi is only trap that suppresses result, no return */
; 1407 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001f9	33 c0		 xor	 eax, eax
  001fb	83 f8 01	 cmp	 eax, 1
  001fe	74 4b		 je	 SHORT $LN13@s390_compa
  00200	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00205	8b c0		 mov	 eax, eax
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00216	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021e	83 e0 10	 and	 eax, 16
  00221	85 c0		 test	 eax, eax
  00223	74 26		 je	 SHORT $LN13@s390_compa
  00225	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00233	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0f		 je	 SHORT $LN13@s390_compa
  0023c	b2 80		 mov	 dl, 128			; 00000080H
  0023e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	e8 00 00 00 00	 call	 ieee_trap
$LN13@s390_compa:

; 1408 : 
; 1409 :     SET_FPC_FLAGS_FROM_SF( regs );

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00269	c1 e0 13	 shl	 eax, 19
  0026c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0027a	c1 e9 08	 shr	 ecx, 8
  0027d	f7 d1		 not	 ecx
  0027f	23 c1		 and	 eax, ecx
  00281	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00286	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00294	0b c8		 or	 ecx, eax
  00296	8b c1		 mov	 eax, ecx
  00298	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1410 : 
; 1411 :     /* Xi is only possible exception detected for Compare   */
; 1412 :     regs->psw.cc = newcc;

  002a6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ae	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  002b3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1413 : }

  002b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002bb	48 33 cc	 xor	 rcx, rsp
  002be	e8 00 00 00 00	 call	 __security_check_cookie
  002c3	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002ca	5f		 pop	 rdi
  002cb	5e		 pop	 rsi
  002cc	c3		 ret	 0
s390_compare_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
s390_compare_and_signal_bfp_short_reg PROC

; 1598 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1599 :     int        r1, r2;
; 1600 :     float32_t  op1, op2;
; 1601 :     BYTE       newcc;
; 1602 : 
; 1603 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_compa

; 1604 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1605 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_compa
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_compa
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_compa
$LN10@s390_compa:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_compa:
$LN7@s390_compa:

; 1606 : 
; 1607 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float32
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s390_get_float32
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s390_compa

; 1608 : 
; 1609 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1610 :     newcc = FLOAT32_COMPARE_AND_SIGNAL( op1, op2 );

  0014f	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  00153	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  00157	e8 00 00 00 00	 call	 s390_float32_signaling_compare
  0015c	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1611 : 
; 1612 :     /* Xi is only trap that suppresses result, no return */
; 1613 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00160	33 c0		 xor	 eax, eax
  00162	83 f8 01	 cmp	 eax, 1
  00165	74 45		 je	 SHORT $LN11@s390_compa
  00167	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016c	8b c0		 mov	 eax, eax
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00174	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00181	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00185	83 e0 10	 and	 eax, 16
  00188	85 c0		 test	 eax, eax
  0018a	74 20		 je	 SHORT $LN11@s390_compa
  0018c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00191	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00197	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019c	85 c0		 test	 eax, eax
  0019e	74 0c		 je	 SHORT $LN11@s390_compa
  001a0	b2 80		 mov	 dl, 128			; 00000080H
  001a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_compa:

; 1614 :     SET_FPC_FLAGS_FROM_SF( regs );

  001ac	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b1	8b c0		 mov	 eax, eax
  001b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ca	c1 e0 13	 shl	 eax, 19
  001cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001d8	c1 e9 08	 shr	 ecx, 8
  001db	f7 d1		 not	 ecx
  001dd	23 c1		 and	 eax, ecx
  001df	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001ef	0b c8		 or	 ecx, eax
  001f1	8b c1		 mov	 eax, ecx
  001f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001f8	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1615 :     regs->psw.cc = newcc;

  001fe	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00203	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00208	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1616 : }

  0020b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0020f	c3		 ret	 0
s390_compare_and_signal_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
effective_addr2$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s390_compare_and_signal_bfp_short PROC

; 1622 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1623 :     int        r1, x2, b2;
; 1624 :     VADR       effective_addr2;
; 1625 :     float32_t  op1, op2;
; 1626 :     BYTE       newcc;
; 1627 : 
; 1628 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s390_compa
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_compa:
  00070	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s390_compa
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_compa:
  000a2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ad	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b1	23 c8		 and	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_compa:
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 83 c0 06	 add	 rax, 6
  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cf	33 c0		 xor	 eax, eax
  000d1	83 f8 06	 cmp	 eax, 6
  000d4	74 0c		 je	 SHORT $LN7@s390_compa
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_compa:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 d1		 jne	 SHORT $LN4@s390_compa

; 1629 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1630 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1631 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00102	85 c0		 test	 eax, eax
  00104	74 39		 je	 SHORT $LN9@s390_compa
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 49		 je	 SHORT $LN8@s390_compa
  0011a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00126	b9 08 00 00 00	 mov	 ecx, 8
  0012b	48 6b c9 01	 imul	 rcx, rcx, 1
  0012f	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00136	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 24		 jne	 SHORT $LN8@s390_compa
$LN9@s390_compa:
  0013f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014e	ba 07 00 00 00	 mov	 edx, 7
  00153	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_compa:

; 1632 : 
; 1633 :     GET_FLOAT32_OP( op1, r1, regs );

  00163	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00167	d1 e0		 shl	 eax, 1
  00169	48 98		 cdqe
  0016b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00178	48 8b d0	 mov	 rdx, rax
  0017b	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  00180	e8 00 00 00 00	 call	 s390_get_float32

; 1634 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00185	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0018a	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0018e	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00192	e8 00 00 00 00	 call	 s390_vfetch4
  00197	89 44 24 38	 mov	 DWORD PTR op2$[rsp], eax

; 1635 : 
; 1636 :     softfloat_exceptionFlags = 0;

  0019b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a0	8b c0		 mov	 eax, eax
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1637 :     newcc = FLOAT32_COMPARE_AND_SIGNAL( op1, op2 );

  001b9	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  001bd	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  001c1	e8 00 00 00 00	 call	 s390_float32_signaling_compare
  001c6	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1638 : 
; 1639 :     /* Xi is only trap that suppresses result, no return */
; 1640 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001ca	33 c0		 xor	 eax, eax
  001cc	83 f8 01	 cmp	 eax, 1
  001cf	74 45		 je	 SHORT $LN10@s390_compa
  001d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d6	8b c0		 mov	 eax, eax
  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001de	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ef	83 e0 10	 and	 eax, 16
  001f2	85 c0		 test	 eax, eax
  001f4	74 20		 je	 SHORT $LN10@s390_compa
  001f6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00201	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00206	85 c0		 test	 eax, eax
  00208	74 0c		 je	 SHORT $LN10@s390_compa
  0020a	b2 80		 mov	 dl, 128			; 00000080H
  0020c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00211	e8 00 00 00 00	 call	 ieee_trap
$LN10@s390_compa:

; 1641 :     SET_FPC_FLAGS_FROM_SF( regs );

  00216	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021b	8b c0		 mov	 eax, eax
  0021d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00223	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00230	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00234	c1 e0 13	 shl	 eax, 19
  00237	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0023c	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00242	c1 e9 08	 shr	 ecx, 8
  00245	f7 d1		 not	 ecx
  00247	23 c1		 and	 eax, ecx
  00249	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0024e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00253	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00259	0b c8		 or	 ecx, eax
  0025b	8b c1		 mov	 eax, ecx
  0025d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00262	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1642 :     regs->psw.cc = newcc;

  00268	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00272	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1643 : }

  00275	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00279	c3		 ret	 0
s390_compare_and_signal_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
s390_compare_and_signal_bfp_long_reg PROC

; 1547 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1548 :     int        r1, r2;
; 1549 :     float64_t  op1, op2;
; 1550 :     BYTE       newcc;
; 1551 : 
; 1552 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_compa

; 1553 : 
; 1554 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1555 :     BFPINST_CHECK(regs);

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s390_compa
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s390_compa
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s390_compa
$LN10@s390_compa:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_compa:
$LN7@s390_compa:

; 1556 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s390_get_float64
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s390_get_float64
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s390_compa

; 1557 : 
; 1558 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1559 :     newcc = FLOAT64_COMPARE_AND_SIGNAL( op1, op2 );

  0014f	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  00154	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op1$[rsp]
  00159	e8 00 00 00 00	 call	 s390_float64_signaling_compare
  0015e	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1560 : 
; 1561 :     /* Xi is only trap that suppresses result, no return */
; 1562 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00162	33 c0		 xor	 eax, eax
  00164	83 f8 01	 cmp	 eax, 1
  00167	74 45		 je	 SHORT $LN11@s390_compa
  00169	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016e	8b c0		 mov	 eax, eax
  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00176	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00183	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00187	83 e0 10	 and	 eax, 16
  0018a	85 c0		 test	 eax, eax
  0018c	74 20		 je	 SHORT $LN11@s390_compa
  0018e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00193	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00199	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019e	85 c0		 test	 eax, eax
  001a0	74 0c		 je	 SHORT $LN11@s390_compa
  001a2	b2 80		 mov	 dl, 128			; 00000080H
  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	e8 00 00 00 00	 call	 ieee_trap
$LN11@s390_compa:

; 1563 :     SET_FPC_FLAGS_FROM_SF( regs );

  001ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b3	8b c0		 mov	 eax, eax
  001b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001bb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cc	c1 e0 13	 shl	 eax, 19
  001cf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001da	c1 e9 08	 shr	 ecx, 8
  001dd	f7 d1		 not	 ecx
  001df	23 c1		 and	 eax, ecx
  001e1	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001f1	0b c8		 or	 ecx, eax
  001f3	8b c1		 mov	 eax, ecx
  001f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001fa	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1564 :     regs->psw.cc = newcc;

  00200	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00205	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0020a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1565 : }

  0020d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00211	c3		 ret	 0
s390_compare_and_signal_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
effective_addr2$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
s390_compare_and_signal_bfp_long PROC

; 1571 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1572 :     int        r1, x2, b2;
; 1573 :     VADR       effective_addr2;
; 1574 :     float64_t  op1, op2;
; 1575 :     BYTE       newcc;
; 1576 : 
; 1577 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s390_compa
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s390_compa:
  00070	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s390_compa
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_compa:
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ad	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b1	23 c8		 and	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_compa:
  000b9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 83 c0 06	 add	 rax, 6
  000c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cf	33 c0		 xor	 eax, eax
  000d1	83 f8 06	 cmp	 eax, 6
  000d4	74 0c		 je	 SHORT $LN7@s390_compa
  000d6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_compa:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 d1		 jne	 SHORT $LN4@s390_compa

; 1578 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1579 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1580 :     BFPINST_CHECK( regs );

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00102	85 c0		 test	 eax, eax
  00104	74 39		 je	 SHORT $LN9@s390_compa
  00106	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00111	d1 e8		 shr	 eax, 1
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 49		 je	 SHORT $LN8@s390_compa
  0011a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00126	b9 08 00 00 00	 mov	 ecx, 8
  0012b	48 6b c9 01	 imul	 rcx, rcx, 1
  0012f	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00136	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 24		 jne	 SHORT $LN8@s390_compa
$LN9@s390_compa:
  0013f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014e	ba 07 00 00 00	 mov	 edx, 7
  00153	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_compa:

; 1581 : 
; 1582 :     GET_FLOAT64_OP( op1, r1, regs );

  00163	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00167	d1 e0		 shl	 eax, 1
  00169	48 98		 cdqe
  0016b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00178	48 8b d0	 mov	 rdx, rax
  0017b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00180	e8 00 00 00 00	 call	 s390_get_float64

; 1583 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00185	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0018a	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0018e	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00192	e8 00 00 00 00	 call	 s390_vfetch8
  00197	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 1584 : 
; 1585 :     softfloat_exceptionFlags = 0;

  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a1	8b c0		 mov	 eax, eax
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1586 :     newcc = FLOAT64_COMPARE_AND_SIGNAL( op1, op2 );

  001ba	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  001bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  001c4	e8 00 00 00 00	 call	 s390_float64_signaling_compare
  001c9	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1587 : 
; 1588 :     /* Xi is only trap that suppresses result, no return */
; 1589 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001cd	33 c0		 xor	 eax, eax
  001cf	83 f8 01	 cmp	 eax, 1
  001d2	74 45		 je	 SHORT $LN10@s390_compa
  001d4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d9	8b c0		 mov	 eax, eax
  001db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ea	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f2	83 e0 10	 and	 eax, 16
  001f5	85 c0		 test	 eax, eax
  001f7	74 20		 je	 SHORT $LN10@s390_compa
  001f9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001fe	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00204	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00209	85 c0		 test	 eax, eax
  0020b	74 0c		 je	 SHORT $LN10@s390_compa
  0020d	b2 80		 mov	 dl, 128			; 00000080H
  0020f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00214	e8 00 00 00 00	 call	 ieee_trap
$LN10@s390_compa:

; 1590 :     SET_FPC_FLAGS_FROM_SF( regs );

  00219	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021e	8b c0		 mov	 eax, eax
  00220	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00226	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00233	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00237	c1 e0 13	 shl	 eax, 19
  0023a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00245	c1 e9 08	 shr	 ecx, 8
  00248	f7 d1		 not	 ecx
  0024a	23 c1		 and	 eax, ecx
  0024c	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00251	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0025c	0b c8		 or	 ecx, eax
  0025e	8b c1		 mov	 eax, ecx
  00260	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1591 :     regs->psw.cc = newcc;

  0026b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00270	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00275	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1592 : }

  00278	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027c	c3		 ret	 0
s390_compare_and_signal_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s390_compare_and_signal_bfp_ext_reg PROC

; 1522 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1523 :     int         r1, r2;
; 1524 :     float128_t  op1, op2;
; 1525 :     BYTE        newcc;
; 1526 : 
; 1527 :     RRE( inst, regs, r1, r2 );

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 03	 imul	 rax, rax, 3
  0002b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00033	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00037	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	c1 f8 04	 sar	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_compa:
  00054	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00060	48 83 c0 04	 add	 rax, 4
  00064	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00070	33 c0		 xor	 eax, eax
  00072	83 f8 04	 cmp	 eax, 4
  00075	74 0f		 je	 SHORT $LN8@s390_compa
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_compa:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 c8		 jne	 SHORT $LN4@s390_compa

; 1528 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1529 :     BFPINST_CHECK( regs );

  0008c	b8 08 00 00 00	 mov	 eax, 8
  00091	48 6b c0 01	 imul	 rax, rax, 1
  00095	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 3f		 je	 SHORT $LN10@s390_compa
  000ad	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bb	d1 e8		 shr	 eax, 1
  000bd	83 e0 01	 and	 eax, 1
  000c0	85 c0		 test	 eax, eax
  000c2	74 55		 je	 SHORT $LN9@s390_compa
  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d3	b9 08 00 00 00	 mov	 ecx, 8
  000d8	48 6b c9 01	 imul	 rcx, rcx, 1
  000dc	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e8	85 c0		 test	 eax, eax
  000ea	75 2d		 jne	 SHORT $LN9@s390_compa
$LN10@s390_compa:
  000ec	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fe	ba 07 00 00 00	 mov	 edx, 7
  00103	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00113	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_compa:

; 1530 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00119	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011d	83 e0 02	 and	 eax, 2
  00120	85 c0		 test	 eax, eax
  00122	75 0b		 jne	 SHORT $LN12@s390_compa
  00124	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	74 1b		 je	 SHORT $LN11@s390_compa
$LN12@s390_compa:
  0012f	ba 06 00 00 00	 mov	 edx, 6
  00134	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00144	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_compa:
$LN7@s390_compa:

; 1531 : 
; 1532 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  0014a	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0014e	d1 e0		 shl	 eax, 1
  00150	48 98		 cdqe
  00152	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00162	48 8b d0	 mov	 rdx, rax
  00165	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  0016a	e8 00 00 00 00	 call	 s390_get_float128
  0016f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00173	d1 e0		 shl	 eax, 1
  00175	48 98		 cdqe
  00177	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00187	48 8b d0	 mov	 rdx, rax
  0018a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0018f	e8 00 00 00 00	 call	 s390_get_float128
  00194	33 c0		 xor	 eax, eax
  00196	85 c0		 test	 eax, eax
  00198	75 b0		 jne	 SHORT $LN7@s390_compa

; 1533 : 
; 1534 :     softfloat_exceptionFlags = 0;

  0019a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019f	8b c0		 mov	 eax, eax
  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1535 :     newcc = FLOAT128_COMPARE_AND_SIGNAL( op1, op2 );

  001b8	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  001bd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001c2	48 8b f8	 mov	 rdi, rax
  001c5	48 8b f1	 mov	 rsi, rcx
  001c8	b9 10 00 00 00	 mov	 ecx, 16
  001cd	f3 a4		 rep movsb
  001cf	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  001d4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001d9	48 8b f8	 mov	 rdi, rax
  001dc	48 8b f1	 mov	 rsi, rcx
  001df	b9 10 00 00 00	 mov	 ecx, 16
  001e4	f3 a4		 rep movsb
  001e6	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  001eb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  001f0	e8 00 00 00 00	 call	 s390_float128_signaling_compare
  001f5	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1536 : 
; 1537 :     /* Xi is only trap that suppresses result, no return */
; 1538 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001f9	33 c0		 xor	 eax, eax
  001fb	83 f8 01	 cmp	 eax, 1
  001fe	74 4b		 je	 SHORT $LN13@s390_compa
  00200	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00205	8b c0		 mov	 eax, eax
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00216	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021e	83 e0 10	 and	 eax, 16
  00221	85 c0		 test	 eax, eax
  00223	74 26		 je	 SHORT $LN13@s390_compa
  00225	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00233	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0f		 je	 SHORT $LN13@s390_compa
  0023c	b2 80		 mov	 dl, 128			; 00000080H
  0023e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	e8 00 00 00 00	 call	 ieee_trap
$LN13@s390_compa:

; 1539 :     SET_FPC_FLAGS_FROM_SF( regs );

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00269	c1 e0 13	 shl	 eax, 19
  0026c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0027a	c1 e9 08	 shr	 ecx, 8
  0027d	f7 d1		 not	 ecx
  0027f	23 c1		 and	 eax, ecx
  00281	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00286	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00294	0b c8		 or	 ecx, eax
  00296	8b c1		 mov	 eax, ecx
  00298	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1540 :     regs->psw.cc = newcc;

  002a6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ae	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  002b3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1541 : }

  002b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002bb	48 33 cc	 xor	 rcx, rsp
  002be	e8 00 00 00 00	 call	 __security_check_cookie
  002c3	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002ca	5f		 pop	 rdi
  002cb	5e		 pop	 rsi
  002cc	c3		 ret	 0
s390_compare_and_signal_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ans$ = 32
ieee_trap_conds$ = 36
i$1 = 40
tv194 = 44
r1$ = 48
tv210 = 52
tv213 = 56
tv215 = 60
tv216 = 64
r2$ = 68
op2$ = 72
op1$ = 76
inst$ = 96
regs$ = 104
s390_add_bfp_short_reg PROC

; 1314 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1315 :     int        r1, r2;
; 1316 :     float32_t  op1, op2, ans;
; 1317 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1318 : 
; 1319 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_add_b:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@s390_add_b
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s390_add_b:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_add_b

; 1320 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1321 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN13@s390_add_b
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN12@s390_add_b
  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN12@s390_add_b
$LN13@s390_add_b:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_add_b:
$LN7@s390_add_b:

; 1322 : 
; 1323 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float32
  00111	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s390_get_float32
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s390_add_b

; 1324 : 
; 1325 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1326 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1327 : 
; 1328 :     ans = f32_add( op1, op2 );

  00191	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00195	8b 4c 24 4c	 mov	 ecx, DWORD PTR op1$[rsp]
  00199	e8 00 00 00 00	 call	 f32_add
  0019e	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax

; 1329 : 
; 1330 :     if (softfloat_exceptionFlags)

  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a7	8b c0		 mov	 eax, eax
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 93 00 00
	00		 je	 $LN14@s390_add_b

; 1331 :     {
; 1332 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001c8	33 c0		 xor	 eax, eax
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	74 45		 je	 SHORT $LN15@s390_add_b
  001cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d4	8b c0		 mov	 eax, eax
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	83 e0 10	 and	 eax, 16
  001f0	85 c0		 test	 eax, eax
  001f2	74 20		 je	 SHORT $LN15@s390_add_b
  001f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ff	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00204	85 c0		 test	 eax, eax
  00206	74 0c		 je	 SHORT $LN15@s390_add_b
  00208	b2 80		 mov	 dl, 128			; 00000080H
  0020a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	e8 00 00 00 00	 call	 ieee_trap
$LN15@s390_add_b:

; 1333 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00214	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0021e	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1334 : 
; 1335 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00222	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00226	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022b	85 c0		 test	 eax, eax
  0022d	74 2c		 je	 SHORT $LN16@s390_add_b

; 1336 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0022f	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00233	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN19@s390_add_b
  0023c	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv194[rsp], -192 ; ffffffffffffff40H
  00244	eb 08		 jmp	 SHORT $LN20@s390_add_b
$LN19@s390_add_b:
  00246	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv194[rsp], 192 ; 000000c0H
$LN20@s390_add_b:
  0024e	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv194[rsp]
  00252	e8 00 00 00 00	 call	 f32_scaledResult
  00257	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax
$LN16@s390_add_b:
$LN14@s390_add_b:
$LN10@s390_add_b:

; 1337 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 1338 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 1339 :     }
; 1340 : 
; 1341 :     PUT_FLOAT32_CC( ans, r1, regs );

  0025b	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0025f	d1 e0		 shl	 eax, 1
  00261	48 98		 cdqe
  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00270	48 8b d0	 mov	 rdx, rax
  00273	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ans$[rsp]
  00278	e8 00 00 00 00	 call	 s390_put_float32
  0027d	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00281	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00286	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0028b	75 17		 jne	 SHORT $LN21@s390_add_b
  0028d	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00291	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00296	85 c0		 test	 eax, eax
  00298	74 0a		 je	 SHORT $LN21@s390_add_b
  0029a	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv216[rsp], 3
  002a2	eb 5e		 jmp	 SHORT $LN28@s390_add_b
$LN21@s390_add_b:
  002a4	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  002a8	0f ba f0 1f	 btr	 eax, 31
  002ac	85 c0		 test	 eax, eax
  002ae	75 0a		 jne	 SHORT $LN22@s390_add_b
  002b0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  002b8	eb 08		 jmp	 SHORT $LN23@s390_add_b
$LN22@s390_add_b:
  002ba	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN23@s390_add_b:
  002c2	83 7c 24 34 00	 cmp	 DWORD PTR tv210[rsp], 0
  002c7	74 0a		 je	 SHORT $LN26@s390_add_b
  002c9	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  002d1	eb 27		 jmp	 SHORT $LN27@s390_add_b
$LN26@s390_add_b:
  002d3	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  002d7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002dc	85 c0		 test	 eax, eax
  002de	74 0a		 je	 SHORT $LN24@s390_add_b
  002e0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  002e8	eb 08		 jmp	 SHORT $LN25@s390_add_b
$LN24@s390_add_b:
  002ea	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv213[rsp], 2
$LN25@s390_add_b:
  002f2	8b 44 24 38	 mov	 eax, DWORD PTR tv213[rsp]
  002f6	89 44 24 3c	 mov	 DWORD PTR tv215[rsp], eax
$LN27@s390_add_b:
  002fa	8b 44 24 3c	 mov	 eax, DWORD PTR tv215[rsp]
  002fe	89 44 24 40	 mov	 DWORD PTR tv216[rsp], eax
$LN28@s390_add_b:
  00302	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00307	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv216[rsp]
  0030c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0030f	33 c0		 xor	 eax, eax
  00311	85 c0		 test	 eax, eax
  00313	0f 85 42 ff ff
	ff		 jne	 $LN10@s390_add_b

; 1342 : 
; 1343 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00319	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0031d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00322	85 c0		 test	 eax, eax
  00324	74 0e		 je	 SHORT $LN17@s390_add_b
  00326	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0032a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0032f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s390_add_b:

; 1344 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1345 : }

  00334	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00338	c3		 ret	 0
s390_add_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ans$ = 36
ieee_trap_conds$ = 40
temp$1 = 44
b2$ = 48
x2$ = 52
tv211 = 56
r1$ = 60
tv227 = 64
tv230 = 68
tv232 = 72
tv233 = 76
op2$ = 80
op1$ = 84
inst$ = 112
regs$ = 120
s390_add_bfp_short PROC

; 1351 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1352 :     int         r1, x2, b2;
; 1353 :     VADR       effective_addr2;
; 1354 :     float32_t  op1, op2, ans;
; 1355 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1356 : 
; 1357 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 34 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN8@s390_add_b
  0005b	48 63 44 24 34	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s390_add_b:
  00078	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN9@s390_add_b
  0008d	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_add_b:
  000aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000af	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_add_b:
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ca	48 83 c0 06	 add	 rax, 6
  000ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 06	 cmp	 eax, 6
  000dc	74 0c		 je	 SHORT $LN10@s390_add_b
  000de	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_add_b:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 d1		 jne	 SHORT $LN4@s390_add_b

; 1358 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1359 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1360 :     BFPINST_CHECK( regs );

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	48 6b c0 01	 imul	 rax, rax, 1
  000f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00105	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $LN12@s390_add_b
  0010e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00113	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00119	d1 e8		 shr	 eax, 1
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 49		 je	 SHORT $LN11@s390_add_b
  00122	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	48 6b c9 01	 imul	 rcx, rcx, 1
  00137	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0013e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN11@s390_add_b
$LN12@s390_add_b:
  00147	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00156	ba 07 00 00 00	 mov	 edx, 7
  0015b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00165	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_add_b:

; 1361 : 
; 1362 :     GET_FLOAT32_OP( op1, r1, regs );

  0016b	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0016f	d1 e0		 shl	 eax, 1
  00171	48 98		 cdqe
  00173	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00180	48 8b d0	 mov	 rdx, rax
  00183	48 8d 4c 24 54	 lea	 rcx, QWORD PTR op1$[rsp]
  00188	e8 00 00 00 00	 call	 s390_get_float32

; 1363 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0018d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00192	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  00196	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019a	e8 00 00 00 00	 call	 s390_vfetch4
  0019f	89 44 24 50	 mov	 DWORD PTR op2$[rsp], eax

; 1364 : 
; 1365 :     softfloat_exceptionFlags = 0;

  001a3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a8	8b c0		 mov	 eax, eax
  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1366 :     SET_SF_RM_FROM_FPC;

  001c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cc	83 e0 07	 and	 eax, 7
  001cf	8b c0		 mov	 eax, eax
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001d8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001dd	8b d2		 mov	 edx, edx
  001df	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001e6	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001ef	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f7	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1367 : 
; 1368 :     ans = f32_add( op1, op2 );

  001fb	8b 54 24 50	 mov	 edx, DWORD PTR op2$[rsp]
  001ff	8b 4c 24 54	 mov	 ecx, DWORD PTR op1$[rsp]
  00203	e8 00 00 00 00	 call	 f32_add
  00208	89 44 24 24	 mov	 DWORD PTR ans$[rsp], eax

; 1369 : 
; 1370 :     if (softfloat_exceptionFlags)

  0020c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00211	8b c0		 mov	 eax, eax
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00219	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00222	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00226	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022a	85 c0		 test	 eax, eax
  0022c	0f 84 93 00 00
	00		 je	 $LN13@s390_add_b

; 1371 :     {
; 1372 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00232	33 c0		 xor	 eax, eax
  00234	83 f8 01	 cmp	 eax, 1
  00237	74 45		 je	 SHORT $LN14@s390_add_b
  00239	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023e	8b c0		 mov	 eax, eax
  00240	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00246	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00253	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00257	83 e0 10	 and	 eax, 16
  0025a	85 c0		 test	 eax, eax
  0025c	74 20		 je	 SHORT $LN14@s390_add_b
  0025e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00263	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00269	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0026e	85 c0		 test	 eax, eax
  00270	74 0c		 je	 SHORT $LN14@s390_add_b
  00272	b2 80		 mov	 dl, 128			; 00000080H
  00274	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_add_b:

; 1373 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0027e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00283	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00288	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1374 : 
; 1375 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0028c	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00290	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00295	85 c0		 test	 eax, eax
  00297	74 2c		 je	 SHORT $LN15@s390_add_b

; 1376 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00299	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0029d	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002a2	85 c0		 test	 eax, eax
  002a4	74 0a		 je	 SHORT $LN18@s390_add_b
  002a6	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv211[rsp], -192 ; ffffffffffffff40H
  002ae	eb 08		 jmp	 SHORT $LN19@s390_add_b
$LN18@s390_add_b:
  002b0	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv211[rsp], 192 ; 000000c0H
$LN19@s390_add_b:
  002b8	8b 4c 24 38	 mov	 ecx, DWORD PTR tv211[rsp]
  002bc	e8 00 00 00 00	 call	 f32_scaledResult
  002c1	89 44 24 24	 mov	 DWORD PTR ans$[rsp], eax
$LN15@s390_add_b:
$LN13@s390_add_b:
$LN7@s390_add_b:

; 1377 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 1378 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 1379 :     }
; 1380 : 
; 1381 :     PUT_FLOAT32_CC( ans, r1, regs );

  002c5	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  002c9	d1 e0		 shl	 eax, 1
  002cb	48 98		 cdqe
  002cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002da	48 8b d0	 mov	 rdx, rax
  002dd	48 8d 4c 24 24	 lea	 rcx, QWORD PTR ans$[rsp]
  002e2	e8 00 00 00 00	 call	 s390_put_float32
  002e7	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  002eb	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  002f0	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  002f5	75 17		 jne	 SHORT $LN20@s390_add_b
  002f7	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  002fb	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00300	85 c0		 test	 eax, eax
  00302	74 0a		 je	 SHORT $LN20@s390_add_b
  00304	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv233[rsp], 3
  0030c	eb 5e		 jmp	 SHORT $LN27@s390_add_b
$LN20@s390_add_b:
  0030e	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  00312	0f ba f0 1f	 btr	 eax, 31
  00316	85 c0		 test	 eax, eax
  00318	75 0a		 jne	 SHORT $LN21@s390_add_b
  0031a	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv227[rsp], 1
  00322	eb 08		 jmp	 SHORT $LN22@s390_add_b
$LN21@s390_add_b:
  00324	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv227[rsp], 0
$LN22@s390_add_b:
  0032c	83 7c 24 40 00	 cmp	 DWORD PTR tv227[rsp], 0
  00331	74 0a		 je	 SHORT $LN25@s390_add_b
  00333	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
  0033b	eb 27		 jmp	 SHORT $LN26@s390_add_b
$LN25@s390_add_b:
  0033d	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  00341	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00346	85 c0		 test	 eax, eax
  00348	74 0a		 je	 SHORT $LN23@s390_add_b
  0034a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
  00352	eb 08		 jmp	 SHORT $LN24@s390_add_b
$LN23@s390_add_b:
  00354	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv230[rsp], 2
$LN24@s390_add_b:
  0035c	8b 44 24 44	 mov	 eax, DWORD PTR tv230[rsp]
  00360	89 44 24 48	 mov	 DWORD PTR tv232[rsp], eax
$LN26@s390_add_b:
  00364	8b 44 24 48	 mov	 eax, DWORD PTR tv232[rsp]
  00368	89 44 24 4c	 mov	 DWORD PTR tv233[rsp], eax
$LN27@s390_add_b:
  0036c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00371	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv233[rsp]
  00376	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00379	33 c0		 xor	 eax, eax
  0037b	85 c0		 test	 eax, eax
  0037d	0f 85 42 ff ff
	ff		 jne	 $LN7@s390_add_b

; 1382 : 
; 1383 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00383	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00387	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0038c	85 c0		 test	 eax, eax
  0038e	74 0e		 je	 SHORT $LN16@s390_add_b
  00390	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00394	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00399	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_add_b:

; 1384 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1385 : }

  0039e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003a2	c3		 ret	 0
s390_add_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
ans$ = 40
i$1 = 48
tv194 = 52
r1$ = 56
tv210 = 60
tv213 = 64
tv215 = 68
tv216 = 72
r2$ = 76
op2$ = 80
op1$ = 88
inst$ = 112
regs$ = 120
s390_add_bfp_long_reg PROC

; 1237 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1238 :     int        r1, r2;
; 1239 :     float64_t  op1, op2, ans;
; 1240 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1241 : 
; 1242 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_add_b:
  00045	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@s390_add_b
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s390_add_b:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s390_add_b

; 1243 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1244 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN13@s390_add_b
  00092	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN12@s390_add_b
  000a6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN12@s390_add_b
$LN13@s390_add_b:
  000cb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_add_b:
$LN7@s390_add_b:

; 1245 : 
; 1246 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_get_float64
  00111	8b 44 24 4c	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s390_get_float64
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s390_add_b

; 1247 : 
; 1248 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1249 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1250 : 
; 1251 :     ans = f64_add( op1, op2 );

  00191	48 8b 54 24 50	 mov	 rdx, QWORD PTR op2$[rsp]
  00196	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 f64_add
  001a0	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax

; 1252 : 
; 1253 :     if (softfloat_exceptionFlags)

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 94 00 00
	00		 je	 $LN14@s390_add_b

; 1254 :     {
; 1255 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001cb	33 c0		 xor	 eax, eax
  001cd	83 f8 01	 cmp	 eax, 1
  001d0	74 45		 je	 SHORT $LN15@s390_add_b
  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	83 e0 10	 and	 eax, 16
  001f3	85 c0		 test	 eax, eax
  001f5	74 20		 je	 SHORT $LN15@s390_add_b
  001f7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00202	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00207	85 c0		 test	 eax, eax
  00209	74 0c		 je	 SHORT $LN15@s390_add_b
  0020b	b2 80		 mov	 dl, 128			; 00000080H
  0020d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_trap
$LN15@s390_add_b:

; 1256 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00217	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00221	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1257 : 
; 1258 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00225	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00229	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022e	85 c0		 test	 eax, eax
  00230	74 2d		 je	 SHORT $LN16@s390_add_b

; 1259 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00232	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00236	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0023b	85 c0		 test	 eax, eax
  0023d	74 0a		 je	 SHORT $LN19@s390_add_b
  0023f	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv194[rsp], -1536 ; fffffffffffffa00H
  00247	eb 08		 jmp	 SHORT $LN20@s390_add_b
$LN19@s390_add_b:
  00249	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv194[rsp], 1536 ; 00000600H
$LN20@s390_add_b:
  00251	8b 4c 24 34	 mov	 ecx, DWORD PTR tv194[rsp]
  00255	e8 00 00 00 00	 call	 f64_scaledResult
  0025a	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax
$LN16@s390_add_b:
$LN14@s390_add_b:
$LN10@s390_add_b:

; 1260 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 1261 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 1262 :     }
; 1263 : 
; 1264 :     PUT_FLOAT64_CC( ans, r1, regs );

  0025f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00263	d1 e0		 shl	 eax, 1
  00265	48 98		 cdqe
  00267	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00274	48 8b d0	 mov	 rdx, rax
  00277	48 8d 4c 24 28	 lea	 rcx, QWORD PTR ans$[rsp]
  0027c	e8 00 00 00 00	 call	 s390_put_float64
  00281	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0028b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00290	48 23 c8	 and	 rcx, rax
  00293	48 8b c1	 mov	 rax, rcx
  00296	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  002a0	48 3b c1	 cmp	 rax, rcx
  002a3	75 24		 jne	 SHORT $LN21@s390_add_b
  002a5	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  002af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  002b4	48 23 c8	 and	 rcx, rax
  002b7	48 8b c1	 mov	 rax, rcx
  002ba	48 85 c0	 test	 rax, rax
  002bd	74 0a		 je	 SHORT $LN21@s390_add_b
  002bf	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR tv216[rsp], 3
  002c7	eb 79		 jmp	 SHORT $LN28@s390_add_b
$LN21@s390_add_b:
  002c9	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  002d8	48 23 c8	 and	 rcx, rax
  002db	48 8b c1	 mov	 rax, rcx
  002de	48 85 c0	 test	 rax, rax
  002e1	75 0a		 jne	 SHORT $LN22@s390_add_b
  002e3	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  002eb	eb 08		 jmp	 SHORT $LN23@s390_add_b
$LN22@s390_add_b:
  002ed	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN23@s390_add_b:
  002f5	83 7c 24 3c 00	 cmp	 DWORD PTR tv210[rsp], 0
  002fa	74 0a		 je	 SHORT $LN26@s390_add_b
  002fc	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  00304	eb 34		 jmp	 SHORT $LN27@s390_add_b
$LN26@s390_add_b:
  00306	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00310	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00315	48 23 c8	 and	 rcx, rax
  00318	48 8b c1	 mov	 rax, rcx
  0031b	48 85 c0	 test	 rax, rax
  0031e	74 0a		 je	 SHORT $LN24@s390_add_b
  00320	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  00328	eb 08		 jmp	 SHORT $LN25@s390_add_b
$LN24@s390_add_b:
  0032a	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv213[rsp], 2
$LN25@s390_add_b:
  00332	8b 44 24 40	 mov	 eax, DWORD PTR tv213[rsp]
  00336	89 44 24 44	 mov	 DWORD PTR tv215[rsp], eax
$LN27@s390_add_b:
  0033a	8b 44 24 44	 mov	 eax, DWORD PTR tv215[rsp]
  0033e	89 44 24 48	 mov	 DWORD PTR tv216[rsp], eax
$LN28@s390_add_b:
  00342	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00347	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv216[rsp]
  0034c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0034f	33 c0		 xor	 eax, eax
  00351	85 c0		 test	 eax, eax
  00353	0f 85 06 ff ff
	ff		 jne	 $LN10@s390_add_b

; 1265 : 
; 1266 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00359	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0035d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00362	85 c0		 test	 eax, eax
  00364	74 0e		 je	 SHORT $LN17@s390_add_b
  00366	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0036a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0036f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s390_add_b:

; 1267 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1268 : }

  00374	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00378	c3		 ret	 0
s390_add_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
ans$ = 48
x2$ = 56
tv211 = 60
r1$ = 64
tv227 = 68
tv230 = 72
tv232 = 76
tv233 = 80
op2$ = 88
op1$ = 96
inst$ = 128
regs$ = 136
s390_add_bfp_long PROC

; 1274 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1275 :     int        r1, x2, b2;
; 1276 :     VADR       effective_addr2;
; 1277 :     float64_t  op1, op2, ans;
; 1278 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1279 : 
; 1280 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00037	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 20		 je	 SHORT $LN8@s390_add_b
  0005e	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00072	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00076	03 c8		 add	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s390_add_b:
  0007e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 20		 je	 SHORT $LN9@s390_add_b
  00093	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ab	03 c8		 add	 ecx, eax
  000ad	8b c1		 mov	 eax, ecx
  000af	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_add_b:
  000b3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000c1	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000c5	23 c8		 and	 ecx, eax
  000c7	8b c1		 mov	 eax, ecx
  000c9	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s390_add_b:
  000cd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0f		 je	 SHORT $LN10@s390_add_b
  000f0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_add_b:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 c8		 jne	 SHORT $LN4@s390_add_b

; 1281 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1282 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1283 :     BFPINST_CHECK( regs );

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00122	85 c0		 test	 eax, eax
  00124	74 3f		 je	 SHORT $LN12@s390_add_b
  00126	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	d1 e8		 shr	 eax, 1
  00136	83 e0 01	 and	 eax, 1
  00139	85 c0		 test	 eax, eax
  0013b	74 55		 je	 SHORT $LN11@s390_add_b
  0013d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00161	85 c0		 test	 eax, eax
  00163	75 2d		 jne	 SHORT $LN11@s390_add_b
$LN12@s390_add_b:
  00165	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_add_b:

; 1284 : 
; 1285 :     GET_FLOAT64_OP( op1, r1, regs );

  00192	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  00196	d1 e0		 shl	 eax, 1
  00198	48 98		 cdqe
  0019a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001aa	48 8b d0	 mov	 rdx, rax
  001ad	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001b2	e8 00 00 00 00	 call	 s390_get_float64

; 1286 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001b7	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001bf	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001c3	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001c7	e8 00 00 00 00	 call	 s390_vfetch8
  001cc	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 1287 : 
; 1288 :     softfloat_exceptionFlags = 0;

  001d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d6	8b c0		 mov	 eax, eax
  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001de	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001eb	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1289 :     SET_SF_RM_FROM_FPC;

  001ef	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001fd	83 e0 07	 and	 eax, 7
  00200	8b c0		 mov	 eax, eax
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00209	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0020e	8b d2		 mov	 edx, edx
  00210	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00217	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00220	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1290 : 
; 1291 :     ans = f64_add( op1, op2 );

  0022c	48 8b 54 24 58	 mov	 rdx, QWORD PTR op2$[rsp]
  00231	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  00236	e8 00 00 00 00	 call	 f64_add
  0023b	48 89 44 24 30	 mov	 QWORD PTR ans$[rsp], rax

; 1292 : 
; 1293 :     if (softfloat_exceptionFlags)

  00240	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00245	8b c0		 mov	 eax, eax
  00247	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0024d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00256	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025e	85 c0		 test	 eax, eax
  00260	0f 84 9d 00 00
	00		 je	 $LN13@s390_add_b

; 1294 :     {
; 1295 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00266	33 c0		 xor	 eax, eax
  00268	83 f8 01	 cmp	 eax, 1
  0026b	74 4b		 je	 SHORT $LN14@s390_add_b
  0026d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00272	8b c0		 mov	 eax, eax
  00274	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0027a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00283	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00287	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028b	83 e0 10	 and	 eax, 16
  0028e	85 c0		 test	 eax, eax
  00290	74 26		 je	 SHORT $LN14@s390_add_b
  00292	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002a0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002a5	85 c0		 test	 eax, eax
  002a7	74 0f		 je	 SHORT $LN14@s390_add_b
  002a9	b2 80		 mov	 dl, 128			; 00000080H
  002ab	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	e8 00 00 00 00	 call	 ieee_trap
$LN14@s390_add_b:

; 1296 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c0	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002c5	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1297 : 
; 1298 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002c9	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cd	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002d2	85 c0		 test	 eax, eax
  002d4	74 2d		 je	 SHORT $LN15@s390_add_b

; 1299 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002d6	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002da	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002df	85 c0		 test	 eax, eax
  002e1	74 0a		 je	 SHORT $LN18@s390_add_b
  002e3	c7 44 24 3c 00
	fa ff ff	 mov	 DWORD PTR tv211[rsp], -1536 ; fffffffffffffa00H
  002eb	eb 08		 jmp	 SHORT $LN19@s390_add_b
$LN18@s390_add_b:
  002ed	c7 44 24 3c 00
	06 00 00	 mov	 DWORD PTR tv211[rsp], 1536 ; 00000600H
$LN19@s390_add_b:
  002f5	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv211[rsp]
  002f9	e8 00 00 00 00	 call	 f64_scaledResult
  002fe	48 89 44 24 30	 mov	 QWORD PTR ans$[rsp], rax
$LN15@s390_add_b:
$LN13@s390_add_b:
$LN7@s390_add_b:

; 1300 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 1301 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 1302 :     }
; 1303 : 
; 1304 :     PUT_FLOAT64_CC( ans, r1, regs );

  00303	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  00307	d1 e0		 shl	 eax, 1
  00309	48 98		 cdqe
  0030b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00313	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0031b	48 8b d0	 mov	 rdx, rax
  0031e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  00323	e8 00 00 00 00	 call	 s390_put_float64
  00328	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00332	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  00337	48 23 c8	 and	 rcx, rax
  0033a	48 8b c1	 mov	 rax, rcx
  0033d	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00347	48 3b c1	 cmp	 rax, rcx
  0034a	75 24		 jne	 SHORT $LN20@s390_add_b
  0034c	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00356	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  0035b	48 23 c8	 and	 rcx, rax
  0035e	48 8b c1	 mov	 rax, rcx
  00361	48 85 c0	 test	 rax, rax
  00364	74 0a		 je	 SHORT $LN20@s390_add_b
  00366	c7 44 24 50 03
	00 00 00	 mov	 DWORD PTR tv233[rsp], 3
  0036e	eb 79		 jmp	 SHORT $LN27@s390_add_b
$LN20@s390_add_b:
  00370	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0037a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  0037f	48 23 c8	 and	 rcx, rax
  00382	48 8b c1	 mov	 rax, rcx
  00385	48 85 c0	 test	 rax, rax
  00388	75 0a		 jne	 SHORT $LN21@s390_add_b
  0038a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv227[rsp], 1
  00392	eb 08		 jmp	 SHORT $LN22@s390_add_b
$LN21@s390_add_b:
  00394	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv227[rsp], 0
$LN22@s390_add_b:
  0039c	83 7c 24 44 00	 cmp	 DWORD PTR tv227[rsp], 0
  003a1	74 0a		 je	 SHORT $LN25@s390_add_b
  003a3	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
  003ab	eb 34		 jmp	 SHORT $LN26@s390_add_b
$LN25@s390_add_b:
  003ad	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  003b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  003bc	48 23 c8	 and	 rcx, rax
  003bf	48 8b c1	 mov	 rax, rcx
  003c2	48 85 c0	 test	 rax, rax
  003c5	74 0a		 je	 SHORT $LN23@s390_add_b
  003c7	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
  003cf	eb 08		 jmp	 SHORT $LN24@s390_add_b
$LN23@s390_add_b:
  003d1	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv230[rsp], 2
$LN24@s390_add_b:
  003d9	8b 44 24 48	 mov	 eax, DWORD PTR tv230[rsp]
  003dd	89 44 24 4c	 mov	 DWORD PTR tv232[rsp], eax
$LN26@s390_add_b:
  003e1	8b 44 24 4c	 mov	 eax, DWORD PTR tv232[rsp]
  003e5	89 44 24 50	 mov	 DWORD PTR tv233[rsp], eax
$LN27@s390_add_b:
  003e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f1	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv233[rsp]
  003f6	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  003f9	33 c0		 xor	 eax, eax
  003fb	85 c0		 test	 eax, eax
  003fd	0f 85 00 ff ff
	ff		 jne	 $LN7@s390_add_b

; 1305 : 
; 1306 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00403	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00407	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0040c	85 c0		 test	 eax, eax
  0040e	74 11		 je	 SHORT $LN16@s390_add_b
  00410	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00414	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s390_add_b:

; 1307 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1308 : }

  00421	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00425	c3		 ret	 0
s390_add_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv203 = 48
tv233 = 52
tv238 = 56
tv240 = 60
tv241 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
ans$ = 144
op2$ = 160
op1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
s390_add_bfp_ext_reg PROC

; 1198 : {

$LN32:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1199 :     int         r1, r2;
; 1200 :     float128_t  op1, op2, ans;
; 1201 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1202 : 
; 1203 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_add_b:
  0005f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN11@s390_add_b
  00082	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s390_add_b:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@s390_add_b

; 1204 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1205 :     BFPINST_CHECK( regs );

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 3f		 je	 SHORT $LN13@s390_add_b
  000b8	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c6	d1 e8		 shr	 eax, 1
  000c8	83 e0 01	 and	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 55		 je	 SHORT $LN12@s390_add_b
  000cf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	b9 08 00 00 00	 mov	 ecx, 8
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ee	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f3	85 c0		 test	 eax, eax
  000f5	75 2d		 jne	 SHORT $LN12@s390_add_b
$LN13@s390_add_b:
  000f7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00109	ba 07 00 00 00	 mov	 edx, 7
  0010e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_add_b:

; 1206 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00124	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN15@s390_add_b
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 02	 and	 eax, 2
  00136	85 c0		 test	 eax, eax
  00138	74 1b		 je	 SHORT $LN14@s390_add_b
$LN15@s390_add_b:
  0013a	ba 06 00 00 00	 mov	 edx, 6
  0013f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@s390_add_b:
$LN7@s390_add_b:

; 1207 : 
; 1208 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  00155	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00159	d1 e0		 shl	 eax, 1
  0015b	48 98		 cdqe
  0015d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00178	e8 00 00 00 00	 call	 s390_get_float128
  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00181	d1 e0		 shl	 eax, 1
  00183	48 98		 cdqe
  00185	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001a0	e8 00 00 00 00	 call	 s390_get_float128
  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 aa		 jne	 SHORT $LN7@s390_add_b

; 1209 : 
; 1210 :     softfloat_exceptionFlags = 0;

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b0	8b c0		 mov	 eax, eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1211 :     SET_SF_RM_FROM_FPC;

  001c9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d7	83 e0 07	 and	 eax, 7
  001da	8b c0		 mov	 eax, eax
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001e8	8b d2		 mov	 edx, edx
  001ea	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001f1	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001fa	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00202	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1212 : 
; 1213 :     ans = f128_add( op1, op2 );

  00206	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  0020b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  00213	48 8b f8	 mov	 rdi, rax
  00216	48 8b f1	 mov	 rsi, rcx
  00219	b9 10 00 00 00	 mov	 ecx, 16
  0021e	f3 a4		 rep movsb
  00220	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  00225	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  0022d	48 8b f8	 mov	 rdi, rax
  00230	48 8b f1	 mov	 rsi, rcx
  00233	b9 10 00 00 00	 mov	 ecx, 16
  00238	f3 a4		 rep movsb
  0023a	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  0023f	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  00244	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  00249	e8 00 00 00 00	 call	 f128_add
  0024e	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00256	48 8b f9	 mov	 rdi, rcx
  00259	48 8b f0	 mov	 rsi, rax
  0025c	b9 10 00 00 00	 mov	 ecx, 16
  00261	f3 a4		 rep movsb

; 1214 : 
; 1215 :     if (softfloat_exceptionFlags)

  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	85 c0		 test	 eax, eax
  00283	0f 84 b5 00 00
	00		 je	 $LN16@s390_add_b

; 1216 :     {
; 1217 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00289	33 c0		 xor	 eax, eax
  0028b	83 f8 01	 cmp	 eax, 1
  0028e	74 4b		 je	 SHORT $LN17@s390_add_b
  00290	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00295	8b c0		 mov	 eax, eax
  00297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ae	83 e0 10	 and	 eax, 16
  002b1	85 c0		 test	 eax, eax
  002b3	74 26		 je	 SHORT $LN17@s390_add_b
  002b5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002c8	85 c0		 test	 eax, eax
  002ca	74 0f		 je	 SHORT $LN17@s390_add_b
  002cc	b2 80		 mov	 dl, 128			; 00000080H
  002ce	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 ieee_trap
$LN17@s390_add_b:

; 1218 : 
; 1219 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002db	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002e8	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1220 : 
; 1221 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ec	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002f5	85 c0		 test	 eax, eax
  002f7	74 45		 je	 SHORT $LN18@s390_add_b

; 1222 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002f9	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002fd	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00302	85 c0		 test	 eax, eax
  00304	74 0a		 je	 SHORT $LN21@s390_add_b
  00306	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv203[rsp], -24576 ; ffffffffffffa000H
  0030e	eb 08		 jmp	 SHORT $LN22@s390_add_b
$LN21@s390_add_b:
  00310	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv203[rsp], 24576 ; 00006000H
$LN22@s390_add_b:
  00318	8b 54 24 30	 mov	 edx, DWORD PTR tv203[rsp]
  0031c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00324	e8 00 00 00 00	 call	 f128_scaledResult
  00329	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00331	48 8b f9	 mov	 rdi, rcx
  00334	48 8b f0	 mov	 rsi, rax
  00337	b9 10 00 00 00	 mov	 ecx, 16
  0033c	f3 a4		 rep movsb
$LN18@s390_add_b:
$LN16@s390_add_b:
$LN10@s390_add_b:

; 1223 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 1224 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 1225 :     }
; 1226 : 
; 1227 :     PUT_FLOAT128_CC( ans, r1, regs );

  0033e	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00342	d1 e0		 shl	 eax, 1
  00344	48 98		 cdqe
  00346	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00356	48 8b d0	 mov	 rdx, rax
  00359	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00361	e8 00 00 00 00	 call	 s390_put_float128
  00366	b8 08 00 00 00	 mov	 eax, 8
  0036b	48 6b c0 01	 imul	 rax, rax, 1
  0036f	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00379	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  00381	48 23 c1	 and	 rax, rcx
  00384	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0038e	48 3b c1	 cmp	 rax, rcx
  00391	75 44		 jne	 SHORT $LN24@s390_add_b
  00393	b8 08 00 00 00	 mov	 eax, 8
  00398	48 6b c0 01	 imul	 rax, rax, 1
  0039c	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  003a6	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  003ae	48 23 c1	 and	 rax, rcx
  003b1	48 85 c0	 test	 rax, rax
  003b4	75 14		 jne	 SHORT $LN23@s390_add_b
  003b6	b8 08 00 00 00	 mov	 eax, 8
  003bb	48 6b c0 00	 imul	 rax, rax, 0
  003bf	48 83 bc 04 90
	00 00 00 00	 cmp	 QWORD PTR ans$[rsp+rax], 0
  003c8	74 0d		 je	 SHORT $LN24@s390_add_b
$LN23@s390_add_b:
  003ca	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv241[rsp], 3
  003d2	e9 9c 00 00 00	 jmp	 $LN31@s390_add_b
$LN24@s390_add_b:
  003d7	b8 08 00 00 00	 mov	 eax, 8
  003dc	48 6b c0 01	 imul	 rax, rax, 1
  003e0	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  003ea	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  003f2	48 23 c1	 and	 rax, rcx
  003f5	b9 08 00 00 00	 mov	 ecx, 8
  003fa	48 6b c9 00	 imul	 rcx, rcx, 0
  003fe	48 0b 84 0c 90
	00 00 00	 or	 rax, QWORD PTR ans$[rsp+rcx]
  00406	48 85 c0	 test	 rax, rax
  00409	75 0a		 jne	 SHORT $LN25@s390_add_b
  0040b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  00413	eb 08		 jmp	 SHORT $LN26@s390_add_b
$LN25@s390_add_b:
  00415	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
$LN26@s390_add_b:
  0041d	83 7c 24 34 00	 cmp	 DWORD PTR tv233[rsp], 0
  00422	74 0a		 je	 SHORT $LN29@s390_add_b
  00424	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv240[rsp], 0
  0042c	eb 3d		 jmp	 SHORT $LN30@s390_add_b
$LN29@s390_add_b:
  0042e	b8 08 00 00 00	 mov	 eax, 8
  00433	48 6b c0 01	 imul	 rax, rax, 1
  00437	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00441	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  00449	48 23 c1	 and	 rax, rcx
  0044c	48 85 c0	 test	 rax, rax
  0044f	74 0a		 je	 SHORT $LN27@s390_add_b
  00451	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv238[rsp], 1
  00459	eb 08		 jmp	 SHORT $LN28@s390_add_b
$LN27@s390_add_b:
  0045b	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv238[rsp], 2
$LN28@s390_add_b:
  00463	8b 44 24 38	 mov	 eax, DWORD PTR tv238[rsp]
  00467	89 44 24 3c	 mov	 DWORD PTR tv240[rsp], eax
$LN30@s390_add_b:
  0046b	8b 44 24 3c	 mov	 eax, DWORD PTR tv240[rsp]
  0046f	89 44 24 40	 mov	 DWORD PTR tv241[rsp], eax
$LN31@s390_add_b:
  00473	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047b	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv241[rsp]
  00480	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00483	33 c0		 xor	 eax, eax
  00485	85 c0		 test	 eax, eax
  00487	0f 85 b1 fe ff
	ff		 jne	 $LN10@s390_add_b

; 1228 : 
; 1229 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0048d	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00491	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00496	85 c0		 test	 eax, eax
  00498	74 11		 je	 SHORT $LN19@s390_add_b
  0049a	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0049e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a6	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@s390_add_b:

; 1230 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1231 : }

  004ab	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004b3	48 33 cc	 xor	 rcx, rsp
  004b6	e8 00 00 00 00	 call	 __security_check_cookie
  004bb	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  004c2	5f		 pop	 rdi
  004c3	5e		 pop	 rsi
  004c4	c3		 ret	 0
s390_add_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv68 = 0
op$ = 32
fpr$ = 40
put_sbfp PROC

; 844  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 845  :     fpr[0] = (op->sign ? 1 << 31 : 0) | (op->exp << 23) | op->fract;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	74 09		 je	 SHORT $LN3@put_sbfp
  00018	c7 04 24 00 00
	00 80		 mov	 DWORD PTR tv68[rsp], -2147483648 ; ffffffff80000000H
  0001f	eb 07		 jmp	 SHORT $LN4@put_sbfp
$LN3@put_sbfp:
  00021	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN4@put_sbfp:
  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00030	c1 e0 17	 shl	 eax, 23
  00033	8b 0c 24	 mov	 ecx, DWORD PTR tv68[rsp]
  00036	0b c8		 or	 ecx, eax
  00038	8b c1		 mov	 eax, ecx
  0003a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  0003f	0b 41 08	 or	 eax, DWORD PTR [rcx+8]
  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	48 6b c9 00	 imul	 rcx, rcx, 0
  0004b	48 8b 54 24 28	 mov	 rdx, QWORD PTR fpr$[rsp]
  00050	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 846  : 
; 847  :     //logmsg("sput exp=%d fract=%x r=%8.8x\n", op->exp, op->fract, *fpr);
; 848  : }

  00053	48 83 c4 18	 add	 rsp, 24
  00057	c3		 ret	 0
put_sbfp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv68 = 0
op$ = 32
fpr$ = 40
put_lbfp PROC

; 836  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 837  :     fpr[0] = (op->sign ? 1 << 31 : 0) | (op->exp << 20) | (op->fract >> 32);

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	74 09		 je	 SHORT $LN3@put_lbfp
  00018	c7 04 24 00 00
	00 80		 mov	 DWORD PTR tv68[rsp], -2147483648 ; ffffffff80000000H
  0001f	eb 07		 jmp	 SHORT $LN4@put_lbfp
$LN3@put_lbfp:
  00021	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN4@put_lbfp:
  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00030	c1 e0 14	 shl	 eax, 20
  00033	8b 0c 24	 mov	 ecx, DWORD PTR tv68[rsp]
  00036	0b c8		 or	 ecx, eax
  00038	8b c1		 mov	 eax, ecx
  0003a	48 98		 cdqe
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  00041	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00045	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  00049	48 0b c1	 or	 rax, rcx
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	48 6b c9 00	 imul	 rcx, rcx, 0
  00055	48 8b 54 24 28	 mov	 rdx, QWORD PTR fpr$[rsp]
  0005a	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 838  :     fpr[1] = op->fract & 0xFFFFFFFF;

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  00062	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00067	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006b	48 23 c1	 and	 rax, rcx
  0006e	b9 04 00 00 00	 mov	 ecx, 4
  00073	48 6b c9 01	 imul	 rcx, rcx, 1
  00077	48 8b 54 24 28	 mov	 rdx, QWORD PTR fpr$[rsp]
  0007c	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 839  : 
; 840  :     //logmsg("lput exp=%d fract=%"PRIx64" r=%8.8x%8.8x\n", op->exp, op->fract, fpr[0], fpr[1]);
; 841  : }

  0007f	48 83 c4 18	 add	 rsp, 24
  00083	c3		 ret	 0
put_lbfp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv67 = 0
op$ = 32
fpr$ = 40
get_sbfp PROC

; 824  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 825  :     op->sign  = (*fpr & 0x80000000) != 0;

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR fpr$[rsp]
  00013	8b 00		 mov	 eax, DWORD PTR [rax]
  00015	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0001a	85 c0		 test	 eax, eax
  0001c	74 09		 je	 SHORT $LN3@get_sbfp
  0001e	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00025	eb 07		 jmp	 SHORT $LN4@get_sbfp
$LN3@get_sbfp:
  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@get_sbfp:
  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  00033	8b 0c 24	 mov	 ecx, DWORD PTR tv67[rsp]
  00036	89 08		 mov	 DWORD PTR [rax], ecx

; 826  :     op->exp   = (*fpr & 0x7F800000) >> 23;

  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR fpr$[rsp]
  0003d	8b 00		 mov	 eax, DWORD PTR [rax]
  0003f	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00044	c1 e8 17	 shr	 eax, 23
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  0004c	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 827  :     op->fract = *fpr & 0x007FFFFF;

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR fpr$[rsp]
  00054	8b 00		 mov	 eax, DWORD PTR [rax]
  00056	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  00060	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 828  : 
; 829  :     //logmsg("sget r=%8.8x exp=%d fract=%x\n", *fpr, op->exp, op->fract);
; 830  : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
get_sbfp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv69 = 0
op$ = 32
fpr$ = 40
get_lbfp PROC

; 815  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 816  :     op->sign  = (fpr[0] & 0x80000000) != 0;

  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	48 6b c0 00	 imul	 rax, rax, 0
  00017	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fpr$[rsp]
  0001c	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0001f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00024	85 c0		 test	 eax, eax
  00026	74 09		 je	 SHORT $LN3@get_lbfp
  00028	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  0002f	eb 07		 jmp	 SHORT $LN4@get_lbfp
$LN3@get_lbfp:
  00031	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN4@get_lbfp:
  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  0003d	8b 0c 24	 mov	 ecx, DWORD PTR tv69[rsp]
  00040	89 08		 mov	 DWORD PTR [rax], ecx

; 817  :     op->exp   = (fpr[0] & 0x7FF00000) >> 20;

  00042	b8 04 00 00 00	 mov	 eax, 4
  00047	48 6b c0 00	 imul	 rax, rax, 0
  0004b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fpr$[rsp]
  00050	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00053	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00058	c1 e8 14	 shr	 eax, 20
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  00060	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 818  :     op->fract = (((U64)fpr[0] & 0x000FFFFF) << 32) | fpr[1];

  00063	b8 04 00 00 00	 mov	 eax, 4
  00068	48 6b c0 00	 imul	 rax, rax, 0
  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fpr$[rsp]
  00071	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00074	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  0007a	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0007e	b9 04 00 00 00	 mov	 ecx, 4
  00083	48 6b c9 01	 imul	 rcx, rcx, 1
  00087	48 8b 54 24 28	 mov	 rdx, QWORD PTR fpr$[rsp]
  0008c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0008f	48 0b c1	 or	 rax, rcx
  00092	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  00097	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 819  : 
; 820  :     //logmsg("lget r=%8.8x%8.8x exp=%d fract=%"PRIx64"\n", fpr[0], fpr[1], op->exp, op->fract);
; 821  : }

  0009b	48 83 c4 18	 add	 rsp, 24
  0009f	c3		 ret	 0
get_lbfp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
sbfpclassify PROC

; 792  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 793  :     if (op->exp == 0)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0000e	75 1a		 jne	 SHORT $LN2@sbfpclassi

; 794  :     {
; 795  :         if (op->fract == 0)

  00010	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  00015	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00019	75 06		 jne	 SHORT $LN4@sbfpclassi

; 796  :             return FP_ZERO;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 3b		 jmp	 SHORT $LN1@sbfpclassi
  0001f	eb 07		 jmp	 SHORT $LN5@sbfpclassi
$LN4@sbfpclassi:

; 797  :         else
; 798  :             return FP_SUBNORMAL;

  00021	b8 fe ff ff ff	 mov	 eax, -2
  00026	eb 32		 jmp	 SHORT $LN1@sbfpclassi
$LN5@sbfpclassi:

; 799  :     }

  00028	eb 30		 jmp	 SHORT $LN3@sbfpclassi
$LN2@sbfpclassi:

; 800  :     else if (op->exp == 0xFF)

  0002a	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0002f	81 78 04 ff 00
	00 00		 cmp	 DWORD PTR [rax+4], 255	; 000000ffH
  00036	75 1d		 jne	 SHORT $LN6@sbfpclassi

; 801  :     {
; 802  :         if (op->fract == 0)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0003d	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00041	75 09		 jne	 SHORT $LN8@sbfpclassi

; 803  :             return FP_INFINITE;

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	eb 10		 jmp	 SHORT $LN1@sbfpclassi
  0004a	eb 07		 jmp	 SHORT $LN9@sbfpclassi
$LN8@sbfpclassi:

; 804  :         else
; 805  :             return FP_NAN;

  0004c	b8 02 00 00 00	 mov	 eax, 2
  00051	eb 07		 jmp	 SHORT $LN1@sbfpclassi
$LN9@sbfpclassi:

; 806  :     }

  00053	eb 05		 jmp	 SHORT $LN7@sbfpclassi
$LN6@sbfpclassi:

; 807  :     else
; 808  :         return FP_NORMAL;

  00055	b8 ff ff ff ff	 mov	 eax, -1
$LN7@sbfpclassi:
$LN3@sbfpclassi:
$LN1@sbfpclassi:

; 809  : }

  0005a	c3		 ret	 0
sbfpclassify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
lbfpclassify PROC

; 772  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 773  :     if (op->exp == 0)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0000e	75 1b		 jne	 SHORT $LN2@lbfpclassi

; 774  :     {
; 775  :         if (op->fract == 0)

  00010	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  00015	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0001a	75 06		 jne	 SHORT $LN4@lbfpclassi

; 776  :             return FP_ZERO;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 3c		 jmp	 SHORT $LN1@lbfpclassi
  00020	eb 07		 jmp	 SHORT $LN5@lbfpclassi
$LN4@lbfpclassi:

; 777  :         else
; 778  :             return FP_SUBNORMAL;

  00022	b8 fe ff ff ff	 mov	 eax, -2
  00027	eb 33		 jmp	 SHORT $LN1@lbfpclassi
$LN5@lbfpclassi:

; 779  :     }

  00029	eb 31		 jmp	 SHORT $LN3@lbfpclassi
$LN2@lbfpclassi:

; 780  :     else if (op->exp == 0x7FF)

  0002b	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  00030	81 78 04 ff 07
	00 00		 cmp	 DWORD PTR [rax+4], 2047	; 000007ffH
  00037	75 1e		 jne	 SHORT $LN6@lbfpclassi

; 781  :     {
; 782  :         if (op->fract == 0)

  00039	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0003e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00043	75 09		 jne	 SHORT $LN8@lbfpclassi

; 783  :             return FP_INFINITE;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	eb 10		 jmp	 SHORT $LN1@lbfpclassi
  0004c	eb 07		 jmp	 SHORT $LN9@lbfpclassi
$LN8@lbfpclassi:

; 784  :         else
; 785  :             return FP_NAN;

  0004e	b8 02 00 00 00	 mov	 eax, 2
  00053	eb 07		 jmp	 SHORT $LN1@lbfpclassi
$LN9@lbfpclassi:

; 786  :     }

  00055	eb 05		 jmp	 SHORT $LN7@lbfpclassi
$LN6@lbfpclassi:

; 787  :     else
; 788  :         return FP_NORMAL;

  00057	b8 ff ff ff ff	 mov	 eax, -1
$LN7@lbfpclassi:
$LN3@lbfpclassi:
$LN1@lbfpclassi:

; 789  : }

  0005c	c3		 ret	 0
lbfpclassify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
s370_float32_signaling_compare PROC

; 689  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 690  :     if (FLOAT32_ISNAN( op1 ) ||

  0000c	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00010	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00015	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0001a	75 0d		 jne	 SHORT $LN4@s370_float
  0001c	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00020	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00025	85 c0		 test	 eax, eax
  00027	75 1d		 jne	 SHORT $LN3@s370_float
$LN4@s370_float:
  00029	8b 44 24 38	 mov	 eax, DWORD PTR op2$[rsp]
  0002d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00032	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00037	75 4e		 jne	 SHORT $LN2@s370_float
  00039	8b 44 24 38	 mov	 eax, DWORD PTR op2$[rsp]
  0003d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00042	85 c0		 test	 eax, eax
  00044	74 41		 je	 SHORT $LN2@s370_float
$LN3@s370_float:

; 691  :         FLOAT32_ISNAN( op2 ))
; 692  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00046	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0004b	8b c0		 mov	 eax, eax
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00053	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00060	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00064	83 c8 10	 or	 eax, 16
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0006d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00076	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0007c	45 8b c0	 mov	 r8d, r8d
  0007f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00083	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s370_float:

; 693  :     return ARCH_DEP( float32_cc_quiet )( op1, op2 );

  00087	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  0008f	e8 00 00 00 00	 call	 s370_float32_cc_quiet

; 694  : }

  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	c3		 ret	 0
s370_float32_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
s370_float32_compare PROC

; 681  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 682  :     if (f32_isSignalingNaN( op1 ) ||

  0000c	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00010	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	75 10		 jne	 SHORT $LN3@s370_float
  0001c	8b 4c 24 38	 mov	 ecx, DWORD PTR op2$[rsp]
  00020	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 41		 je	 SHORT $LN2@s370_float
$LN3@s370_float:

; 683  :         f32_isSignalingNaN( op2 ))
; 684  :         softfloat_raiseFlags( softfloat_flag_invalid );

  0002c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00031	8b c0		 mov	 eax, eax
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00039	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00042	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00046	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004a	83 c8 10	 or	 eax, 16
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00053	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005c	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00062	45 8b c0	 mov	 r8d, r8d
  00065	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00069	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s370_float:

; 685  :     return ARCH_DEP( float32_cc_quiet )( op1, op2 );

  0006d	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00071	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00075	e8 00 00 00 00	 call	 s370_float32_cc_quiet

; 686  : }

  0007a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007e	c3		 ret	 0
s370_float32_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv81 = 32
tv83 = 36
tv84 = 40
op1$ = 64
op2$ = 72
s370_float32_cc_quiet PROC

; 673  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 674  :     return FLOAT32_ISNAN( op1      ) ||

  0000c	8b 44 24 40	 mov	 eax, DWORD PTR op1$[rsp]
  00010	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00015	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0001a	75 0d		 jne	 SHORT $LN3@s370_float
  0001c	8b 44 24 40	 mov	 eax, DWORD PTR op1$[rsp]
  00020	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00025	85 c0		 test	 eax, eax
  00027	75 73		 jne	 SHORT $LN5@s370_float
$LN3@s370_float:
  00029	8b 44 24 48	 mov	 eax, DWORD PTR op2$[rsp]
  0002d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00032	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00037	75 0d		 jne	 SHORT $LN4@s370_float
  00039	8b 44 24 48	 mov	 eax, DWORD PTR op2$[rsp]
  0003d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00042	85 c0		 test	 eax, eax
  00044	75 56		 jne	 SHORT $LN5@s370_float
$LN4@s370_float:
  00046	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  0004a	8b 4c 24 40	 mov	 ecx, DWORD PTR op1$[rsp]
  0004e	e8 00 00 00 00	 call	 f32_eq
  00053	0f b6 c0	 movzx	 eax, al
  00056	85 c0		 test	 eax, eax
  00058	74 0a		 je	 SHORT $LN8@s370_float
  0005a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  00062	eb 2e		 jmp	 SHORT $LN9@s370_float
$LN8@s370_float:
  00064	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00068	8b 4c 24 40	 mov	 ecx, DWORD PTR op1$[rsp]
  0006c	e8 00 00 00 00	 call	 f32_lt_quiet
  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	74 0a		 je	 SHORT $LN6@s370_float
  00078	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00080	eb 08		 jmp	 SHORT $LN7@s370_float
$LN6@s370_float:
  00082	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv81[rsp], 2
$LN7@s370_float:
  0008a	8b 44 24 20	 mov	 eax, DWORD PTR tv81[rsp]
  0008e	89 44 24 24	 mov	 DWORD PTR tv83[rsp], eax
$LN9@s370_float:
  00092	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  00096	89 44 24 28	 mov	 DWORD PTR tv84[rsp], eax
  0009a	eb 08		 jmp	 SHORT $LN10@s370_float
$LN5@s370_float:
  0009c	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv84[rsp], 3
$LN10@s370_float:
  000a4	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv84[rsp]

; 675  :            FLOAT32_ISNAN(      op2 ) ? 3 :
; 676  :            f32_eq(        op1, op2 ) ? 0 :
; 677  :            f32_lt_quiet(  op1, op2 ) ? 1 : 2;
; 678  : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
s370_float32_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
s370_float64_signaling_compare PROC

; 665  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 666  :     if (FLOAT64_ISNAN( op1 ) ||

  0000e	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 23 c8	 and	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	75 1a		 jne	 SHORT $LN4@s370_float
  00032	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00041	48 23 c8	 and	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 85 c0	 test	 rax, rax
  0004a	75 3e		 jne	 SHORT $LN3@s370_float
$LN4@s370_float:
  0004c	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00056	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  0005b	48 23 c8	 and	 rcx, rax
  0005e	48 8b c1	 mov	 rax, rcx
  00061	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0006b	48 3b c1	 cmp	 rax, rcx
  0006e	75 5b		 jne	 SHORT $LN2@s370_float
  00070	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0007a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  0007f	48 23 c8	 and	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 85 c0	 test	 rax, rax
  00088	74 41		 je	 SHORT $LN2@s370_float
$LN3@s370_float:

; 667  :         FLOAT64_ISNAN( op2 ))
; 668  :         softfloat_raiseFlags( softfloat_flag_invalid );

  0008a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0008f	8b c0		 mov	 eax, eax
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00097	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000a0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a8	83 c8 10	 or	 eax, 16
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000ba	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  000c0	45 8b c0	 mov	 r8d, r8d
  000c3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000c7	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s370_float:

; 669  :     return ARCH_DEP( float64_cc_quiet )( op1, op2 );

  000cb	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  000d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  000d5	e8 00 00 00 00	 call	 s370_float64_cc_quiet

; 670  : }

  000da	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000de	c3		 ret	 0
s370_float64_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 48
op2$ = 56
s370_float64_compare PROC

; 657  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 658  :     if (f64_isSignalingNaN( op1 ) ||

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00013	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 11		 jne	 SHORT $LN3@s370_float
  0001f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  00024	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	74 41		 je	 SHORT $LN2@s370_float
$LN3@s370_float:

; 659  :         f64_isSignalingNaN( op2 ))
; 660  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00030	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00035	8b c0		 mov	 eax, eax
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00046	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0004a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004e	83 c8 10	 or	 eax, 16
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00057	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00060	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00066	45 8b c0	 mov	 r8d, r8d
  00069	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0006d	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s370_float:

; 661  :     return ARCH_DEP( float64_cc_quiet )( op1, op2 );

  00071	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  0007b	e8 00 00 00 00	 call	 s370_float64_cc_quiet

; 662  : }

  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	c3		 ret	 0
s370_float64_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv81 = 32
tv83 = 36
tv84 = 40
op1$ = 64
op2$ = 72
s370_float64_cc_quiet PROC

; 649  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 650  :     return FLOAT64_ISNAN( op1      ) ||

  0000e	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 23 c8	 and	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	75 1e		 jne	 SHORT $LN3@s370_float
  00032	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00041	48 23 c8	 and	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 85 c0	 test	 rax, rax
  0004a	0f 85 98 00 00
	00		 jne	 $LN5@s370_float
$LN3@s370_float:
  00050	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  0005f	48 23 c8	 and	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0006f	48 3b c1	 cmp	 rax, rcx
  00072	75 1a		 jne	 SHORT $LN4@s370_float
  00074	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0007e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00083	48 23 c8	 and	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	48 85 c0	 test	 rax, rax
  0008c	75 5a		 jne	 SHORT $LN5@s370_float
$LN4@s370_float:
  0008e	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00098	e8 00 00 00 00	 call	 f64_eq
  0009d	0f b6 c0	 movzx	 eax, al
  000a0	85 c0		 test	 eax, eax
  000a2	74 0a		 je	 SHORT $LN8@s370_float
  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000ac	eb 30		 jmp	 SHORT $LN9@s370_float
$LN8@s370_float:
  000ae	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  000b8	e8 00 00 00 00	 call	 f64_lt_quiet
  000bd	0f b6 c0	 movzx	 eax, al
  000c0	85 c0		 test	 eax, eax
  000c2	74 0a		 je	 SHORT $LN6@s370_float
  000c4	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  000cc	eb 08		 jmp	 SHORT $LN7@s370_float
$LN6@s370_float:
  000ce	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv81[rsp], 2
$LN7@s370_float:
  000d6	8b 44 24 20	 mov	 eax, DWORD PTR tv81[rsp]
  000da	89 44 24 24	 mov	 DWORD PTR tv83[rsp], eax
$LN9@s370_float:
  000de	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  000e2	89 44 24 28	 mov	 DWORD PTR tv84[rsp], eax
  000e6	eb 08		 jmp	 SHORT $LN10@s370_float
$LN5@s370_float:
  000e8	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv84[rsp], 3
$LN10@s370_float:
  000f0	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv84[rsp]

; 651  :            FLOAT64_ISNAN(      op2 ) ? 3 :
; 652  :            f64_eq(        op1, op2 ) ? 0 :
; 653  :            f64_lt_quiet(  op1, op2 ) ? 1 : 2;
; 654  : }

  000f5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f9	c3		 ret	 0
s370_float64_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
op1$ = 96
op2$ = 104
s370_float128_signaling_compare PROC

; 641  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 642  :     if (FLOAT128_ISNAN( op1 ) ||

  00010	b8 08 00 00 00	 mov	 eax, 8
  00015	48 6b c0 01	 imul	 rax, rax, 1
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  0001e	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  00028	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0002c	48 23 c2	 and	 rax, rdx
  0002f	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00039	48 3b c1	 cmp	 rax, rcx
  0003c	75 39		 jne	 SHORT $LN4@s370_float
  0003e	b8 08 00 00 00	 mov	 eax, 8
  00043	48 6b c0 01	 imul	 rax, rax, 1
  00047	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  0004c	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  00056	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0005a	48 23 c2	 and	 rax, rdx
  0005d	48 85 c0	 test	 rax, rax
  00060	75 7c		 jne	 SHORT $LN3@s370_float
  00062	b8 08 00 00 00	 mov	 eax, 8
  00067	48 6b c0 00	 imul	 rax, rax, 0
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  00070	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00075	75 67		 jne	 SHORT $LN3@s370_float
$LN4@s370_float:
  00077	b8 08 00 00 00	 mov	 eax, 8
  0007c	48 6b c0 01	 imul	 rax, rax, 1
  00080	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  00085	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  0008f	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00093	48 23 c2	 and	 rax, rdx
  00096	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  000a0	48 3b c1	 cmp	 rax, rcx
  000a3	75 7a		 jne	 SHORT $LN2@s370_float
  000a5	b8 08 00 00 00	 mov	 eax, 8
  000aa	48 6b c0 01	 imul	 rax, rax, 1
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  000b3	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  000bd	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000c1	48 23 c2	 and	 rax, rdx
  000c4	48 85 c0	 test	 rax, rax
  000c7	75 15		 jne	 SHORT $LN5@s370_float
  000c9	b8 08 00 00 00	 mov	 eax, 8
  000ce	48 6b c0 00	 imul	 rax, rax, 0
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op2$[rsp]
  000d7	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000dc	74 41		 je	 SHORT $LN2@s370_float
$LN5@s370_float:
$LN3@s370_float:

; 643  :         FLOAT128_ISNAN( op2 ))
; 644  :         softfloat_raiseFlags( softfloat_flag_invalid );

  000de	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  000e3	8b c0		 mov	 eax, eax
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000eb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000f4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000f8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fc	83 c8 10	 or	 eax, 16
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00105	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0010e	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00114	45 8b c0	 mov	 r8d, r8d
  00117	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0011b	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN2@s370_float:

; 645  :     return ARCH_DEP( float128_cc_quiet )( op1, op2 );

  0011f	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00124	48 8b f8	 mov	 rdi, rax
  00127	48 8b 74 24 68	 mov	 rsi, QWORD PTR op2$[rsp]
  0012c	b9 10 00 00 00	 mov	 ecx, 16
  00131	f3 a4		 rep movsb
  00133	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00138	48 8b f8	 mov	 rdi, rax
  0013b	48 8b 74 24 60	 mov	 rsi, QWORD PTR op1$[rsp]
  00140	b9 10 00 00 00	 mov	 ecx, 16
  00145	f3 a4		 rep movsb
  00147	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0014c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00151	e8 00 00 00 00	 call	 s370_float128_cc_quiet

; 646  : }

  00156	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015a	5f		 pop	 rdi
  0015b	5e		 pop	 rsi
  0015c	c3		 ret	 0
s370_float128_signaling_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
op1$ = 128
op2$ = 136
s370_float128_compare PROC

; 633  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 634  :     if (f128_isSignalingNaN( op1 ) ||

  00010	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00015	48 8b f8	 mov	 rdi, rax
  00018	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00020	b9 10 00 00 00	 mov	 ecx, 16
  00025	f3 a4		 rep movsb
  00027	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0002c	e8 00 00 00 00	 call	 f128_isSignalingNaN
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 28		 jne	 SHORT $LN3@s370_float
  00038	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0003d	48 8b f8	 mov	 rdi, rax
  00040	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  00048	b9 10 00 00 00	 mov	 ecx, 16
  0004d	f3 a4		 rep movsb
  0004f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00054	e8 00 00 00 00	 call	 f128_isSignalingNaN
  00059	0f b6 c0	 movzx	 eax, al
  0005c	85 c0		 test	 eax, eax
  0005e	74 3e		 je	 SHORT $LN2@s370_float
$LN3@s370_float:

; 635  :         f128_isSignalingNaN( op2 ))
; 636  :         softfloat_raiseFlags( softfloat_flag_invalid );

  00060	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00065	8b c0		 mov	 eax, eax
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0006d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00076	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0007a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007e	83 c8 10	 or	 eax, 16
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00087	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00090	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00095	8b ff		 mov	 edi, edi
  00097	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0009b	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN2@s370_float:

; 637  :     return ARCH_DEP( float128_cc_quiet )( op1, op2 );

  0009e	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  000a3	48 8b f8	 mov	 rdi, rax
  000a6	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  000ae	b9 10 00 00 00	 mov	 ecx, 16
  000b3	f3 a4		 rep movsb
  000b5	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  000ba	48 8b f8	 mov	 rdi, rax
  000bd	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  000c5	b9 10 00 00 00	 mov	 ecx, 16
  000ca	f3 a4		 rep movsb
  000cc	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  000d1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  000d6	e8 00 00 00 00	 call	 s370_float128_cc_quiet

; 638  : }

  000db	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
s370_float128_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv133 = 32
tv135 = 36
tv136 = 40
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
op1$ = 144
op2$ = 152
s370_float128_cc_quiet PROC

; 625  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 626  :     return FLOAT128_ISNAN( op1      ) ||

  00010	b8 08 00 00 00	 mov	 eax, 8
  00015	48 6b c0 01	 imul	 rax, rax, 1
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  00021	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  0002b	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0002f	48 23 c2	 and	 rax, rdx
  00032	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	75 47		 jne	 SHORT $LN4@s370_float
  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	48 6b c0 01	 imul	 rax, rax, 1
  0004a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  00052	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  0005c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00060	48 23 c2	 and	 rax, rdx
  00063	48 85 c0	 test	 rax, rax
  00066	0f 85 4a 01 00
	00		 jne	 $LN3@s370_float
  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 00	 imul	 rax, rax, 0
  00075	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR op1$[rsp]
  0007d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00082	0f 85 2e 01 00
	00		 jne	 $LN3@s370_float
$LN4@s370_float:
  00088	b8 08 00 00 00	 mov	 eax, 8
  0008d	48 6b c0 01	 imul	 rax, rax, 1
  00091	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  00099	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  000a3	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a7	48 23 c2	 and	 rax, rdx
  000aa	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  000b4	48 3b c1	 cmp	 rax, rcx
  000b7	75 47		 jne	 SHORT $LN6@s370_float
  000b9	b8 08 00 00 00	 mov	 eax, 8
  000be	48 6b c0 01	 imul	 rax, rax, 1
  000c2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  000ca	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  000d4	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000d8	48 23 c2	 and	 rax, rdx
  000db	48 85 c0	 test	 rax, rax
  000de	0f 85 d2 00 00
	00		 jne	 $LN5@s370_float
  000e4	b8 08 00 00 00	 mov	 eax, 8
  000e9	48 6b c0 00	 imul	 rax, rax, 0
  000ed	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR op2$[rsp]
  000f5	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000fa	0f 85 b6 00 00
	00		 jne	 $LN3@s370_float
$LN6@s370_float:
  00100	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00105	48 8b f8	 mov	 rdi, rax
  00108	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  00110	b9 10 00 00 00	 mov	 ecx, 16
  00115	f3 a4		 rep movsb
  00117	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0011c	48 8b f8	 mov	 rdi, rax
  0011f	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00127	b9 10 00 00 00	 mov	 ecx, 16
  0012c	f3 a4		 rep movsb
  0012e	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00133	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00138	e8 00 00 00 00	 call	 f128_eq
  0013d	0f b6 c0	 movzx	 eax, al
  00140	85 c0		 test	 eax, eax
  00142	74 0a		 je	 SHORT $LN9@s370_float
  00144	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
  0014c	eb 5e		 jmp	 SHORT $LN10@s370_float
$LN9@s370_float:
  0014e	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00153	48 8b f8	 mov	 rdi, rax
  00156	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR op2$[rsp]
  0015e	b9 10 00 00 00	 mov	 ecx, 16
  00163	f3 a4		 rep movsb
  00165	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  0016a	48 8b f8	 mov	 rdi, rax
  0016d	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR op1$[rsp]
  00175	b9 10 00 00 00	 mov	 ecx, 16
  0017a	f3 a4		 rep movsb
  0017c	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  00181	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  00186	e8 00 00 00 00	 call	 f128_lt_quiet
  0018b	0f b6 c0	 movzx	 eax, al
  0018e	85 c0		 test	 eax, eax
  00190	74 0a		 je	 SHORT $LN7@s370_float
  00192	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  0019a	eb 08		 jmp	 SHORT $LN8@s370_float
$LN7@s370_float:
  0019c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
$LN8@s370_float:
  001a4	8b 44 24 20	 mov	 eax, DWORD PTR tv133[rsp]
  001a8	89 44 24 24	 mov	 DWORD PTR tv135[rsp], eax
$LN10@s370_float:
  001ac	8b 44 24 24	 mov	 eax, DWORD PTR tv135[rsp]
  001b0	89 44 24 28	 mov	 DWORD PTR tv136[rsp], eax
  001b4	eb 08		 jmp	 SHORT $LN11@s370_float
$LN3@s370_float:
$LN5@s370_float:
  001b6	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv136[rsp], 3
$LN11@s370_float:
  001be	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv136[rsp]

; 627  :            FLOAT128_ISNAN(      op2 ) ? 3 :
; 628  :            f128_eq(        op1, op2 ) ? 0 :
; 629  :            f128_lt_quiet(  op1, op2 ) ? 1 : 2;
; 630  : }

  001c3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001c7	5f		 pop	 rdi
  001c8	5e		 pop	 rsi
  001c9	c3		 ret	 0
s370_float128_cc_quiet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s370_put_float32 PROC

; 584  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 585  :     *fpr = op->v;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR fpr$[rsp]
  0000f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00014	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00016	89 08		 mov	 DWORD PTR [rax], ecx

; 586  : }

  00018	c3		 ret	 0
s370_put_float32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s370_get_float32 PROC

; 579  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 580  :     op->v = *fpr;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00014	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00016	89 08		 mov	 DWORD PTR [rax], ecx

; 581  : }

  00018	c3		 ret	 0
s370_get_float32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s370_put_float64 PROC

; 573  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 574  :     fpr[0] = (U32) (op->v >> 32);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00016	b9 04 00 00 00	 mov	 ecx, 4
  0001b	48 6b c9 00	 imul	 rcx, rcx, 0
  0001f	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00024	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 575  :     fpr[1] = (U32) (op->v & 0xFFFFFFFF);

  00027	48 8b 44 24 08	 mov	 rax, QWORD PTR op$[rsp]
  0002c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 23 c1	 and	 rax, rcx
  00037	b9 04 00 00 00	 mov	 ecx, 4
  0003c	48 6b c9 01	 imul	 rcx, rcx, 1
  00040	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00045	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 576  : }

  00048	c3		 ret	 0
s370_put_float64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s370_get_float64 PROC

; 568  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 569  :     op->v = ((U64)fpr[0] << 32) | fpr[1];

  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	48 6b c0 00	 imul	 rax, rax, 0
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00018	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0001b	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	48 6b c9 01	 imul	 rcx, rcx, 1
  00028	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00030	48 0b c1	 or	 rax, rcx
  00033	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00038	48 89 01	 mov	 QWORD PTR [rcx], rax

; 570  : }

  0003b	c3		 ret	 0
s370_get_float64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s370_put_float128 PROC

; 560  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 561  :     fpr[0]       = (U32) (op->v[FLOAT128_HI] >> 32);

  0000a	b8 08 00 00 00	 mov	 eax, 8
  0000f	48 6b c0 01	 imul	 rax, rax, 1
  00013	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00018	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0001c	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00020	b9 04 00 00 00	 mov	 ecx, 4
  00025	48 6b c9 00	 imul	 rcx, rcx, 0
  00029	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002e	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 562  :     fpr[1]       = (U32) (op->v[FLOAT128_HI] & 0xFFFFFFFF);

  00031	b8 08 00 00 00	 mov	 eax, 8
  00036	48 6b c0 01	 imul	 rax, rax, 1
  0003a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  0003f	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00044	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00048	48 23 c2	 and	 rax, rdx
  0004b	b9 04 00 00 00	 mov	 ecx, 4
  00050	48 6b c9 01	 imul	 rcx, rcx, 1
  00054	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00059	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 563  :     fpr[FPREX]   = (U32) (op->v[FLOAT128_LO] >> 32);

  0005c	b8 08 00 00 00	 mov	 eax, 8
  00061	48 6b c0 00	 imul	 rax, rax, 0
  00065	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  0006a	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0006e	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00072	b9 04 00 00 00	 mov	 ecx, 4
  00077	48 6b c9 04	 imul	 rcx, rcx, 4
  0007b	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00080	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 564  :     fpr[FPREX+1] = (U32) (op->v[FLOAT128_LO] & 0xFFFFFFFF);

  00083	b8 08 00 00 00	 mov	 eax, 8
  00088	48 6b c0 00	 imul	 rax, rax, 0
  0008c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR op$[rsp]
  00091	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00096	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0009a	48 23 c2	 and	 rax, rdx
  0009d	b9 04 00 00 00	 mov	 ecx, 4
  000a2	48 6b c9 05	 imul	 rcx, rcx, 5
  000a6	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  000ab	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 565  : }

  000ae	c3		 ret	 0
s370_put_float128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 8
fpr$ = 16
s370_get_float128 PROC

; 553  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 554  :                                                       /* high order bits in v[1], low order in v[0]  */
; 555  :     op->v[FLOAT128_HI] = ((U64)fpr[0]     << 32) | fpr[1];               /* *****  Possible endian concern  ******* */

  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	48 6b c0 00	 imul	 rax, rax, 0
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00018	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0001b	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	48 6b c9 01	 imul	 rcx, rcx, 1
  00028	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  0002d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00030	48 0b c1	 or	 rax, rcx
  00033	b9 08 00 00 00	 mov	 ecx, 8
  00038	48 6b c9 01	 imul	 rcx, rcx, 1
  0003c	48 8b 54 24 08	 mov	 rdx, QWORD PTR op$[rsp]
  00041	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 556  :     op->v[FLOAT128_LO] = ((U64)fpr[FPREX] << 32) | fpr[FPREX+1];

  00045	b8 04 00 00 00	 mov	 eax, 4
  0004a	48 6b c0 04	 imul	 rax, rax, 4
  0004e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpr$[rsp]
  00053	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00056	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0005a	b9 04 00 00 00	 mov	 ecx, 4
  0005f	48 6b c9 05	 imul	 rcx, rcx, 5
  00063	48 8b 54 24 10	 mov	 rdx, QWORD PTR fpr$[rsp]
  00068	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0006b	48 0b c1	 or	 rax, rcx
  0006e	b9 08 00 00 00	 mov	 ecx, 8
  00073	48 6b c9 00	 imul	 rcx, rcx, 0
  00077	48 8b 54 24 08	 mov	 rdx, QWORD PTR op$[rsp]
  0007c	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 557  : }

  00080	c3		 ret	 0
s370_get_float128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
regs$ = 48
mask$ = 56
s370_BFP_RM_check PROC

; 534  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 535  : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 536  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 04	 imul	 rax, rax, 4
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00023	83 e0 04	 and	 eax, 4
  00026	85 c0		 test	 eax, eax
  00028	74 3a		 je	 SHORT $LN2@s370_BFP_R

; 537  :     {
; 538  :         if (mask > 7 || !map_valid_m3_values_FPX[ (mask & 0x7) ]) 

  0002a	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  0002f	83 f8 07	 cmp	 eax, 7
  00032	7f 19		 jg	 SHORT $LN5@s370_BFP_R
  00034	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  00039	83 e0 07	 and	 eax, 7
  0003c	48 98		 cdqe
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_valid_m3_values_FPX
  00045	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00049	85 c0		 test	 eax, eax
  0004b	75 15		 jne	 SHORT $LN4@s370_BFP_R
$LN5@s370_BFP_R:

; 539  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0004d	ba 06 00 00 00	 mov	 edx, 6
  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@s370_BFP_R:

; 540  :     }

  00062	eb 38		 jmp	 SHORT $LN3@s370_BFP_R
$LN2@s370_BFP_R:

; 541  :     else
; 542  : #endif
; 543  :     {
; 544  :         if (mask > 7 || !map_valid_m3_values_NOFPX[ (mask & 0x7) ])

  00064	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  00069	83 f8 07	 cmp	 eax, 7
  0006c	7f 19		 jg	 SHORT $LN7@s370_BFP_R
  0006e	0f b6 44 24 38	 movzx	 eax, BYTE PTR mask$[rsp]
  00073	83 e0 07	 and	 eax, 7
  00076	48 98		 cdqe
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_valid_m3_values_NOFPX
  0007f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00083	85 c0		 test	 eax, eax
  00085	75 15		 jne	 SHORT $LN6@s370_BFP_R
$LN7@s370_BFP_R:

; 545  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00087	ba 06 00 00 00	 mov	 edx, 6
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00096	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_BFP_R:
$LN3@s370_BFP_R:

; 546  :     }
; 547  : }

  0009c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a0	c3		 ret	 0
s370_BFP_RM_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 0
regs$ = 32
ieee_exception_test_oux PROC

; 469  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 470  :     U32 ieee_trap_conds = 0;

  00009	c7 04 24 00 00
	00 00		 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 471  : 
; 472  :     if (regs->fpc & FPC_MASKS)

  00010	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00015	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0001b	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00020	85 c0		 test	 eax, eax
  00022	0f 84 36 01 00
	00		 je	 $LN2@ieee_excep

; 473  :     {
; 474  :         /* Some flags and some traps enabled. Figure it out. */
; 475  : 
; 476  :         /* If tiny and underflow trappable... */
; 477  :         if (1
; 478  :             && (softfloat_exceptionFlags & softfloat_flag_tiny)
; 479  :             && regs->fpc & FPC_MASK_IMU

  00028	33 c0		 xor	 eax, eax
  0002a	83 f8 01	 cmp	 eax, 1
  0002d	74 7a		 je	 SHORT $LN4@ieee_excep
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00034	8b c0		 mov	 eax, eax
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00045	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00049	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004d	83 e0 40	 and	 eax, 64			; 00000040H
  00050	85 c0		 test	 eax, eax
  00052	74 55		 je	 SHORT $LN4@ieee_excep
  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00059	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0005f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00064	85 c0		 test	 eax, eax
  00066	74 41		 je	 SHORT $LN4@ieee_excep

; 480  :         )
; 481  :             /* Raise underflow per SA22-7832-10 page 9-20 */
; 482  :             softfloat_exceptionFlags |= softfloat_flag_underflow;

  00068	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0006d	8b c0		 mov	 eax, eax
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00075	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0007e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00082	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00086	83 c8 02	 or	 eax, 2
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0008f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00098	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0009e	45 8b c0	 mov	 r8d, r8d
  000a1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000a5	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN4@ieee_excep:

; 483  : 
; 484  :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds,

  000a9	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  000b4	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  000be	8b c9		 mov	 ecx, ecx
  000c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  000c6	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  000cf	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  000d3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d7	c1 e1 1b	 shl	 ecx, 27
  000da	23 c1		 and	 eax, ecx
  000dc	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  000e1	89 04 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 485  :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 486  : 
; 487  :         /* Transfer any returned flags from Softfloat to FPC */
; 488  :         SET_FPC_FLAGS_FROM_SF( regs );

  000e4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  000e9	8b c0		 mov	 eax, eax
  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000f1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000fa	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00102	c1 e0 13	 shl	 eax, 19
  00105	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0010a	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00110	c1 e9 08	 shr	 ecx, 8
  00113	f7 d1		 not	 ecx
  00115	23 c1		 and	 eax, ecx
  00117	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0011c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00127	0b c8		 or	 ecx, eax
  00129	8b c1		 mov	 eax, ecx
  0012b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 489  : 
; 490  :         /* Turn off inexact flag if overflow or underflow will trap */
; 491  :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00136	8b 04 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00139	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0013e	85 c0		 test	 eax, eax
  00140	74 1a		 je	 SHORT $LN5@ieee_excep

; 492  :             regs->fpc &= ~FPC_FLAG_SFX;

  00142	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00147	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0014d	0f ba f0 13	 btr	 eax, 19
  00151	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN5@ieee_excep:

; 493  :     }

  0015c	eb 52		 jmp	 SHORT $LN3@ieee_excep
$LN2@ieee_excep:

; 494  :     else
; 495  :         /* Transfer any returned flags from Softfloat to FPC */
; 496  :         SET_FPC_FLAGS_FROM_SF( regs );

  0015e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00163	8b c0		 mov	 eax, eax
  00165	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0016b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00174	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00178	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0017c	c1 e0 13	 shl	 eax, 19
  0017f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0018a	c1 e9 08	 shr	 ecx, 8
  0018d	f7 d1		 not	 ecx
  0018f	23 c1		 and	 eax, ecx
  00191	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00196	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001a1	0b c8		 or	 ecx, eax
  001a3	8b c1		 mov	 eax, ecx
  001a5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  001aa	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN3@ieee_excep:

; 497  : 
; 498  :     return ieee_trap_conds;

  001b0	8b 04 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]

; 499  : }

  001b3	48 83 c4 18	 add	 rsp, 24
  001b7	c3		 ret	 0
ieee_exception_test_oux ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
neg$ = 32
tv66 = 36
tv135 = 40
tv140 = 44
tv144 = 48
tv148 = 52
tv152 = 56
tv155 = 60
op$ = 80
float32_class PROC

; 381  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 382  :     int neg = (op.v & 0x80000000) ? 1 : 0;

  00008	8b 44 24 50	 mov	 eax, DWORD PTR op$[rsp]
  0000c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00011	85 c0		 test	 eax, eax
  00013	74 0a		 je	 SHORT $LN8@float32_cl
  00015	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0001d	eb 08		 jmp	 SHORT $LN9@float32_cl
$LN8@float32_cl:
  0001f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN9@float32_cl:
  00027	8b 44 24 24	 mov	 eax, DWORD PTR tv66[rsp]
  0002b	89 44 24 20	 mov	 DWORD PTR neg$[rsp], eax

; 383  : 
; 384  :     if (f32_isSignalingNaN( op ))   {return float_class_pos_signaling_nan >> neg;}

  0002f	8b 4c 24 50	 mov	 ecx, DWORD PTR op$[rsp]
  00033	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	74 1b		 je	 SHORT $LN2@float32_cl
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  00043	b9 02 00 00 00	 mov	 ecx, 2
  00048	89 4c 24 28	 mov	 DWORD PTR tv135[rsp], ecx
  0004c	0f b6 c8	 movzx	 ecx, al
  0004f	8b 44 24 28	 mov	 eax, DWORD PTR tv135[rsp]
  00053	d3 f8		 sar	 eax, cl
  00055	e9 be 00 00 00	 jmp	 $LN1@float32_cl
$LN2@float32_cl:

; 385  :     if (FLOAT32_ISNAN( op ))        {return float_class_pos_quiet_nan     >> neg;}

  0005a	8b 44 24 50	 mov	 eax, DWORD PTR op$[rsp]
  0005e	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00063	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00068	75 28		 jne	 SHORT $LN3@float32_cl
  0006a	8b 44 24 50	 mov	 eax, DWORD PTR op$[rsp]
  0006e	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00073	85 c0		 test	 eax, eax
  00075	74 1b		 je	 SHORT $LN3@float32_cl
  00077	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  0007b	b9 08 00 00 00	 mov	 ecx, 8
  00080	89 4c 24 2c	 mov	 DWORD PTR tv140[rsp], ecx
  00084	0f b6 c8	 movzx	 ecx, al
  00087	8b 44 24 2c	 mov	 eax, DWORD PTR tv140[rsp]
  0008b	d3 f8		 sar	 eax, cl
  0008d	e9 86 00 00 00	 jmp	 $LN1@float32_cl
$LN3@float32_cl:

; 386  :     if (!(op.v & 0x7FFFFFFF))       {return float_class_pos_zero          >> neg;}

  00092	8b 44 24 50	 mov	 eax, DWORD PTR op$[rsp]
  00096	0f ba f0 1f	 btr	 eax, 31
  0009a	85 c0		 test	 eax, eax
  0009c	75 18		 jne	 SHORT $LN4@float32_cl
  0009e	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  000a2	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  000a7	89 4c 24 30	 mov	 DWORD PTR tv144[rsp], ecx
  000ab	0f b6 c8	 movzx	 ecx, al
  000ae	8b 44 24 30	 mov	 eax, DWORD PTR tv144[rsp]
  000b2	d3 f8		 sar	 eax, cl
  000b4	eb 62		 jmp	 SHORT $LN1@float32_cl
$LN4@float32_cl:

; 387  :     if ( (op.v & 0x7FFFFFFF)
; 388  :               == 0x7F800000)        {return float_class_pos_infinity      >> neg;}

  000b6	8b 44 24 50	 mov	 eax, DWORD PTR op$[rsp]
  000ba	0f ba f0 1f	 btr	 eax, 31
  000be	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  000c3	75 18		 jne	 SHORT $LN5@float32_cl
  000c5	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  000c9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000ce	89 4c 24 34	 mov	 DWORD PTR tv148[rsp], ecx
  000d2	0f b6 c8	 movzx	 ecx, al
  000d5	8b 44 24 34	 mov	 eax, DWORD PTR tv148[rsp]
  000d9	d3 f8		 sar	 eax, cl
  000db	eb 3b		 jmp	 SHORT $LN1@float32_cl
$LN5@float32_cl:

; 389  :     if (  op.v & 0x7F800000)        {return float_class_pos_normal        >> neg;}

  000dd	8b 44 24 50	 mov	 eax, DWORD PTR op$[rsp]
  000e1	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  000e6	85 c0		 test	 eax, eax
  000e8	74 18		 je	 SHORT $LN6@float32_cl
  000ea	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  000ee	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  000f3	89 4c 24 38	 mov	 DWORD PTR tv152[rsp], ecx
  000f7	0f b6 c8	 movzx	 ecx, al
  000fa	8b 44 24 38	 mov	 eax, DWORD PTR tv152[rsp]
  000fe	d3 f8		 sar	 eax, cl
  00100	eb 16		 jmp	 SHORT $LN1@float32_cl
$LN6@float32_cl:

; 390  :                                      return float_class_pos_subnormal     >> neg;

  00102	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  00106	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0010b	89 4c 24 3c	 mov	 DWORD PTR tv155[rsp], ecx
  0010f	0f b6 c8	 movzx	 ecx, al
  00112	8b 44 24 3c	 mov	 eax, DWORD PTR tv155[rsp]
  00116	d3 f8		 sar	 eax, cl
$LN1@float32_cl:

; 391  : }

  00118	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011c	c3		 ret	 0
float32_class ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
neg$ = 32
tv66 = 36
tv136 = 40
tv144 = 44
tv149 = 48
tv155 = 52
tv160 = 56
tv163 = 60
op$ = 80
float64_class PROC

; 368  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 369  :     int neg = (op.v & 0x8000000000000000ULL ) ? 1 : 0;

  00009	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00018	48 23 c8	 and	 rcx, rax
  0001b	48 8b c1	 mov	 rax, rcx
  0001e	48 85 c0	 test	 rax, rax
  00021	74 0a		 je	 SHORT $LN8@float64_cl
  00023	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0002b	eb 08		 jmp	 SHORT $LN9@float64_cl
$LN8@float64_cl:
  0002d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN9@float64_cl:
  00035	8b 44 24 24	 mov	 eax, DWORD PTR tv66[rsp]
  00039	89 44 24 20	 mov	 DWORD PTR neg$[rsp], eax

; 370  : 
; 371  :     if (f64_isSignalingNaN( op ))           {return float_class_pos_signaling_nan >> neg;}

  0003d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00042	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00047	0f b6 c0	 movzx	 eax, al
  0004a	85 c0		 test	 eax, eax
  0004c	74 1b		 je	 SHORT $LN2@float64_cl
  0004e	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  00052	b9 02 00 00 00	 mov	 ecx, 2
  00057	89 4c 24 28	 mov	 DWORD PTR tv136[rsp], ecx
  0005b	0f b6 c8	 movzx	 ecx, al
  0005e	8b 44 24 28	 mov	 eax, DWORD PTR tv136[rsp]
  00062	d3 f8		 sar	 eax, cl
  00064	e9 12 01 00 00	 jmp	 $LN1@float64_cl
$LN2@float64_cl:

; 372  :     if (FLOAT64_ISNAN( op ))                {return float_class_pos_quiet_nan     >> neg;}

  00069	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00078	48 23 c8	 and	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00088	48 3b c1	 cmp	 rax, rcx
  0008b	75 35		 jne	 SHORT $LN3@float64_cl
  0008d	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00097	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  0009c	48 23 c8	 and	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx
  000a2	48 85 c0	 test	 rax, rax
  000a5	74 1b		 je	 SHORT $LN3@float64_cl
  000a7	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  000ab	b9 08 00 00 00	 mov	 ecx, 8
  000b0	89 4c 24 2c	 mov	 DWORD PTR tv144[rsp], ecx
  000b4	0f b6 c8	 movzx	 ecx, al
  000b7	8b 44 24 2c	 mov	 eax, DWORD PTR tv144[rsp]
  000bb	d3 f8		 sar	 eax, cl
  000bd	e9 b9 00 00 00	 jmp	 $LN1@float64_cl
$LN3@float64_cl:

; 373  :     if (!(op.v & 0x7FFFFFFFFFFFFFFFULL ))   {return float_class_pos_zero          >> neg;}

  000c2	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000d1	48 23 c8	 and	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 85 c0	 test	 rax, rax
  000da	75 1b		 jne	 SHORT $LN4@float64_cl
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  000e0	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  000e5	89 4c 24 30	 mov	 DWORD PTR tv149[rsp], ecx
  000e9	0f b6 c8	 movzx	 ecx, al
  000ec	8b 44 24 30	 mov	 eax, DWORD PTR tv149[rsp]
  000f0	d3 f8		 sar	 eax, cl
  000f2	e9 84 00 00 00	 jmp	 $LN1@float64_cl
$LN4@float64_cl:

; 374  :     if ( (op.v & 0x7FFFFFFFFFFFFFFFULL )
; 375  :               == 0x7FF0000000000000ULL )    {return float_class_pos_infinity      >> neg;}

  000f7	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00101	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00106	48 23 c8	 and	 rcx, rax
  00109	48 8b c1	 mov	 rax, rcx
  0010c	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00116	48 3b c1	 cmp	 rax, rcx
  00119	75 18		 jne	 SHORT $LN5@float64_cl
  0011b	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  0011f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00124	89 4c 24 34	 mov	 DWORD PTR tv155[rsp], ecx
  00128	0f b6 c8	 movzx	 ecx, al
  0012b	8b 44 24 34	 mov	 eax, DWORD PTR tv155[rsp]
  0012f	d3 f8		 sar	 eax, cl
  00131	eb 48		 jmp	 SHORT $LN1@float64_cl
$LN5@float64_cl:

; 376  :     if (  op.v & 0x7FF0000000000000ULL )    {return float_class_pos_normal        >> neg;}

  00133	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0013d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00142	48 23 c8	 and	 rcx, rax
  00145	48 8b c1	 mov	 rax, rcx
  00148	48 85 c0	 test	 rax, rax
  0014b	74 18		 je	 SHORT $LN6@float64_cl
  0014d	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  00151	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00156	89 4c 24 38	 mov	 DWORD PTR tv160[rsp], ecx
  0015a	0f b6 c8	 movzx	 ecx, al
  0015d	8b 44 24 38	 mov	 eax, DWORD PTR tv160[rsp]
  00161	d3 f8		 sar	 eax, cl
  00163	eb 16		 jmp	 SHORT $LN1@float64_cl
$LN6@float64_cl:

; 377  :                                              return float_class_pos_subnormal     >> neg;

  00165	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  00169	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0016e	89 4c 24 3c	 mov	 DWORD PTR tv163[rsp], ecx
  00172	0f b6 c8	 movzx	 ecx, al
  00175	8b 44 24 3c	 mov	 eax, DWORD PTR tv163[rsp]
  00179	d3 f8		 sar	 eax, cl
$LN1@float64_cl:

; 378  : }

  0017b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017f	c3		 ret	 0
float64_class ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
neg$ = 32
tv69 = 36
tv172 = 40
tv186 = 44
tv195 = 48
tv205 = 52
tv212 = 56
tv215 = 60
$T1 = 64
op$ = 112
float128_class PROC

; 355  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 356  :     int neg = (op.v[FLOAT128_HI] & 0x8000000000000000ULL ) ? 1 : 0;

  0000b	b8 08 00 00 00	 mov	 eax, 8
  00010	48 6b c0 01	 imul	 rax, rax, 1
  00014	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  00019	48 ba 00 00 00
	00 00 00 00 80	 mov	 rdx, -9223372036854775808 ; 8000000000000000H
  00023	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00027	48 23 c2	 and	 rax, rdx
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 0a		 je	 SHORT $LN9@float128_c
  0002f	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  00037	eb 08		 jmp	 SHORT $LN10@float128_c
$LN9@float128_c:
  00039	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN10@float128_c:
  00041	8b 44 24 24	 mov	 eax, DWORD PTR tv69[rsp]
  00045	89 44 24 20	 mov	 DWORD PTR neg$[rsp], eax

; 357  : 
; 358  :     if (f128_isSignalingNaN( op ))                                           {return float_class_pos_signaling_nan >> neg;}

  00049	48 8d 44 24 40	 lea	 rax, QWORD PTR $T1[rsp]
  0004e	48 8b f8	 mov	 rdi, rax
  00051	48 8b 74 24 70	 mov	 rsi, QWORD PTR op$[rsp]
  00056	b9 10 00 00 00	 mov	 ecx, 16
  0005b	f3 a4		 rep movsb
  0005d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T1[rsp]
  00062	e8 00 00 00 00	 call	 f128_isSignalingNaN
  00067	0f b6 c0	 movzx	 eax, al
  0006a	85 c0		 test	 eax, eax
  0006c	74 1b		 je	 SHORT $LN2@float128_c
  0006e	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  00072	b9 02 00 00 00	 mov	 ecx, 2
  00077	89 4c 24 28	 mov	 DWORD PTR tv172[rsp], ecx
  0007b	0f b6 c8	 movzx	 ecx, al
  0007e	8b 44 24 28	 mov	 eax, DWORD PTR tv172[rsp]
  00082	d3 f8		 sar	 eax, cl
  00084	e9 83 01 00 00	 jmp	 $LN1@float128_c
$LN2@float128_c:

; 359  :     if (FLOAT128_ISNAN( op ))                                                {return float_class_pos_quiet_nan     >> neg;}

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  00097	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  000a1	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a5	48 23 c2	 and	 rax, rdx
  000a8	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  000b2	48 3b c1	 cmp	 rax, rcx
  000b5	75 54		 jne	 SHORT $LN3@float128_c
  000b7	b8 08 00 00 00	 mov	 eax, 8
  000bc	48 6b c0 01	 imul	 rax, rax, 1
  000c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  000c5	48 ba ff ff ff
	ff ff ff 00 00	 mov	 rdx, 281474976710655	; 0000ffffffffffffH
  000cf	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000d3	48 23 c2	 and	 rax, rdx
  000d6	48 85 c0	 test	 rax, rax
  000d9	75 15		 jne	 SHORT $LN4@float128_c
  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  000e9	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000ee	74 1b		 je	 SHORT $LN3@float128_c
$LN4@float128_c:
  000f0	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  000f4	b9 08 00 00 00	 mov	 ecx, 8
  000f9	89 4c 24 2c	 mov	 DWORD PTR tv186[rsp], ecx
  000fd	0f b6 c8	 movzx	 ecx, al
  00100	8b 44 24 2c	 mov	 eax, DWORD PTR tv186[rsp]
  00104	d3 f8		 sar	 eax, cl
  00106	e9 01 01 00 00	 jmp	 $LN1@float128_c
$LN3@float128_c:

; 360  :     if (!(op.v[FLOAT128_HI] & 0x7FFFFFFFFFFFFFFFULL ) && !op.v[FLOAT128_LO]) {return float_class_pos_zero          >> neg;}

  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  00119	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  00123	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00127	48 23 c2	 and	 rax, rdx
  0012a	48 85 c0	 test	 rax, rax
  0012d	75 30		 jne	 SHORT $LN5@float128_c
  0012f	b8 08 00 00 00	 mov	 eax, 8
  00134	48 6b c0 00	 imul	 rax, rax, 0
  00138	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  0013d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00142	75 1b		 jne	 SHORT $LN5@float128_c
  00144	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  00148	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0014d	89 4c 24 30	 mov	 DWORD PTR tv195[rsp], ecx
  00151	0f b6 c8	 movzx	 ecx, al
  00154	8b 44 24 30	 mov	 eax, DWORD PTR tv195[rsp]
  00158	d3 f8		 sar	 eax, cl
  0015a	e9 ad 00 00 00	 jmp	 $LN1@float128_c
$LN5@float128_c:

; 361  :     if ( (op.v[FLOAT128_HI] & 0x7FFFFFFFFFFFFFFFULL )
; 362  :                            == 0x7FFF000000000000ULL   && !op.v[FLOAT128_LO]) {return float_class_pos_infinity      >> neg;}

  0015f	b8 08 00 00 00	 mov	 eax, 8
  00164	48 6b c0 01	 imul	 rax, rax, 1
  00168	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  0016d	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  00177	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0017b	48 23 c2	 and	 rax, rdx
  0017e	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00188	48 3b c1	 cmp	 rax, rcx
  0018b	75 2d		 jne	 SHORT $LN6@float128_c
  0018d	b8 08 00 00 00	 mov	 eax, 8
  00192	48 6b c0 00	 imul	 rax, rax, 0
  00196	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  0019b	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  001a0	75 18		 jne	 SHORT $LN6@float128_c
  001a2	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  001a6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001ab	89 4c 24 34	 mov	 DWORD PTR tv205[rsp], ecx
  001af	0f b6 c8	 movzx	 ecx, al
  001b2	8b 44 24 34	 mov	 eax, DWORD PTR tv205[rsp]
  001b6	d3 f8		 sar	 eax, cl
  001b8	eb 52		 jmp	 SHORT $LN1@float128_c
$LN6@float128_c:

; 363  :     if (  op.v[FLOAT128_HI] & 0x7FFF000000000000ULL )                        {return float_class_pos_normal        >> neg;}

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op$[rsp]
  001c8	48 ba 00 00 00
	00 00 00 ff 7f	 mov	 rdx, 9223090561878065152 ; 7fff000000000000H
  001d2	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  001d6	48 23 c2	 and	 rax, rdx
  001d9	48 85 c0	 test	 rax, rax
  001dc	74 18		 je	 SHORT $LN7@float128_c
  001de	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  001e2	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001e7	89 4c 24 38	 mov	 DWORD PTR tv212[rsp], ecx
  001eb	0f b6 c8	 movzx	 ecx, al
  001ee	8b 44 24 38	 mov	 eax, DWORD PTR tv212[rsp]
  001f2	d3 f8		 sar	 eax, cl
  001f4	eb 16		 jmp	 SHORT $LN1@float128_c
$LN7@float128_c:

; 364  :                                                                               return float_class_pos_subnormal     >> neg;

  001f6	8b 44 24 20	 mov	 eax, DWORD PTR neg$[rsp]
  001fa	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001ff	89 4c 24 3c	 mov	 DWORD PTR tv215[rsp], ecx
  00203	0f b6 c8	 movzx	 ecx, al
  00206	8b 44 24 3c	 mov	 eax, DWORD PTR tv215[rsp]
  0020a	d3 f8		 sar	 eax, cl
$LN1@float128_c:

; 365  : }

  0020c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00210	5f		 pop	 rdi
  00211	5e		 pop	 rsi
  00212	c3		 ret	 0
float128_class ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
tv83 = 32
tv93 = 36
tv95 = 40
tv142 = 44
tv152 = 48
tv154 = 52
tv169 = 56
regs$ = 80
ieee_traps$ = 88
ieee_cond_trap PROC

; 292  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 293  :     /* ieee_cond_trap is called before instruction completion for Xi    */
; 294  :     /* and Xz traps, resulting in instruction suppression.              */
; 295  :     /* For other instructions, it is called after instruction results   */
; 296  :     /* have been stored.                                                */
; 297  : 
; 298  :     /* PROGRAMMING NOTE: for the underflow/overflow and inexact         */
; 299  :     /* data exceptions, SoftFloat does not distinguish between          */
; 300  :     /* inexact and truncated or inexact and incremented, so neither     */
; 301  :     /* can we. Thus for now we will always return "truncated."          */
; 302  :     /* We can tell the difference between exact and inexact.            */
; 303  : 
; 304  :     /* We will add inexact and incremented when we get Softfloat up to  */
; 305  :     /* speed on returning and incremented indication.                   */
; 306  : 
; 307  :     /* Note: switch/case does not work here because multiple            */
; 308  :     /* exceptions may be passed by the caller.                          */
; 309  : 
; 310  :     if (ieee_traps & FPC_MASK_IMI)

  0000d	8b 44 24 58	 mov	 eax, DWORD PTR ieee_traps$[rsp]
  00011	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00016	85 c0		 test	 eax, eax
  00018	74 11		 je	 SHORT $LN2@ieee_cond_

; 311  :         ieee_trap( regs, DXC_IEEE_INVALID_OP );

  0001a	b2 80		 mov	 dl, 128			; 00000080H
  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00021	e8 00 00 00 00	 call	 ieee_trap
  00026	e9 c6 01 00 00	 jmp	 $LN3@ieee_cond_
$LN2@ieee_cond_:

; 312  : 
; 313  :     else if (ieee_traps & FPC_MASK_IMZ)

  0002b	8b 44 24 58	 mov	 eax, DWORD PTR ieee_traps$[rsp]
  0002f	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00034	85 c0		 test	 eax, eax
  00036	74 11		 je	 SHORT $LN4@ieee_cond_

; 314  :         ieee_trap( regs, DXC_IEEE_DIV_ZERO );

  00038	b2 40		 mov	 dl, 64			; 00000040H
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	e8 00 00 00 00	 call	 ieee_trap
  00044	e9 a8 01 00 00	 jmp	 $LN5@ieee_cond_
$LN4@ieee_cond_:

; 315  : 
; 316  :     else if (ieee_traps & FPC_MASK_IMO)

  00049	8b 44 24 58	 mov	 eax, DWORD PTR ieee_traps$[rsp]
  0004d	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00052	85 c0		 test	 eax, eax
  00054	0f 84 9b 00 00
	00		 je	 $LN6@ieee_cond_

; 317  :         ieee_trap( regs, !(softfloat_exceptionFlags & softfloat_flag_inexact)    ? DXC_IEEE_OF_EXACT :

  0005a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0005f	8b c0		 mov	 eax, eax
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00067	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00070	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00074	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00078	83 e0 01	 and	 eax, 1
  0007b	85 c0		 test	 eax, eax
  0007d	75 0a		 jne	 SHORT $LN12@ieee_cond_
  0007f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  00087	eb 08		 jmp	 SHORT $LN13@ieee_cond_
$LN12@ieee_cond_:
  00089	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN13@ieee_cond_:
  00091	83 7c 24 20 00	 cmp	 DWORD PTR tv83[rsp], 0
  00096	74 0a		 je	 SHORT $LN16@ieee_cond_
  00098	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR tv95[rsp], 32	; 00000020H
  000a0	eb 3f		 jmp	 SHORT $LN17@ieee_cond_
$LN16@ieee_cond_:
  000a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  000a7	8b c0		 mov	 eax, eax
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c0	83 e0 20	 and	 eax, 32			; 00000020H
  000c3	85 c0		 test	 eax, eax
  000c5	74 0a		 je	 SHORT $LN14@ieee_cond_
  000c7	c7 44 24 24 2c
	00 00 00	 mov	 DWORD PTR tv93[rsp], 44	; 0000002cH
  000cf	eb 08		 jmp	 SHORT $LN15@ieee_cond_
$LN14@ieee_cond_:
  000d1	c7 44 24 24 28
	00 00 00	 mov	 DWORD PTR tv93[rsp], 40	; 00000028H
$LN15@ieee_cond_:
  000d9	8b 44 24 24	 mov	 eax, DWORD PTR tv93[rsp]
  000dd	89 44 24 28	 mov	 DWORD PTR tv95[rsp], eax
$LN17@ieee_cond_:
  000e1	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv95[rsp]
  000e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	e8 00 00 00 00	 call	 ieee_trap
  000f0	e9 fc 00 00 00	 jmp	 $LN7@ieee_cond_
$LN6@ieee_cond_:

; 318  :                            softfloat_exceptionFlags & softfloat_flag_incremented ? DXC_IEEE_OF_INEX_INCR
; 319  :                                                                                  : DXC_IEEE_OF_INEX_TRUNC );
; 320  :     else if (ieee_traps & FPC_MASK_IMU)

  000f5	8b 44 24 58	 mov	 eax, DWORD PTR ieee_traps$[rsp]
  000f9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000fe	85 c0		 test	 eax, eax
  00100	0f 84 98 00 00
	00		 je	 $LN8@ieee_cond_

; 321  :         ieee_trap( regs, !(softfloat_exceptionFlags & softfloat_flag_inexact)    ? DXC_IEEE_UF_EXACT :

  00106	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0010b	8b c0		 mov	 eax, eax
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00113	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0011c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00120	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00124	83 e0 01	 and	 eax, 1
  00127	85 c0		 test	 eax, eax
  00129	75 0a		 jne	 SHORT $LN18@ieee_cond_
  0012b	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  00133	eb 08		 jmp	 SHORT $LN19@ieee_cond_
$LN18@ieee_cond_:
  00135	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN19@ieee_cond_:
  0013d	83 7c 24 2c 00	 cmp	 DWORD PTR tv142[rsp], 0
  00142	74 0a		 je	 SHORT $LN22@ieee_cond_
  00144	c7 44 24 34 10
	00 00 00	 mov	 DWORD PTR tv154[rsp], 16
  0014c	eb 3f		 jmp	 SHORT $LN23@ieee_cond_
$LN22@ieee_cond_:
  0014e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00153	8b c0		 mov	 eax, eax
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0015b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00164	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00168	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0016c	83 e0 20	 and	 eax, 32			; 00000020H
  0016f	85 c0		 test	 eax, eax
  00171	74 0a		 je	 SHORT $LN20@ieee_cond_
  00173	c7 44 24 30 1c
	00 00 00	 mov	 DWORD PTR tv152[rsp], 28
  0017b	eb 08		 jmp	 SHORT $LN21@ieee_cond_
$LN20@ieee_cond_:
  0017d	c7 44 24 30 18
	00 00 00	 mov	 DWORD PTR tv152[rsp], 24
$LN21@ieee_cond_:
  00185	8b 44 24 30	 mov	 eax, DWORD PTR tv152[rsp]
  00189	89 44 24 34	 mov	 DWORD PTR tv154[rsp], eax
$LN23@ieee_cond_:
  0018d	0f b6 54 24 34	 movzx	 edx, BYTE PTR tv154[rsp]
  00192	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	e8 00 00 00 00	 call	 ieee_trap
  0019c	eb 53		 jmp	 SHORT $LN9@ieee_cond_
$LN8@ieee_cond_:

; 322  :                            softfloat_exceptionFlags & softfloat_flag_incremented ? DXC_IEEE_UF_INEX_INCR
; 323  :                                                                                  : DXC_IEEE_UF_INEX_TRUNC );
; 324  :     else if (ieee_traps & FPC_MASK_IMX)

  0019e	8b 44 24 58	 mov	 eax, DWORD PTR ieee_traps$[rsp]
  001a2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001a7	85 c0		 test	 eax, eax
  001a9	74 46		 je	 SHORT $LN10@ieee_cond_

; 325  :         ieee_trap( regs,   softfloat_exceptionFlags & softfloat_flag_incremented ? DXC_IEEE_INEXACT_INCR

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b0	8b c0		 mov	 eax, eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c9	83 e0 20	 and	 eax, 32			; 00000020H
  001cc	85 c0		 test	 eax, eax
  001ce	74 0a		 je	 SHORT $LN24@ieee_cond_
  001d0	c7 44 24 38 0c
	00 00 00	 mov	 DWORD PTR tv169[rsp], 12
  001d8	eb 08		 jmp	 SHORT $LN25@ieee_cond_
$LN24@ieee_cond_:
  001da	c7 44 24 38 08
	00 00 00	 mov	 DWORD PTR tv169[rsp], 8
$LN25@ieee_cond_:
  001e2	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv169[rsp]
  001e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001ec	e8 00 00 00 00	 call	 ieee_trap
$LN10@ieee_cond_:
$LN9@ieee_cond_:
$LN7@ieee_cond_:
$LN5@ieee_cond_:
$LN3@ieee_cond_:

; 326  :                                                                                  : DXC_IEEE_INEXACT_TRUNC );
; 327  : }

  001f1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f5	c3		 ret	 0
ieee_cond_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
regs$ = 48
dxc$ = 56
ieee_trap PROC

; 284  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 285  :     regs->dxc = dxc;                   /*  Save DXC in PSA         */

  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR dxc$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 286  :     regs->fpc &= ~FPC_DXC;             /*  Clear any previous DXC  */

  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00028	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 287  :     regs->fpc |= ((U32)dxc << FPC_DXC_SHIFT);

  00038	0f b6 44 24 38	 movzx	 eax, BYTE PTR dxc$[rsp]
  0003d	c1 e0 08	 shl	 eax, 8
  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0004b	0b c8		 or	 ecx, eax
  0004d	8b c1		 mov	 eax, ecx
  0004f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 288  :     regs->program_interrupt( regs, PGM_DATA_EXCEPTION );

  0005a	ba 07 00 00 00	 mov	 edx, 7
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00069	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 289  : }

  0006f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00073	c3		 ret	 0
ieee_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch8
_TEXT	SEGMENT
tv70 = 48
tv76 = 52
tv88 = 56
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch8 PROC					; COMDAT

; 711  : {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0001a	3d f8 07 00 00	 cmp	 eax, 2040		; 000007f8H
  0001f	77 0a		 ja	 SHORT $LN10@s370_vfetc
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN11@s370_vfetc
$LN10@s370_vfetc:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN11@s370_vfetc:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00038	0f 84 9b 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );

  0003e	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00043	73 0a		 jae	 SHORT $LN14@s370_vfetc
  00045	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0004d	eb 08		 jmp	 SHORT $LN15@s370_vfetc
$LN14@s370_vfetc:
  0004f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN15@s370_vfetc:
  00057	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  0005c	74 16		 je	 SHORT $LN16@s370_vfetc
  0005e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00062	83 c0 07	 add	 eax, 7
  00065	83 f8 50	 cmp	 eax, 80			; 00000050H
  00068	72 0a		 jb	 SHORT $LN16@s370_vfetc
  0006a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  00072	eb 08		 jmp	 SHORT $LN22@s370_vfetc
$LN16@s370_vfetc:
  00074	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN22@s370_vfetc:
  0007c	83 7c 24 38 00	 cmp	 DWORD PTR tv88[rsp], 0
  00081	74 0a		 je	 SHORT $LN6@s370_vfetc
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	e8 00 00 00 00	 call	 s370_store_int_timer
$LN6@s370_vfetc:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00093	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00098	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0009c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000a0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000a8	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ad	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000b2	ba 08 00 00 00	 mov	 edx, 8
  000b7	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000bb	e8 00 00 00 00	 call	 s370_maddr_l
  000c0	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ca	e8 00 00 00 00	 call	 fetch_dw_noswap
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 _byteswap_uint64
  000d7	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  000d9	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000de	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  000e2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000e6	e8 00 00 00 00	 call	 s370_vfetch8_full
$LN1@s370_vfetc:

; 737  : }

  000eb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ef	c3		 ret	 0
s370_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch4 PROC					; COMDAT

; 695  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  0005c	0f 87 9a 00 00
	00		 ja	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 16		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008c	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00096	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00098	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  000a0	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a5	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000c0	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d1	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d6	ba 04 00 00 00	 mov	 edx, 4
  000db	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000df	e8 00 00 00 00	 call	 s370_maddr_l
  000e4	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ee	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f3	8b c8		 mov	 ecx, eax
  000f5	e8 00 00 00 00	 call	 _byteswap_ulong
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch4_full
$LN1@s370_vfetc:

; 705  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00029	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002e	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00033	2b c8		 sub	 ecx, eax
  00035	8b c1		 mov	 eax, ecx
  00037	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00040	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00050	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00058	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00060	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00068	48 8b d0	 mov	 rdx, rax
  0006b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00072	e8 00 00 00 00	 call	 s370_maddr_l
  00077	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  0007c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00081	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00086	48 8b f9	 mov	 rdi, rcx
  00089	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00093	b8 08 00 00 00	 mov	 eax, 8
  00098	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009c	48 98		 cdqe
  0009e	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a2	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000a9	03 d1		 add	 edx, ecx
  000ab	8b ca		 mov	 ecx, edx
  000ad	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000b3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bf	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c3	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cb	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d3	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000db	48 8b d0	 mov	 rdx, rax
  000de	e8 00 00 00 00	 call	 s370_maddr_l
  000e3	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000e8	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  000f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f5	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  000fa	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  000ff	e8 00 00 00 00	 call	 fetch_dw_noswap
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0010c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s370_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s370_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b3	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000bf	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	e8 00 00 00 00	 call	 s370_maddr_l
  000d4	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000d9	b8 04 00 00 00	 mov	 eax, 4
  000de	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000e2	48 98		 cdqe
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000e9	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000ee	48 8b f9	 mov	 rdi, rcx
  000f1	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00100	e8 00 00 00 00	 call	 fetch_fw_noswap
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0010c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
tv161 = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s370_test_data_class_bfp_short PROC

; 5027 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5028 :     int        r1, x2, b2;
; 5029 :     VADR       effective_addr2;
; 5030 :     float32_t  op1;
; 5031 : 
; 5032 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s370_test_
  00053	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  00070	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s370_test_
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000a2	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000a6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ab	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 06	 add	 rax, 6
  000bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN7@s370_test_
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 d1		 jne	 SHORT $LN4@s370_test_

; 5033 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5034 :     BFPINST_CHECK( regs );

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	85 c0		 test	 eax, eax
  000fa	74 39		 je	 SHORT $LN9@s370_test_
  000fc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00107	d1 e8		 shr	 eax, 1
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	74 49		 je	 SHORT $LN8@s370_test_
  00110	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	48 6b c9 01	 imul	 rcx, rcx, 1
  00125	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	75 24		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00135	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00144	ba 07 00 00 00	 mov	 edx, 7
  00149	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00153	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5035 : 
; 5036 :     GET_FLOAT32_OP( op1, r1, regs );

  00159	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	48 98		 cdqe
  00161	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016e	48 8b d0	 mov	 rdx, rax
  00171	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00176	e8 00 00 00 00	 call	 s370_get_float32

; 5037 : 
; 5038 :     regs->psw.cc = !!(((U32)effective_addr2) & float32_class( op1 ));

  0017b	8b 4c 24 38	 mov	 ecx, DWORD PTR op1$[rsp]
  0017f	e8 00 00 00 00	 call	 float32_class
  00184	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00188	23 c8		 and	 ecx, eax
  0018a	8b c1		 mov	 eax, ecx
  0018c	85 c0		 test	 eax, eax
  0018e	74 0a		 je	 SHORT $LN11@s370_test_
  00190	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  00198	eb 08		 jmp	 SHORT $LN12@s370_test_
$LN11@s370_test_:
  0019a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN12@s370_test_:
  001a2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001a7	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv161[rsp]
  001ac	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5039 : }

  001af	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b3	c3		 ret	 0
s370_test_data_class_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
tv161 = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s370_test_data_class_bfp_long PROC

; 5046 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5047 :     int        r1, x2, b2;
; 5048 :     VADR       effective_addr2;
; 5049 :     float64_t  op1;
; 5050 : 
; 5051 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s370_test_
  00053	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  00070	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s370_test_
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000a2	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000a6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ab	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 06	 add	 rax, 6
  000bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN7@s370_test_
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 d1		 jne	 SHORT $LN4@s370_test_

; 5052 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5053 :     BFPINST_CHECK( regs );

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	85 c0		 test	 eax, eax
  000fa	74 39		 je	 SHORT $LN9@s370_test_
  000fc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00107	d1 e8		 shr	 eax, 1
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	74 49		 je	 SHORT $LN8@s370_test_
  00110	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	48 6b c9 01	 imul	 rcx, rcx, 1
  00125	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	75 24		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00135	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00144	ba 07 00 00 00	 mov	 edx, 7
  00149	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00153	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5054 : 
; 5055 :     GET_FLOAT64_OP( op1, r1, regs );

  00159	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	48 98		 cdqe
  00161	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016e	48 8b d0	 mov	 rdx, rax
  00171	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00176	e8 00 00 00 00	 call	 s370_get_float64

; 5056 : 
; 5057 :     regs->psw.cc = !!(((U32)effective_addr2) & float64_class( op1 ));

  0017b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op1$[rsp]
  00180	e8 00 00 00 00	 call	 float64_class
  00185	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00189	23 c8		 and	 ecx, eax
  0018b	8b c1		 mov	 eax, ecx
  0018d	85 c0		 test	 eax, eax
  0018f	74 0a		 je	 SHORT $LN11@s370_test_
  00191	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  00199	eb 08		 jmp	 SHORT $LN12@s370_test_
$LN11@s370_test_:
  0019b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN12@s370_test_:
  001a3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv161[rsp]
  001ad	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5058 : }

  001b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b4	c3		 ret	 0
s370_test_data_class_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r1$ = 48
tv166 = 52
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
s370_test_data_class_bfp_ext PROC

; 5065 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5066 :     int         r1, x2, b2;
; 5067 :     VADR        effective_addr2;
; 5068 :     float128_t  op1;
; 5069 : 
; 5070 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 10	 shr	 eax, 16
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 14	 shr	 eax, 20
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00060	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00065	74 20		 je	 SHORT $LN5@s370_test_
  00067	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  00087	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 0c	 shr	 eax, 12
  0008e	83 e0 0f	 and	 eax, 15
  00091	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00095	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009a	74 20		 je	 SHORT $LN6@s370_test_
  0009c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b4	03 c8		 add	 ecx, eax
  000b6	8b c1		 mov	 eax, ecx
  000b8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000bc	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000c9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d5	48 83 c0 06	 add	 rax, 6
  000d9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e5	33 c0		 xor	 eax, eax
  000e7	83 f8 06	 cmp	 eax, 6
  000ea	74 0f		 je	 SHORT $LN7@s370_test_
  000ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 c8		 jne	 SHORT $LN4@s370_test_

; 5071 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5072 :     BFPINST_CHECK( regs );

  00101	b8 08 00 00 00	 mov	 eax, 8
  00106	48 6b c0 01	 imul	 rax, rax, 1
  0010a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0011e	85 c0		 test	 eax, eax
  00120	74 3f		 je	 SHORT $LN9@s370_test_
  00122	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00130	d1 e8		 shr	 eax, 1
  00132	83 e0 01	 and	 eax, 1
  00135	85 c0		 test	 eax, eax
  00137	74 55		 je	 SHORT $LN8@s370_test_
  00139	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00141	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00148	b9 08 00 00 00	 mov	 ecx, 8
  0014d	48 6b c9 01	 imul	 rcx, rcx, 1
  00151	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00158	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0015d	85 c0		 test	 eax, eax
  0015f	75 2d		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00161	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00173	ba 07 00 00 00	 mov	 edx, 7
  00178	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00180	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00188	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5073 :     BFPREGPAIR_CHECK( r1, regs );

  0018e	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00192	83 e0 02	 and	 eax, 2
  00195	85 c0		 test	 eax, eax
  00197	74 1b		 je	 SHORT $LN10@s370_test_
  00199	ba 06 00 00 00	 mov	 edx, 6
  0019e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_test_:

; 5074 : 
; 5075 :     GET_FLOAT128_OP( op1, r1, regs );

  001b4	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001b8	d1 e0		 shl	 eax, 1
  001ba	48 98		 cdqe
  001bc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001cc	48 8b d0	 mov	 rdx, rax
  001cf	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  001d4	e8 00 00 00 00	 call	 s370_get_float128

; 5076 : 
; 5077 :     regs->psw.cc = !!(((U32)effective_addr2) & float128_class( op1 ));

  001d9	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  001de	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  001e3	48 8b f8	 mov	 rdi, rax
  001e6	48 8b f1	 mov	 rsi, rcx
  001e9	b9 10 00 00 00	 mov	 ecx, 16
  001ee	f3 a4		 rep movsb
  001f0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  001f5	e8 00 00 00 00	 call	 float128_class
  001fa	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001fe	23 c8		 and	 ecx, eax
  00200	8b c1		 mov	 eax, ecx
  00202	85 c0		 test	 eax, eax
  00204	74 0a		 je	 SHORT $LN12@s370_test_
  00206	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  0020e	eb 08		 jmp	 SHORT $LN13@s370_test_
$LN12@s370_test_:
  00210	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN13@s370_test_:
  00218	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00220	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv166[rsp]
  00225	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5078 : }

  00228	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0022d	48 33 cc	 xor	 rcx, rsp
  00230	e8 00 00 00 00	 call	 __security_check_cookie
  00235	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00239	5f		 pop	 rdi
  0023a	5e		 pop	 rsi
  0023b	c3		 ret	 0
s370_test_data_class_bfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ans$ = 32
ieee_trap_conds$ = 36
i$1 = 40
tv194 = 44
r1$ = 48
tv210 = 52
tv213 = 56
tv215 = 60
tv216 = 64
r2$ = 68
op2$ = 72
op1$ = 76
inst$ = 96
regs$ = 104
s370_subtract_bfp_short_reg PROC

; 4949 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4950 :     int        r1, r2;
; 4951 :     float32_t  op1, op2, ans;
; 4952 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4953 : 
; 4954 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_subtr:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@s370_subtr
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s370_subtr:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_subtr

; 4955 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4956 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN13@s370_subtr
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN12@s370_subtr
  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN12@s370_subtr
$LN13@s370_subtr:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_subtr:
$LN7@s370_subtr:

; 4957 : 
; 4958 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float32
  00111	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s370_get_float32
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s370_subtr

; 4959 : 
; 4960 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4961 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4962 : 
; 4963 :     ans = f32_sub( op1, op2 );

  00191	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00195	8b 4c 24 4c	 mov	 ecx, DWORD PTR op1$[rsp]
  00199	e8 00 00 00 00	 call	 f32_sub
  0019e	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax

; 4964 : 
; 4965 :     if (softfloat_exceptionFlags)

  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a7	8b c0		 mov	 eax, eax
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 93 00 00
	00		 je	 $LN14@s370_subtr

; 4966 :     {
; 4967 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001c8	33 c0		 xor	 eax, eax
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	74 45		 je	 SHORT $LN15@s370_subtr
  001cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d4	8b c0		 mov	 eax, eax
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	83 e0 10	 and	 eax, 16
  001f0	85 c0		 test	 eax, eax
  001f2	74 20		 je	 SHORT $LN15@s370_subtr
  001f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ff	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00204	85 c0		 test	 eax, eax
  00206	74 0c		 je	 SHORT $LN15@s370_subtr
  00208	b2 80		 mov	 dl, 128			; 00000080H
  0020a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	e8 00 00 00 00	 call	 ieee_trap
$LN15@s370_subtr:

; 4968 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00214	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0021e	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4969 : 
; 4970 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00222	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00226	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022b	85 c0		 test	 eax, eax
  0022d	74 2c		 je	 SHORT $LN16@s370_subtr

; 4971 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0022f	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00233	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN19@s370_subtr
  0023c	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv194[rsp], -192 ; ffffffffffffff40H
  00244	eb 08		 jmp	 SHORT $LN20@s370_subtr
$LN19@s370_subtr:
  00246	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv194[rsp], 192 ; 000000c0H
$LN20@s370_subtr:
  0024e	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv194[rsp]
  00252	e8 00 00 00 00	 call	 f32_scaledResult
  00257	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax
$LN16@s370_subtr:
$LN14@s370_subtr:
$LN10@s370_subtr:

; 4972 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4973 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4974 :     }
; 4975 : 
; 4976 :     PUT_FLOAT32_CC( ans, r1, regs );

  0025b	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0025f	d1 e0		 shl	 eax, 1
  00261	48 98		 cdqe
  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00270	48 8b d0	 mov	 rdx, rax
  00273	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ans$[rsp]
  00278	e8 00 00 00 00	 call	 s370_put_float32
  0027d	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00281	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00286	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0028b	75 17		 jne	 SHORT $LN21@s370_subtr
  0028d	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00291	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00296	85 c0		 test	 eax, eax
  00298	74 0a		 je	 SHORT $LN21@s370_subtr
  0029a	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv216[rsp], 3
  002a2	eb 5e		 jmp	 SHORT $LN28@s370_subtr
$LN21@s370_subtr:
  002a4	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  002a8	0f ba f0 1f	 btr	 eax, 31
  002ac	85 c0		 test	 eax, eax
  002ae	75 0a		 jne	 SHORT $LN22@s370_subtr
  002b0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  002b8	eb 08		 jmp	 SHORT $LN23@s370_subtr
$LN22@s370_subtr:
  002ba	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN23@s370_subtr:
  002c2	83 7c 24 34 00	 cmp	 DWORD PTR tv210[rsp], 0
  002c7	74 0a		 je	 SHORT $LN26@s370_subtr
  002c9	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  002d1	eb 27		 jmp	 SHORT $LN27@s370_subtr
$LN26@s370_subtr:
  002d3	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  002d7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002dc	85 c0		 test	 eax, eax
  002de	74 0a		 je	 SHORT $LN24@s370_subtr
  002e0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  002e8	eb 08		 jmp	 SHORT $LN25@s370_subtr
$LN24@s370_subtr:
  002ea	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv213[rsp], 2
$LN25@s370_subtr:
  002f2	8b 44 24 38	 mov	 eax, DWORD PTR tv213[rsp]
  002f6	89 44 24 3c	 mov	 DWORD PTR tv215[rsp], eax
$LN27@s370_subtr:
  002fa	8b 44 24 3c	 mov	 eax, DWORD PTR tv215[rsp]
  002fe	89 44 24 40	 mov	 DWORD PTR tv216[rsp], eax
$LN28@s370_subtr:
  00302	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00307	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv216[rsp]
  0030c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0030f	33 c0		 xor	 eax, eax
  00311	85 c0		 test	 eax, eax
  00313	0f 85 42 ff ff
	ff		 jne	 $LN10@s370_subtr

; 4977 : 
; 4978 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00319	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0031d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00322	85 c0		 test	 eax, eax
  00324	74 0e		 je	 SHORT $LN17@s370_subtr
  00326	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0032a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0032f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s370_subtr:

; 4979 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4980 : }

  00334	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00338	c3		 ret	 0
s370_subtract_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ans$ = 36
ieee_trap_conds$ = 40
temp$1 = 44
b2$ = 48
x2$ = 52
tv210 = 56
r1$ = 60
tv226 = 64
tv229 = 68
tv231 = 72
tv232 = 76
op2$ = 80
op1$ = 84
inst$ = 112
regs$ = 120
s370_subtract_bfp_short PROC

; 4986 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4987 :     int        r1, x2, b2;
; 4988 :     VADR       effective_addr2;
; 4989 :     float32_t  op1, op2, ans;
; 4990 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4991 : 
; 4992 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 34 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN8@s370_subtr
  0005b	48 63 44 24 34	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_subtr:
  00078	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN9@s370_subtr
  0008d	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_subtr:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000ae	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_subtr:
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f8 06	 cmp	 eax, 6
  000d2	74 0c		 je	 SHORT $LN10@s370_subtr
  000d4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_subtr:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d1		 jne	 SHORT $LN4@s370_subtr

; 4993 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4994 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4995 :     BFPINST_CHECK( regs );

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	74 39		 je	 SHORT $LN12@s370_subtr
  00104	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010f	d1 e8		 shr	 eax, 1
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 49		 je	 SHORT $LN11@s370_subtr
  00118	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00124	b9 08 00 00 00	 mov	 ecx, 8
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	75 24		 jne	 SHORT $LN11@s370_subtr
$LN12@s370_subtr:
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014c	ba 07 00 00 00	 mov	 edx, 7
  00151	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_subtr:

; 4996 : 
; 4997 :     GET_FLOAT32_OP( op1, r1, regs );

  00161	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00165	d1 e0		 shl	 eax, 1
  00167	48 98		 cdqe
  00169	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00176	48 8b d0	 mov	 rdx, rax
  00179	48 8d 4c 24 54	 lea	 rcx, QWORD PTR op1$[rsp]
  0017e	e8 00 00 00 00	 call	 s370_get_float32

; 4998 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00183	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00188	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  0018c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00190	e8 00 00 00 00	 call	 s370_vfetch4
  00195	89 44 24 50	 mov	 DWORD PTR op2$[rsp], eax

; 4999 : 
; 5000 :     softfloat_exceptionFlags = 0;

  00199	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019e	8b c0		 mov	 eax, eax
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5001 :     SET_SF_RM_FROM_FPC;

  001b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c2	83 e0 07	 and	 eax, 7
  001c5	8b c0		 mov	 eax, eax
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001d3	8b d2		 mov	 edx, edx
  001d5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001dc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001e5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5002 : 
; 5003 :     ans = f32_sub( op1, op2 );

  001f1	8b 54 24 50	 mov	 edx, DWORD PTR op2$[rsp]
  001f5	8b 4c 24 54	 mov	 ecx, DWORD PTR op1$[rsp]
  001f9	e8 00 00 00 00	 call	 f32_sub
  001fe	89 44 24 24	 mov	 DWORD PTR ans$[rsp], eax

; 5004 : 
; 5005 :     if (softfloat_exceptionFlags)

  00202	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00207	8b c0		 mov	 eax, eax
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00218	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00220	85 c0		 test	 eax, eax
  00222	0f 84 93 00 00
	00		 je	 $LN13@s370_subtr

; 5006 :     {
; 5007 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00228	33 c0		 xor	 eax, eax
  0022a	83 f8 01	 cmp	 eax, 1
  0022d	74 45		 je	 SHORT $LN14@s370_subtr
  0022f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00234	8b c0		 mov	 eax, eax
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00245	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00249	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024d	83 e0 10	 and	 eax, 16
  00250	85 c0		 test	 eax, eax
  00252	74 20		 je	 SHORT $LN14@s370_subtr
  00254	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00259	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0025f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00264	85 c0		 test	 eax, eax
  00266	74 0c		 je	 SHORT $LN14@s370_subtr
  00268	b2 80		 mov	 dl, 128			; 00000080H
  0026a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_subtr:

; 5008 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00274	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0027e	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5009 : 
; 5010 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00282	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00286	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0028b	85 c0		 test	 eax, eax
  0028d	74 2c		 je	 SHORT $LN15@s370_subtr

; 5011 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0028f	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00293	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00298	85 c0		 test	 eax, eax
  0029a	74 0a		 je	 SHORT $LN18@s370_subtr
  0029c	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv210[rsp], -192 ; ffffffffffffff40H
  002a4	eb 08		 jmp	 SHORT $LN19@s370_subtr
$LN18@s370_subtr:
  002a6	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv210[rsp], 192 ; 000000c0H
$LN19@s370_subtr:
  002ae	8b 4c 24 38	 mov	 ecx, DWORD PTR tv210[rsp]
  002b2	e8 00 00 00 00	 call	 f32_scaledResult
  002b7	89 44 24 24	 mov	 DWORD PTR ans$[rsp], eax
$LN15@s370_subtr:
$LN13@s370_subtr:
$LN7@s370_subtr:

; 5012 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 5013 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 5014 :     }
; 5015 : 
; 5016 :     PUT_FLOAT32_CC( ans, r1, regs );

  002bb	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  002bf	d1 e0		 shl	 eax, 1
  002c1	48 98		 cdqe
  002c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d0	48 8b d0	 mov	 rdx, rax
  002d3	48 8d 4c 24 24	 lea	 rcx, QWORD PTR ans$[rsp]
  002d8	e8 00 00 00 00	 call	 s370_put_float32
  002dd	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  002e1	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  002e6	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  002eb	75 17		 jne	 SHORT $LN20@s370_subtr
  002ed	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  002f1	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  002f6	85 c0		 test	 eax, eax
  002f8	74 0a		 je	 SHORT $LN20@s370_subtr
  002fa	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv232[rsp], 3
  00302	eb 5e		 jmp	 SHORT $LN27@s370_subtr
$LN20@s370_subtr:
  00304	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  00308	0f ba f0 1f	 btr	 eax, 31
  0030c	85 c0		 test	 eax, eax
  0030e	75 0a		 jne	 SHORT $LN21@s370_subtr
  00310	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  00318	eb 08		 jmp	 SHORT $LN22@s370_subtr
$LN21@s370_subtr:
  0031a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN22@s370_subtr:
  00322	83 7c 24 40 00	 cmp	 DWORD PTR tv226[rsp], 0
  00327	74 0a		 je	 SHORT $LN25@s370_subtr
  00329	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
  00331	eb 27		 jmp	 SHORT $LN26@s370_subtr
$LN25@s370_subtr:
  00333	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  00337	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0033c	85 c0		 test	 eax, eax
  0033e	74 0a		 je	 SHORT $LN23@s370_subtr
  00340	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv229[rsp], 1
  00348	eb 08		 jmp	 SHORT $LN24@s370_subtr
$LN23@s370_subtr:
  0034a	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv229[rsp], 2
$LN24@s370_subtr:
  00352	8b 44 24 44	 mov	 eax, DWORD PTR tv229[rsp]
  00356	89 44 24 48	 mov	 DWORD PTR tv231[rsp], eax
$LN26@s370_subtr:
  0035a	8b 44 24 48	 mov	 eax, DWORD PTR tv231[rsp]
  0035e	89 44 24 4c	 mov	 DWORD PTR tv232[rsp], eax
$LN27@s370_subtr:
  00362	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00367	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv232[rsp]
  0036c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0036f	33 c0		 xor	 eax, eax
  00371	85 c0		 test	 eax, eax
  00373	0f 85 42 ff ff
	ff		 jne	 $LN7@s370_subtr

; 5017 : 
; 5018 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00379	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0037d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00382	85 c0		 test	 eax, eax
  00384	74 0e		 je	 SHORT $LN16@s370_subtr
  00386	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0038a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0038f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_subtr:

; 5019 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 5020 : }

  00394	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00398	c3		 ret	 0
s370_subtract_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
ans$ = 40
i$1 = 48
tv194 = 52
r1$ = 56
tv210 = 60
tv213 = 64
tv215 = 68
tv216 = 72
r2$ = 76
op2$ = 80
op1$ = 88
inst$ = 112
regs$ = 120
s370_subtract_bfp_long_reg PROC

; 4872 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4873 :     int        r1, r2;
; 4874 :     float64_t  op1, op2, ans;
; 4875 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4876 : 
; 4877 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_subtr:
  00045	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@s370_subtr
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s370_subtr:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_subtr

; 4878 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4879 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN13@s370_subtr
  00092	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN12@s370_subtr
  000a6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN12@s370_subtr
$LN13@s370_subtr:
  000cb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_subtr:
$LN7@s370_subtr:

; 4880 : 
; 4881 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float64
  00111	8b 44 24 4c	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s370_get_float64
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s370_subtr

; 4882 : 
; 4883 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4884 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4885 : 
; 4886 :     ans = f64_sub( op1, op2 );

  00191	48 8b 54 24 50	 mov	 rdx, QWORD PTR op2$[rsp]
  00196	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 f64_sub
  001a0	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax

; 4887 : 
; 4888 :     if (softfloat_exceptionFlags)

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 94 00 00
	00		 je	 $LN14@s370_subtr

; 4889 :     {
; 4890 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001cb	33 c0		 xor	 eax, eax
  001cd	83 f8 01	 cmp	 eax, 1
  001d0	74 45		 je	 SHORT $LN15@s370_subtr
  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	83 e0 10	 and	 eax, 16
  001f3	85 c0		 test	 eax, eax
  001f5	74 20		 je	 SHORT $LN15@s370_subtr
  001f7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00202	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00207	85 c0		 test	 eax, eax
  00209	74 0c		 je	 SHORT $LN15@s370_subtr
  0020b	b2 80		 mov	 dl, 128			; 00000080H
  0020d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_trap
$LN15@s370_subtr:

; 4891 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00217	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00221	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4892 : 
; 4893 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00225	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00229	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022e	85 c0		 test	 eax, eax
  00230	74 2d		 je	 SHORT $LN16@s370_subtr

; 4894 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00232	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00236	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0023b	85 c0		 test	 eax, eax
  0023d	74 0a		 je	 SHORT $LN19@s370_subtr
  0023f	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv194[rsp], -1536 ; fffffffffffffa00H
  00247	eb 08		 jmp	 SHORT $LN20@s370_subtr
$LN19@s370_subtr:
  00249	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv194[rsp], 1536 ; 00000600H
$LN20@s370_subtr:
  00251	8b 4c 24 34	 mov	 ecx, DWORD PTR tv194[rsp]
  00255	e8 00 00 00 00	 call	 f64_scaledResult
  0025a	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax
$LN16@s370_subtr:
$LN14@s370_subtr:
$LN10@s370_subtr:

; 4895 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4896 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4897 :     }
; 4898 : 
; 4899 :     PUT_FLOAT64_CC( ans, r1, regs );

  0025f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00263	d1 e0		 shl	 eax, 1
  00265	48 98		 cdqe
  00267	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00274	48 8b d0	 mov	 rdx, rax
  00277	48 8d 4c 24 28	 lea	 rcx, QWORD PTR ans$[rsp]
  0027c	e8 00 00 00 00	 call	 s370_put_float64
  00281	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0028b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00290	48 23 c8	 and	 rcx, rax
  00293	48 8b c1	 mov	 rax, rcx
  00296	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  002a0	48 3b c1	 cmp	 rax, rcx
  002a3	75 24		 jne	 SHORT $LN21@s370_subtr
  002a5	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  002af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  002b4	48 23 c8	 and	 rcx, rax
  002b7	48 8b c1	 mov	 rax, rcx
  002ba	48 85 c0	 test	 rax, rax
  002bd	74 0a		 je	 SHORT $LN21@s370_subtr
  002bf	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR tv216[rsp], 3
  002c7	eb 79		 jmp	 SHORT $LN28@s370_subtr
$LN21@s370_subtr:
  002c9	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  002d8	48 23 c8	 and	 rcx, rax
  002db	48 8b c1	 mov	 rax, rcx
  002de	48 85 c0	 test	 rax, rax
  002e1	75 0a		 jne	 SHORT $LN22@s370_subtr
  002e3	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  002eb	eb 08		 jmp	 SHORT $LN23@s370_subtr
$LN22@s370_subtr:
  002ed	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN23@s370_subtr:
  002f5	83 7c 24 3c 00	 cmp	 DWORD PTR tv210[rsp], 0
  002fa	74 0a		 je	 SHORT $LN26@s370_subtr
  002fc	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  00304	eb 34		 jmp	 SHORT $LN27@s370_subtr
$LN26@s370_subtr:
  00306	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00310	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00315	48 23 c8	 and	 rcx, rax
  00318	48 8b c1	 mov	 rax, rcx
  0031b	48 85 c0	 test	 rax, rax
  0031e	74 0a		 je	 SHORT $LN24@s370_subtr
  00320	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  00328	eb 08		 jmp	 SHORT $LN25@s370_subtr
$LN24@s370_subtr:
  0032a	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv213[rsp], 2
$LN25@s370_subtr:
  00332	8b 44 24 40	 mov	 eax, DWORD PTR tv213[rsp]
  00336	89 44 24 44	 mov	 DWORD PTR tv215[rsp], eax
$LN27@s370_subtr:
  0033a	8b 44 24 44	 mov	 eax, DWORD PTR tv215[rsp]
  0033e	89 44 24 48	 mov	 DWORD PTR tv216[rsp], eax
$LN28@s370_subtr:
  00342	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00347	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv216[rsp]
  0034c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0034f	33 c0		 xor	 eax, eax
  00351	85 c0		 test	 eax, eax
  00353	0f 85 06 ff ff
	ff		 jne	 $LN10@s370_subtr

; 4900 : 
; 4901 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00359	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0035d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00362	85 c0		 test	 eax, eax
  00364	74 0e		 je	 SHORT $LN17@s370_subtr
  00366	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0036a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0036f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s370_subtr:

; 4902 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4903 : }

  00374	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00378	c3		 ret	 0
s370_subtract_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
ans$ = 48
x2$ = 56
tv210 = 60
r1$ = 64
tv226 = 68
tv229 = 72
tv231 = 76
tv232 = 80
op2$ = 88
op1$ = 96
inst$ = 128
regs$ = 136
s370_subtract_bfp_long PROC

; 4909 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4910 :     int        r1, x2, b2;
; 4911 :     VADR       effective_addr2;
; 4912 :     float64_t  op1, op2, ans;
; 4913 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4914 : 
; 4915 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00037	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 20		 je	 SHORT $LN8@s370_subtr
  0005e	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00072	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00076	03 c8		 add	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_subtr:
  0007e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 20		 je	 SHORT $LN9@s370_subtr
  00093	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ab	03 c8		 add	 ecx, eax
  000ad	8b c1		 mov	 eax, ecx
  000af	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_subtr:
  000b3	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000b7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000bc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_subtr:
  000c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000cc	48 83 c0 06	 add	 rax, 6
  000d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000dc	33 c0		 xor	 eax, eax
  000de	83 f8 06	 cmp	 eax, 6
  000e1	74 0f		 je	 SHORT $LN10@s370_subtr
  000e3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_subtr:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 c8		 jne	 SHORT $LN4@s370_subtr

; 4916 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4917 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4918 :     BFPINST_CHECK( regs );

  000f8	b8 08 00 00 00	 mov	 eax, 8
  000fd	48 6b c0 01	 imul	 rax, rax, 1
  00101	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00110	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00115	85 c0		 test	 eax, eax
  00117	74 3f		 je	 SHORT $LN12@s370_subtr
  00119	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00127	d1 e8		 shr	 eax, 1
  00129	83 e0 01	 and	 eax, 1
  0012c	85 c0		 test	 eax, eax
  0012e	74 55		 je	 SHORT $LN11@s370_subtr
  00130	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00138	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013f	b9 08 00 00 00	 mov	 ecx, 8
  00144	48 6b c9 01	 imul	 rcx, rcx, 1
  00148	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0014f	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00154	85 c0		 test	 eax, eax
  00156	75 2d		 jne	 SHORT $LN11@s370_subtr
$LN12@s370_subtr:
  00158	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0016a	ba 07 00 00 00	 mov	 edx, 7
  0016f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_subtr:

; 4919 : 
; 4920 :     GET_FLOAT64_OP( op1, r1, regs );

  00185	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  00189	d1 e0		 shl	 eax, 1
  0018b	48 98		 cdqe
  0018d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00195	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0019d	48 8b d0	 mov	 rdx, rax
  001a0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001a5	e8 00 00 00 00	 call	 s370_get_float64

; 4921 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001aa	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b2	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001b6	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001ba	e8 00 00 00 00	 call	 s370_vfetch8
  001bf	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 4922 : 
; 4923 :     softfloat_exceptionFlags = 0;

  001c4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c9	8b c0		 mov	 eax, eax
  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001da	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001de	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4924 :     SET_SF_RM_FROM_FPC;

  001e2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ea	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f0	83 e0 07	 and	 eax, 7
  001f3	8b c0		 mov	 eax, eax
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001fc	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00201	8b d2		 mov	 edx, edx
  00203	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0020a	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00213	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00217	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021b	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4925 : 
; 4926 :     ans = f64_sub( op1, op2 );

  0021f	48 8b 54 24 58	 mov	 rdx, QWORD PTR op2$[rsp]
  00224	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  00229	e8 00 00 00 00	 call	 f64_sub
  0022e	48 89 44 24 30	 mov	 QWORD PTR ans$[rsp], rax

; 4927 : 
; 4928 :     if (softfloat_exceptionFlags)

  00233	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00238	8b c0		 mov	 eax, eax
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00240	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00249	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00251	85 c0		 test	 eax, eax
  00253	0f 84 9d 00 00
	00		 je	 $LN13@s370_subtr

; 4929 :     {
; 4930 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00259	33 c0		 xor	 eax, eax
  0025b	83 f8 01	 cmp	 eax, 1
  0025e	74 4b		 je	 SHORT $LN14@s370_subtr
  00260	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00265	8b c0		 mov	 eax, eax
  00267	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00276	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027e	83 e0 10	 and	 eax, 16
  00281	85 c0		 test	 eax, eax
  00283	74 26		 je	 SHORT $LN14@s370_subtr
  00285	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00293	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00298	85 c0		 test	 eax, eax
  0029a	74 0f		 je	 SHORT $LN14@s370_subtr
  0029c	b2 80		 mov	 dl, 128			; 00000080H
  0029e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a6	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_subtr:

; 4931 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ab	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002b8	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4932 : 
; 4933 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002bc	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002c0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002c5	85 c0		 test	 eax, eax
  002c7	74 2d		 je	 SHORT $LN15@s370_subtr

; 4934 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002c9	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cd	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002d2	85 c0		 test	 eax, eax
  002d4	74 0a		 je	 SHORT $LN18@s370_subtr
  002d6	c7 44 24 3c 00
	fa ff ff	 mov	 DWORD PTR tv210[rsp], -1536 ; fffffffffffffa00H
  002de	eb 08		 jmp	 SHORT $LN19@s370_subtr
$LN18@s370_subtr:
  002e0	c7 44 24 3c 00
	06 00 00	 mov	 DWORD PTR tv210[rsp], 1536 ; 00000600H
$LN19@s370_subtr:
  002e8	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv210[rsp]
  002ec	e8 00 00 00 00	 call	 f64_scaledResult
  002f1	48 89 44 24 30	 mov	 QWORD PTR ans$[rsp], rax
$LN15@s370_subtr:
$LN13@s370_subtr:
$LN7@s370_subtr:

; 4935 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4936 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4937 :     }
; 4938 : 
; 4939 :     PUT_FLOAT64_CC( ans, r1, regs );

  002f6	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  002fa	d1 e0		 shl	 eax, 1
  002fc	48 98		 cdqe
  002fe	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00306	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0030e	48 8b d0	 mov	 rdx, rax
  00311	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  00316	e8 00 00 00 00	 call	 s370_put_float64
  0031b	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00325	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  0032a	48 23 c8	 and	 rcx, rax
  0032d	48 8b c1	 mov	 rax, rcx
  00330	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0033a	48 3b c1	 cmp	 rax, rcx
  0033d	75 24		 jne	 SHORT $LN20@s370_subtr
  0033f	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00349	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  0034e	48 23 c8	 and	 rcx, rax
  00351	48 8b c1	 mov	 rax, rcx
  00354	48 85 c0	 test	 rax, rax
  00357	74 0a		 je	 SHORT $LN20@s370_subtr
  00359	c7 44 24 50 03
	00 00 00	 mov	 DWORD PTR tv232[rsp], 3
  00361	eb 79		 jmp	 SHORT $LN27@s370_subtr
$LN20@s370_subtr:
  00363	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0036d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  00372	48 23 c8	 and	 rcx, rax
  00375	48 8b c1	 mov	 rax, rcx
  00378	48 85 c0	 test	 rax, rax
  0037b	75 0a		 jne	 SHORT $LN21@s370_subtr
  0037d	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  00385	eb 08		 jmp	 SHORT $LN22@s370_subtr
$LN21@s370_subtr:
  00387	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN22@s370_subtr:
  0038f	83 7c 24 44 00	 cmp	 DWORD PTR tv226[rsp], 0
  00394	74 0a		 je	 SHORT $LN25@s370_subtr
  00396	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
  0039e	eb 34		 jmp	 SHORT $LN26@s370_subtr
$LN25@s370_subtr:
  003a0	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  003aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  003af	48 23 c8	 and	 rcx, rax
  003b2	48 8b c1	 mov	 rax, rcx
  003b5	48 85 c0	 test	 rax, rax
  003b8	74 0a		 je	 SHORT $LN23@s370_subtr
  003ba	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv229[rsp], 1
  003c2	eb 08		 jmp	 SHORT $LN24@s370_subtr
$LN23@s370_subtr:
  003c4	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv229[rsp], 2
$LN24@s370_subtr:
  003cc	8b 44 24 48	 mov	 eax, DWORD PTR tv229[rsp]
  003d0	89 44 24 4c	 mov	 DWORD PTR tv231[rsp], eax
$LN26@s370_subtr:
  003d4	8b 44 24 4c	 mov	 eax, DWORD PTR tv231[rsp]
  003d8	89 44 24 50	 mov	 DWORD PTR tv232[rsp], eax
$LN27@s370_subtr:
  003dc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e4	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv232[rsp]
  003e9	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  003ec	33 c0		 xor	 eax, eax
  003ee	85 c0		 test	 eax, eax
  003f0	0f 85 00 ff ff
	ff		 jne	 $LN7@s370_subtr

; 4940 : 
; 4941 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003f6	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003fa	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003ff	85 c0		 test	 eax, eax
  00401	74 11		 je	 SHORT $LN16@s370_subtr
  00403	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00407	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_subtr:

; 4942 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4943 : }

  00414	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00418	c3		 ret	 0
s370_subtract_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv214 = 48
tv244 = 52
tv249 = 56
tv251 = 60
tv252 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
ans$ = 144
op2$ = 160
op1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
s370_subtract_bfp_ext_reg PROC

; 4833 : {

$LN32:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4834 :     int         r1, r2;
; 4835 :     float128_t  op1, op2, ans;
; 4836 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4837 : 
; 4838 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_subtr:
  0005f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN11@s370_subtr
  00082	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s370_subtr:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@s370_subtr

; 4839 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4840 :     BFPINST_CHECK( regs );

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 3f		 je	 SHORT $LN13@s370_subtr
  000b8	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c6	d1 e8		 shr	 eax, 1
  000c8	83 e0 01	 and	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 55		 je	 SHORT $LN12@s370_subtr
  000cf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	b9 08 00 00 00	 mov	 ecx, 8
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ee	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f3	85 c0		 test	 eax, eax
  000f5	75 2d		 jne	 SHORT $LN12@s370_subtr
$LN13@s370_subtr:
  000f7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00109	ba 07 00 00 00	 mov	 edx, 7
  0010e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_subtr:

; 4841 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00124	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN15@s370_subtr
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 02	 and	 eax, 2
  00136	85 c0		 test	 eax, eax
  00138	74 1b		 je	 SHORT $LN14@s370_subtr
$LN15@s370_subtr:
  0013a	ba 06 00 00 00	 mov	 edx, 6
  0013f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@s370_subtr:
$LN7@s370_subtr:

; 4842 : 
; 4843 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  00155	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00159	d1 e0		 shl	 eax, 1
  0015b	48 98		 cdqe
  0015d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00178	e8 00 00 00 00	 call	 s370_get_float128
  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00181	d1 e0		 shl	 eax, 1
  00183	48 98		 cdqe
  00185	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001a0	e8 00 00 00 00	 call	 s370_get_float128
  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 aa		 jne	 SHORT $LN7@s370_subtr

; 4844 : 
; 4845 :     SET_SF_RM_FROM_FPC;

  001ab	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001b9	83 e0 07	 and	 eax, 7
  001bc	8b c0		 mov	 eax, eax
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001c5	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001ca	8b d2		 mov	 edx, edx
  001cc	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001d3	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001dc	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e4	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4846 :     softfloat_exceptionFlags = 0;

  001e8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ed	8b c0		 mov	 eax, eax
  001ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001fe	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00202	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4847 :     SET_SF_RM_FROM_FPC;

  00206	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00214	83 e0 07	 and	 eax, 7
  00217	8b c0		 mov	 eax, eax
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00220	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00225	8b d2		 mov	 edx, edx
  00227	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0022e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00237	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0023b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4848 : 
; 4849 :     ans = f128_sub( op1, op2 );

  00243	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  00248	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  00250	48 8b f8	 mov	 rdi, rax
  00253	48 8b f1	 mov	 rsi, rcx
  00256	b9 10 00 00 00	 mov	 ecx, 16
  0025b	f3 a4		 rep movsb
  0025d	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  00262	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  0026a	48 8b f8	 mov	 rdi, rax
  0026d	48 8b f1	 mov	 rsi, rcx
  00270	b9 10 00 00 00	 mov	 ecx, 16
  00275	f3 a4		 rep movsb
  00277	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  0027c	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  00281	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  00286	e8 00 00 00 00	 call	 f128_sub
  0028b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00293	48 8b f9	 mov	 rdi, rcx
  00296	48 8b f0	 mov	 rsi, rax
  00299	b9 10 00 00 00	 mov	 ecx, 16
  0029e	f3 a4		 rep movsb

; 4850 : 
; 4851 :     if (softfloat_exceptionFlags)

  002a0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a5	8b c0		 mov	 eax, eax
  002a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ad	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002be	85 c0		 test	 eax, eax
  002c0	0f 84 b5 00 00
	00		 je	 $LN16@s370_subtr

; 4852 :     {
; 4853 :         IEEE_EXCEPTION_TRAP_XI( regs );

  002c6	33 c0		 xor	 eax, eax
  002c8	83 f8 01	 cmp	 eax, 1
  002cb	74 4b		 je	 SHORT $LN17@s370_subtr
  002cd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d2	8b c0		 mov	 eax, eax
  002d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002da	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002eb	83 e0 10	 and	 eax, 16
  002ee	85 c0		 test	 eax, eax
  002f0	74 26		 je	 SHORT $LN17@s370_subtr
  002f2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fa	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00300	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00305	85 c0		 test	 eax, eax
  00307	74 0f		 je	 SHORT $LN17@s370_subtr
  00309	b2 80		 mov	 dl, 128			; 00000080H
  0030b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00313	e8 00 00 00 00	 call	 ieee_trap
$LN17@s370_subtr:

; 4854 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00318	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00325	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4855 : 
; 4856 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00329	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0032d	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00332	85 c0		 test	 eax, eax
  00334	74 45		 je	 SHORT $LN18@s370_subtr

; 4857 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00336	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0033a	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0033f	85 c0		 test	 eax, eax
  00341	74 0a		 je	 SHORT $LN21@s370_subtr
  00343	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv214[rsp], -24576 ; ffffffffffffa000H
  0034b	eb 08		 jmp	 SHORT $LN22@s370_subtr
$LN21@s370_subtr:
  0034d	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv214[rsp], 24576 ; 00006000H
$LN22@s370_subtr:
  00355	8b 54 24 30	 mov	 edx, DWORD PTR tv214[rsp]
  00359	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00361	e8 00 00 00 00	 call	 f128_scaledResult
  00366	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0036e	48 8b f9	 mov	 rdi, rcx
  00371	48 8b f0	 mov	 rsi, rax
  00374	b9 10 00 00 00	 mov	 ecx, 16
  00379	f3 a4		 rep movsb
$LN18@s370_subtr:
$LN16@s370_subtr:
$LN10@s370_subtr:

; 4858 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 4859 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 4860 :     }
; 4861 : 
; 4862 :     PUT_FLOAT128_CC( ans, r1, regs );

  0037b	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0037f	d1 e0		 shl	 eax, 1
  00381	48 98		 cdqe
  00383	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00393	48 8b d0	 mov	 rdx, rax
  00396	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0039e	e8 00 00 00 00	 call	 s370_put_float128
  003a3	b8 08 00 00 00	 mov	 eax, 8
  003a8	48 6b c0 01	 imul	 rax, rax, 1
  003ac	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  003b6	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  003be	48 23 c1	 and	 rax, rcx
  003c1	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  003cb	48 3b c1	 cmp	 rax, rcx
  003ce	75 44		 jne	 SHORT $LN24@s370_subtr
  003d0	b8 08 00 00 00	 mov	 eax, 8
  003d5	48 6b c0 01	 imul	 rax, rax, 1
  003d9	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  003e3	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  003eb	48 23 c1	 and	 rax, rcx
  003ee	48 85 c0	 test	 rax, rax
  003f1	75 14		 jne	 SHORT $LN23@s370_subtr
  003f3	b8 08 00 00 00	 mov	 eax, 8
  003f8	48 6b c0 00	 imul	 rax, rax, 0
  003fc	48 83 bc 04 90
	00 00 00 00	 cmp	 QWORD PTR ans$[rsp+rax], 0
  00405	74 0d		 je	 SHORT $LN24@s370_subtr
$LN23@s370_subtr:
  00407	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv252[rsp], 3
  0040f	e9 9c 00 00 00	 jmp	 $LN31@s370_subtr
$LN24@s370_subtr:
  00414	b8 08 00 00 00	 mov	 eax, 8
  00419	48 6b c0 01	 imul	 rax, rax, 1
  0041d	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00427	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  0042f	48 23 c1	 and	 rax, rcx
  00432	b9 08 00 00 00	 mov	 ecx, 8
  00437	48 6b c9 00	 imul	 rcx, rcx, 0
  0043b	48 0b 84 0c 90
	00 00 00	 or	 rax, QWORD PTR ans$[rsp+rcx]
  00443	48 85 c0	 test	 rax, rax
  00446	75 0a		 jne	 SHORT $LN25@s370_subtr
  00448	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv244[rsp], 1
  00450	eb 08		 jmp	 SHORT $LN26@s370_subtr
$LN25@s370_subtr:
  00452	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv244[rsp], 0
$LN26@s370_subtr:
  0045a	83 7c 24 34 00	 cmp	 DWORD PTR tv244[rsp], 0
  0045f	74 0a		 je	 SHORT $LN29@s370_subtr
  00461	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
  00469	eb 3d		 jmp	 SHORT $LN30@s370_subtr
$LN29@s370_subtr:
  0046b	b8 08 00 00 00	 mov	 eax, 8
  00470	48 6b c0 01	 imul	 rax, rax, 1
  00474	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0047e	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  00486	48 23 c1	 and	 rax, rcx
  00489	48 85 c0	 test	 rax, rax
  0048c	74 0a		 je	 SHORT $LN27@s370_subtr
  0048e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv249[rsp], 1
  00496	eb 08		 jmp	 SHORT $LN28@s370_subtr
$LN27@s370_subtr:
  00498	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv249[rsp], 2
$LN28@s370_subtr:
  004a0	8b 44 24 38	 mov	 eax, DWORD PTR tv249[rsp]
  004a4	89 44 24 3c	 mov	 DWORD PTR tv251[rsp], eax
$LN30@s370_subtr:
  004a8	8b 44 24 3c	 mov	 eax, DWORD PTR tv251[rsp]
  004ac	89 44 24 40	 mov	 DWORD PTR tv252[rsp], eax
$LN31@s370_subtr:
  004b0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b8	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv252[rsp]
  004bd	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  004c0	33 c0		 xor	 eax, eax
  004c2	85 c0		 test	 eax, eax
  004c4	0f 85 b1 fe ff
	ff		 jne	 $LN10@s370_subtr

; 4863 : 
; 4864 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  004ca	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004ce	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  004d3	85 c0		 test	 eax, eax
  004d5	74 11		 je	 SHORT $LN19@s370_subtr
  004d7	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004db	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@s370_subtr:

; 4865 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4866 : }

  004e8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f0	48 33 cc	 xor	 rcx, rsp
  004f3	e8 00 00 00 00	 call	 __security_check_cookie
  004f8	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  004ff	5f		 pop	 rdi
  00500	5e		 pop	 rsi
  00501	c3		 ret	 0
s370_subtract_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
op2$ = 44
r1$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
s370_squareroot_bfp_short_reg PROC

; 4766 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4767 :     int        r1, r2;
; 4768 :     float32_t  op1, op2;
; 4769 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4770 : 
; 4771 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_squar:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN5@s370_squar
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_squar:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_squar

; 4772 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4773 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN7@s370_squar
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN6@s370_squar
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN6@s370_squar
$LN7@s370_squar:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_squar:

; 4774 : 
; 4775 :     GET_FLOAT32_OP( op2, r2, regs );

  000ef	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR op2$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float32

; 4776 : 
; 4777 :     softfloat_exceptionFlags = 0;

  00111	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00116	8b c0		 mov	 eax, eax
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0011e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00127	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0012b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4778 :     SET_SF_RM_FROM_FPC;

  0012f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00134	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0013a	83 e0 07	 and	 eax, 7
  0013d	8b c0		 mov	 eax, eax
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00146	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0014b	8b d2		 mov	 edx, edx
  0014d	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00154	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  0015d	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00161	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00165	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4779 : 
; 4780 :     op1 = f32_sqrt( op2 );

  00169	8b 4c 24 2c	 mov	 ecx, DWORD PTR op2$[rsp]
  0016d	e8 00 00 00 00	 call	 f32_sqrt
  00172	89 44 24 34	 mov	 DWORD PTR op1$[rsp], eax

; 4781 : 
; 4782 :     if (softfloat_exceptionFlags)

  00176	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017b	8b c0		 mov	 eax, eax
  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00183	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00190	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00194	85 c0		 test	 eax, eax
  00196	0f 84 88 00 00
	00		 je	 $LN8@s370_squar

; 4783 :     {
; 4784 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0019c	33 c0		 xor	 eax, eax
  0019e	83 f8 01	 cmp	 eax, 1
  001a1	74 45		 je	 SHORT $LN9@s370_squar
  001a3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a8	8b c0		 mov	 eax, eax
  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c1	83 e0 10	 and	 eax, 16
  001c4	85 c0		 test	 eax, eax
  001c6	74 20		 je	 SHORT $LN9@s370_squar
  001c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001cd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001d8	85 c0		 test	 eax, eax
  001da	74 0c		 je	 SHORT $LN9@s370_squar
  001dc	b2 80		 mov	 dl, 128			; 00000080H
  001de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	e8 00 00 00 00	 call	 ieee_trap
$LN9@s370_squar:

; 4785 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  001e8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f3	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  001f8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  001fd	8b c9		 mov	 ecx, ecx
  001ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00205	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  0020e	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00212	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00216	c1 e1 1b	 shl	 ecx, 27
  00219	23 c1		 and	 eax, ecx
  0021b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00220	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN8@s370_squar:

; 4786 :     }
; 4787 : 
; 4788 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  00224	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00228	d1 e0		 shl	 eax, 1
  0022a	48 98		 cdqe
  0022c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00231	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00239	48 8b d0	 mov	 rdx, rax
  0023c	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00241	e8 00 00 00 00	 call	 s370_put_float32

; 4789 : 
; 4790 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00246	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0024a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0024f	85 c0		 test	 eax, eax
  00251	74 0e		 je	 SHORT $LN10@s370_squar
  00253	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00257	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0025c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN10@s370_squar:

; 4791 :     SET_FPC_FLAGS_FROM_SF( regs );

  00261	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00266	8b c0		 mov	 eax, eax
  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00277	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027f	c1 e0 13	 shl	 eax, 19
  00282	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00287	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0028d	c1 e9 08	 shr	 ecx, 8
  00290	f7 d1		 not	 ecx
  00292	23 c1		 and	 eax, ecx
  00294	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00299	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002a4	0b c8		 or	 ecx, eax
  002a6	8b c1		 mov	 eax, ecx
  002a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002ad	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4792 : }

  002b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002b7	c3		 ret	 0
s370_squareroot_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
ieee_trap_conds$ = 44
x2$ = 48
op2$ = 52
r1$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s370_squareroot_bfp_short PROC

; 4798 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4799 :     int        r1, x2, b2;
; 4800 :     VADR       effective_addr2;
; 4801 :     float32_t  op1, op2;
; 4802 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4803 : 
; 4804 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_squar
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_squar:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_squar
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_squar:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000ae	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_squar:
  000b7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f8 06	 cmp	 eax, 6
  000d2	74 0c		 je	 SHORT $LN7@s370_squar
  000d4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_squar:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d1		 jne	 SHORT $LN4@s370_squar

; 4805 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4806 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4807 :     BFPINST_CHECK( regs );

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	74 39		 je	 SHORT $LN9@s370_squar
  00104	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010f	d1 e8		 shr	 eax, 1
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 49		 je	 SHORT $LN8@s370_squar
  00118	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00124	b9 08 00 00 00	 mov	 ecx, 8
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	75 24		 jne	 SHORT $LN8@s370_squar
$LN9@s370_squar:
  0013d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00142	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014c	ba 07 00 00 00	 mov	 edx, 7
  00151	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_squar:

; 4808 : 
; 4809 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00161	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00166	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  0016a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0016e	e8 00 00 00 00	 call	 s370_vfetch4
  00173	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 4810 : 
; 4811 :     softfloat_exceptionFlags = 0;

  00177	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017c	8b c0		 mov	 eax, eax
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00184	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00191	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4812 :     SET_SF_RM_FROM_FPC;

  00195	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0019a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001a0	83 e0 07	 and	 eax, 7
  001a3	8b c0		 mov	 eax, eax
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ac	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001b1	8b d2		 mov	 edx, edx
  001b3	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001ba	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001c3	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001c7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cb	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4813 : 
; 4814 :     op1 = f32_sqrt( op2 );

  001cf	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  001d3	e8 00 00 00 00	 call	 f32_sqrt
  001d8	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 4815 : 
; 4816 :     if (softfloat_exceptionFlags)

  001dc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e1	8b c0		 mov	 eax, eax
  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fa	85 c0		 test	 eax, eax
  001fc	0f 84 88 00 00
	00		 je	 $LN10@s370_squar

; 4817 :     {
; 4818 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00202	33 c0		 xor	 eax, eax
  00204	83 f8 01	 cmp	 eax, 1
  00207	74 45		 je	 SHORT $LN11@s370_squar
  00209	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020e	8b c0		 mov	 eax, eax
  00210	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00216	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00223	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00227	83 e0 10	 and	 eax, 16
  0022a	85 c0		 test	 eax, eax
  0022c	74 20		 je	 SHORT $LN11@s370_squar
  0022e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00233	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00239	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0023e	85 c0		 test	 eax, eax
  00240	74 0c		 je	 SHORT $LN11@s370_squar
  00242	b2 80		 mov	 dl, 128			; 00000080H
  00244	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_squar:

; 4819 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  0024e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00253	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00259	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  0025e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  00263	8b c9		 mov	 ecx, ecx
  00265	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0026b	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00274	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00278	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0027c	c1 e1 1b	 shl	 ecx, 27
  0027f	23 c1		 and	 eax, ecx
  00281	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00286	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN10@s370_squar:

; 4820 :     }
; 4821 : 
; 4822 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  0028a	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0028e	d1 e0		 shl	 eax, 1
  00290	48 98		 cdqe
  00292	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00297	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0029f	48 8b d0	 mov	 rdx, rax
  002a2	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  002a7	e8 00 00 00 00	 call	 s370_put_float32

; 4823 : 
; 4824 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002ac	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002b5	85 c0		 test	 eax, eax
  002b7	74 0e		 je	 SHORT $LN12@s370_squar
  002b9	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002c2	e8 00 00 00 00	 call	 ieee_cond_trap
$LN12@s370_squar:

; 4825 :     SET_FPC_FLAGS_FROM_SF( regs );

  002c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002cc	8b c0		 mov	 eax, eax
  002ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e5	c1 e0 13	 shl	 eax, 19
  002e8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002ed	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002f3	c1 e9 08	 shr	 ecx, 8
  002f6	f7 d1		 not	 ecx
  002f8	23 c1		 and	 eax, ecx
  002fa	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00304	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0030a	0b c8		 or	 ecx, eax
  0030c	8b c1		 mov	 eax, ecx
  0030e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00313	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4826 : }

  00319	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0031d	c3		 ret	 0
s370_squareroot_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
s370_squareroot_bfp_long_reg PROC

; 4700 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4701 :     int        r1, r2;
; 4702 :     float64_t  op1, op2;
; 4703 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4704 : 
; 4705 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_squar:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN5@s370_squar
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_squar:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_squar

; 4706 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4707 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN7@s370_squar
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN6@s370_squar
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN6@s370_squar
$LN7@s370_squar:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_squar:

; 4708 : 
; 4709 :     GET_FLOAT64_OP( op2, r2, regs );

  000ef	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float64

; 4710 : 
; 4711 :     softfloat_exceptionFlags = 0;

  00111	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00116	8b c0		 mov	 eax, eax
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0011e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00127	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0012b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4712 :     SET_SF_RM_FROM_FPC;

  0012f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00134	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0013a	83 e0 07	 and	 eax, 7
  0013d	8b c0		 mov	 eax, eax
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00146	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  0014b	8b d2		 mov	 edx, edx
  0014d	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00154	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  0015d	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00161	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00165	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4713 : 
; 4714 :     op1 = f64_sqrt( op2 );

  00169	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0016e	e8 00 00 00 00	 call	 f64_sqrt
  00173	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 4715 : 
; 4716 :     if (softfloat_exceptionFlags)

  00178	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017d	8b c0		 mov	 eax, eax
  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00185	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00192	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00196	85 c0		 test	 eax, eax
  00198	0f 84 88 00 00
	00		 je	 $LN8@s370_squar

; 4717 :     {
; 4718 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0019e	33 c0		 xor	 eax, eax
  001a0	83 f8 01	 cmp	 eax, 1
  001a3	74 45		 je	 SHORT $LN9@s370_squar
  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	83 e0 10	 and	 eax, 16
  001c6	85 c0		 test	 eax, eax
  001c8	74 20		 je	 SHORT $LN9@s370_squar
  001ca	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d5	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001da	85 c0		 test	 eax, eax
  001dc	74 0c		 je	 SHORT $LN9@s370_squar
  001de	b2 80		 mov	 dl, 128			; 00000080H
  001e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e5	e8 00 00 00 00	 call	 ieee_trap
$LN9@s370_squar:

; 4719 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  001ea	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f5	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  001fa	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  001ff	8b c9		 mov	 ecx, ecx
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00207	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00210	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00214	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00218	c1 e1 1b	 shl	 ecx, 27
  0021b	23 c1		 and	 eax, ecx
  0021d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00222	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN8@s370_squar:

; 4720 :     }
; 4721 : 
; 4722 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00226	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0022a	d1 e0		 shl	 eax, 1
  0022c	48 98		 cdqe
  0022e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00233	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0023b	48 8b d0	 mov	 rdx, rax
  0023e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00243	e8 00 00 00 00	 call	 s370_put_float64

; 4723 : 
; 4724 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00248	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0024c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00251	85 c0		 test	 eax, eax
  00253	74 0e		 je	 SHORT $LN10@s370_squar
  00255	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00259	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	e8 00 00 00 00	 call	 ieee_cond_trap
$LN10@s370_squar:

; 4725 :     SET_FPC_FLAGS_FROM_SF( regs );

  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	c1 e0 13	 shl	 eax, 19
  00284	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00289	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0028f	c1 e9 08	 shr	 ecx, 8
  00292	f7 d1		 not	 ecx
  00294	23 c1		 and	 eax, ecx
  00296	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0029b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002a6	0b c8		 or	 ecx, eax
  002a8	8b c1		 mov	 eax, ecx
  002aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002af	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4726 : }

  002b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002b9	c3		 ret	 0
s370_squareroot_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
ieee_trap_conds$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
s370_squareroot_bfp_long PROC

; 4732 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4733 :     int        r1, x2, b2;
; 4734 :     VADR       effective_addr2;
; 4735 :     float64_t  op1, op2;
; 4736 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4737 : 
; 4738 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_squar
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_squar:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_squar
  0008d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_squar:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000ae	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_squar:
  000b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f8 06	 cmp	 eax, 6
  000d2	74 0c		 je	 SHORT $LN7@s370_squar
  000d4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_squar:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d1		 jne	 SHORT $LN4@s370_squar

; 4739 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4740 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4741 :     BFPINST_CHECK( regs );

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	74 39		 je	 SHORT $LN9@s370_squar
  00104	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010f	d1 e8		 shr	 eax, 1
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 49		 je	 SHORT $LN8@s370_squar
  00118	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00124	b9 08 00 00 00	 mov	 ecx, 8
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	75 24		 jne	 SHORT $LN8@s370_squar
$LN9@s370_squar:
  0013d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00142	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014c	ba 07 00 00 00	 mov	 edx, 7
  00151	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_squar:

; 4742 : 
; 4743 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00161	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00166	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  0016a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0016e	e8 00 00 00 00	 call	 s370_vfetch8
  00173	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 4744 : 
; 4745 :     softfloat_exceptionFlags = 0;

  00178	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017d	8b c0		 mov	 eax, eax
  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00185	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00192	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4746 :     SET_SF_RM_FROM_FPC;

  00196	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001a1	83 e0 07	 and	 eax, 7
  001a4	8b c0		 mov	 eax, eax
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ad	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001b2	8b d2		 mov	 edx, edx
  001b4	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001bb	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001c4	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cc	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4747 : 
; 4748 :     op1 = f64_sqrt( op2 );

  001d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  001d5	e8 00 00 00 00	 call	 f64_sqrt
  001da	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 4749 : 
; 4750 :     if (softfloat_exceptionFlags)

  001df	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e4	8b c0		 mov	 eax, eax
  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ec	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fd	85 c0		 test	 eax, eax
  001ff	0f 84 88 00 00
	00		 je	 $LN10@s370_squar

; 4751 :     {
; 4752 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00205	33 c0		 xor	 eax, eax
  00207	83 f8 01	 cmp	 eax, 1
  0020a	74 45		 je	 SHORT $LN11@s370_squar
  0020c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00211	8b c0		 mov	 eax, eax
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00219	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00222	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00226	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022a	83 e0 10	 and	 eax, 16
  0022d	85 c0		 test	 eax, eax
  0022f	74 20		 je	 SHORT $LN11@s370_squar
  00231	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00236	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0023c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00241	85 c0		 test	 eax, eax
  00243	74 0c		 je	 SHORT $LN11@s370_squar
  00245	b2 80		 mov	 dl, 128			; 00000080H
  00247	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0024c	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_squar:

; 4753 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  00251	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00256	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0025c	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00261	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  00266	8b c9		 mov	 ecx, ecx
  00268	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0026e	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  00277	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  0027b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0027f	c1 e1 1b	 shl	 ecx, 27
  00282	23 c1		 and	 eax, ecx
  00284	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00289	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN10@s370_squar:

; 4754 :     }
; 4755 : 
; 4756 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  0028d	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00291	d1 e0		 shl	 eax, 1
  00293	48 98		 cdqe
  00295	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002a2	48 8b d0	 mov	 rdx, rax
  002a5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  002aa	e8 00 00 00 00	 call	 s370_put_float64

; 4757 : 
; 4758 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002af	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002b8	85 c0		 test	 eax, eax
  002ba	74 0e		 je	 SHORT $LN12@s370_squar
  002bc	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c5	e8 00 00 00 00	 call	 ieee_cond_trap
$LN12@s370_squar:

; 4759 :     SET_FPC_FLAGS_FROM_SF( regs );

  002ca	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002cf	8b c0		 mov	 eax, eax
  002d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e8	c1 e0 13	 shl	 eax, 19
  002eb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002f6	c1 e9 08	 shr	 ecx, 8
  002f9	f7 d1		 not	 ecx
  002fb	23 c1		 and	 eax, ecx
  002fd	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00302	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00307	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0030d	0b c8		 or	 ecx, eax
  0030f	8b c1		 mov	 eax, ecx
  00311	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00316	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4760 : }

  0031c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00320	c3		 ret	 0
s370_squareroot_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s370_squareroot_bfp_ext_reg PROC

; 4667 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4668 :     int         r1, r2;
; 4669 :     float128_t  op1, op2;
; 4670 :     U32         ieee_trap_conds = 0;

  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4671 : 
; 4672 :     RRE( inst, regs, r1, r2 );

  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 03	 imul	 rax, rax, 3
  00033	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003f	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0004e	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00052	c1 f8 04	 sar	 eax, 4
  00055	83 e0 0f	 and	 eax, 15
  00058	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_squar:
  0005c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0f		 je	 SHORT $LN5@s370_squar
  0007f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_squar:
  0008e	33 c0		 xor	 eax, eax
  00090	85 c0		 test	 eax, eax
  00092	75 c8		 jne	 SHORT $LN4@s370_squar

; 4673 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4674 :     BFPINST_CHECK( regs );

  00094	b8 08 00 00 00	 mov	 eax, 8
  00099	48 6b c0 01	 imul	 rax, rax, 1
  0009d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ac	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b1	85 c0		 test	 eax, eax
  000b3	74 3f		 je	 SHORT $LN7@s370_squar
  000b5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c3	d1 e8		 shr	 eax, 1
  000c5	83 e0 01	 and	 eax, 1
  000c8	85 c0		 test	 eax, eax
  000ca	74 55		 je	 SHORT $LN6@s370_squar
  000cc	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000db	b9 08 00 00 00	 mov	 ecx, 8
  000e0	48 6b c9 01	 imul	 rcx, rcx, 1
  000e4	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000eb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f0	85 c0		 test	 eax, eax
  000f2	75 2d		 jne	 SHORT $LN6@s370_squar
$LN7@s370_squar:
  000f4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00106	ba 07 00 00 00	 mov	 edx, 7
  0010b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_squar:

; 4675 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00121	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00125	83 e0 02	 and	 eax, 2
  00128	85 c0		 test	 eax, eax
  0012a	75 0b		 jne	 SHORT $LN9@s370_squar
  0012c	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00130	83 e0 02	 and	 eax, 2
  00133	85 c0		 test	 eax, eax
  00135	74 1b		 je	 SHORT $LN8@s370_squar
$LN9@s370_squar:
  00137	ba 06 00 00 00	 mov	 edx, 6
  0013c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_squar:

; 4676 : 
; 4677 :     GET_FLOAT128_OP( op2, r2, regs );

  00152	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00156	d1 e0		 shl	 eax, 1
  00158	48 98		 cdqe
  0015a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016a	48 8b d0	 mov	 rdx, rax
  0016d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  00172	e8 00 00 00 00	 call	 s370_get_float128

; 4678 : 
; 4679 :     softfloat_exceptionFlags = 0;

  00177	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017c	8b c0		 mov	 eax, eax
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00184	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00191	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4680 :     SET_SF_RM_FROM_FPC;

  00195	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001a3	83 e0 07	 and	 eax, 7
  001a6	8b c0		 mov	 eax, eax
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001af	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001b4	8b d2		 mov	 edx, edx
  001b6	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001bd	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001c6	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ce	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4681 : 
; 4682 :     op1 = f128_sqrt( op2 );

  001d2	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  001d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001dc	48 8b f8	 mov	 rdi, rax
  001df	48 8b f1	 mov	 rsi, rcx
  001e2	b9 10 00 00 00	 mov	 ecx, 16
  001e7	f3 a4		 rep movsb
  001e9	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  001ee	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  001f3	e8 00 00 00 00	 call	 f128_sqrt
  001f8	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001fd	48 8b f9	 mov	 rdi, rcx
  00200	48 8b f0	 mov	 rsi, rax
  00203	b9 10 00 00 00	 mov	 ecx, 16
  00208	f3 a4		 rep movsb

; 4683 : 
; 4684 :     if (softfloat_exceptionFlags)

  0020a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020f	8b c0		 mov	 eax, eax
  00211	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00217	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00220	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	85 c0		 test	 eax, eax
  0022a	0f 84 91 00 00
	00		 je	 $LN10@s370_squar

; 4685 :     {
; 4686 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00230	33 c0		 xor	 eax, eax
  00232	83 f8 01	 cmp	 eax, 1
  00235	74 4b		 je	 SHORT $LN11@s370_squar
  00237	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023c	8b c0		 mov	 eax, eax
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00244	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00251	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00255	83 e0 10	 and	 eax, 16
  00258	85 c0		 test	 eax, eax
  0025a	74 26		 je	 SHORT $LN11@s370_squar
  0025c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00264	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0026a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0026f	85 c0		 test	 eax, eax
  00271	74 0f		 je	 SHORT $LN11@s370_squar
  00273	b2 80		 mov	 dl, 128			; 00000080H
  00275	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_squar:

; 4687 :         IEEE_EXCEPTION_TEST_TRAPS( regs, ieee_trap_conds, FPC_MASK_IMX );

  00282	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00290	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00295	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:softfloat_exceptionFlags
  0029a	8b c9		 mov	 ecx, ecx
  0029c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  002a2	65 48 8b 3c 25
	58 00 00 00	 mov	 rdi, QWORD PTR gs:88
  002ab	48 8b 14 d7	 mov	 rdx, QWORD PTR [rdi+rdx*8]
  002af	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002b3	c1 e1 1b	 shl	 ecx, 27
  002b6	23 c1		 and	 eax, ecx
  002b8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002bd	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax
$LN10@s370_squar:

; 4688 :     }
; 4689 : 
; 4690 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  002c1	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002c5	d1 e0		 shl	 eax, 1
  002c7	48 98		 cdqe
  002c9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d1	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d9	48 8b d0	 mov	 rdx, rax
  002dc	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  002e1	e8 00 00 00 00	 call	 s370_put_float128

; 4691 : 
; 4692 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002e6	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ea	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002ef	85 c0		 test	 eax, eax
  002f1	74 11		 je	 SHORT $LN12@s370_squar
  002f3	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002f7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ff	e8 00 00 00 00	 call	 ieee_cond_trap
$LN12@s370_squar:

; 4693 :     SET_FPC_FLAGS_FROM_SF( regs );

  00304	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00309	8b c0		 mov	 eax, eax
  0030b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00311	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0031a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00322	c1 e0 13	 shl	 eax, 19
  00325	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00333	c1 e9 08	 shr	 ecx, 8
  00336	f7 d1		 not	 ecx
  00338	23 c1		 and	 eax, ecx
  0033a	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0033f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00347	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0034d	0b c8		 or	 ecx, eax
  0034f	8b c1		 mov	 eax, ecx
  00351	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00359	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 4694 : }

  0035f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00364	48 33 cc	 xor	 rcx, rsp
  00367	e8 00 00 00 00	 call	 __security_check_cookie
  0036c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00373	5f		 pop	 rdi
  00374	5e		 pop	 rsi
  00375	c3		 ret	 0
s370_squareroot_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op1$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
tv212 = 44
r1$ = 48
ans$ = 52
r3$ = 56
r2$ = 60
op3$ = 64
op2$ = 68
inst$ = 96
regs$ = 104
s370_multiply_subtract_bfp_short_reg PROC

; 4575 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4576 :     int        r1, r2, r3;
; 4577 :     float32_t  op1, op2, op3, ans;
; 4578 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4579 : 
; 4580 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 3c	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN8@s370_multi
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@s370_multi

; 4581 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4582 :     BFPINST_CHECK( regs );

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00096	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009b	85 c0		 test	 eax, eax
  0009d	74 39		 je	 SHORT $LN10@s370_multi
  0009f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000aa	d1 e8		 shr	 eax, 1
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 49		 je	 SHORT $LN9@s370_multi
  000b3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000d4	85 c0		 test	 eax, eax
  000d6	75 24		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000d8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e7	ba 07 00 00 00	 mov	 edx, 7
  000ec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:
$LN7@s370_multi:

; 4583 : 
; 4584 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  000fc	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00100	d1 e0		 shl	 eax, 1
  00102	48 98		 cdqe
  00104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op1$[rsp]
  00119	e8 00 00 00 00	 call	 s370_get_float32
  0011e	8b 44 24 38	 mov	 eax, DWORD PTR r3$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op3$[rsp]
  0013b	e8 00 00 00 00	 call	 s370_get_float32
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 b6		 jne	 SHORT $LN7@s370_multi

; 4585 :     GET_FLOAT32_OP( op2, r2, regs );

  00146	8b 44 24 3c	 mov	 eax, DWORD PTR r2$[rsp]
  0014a	d1 e0		 shl	 eax, 1
  0014c	48 98		 cdqe
  0014e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op2$[rsp]
  00163	e8 00 00 00 00	 call	 s370_get_float32

; 4586 : 
; 4587 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4588 :     if (0
; 4589 :         || !(op1.v & 0x007FFFFF)
; 4590 :         || ((op1.v & 0x7F800000) ^ 0x7F800000)

  00168	33 c0		 xor	 eax, eax
  0016a	85 c0		 test	 eax, eax
  0016c	75 1f		 jne	 SHORT $LN12@s370_multi
  0016e	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  00172	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00177	85 c0		 test	 eax, eax
  00179	74 12		 je	 SHORT $LN12@s370_multi
  0017b	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  0017f	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00184	35 00 00 80 7f	 xor	 eax, 2139095040		; 7f800000H
  00189	85 c0		 test	 eax, eax
  0018b	74 0c		 je	 SHORT $LN11@s370_multi
$LN12@s370_multi:

; 4591 :     )
; 4592 :         op1.v ^= 0x80000000;

  0018d	8b 44 24 20	 mov	 eax, DWORD PTR op1$[rsp]
  00191	0f ba f8 1f	 btc	 eax, 31
  00195	89 44 24 20	 mov	 DWORD PTR op1$[rsp], eax
$LN11@s370_multi:

; 4593 : 
; 4594 :     softfloat_exceptionFlags = 0;

  00199	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019e	8b c0		 mov	 eax, eax
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4595 :     SET_SF_RM_FROM_FPC;

  001b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c2	83 e0 07	 and	 eax, 7
  001c5	8b c0		 mov	 eax, eax
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001d3	8b d2		 mov	 edx, edx
  001d5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001dc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001e5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4596 : 
; 4597 :     ans = f32_mulAdd( op2, op3, op1 );

  001f1	44 8b 44 24 20	 mov	 r8d, DWORD PTR op1$[rsp]
  001f6	8b 54 24 40	 mov	 edx, DWORD PTR op3$[rsp]
  001fa	8b 4c 24 44	 mov	 ecx, DWORD PTR op2$[rsp]
  001fe	e8 00 00 00 00	 call	 f32_mulAdd
  00203	89 44 24 34	 mov	 DWORD PTR ans$[rsp], eax

; 4598 : 
; 4599 :     if (softfloat_exceptionFlags)

  00207	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020c	8b c0		 mov	 eax, eax
  0020e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00214	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00221	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00225	85 c0		 test	 eax, eax
  00227	0f 84 93 00 00
	00		 je	 $LN13@s370_multi

; 4600 :     {
; 4601 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0022d	33 c0		 xor	 eax, eax
  0022f	83 f8 01	 cmp	 eax, 1
  00232	74 45		 je	 SHORT $LN14@s370_multi
  00234	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00239	8b c0		 mov	 eax, eax
  0023b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00241	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00252	83 e0 10	 and	 eax, 16
  00255	85 c0		 test	 eax, eax
  00257	74 20		 je	 SHORT $LN14@s370_multi
  00259	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0025e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00264	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00269	85 c0		 test	 eax, eax
  0026b	74 0c		 je	 SHORT $LN14@s370_multi
  0026d	b2 80		 mov	 dl, 128			; 00000080H
  0026f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_multi:

; 4602 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00279	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0027e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00283	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4603 : 
; 4604 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00287	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0028b	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00290	85 c0		 test	 eax, eax
  00292	74 2c		 je	 SHORT $LN15@s370_multi

; 4605 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00294	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00298	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0029d	85 c0		 test	 eax, eax
  0029f	74 0a		 je	 SHORT $LN18@s370_multi
  002a1	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv212[rsp], -192 ; ffffffffffffff40H
  002a9	eb 08		 jmp	 SHORT $LN19@s370_multi
$LN18@s370_multi:
  002ab	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv212[rsp], 192 ; 000000c0H
$LN19@s370_multi:
  002b3	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv212[rsp]
  002b7	e8 00 00 00 00	 call	 f32_scaledResult
  002bc	89 44 24 34	 mov	 DWORD PTR ans$[rsp], eax
$LN15@s370_multi:
$LN13@s370_multi:

; 4606 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4607 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4608 :     }
; 4609 : 
; 4610 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  002c0	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  002c4	d1 e0		 shl	 eax, 1
  002c6	48 98		 cdqe
  002c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d5	48 8b d0	 mov	 rdx, rax
  002d8	48 8d 4c 24 34	 lea	 rcx, QWORD PTR ans$[rsp]
  002dd	e8 00 00 00 00	 call	 s370_put_float32

; 4611 : 
; 4612 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002e2	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e6	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002eb	85 c0		 test	 eax, eax
  002ed	74 0e		 je	 SHORT $LN16@s370_multi
  002ef	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f8	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_multi:

; 4613 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4614 : }

  002fd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00301	c3		 ret	 0
s370_multiply_subtract_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
op1$ = 36
ieee_trap_conds$ = 40
temp$1 = 44
b2$ = 48
x2$ = 52
tv230 = 56
r1$ = 60
ans$ = 64
r3$ = 68
op3$ = 72
op2$ = 76
inst$ = 96
regs$ = 104
s370_multiply_subtract_bfp_short PROC

; 4620 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4621 :     int        x2, r1, r3, b2;
; 4622 :     VADR       effective_addr2;
; 4623 :     float32_t  op1, op2, op3, ans;
; 4624 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4625 : 
; 4626 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 04	 imul	 rax, rax, 4
  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	c1 f8 04	 sar	 eax, 4
  00040	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 10	 shr	 eax, 16
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 34	 mov	 DWORD PTR x2$[rsp], eax
  0005f	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 14	 shr	 eax, 20
  00066	83 e0 0f	 and	 eax, 15
  00069	89 44 24 44	 mov	 DWORD PTR r3$[rsp], eax
  0006d	83 7c 24 34 00	 cmp	 DWORD PTR x2$[rsp], 0
  00072	74 1d		 je	 SHORT $LN8@s370_multi
  00074	48 63 44 24 34	 movsxd	 rax, DWORD PTR x2$[rsp]
  00079	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00085	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00089	03 c8		 add	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_multi:
  00091	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00095	c1 e8 0c	 shr	 eax, 12
  00098	83 e0 0f	 and	 eax, 15
  0009b	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  0009f	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a4	74 1d		 je	 SHORT $LN9@s370_multi
  000a6	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bb	03 c8		 add	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_multi:
  000c3	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000cc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_multi:
  000d0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e2	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e6	33 c0		 xor	 eax, eax
  000e8	83 f8 06	 cmp	 eax, 6
  000eb	74 0c		 je	 SHORT $LN10@s370_multi
  000ed	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_multi:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 d1		 jne	 SHORT $LN4@s370_multi

; 4627 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4628 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4629 :     BFPINST_CHECK( regs );

  000ff	b8 08 00 00 00	 mov	 eax, 8
  00104	48 6b c0 01	 imul	 rax, rax, 1
  00108	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0010d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00114	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00119	85 c0		 test	 eax, eax
  0011b	74 39		 je	 SHORT $LN12@s370_multi
  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00122	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00128	d1 e8		 shr	 eax, 1
  0012a	83 e0 01	 and	 eax, 1
  0012d	85 c0		 test	 eax, eax
  0012f	74 49		 je	 SHORT $LN11@s370_multi
  00131	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00136	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013d	b9 08 00 00 00	 mov	 ecx, 8
  00142	48 6b c9 01	 imul	 rcx, rcx, 1
  00146	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0014d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00152	85 c0		 test	 eax, eax
  00154	75 24		 jne	 SHORT $LN11@s370_multi
$LN12@s370_multi:
  00156	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00165	ba 07 00 00 00	 mov	 edx, 7
  0016a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0016f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00174	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_multi:
$LN7@s370_multi:

; 4630 : 
; 4631 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  0017a	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0017e	d1 e0		 shl	 eax, 1
  00180	48 98		 cdqe
  00182	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0018f	48 8b d0	 mov	 rdx, rax
  00192	48 8d 4c 24 24	 lea	 rcx, QWORD PTR op1$[rsp]
  00197	e8 00 00 00 00	 call	 s370_get_float32
  0019c	8b 44 24 44	 mov	 eax, DWORD PTR r3$[rsp]
  001a0	d1 e0		 shl	 eax, 1
  001a2	48 98		 cdqe
  001a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b1	48 8b d0	 mov	 rdx, rax
  001b4	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  001b9	e8 00 00 00 00	 call	 s370_get_float32
  001be	33 c0		 xor	 eax, eax
  001c0	85 c0		 test	 eax, eax
  001c2	75 b6		 jne	 SHORT $LN7@s370_multi

; 4632 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  001c4	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001c9	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  001cd	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001d1	e8 00 00 00 00	 call	 s370_vfetch4
  001d6	89 44 24 4c	 mov	 DWORD PTR op2$[rsp], eax

; 4633 : 
; 4634 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4635 :     if (0
; 4636 :         || !(op1.v & 0x007FFFFF)
; 4637 :         || ((op1.v & 0x7F800000) ^ 0x7F800000)

  001da	33 c0		 xor	 eax, eax
  001dc	85 c0		 test	 eax, eax
  001de	75 1f		 jne	 SHORT $LN14@s370_multi
  001e0	8b 44 24 24	 mov	 eax, DWORD PTR op1$[rsp]
  001e4	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001e9	85 c0		 test	 eax, eax
  001eb	74 12		 je	 SHORT $LN14@s370_multi
  001ed	8b 44 24 24	 mov	 eax, DWORD PTR op1$[rsp]
  001f1	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  001f6	35 00 00 80 7f	 xor	 eax, 2139095040		; 7f800000H
  001fb	85 c0		 test	 eax, eax
  001fd	74 0c		 je	 SHORT $LN13@s370_multi
$LN14@s370_multi:

; 4638 :     )
; 4639 :         op1.v ^= 0x80000000;

  001ff	8b 44 24 24	 mov	 eax, DWORD PTR op1$[rsp]
  00203	0f ba f8 1f	 btc	 eax, 31
  00207	89 44 24 24	 mov	 DWORD PTR op1$[rsp], eax
$LN13@s370_multi:

; 4640 : 
; 4641 :     softfloat_exceptionFlags = 0;

  0020b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00210	8b c0		 mov	 eax, eax
  00212	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00218	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00221	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00225	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4642 :     SET_SF_RM_FROM_FPC;

  00229	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0022e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00234	83 e0 07	 and	 eax, 7
  00237	8b c0		 mov	 eax, eax
  00239	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00240	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00245	8b d2		 mov	 edx, edx
  00247	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0024e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00257	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0025b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4643 : 
; 4644 :     ans = f32_mulAdd( op2, op3, op1 );

  00263	44 8b 44 24 24	 mov	 r8d, DWORD PTR op1$[rsp]
  00268	8b 54 24 48	 mov	 edx, DWORD PTR op3$[rsp]
  0026c	8b 4c 24 4c	 mov	 ecx, DWORD PTR op2$[rsp]
  00270	e8 00 00 00 00	 call	 f32_mulAdd
  00275	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax

; 4645 : 
; 4646 :     if (softfloat_exceptionFlags)

  00279	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0027e	8b c0		 mov	 eax, eax
  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00286	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0028f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00293	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00297	85 c0		 test	 eax, eax
  00299	0f 84 93 00 00
	00		 je	 $LN15@s370_multi

; 4647 :     {
; 4648 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0029f	33 c0		 xor	 eax, eax
  002a1	83 f8 01	 cmp	 eax, 1
  002a4	74 45		 je	 SHORT $LN16@s370_multi
  002a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ab	8b c0		 mov	 eax, eax
  002ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002bc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c4	83 e0 10	 and	 eax, 16
  002c7	85 c0		 test	 eax, eax
  002c9	74 20		 je	 SHORT $LN16@s370_multi
  002cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002d6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002db	85 c0		 test	 eax, eax
  002dd	74 0c		 je	 SHORT $LN16@s370_multi
  002df	b2 80		 mov	 dl, 128			; 00000080H
  002e1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e6	e8 00 00 00 00	 call	 ieee_trap
$LN16@s370_multi:

; 4649 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002eb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002f5	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4650 : 
; 4651 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002f9	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002fd	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00302	85 c0		 test	 eax, eax
  00304	74 2c		 je	 SHORT $LN17@s370_multi

; 4652 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00306	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0030a	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0030f	85 c0		 test	 eax, eax
  00311	74 0a		 je	 SHORT $LN20@s370_multi
  00313	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv230[rsp], -192 ; ffffffffffffff40H
  0031b	eb 08		 jmp	 SHORT $LN21@s370_multi
$LN20@s370_multi:
  0031d	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv230[rsp], 192 ; 000000c0H
$LN21@s370_multi:
  00325	8b 4c 24 38	 mov	 ecx, DWORD PTR tv230[rsp]
  00329	e8 00 00 00 00	 call	 f32_scaledResult
  0032e	89 44 24 40	 mov	 DWORD PTR ans$[rsp], eax
$LN17@s370_multi:
$LN15@s370_multi:

; 4653 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4654 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4655 :     }
; 4656 : 
; 4657 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  00332	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00336	d1 e0		 shl	 eax, 1
  00338	48 98		 cdqe
  0033a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0033f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00347	48 8b d0	 mov	 rdx, rax
  0034a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  0034f	e8 00 00 00 00	 call	 s370_put_float32

; 4658 : 
; 4659 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00354	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00358	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0035d	85 c0		 test	 eax, eax
  0035f	74 0e		 je	 SHORT $LN18@s370_multi
  00361	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00365	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0036a	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@s370_multi:

; 4660 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4661 : }

  0036f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00373	c3		 ret	 0
s370_multiply_subtract_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv212 = 40
r1$ = 44
op1$ = 48
r3$ = 56
r2$ = 60
ans$ = 64
op3$ = 72
op2$ = 80
inst$ = 112
regs$ = 120
s370_multiply_subtract_bfp_long_reg PROC

; 4483 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4484 :     int        r1, r2, r3;
; 4485 :     float64_t  op1, op2, op3, ans;
; 4486 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4487 : 
; 4488 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 3c	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  00052	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN8@s370_multi
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@s370_multi

; 4489 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4490 :     BFPINST_CHECK( regs );

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00096	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009b	85 c0		 test	 eax, eax
  0009d	74 39		 je	 SHORT $LN10@s370_multi
  0009f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000aa	d1 e8		 shr	 eax, 1
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 49		 je	 SHORT $LN9@s370_multi
  000b3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000d4	85 c0		 test	 eax, eax
  000d6	75 24		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e7	ba 07 00 00 00	 mov	 edx, 7
  000ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:
$LN7@s370_multi:

; 4491 : 
; 4492 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  000fc	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00100	d1 e0		 shl	 eax, 1
  00102	48 98		 cdqe
  00104	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00119	e8 00 00 00 00	 call	 s370_get_float64
  0011e	8b 44 24 38	 mov	 eax, DWORD PTR r3$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  0013b	e8 00 00 00 00	 call	 s370_get_float64
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 b6		 jne	 SHORT $LN7@s370_multi

; 4493 :     GET_FLOAT64_OP( op2, r2, regs );

  00146	8b 44 24 3c	 mov	 eax, DWORD PTR r2$[rsp]
  0014a	d1 e0		 shl	 eax, 1
  0014c	48 98		 cdqe
  0014e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  00163	e8 00 00 00 00	 call	 s370_get_float64

; 4494 : 
; 4495 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4496 :     if (0
; 4497 :         || !(op1.v & 0x000FFFFFFFFFFFFF)
; 4498 :         || ((op1.v & 0x7FF0000000000000) ^ 0x7FF0000000000000)

  00168	33 c0		 xor	 eax, eax
  0016a	85 c0		 test	 eax, eax
  0016c	75 41		 jne	 SHORT $LN12@s370_multi
  0016e	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00178	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  0017d	48 23 c8	 and	 rcx, rax
  00180	48 8b c1	 mov	 rax, rcx
  00183	48 85 c0	 test	 rax, rax
  00186	74 27		 je	 SHORT $LN12@s370_multi
  00188	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00192	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  00197	48 23 c8	 and	 rcx, rax
  0019a	48 8b c1	 mov	 rax, rcx
  0019d	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001a7	48 33 c1	 xor	 rax, rcx
  001aa	48 85 c0	 test	 rax, rax
  001ad	74 1a		 je	 SHORT $LN11@s370_multi
$LN12@s370_multi:

; 4499 :     )
; 4500 :         op1.v ^= 0x8000000000000000ULL;

  001af	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1$[rsp]
  001be	48 33 c8	 xor	 rcx, rax
  001c1	48 8b c1	 mov	 rax, rcx
  001c4	48 89 44 24 30	 mov	 QWORD PTR op1$[rsp], rax
$LN11@s370_multi:

; 4501 : 
; 4502 :     softfloat_exceptionFlags = 0;

  001c9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ce	8b c0		 mov	 eax, eax
  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001df	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4503 :     SET_SF_RM_FROM_FPC;

  001e7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ec	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f2	83 e0 07	 and	 eax, 7
  001f5	8b c0		 mov	 eax, eax
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001fe	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00203	8b d2		 mov	 edx, edx
  00205	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0020c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00215	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00219	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4504 : 
; 4505 :     ans = f64_mulAdd( op2, op3, op1 );

  00221	4c 8b 44 24 30	 mov	 r8, QWORD PTR op1$[rsp]
  00226	48 8b 54 24 48	 mov	 rdx, QWORD PTR op3$[rsp]
  0022b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  00230	e8 00 00 00 00	 call	 f64_mulAdd
  00235	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 4506 : 
; 4507 :     if (softfloat_exceptionFlags)

  0023a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0023f	8b c0		 mov	 eax, eax
  00241	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00247	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00250	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00254	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00258	85 c0		 test	 eax, eax
  0025a	0f 84 94 00 00
	00		 je	 $LN13@s370_multi

; 4508 :     {
; 4509 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00260	33 c0		 xor	 eax, eax
  00262	83 f8 01	 cmp	 eax, 1
  00265	74 45		 je	 SHORT $LN14@s370_multi
  00267	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0026c	8b c0		 mov	 eax, eax
  0026e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00274	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00281	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00285	83 e0 10	 and	 eax, 16
  00288	85 c0		 test	 eax, eax
  0028a	74 20		 je	 SHORT $LN14@s370_multi
  0028c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00291	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00297	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0029c	85 c0		 test	 eax, eax
  0029e	74 0c		 je	 SHORT $LN14@s370_multi
  002a0	b2 80		 mov	 dl, 128			; 00000080H
  002a2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002a7	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_multi:

; 4510 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ac	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002b1	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002b6	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4511 : 
; 4512 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ba	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002be	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002c3	85 c0		 test	 eax, eax
  002c5	74 2d		 je	 SHORT $LN15@s370_multi

; 4513 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002c7	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cb	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002d0	85 c0		 test	 eax, eax
  002d2	74 0a		 je	 SHORT $LN18@s370_multi
  002d4	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv212[rsp], -1536 ; fffffffffffffa00H
  002dc	eb 08		 jmp	 SHORT $LN19@s370_multi
$LN18@s370_multi:
  002de	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv212[rsp], 1536 ; 00000600H
$LN19@s370_multi:
  002e6	8b 4c 24 28	 mov	 ecx, DWORD PTR tv212[rsp]
  002ea	e8 00 00 00 00	 call	 f64_scaledResult
  002ef	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN15@s370_multi:
$LN13@s370_multi:

; 4514 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4515 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4516 :     }
; 4517 : 
; 4518 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  002f4	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002f8	d1 e0		 shl	 eax, 1
  002fa	48 98		 cdqe
  002fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00301	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00309	48 8b d0	 mov	 rdx, rax
  0030c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  00311	e8 00 00 00 00	 call	 s370_put_float64

; 4519 : 
; 4520 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00316	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0031a	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0031f	85 c0		 test	 eax, eax
  00321	74 0e		 je	 SHORT $LN16@s370_multi
  00323	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00327	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0032c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_multi:

; 4521 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4522 : }

  00331	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00335	c3		 ret	 0
s370_multiply_subtract_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv230 = 52
r1$ = 56
op1$ = 64
r3$ = 72
ans$ = 80
op3$ = 88
op2$ = 96
inst$ = 128
regs$ = 136
s370_multiply_subtract_bfp_long PROC

; 4528 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4529 :     int        x2, r1, r3, b2;
; 4530 :     VADR       effective_addr2;
; 4531 :     float64_t  op1, op2, op3, ans;
; 4532 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4533 : 
; 4534 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 04	 imul	 rax, rax, 4
  00037	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00043	c1 f8 04	 sar	 eax, 4
  00046	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  0004a	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00053	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00057	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	c1 e8 10	 shr	 eax, 16
  0005e	83 e0 0f	 and	 eax, 15
  00061	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00065	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00069	c1 e8 14	 shr	 eax, 20
  0006c	83 e0 0f	 and	 eax, 15
  0006f	89 44 24 48	 mov	 DWORD PTR r3$[rsp], eax
  00073	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00078	74 20		 je	 SHORT $LN8@s370_multi
  0007a	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0007f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0008e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00092	03 c8		 add	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_multi:
  0009a	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0009e	c1 e8 0c	 shr	 eax, 12
  000a1	83 e0 0f	 and	 eax, 15
  000a4	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  000a8	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ad	74 20		 je	 SHORT $LN9@s370_multi
  000af	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c3	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000c7	03 c8		 add	 ecx, eax
  000c9	8b c1		 mov	 eax, ecx
  000cb	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_multi:
  000cf	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000d3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000d8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_multi:
  000dc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e8	48 83 c0 06	 add	 rax, 6
  000ec	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f8	33 c0		 xor	 eax, eax
  000fa	83 f8 06	 cmp	 eax, 6
  000fd	74 0f		 je	 SHORT $LN10@s370_multi
  000ff	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00107	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_multi:
  0010e	33 c0		 xor	 eax, eax
  00110	85 c0		 test	 eax, eax
  00112	75 c8		 jne	 SHORT $LN4@s370_multi

; 4535 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4536 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4537 :     BFPINST_CHECK( regs );

  00114	b8 08 00 00 00	 mov	 eax, 8
  00119	48 6b c0 01	 imul	 rax, rax, 1
  0011d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	74 3f		 je	 SHORT $LN12@s370_multi
  00135	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00143	d1 e8		 shr	 eax, 1
  00145	83 e0 01	 and	 eax, 1
  00148	85 c0		 test	 eax, eax
  0014a	74 55		 je	 SHORT $LN11@s370_multi
  0014c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00154	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0015b	b9 08 00 00 00	 mov	 ecx, 8
  00160	48 6b c9 01	 imul	 rcx, rcx, 1
  00164	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0016b	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00170	85 c0		 test	 eax, eax
  00172	75 2d		 jne	 SHORT $LN11@s370_multi
$LN12@s370_multi:
  00174	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00186	ba 07 00 00 00	 mov	 edx, 7
  0018b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00193	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_multi:
$LN7@s370_multi:

; 4538 : 
; 4539 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  001a1	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001a5	d1 e0		 shl	 eax, 1
  001a7	48 98		 cdqe
  001a9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b9	48 8b d0	 mov	 rdx, rax
  001bc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  001c1	e8 00 00 00 00	 call	 s370_get_float64
  001c6	8b 44 24 48	 mov	 eax, DWORD PTR r3$[rsp]
  001ca	d1 e0		 shl	 eax, 1
  001cc	48 98		 cdqe
  001ce	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d6	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001de	48 8b d0	 mov	 rdx, rax
  001e1	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op3$[rsp]
  001e6	e8 00 00 00 00	 call	 s370_get_float64
  001eb	33 c0		 xor	 eax, eax
  001ed	85 c0		 test	 eax, eax
  001ef	75 b0		 jne	 SHORT $LN7@s370_multi

; 4540 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001f1	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f9	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001fd	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00201	e8 00 00 00 00	 call	 s370_vfetch8
  00206	48 89 44 24 60	 mov	 QWORD PTR op2$[rsp], rax

; 4541 : 
; 4542 :     /* if Operand 1 is not a NaN, the sign bit is inverted */
; 4543 :     if (0
; 4544 :         || !(op1.v & 0x000FFFFFFFFFFFFF)
; 4545 :         || ((op1.v & 0x7FF0000000000000) ^ 0x7FF0000000000000)

  0020b	33 c0		 xor	 eax, eax
  0020d	85 c0		 test	 eax, eax
  0020f	75 41		 jne	 SHORT $LN14@s370_multi
  00211	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0021b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00220	48 23 c8	 and	 rcx, rax
  00223	48 8b c1	 mov	 rax, rcx
  00226	48 85 c0	 test	 rax, rax
  00229	74 27		 je	 SHORT $LN14@s370_multi
  0022b	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00235	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  0023a	48 23 c8	 and	 rcx, rax
  0023d	48 8b c1	 mov	 rax, rcx
  00240	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0024a	48 33 c1	 xor	 rax, rcx
  0024d	48 85 c0	 test	 rax, rax
  00250	74 1a		 je	 SHORT $LN13@s370_multi
$LN14@s370_multi:

; 4546 :     )
; 4547 :         op1.v ^= 0x8000000000000000ULL;

  00252	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0025c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00261	48 33 c8	 xor	 rcx, rax
  00264	48 8b c1	 mov	 rax, rcx
  00267	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax
$LN13@s370_multi:

; 4548 : 
; 4549 :     softfloat_exceptionFlags = 0;

  0026c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00271	8b c0		 mov	 eax, eax
  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00279	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00282	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00286	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4550 :     SET_SF_RM_FROM_FPC;

  0028a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00292	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00298	83 e0 07	 and	 eax, 7
  0029b	8b c0		 mov	 eax, eax
  0029d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002a4	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  002a9	8b d2		 mov	 edx, edx
  002ab	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  002b2	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  002bb	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  002bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c3	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4551 : 
; 4552 :     ans = f64_mulAdd( op2, op3, op1 );

  002c7	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  002cc	48 8b 54 24 58	 mov	 rdx, QWORD PTR op3$[rsp]
  002d1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op2$[rsp]
  002d6	e8 00 00 00 00	 call	 f64_mulAdd
  002db	48 89 44 24 50	 mov	 QWORD PTR ans$[rsp], rax

; 4553 : 
; 4554 :     if (softfloat_exceptionFlags)

  002e0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e5	8b c0		 mov	 eax, eax
  002e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ed	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002fe	85 c0		 test	 eax, eax
  00300	0f 84 9d 00 00
	00		 je	 $LN15@s370_multi

; 4555 :     {
; 4556 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00306	33 c0		 xor	 eax, eax
  00308	83 f8 01	 cmp	 eax, 1
  0030b	74 4b		 je	 SHORT $LN16@s370_multi
  0030d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00312	8b c0		 mov	 eax, eax
  00314	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0031a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00323	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00327	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0032b	83 e0 10	 and	 eax, 16
  0032e	85 c0		 test	 eax, eax
  00330	74 26		 je	 SHORT $LN16@s370_multi
  00332	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00340	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00345	85 c0		 test	 eax, eax
  00347	74 0f		 je	 SHORT $LN16@s370_multi
  00349	b2 80		 mov	 dl, 128			; 00000080H
  0034b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00353	e8 00 00 00 00	 call	 ieee_trap
$LN16@s370_multi:

; 4557 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00358	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00360	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00365	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4558 : 
; 4559 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00369	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0036d	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00372	85 c0		 test	 eax, eax
  00374	74 2d		 je	 SHORT $LN17@s370_multi

; 4560 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00376	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0037a	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0037f	85 c0		 test	 eax, eax
  00381	74 0a		 je	 SHORT $LN20@s370_multi
  00383	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv230[rsp], -1536 ; fffffffffffffa00H
  0038b	eb 08		 jmp	 SHORT $LN21@s370_multi
$LN20@s370_multi:
  0038d	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv230[rsp], 1536 ; 00000600H
$LN21@s370_multi:
  00395	8b 4c 24 34	 mov	 ecx, DWORD PTR tv230[rsp]
  00399	e8 00 00 00 00	 call	 f64_scaledResult
  0039e	48 89 44 24 50	 mov	 QWORD PTR ans$[rsp], rax
$LN17@s370_multi:
$LN15@s370_multi:

; 4561 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4562 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4563 :     }
; 4564 : 
; 4565 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  003a3	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  003a7	d1 e0		 shl	 eax, 1
  003a9	48 98		 cdqe
  003ab	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b3	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003bb	48 8b d0	 mov	 rdx, rax
  003be	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ans$[rsp]
  003c3	e8 00 00 00 00	 call	 s370_put_float64

; 4566 : 
; 4567 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003c8	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003cc	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003d1	85 c0		 test	 eax, eax
  003d3	74 11		 je	 SHORT $LN18@s370_multi
  003d5	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e1	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@s370_multi:

; 4568 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4569 : }

  003e6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003ea	c3		 ret	 0
s370_multiply_subtract_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
op1$ = 44
op2$ = 48
ans$ = 56
iop2$ = 64
iop1$ = 72
inst$ = 96
regs$ = 104
s370_multiply_bfp_short_to_long_reg PROC

; 4145 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4146 :     int        r1, r2;
; 4147 :     float32_t  op1, op2;
; 4148 :     float64_t  iop1, iop2, ans;
; 4149 : 
; 4150 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_multi
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_multi

; 4151 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4152 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_multi
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_multi
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:
$LN7@s370_multi:

; 4153 : 
; 4154 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float32
  00109	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s370_get_float32
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s370_multi

; 4155 : 
; 4156 :     /* f32_to_f64 will, if presented with a SNaN, convert it to quiet
; 4157 :        and raise softfloat_flags_invalid.  Unfortunately, if one of
; 4158 :        the operands is an SNaN and the other a QNaN, f64_mul() will be
; 4159 :        unable to do NaN propagation correctly because it will see only
; 4160 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 4161 :        input operands, that becomes the answer.  If both operands are
; 4162 :        QNaNs, then f64_mul() will be able to do NaN propagation correctly.
; 4163 :     */
; 4164 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4165 :     softfloat_roundingMode = softfloat_round_near_even;

  0014f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00154	8b c0		 mov	 eax, eax
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0015c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00165	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00169	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4166 : 
; 4167 :     iop1 = f32_to_f64( op1 );

  0016d	8b 4c 24 2c	 mov	 ecx, DWORD PTR op1$[rsp]
  00171	e8 00 00 00 00	 call	 f32_to_f64
  00176	48 89 44 24 48	 mov	 QWORD PTR iop1$[rsp], rax

; 4168 : 
; 4169 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0017b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00180	8b c0		 mov	 eax, eax
  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00188	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00191	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00195	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00199	83 e0 10	 and	 eax, 16
  0019c	85 c0		 test	 eax, eax
  0019e	74 0c		 je	 SHORT $LN11@s370_multi

; 4170 :         ans = iop1;

  001a0	48 8b 44 24 48	 mov	 rax, QWORD PTR iop1$[rsp]
  001a5	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
  001aa	eb 53		 jmp	 SHORT $LN12@s370_multi
$LN11@s370_multi:

; 4171 :     else
; 4172 :     {
; 4173 :         iop2 = f32_to_f64( op2 );

  001ac	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 f32_to_f64
  001b5	48 89 44 24 40	 mov	 QWORD PTR iop2$[rsp], rax

; 4174 : 
; 4175 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  001ba	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001bf	8b c0		 mov	 eax, eax
  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d8	83 e0 10	 and	 eax, 16
  001db	85 c0		 test	 eax, eax
  001dd	74 0c		 je	 SHORT $LN13@s370_multi

; 4176 :             ans = iop2;

  001df	48 8b 44 24 40	 mov	 rax, QWORD PTR iop2$[rsp]
  001e4	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
  001e9	eb 14		 jmp	 SHORT $LN14@s370_multi
$LN13@s370_multi:

; 4177 :         else
; 4178 :             ans = f64_mul( iop1, iop2 );

  001eb	48 8b 54 24 40	 mov	 rdx, QWORD PTR iop2$[rsp]
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR iop1$[rsp]
  001f5	e8 00 00 00 00	 call	 f64_mul
  001fa	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN14@s370_multi:
$LN12@s370_multi:

; 4179 :     }
; 4180 : 
; 4181 :     if (softfloat_exceptionFlags)

  001ff	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00204	8b c0		 mov	 eax, eax
  00206	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00215	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00219	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021d	85 c0		 test	 eax, eax
  0021f	0f 84 9e 00 00
	00		 je	 $LN15@s370_multi

; 4182 :     {
; 4183 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00225	33 c0		 xor	 eax, eax
  00227	83 f8 01	 cmp	 eax, 1
  0022a	74 45		 je	 SHORT $LN16@s370_multi
  0022c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00231	8b c0		 mov	 eax, eax
  00233	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00239	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00242	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00246	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024a	83 e0 10	 and	 eax, 16
  0024d	85 c0		 test	 eax, eax
  0024f	74 20		 je	 SHORT $LN16@s370_multi
  00251	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00256	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0025c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00261	85 c0		 test	 eax, eax
  00263	74 0c		 je	 SHORT $LN16@s370_multi
  00265	b2 80		 mov	 dl, 128			; 00000080H
  00267	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	e8 00 00 00 00	 call	 ieee_trap
$LN16@s370_multi:

; 4184 :         SET_FPC_FLAGS_FROM_SF( regs );

  00271	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00276	8b c0		 mov	 eax, eax
  00278	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0027e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00287	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0028b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028f	c1 e0 13	 shl	 eax, 19
  00292	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00297	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0029d	c1 e9 08	 shr	 ecx, 8
  002a0	f7 d1		 not	 ecx
  002a2	23 c1		 and	 eax, ecx
  002a4	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ae	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002b4	0b c8		 or	 ecx, eax
  002b6	8b c1		 mov	 eax, ecx
  002b8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN15@s370_multi:

; 4185 :     }
; 4186 : 
; 4187 :     PUT_FLOAT64_NOCC(ans, r1, regs);

  002c3	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  002c7	d1 e0		 shl	 eax, 1
  002c9	48 98		 cdqe
  002cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002d0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d8	48 8b d0	 mov	 rdx, rax
  002db	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  002e0	e8 00 00 00 00	 call	 s370_put_float64

; 4188 : }

  002e5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002e9	c3		 ret	 0
s370_multiply_bfp_short_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
r1$ = 48
op1$ = 52
op2$ = 56
ans$ = 64
iop2$ = 72
iop1$ = 80
inst$ = 112
regs$ = 120
s370_multiply_bfp_short_to_long PROC

; 4198 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4199 :     int        r1, x2, b2;
; 4200 :     VADR       effective_addr2;
; 4201 :     float32_t  op1, op2;
; 4202 :     float64_t  iop1, iop2, ans;
; 4203 : 
; 4204 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s370_multi
  00053	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_multi:
  00070	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s370_multi
  00085	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_multi:
  000a2	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000a6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ab	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_multi:
  000af	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 06	 add	 rax, 6
  000bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN7@s370_multi
  000cc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_multi:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 d1		 jne	 SHORT $LN4@s370_multi

; 4205 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4206 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4207 :     BFPINST_CHECK( regs );

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	85 c0		 test	 eax, eax
  000fa	74 39		 je	 SHORT $LN9@s370_multi
  000fc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00107	d1 e8		 shr	 eax, 1
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	74 49		 je	 SHORT $LN8@s370_multi
  00110	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	48 6b c9 01	 imul	 rcx, rcx, 1
  00125	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	75 24		 jne	 SHORT $LN8@s370_multi
$LN9@s370_multi:
  00135	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00144	ba 07 00 00 00	 mov	 edx, 7
  00149	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00153	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_multi:

; 4208 : 
; 4209 :     GET_FLOAT32_OP( op1, r1, regs );

  00159	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	48 98		 cdqe
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016e	48 8b d0	 mov	 rdx, rax
  00171	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00176	e8 00 00 00 00	 call	 s370_get_float32

; 4210 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0017b	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00180	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00184	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00188	e8 00 00 00 00	 call	 s370_vfetch4
  0018d	89 44 24 38	 mov	 DWORD PTR op2$[rsp], eax

; 4211 : 
; 4212 :     /* f32_to_f64 will, if presented with a SNaN, convert it to quiet
; 4213 :        and raise softfloat_flags_invalid.  Unfortunately, if one of the
; 4214 :        operands is an SNaN and the other a QNaN, f64_mul() will be
; 4215 :        unable to do NaN propagation correctly because it will see only
; 4216 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 4217 :        input operands, that becomes the answer.  If both operands are
; 4218 :        QNaNs, then f64_mul() will be able to do NaN propagation correctly.
; 4219 :     */
; 4220 :     softfloat_exceptionFlags = 0;

  00191	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00196	8b c0		 mov	 eax, eax
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ab	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4221 :     softfloat_roundingMode = softfloat_round_near_even;

  001af	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001b4	8b c0		 mov	 eax, eax
  001b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001bc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c9	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4222 : 
; 4223 :     iop1 = f32_to_f64( op1 );

  001cd	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  001d1	e8 00 00 00 00	 call	 f32_to_f64
  001d6	48 89 44 24 50	 mov	 QWORD PTR iop1$[rsp], rax

; 4224 : 
; 4225 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  001db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e0	8b c0		 mov	 eax, eax
  001e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f9	83 e0 10	 and	 eax, 16
  001fc	85 c0		 test	 eax, eax
  001fe	74 0c		 je	 SHORT $LN10@s370_multi

; 4226 :         ans = iop1;

  00200	48 8b 44 24 50	 mov	 rax, QWORD PTR iop1$[rsp]
  00205	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
  0020a	eb 53		 jmp	 SHORT $LN11@s370_multi
$LN10@s370_multi:

; 4227 :     else
; 4228 :     {
; 4229 :         iop2 = f32_to_f64( op2 );

  0020c	8b 4c 24 38	 mov	 ecx, DWORD PTR op2$[rsp]
  00210	e8 00 00 00 00	 call	 f32_to_f64
  00215	48 89 44 24 48	 mov	 QWORD PTR iop2$[rsp], rax

; 4230 : 
; 4231 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0021a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0021f	8b c0		 mov	 eax, eax
  00221	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00227	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00230	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00234	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00238	83 e0 10	 and	 eax, 16
  0023b	85 c0		 test	 eax, eax
  0023d	74 0c		 je	 SHORT $LN12@s370_multi

; 4232 :             ans = iop2;

  0023f	48 8b 44 24 48	 mov	 rax, QWORD PTR iop2$[rsp]
  00244	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
  00249	eb 14		 jmp	 SHORT $LN13@s370_multi
$LN12@s370_multi:

; 4233 :         else
; 4234 :             ans = f64_mul( iop1, iop2 );

  0024b	48 8b 54 24 48	 mov	 rdx, QWORD PTR iop2$[rsp]
  00250	48 8b 4c 24 50	 mov	 rcx, QWORD PTR iop1$[rsp]
  00255	e8 00 00 00 00	 call	 f64_mul
  0025a	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN13@s370_multi:
$LN11@s370_multi:

; 4235 :     }
; 4236 : 
; 4237 :     if (softfloat_exceptionFlags)

  0025f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00264	8b c0		 mov	 eax, eax
  00266	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00275	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00279	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027d	85 c0		 test	 eax, eax
  0027f	0f 84 9e 00 00
	00		 je	 $LN14@s370_multi

; 4238 :     {
; 4239 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00285	33 c0		 xor	 eax, eax
  00287	83 f8 01	 cmp	 eax, 1
  0028a	74 45		 je	 SHORT $LN15@s370_multi
  0028c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00291	8b c0		 mov	 eax, eax
  00293	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00299	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002aa	83 e0 10	 and	 eax, 16
  002ad	85 c0		 test	 eax, eax
  002af	74 20		 je	 SHORT $LN15@s370_multi
  002b1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002b6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002bc	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002c1	85 c0		 test	 eax, eax
  002c3	74 0c		 je	 SHORT $LN15@s370_multi
  002c5	b2 80		 mov	 dl, 128			; 00000080H
  002c7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	e8 00 00 00 00	 call	 ieee_trap
$LN15@s370_multi:

; 4240 :         SET_FPC_FLAGS_FROM_SF( regs );

  002d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002d6	8b c0		 mov	 eax, eax
  002d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002de	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ef	c1 e0 13	 shl	 eax, 19
  002f2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002fd	c1 e9 08	 shr	 ecx, 8
  00300	f7 d1		 not	 ecx
  00302	23 c1		 and	 eax, ecx
  00304	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00309	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0030e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00314	0b c8		 or	 ecx, eax
  00316	8b c1		 mov	 eax, ecx
  00318	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0031d	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN14@s370_multi:

; 4241 :     }
; 4242 : 
; 4243 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00323	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00327	d1 e0		 shl	 eax, 1
  00329	48 98		 cdqe
  0032b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00330	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00338	48 8b d0	 mov	 rdx, rax
  0033b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  00340	e8 00 00 00 00	 call	 s370_put_float64

; 4244 : }

  00345	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00349	c3		 ret	 0
s370_multiply_bfp_short_to_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv194 = 40
r1$ = 44
ans$ = 48
r2$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s370_multiply_bfp_short_reg PROC

; 4250 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4251 :     int        r1, r2;
; 4252 :     float32_t  op1, op2, ans;
; 4253 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4254 : 
; 4255 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@s370_multi
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_multi

; 4256 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4257 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN10@s370_multi
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN9@s370_multi
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:
$LN7@s370_multi:

; 4258 : 
; 4259 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float32
  00111	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s370_get_float32
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s370_multi

; 4260 : 
; 4261 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4262 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4263 : 
; 4264 :     ans = f32_mul( op1, op2 );

  00191	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00195	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  00199	e8 00 00 00 00	 call	 f32_mul
  0019e	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 4265 : 
; 4266 :     if (softfloat_exceptionFlags)

  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a7	8b c0		 mov	 eax, eax
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 93 00 00
	00		 je	 $LN11@s370_multi

; 4267 :     {
; 4268 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001c8	33 c0		 xor	 eax, eax
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	74 45		 je	 SHORT $LN12@s370_multi
  001cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d4	8b c0		 mov	 eax, eax
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	83 e0 10	 and	 eax, 16
  001f0	85 c0		 test	 eax, eax
  001f2	74 20		 je	 SHORT $LN12@s370_multi
  001f4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ff	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00204	85 c0		 test	 eax, eax
  00206	74 0c		 je	 SHORT $LN12@s370_multi
  00208	b2 80		 mov	 dl, 128			; 00000080H
  0020a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_multi:

; 4269 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00214	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0021e	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4270 : 
; 4271 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00222	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00226	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022b	85 c0		 test	 eax, eax
  0022d	74 2c		 je	 SHORT $LN13@s370_multi

; 4272 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0022f	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00233	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN16@s370_multi
  0023c	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv194[rsp], -192 ; ffffffffffffff40H
  00244	eb 08		 jmp	 SHORT $LN17@s370_multi
$LN16@s370_multi:
  00246	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv194[rsp], 192 ; 000000c0H
$LN17@s370_multi:
  0024e	8b 4c 24 28	 mov	 ecx, DWORD PTR tv194[rsp]
  00252	e8 00 00 00 00	 call	 f32_scaledResult
  00257	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN13@s370_multi:
$LN11@s370_multi:

; 4273 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4274 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4275 :     }
; 4276 : 
; 4277 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  0025b	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0025f	d1 e0		 shl	 eax, 1
  00261	48 98		 cdqe
  00263	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00270	48 8b d0	 mov	 rdx, rax
  00273	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  00278	e8 00 00 00 00	 call	 s370_put_float32

; 4278 : 
; 4279 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0027d	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00281	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00286	85 c0		 test	 eax, eax
  00288	74 0e		 je	 SHORT $LN14@s370_multi
  0028a	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0028e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_multi:

; 4280 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4281 : }

  00298	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0029c	c3		 ret	 0
s370_multiply_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv210 = 52
r1$ = 56
ans$ = 60
op2$ = 64
op1$ = 68
inst$ = 96
regs$ = 104
s370_multiply_bfp_short PROC

; 4287 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4288 :     int        r1, x2, b2;
; 4289 :     VADR       effective_addr2;
; 4290 :     float32_t  op1, op2, ans;
; 4291 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4292 : 
; 4293 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_multi
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_multi:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_multi
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_multi:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000ae	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_multi:
  000b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f8 06	 cmp	 eax, 6
  000d2	74 0c		 je	 SHORT $LN7@s370_multi
  000d4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_multi:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d1		 jne	 SHORT $LN4@s370_multi

; 4294 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4295 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4296 :     BFPINST_CHECK( regs );

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	74 39		 je	 SHORT $LN9@s370_multi
  00104	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010f	d1 e8		 shr	 eax, 1
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 49		 je	 SHORT $LN8@s370_multi
  00118	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00124	b9 08 00 00 00	 mov	 ecx, 8
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	75 24		 jne	 SHORT $LN8@s370_multi
$LN9@s370_multi:
  0013d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00142	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014c	ba 07 00 00 00	 mov	 edx, 7
  00151	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_multi:

; 4297 : 
; 4298 :     GET_FLOAT32_OP( op1, r1, regs );

  00161	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00165	d1 e0		 shl	 eax, 1
  00167	48 98		 cdqe
  00169	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00176	48 8b d0	 mov	 rdx, rax
  00179	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op1$[rsp]
  0017e	e8 00 00 00 00	 call	 s370_get_float32

; 4299 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00183	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00188	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0018c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00190	e8 00 00 00 00	 call	 s370_vfetch4
  00195	89 44 24 40	 mov	 DWORD PTR op2$[rsp], eax

; 4300 : 
; 4301 :     softfloat_exceptionFlags = 0;

  00199	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019e	8b c0		 mov	 eax, eax
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4302 :     SET_SF_RM_FROM_FPC;

  001b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c2	83 e0 07	 and	 eax, 7
  001c5	8b c0		 mov	 eax, eax
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001d3	8b d2		 mov	 edx, edx
  001d5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001dc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001e5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4303 : 
; 4304 :     ans = f32_mul( op1, op2 );

  001f1	8b 54 24 40	 mov	 edx, DWORD PTR op2$[rsp]
  001f5	8b 4c 24 44	 mov	 ecx, DWORD PTR op1$[rsp]
  001f9	e8 00 00 00 00	 call	 f32_mul
  001fe	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax

; 4305 : 
; 4306 :     if (softfloat_exceptionFlags)

  00202	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00207	8b c0		 mov	 eax, eax
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00218	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00220	85 c0		 test	 eax, eax
  00222	0f 84 93 00 00
	00		 je	 $LN10@s370_multi

; 4307 :     {
; 4308 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00228	33 c0		 xor	 eax, eax
  0022a	83 f8 01	 cmp	 eax, 1
  0022d	74 45		 je	 SHORT $LN11@s370_multi
  0022f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00234	8b c0		 mov	 eax, eax
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00245	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00249	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024d	83 e0 10	 and	 eax, 16
  00250	85 c0		 test	 eax, eax
  00252	74 20		 je	 SHORT $LN11@s370_multi
  00254	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00259	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0025f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00264	85 c0		 test	 eax, eax
  00266	74 0c		 je	 SHORT $LN11@s370_multi
  00268	b2 80		 mov	 dl, 128			; 00000080H
  0026a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_multi:

; 4309 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00274	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0027e	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4310 : 
; 4311 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00282	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00286	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0028b	85 c0		 test	 eax, eax
  0028d	74 2c		 je	 SHORT $LN12@s370_multi

; 4312 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0028f	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00293	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00298	85 c0		 test	 eax, eax
  0029a	74 0a		 je	 SHORT $LN15@s370_multi
  0029c	c7 44 24 34 40
	ff ff ff	 mov	 DWORD PTR tv210[rsp], -192 ; ffffffffffffff40H
  002a4	eb 08		 jmp	 SHORT $LN16@s370_multi
$LN15@s370_multi:
  002a6	c7 44 24 34 c0
	00 00 00	 mov	 DWORD PTR tv210[rsp], 192 ; 000000c0H
$LN16@s370_multi:
  002ae	8b 4c 24 34	 mov	 ecx, DWORD PTR tv210[rsp]
  002b2	e8 00 00 00 00	 call	 f32_scaledResult
  002b7	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax
$LN12@s370_multi:
$LN10@s370_multi:

; 4313 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4314 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4315 :     }
; 4316 : 
; 4317 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  002bb	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002bf	d1 e0		 shl	 eax, 1
  002c1	48 98		 cdqe
  002c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d0	48 8b d0	 mov	 rdx, rax
  002d3	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR ans$[rsp]
  002d8	e8 00 00 00 00	 call	 s370_put_float32

; 4318 : 
; 4319 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002dd	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e1	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002e6	85 c0		 test	 eax, eax
  002e8	74 0e		 je	 SHORT $LN13@s370_multi
  002ea	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002ee	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002f3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN13@s370_multi:

; 4320 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4321 : }

  002f8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002fc	c3		 ret	 0
s370_multiply_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
r1$ = 32
i$1 = 36
r2$ = 40
op1$ = 48
op2$ = 56
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
ans$ = 144
iop2$ = 160
iop1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
s370_multiply_bfp_long_to_ext_reg PROC

; 3958 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3959 :     int         r1, r2;
; 3960 :     float64_t   op1, op2;
; 3961 :     float128_t  iop1, iop2, ans;
; 3962 : 
; 3963 :     RRE( inst, regs, r1, r2 );

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	48 6b c0 03	 imul	 rax, rax, 3
  0002e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00036	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003a	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004d	c1 f8 04	 sar	 eax, 4
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  00057	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00063	48 83 c0 04	 add	 rax, 4
  00067	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00073	33 c0		 xor	 eax, eax
  00075	83 f8 04	 cmp	 eax, 4
  00078	74 0f		 je	 SHORT $LN8@s370_multi
  0007a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 c8		 jne	 SHORT $LN4@s370_multi

; 3964 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3965 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a0	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a7	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ac	85 c0		 test	 eax, eax
  000ae	74 3f		 je	 SHORT $LN10@s370_multi
  000b0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000be	d1 e8		 shr	 eax, 1
  000c0	83 e0 01	 and	 eax, 1
  000c3	85 c0		 test	 eax, eax
  000c5	74 55		 je	 SHORT $LN9@s370_multi
  000c7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d6	b9 08 00 00 00	 mov	 ecx, 8
  000db	48 6b c9 01	 imul	 rcx, rcx, 1
  000df	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e6	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000eb	85 c0		 test	 eax, eax
  000ed	75 2d		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000ef	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00101	ba 07 00 00 00	 mov	 edx, 7
  00106	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00116	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:

; 3966 :     BFPREGPAIR_CHECK( r1, regs );

  0011c	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  00120	83 e0 02	 and	 eax, 2
  00123	85 c0		 test	 eax, eax
  00125	74 1b		 je	 SHORT $LN11@s370_multi
  00127	ba 06 00 00 00	 mov	 edx, 6
  0012c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_multi:
$LN7@s370_multi:

; 3967 : 
; 3968 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  00142	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  00146	d1 e0		 shl	 eax, 1
  00148	48 98		 cdqe
  0014a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00152	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015a	48 8b d0	 mov	 rdx, rax
  0015d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00162	e8 00 00 00 00	 call	 s370_get_float64
  00167	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0016b	d1 e0		 shl	 eax, 1
  0016d	48 98		 cdqe
  0016f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0017f	48 8b d0	 mov	 rdx, rax
  00182	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  00187	e8 00 00 00 00	 call	 s370_get_float64
  0018c	33 c0		 xor	 eax, eax
  0018e	85 c0		 test	 eax, eax
  00190	75 b0		 jne	 SHORT $LN7@s370_multi

; 3969 : 
; 3970 :     /* f64_to_f128 will, if presented with a SNaN, convert it to quiet
; 3971 :        and raise softfloat_flags_invalid. Unfortunately, if one of the
; 3972 :        operands is an SNaN and the other a QNaN, f128_mul() will be
; 3973 :        unable to do NaN propagation correctly because it will see only
; 3974 :        two QNaNs.  So if we encounter an SNaN while upconverting the
; 3975 :        input operands, that becomes the answer.  If both operands are
; 3976 :        QNaNs, then f128_mul() will be able to do NaN propagation correctly.
; 3977 :     */
; 3978 :     softfloat_exceptionFlags = 0;

  00192	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00197	8b c0		 mov	 eax, eax
  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ac	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3979 :     softfloat_roundingMode = softfloat_round_near_even;

  001b0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001b5	8b c0		 mov	 eax, eax
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001bd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ca	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3980 : 
; 3981 :     iop1 = f64_to_f128( op1 );

  001ce	48 8b 54 24 30	 mov	 rdx, QWORD PTR op1$[rsp]
  001d3	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  001d8	e8 00 00 00 00	 call	 f64_to_f128
  001dd	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  001e5	48 8b f9	 mov	 rdi, rcx
  001e8	48 8b f0	 mov	 rsi, rax
  001eb	b9 10 00 00 00	 mov	 ecx, 16
  001f0	f3 a4		 rep movsb

; 3982 : 
; 3983 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  001f2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f7	8b c0		 mov	 eax, eax
  001f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ff	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00208	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0020c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00210	83 e0 10	 and	 eax, 16
  00213	85 c0		 test	 eax, eax
  00215	74 22		 je	 SHORT $LN12@s370_multi

; 3984 :         ans = iop1;

  00217	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  0021f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  00227	48 8b f8	 mov	 rdi, rax
  0022a	48 8b f1	 mov	 rsi, rcx
  0022d	b9 10 00 00 00	 mov	 ecx, 16
  00232	f3 a4		 rep movsb
  00234	e9 c8 00 00 00	 jmp	 $LN13@s370_multi
$LN12@s370_multi:

; 3985 :     else
; 3986 :     {
; 3987 :         iop2 = f64_to_f128( op2 );

  00239	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  0023e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  00243	e8 00 00 00 00	 call	 f64_to_f128
  00248	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  00250	48 8b f9	 mov	 rdi, rcx
  00253	48 8b f0	 mov	 rsi, rax
  00256	b9 10 00 00 00	 mov	 ecx, 16
  0025b	f3 a4		 rep movsb

; 3988 : 
; 3989 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0025d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00262	8b c0		 mov	 eax, eax
  00264	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00273	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00277	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027b	83 e0 10	 and	 eax, 16
  0027e	85 c0		 test	 eax, eax
  00280	74 1f		 je	 SHORT $LN14@s370_multi

; 3990 :             ans = iop2;

  00282	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  0028a	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  00292	48 8b f8	 mov	 rdi, rax
  00295	48 8b f1	 mov	 rsi, rcx
  00298	b9 10 00 00 00	 mov	 ecx, 16
  0029d	f3 a4		 rep movsb
  0029f	eb 60		 jmp	 SHORT $LN15@s370_multi
$LN14@s370_multi:

; 3991 :         else
; 3992 :             ans = f128_mul( iop1, iop2 );

  002a1	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  002a6	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  002ae	48 8b f8	 mov	 rdi, rax
  002b1	48 8b f1	 mov	 rsi, rcx
  002b4	b9 10 00 00 00	 mov	 ecx, 16
  002b9	f3 a4		 rep movsb
  002bb	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  002c0	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  002c8	48 8b f8	 mov	 rdi, rax
  002cb	48 8b f1	 mov	 rsi, rcx
  002ce	b9 10 00 00 00	 mov	 ecx, 16
  002d3	f3 a4		 rep movsb
  002d5	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  002da	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  002df	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  002e7	e8 00 00 00 00	 call	 f128_mul
  002ec	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  002f4	48 8b f9	 mov	 rdi, rcx
  002f7	48 8b f0	 mov	 rsi, rax
  002fa	b9 10 00 00 00	 mov	 ecx, 16
  002ff	f3 a4		 rep movsb
$LN15@s370_multi:
$LN13@s370_multi:

; 3993 :     }
; 3994 : 
; 3995 :     if (softfloat_exceptionFlags)

  00301	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00306	8b c0		 mov	 eax, eax
  00308	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00317	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031f	85 c0		 test	 eax, eax
  00321	0f 84 ad 00 00
	00		 je	 $LN16@s370_multi

; 3996 :     {
; 3997 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00327	33 c0		 xor	 eax, eax
  00329	83 f8 01	 cmp	 eax, 1
  0032c	74 4b		 je	 SHORT $LN17@s370_multi
  0032e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00333	8b c0		 mov	 eax, eax
  00335	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0033b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00344	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00348	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034c	83 e0 10	 and	 eax, 16
  0034f	85 c0		 test	 eax, eax
  00351	74 26		 je	 SHORT $LN17@s370_multi
  00353	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00361	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00366	85 c0		 test	 eax, eax
  00368	74 0f		 je	 SHORT $LN17@s370_multi
  0036a	b2 80		 mov	 dl, 128			; 00000080H
  0036c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00374	e8 00 00 00 00	 call	 ieee_trap
$LN17@s370_multi:

; 3998 :         SET_FPC_FLAGS_FROM_SF( regs );

  00379	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0037e	8b c0		 mov	 eax, eax
  00380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00386	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	c1 e0 13	 shl	 eax, 19
  0039a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a2	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003a8	c1 e9 08	 shr	 ecx, 8
  003ab	f7 d1		 not	 ecx
  003ad	23 c1		 and	 eax, ecx
  003af	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  003b4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bc	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  003c2	0b c8		 or	 ecx, eax
  003c4	8b c1		 mov	 eax, ecx
  003c6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ce	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN16@s370_multi:

; 3999 :     }
; 4000 : 
; 4001 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  003d4	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  003d8	d1 e0		 shl	 eax, 1
  003da	48 98		 cdqe
  003dc	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003ec	48 8b d0	 mov	 rdx, rax
  003ef	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  003f7	e8 00 00 00 00	 call	 s370_put_float128

; 4002 : }

  003fc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00404	48 33 cc	 xor	 rcx, rsp
  00407	e8 00 00 00 00	 call	 __security_check_cookie
  0040c	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00413	5f		 pop	 rdi
  00414	5e		 pop	 rsi
  00415	c3		 ret	 0
s370_multiply_bfp_long_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
r1$ = 44
x2$ = 48
op1$ = 56
op2$ = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
ans$ = 160
iop2$ = 176
iop1$ = 192
__$ArrayPad$ = 208
inst$ = 256
regs$ = 264
s370_multiply_bfp_long_to_ext PROC

; 4012 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4013 :     int         r1, x2, b2;
; 4014 :     VADR        effective_addr2;
; 4015 :     float64_t   op1, op2;
; 4016 :     float128_t  iop1, iop2, ans;
; 4017 : 
; 4018 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00025	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 _byteswap_ulong
  00039	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003d	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00041	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00046	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 10	 shr	 eax, 16
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00058	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 14	 shr	 eax, 20
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00066	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006b	74 20		 je	 SHORT $LN5@s370_multi
  0006d	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00072	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00085	03 c8		 add	 ecx, eax
  00087	8b c1		 mov	 eax, ecx
  00089	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_multi:
  0008d	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00091	c1 e8 0c	 shr	 eax, 12
  00094	83 e0 0f	 and	 eax, 15
  00097	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0009b	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a0	74 20		 je	 SHORT $LN6@s370_multi
  000a2	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b6	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ba	03 c8		 add	 ecx, eax
  000bc	8b c1		 mov	 eax, ecx
  000be	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_multi:
  000c2	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000cb	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_multi:
  000cf	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000db	48 83 c0 06	 add	 rax, 6
  000df	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000eb	33 c0		 xor	 eax, eax
  000ed	83 f8 06	 cmp	 eax, 6
  000f0	74 0f		 je	 SHORT $LN7@s370_multi
  000f2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_multi:
  00101	33 c0		 xor	 eax, eax
  00103	85 c0		 test	 eax, eax
  00105	75 c8		 jne	 SHORT $LN4@s370_multi

; 4019 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4020 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4021 :     BFPINST_CHECK( regs );

  00107	b8 08 00 00 00	 mov	 eax, 8
  0010c	48 6b c0 01	 imul	 rax, rax, 1
  00110	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011f	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00124	85 c0		 test	 eax, eax
  00126	74 3f		 je	 SHORT $LN9@s370_multi
  00128	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00130	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00136	d1 e8		 shr	 eax, 1
  00138	83 e0 01	 and	 eax, 1
  0013b	85 c0		 test	 eax, eax
  0013d	74 55		 je	 SHORT $LN8@s370_multi
  0013f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00147	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014e	b9 08 00 00 00	 mov	 ecx, 8
  00153	48 6b c9 01	 imul	 rcx, rcx, 1
  00157	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00163	85 c0		 test	 eax, eax
  00165	75 2d		 jne	 SHORT $LN8@s370_multi
$LN9@s370_multi:
  00167	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016f	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00179	ba 07 00 00 00	 mov	 edx, 7
  0017e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_multi:

; 4022 :     BFPREGPAIR_CHECK( r1, regs );

  00194	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00198	83 e0 02	 and	 eax, 2
  0019b	85 c0		 test	 eax, eax
  0019d	74 1b		 je	 SHORT $LN10@s370_multi
  0019f	ba 06 00 00 00	 mov	 edx, 6
  001a4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ac	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_multi:

; 4023 : 
; 4024 :     GET_FLOAT64_OP( op1, r1, regs );

  001ba	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001be	d1 e0		 shl	 eax, 1
  001c0	48 98		 cdqe
  001c2	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  001da	e8 00 00 00 00	 call	 s370_get_float64

; 4025 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001df	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e7	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001eb	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001ef	e8 00 00 00 00	 call	 s370_vfetch8
  001f4	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 4026 : 
; 4027 :     /* f64_to_f128 will, if presented with a SNaN, convert it to quiet
; 4028 :        and raise softfloat_flags_invalid.  Unfortunately, if one of
; 4029 :        the operands is an SNaN and the other a QNaN, f128_mul() will
; 4030 :        be unable to do NaN propagation correctly because it will see
; 4031 :        only two QNaNs.  So if we encounter an SNaN while upconverting
; 4032 :        the input operands, that becomes the answer.  If both operands
; 4033 :        are QNaNs, then f128_mul() will be able to do NaN propagation correctly.
; 4034 :     */
; 4035 :     softfloat_exceptionFlags = 0;

  001f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001fe	8b c0		 mov	 eax, eax
  00200	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00206	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0020f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00213	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4036 :     softfloat_roundingMode = softfloat_round_near_even;

  00217	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0021c	8b c0		 mov	 eax, eax
  0021e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00224	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0022d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00231	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4037 : 
; 4038 :     iop1 = f64_to_f128( op1 );

  00235	48 8b 54 24 38	 mov	 rdx, QWORD PTR op1$[rsp]
  0023a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  0023f	e8 00 00 00 00	 call	 f64_to_f128
  00244	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  0024c	48 8b f9	 mov	 rdi, rcx
  0024f	48 8b f0	 mov	 rsi, rax
  00252	b9 10 00 00 00	 mov	 ecx, 16
  00257	f3 a4		 rep movsb

; 4039 : 
; 4040 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00259	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0025e	8b c0		 mov	 eax, eax
  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00266	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0026f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00273	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00277	83 e0 10	 and	 eax, 16
  0027a	85 c0		 test	 eax, eax
  0027c	74 22		 je	 SHORT $LN11@s370_multi

; 4041 :         ans = iop1;

  0027e	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  00286	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  0028e	48 8b f8	 mov	 rdi, rax
  00291	48 8b f1	 mov	 rsi, rcx
  00294	b9 10 00 00 00	 mov	 ecx, 16
  00299	f3 a4		 rep movsb
  0029b	e9 cb 00 00 00	 jmp	 $LN12@s370_multi
$LN11@s370_multi:

; 4042 :     else
; 4043 :     {
; 4044 :         iop2 = f64_to_f128( op2 );

  002a0	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  002a5	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  002ad	e8 00 00 00 00	 call	 f64_to_f128
  002b2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  002ba	48 8b f9	 mov	 rdi, rcx
  002bd	48 8b f0	 mov	 rsi, rax
  002c0	b9 10 00 00 00	 mov	 ecx, 16
  002c5	f3 a4		 rep movsb

; 4045 : 
; 4046 :         if (softfloat_exceptionFlags & softfloat_flag_invalid)

  002c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002cc	8b c0		 mov	 eax, eax
  002ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e5	83 e0 10	 and	 eax, 16
  002e8	85 c0		 test	 eax, eax
  002ea	74 1f		 je	 SHORT $LN13@s370_multi

; 4047 :             ans = iop2;

  002ec	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR ans$[rsp]
  002f4	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  002fc	48 8b f8	 mov	 rdi, rax
  002ff	48 8b f1	 mov	 rsi, rcx
  00302	b9 10 00 00 00	 mov	 ecx, 16
  00307	f3 a4		 rep movsb
  00309	eb 60		 jmp	 SHORT $LN14@s370_multi
$LN13@s370_multi:

; 4048 :         else
; 4049 :             ans = f128_mul( iop1, iop2 );

  0030b	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  00310	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR iop2$[rsp]
  00318	48 8b f8	 mov	 rdi, rax
  0031b	48 8b f1	 mov	 rsi, rcx
  0031e	b9 10 00 00 00	 mov	 ecx, 16
  00323	f3 a4		 rep movsb
  00325	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  0032a	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR iop1$[rsp]
  00332	48 8b f8	 mov	 rdi, rax
  00335	48 8b f1	 mov	 rsi, rcx
  00338	b9 10 00 00 00	 mov	 ecx, 16
  0033d	f3 a4		 rep movsb
  0033f	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  00344	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  00349	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00351	e8 00 00 00 00	 call	 f128_mul
  00356	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0035e	48 8b f9	 mov	 rdi, rcx
  00361	48 8b f0	 mov	 rsi, rax
  00364	b9 10 00 00 00	 mov	 ecx, 16
  00369	f3 a4		 rep movsb
$LN14@s370_multi:
$LN12@s370_multi:

; 4050 :     }
; 4051 : 
; 4052 :     if (softfloat_exceptionFlags)

  0036b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00370	8b c0		 mov	 eax, eax
  00372	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00378	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00381	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00385	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00389	85 c0		 test	 eax, eax
  0038b	0f 84 ad 00 00
	00		 je	 $LN15@s370_multi

; 4053 :     {
; 4054 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00391	33 c0		 xor	 eax, eax
  00393	83 f8 01	 cmp	 eax, 1
  00396	74 4b		 je	 SHORT $LN16@s370_multi
  00398	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0039d	8b c0		 mov	 eax, eax
  0039f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003ae	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b6	83 e0 10	 and	 eax, 16
  003b9	85 c0		 test	 eax, eax
  003bb	74 26		 je	 SHORT $LN16@s370_multi
  003bd	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c5	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003cb	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003d0	85 c0		 test	 eax, eax
  003d2	74 0f		 je	 SHORT $LN16@s370_multi
  003d4	b2 80		 mov	 dl, 128			; 00000080H
  003d6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003de	e8 00 00 00 00	 call	 ieee_trap
$LN16@s370_multi:

; 4055 :         SET_FPC_FLAGS_FROM_SF( regs );

  003e3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003e8	8b c0		 mov	 eax, eax
  003ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003f0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003f9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003fd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00401	c1 e0 13	 shl	 eax, 19
  00404	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040c	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00412	c1 e9 08	 shr	 ecx, 8
  00415	f7 d1		 not	 ecx
  00417	23 c1		 and	 eax, ecx
  00419	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0041e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00426	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0042c	0b c8		 or	 ecx, eax
  0042e	8b c1		 mov	 eax, ecx
  00430	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00438	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN15@s370_multi:

; 4056 :     }
; 4057 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  0043e	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00442	d1 e0		 shl	 eax, 1
  00444	48 98		 cdqe
  00446	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00456	48 8b d0	 mov	 rdx, rax
  00459	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00461	e8 00 00 00 00	 call	 s370_put_float128

; 4058 : }

  00466	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0046e	48 33 cc	 xor	 rcx, rsp
  00471	e8 00 00 00 00	 call	 __security_check_cookie
  00476	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0047d	5f		 pop	 rdi
  0047e	5e		 pop	 rsi
  0047f	c3		 ret	 0
s370_multiply_bfp_long_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv194 = 40
r1$ = 44
r2$ = 48
ans$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
s370_multiply_bfp_long_reg PROC

; 4064 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4065 :     int        r1, r2;
; 4066 :     float64_t  op1, op2, ans;
; 4067 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4068 : 
; 4069 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@s370_multi
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_multi

; 4070 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4071 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN10@s370_multi
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN9@s370_multi
  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:
$LN7@s370_multi:

; 4072 : 
; 4073 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float64
  00111	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s370_get_float64
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s370_multi

; 4074 : 
; 4075 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4076 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4077 : 
; 4078 :     ans = f64_mul( op1, op2 );

  00191	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00196	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 f64_mul
  001a0	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 4079 : 
; 4080 :     if (softfloat_exceptionFlags)

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 94 00 00
	00		 je	 $LN11@s370_multi

; 4081 :     {
; 4082 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001cb	33 c0		 xor	 eax, eax
  001cd	83 f8 01	 cmp	 eax, 1
  001d0	74 45		 je	 SHORT $LN12@s370_multi
  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	83 e0 10	 and	 eax, 16
  001f3	85 c0		 test	 eax, eax
  001f5	74 20		 je	 SHORT $LN12@s370_multi
  001f7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00202	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00207	85 c0		 test	 eax, eax
  00209	74 0c		 je	 SHORT $LN12@s370_multi
  0020b	b2 80		 mov	 dl, 128			; 00000080H
  0020d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_multi:

; 4083 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00217	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00221	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4084 : 
; 4085 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00225	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00229	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022e	85 c0		 test	 eax, eax
  00230	74 2d		 je	 SHORT $LN13@s370_multi

; 4086 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00232	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00236	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0023b	85 c0		 test	 eax, eax
  0023d	74 0a		 je	 SHORT $LN16@s370_multi
  0023f	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv194[rsp], -1536 ; fffffffffffffa00H
  00247	eb 08		 jmp	 SHORT $LN17@s370_multi
$LN16@s370_multi:
  00249	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv194[rsp], 1536 ; 00000600H
$LN17@s370_multi:
  00251	8b 4c 24 28	 mov	 ecx, DWORD PTR tv194[rsp]
  00255	e8 00 00 00 00	 call	 f64_scaledResult
  0025a	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN13@s370_multi:
$LN11@s370_multi:

; 4087 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4088 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4089 :     }
; 4090 : 
; 4091 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  0025f	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00263	d1 e0		 shl	 eax, 1
  00265	48 98		 cdqe
  00267	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00274	48 8b d0	 mov	 rdx, rax
  00277	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  0027c	e8 00 00 00 00	 call	 s370_put_float64

; 4092 : 
; 4093 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00281	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00285	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0028a	85 c0		 test	 eax, eax
  0028c	74 0e		 je	 SHORT $LN14@s370_multi
  0028e	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00292	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00297	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_multi:

; 4094 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4095 : }

  0029c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002a0	c3		 ret	 0
s370_multiply_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv210 = 52
r1$ = 56
ans$ = 64
op2$ = 72
op1$ = 80
inst$ = 112
regs$ = 120
s370_multiply_bfp_long PROC

; 4101 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4102 :     int        r1, x2, b2;
; 4103 :     VADR       effective_addr2;
; 4104 :     float64_t  op1, op2, ans;
; 4105 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4106 : 
; 4107 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_multi
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_multi:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_multi
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_multi:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000ae	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_multi:
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f8 06	 cmp	 eax, 6
  000d2	74 0c		 je	 SHORT $LN7@s370_multi
  000d4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_multi:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d1		 jne	 SHORT $LN4@s370_multi

; 4108 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4109 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4110 :     BFPINST_CHECK( regs );

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	74 39		 je	 SHORT $LN9@s370_multi
  00104	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010f	d1 e8		 shr	 eax, 1
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 49		 je	 SHORT $LN8@s370_multi
  00118	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00124	b9 08 00 00 00	 mov	 ecx, 8
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	75 24		 jne	 SHORT $LN8@s370_multi
$LN9@s370_multi:
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014c	ba 07 00 00 00	 mov	 edx, 7
  00151	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_multi:

; 4111 : 
; 4112 :     GET_FLOAT64_OP( op1, r1, regs );

  00161	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00165	d1 e0		 shl	 eax, 1
  00167	48 98		 cdqe
  00169	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00176	48 8b d0	 mov	 rdx, rax
  00179	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0017e	e8 00 00 00 00	 call	 s370_get_float64

; 4113 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00183	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00188	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0018c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00190	e8 00 00 00 00	 call	 s370_vfetch8
  00195	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 4114 : 
; 4115 :     softfloat_exceptionFlags = 0;

  0019a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019f	8b c0		 mov	 eax, eax
  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4116 :     SET_SF_RM_FROM_FPC;

  001b8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c3	83 e0 07	 and	 eax, 7
  001c6	8b c0		 mov	 eax, eax
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001cf	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001d4	8b d2		 mov	 edx, edx
  001d6	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001dd	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001e6	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001ea	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ee	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4117 : 
; 4118 :     ans = f64_mul( op1, op2 );

  001f2	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  001f7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op1$[rsp]
  001fc	e8 00 00 00 00	 call	 f64_mul
  00201	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 4119 : 
; 4120 :     if (softfloat_exceptionFlags)

  00206	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020b	8b c0		 mov	 eax, eax
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00213	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00220	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00224	85 c0		 test	 eax, eax
  00226	0f 84 94 00 00
	00		 je	 $LN10@s370_multi

; 4121 :     {
; 4122 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0022c	33 c0		 xor	 eax, eax
  0022e	83 f8 01	 cmp	 eax, 1
  00231	74 45		 je	 SHORT $LN11@s370_multi
  00233	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00238	8b c0		 mov	 eax, eax
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00240	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00249	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00251	83 e0 10	 and	 eax, 16
  00254	85 c0		 test	 eax, eax
  00256	74 20		 je	 SHORT $LN11@s370_multi
  00258	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0025d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00263	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00268	85 c0		 test	 eax, eax
  0026a	74 0c		 je	 SHORT $LN11@s370_multi
  0026c	b2 80		 mov	 dl, 128			; 00000080H
  0026e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_multi:

; 4123 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00278	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00282	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4124 : 
; 4125 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00286	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0028a	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0028f	85 c0		 test	 eax, eax
  00291	74 2d		 je	 SHORT $LN12@s370_multi

; 4126 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00293	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00297	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0029c	85 c0		 test	 eax, eax
  0029e	74 0a		 je	 SHORT $LN15@s370_multi
  002a0	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv210[rsp], -1536 ; fffffffffffffa00H
  002a8	eb 08		 jmp	 SHORT $LN16@s370_multi
$LN15@s370_multi:
  002aa	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv210[rsp], 1536 ; 00000600H
$LN16@s370_multi:
  002b2	8b 4c 24 34	 mov	 ecx, DWORD PTR tv210[rsp]
  002b6	e8 00 00 00 00	 call	 f64_scaledResult
  002bb	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN12@s370_multi:
$LN10@s370_multi:

; 4127 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4128 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4129 :     }
; 4130 : 
; 4131 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  002c0	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002c4	d1 e0		 shl	 eax, 1
  002c6	48 98		 cdqe
  002c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d5	48 8b d0	 mov	 rdx, rax
  002d8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  002dd	e8 00 00 00 00	 call	 s370_put_float64

; 4132 : 
; 4133 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002e2	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e6	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002eb	85 c0		 test	 eax, eax
  002ed	74 0e		 je	 SHORT $LN13@s370_multi
  002ef	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f8	e8 00 00 00 00	 call	 ieee_cond_trap
$LN13@s370_multi:

; 4134 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4135 : }

  002fd	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00301	c3		 ret	 0
s370_multiply_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv203 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
ans$ = 128
op2$ = 144
op1$ = 160
__$ArrayPad$ = 176
inst$ = 224
regs$ = 232
s370_multiply_bfp_ext_reg PROC

; 3916 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3917 :     int         r1, r2;
; 3918 :     float128_t  op1, op2, ans;
; 3919 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3920 : 
; 3921 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  0005f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN8@s370_multi
  00082	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@s370_multi

; 3922 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3923 :     BFPINST_CHECK( regs );

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 3f		 je	 SHORT $LN10@s370_multi
  000b8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c6	d1 e8		 shr	 eax, 1
  000c8	83 e0 01	 and	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 55		 je	 SHORT $LN9@s370_multi
  000cf	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	b9 08 00 00 00	 mov	 ecx, 8
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ee	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f3	85 c0		 test	 eax, eax
  000f5	75 2d		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000f7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00109	ba 07 00 00 00	 mov	 edx, 7
  0010e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:

; 3924 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00124	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN12@s370_multi
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 02	 and	 eax, 2
  00136	85 c0		 test	 eax, eax
  00138	74 1b		 je	 SHORT $LN11@s370_multi
$LN12@s370_multi:
  0013a	ba 06 00 00 00	 mov	 edx, 6
  0013f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_multi:
$LN7@s370_multi:

; 3925 : 
; 3926 :     GET_FLOAT128_OPS(op1, r1, op2, r2, regs);

  00155	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00159	d1 e0		 shl	 eax, 1
  0015b	48 98		 cdqe
  0015d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00178	e8 00 00 00 00	 call	 s370_get_float128
  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00181	d1 e0		 shl	 eax, 1
  00183	48 98		 cdqe
  00185	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001a0	e8 00 00 00 00	 call	 s370_get_float128
  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 aa		 jne	 SHORT $LN7@s370_multi

; 3927 : 
; 3928 :     softfloat_exceptionFlags = 0;

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b0	8b c0		 mov	 eax, eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3929 :     SET_SF_RM_FROM_FPC;

  001c9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d7	83 e0 07	 and	 eax, 7
  001da	8b c0		 mov	 eax, eax
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001e8	8b d2		 mov	 edx, edx
  001ea	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001f1	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001fa	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00202	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3930 : 
; 3931 :     ans = f128_mul( op1, op2 );

  00206	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0020b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  00213	48 8b f8	 mov	 rdi, rax
  00216	48 8b f1	 mov	 rsi, rcx
  00219	b9 10 00 00 00	 mov	 ecx, 16
  0021e	f3 a4		 rep movsb
  00220	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00225	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  0022d	48 8b f8	 mov	 rdi, rax
  00230	48 8b f1	 mov	 rsi, rcx
  00233	b9 10 00 00 00	 mov	 ecx, 16
  00238	f3 a4		 rep movsb
  0023a	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  0023f	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  00244	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  00249	e8 00 00 00 00	 call	 f128_mul
  0024e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00256	48 8b f9	 mov	 rdi, rcx
  00259	48 8b f0	 mov	 rsi, rax
  0025c	b9 10 00 00 00	 mov	 ecx, 16
  00261	f3 a4		 rep movsb

; 3932 : 
; 3933 :     if (softfloat_exceptionFlags)

  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	85 c0		 test	 eax, eax
  00283	0f 84 b2 00 00
	00		 je	 $LN13@s370_multi

; 3934 :     {
; 3935 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00289	33 c0		 xor	 eax, eax
  0028b	83 f8 01	 cmp	 eax, 1
  0028e	74 4b		 je	 SHORT $LN14@s370_multi
  00290	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00295	8b c0		 mov	 eax, eax
  00297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ae	83 e0 10	 and	 eax, 16
  002b1	85 c0		 test	 eax, eax
  002b3	74 26		 je	 SHORT $LN14@s370_multi
  002b5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002c8	85 c0		 test	 eax, eax
  002ca	74 0f		 je	 SHORT $LN14@s370_multi
  002cc	b2 80		 mov	 dl, 128			; 00000080H
  002ce	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_multi:

; 3936 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002db	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002e8	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3937 : 
; 3938 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ec	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002f5	85 c0		 test	 eax, eax
  002f7	74 42		 je	 SHORT $LN15@s370_multi

; 3939 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002f9	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002fd	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00302	85 c0		 test	 eax, eax
  00304	74 0a		 je	 SHORT $LN18@s370_multi
  00306	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv203[rsp], -24576 ; ffffffffffffa000H
  0030e	eb 08		 jmp	 SHORT $LN19@s370_multi
$LN18@s370_multi:
  00310	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv203[rsp], 24576 ; 00006000H
$LN19@s370_multi:
  00318	8b 54 24 30	 mov	 edx, DWORD PTR tv203[rsp]
  0031c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  00321	e8 00 00 00 00	 call	 f128_scaledResult
  00326	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0032e	48 8b f9	 mov	 rdi, rcx
  00331	48 8b f0	 mov	 rsi, rax
  00334	b9 10 00 00 00	 mov	 ecx, 16
  00339	f3 a4		 rep movsb
$LN15@s370_multi:
$LN13@s370_multi:

; 3940 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 3941 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 3942 :     }
; 3943 : 
; 3944 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  0033b	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0033f	d1 e0		 shl	 eax, 1
  00341	48 98		 cdqe
  00343	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00353	48 8b d0	 mov	 rdx, rax
  00356	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  0035e	e8 00 00 00 00	 call	 s370_put_float128

; 3945 : 
; 3946 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00363	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00367	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0036c	85 c0		 test	 eax, eax
  0036e	74 11		 je	 SHORT $LN16@s370_multi
  00370	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00374	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037c	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_multi:

; 3947 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3948 : }

  00381	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00389	48 33 cc	 xor	 rcx, rsp
  0038c	e8 00 00 00 00	 call	 __security_check_cookie
  00391	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00398	5f		 pop	 rdi
  00399	5e		 pop	 rsi
  0039a	c3		 ret	 0
s370_multiply_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv205 = 40
r1$ = 44
ans$ = 48
r3$ = 52
r2$ = 56
op1$ = 60
op3$ = 64
op2$ = 68
inst$ = 96
regs$ = 104
s370_multiply_add_bfp_short_reg PROC

; 4405 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4406 :     int        r1, r2, r3;
; 4407 :     float32_t  op1, op2, op3, ans;
; 4408 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4409 : 
; 4410 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN8@s370_multi
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@s370_multi

; 4411 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4412 :     BFPINST_CHECK( regs );

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00096	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009b	85 c0		 test	 eax, eax
  0009d	74 39		 je	 SHORT $LN10@s370_multi
  0009f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000aa	d1 e8		 shr	 eax, 1
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 49		 je	 SHORT $LN9@s370_multi
  000b3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000d4	85 c0		 test	 eax, eax
  000d6	75 24		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000d8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e7	ba 07 00 00 00	 mov	 edx, 7
  000ec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:
$LN7@s370_multi:

; 4413 : 
; 4414 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  000fc	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00100	d1 e0		 shl	 eax, 1
  00102	48 98		 cdqe
  00104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  00119	e8 00 00 00 00	 call	 s370_get_float32
  0011e	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op3$[rsp]
  0013b	e8 00 00 00 00	 call	 s370_get_float32
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 b6		 jne	 SHORT $LN7@s370_multi

; 4415 :     GET_FLOAT32_OP( op2, r2, regs );

  00146	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  0014a	d1 e0		 shl	 eax, 1
  0014c	48 98		 cdqe
  0014e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op2$[rsp]
  00163	e8 00 00 00 00	 call	 s370_get_float32

; 4416 : 
; 4417 :     softfloat_exceptionFlags = 0;

  00168	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016d	8b c0		 mov	 eax, eax
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00175	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00182	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4418 :     SET_SF_RM_FROM_FPC;

  00186	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00191	83 e0 07	 and	 eax, 7
  00194	8b c0		 mov	 eax, eax
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0019d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001a2	8b d2		 mov	 edx, edx
  001a4	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001ab	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001b4	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001bc	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4419 : 
; 4420 :     ans = f32_mulAdd( op2, op3, op1 );

  001c0	44 8b 44 24 3c	 mov	 r8d, DWORD PTR op1$[rsp]
  001c5	8b 54 24 40	 mov	 edx, DWORD PTR op3$[rsp]
  001c9	8b 4c 24 44	 mov	 ecx, DWORD PTR op2$[rsp]
  001cd	e8 00 00 00 00	 call	 f32_mulAdd
  001d2	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 4421 : 
; 4422 :     if (softfloat_exceptionFlags)

  001d6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001db	8b c0		 mov	 eax, eax
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ec	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f4	85 c0		 test	 eax, eax
  001f6	0f 84 93 00 00
	00		 je	 $LN11@s370_multi

; 4423 :     {
; 4424 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001fc	33 c0		 xor	 eax, eax
  001fe	83 f8 01	 cmp	 eax, 1
  00201	74 45		 je	 SHORT $LN12@s370_multi
  00203	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00208	8b c0		 mov	 eax, eax
  0020a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00210	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00219	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00221	83 e0 10	 and	 eax, 16
  00224	85 c0		 test	 eax, eax
  00226	74 20		 je	 SHORT $LN12@s370_multi
  00228	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00233	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0c		 je	 SHORT $LN12@s370_multi
  0023c	b2 80		 mov	 dl, 128			; 00000080H
  0023e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00243	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_multi:

; 4425 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00248	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0024d	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00252	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4426 : 
; 4427 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00256	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0025a	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0025f	85 c0		 test	 eax, eax
  00261	74 2c		 je	 SHORT $LN13@s370_multi

; 4428 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00263	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00267	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0026c	85 c0		 test	 eax, eax
  0026e	74 0a		 je	 SHORT $LN16@s370_multi
  00270	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv205[rsp], -192 ; ffffffffffffff40H
  00278	eb 08		 jmp	 SHORT $LN17@s370_multi
$LN16@s370_multi:
  0027a	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv205[rsp], 192 ; 000000c0H
$LN17@s370_multi:
  00282	8b 4c 24 28	 mov	 ecx, DWORD PTR tv205[rsp]
  00286	e8 00 00 00 00	 call	 f32_scaledResult
  0028b	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN13@s370_multi:
$LN11@s370_multi:

; 4429 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4430 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4431 :     }
; 4432 : 
; 4433 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  0028f	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00293	d1 e0		 shl	 eax, 1
  00295	48 98		 cdqe
  00297	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002a4	48 8b d0	 mov	 rdx, rax
  002a7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  002ac	e8 00 00 00 00	 call	 s370_put_float32

; 4434 : 
; 4435 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002b1	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b5	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002ba	85 c0		 test	 eax, eax
  002bc	74 0e		 je	 SHORT $LN14@s370_multi
  002be	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c7	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_multi:

; 4436 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4437 : }

  002cc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d0	c3		 ret	 0
s370_multiply_add_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv223 = 52
r1$ = 56
ans$ = 60
r3$ = 64
op1$ = 68
op3$ = 72
op2$ = 76
inst$ = 96
regs$ = 104
s370_multiply_add_bfp_short PROC

; 4443 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4444 :     int        x2, r1, r3, b2;
; 4445 :     VADR       effective_addr2;
; 4446 :     float32_t  op1, op2, op3, ans;
; 4447 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4448 : 
; 4449 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 04	 imul	 rax, rax, 4
  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	c1 f8 04	 sar	 eax, 4
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 10	 shr	 eax, 16
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0005f	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 14	 shr	 eax, 20
  00066	83 e0 0f	 and	 eax, 15
  00069	89 44 24 40	 mov	 DWORD PTR r3$[rsp], eax
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00072	74 1d		 je	 SHORT $LN8@s370_multi
  00074	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00079	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00085	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00089	03 c8		 add	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_multi:
  00091	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00095	c1 e8 0c	 shr	 eax, 12
  00098	83 e0 0f	 and	 eax, 15
  0009b	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0009f	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a4	74 1d		 je	 SHORT $LN9@s370_multi
  000a6	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bb	03 c8		 add	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_multi:
  000c3	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000cc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_multi:
  000d0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e2	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e6	33 c0		 xor	 eax, eax
  000e8	83 f8 06	 cmp	 eax, 6
  000eb	74 0c		 je	 SHORT $LN10@s370_multi
  000ed	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_multi:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 d1		 jne	 SHORT $LN4@s370_multi

; 4450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4451 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4452 :     BFPINST_CHECK( regs );

  000ff	b8 08 00 00 00	 mov	 eax, 8
  00104	48 6b c0 01	 imul	 rax, rax, 1
  00108	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0010d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00114	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00119	85 c0		 test	 eax, eax
  0011b	74 39		 je	 SHORT $LN12@s370_multi
  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00122	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00128	d1 e8		 shr	 eax, 1
  0012a	83 e0 01	 and	 eax, 1
  0012d	85 c0		 test	 eax, eax
  0012f	74 49		 je	 SHORT $LN11@s370_multi
  00131	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00136	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013d	b9 08 00 00 00	 mov	 ecx, 8
  00142	48 6b c9 01	 imul	 rcx, rcx, 1
  00146	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0014d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00152	85 c0		 test	 eax, eax
  00154	75 24		 jne	 SHORT $LN11@s370_multi
$LN12@s370_multi:
  00156	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00165	ba 07 00 00 00	 mov	 edx, 7
  0016a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0016f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00174	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_multi:
$LN7@s370_multi:

; 4453 : 
; 4454 :     GET_FLOAT32_OPS( op1, r1, op3, r3, regs );

  0017a	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0017e	d1 e0		 shl	 eax, 1
  00180	48 98		 cdqe
  00182	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0018f	48 8b d0	 mov	 rdx, rax
  00192	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op1$[rsp]
  00197	e8 00 00 00 00	 call	 s370_get_float32
  0019c	8b 44 24 40	 mov	 eax, DWORD PTR r3$[rsp]
  001a0	d1 e0		 shl	 eax, 1
  001a2	48 98		 cdqe
  001a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b1	48 8b d0	 mov	 rdx, rax
  001b4	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  001b9	e8 00 00 00 00	 call	 s370_get_float32
  001be	33 c0		 xor	 eax, eax
  001c0	85 c0		 test	 eax, eax
  001c2	75 b6		 jne	 SHORT $LN7@s370_multi

; 4455 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  001c4	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001c9	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001cd	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001d1	e8 00 00 00 00	 call	 s370_vfetch4
  001d6	89 44 24 4c	 mov	 DWORD PTR op2$[rsp], eax

; 4456 : 
; 4457 :     softfloat_exceptionFlags = 0;

  001da	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001df	8b c0		 mov	 eax, eax
  001e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4458 :     SET_SF_RM_FROM_FPC;

  001f8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00203	83 e0 07	 and	 eax, 7
  00206	8b c0		 mov	 eax, eax
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0020f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00214	8b d2		 mov	 edx, edx
  00216	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0021d	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00226	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0022a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022e	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4459 : 
; 4460 :     ans = f32_mulAdd( op2, op3, op1 );

  00232	44 8b 44 24 44	 mov	 r8d, DWORD PTR op1$[rsp]
  00237	8b 54 24 48	 mov	 edx, DWORD PTR op3$[rsp]
  0023b	8b 4c 24 4c	 mov	 ecx, DWORD PTR op2$[rsp]
  0023f	e8 00 00 00 00	 call	 f32_mulAdd
  00244	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax

; 4461 : 
; 4462 :     if (softfloat_exceptionFlags)

  00248	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0024d	8b c0		 mov	 eax, eax
  0024f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00255	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0025e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00262	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00266	85 c0		 test	 eax, eax
  00268	0f 84 93 00 00
	00		 je	 $LN13@s370_multi

; 4463 :     {
; 4464 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0026e	33 c0		 xor	 eax, eax
  00270	83 f8 01	 cmp	 eax, 1
  00273	74 45		 je	 SHORT $LN14@s370_multi
  00275	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0027a	8b c0		 mov	 eax, eax
  0027c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00282	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0028b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0028f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00293	83 e0 10	 and	 eax, 16
  00296	85 c0		 test	 eax, eax
  00298	74 20		 je	 SHORT $LN14@s370_multi
  0029a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0029f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002a5	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002aa	85 c0		 test	 eax, eax
  002ac	74 0c		 je	 SHORT $LN14@s370_multi
  002ae	b2 80		 mov	 dl, 128			; 00000080H
  002b0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002b5	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_multi:

; 4465 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002c4	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4466 : 
; 4467 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002c8	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cc	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002d1	85 c0		 test	 eax, eax
  002d3	74 2c		 je	 SHORT $LN15@s370_multi

; 4468 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002d5	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002d9	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002de	85 c0		 test	 eax, eax
  002e0	74 0a		 je	 SHORT $LN18@s370_multi
  002e2	c7 44 24 34 40
	ff ff ff	 mov	 DWORD PTR tv223[rsp], -192 ; ffffffffffffff40H
  002ea	eb 08		 jmp	 SHORT $LN19@s370_multi
$LN18@s370_multi:
  002ec	c7 44 24 34 c0
	00 00 00	 mov	 DWORD PTR tv223[rsp], 192 ; 000000c0H
$LN19@s370_multi:
  002f4	8b 4c 24 34	 mov	 ecx, DWORD PTR tv223[rsp]
  002f8	e8 00 00 00 00	 call	 f32_scaledResult
  002fd	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax
$LN15@s370_multi:
$LN13@s370_multi:

; 4469 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 4470 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 4471 :     }
; 4472 : 
; 4473 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  00301	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00305	d1 e0		 shl	 eax, 1
  00307	48 98		 cdqe
  00309	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0030e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00316	48 8b d0	 mov	 rdx, rax
  00319	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR ans$[rsp]
  0031e	e8 00 00 00 00	 call	 s370_put_float32

; 4474 : 
; 4475 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00323	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00327	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0032c	85 c0		 test	 eax, eax
  0032e	74 0e		 je	 SHORT $LN16@s370_multi
  00330	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00334	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00339	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_multi:

; 4476 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4477 : }

  0033e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00342	c3		 ret	 0
s370_multiply_add_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
temp$1 = 36
tv205 = 40
r1$ = 44
r3$ = 48
r2$ = 52
ans$ = 56
op1$ = 64
op3$ = 72
op2$ = 80
inst$ = 112
regs$ = 120
s370_multiply_add_bfp_long_reg PROC

; 4327 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4328 :     int        r1, r2, r3;
; 4329 :     float64_t  op1, op2, op3, ans;
; 4330 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4331 : 
; 4332 :     RRD( inst, regs, r1, r2, r3 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 0c	 shr	 eax, 12
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  00052	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 83 c0 04	 add	 rax, 4
  0005f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00068	33 c0		 xor	 eax, eax
  0006a	83 f8 04	 cmp	 eax, 4
  0006d	74 0c		 je	 SHORT $LN8@s370_multi
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_multi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 d1		 jne	 SHORT $LN4@s370_multi

; 4333 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4334 :     BFPINST_CHECK( regs );

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00096	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009b	85 c0		 test	 eax, eax
  0009d	74 39		 je	 SHORT $LN10@s370_multi
  0009f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000aa	d1 e8		 shr	 eax, 1
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 49		 je	 SHORT $LN9@s370_multi
  000b3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000d4	85 c0		 test	 eax, eax
  000d6	75 24		 jne	 SHORT $LN9@s370_multi
$LN10@s370_multi:
  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e7	ba 07 00 00 00	 mov	 edx, 7
  000ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_multi:
$LN7@s370_multi:

; 4335 : 
; 4336 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  000fc	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00100	d1 e0		 shl	 eax, 1
  00102	48 98		 cdqe
  00104	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00119	e8 00 00 00 00	 call	 s370_get_float64
  0011e	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  00122	d1 e0		 shl	 eax, 1
  00124	48 98		 cdqe
  00126	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op3$[rsp]
  0013b	e8 00 00 00 00	 call	 s370_get_float64
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 b6		 jne	 SHORT $LN7@s370_multi

; 4337 :     GET_FLOAT64_OP( op2, r2, regs );

  00146	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0014a	d1 e0		 shl	 eax, 1
  0014c	48 98		 cdqe
  0014e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  00163	e8 00 00 00 00	 call	 s370_get_float64

; 4338 : 
; 4339 :     softfloat_exceptionFlags = 0;

  00168	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016d	8b c0		 mov	 eax, eax
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00175	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00182	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4340 :     SET_SF_RM_FROM_FPC;

  00186	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00191	83 e0 07	 and	 eax, 7
  00194	8b c0		 mov	 eax, eax
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0019d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001a2	8b d2		 mov	 edx, edx
  001a4	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001ab	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001b4	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001bc	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4341 : 
; 4342 :     ans = f64_mulAdd( op2, op3, op1 );

  001c0	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  001c5	48 8b 54 24 48	 mov	 rdx, QWORD PTR op3$[rsp]
  001ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op2$[rsp]
  001cf	e8 00 00 00 00	 call	 f64_mulAdd
  001d4	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 4343 : 
; 4344 :     if (softfloat_exceptionFlags)

  001d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001de	8b c0		 mov	 eax, eax
  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ef	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f7	85 c0		 test	 eax, eax
  001f9	0f 84 94 00 00
	00		 je	 $LN11@s370_multi

; 4345 :     {
; 4346 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001ff	33 c0		 xor	 eax, eax
  00201	83 f8 01	 cmp	 eax, 1
  00204	74 45		 je	 SHORT $LN12@s370_multi
  00206	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020b	8b c0		 mov	 eax, eax
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00213	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00220	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00224	83 e0 10	 and	 eax, 16
  00227	85 c0		 test	 eax, eax
  00229	74 20		 je	 SHORT $LN12@s370_multi
  0022b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00230	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00236	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0023b	85 c0		 test	 eax, eax
  0023d	74 0c		 je	 SHORT $LN12@s370_multi
  0023f	b2 80		 mov	 dl, 128			; 00000080H
  00241	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_multi:

; 4347 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0024b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00250	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00255	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4348 : 
; 4349 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00259	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0025d	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00262	85 c0		 test	 eax, eax
  00264	74 2d		 je	 SHORT $LN13@s370_multi

; 4350 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00266	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0026a	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0026f	85 c0		 test	 eax, eax
  00271	74 0a		 je	 SHORT $LN16@s370_multi
  00273	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv205[rsp], -1536 ; fffffffffffffa00H
  0027b	eb 08		 jmp	 SHORT $LN17@s370_multi
$LN16@s370_multi:
  0027d	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv205[rsp], 1536 ; 00000600H
$LN17@s370_multi:
  00285	8b 4c 24 28	 mov	 ecx, DWORD PTR tv205[rsp]
  00289	e8 00 00 00 00	 call	 f64_scaledResult
  0028e	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN13@s370_multi:
$LN11@s370_multi:

; 4351 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4352 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4353 :     }
; 4354 : 
; 4355 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00293	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00297	d1 e0		 shl	 eax, 1
  00299	48 98		 cdqe
  0029b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002a8	48 8b d0	 mov	 rdx, rax
  002ab	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  002b0	e8 00 00 00 00	 call	 s370_put_float64

; 4356 : 
; 4357 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002b5	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002b9	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002be	85 c0		 test	 eax, eax
  002c0	74 0e		 je	 SHORT $LN14@s370_multi
  002c2	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_multi:

; 4358 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4359 : }

  002d0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002d4	c3		 ret	 0
s370_multiply_add_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv223 = 52
r1$ = 56
r3$ = 60
ans$ = 64
op1$ = 72
op3$ = 80
op2$ = 88
inst$ = 112
regs$ = 120
s370_multiply_add_bfp_long PROC

; 4365 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4366 :     int        x2, r1, r3, b2;
; 4367 :     VADR       effective_addr2;
; 4368 :     float64_t  op1, op2, op3, ans;
; 4369 :     U32        ieee_trap_conds =0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 4370 : 
; 4371 :     RXF( inst, regs, r1, r3, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 04	 imul	 rax, rax, 4
  00034	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003d	c1 f8 04	 sar	 eax, 4
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 10	 shr	 eax, 16
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0005f	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 14	 shr	 eax, 20
  00066	83 e0 0f	 and	 eax, 15
  00069	89 44 24 3c	 mov	 DWORD PTR r3$[rsp], eax
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00072	74 1d		 je	 SHORT $LN8@s370_multi
  00074	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00079	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00085	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00089	03 c8		 add	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_multi:
  00091	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00095	c1 e8 0c	 shr	 eax, 12
  00098	83 e0 0f	 and	 eax, 15
  0009b	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0009f	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a4	74 1d		 je	 SHORT $LN9@s370_multi
  000a6	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bb	03 c8		 add	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_multi:
  000c3	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000cc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_multi:
  000d0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e2	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e6	33 c0		 xor	 eax, eax
  000e8	83 f8 06	 cmp	 eax, 6
  000eb	74 0c		 je	 SHORT $LN10@s370_multi
  000ed	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_multi:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 d1		 jne	 SHORT $LN4@s370_multi

; 4372 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 4373 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4374 :     BFPINST_CHECK( regs );

  000ff	b8 08 00 00 00	 mov	 eax, 8
  00104	48 6b c0 01	 imul	 rax, rax, 1
  00108	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00114	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00119	85 c0		 test	 eax, eax
  0011b	74 39		 je	 SHORT $LN12@s370_multi
  0011d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00122	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00128	d1 e8		 shr	 eax, 1
  0012a	83 e0 01	 and	 eax, 1
  0012d	85 c0		 test	 eax, eax
  0012f	74 49		 je	 SHORT $LN11@s370_multi
  00131	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00136	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013d	b9 08 00 00 00	 mov	 ecx, 8
  00142	48 6b c9 01	 imul	 rcx, rcx, 1
  00146	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0014d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00152	85 c0		 test	 eax, eax
  00154	75 24		 jne	 SHORT $LN11@s370_multi
$LN12@s370_multi:
  00156	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00165	ba 07 00 00 00	 mov	 edx, 7
  0016a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00174	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_multi:
$LN7@s370_multi:

; 4375 : 
; 4376 :     GET_FLOAT64_OPS( op1, r1, op3, r3, regs );

  0017a	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0017e	d1 e0		 shl	 eax, 1
  00180	48 98		 cdqe
  00182	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0018f	48 8b d0	 mov	 rdx, rax
  00192	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00197	e8 00 00 00 00	 call	 s370_get_float64
  0019c	8b 44 24 3c	 mov	 eax, DWORD PTR r3$[rsp]
  001a0	d1 e0		 shl	 eax, 1
  001a2	48 98		 cdqe
  001a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b1	48 8b d0	 mov	 rdx, rax
  001b4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op3$[rsp]
  001b9	e8 00 00 00 00	 call	 s370_get_float64
  001be	33 c0		 xor	 eax, eax
  001c0	85 c0		 test	 eax, eax
  001c2	75 b6		 jne	 SHORT $LN7@s370_multi

; 4377 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001c4	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001c9	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001cd	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001d1	e8 00 00 00 00	 call	 s370_vfetch8
  001d6	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 4378 : 
; 4379 :     softfloat_exceptionFlags = 0;

  001db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e0	8b c0		 mov	 eax, eax
  001e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 4380 :     SET_SF_RM_FROM_FPC;

  001f9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001fe	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00204	83 e0 07	 and	 eax, 7
  00207	8b c0		 mov	 eax, eax
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00210	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00215	8b d2		 mov	 edx, edx
  00217	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0021e	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00227	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0022b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022f	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 4381 : 
; 4382 :     ans = f64_mulAdd( op2, op3, op1 );

  00233	4c 8b 44 24 48	 mov	 r8, QWORD PTR op1$[rsp]
  00238	48 8b 54 24 50	 mov	 rdx, QWORD PTR op3$[rsp]
  0023d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op2$[rsp]
  00242	e8 00 00 00 00	 call	 f64_mulAdd
  00247	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 4383 : 
; 4384 :     if (softfloat_exceptionFlags)

  0024c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00251	8b c0		 mov	 eax, eax
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00259	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00262	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00266	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026a	85 c0		 test	 eax, eax
  0026c	0f 84 94 00 00
	00		 je	 $LN13@s370_multi

; 4385 :     {
; 4386 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00272	33 c0		 xor	 eax, eax
  00274	83 f8 01	 cmp	 eax, 1
  00277	74 45		 je	 SHORT $LN14@s370_multi
  00279	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0027e	8b c0		 mov	 eax, eax
  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00286	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0028f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00293	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00297	83 e0 10	 and	 eax, 16
  0029a	85 c0		 test	 eax, eax
  0029c	74 20		 je	 SHORT $LN14@s370_multi
  0029e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002a3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002a9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002ae	85 c0		 test	 eax, eax
  002b0	74 0c		 je	 SHORT $LN14@s370_multi
  002b2	b2 80		 mov	 dl, 128			; 00000080H
  002b4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002b9	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_multi:

; 4387 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002c8	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 4388 : 
; 4389 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002cc	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002d0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002d5	85 c0		 test	 eax, eax
  002d7	74 2d		 je	 SHORT $LN15@s370_multi

; 4390 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002d9	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002dd	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002e2	85 c0		 test	 eax, eax
  002e4	74 0a		 je	 SHORT $LN18@s370_multi
  002e6	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv223[rsp], -1536 ; fffffffffffffa00H
  002ee	eb 08		 jmp	 SHORT $LN19@s370_multi
$LN18@s370_multi:
  002f0	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv223[rsp], 1536 ; 00000600H
$LN19@s370_multi:
  002f8	8b 4c 24 34	 mov	 ecx, DWORD PTR tv223[rsp]
  002fc	e8 00 00 00 00	 call	 f64_scaledResult
  00301	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN15@s370_multi:
$LN13@s370_multi:

; 4391 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 4392 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 4393 :     }
; 4394 : 
; 4395 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  00306	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0030a	d1 e0		 shl	 eax, 1
  0030c	48 98		 cdqe
  0030e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00313	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0031b	48 8b d0	 mov	 rdx, rax
  0031e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  00323	e8 00 00 00 00	 call	 s370_put_float64

; 4396 : 
; 4397 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00328	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0032c	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00331	85 c0		 test	 eax, eax
  00333	74 0e		 je	 SHORT $LN16@s370_multi
  00335	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00339	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0033e	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_multi:

; 4398 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 4399 : }

  00343	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00347	c3		 ret	 0
s370_multiply_add_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
tv167 = 44
tv256 = 48
r1$ = 52
r2$ = 56
op1$ = 60
op2$ = 64
inst$ = 96
regs$ = 104
s370_load_rounded_bfp_long_to_short_reg PROC

; 3726 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3727 :     int        r1, r2;
; 3728 :     BYTE       m3, m4;
; 3729 :     float64_t  op2;
; 3730 :     float32_t  op1;
; 3731 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3732 : 
; 3733 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_load_:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_load_
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_load_

; 3734 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3735 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_load_
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_load_
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3736 : 
; 3737 :     GET_FLOAT64_OP( op2, r2, regs );

  0010a	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  0010e	d1 e0		 shl	 eax, 1
  00110	48 98		 cdqe
  00112	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011f	48 8b d0	 mov	 rdx, rax
  00122	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  00127	e8 00 00 00 00	 call	 s370_get_float64

; 3738 : 
; 3739 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3740 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0012c	b8 01 00 00 00	 mov	 eax, 1
  00131	48 6b c0 04	 imul	 rax, rax, 4
  00135	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00142	83 e0 04	 and	 eax, 4
  00145	85 c0		 test	 eax, eax
  00147	74 62		 je	 SHORT $LN8@s370_load_

; 3741 :         SET_SF_RM_FROM_MASK( m3 );

  00149	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0014e	85 c0		 test	 eax, eax
  00150	74 16		 je	 SHORT $LN19@s370_load_
  00152	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0015e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00162	89 44 24 2c	 mov	 DWORD PTR tv167[rsp], eax
  00166	eb 1f		 jmp	 SHORT $LN20@s370_load_
$LN19@s370_load_:
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00173	83 e0 07	 and	 eax, 7
  00176	8b c0		 mov	 eax, eax
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0017f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00183	89 44 24 2c	 mov	 DWORD PTR tv167[rsp], eax
$LN20@s370_load_:
  00187	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0018c	8b c0		 mov	 eax, eax
  0018e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00194	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0019d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001a1	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv167[rsp]
  001a6	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  001a9	eb 61		 jmp	 SHORT $LN9@s370_load_
$LN8@s370_load_:

; 3742 :     else
; 3743 : #endif
; 3744 :     {
; 3745 :         if (m3 || m4)

  001ab	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001b0	85 c0		 test	 eax, eax
  001b2	75 09		 jne	 SHORT $LN11@s370_load_
  001b4	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  001b9	85 c0		 test	 eax, eax
  001bb	74 15		 je	 SHORT $LN10@s370_load_
$LN11@s370_load_:

; 3746 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001bd	ba 06 00 00 00	 mov	 edx, 6
  001c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001cc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_load_:

; 3747 :         SET_SF_RM_FROM_FPC;

  001d2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001dd	83 e0 07	 and	 eax, 7
  001e0	8b c0		 mov	 eax, eax
  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001e9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001ee	8b d2		 mov	 edx, edx
  001f0	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001f7	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00200	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00204	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00208	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al
$LN9@s370_load_:

; 3748 :     }
; 3749 : 
; 3750 :     softfloat_exceptionFlags = 0;

  0020c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00211	8b c0		 mov	 eax, eax
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00219	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00222	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00226	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3751 : 
; 3752 :     op1 = f64_to_f32( op2 );

  0022a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  0022f	e8 00 00 00 00	 call	 f64_to_f32
  00234	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 3753 : 
; 3754 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3755 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00238	b8 01 00 00 00	 mov	 eax, 1
  0023d	48 6b c0 04	 imul	 rax, rax, 4
  00241	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0024e	83 e0 04	 and	 eax, 4
  00251	85 c0		 test	 eax, eax
  00253	74 4d		 je	 SHORT $LN12@s370_load_

; 3756 :     {
; 3757 :         if (SUPPRESS_INEXACT( m4 ))

  00255	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  0025a	83 e0 04	 and	 eax, 4
  0025d	85 c0		 test	 eax, eax
  0025f	74 41		 je	 SHORT $LN13@s370_load_

; 3758 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;

  00261	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00266	8b c0		 mov	 eax, eax
  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00277	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027f	83 e0 fe	 and	 eax, -2
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00288	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00291	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00297	45 8b c0	 mov	 r8d, r8d
  0029a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029e	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN13@s370_load_:
$LN12@s370_load_:

; 3759 :     }
; 3760 : #endif
; 3761 : 
; 3762 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002a2	33 c0		 xor	 eax, eax
  002a4	83 f8 01	 cmp	 eax, 1
  002a7	74 45		 je	 SHORT $LN14@s370_load_
  002a9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002ae	8b c0		 mov	 eax, eax
  002b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002bf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c7	83 e0 10	 and	 eax, 16
  002ca	85 c0		 test	 eax, eax
  002cc	74 20		 je	 SHORT $LN14@s370_load_
  002ce	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002d3	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002d9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002de	85 c0		 test	 eax, eax
  002e0	74 0c		 je	 SHORT $LN14@s370_load_
  002e2	b2 80		 mov	 dl, 128			; 00000080H
  002e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_load_:

; 3763 : 
; 3764 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  002ee	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  002f2	d1 e0		 shl	 eax, 1
  002f4	48 98		 cdqe
  002f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fb	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00303	48 8b d0	 mov	 rdx, rax
  00306	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0030b	e8 00 00 00 00	 call	 s370_put_float32

; 3765 : 
; 3766 :     if (softfloat_exceptionFlags)

  00310	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00315	8b c0		 mov	 eax, eax
  00317	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0031d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00326	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0032a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0032e	85 c0		 test	 eax, eax
  00330	0f 84 85 00 00
	00		 je	 $LN15@s370_load_

; 3767 :     {
; 3768 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00336	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0033b	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00340	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3769 : 
; 3770 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00344	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00348	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0034d	85 c0		 test	 eax, eax
  0034f	74 4f		 je	 SHORT $LN16@s370_load_

; 3771 :         {
; 3772 :             op2 = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00351	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00355	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0035a	85 c0		 test	 eax, eax
  0035c	74 0a		 je	 SHORT $LN21@s370_load_
  0035e	c7 44 24 30 00
	fe ff ff	 mov	 DWORD PTR tv256[rsp], -512 ; fffffffffffffe00H
  00366	eb 08		 jmp	 SHORT $LN22@s370_load_
$LN21@s370_load_:
  00368	c7 44 24 30 00
	02 00 00	 mov	 DWORD PTR tv256[rsp], 512 ; 00000200H
$LN22@s370_load_:
  00370	8b 4c 24 30	 mov	 ecx, DWORD PTR tv256[rsp]
  00374	e8 00 00 00 00	 call	 f64_scaledResult
  00379	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 3773 :                 SCALE_FACTOR_LOADR_OFLOW_LONG :
; 3774 :                 SCALE_FACTOR_LOADR_UFLOW_LONG );
; 3775 : 
; 3776 :             PUT_FLOAT64_NOCC( op2, r1, regs );

  0037e	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00382	d1 e0		 shl	 eax, 1
  00384	48 98		 cdqe
  00386	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0038b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00393	48 8b d0	 mov	 rdx, rax
  00396	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  0039b	e8 00 00 00 00	 call	 s370_put_float64
$LN16@s370_load_:

; 3777 :         }
; 3778 : 
; 3779 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003a0	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003a4	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003a9	85 c0		 test	 eax, eax
  003ab	74 0e		 je	 SHORT $LN17@s370_load_
  003ad	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003b1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b6	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s370_load_:
$LN15@s370_load_:

; 3780 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3781 :     }
; 3782 : }

  003bb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003bf	c3		 ret	 0
s370_load_rounded_bfp_long_to_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
r1$ = 44
r2$ = 48
tv174 = 52
tv263 = 56
op1$ = 60
$T2 = 64
$T3 = 80
op2$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s370_load_rounded_bfp_ext_to_short_reg PROC

; 3853 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3854 :     int         r1, r2;
; 3855 :     BYTE        m3, m4;
; 3856 :     float128_t  op2;
; 3857 :     float32_t   op1;
; 3858 :     U32         ieee_trap_conds = 0;

  00022	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3859 : 
; 3860 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  0004d	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 04	 shr	 eax, 4
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0005b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 08	 shr	 eax, 8
  00062	83 e0 0f	 and	 eax, 15
  00065	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00069	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 0c	 shr	 eax, 12
  00070	83 e0 0f	 and	 eax, 15
  00073	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_load_:
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00083	48 83 c0 04	 add	 rax, 4
  00087	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00093	33 c0		 xor	 eax, eax
  00095	83 f8 04	 cmp	 eax, 4
  00098	74 0f		 je	 SHORT $LN5@s370_load_
  0009a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 c8		 jne	 SHORT $LN4@s370_load_

; 3861 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3862 :     BFPINST_CHECK( regs );

  000af	b8 08 00 00 00	 mov	 eax, 8
  000b4	48 6b c0 01	 imul	 rax, rax, 1
  000b8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c7	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cc	85 c0		 test	 eax, eax
  000ce	74 3f		 je	 SHORT $LN7@s370_load_
  000d0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000de	d1 e8		 shr	 eax, 1
  000e0	83 e0 01	 and	 eax, 1
  000e3	85 c0		 test	 eax, eax
  000e5	74 55		 je	 SHORT $LN6@s370_load_
  000e7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f6	b9 08 00 00 00	 mov	 ecx, 8
  000fb	48 6b c9 01	 imul	 rcx, rcx, 1
  000ff	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00106	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010b	85 c0		 test	 eax, eax
  0010d	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  0010f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00121	ba 07 00 00 00	 mov	 edx, 7
  00126	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3863 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  0013c	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00140	83 e0 02	 and	 eax, 2
  00143	85 c0		 test	 eax, eax
  00145	75 0b		 jne	 SHORT $LN9@s370_load_
  00147	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0014b	83 e0 02	 and	 eax, 2
  0014e	85 c0		 test	 eax, eax
  00150	74 1b		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  00152	ba 06 00 00 00	 mov	 edx, 6
  00157	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00167	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3864 : 
; 3865 :     GET_FLOAT128_OP( op2, r2, regs );

  0016d	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00171	d1 e0		 shl	 eax, 1
  00173	48 98		 cdqe
  00175	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00185	48 8b d0	 mov	 rdx, rax
  00188	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  0018d	e8 00 00 00 00	 call	 s370_get_float128

; 3866 : 
; 3867 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3868 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00192	b8 01 00 00 00	 mov	 eax, 1
  00197	48 6b c0 04	 imul	 rax, rax, 4
  0019b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a3	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001ab	83 e0 04	 and	 eax, 4
  001ae	85 c0		 test	 eax, eax
  001b0	74 65		 je	 SHORT $LN10@s370_load_

; 3869 :         SET_SF_RM_FROM_MASK( m3 );

  001b2	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001b7	85 c0		 test	 eax, eax
  001b9	74 16		 je	 SHORT $LN21@s370_load_
  001bb	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001c7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cb	89 44 24 34	 mov	 DWORD PTR tv174[rsp], eax
  001cf	eb 22		 jmp	 SHORT $LN22@s370_load_
$LN21@s370_load_:
  001d1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001df	83 e0 07	 and	 eax, 7
  001e2	8b c0		 mov	 eax, eax
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ef	89 44 24 34	 mov	 DWORD PTR tv174[rsp], eax
$LN22@s370_load_:
  001f3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001f8	8b c0		 mov	 eax, eax
  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00200	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00209	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0020d	0f b6 54 24 34	 movzx	 edx, BYTE PTR tv174[rsp]
  00212	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00215	eb 6a		 jmp	 SHORT $LN11@s370_load_
$LN10@s370_load_:

; 3870 :     else
; 3871 : #endif
; 3872 :     {
; 3873 :         if (m3 || m4)

  00217	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0021c	85 c0		 test	 eax, eax
  0021e	75 09		 jne	 SHORT $LN13@s370_load_
  00220	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00225	85 c0		 test	 eax, eax
  00227	74 1b		 je	 SHORT $LN12@s370_load_
$LN13@s370_load_:

; 3874 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00229	ba 06 00 00 00	 mov	 edx, 6
  0022e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00236	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_load_:

; 3875 :         SET_SF_RM_FROM_FPC;

  00244	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00252	83 e0 07	 and	 eax, 7
  00255	8b c0		 mov	 eax, eax
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0025e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00263	8b d2		 mov	 edx, edx
  00265	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0026c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00275	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00279	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al
$LN11@s370_load_:

; 3876 :     }
; 3877 : 
; 3878 :     softfloat_exceptionFlags = 0;

  00281	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00286	8b c0		 mov	 eax, eax
  00288	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0028e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00297	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3879 : 
; 3880 :     op1 = f128_to_f32( op2 );

  0029f	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  002a4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  002a9	48 8b f8	 mov	 rdi, rax
  002ac	48 8b f1	 mov	 rsi, rcx
  002af	b9 10 00 00 00	 mov	 ecx, 16
  002b4	f3 a4		 rep movsb
  002b6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  002bb	e8 00 00 00 00	 call	 f128_to_f32
  002c0	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 3881 : 
; 3882 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3883 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  002c4	b8 01 00 00 00	 mov	 eax, 1
  002c9	48 6b c0 04	 imul	 rax, rax, 4
  002cd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d5	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  002dd	83 e0 04	 and	 eax, 4
  002e0	85 c0		 test	 eax, eax
  002e2	74 4a		 je	 SHORT $LN14@s370_load_

; 3884 :     {
; 3885 :         if (SUPPRESS_INEXACT( m4 ))

  002e4	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002e9	83 e0 04	 and	 eax, 4
  002ec	85 c0		 test	 eax, eax
  002ee	74 3e		 je	 SHORT $LN15@s370_load_

; 3886 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;

  002f0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002f5	8b c0		 mov	 eax, eax
  002f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002fd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00306	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0030a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0030e	83 e0 fe	 and	 eax, -2
  00311	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00317	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00320	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00325	8b ff		 mov	 edi, edi
  00327	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0032b	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN15@s370_load_:
$LN14@s370_load_:

; 3887 :     }
; 3888 : #endif
; 3889 : 
; 3890 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0032e	33 c0		 xor	 eax, eax
  00330	83 f8 01	 cmp	 eax, 1
  00333	74 4b		 je	 SHORT $LN16@s370_load_
  00335	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0033a	8b c0		 mov	 eax, eax
  0033c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00342	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0034b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0034f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00353	83 e0 10	 and	 eax, 16
  00356	85 c0		 test	 eax, eax
  00358	74 26		 je	 SHORT $LN16@s370_load_
  0035a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00362	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00368	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0036d	85 c0		 test	 eax, eax
  0036f	74 0f		 je	 SHORT $LN16@s370_load_
  00371	b2 80		 mov	 dl, 128			; 00000080H
  00373	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037b	e8 00 00 00 00	 call	 ieee_trap
$LN16@s370_load_:

; 3891 : 
; 3892 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  00380	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00384	d1 e0		 shl	 eax, 1
  00386	48 98		 cdqe
  00388	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00390	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00398	48 8b d0	 mov	 rdx, rax
  0039b	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  003a0	e8 00 00 00 00	 call	 s370_put_float32

; 3893 : 
; 3894 :     if (softfloat_exceptionFlags)

  003a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003aa	8b c0		 mov	 eax, eax
  003ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003c3	85 c0		 test	 eax, eax
  003c5	0f 84 a0 00 00
	00		 je	 $LN17@s370_load_

; 3895 :     {
; 3896 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  003cb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003d8	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3897 : 
; 3898 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  003dc	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003e0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  003e5	85 c0		 test	 eax, eax
  003e7	74 64		 je	 SHORT $LN18@s370_load_

; 3899 :         {
; 3900 :             op2 = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  003e9	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003ed	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003f2	85 c0		 test	 eax, eax
  003f4	74 0a		 je	 SHORT $LN23@s370_load_
  003f6	c7 44 24 38 00
	e0 ff ff	 mov	 DWORD PTR tv263[rsp], -8192 ; ffffffffffffe000H
  003fe	eb 08		 jmp	 SHORT $LN24@s370_load_
$LN23@s370_load_:
  00400	c7 44 24 38 00
	20 00 00	 mov	 DWORD PTR tv263[rsp], 8192 ; 00002000H
$LN24@s370_load_:
  00408	8b 54 24 38	 mov	 edx, DWORD PTR tv263[rsp]
  0040c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  00411	e8 00 00 00 00	 call	 f128_scaledResult
  00416	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  0041b	48 8b f9	 mov	 rdi, rcx
  0041e	48 8b f0	 mov	 rsi, rax
  00421	b9 10 00 00 00	 mov	 ecx, 16
  00426	f3 a4		 rep movsb

; 3901 :                 SCALE_FACTOR_LOADR_OFLOW_EXTD :
; 3902 :                 SCALE_FACTOR_LOADR_UFLOW_EXTD );
; 3903 : 
; 3904 :             PUT_FLOAT128_NOCC( op2, r1, regs );

  00428	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0042c	d1 e0		 shl	 eax, 1
  0042e	48 98		 cdqe
  00430	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00438	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00440	48 8b d0	 mov	 rdx, rax
  00443	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op2$[rsp]
  00448	e8 00 00 00 00	 call	 s370_put_float128
$LN18@s370_load_:

; 3905 :         }
; 3906 : 
; 3907 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0044d	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00451	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00456	85 c0		 test	 eax, eax
  00458	74 11		 je	 SHORT $LN19@s370_load_
  0045a	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0045e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00466	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@s370_load_:
$LN17@s370_load_:

; 3908 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3909 :     }
; 3910 : }

  0046b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00470	48 33 cc	 xor	 rcx, rsp
  00473	e8 00 00 00 00	 call	 __security_check_cookie
  00478	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0047f	5f		 pop	 rdi
  00480	5e		 pop	 rsi
  00481	c3		 ret	 0
s370_load_rounded_bfp_ext_to_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
ieee_trap_conds$ = 36
temp$1 = 40
r1$ = 44
r2$ = 48
tv174 = 52
tv263 = 56
op1$ = 64
$T2 = 80
$T3 = 96
op2$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
s370_load_rounded_bfp_ext_to_long_reg PROC

; 3789 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3790 :     int         r1, r2;
; 3791 :     BYTE        m3, m4;
; 3792 :     float128_t  op2;
; 3793 :     float64_t   op1;
; 3794 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3795 : 
; 3796 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_load_:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN5@s370_load_
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s370_load_

; 3797 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3798 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN7@s370_load_
  000d3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN6@s370_load_
  000ea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  00112	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3799 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  0013f	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00143	83 e0 02	 and	 eax, 2
  00146	85 c0		 test	 eax, eax
  00148	75 0b		 jne	 SHORT $LN9@s370_load_
  0014a	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0014e	83 e0 02	 and	 eax, 2
  00151	85 c0		 test	 eax, eax
  00153	74 1b		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  00155	ba 06 00 00 00	 mov	 edx, 6
  0015a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3800 : 
; 3801 :     GET_FLOAT128_OP( op2, r2, regs );

  00170	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00174	d1 e0		 shl	 eax, 1
  00176	48 98		 cdqe
  00178	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00180	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00188	48 8b d0	 mov	 rdx, rax
  0018b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  00190	e8 00 00 00 00	 call	 s370_get_float128

; 3802 : 
; 3803 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3804 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00195	b8 01 00 00 00	 mov	 eax, 1
  0019a	48 6b c0 04	 imul	 rax, rax, 4
  0019e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001ae	83 e0 04	 and	 eax, 4
  001b1	85 c0		 test	 eax, eax
  001b3	74 65		 je	 SHORT $LN10@s370_load_

; 3805 :         SET_SF_RM_FROM_MASK( m3 );

  001b5	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001ba	85 c0		 test	 eax, eax
  001bc	74 16		 je	 SHORT $LN21@s370_load_
  001be	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ce	89 44 24 34	 mov	 DWORD PTR tv174[rsp], eax
  001d2	eb 22		 jmp	 SHORT $LN22@s370_load_
$LN21@s370_load_:
  001d4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001e2	83 e0 07	 and	 eax, 7
  001e5	8b c0		 mov	 eax, eax
  001e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f2	89 44 24 34	 mov	 DWORD PTR tv174[rsp], eax
$LN22@s370_load_:
  001f6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001fb	8b c0		 mov	 eax, eax
  001fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00203	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0020c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00210	0f b6 54 24 34	 movzx	 edx, BYTE PTR tv174[rsp]
  00215	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00218	eb 6a		 jmp	 SHORT $LN11@s370_load_
$LN10@s370_load_:

; 3806 :     else
; 3807 : #endif
; 3808 :     {
; 3809 :         if (m3 || m4)

  0021a	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0021f	85 c0		 test	 eax, eax
  00221	75 09		 jne	 SHORT $LN13@s370_load_
  00223	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00228	85 c0		 test	 eax, eax
  0022a	74 1b		 je	 SHORT $LN12@s370_load_
$LN13@s370_load_:

; 3810 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0022c	ba 06 00 00 00	 mov	 edx, 6
  00231	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00241	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_load_:

; 3811 :         SET_SF_RM_FROM_FPC;

  00247	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00255	83 e0 07	 and	 eax, 7
  00258	8b c0		 mov	 eax, eax
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00261	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00266	8b d2		 mov	 edx, edx
  00268	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0026f	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00278	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0027c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00280	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al
$LN11@s370_load_:

; 3812 :     }
; 3813 : 
; 3814 :     softfloat_exceptionFlags = 0;

  00284	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00289	8b c0		 mov	 eax, eax
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00291	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029e	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3815 : 
; 3816 :     op1 = f128_to_f64( op2 );

  002a2	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  002a7	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  002ac	48 8b f8	 mov	 rdi, rax
  002af	48 8b f1	 mov	 rsi, rcx
  002b2	b9 10 00 00 00	 mov	 ecx, 16
  002b7	f3 a4		 rep movsb
  002b9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T2[rsp]
  002be	e8 00 00 00 00	 call	 f128_to_f64
  002c3	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 3817 : 
; 3818 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3819 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  002c8	b8 01 00 00 00	 mov	 eax, 1
  002cd	48 6b c0 04	 imul	 rax, rax, 4
  002d1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  002e1	83 e0 04	 and	 eax, 4
  002e4	85 c0		 test	 eax, eax
  002e6	74 4a		 je	 SHORT $LN14@s370_load_

; 3820 :     {
; 3821 :         if (SUPPRESS_INEXACT( m4 ))

  002e8	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002ed	83 e0 04	 and	 eax, 4
  002f0	85 c0		 test	 eax, eax
  002f2	74 3e		 je	 SHORT $LN15@s370_load_

; 3822 :             softfloat_exceptionFlags &= ~softfloat_flag_inexact;

  002f4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002f9	8b c0		 mov	 eax, eax
  002fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00301	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0030a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0030e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00312	83 e0 fe	 and	 eax, -2
  00315	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0031b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00324	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00329	8b ff		 mov	 edi, edi
  0032b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0032f	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN15@s370_load_:
$LN14@s370_load_:

; 3823 :     }
; 3824 : #endif
; 3825 : 
; 3826 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00332	33 c0		 xor	 eax, eax
  00334	83 f8 01	 cmp	 eax, 1
  00337	74 4b		 je	 SHORT $LN16@s370_load_
  00339	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0033e	8b c0		 mov	 eax, eax
  00340	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00346	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0034f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00353	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00357	83 e0 10	 and	 eax, 16
  0035a	85 c0		 test	 eax, eax
  0035c	74 26		 je	 SHORT $LN16@s370_load_
  0035e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00366	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0036c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00371	85 c0		 test	 eax, eax
  00373	74 0f		 je	 SHORT $LN16@s370_load_
  00375	b2 80		 mov	 dl, 128			; 00000080H
  00377	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037f	e8 00 00 00 00	 call	 ieee_trap
$LN16@s370_load_:

; 3827 : 
; 3828 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00384	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00388	d1 e0		 shl	 eax, 1
  0038a	48 98		 cdqe
  0038c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00394	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0039c	48 8b d0	 mov	 rdx, rax
  0039f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  003a4	e8 00 00 00 00	 call	 s370_put_float64

; 3829 : 
; 3830 :     if (softfloat_exceptionFlags)

  003a9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003ae	8b c0		 mov	 eax, eax
  003b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003b6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003bf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003c7	85 c0		 test	 eax, eax
  003c9	0f 84 a0 00 00
	00		 je	 $LN17@s370_load_

; 3831 :     {
; 3832 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  003cf	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d7	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003dc	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3833 : 
; 3834 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  003e0	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003e4	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  003e9	85 c0		 test	 eax, eax
  003eb	74 64		 je	 SHORT $LN18@s370_load_

; 3835 :         {
; 3836 :             op2 = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  003ed	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003f1	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  003f6	85 c0		 test	 eax, eax
  003f8	74 0a		 je	 SHORT $LN23@s370_load_
  003fa	c7 44 24 38 00
	e0 ff ff	 mov	 DWORD PTR tv263[rsp], -8192 ; ffffffffffffe000H
  00402	eb 08		 jmp	 SHORT $LN24@s370_load_
$LN23@s370_load_:
  00404	c7 44 24 38 00
	20 00 00	 mov	 DWORD PTR tv263[rsp], 8192 ; 00002000H
$LN24@s370_load_:
  0040c	8b 54 24 38	 mov	 edx, DWORD PTR tv263[rsp]
  00410	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  00415	e8 00 00 00 00	 call	 f128_scaledResult
  0041a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  0041f	48 8b f9	 mov	 rdi, rcx
  00422	48 8b f0	 mov	 rsi, rax
  00425	b9 10 00 00 00	 mov	 ecx, 16
  0042a	f3 a4		 rep movsb

; 3837 :                 SCALE_FACTOR_LOADR_OFLOW_EXTD :
; 3838 :                 SCALE_FACTOR_LOADR_UFLOW_EXTD );
; 3839 : 
; 3840 :             PUT_FLOAT128_NOCC( op2, r1, regs );

  0042c	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00430	d1 e0		 shl	 eax, 1
  00432	48 98		 cdqe
  00434	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00444	48 8b d0	 mov	 rdx, rax
  00447	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  0044c	e8 00 00 00 00	 call	 s370_put_float128
$LN18@s370_load_:

; 3841 :         }
; 3842 : 
; 3843 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00451	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00455	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  0045a	85 c0		 test	 eax, eax
  0045c	74 11		 je	 SHORT $LN19@s370_load_
  0045e	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00462	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@s370_load_:
$LN17@s370_load_:

; 3844 :             FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3845 :     }
; 3846 : }

  0046f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00477	48 33 cc	 xor	 rcx, rsp
  0047a	e8 00 00 00 00	 call	 __security_check_cookie
  0047f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00486	5f		 pop	 rdi
  00487	5e		 pop	 rsi
  00488	c3		 ret	 0
s370_load_rounded_bfp_ext_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv151 = 40
tv154 = 44
tv156 = 48
tv157 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s370_load_positive_bfp_short_reg PROC

; 3686 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3687 :     int        r1, r2;
; 3688 :     float32_t  op;
; 3689 : 
; 3690 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3691 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3692 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3693 : 
; 3694 :     GET_FLOAT32_OP( op, r2, regs );

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float32

; 3695 :     op.v &= ~0x80000000;

  00109	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0010d	0f ba f0 1f	 btr	 eax, 31
  00111	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN7@s370_load_:

; 3696 : 
; 3697 :     PUT_FLOAT32_CC( op, r1, regs );

  00115	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00119	d1 e0		 shl	 eax, 1
  0011b	48 98		 cdqe
  0011d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00132	e8 00 00 00 00	 call	 s370_put_float32
  00137	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0013b	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00140	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00145	75 17		 jne	 SHORT $LN12@s370_load_
  00147	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0014b	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00150	85 c0		 test	 eax, eax
  00152	74 0a		 je	 SHORT $LN12@s370_load_
  00154	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0015c	eb 5e		 jmp	 SHORT $LN19@s370_load_
$LN12@s370_load_:
  0015e	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00162	0f ba f0 1f	 btr	 eax, 31
  00166	85 c0		 test	 eax, eax
  00168	75 0a		 jne	 SHORT $LN13@s370_load_
  0016a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00172	eb 08		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  00174	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s370_load_:
  0017c	83 7c 24 28 00	 cmp	 DWORD PTR tv151[rsp], 0
  00181	74 0a		 je	 SHORT $LN17@s370_load_
  00183	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  0018b	eb 27		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  0018d	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00191	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00196	85 c0		 test	 eax, eax
  00198	74 0a		 je	 SHORT $LN15@s370_load_
  0019a	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001a4	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s370_load_:
  001ac	8b 44 24 2c	 mov	 eax, DWORD PTR tv154[rsp]
  001b0	89 44 24 30	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s370_load_:
  001b4	8b 44 24 30	 mov	 eax, DWORD PTR tv156[rsp]
  001b8	89 44 24 34	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s370_load_:
  001bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv157[rsp]
  001c6	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  001c9	33 c0		 xor	 eax, eax
  001cb	85 c0		 test	 eax, eax
  001cd	0f 85 42 ff ff
	ff		 jne	 $LN7@s370_load_

; 3698 : }

  001d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d7	c3		 ret	 0
s370_load_positive_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv151 = 36
tv154 = 40
tv156 = 44
tv157 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s370_load_positive_bfp_long_reg PROC

; 3667 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3668 :     int        r1, r2;
; 3669 :     float64_t  op;
; 3670 : 
; 3671 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3672 : 
; 3673 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3674 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_load_
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_load_
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3675 : 
; 3676 :     GET_FLOAT64_OP( op, r2, regs );

  000e7	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float64

; 3677 :     op.v  &= ~0x8000000000000000ULL;

  00109	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00118	48 23 c8	 and	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN7@s370_load_:

; 3678 : 
; 3679 :     PUT_FLOAT64_CC( op, r1, regs );

  00123	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00127	d1 e0		 shl	 eax, 1
  00129	48 98		 cdqe
  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00138	48 8b d0	 mov	 rdx, rax
  0013b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00140	e8 00 00 00 00	 call	 s370_put_float64
  00145	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0014f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00154	48 23 c8	 and	 rcx, rax
  00157	48 8b c1	 mov	 rax, rcx
  0015a	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00164	48 3b c1	 cmp	 rax, rcx
  00167	75 24		 jne	 SHORT $LN12@s370_load_
  00169	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00178	48 23 c8	 and	 rcx, rax
  0017b	48 8b c1	 mov	 rax, rcx
  0017e	48 85 c0	 test	 rax, rax
  00181	74 0a		 je	 SHORT $LN12@s370_load_
  00183	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0018b	eb 79		 jmp	 SHORT $LN19@s370_load_
$LN12@s370_load_:
  0018d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00197	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019c	48 23 c8	 and	 rcx, rax
  0019f	48 8b c1	 mov	 rax, rcx
  001a2	48 85 c0	 test	 rax, rax
  001a5	75 0a		 jne	 SHORT $LN13@s370_load_
  001a7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  001b1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s370_load_:
  001b9	83 7c 24 24 00	 cmp	 DWORD PTR tv151[rsp], 0
  001be	74 0a		 je	 SHORT $LN17@s370_load_
  001c0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  001c8	eb 34		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  001ca	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d9	48 23 c8	 and	 rcx, rax
  001dc	48 8b c1	 mov	 rax, rcx
  001df	48 85 c0	 test	 rax, rax
  001e2	74 0a		 je	 SHORT $LN15@s370_load_
  001e4	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001ec	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001ee	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s370_load_:
  001f6	8b 44 24 28	 mov	 eax, DWORD PTR tv154[rsp]
  001fa	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s370_load_:
  001fe	8b 44 24 2c	 mov	 eax, DWORD PTR tv156[rsp]
  00202	89 44 24 30	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s370_load_:
  00206	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv157[rsp]
  00210	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 06 ff ff
	ff		 jne	 $LN7@s370_load_

; 3680 : }

  0021d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00221	c3		 ret	 0
s370_load_positive_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv174 = 44
tv179 = 48
tv181 = 52
tv182 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
s370_load_positive_bfp_ext_reg PROC

; 3647 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3648 :     int         r1, r2;
; 3649 :     float128_t  op;
; 3650 : 
; 3651 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN8@s370_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@s370_load_

; 3652 : 
; 3653 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3654 :     BFPINST_CHECK( regs );

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00090	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00095	85 c0		 test	 eax, eax
  00097	74 39		 je	 SHORT $LN10@s370_load_
  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a4	d1 e8		 shr	 eax, 1
  000a6	83 e0 01	 and	 eax, 1
  000a9	85 c0		 test	 eax, eax
  000ab	74 49		 je	 SHORT $LN9@s370_load_
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b9	b9 08 00 00 00	 mov	 ecx, 8
  000be	48 6b c9 01	 imul	 rcx, rcx, 1
  000c2	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ce	85 c0		 test	 eax, eax
  000d0	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000d2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e1	ba 07 00 00 00	 mov	 edx, 7
  000e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3655 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  000f6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000fa	83 e0 02	 and	 eax, 2
  000fd	85 c0		 test	 eax, eax
  000ff	75 0b		 jne	 SHORT $LN12@s370_load_
  00101	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00105	83 e0 02	 and	 eax, 2
  00108	85 c0		 test	 eax, eax
  0010a	74 15		 je	 SHORT $LN11@s370_load_
$LN12@s370_load_:
  0010c	ba 06 00 00 00	 mov	 edx, 6
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_load_:

; 3656 : 
; 3657 :     GET_FLOAT128_OP( op, r2, regs );

  00121	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00125	d1 e0		 shl	 eax, 1
  00127	48 98		 cdqe
  00129	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00136	48 8b d0	 mov	 rdx, rax
  00139	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0013e	e8 00 00 00 00	 call	 s370_get_float128

; 3658 :     op.v[FLOAT128_HI] &= ~0x8000000000000000ULL;

  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 01	 imul	 rax, rax, 1
  0014c	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00156	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0015b	48 23 c1	 and	 rax, rcx
  0015e	b9 08 00 00 00	 mov	 ecx, 8
  00163	48 6b c9 01	 imul	 rcx, rcx, 1
  00167	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN7@s370_load_:

; 3659 : 
; 3660 :     PUT_FLOAT128_CC( op, r1, regs );

  0016c	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00170	d1 e0		 shl	 eax, 1
  00172	48 98		 cdqe
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00181	48 8b d0	 mov	 rdx, rax
  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00189	e8 00 00 00 00	 call	 s370_put_float128
  0018e	b8 08 00 00 00	 mov	 eax, 8
  00193	48 6b c0 01	 imul	 rax, rax, 1
  00197	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001a1	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001a6	48 23 c1	 and	 rax, rcx
  001a9	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001b3	48 3b c1	 cmp	 rax, rcx
  001b6	75 3e		 jne	 SHORT $LN15@s370_load_
  001b8	b8 08 00 00 00	 mov	 eax, 8
  001bd	48 6b c0 01	 imul	 rax, rax, 1
  001c1	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001cb	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001d0	48 23 c1	 and	 rax, rcx
  001d3	48 85 c0	 test	 rax, rax
  001d6	75 11		 jne	 SHORT $LN14@s370_load_
  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 00	 imul	 rax, rax, 0
  001e1	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  001e7	74 0d		 je	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  001e9	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv182[rsp], 3
  001f1	e9 93 00 00 00	 jmp	 $LN22@s370_load_
$LN15@s370_load_:
  001f6	b8 08 00 00 00	 mov	 eax, 8
  001fb	48 6b c0 01	 imul	 rax, rax, 1
  001ff	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00209	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0020e	48 23 c1	 and	 rax, rcx
  00211	b9 08 00 00 00	 mov	 ecx, 8
  00216	48 6b c9 00	 imul	 rcx, rcx, 0
  0021a	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  0021f	48 85 c0	 test	 rax, rax
  00222	75 0a		 jne	 SHORT $LN16@s370_load_
  00224	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0022c	eb 08		 jmp	 SHORT $LN17@s370_load_
$LN16@s370_load_:
  0022e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN17@s370_load_:
  00236	83 7c 24 2c 00	 cmp	 DWORD PTR tv174[rsp], 0
  0023b	74 0a		 je	 SHORT $LN20@s370_load_
  0023d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
  00245	eb 3a		 jmp	 SHORT $LN21@s370_load_
$LN20@s370_load_:
  00247	b8 08 00 00 00	 mov	 eax, 8
  0024c	48 6b c0 01	 imul	 rax, rax, 1
  00250	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025a	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0025f	48 23 c1	 and	 rax, rcx
  00262	48 85 c0	 test	 rax, rax
  00265	74 0a		 je	 SHORT $LN18@s370_load_
  00267	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  0026f	eb 08		 jmp	 SHORT $LN19@s370_load_
$LN18@s370_load_:
  00271	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv179[rsp], 2
$LN19@s370_load_:
  00279	8b 44 24 30	 mov	 eax, DWORD PTR tv179[rsp]
  0027d	89 44 24 34	 mov	 DWORD PTR tv181[rsp], eax
$LN21@s370_load_:
  00281	8b 44 24 34	 mov	 eax, DWORD PTR tv181[rsp]
  00285	89 44 24 38	 mov	 DWORD PTR tv182[rsp], eax
$LN22@s370_load_:
  00289	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0028e	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv182[rsp]
  00293	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00296	33 c0		 xor	 eax, eax
  00298	85 c0		 test	 eax, eax
  0029a	0f 85 cc fe ff
	ff		 jne	 $LN7@s370_load_

; 3661 : }

  002a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a5	48 33 cc	 xor	 rcx, rsp
  002a8	e8 00 00 00 00	 call	 __security_check_cookie
  002ad	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b1	c3		 ret	 0
s370_load_positive_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv151 = 40
tv154 = 44
tv156 = 48
tv157 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s370_load_negative_bfp_short_reg PROC

; 3574 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3575 :     int        r1, r2;
; 3576 :     float32_t  op;
; 3577 : 
; 3578 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3579 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3580 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3581 : 
; 3582 :     GET_FLOAT32_OP( op, r2, regs );

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float32

; 3583 :     op.v |= 0x80000000;

  00109	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0010d	0f ba e8 1f	 bts	 eax, 31
  00111	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN7@s370_load_:

; 3584 : 
; 3585 :     PUT_FLOAT32_CC( op, r1, regs );

  00115	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00119	d1 e0		 shl	 eax, 1
  0011b	48 98		 cdqe
  0011d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00132	e8 00 00 00 00	 call	 s370_put_float32
  00137	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0013b	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00140	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00145	75 17		 jne	 SHORT $LN12@s370_load_
  00147	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0014b	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00150	85 c0		 test	 eax, eax
  00152	74 0a		 je	 SHORT $LN12@s370_load_
  00154	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0015c	eb 5e		 jmp	 SHORT $LN19@s370_load_
$LN12@s370_load_:
  0015e	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00162	0f ba f0 1f	 btr	 eax, 31
  00166	85 c0		 test	 eax, eax
  00168	75 0a		 jne	 SHORT $LN13@s370_load_
  0016a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00172	eb 08		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  00174	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s370_load_:
  0017c	83 7c 24 28 00	 cmp	 DWORD PTR tv151[rsp], 0
  00181	74 0a		 je	 SHORT $LN17@s370_load_
  00183	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  0018b	eb 27		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  0018d	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00191	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00196	85 c0		 test	 eax, eax
  00198	74 0a		 je	 SHORT $LN15@s370_load_
  0019a	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001a4	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s370_load_:
  001ac	8b 44 24 2c	 mov	 eax, DWORD PTR tv154[rsp]
  001b0	89 44 24 30	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s370_load_:
  001b4	8b 44 24 30	 mov	 eax, DWORD PTR tv156[rsp]
  001b8	89 44 24 34	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s370_load_:
  001bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv157[rsp]
  001c6	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  001c9	33 c0		 xor	 eax, eax
  001cb	85 c0		 test	 eax, eax
  001cd	0f 85 42 ff ff
	ff		 jne	 $LN7@s370_load_

; 3586 : }

  001d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d7	c3		 ret	 0
s370_load_negative_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv151 = 36
tv154 = 40
tv156 = 44
tv157 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s370_load_negative_bfp_long_reg PROC

; 3556 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3557 :     int        r1, r2;
; 3558 :     float64_t  op;
; 3559 : 
; 3560 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3561 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3562 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_load_
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_load_
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3563 : 
; 3564 :     GET_FLOAT64_OP( op, r2, regs );

  000e7	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float64

; 3565 :     op.v |= 0x8000000000000000ULL;

  00109	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00118	48 0b c8	 or	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN7@s370_load_:

; 3566 : 
; 3567 :     PUT_FLOAT64_CC( op, r1, regs );

  00123	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00127	d1 e0		 shl	 eax, 1
  00129	48 98		 cdqe
  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00138	48 8b d0	 mov	 rdx, rax
  0013b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00140	e8 00 00 00 00	 call	 s370_put_float64
  00145	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0014f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00154	48 23 c8	 and	 rcx, rax
  00157	48 8b c1	 mov	 rax, rcx
  0015a	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00164	48 3b c1	 cmp	 rax, rcx
  00167	75 24		 jne	 SHORT $LN12@s370_load_
  00169	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00178	48 23 c8	 and	 rcx, rax
  0017b	48 8b c1	 mov	 rax, rcx
  0017e	48 85 c0	 test	 rax, rax
  00181	74 0a		 je	 SHORT $LN12@s370_load_
  00183	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0018b	eb 79		 jmp	 SHORT $LN19@s370_load_
$LN12@s370_load_:
  0018d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00197	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019c	48 23 c8	 and	 rcx, rax
  0019f	48 8b c1	 mov	 rax, rcx
  001a2	48 85 c0	 test	 rax, rax
  001a5	75 0a		 jne	 SHORT $LN13@s370_load_
  001a7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  001b1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s370_load_:
  001b9	83 7c 24 24 00	 cmp	 DWORD PTR tv151[rsp], 0
  001be	74 0a		 je	 SHORT $LN17@s370_load_
  001c0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  001c8	eb 34		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  001ca	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d9	48 23 c8	 and	 rcx, rax
  001dc	48 8b c1	 mov	 rax, rcx
  001df	48 85 c0	 test	 rax, rax
  001e2	74 0a		 je	 SHORT $LN15@s370_load_
  001e4	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001ec	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001ee	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s370_load_:
  001f6	8b 44 24 28	 mov	 eax, DWORD PTR tv154[rsp]
  001fa	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s370_load_:
  001fe	8b 44 24 2c	 mov	 eax, DWORD PTR tv156[rsp]
  00202	89 44 24 30	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s370_load_:
  00206	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv157[rsp]
  00210	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 06 ff ff
	ff		 jne	 $LN7@s370_load_

; 3568 : }

  0021d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00221	c3		 ret	 0
s370_load_negative_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv174 = 44
tv179 = 48
tv181 = 52
tv182 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
s370_load_negative_bfp_ext_reg PROC

; 3537 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3538 :     int         r1, r2;
; 3539 :     float128_t  op;
; 3540 : 
; 3541 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN8@s370_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@s370_load_

; 3542 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3543 :     BFPINST_CHECK( regs );

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00090	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00095	85 c0		 test	 eax, eax
  00097	74 39		 je	 SHORT $LN10@s370_load_
  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a4	d1 e8		 shr	 eax, 1
  000a6	83 e0 01	 and	 eax, 1
  000a9	85 c0		 test	 eax, eax
  000ab	74 49		 je	 SHORT $LN9@s370_load_
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b9	b9 08 00 00 00	 mov	 ecx, 8
  000be	48 6b c9 01	 imul	 rcx, rcx, 1
  000c2	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ce	85 c0		 test	 eax, eax
  000d0	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000d2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e1	ba 07 00 00 00	 mov	 edx, 7
  000e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3544 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  000f6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000fa	83 e0 02	 and	 eax, 2
  000fd	85 c0		 test	 eax, eax
  000ff	75 0b		 jne	 SHORT $LN12@s370_load_
  00101	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00105	83 e0 02	 and	 eax, 2
  00108	85 c0		 test	 eax, eax
  0010a	74 15		 je	 SHORT $LN11@s370_load_
$LN12@s370_load_:
  0010c	ba 06 00 00 00	 mov	 edx, 6
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_load_:

; 3545 : 
; 3546 :     GET_FLOAT128_OP( op, r2, regs );

  00121	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00125	d1 e0		 shl	 eax, 1
  00127	48 98		 cdqe
  00129	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00136	48 8b d0	 mov	 rdx, rax
  00139	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0013e	e8 00 00 00 00	 call	 s370_get_float128

; 3547 :     op.v[FLOAT128_HI] |= 0x8000000000000000ULL;

  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 01	 imul	 rax, rax, 1
  0014c	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00156	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0015b	48 0b c1	 or	 rax, rcx
  0015e	b9 08 00 00 00	 mov	 ecx, 8
  00163	48 6b c9 01	 imul	 rcx, rcx, 1
  00167	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN7@s370_load_:

; 3548 : 
; 3549 :     PUT_FLOAT128_CC( op, r1, regs );

  0016c	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00170	d1 e0		 shl	 eax, 1
  00172	48 98		 cdqe
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00181	48 8b d0	 mov	 rdx, rax
  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00189	e8 00 00 00 00	 call	 s370_put_float128
  0018e	b8 08 00 00 00	 mov	 eax, 8
  00193	48 6b c0 01	 imul	 rax, rax, 1
  00197	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001a1	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001a6	48 23 c1	 and	 rax, rcx
  001a9	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001b3	48 3b c1	 cmp	 rax, rcx
  001b6	75 3e		 jne	 SHORT $LN15@s370_load_
  001b8	b8 08 00 00 00	 mov	 eax, 8
  001bd	48 6b c0 01	 imul	 rax, rax, 1
  001c1	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001cb	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001d0	48 23 c1	 and	 rax, rcx
  001d3	48 85 c0	 test	 rax, rax
  001d6	75 11		 jne	 SHORT $LN14@s370_load_
  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 00	 imul	 rax, rax, 0
  001e1	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  001e7	74 0d		 je	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  001e9	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv182[rsp], 3
  001f1	e9 93 00 00 00	 jmp	 $LN22@s370_load_
$LN15@s370_load_:
  001f6	b8 08 00 00 00	 mov	 eax, 8
  001fb	48 6b c0 01	 imul	 rax, rax, 1
  001ff	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00209	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0020e	48 23 c1	 and	 rax, rcx
  00211	b9 08 00 00 00	 mov	 ecx, 8
  00216	48 6b c9 00	 imul	 rcx, rcx, 0
  0021a	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  0021f	48 85 c0	 test	 rax, rax
  00222	75 0a		 jne	 SHORT $LN16@s370_load_
  00224	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0022c	eb 08		 jmp	 SHORT $LN17@s370_load_
$LN16@s370_load_:
  0022e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN17@s370_load_:
  00236	83 7c 24 2c 00	 cmp	 DWORD PTR tv174[rsp], 0
  0023b	74 0a		 je	 SHORT $LN20@s370_load_
  0023d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
  00245	eb 3a		 jmp	 SHORT $LN21@s370_load_
$LN20@s370_load_:
  00247	b8 08 00 00 00	 mov	 eax, 8
  0024c	48 6b c0 01	 imul	 rax, rax, 1
  00250	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025a	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0025f	48 23 c1	 and	 rax, rcx
  00262	48 85 c0	 test	 rax, rax
  00265	74 0a		 je	 SHORT $LN18@s370_load_
  00267	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  0026f	eb 08		 jmp	 SHORT $LN19@s370_load_
$LN18@s370_load_:
  00271	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv179[rsp], 2
$LN19@s370_load_:
  00279	8b 44 24 30	 mov	 eax, DWORD PTR tv179[rsp]
  0027d	89 44 24 34	 mov	 DWORD PTR tv181[rsp], eax
$LN21@s370_load_:
  00281	8b 44 24 34	 mov	 eax, DWORD PTR tv181[rsp]
  00285	89 44 24 38	 mov	 DWORD PTR tv182[rsp], eax
$LN22@s370_load_:
  00289	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0028e	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv182[rsp]
  00293	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00296	33 c0		 xor	 eax, eax
  00298	85 c0		 test	 eax, eax
  0029a	0f 85 cc fe ff
	ff		 jne	 $LN7@s370_load_

; 3550 : }

  002a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a5	48 33 cc	 xor	 rcx, rsp
  002a8	e8 00 00 00 00	 call	 __security_check_cookie
  002ad	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b1	c3		 ret	 0
s370_load_negative_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op2$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
op1$ = 48
inst$ = 80
regs$ = 88
s370_load_lengthened_bfp_short_to_long_reg PROC

; 3353 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3354 :     int        r1, r2;
; 3355 :     float32_t  op2;
; 3356 :     float64_t  op1;
; 3357 : 
; 3358 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN5@s370_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3359 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3360 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN7@s370_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN6@s370_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3361 : 
; 3362 :     GET_FLOAT32_OP( op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op2$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float32

; 3363 : 
; 3364 :     if (f32_isSignalingNaN( op2 ))

  00109	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  0010d	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00112	0f b6 c0	 movzx	 eax, al
  00115	85 c0		 test	 eax, eax
  00117	0f 84 c8 00 00
	00		 je	 $LN8@s370_load_

; 3365 :     {
; 3366 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  0011d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00122	8b c0		 mov	 eax, eax
  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0012a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00133	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00137	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3367 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0013b	33 c0		 xor	 eax, eax
  0013d	83 f8 01	 cmp	 eax, 1
  00140	74 45		 je	 SHORT $LN9@s370_load_
  00142	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00147	8b c0		 mov	 eax, eax
  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0014f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00158	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0015c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00160	83 e0 10	 and	 eax, 16
  00163	85 c0		 test	 eax, eax
  00165	74 20		 je	 SHORT $LN9@s370_load_
  00167	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00172	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00177	85 c0		 test	 eax, eax
  00179	74 0c		 je	 SHORT $LN9@s370_load_
  0017b	b2 80		 mov	 dl, 128			; 00000080H
  0017d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	e8 00 00 00 00	 call	 ieee_trap
$LN9@s370_load_:

; 3368 : 
; 3369 :         FLOAT32_MAKE_QNAN( op2 );

  00187	8b 44 24 20	 mov	 eax, DWORD PTR op2$[rsp]
  0018b	0f ba e8 16	 bts	 eax, 22
  0018f	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 3370 :         SET_FPC_FLAGS_FROM_SF( regs );

  00193	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00198	8b c0		 mov	 eax, eax
  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b1	c1 e0 13	 shl	 eax, 19
  001b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001bf	c1 e9 08	 shr	 ecx, 8
  001c2	f7 d1		 not	 ecx
  001c4	23 c1		 and	 eax, ecx
  001c6	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001cb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001d6	0b c8		 or	 ecx, eax
  001d8	8b c1		 mov	 eax, ecx
  001da	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN8@s370_load_:

; 3371 :     }
; 3372 : 
; 3373 :     op1 = f32_to_f64( op2 );

  001e5	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  001e9	e8 00 00 00 00	 call	 f32_to_f64
  001ee	48 89 44 24 30	 mov	 QWORD PTR op1$[rsp], rax

; 3374 : 
; 3375 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  001f3	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001f7	d1 e0		 shl	 eax, 1
  001f9	48 98		 cdqe
  001fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00200	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00208	48 8b d0	 mov	 rdx, rax
  0020b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00210	e8 00 00 00 00	 call	 s370_put_float64

; 3376 : }

  00215	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00219	c3		 ret	 0
s370_load_lengthened_bfp_short_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
op2$ = 40
b2$ = 44
x2$ = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s370_load_lengthened_bfp_short_to_long PROC

; 3382 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3383 :     int        r1, x2, b2;
; 3384 :     VADR       effective_addr2;
; 3385 :     float32_t  op2;
; 3386 :     float64_t  op1;
; 3387 : 
; 3388 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s370_load_
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00070	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s370_load_
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
  000a2	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000a6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ab	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_load_:
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 06	 add	 rax, 6
  000bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN7@s370_load_
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_load_:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 d1		 jne	 SHORT $LN4@s370_load_

; 3389 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3390 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3391 :     BFPINST_CHECK( regs );

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	85 c0		 test	 eax, eax
  000fa	74 39		 je	 SHORT $LN9@s370_load_
  000fc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00107	d1 e8		 shr	 eax, 1
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	74 49		 je	 SHORT $LN8@s370_load_
  00110	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	48 6b c9 01	 imul	 rcx, rcx, 1
  00125	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	75 24		 jne	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  00135	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00144	ba 07 00 00 00	 mov	 edx, 7
  00149	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00153	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3392 : 
; 3393 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00159	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0015e	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00162	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00166	e8 00 00 00 00	 call	 s370_vfetch4
  0016b	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3394 : 
; 3395 :     if (f32_isSignalingNaN( op2 ))

  0016f	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  00173	e8 00 00 00 00	 call	 f32_isSignalingNaN
  00178	0f b6 c0	 movzx	 eax, al
  0017b	85 c0		 test	 eax, eax
  0017d	0f 84 c8 00 00
	00		 je	 $LN10@s370_load_

; 3396 :     {
; 3397 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  00183	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00188	8b c0		 mov	 eax, eax
  0018a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00190	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00199	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0019d	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3398 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001a1	33 c0		 xor	 eax, eax
  001a3	83 f8 01	 cmp	 eax, 1
  001a6	74 45		 je	 SHORT $LN11@s370_load_
  001a8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001ad	8b c0		 mov	 eax, eax
  001af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001be	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c6	83 e0 10	 and	 eax, 16
  001c9	85 c0		 test	 eax, eax
  001cb	74 20		 je	 SHORT $LN11@s370_load_
  001cd	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001dd	85 c0		 test	 eax, eax
  001df	74 0c		 je	 SHORT $LN11@s370_load_
  001e1	b2 80		 mov	 dl, 128			; 00000080H
  001e3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e8	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_load_:

; 3399 : 
; 3400 :         FLOAT32_MAKE_QNAN( op2 );

  001ed	8b 44 24 28	 mov	 eax, DWORD PTR op2$[rsp]
  001f1	0f ba e8 16	 bts	 eax, 22
  001f5	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3401 :         SET_FPC_FLAGS_FROM_SF( regs );

  001f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001fe	8b c0		 mov	 eax, eax
  00200	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00206	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0020f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00213	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00217	c1 e0 13	 shl	 eax, 19
  0021a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00225	c1 e9 08	 shr	 ecx, 8
  00228	f7 d1		 not	 ecx
  0022a	23 c1		 and	 eax, ecx
  0022c	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00231	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00236	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0023c	0b c8		 or	 ecx, eax
  0023e	8b c1		 mov	 eax, ecx
  00240	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00245	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN10@s370_load_:

; 3402 :     }
; 3403 : 
; 3404 :     op1 = f32_to_f64( op2 );

  0024b	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  0024f	e8 00 00 00 00	 call	 f32_to_f64
  00254	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 3405 : 
; 3406 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  00259	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0025d	d1 e0		 shl	 eax, 1
  0025f	48 98		 cdqe
  00261	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00266	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0026e	48 8b d0	 mov	 rdx, rax
  00271	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00276	e8 00 00 00 00	 call	 s370_put_float64

; 3407 : }

  0027b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0027f	c3		 ret	 0
s370_load_lengthened_bfp_short_to_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op2$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
op1$ = 64
__$ArrayPad$ = 80
inst$ = 128
regs$ = 136
s370_load_lengthened_bfp_short_to_ext_reg PROC

; 3475 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3476 :     int         r1, r2;
; 3477 :     float32_t   op2;
; 3478 :     float128_t  op1;
; 3479 : 
; 3480 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  00051	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN5@s370_load_
  00074	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@s370_load_

; 3481 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3482 :     BFPINST_CHECK( regs );

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a6	85 c0		 test	 eax, eax
  000a8	74 3f		 je	 SHORT $LN7@s370_load_
  000aa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 55		 je	 SHORT $LN6@s370_load_
  000c1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	b9 08 00 00 00	 mov	 ecx, 8
  000d5	48 6b c9 01	 imul	 rcx, rcx, 1
  000d9	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e5	85 c0		 test	 eax, eax
  000e7	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fb	ba 07 00 00 00	 mov	 edx, 7
  00100	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3483 :     BFPREGPAIR_CHECK( r1, regs );

  00116	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011a	83 e0 02	 and	 eax, 2
  0011d	85 c0		 test	 eax, eax
  0011f	74 1b		 je	 SHORT $LN8@s370_load_
  00121	ba 06 00 00 00	 mov	 edx, 6
  00126	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3484 : 
; 3485 :     GET_FLOAT32_OP( op2, r2, regs );

  0013c	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00140	d1 e0		 shl	 eax, 1
  00142	48 98		 cdqe
  00144	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00154	48 8b d0	 mov	 rdx, rax
  00157	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op2$[rsp]
  0015c	e8 00 00 00 00	 call	 s370_get_float32

; 3486 : 
; 3487 :     if (f32_isSignalingNaN( op2 ))

  00161	8b 4c 24 20	 mov	 ecx, DWORD PTR op2$[rsp]
  00165	e8 00 00 00 00	 call	 f32_isSignalingNaN
  0016a	0f b6 c0	 movzx	 eax, al
  0016d	85 c0		 test	 eax, eax
  0016f	0f 84 d7 00 00
	00		 je	 $LN9@s370_load_

; 3488 :     {
; 3489 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  00175	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017a	8b c0		 mov	 eax, eax
  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00182	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0018f	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3490 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00193	33 c0		 xor	 eax, eax
  00195	83 f8 01	 cmp	 eax, 1
  00198	74 4b		 je	 SHORT $LN10@s370_load_
  0019a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019f	8b c0		 mov	 eax, eax
  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b8	83 e0 10	 and	 eax, 16
  001bb	85 c0		 test	 eax, eax
  001bd	74 26		 je	 SHORT $LN10@s370_load_
  001bf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001cd	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001d2	85 c0		 test	 eax, eax
  001d4	74 0f		 je	 SHORT $LN10@s370_load_
  001d6	b2 80		 mov	 dl, 128			; 00000080H
  001d8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e0	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_load_:

; 3491 : 
; 3492 :         FLOAT32_MAKE_QNAN( op2 );

  001e5	8b 44 24 20	 mov	 eax, DWORD PTR op2$[rsp]
  001e9	0f ba e8 16	 bts	 eax, 22
  001ed	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 3493 :         SET_FPC_FLAGS_FROM_SF( regs );

  001f1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f6	8b c0		 mov	 eax, eax
  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001fe	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00207	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0020b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020f	c1 e0 13	 shl	 eax, 19
  00212	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021a	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00220	c1 e9 08	 shr	 ecx, 8
  00223	f7 d1		 not	 ecx
  00225	23 c1		 and	 eax, ecx
  00227	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0022c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00234	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0023a	0b c8		 or	 ecx, eax
  0023c	8b c1		 mov	 eax, ecx
  0023e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN9@s370_load_:

; 3494 :     }
; 3495 : 
; 3496 :     op1 = f32_to_f128( op2 );

  0024c	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  00250	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00255	e8 00 00 00 00	 call	 f32_to_f128
  0025a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  0025f	48 8b f9	 mov	 rdi, rcx
  00262	48 8b f0	 mov	 rsi, rax
  00265	b9 10 00 00 00	 mov	 ecx, 16
  0026a	f3 a4		 rep movsb

; 3497 : 
; 3498 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0026c	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00270	d1 e0		 shl	 eax, 1
  00272	48 98		 cdqe
  00274	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00284	48 8b d0	 mov	 rdx, rax
  00287	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  0028c	e8 00 00 00 00	 call	 s370_put_float128

; 3499 : }

  00291	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00296	48 33 cc	 xor	 rcx, rsp
  00299	e8 00 00 00 00	 call	 __security_check_cookie
  0029e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002a2	5f		 pop	 rdi
  002a3	5e		 pop	 rsi
  002a4	c3		 ret	 0
s370_load_lengthened_bfp_short_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
op2$ = 40
b2$ = 44
x2$ = 48
r1$ = 52
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
s370_load_lengthened_bfp_short_to_ext PROC

; 3505 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3506 :     int         r1, x2, b2;
; 3507 :     VADR        effective_addr2;
; 3508 :     float32_t   op2;
; 3509 :     float128_t  op1;
; 3510 : 
; 3511 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 10	 shr	 eax, 16
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 14	 shr	 eax, 20
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00060	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00065	74 20		 je	 SHORT $LN5@s370_load_
  00067	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00087	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 0c	 shr	 eax, 12
  0008e	83 e0 0f	 and	 eax, 15
  00091	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00095	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009a	74 20		 je	 SHORT $LN6@s370_load_
  0009c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b4	03 c8		 add	 ecx, eax
  000b6	8b c1		 mov	 eax, ecx
  000b8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
  000bc	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_load_:
  000c9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d5	48 83 c0 06	 add	 rax, 6
  000d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e5	33 c0		 xor	 eax, eax
  000e7	83 f8 06	 cmp	 eax, 6
  000ea	74 0f		 je	 SHORT $LN7@s370_load_
  000ec	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_load_:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 c8		 jne	 SHORT $LN4@s370_load_

; 3512 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3513 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3514 :     BFPINST_CHECK( regs );

  00101	b8 08 00 00 00	 mov	 eax, 8
  00106	48 6b c0 01	 imul	 rax, rax, 1
  0010a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0011e	85 c0		 test	 eax, eax
  00120	74 3f		 je	 SHORT $LN9@s370_load_
  00122	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00130	d1 e8		 shr	 eax, 1
  00132	83 e0 01	 and	 eax, 1
  00135	85 c0		 test	 eax, eax
  00137	74 55		 je	 SHORT $LN8@s370_load_
  00139	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00141	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00148	b9 08 00 00 00	 mov	 ecx, 8
  0014d	48 6b c9 01	 imul	 rcx, rcx, 1
  00151	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00158	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0015d	85 c0		 test	 eax, eax
  0015f	75 2d		 jne	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  00161	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00173	ba 07 00 00 00	 mov	 edx, 7
  00178	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00180	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00188	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3515 :     BFPREGPAIR_CHECK( r1, regs );

  0018e	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  00192	83 e0 02	 and	 eax, 2
  00195	85 c0		 test	 eax, eax
  00197	74 1b		 je	 SHORT $LN10@s370_load_
  00199	ba 06 00 00 00	 mov	 edx, 6
  0019e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_load_:

; 3516 : 
; 3517 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  001b4	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001bc	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001c0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001c4	e8 00 00 00 00	 call	 s370_vfetch4
  001c9	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3518 : 
; 3519 :     if (f32_isSignalingNaN( op2 ))

  001cd	8b 4c 24 28	 mov	 ecx, DWORD PTR op2$[rsp]
  001d1	e8 00 00 00 00	 call	 f32_isSignalingNaN
  001d6	0f b6 c0	 movzx	 eax, al
  001d9	85 c0		 test	 eax, eax
  001db	0f 84 d7 00 00
	00		 je	 $LN11@s370_load_

; 3520 :     {
; 3521 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  001e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e6	8b c0		 mov	 eax, eax
  001e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001fb	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3522 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001ff	33 c0		 xor	 eax, eax
  00201	83 f8 01	 cmp	 eax, 1
  00204	74 4b		 je	 SHORT $LN12@s370_load_
  00206	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020b	8b c0		 mov	 eax, eax
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00213	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00220	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00224	83 e0 10	 and	 eax, 16
  00227	85 c0		 test	 eax, eax
  00229	74 26		 je	 SHORT $LN12@s370_load_
  0022b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00233	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00239	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0023e	85 c0		 test	 eax, eax
  00240	74 0f		 je	 SHORT $LN12@s370_load_
  00242	b2 80		 mov	 dl, 128			; 00000080H
  00244	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024c	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_load_:

; 3523 : 
; 3524 :         FLOAT32_MAKE_QNAN( op2 );

  00251	8b 44 24 28	 mov	 eax, DWORD PTR op2$[rsp]
  00255	0f ba e8 16	 bts	 eax, 22
  00259	89 44 24 28	 mov	 DWORD PTR op2$[rsp], eax

; 3525 :         SET_FPC_FLAGS_FROM_SF( regs );

  0025d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00262	8b c0		 mov	 eax, eax
  00264	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00273	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00277	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027b	c1 e0 13	 shl	 eax, 19
  0027e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00286	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0028c	c1 e9 08	 shr	 ecx, 8
  0028f	f7 d1		 not	 ecx
  00291	23 c1		 and	 eax, ecx
  00293	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00298	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002a6	0b c8		 or	 ecx, eax
  002a8	8b c1		 mov	 eax, ecx
  002aa	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b2	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN11@s370_load_:

; 3526 :     }
; 3527 : 
; 3528 :     op1 = f32_to_f128( op2 );

  002b8	8b 54 24 28	 mov	 edx, DWORD PTR op2$[rsp]
  002bc	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  002c1	e8 00 00 00 00	 call	 f32_to_f128
  002c6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  002cb	48 8b f9	 mov	 rdi, rcx
  002ce	48 8b f0	 mov	 rsi, rax
  002d1	b9 10 00 00 00	 mov	 ecx, 16
  002d6	f3 a4		 rep movsb

; 3529 : 
; 3530 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  002d8	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  002dc	d1 e0		 shl	 eax, 1
  002de	48 98		 cdqe
  002e0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002f0	48 8b d0	 mov	 rdx, rax
  002f3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  002f8	e8 00 00 00 00	 call	 s370_put_float128

; 3531 : }

  002fd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00302	48 33 cc	 xor	 rcx, rsp
  00305	e8 00 00 00 00	 call	 __security_check_cookie
  0030a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0030e	5f		 pop	 rdi
  0030f	5e		 pop	 rsi
  00310	c3		 ret	 0
s370_load_lengthened_bfp_short_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
op2$ = 40
r2$ = 48
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
s370_load_lengthened_bfp_long_to_ext_reg PROC

; 3413 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3414 :     int         r1, r2;
; 3415 :     float64_t   op2;
; 3416 :     float128_t  op1;
; 3417 : 
; 3418 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  00051	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN5@s370_load_
  00074	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@s370_load_

; 3419 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3420 :     BFPINST_CHECK( regs );

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a6	85 c0		 test	 eax, eax
  000a8	74 3f		 je	 SHORT $LN7@s370_load_
  000aa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 55		 je	 SHORT $LN6@s370_load_
  000c1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	b9 08 00 00 00	 mov	 ecx, 8
  000d5	48 6b c9 01	 imul	 rcx, rcx, 1
  000d9	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e5	85 c0		 test	 eax, eax
  000e7	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fb	ba 07 00 00 00	 mov	 edx, 7
  00100	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3421 :     BFPREGPAIR_CHECK( r1, regs );

  00116	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0011a	83 e0 02	 and	 eax, 2
  0011d	85 c0		 test	 eax, eax
  0011f	74 1b		 je	 SHORT $LN8@s370_load_
  00121	ba 06 00 00 00	 mov	 edx, 6
  00126	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3422 : 
; 3423 :     GET_FLOAT64_OP( op2, r2, regs );

  0013c	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00140	d1 e0		 shl	 eax, 1
  00142	48 98		 cdqe
  00144	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00154	48 8b d0	 mov	 rdx, rax
  00157	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op2$[rsp]
  0015c	e8 00 00 00 00	 call	 s370_get_float64

; 3424 : 
; 3425 :     if (f64_isSignalingNaN( op2 ))

  00161	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op2$[rsp]
  00166	e8 00 00 00 00	 call	 f64_isSignalingNaN
  0016b	0f b6 c0	 movzx	 eax, al
  0016e	85 c0		 test	 eax, eax
  00170	0f 84 e5 00 00
	00		 je	 $LN9@s370_load_

; 3426 :     {
; 3427 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  00176	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017b	8b c0		 mov	 eax, eax
  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00183	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00190	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3428 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00194	33 c0		 xor	 eax, eax
  00196	83 f8 01	 cmp	 eax, 1
  00199	74 4b		 je	 SHORT $LN10@s370_load_
  0019b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a0	8b c0		 mov	 eax, eax
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b9	83 e0 10	 and	 eax, 16
  001bc	85 c0		 test	 eax, eax
  001be	74 26		 je	 SHORT $LN10@s370_load_
  001c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ce	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001d3	85 c0		 test	 eax, eax
  001d5	74 0f		 je	 SHORT $LN10@s370_load_
  001d7	b2 80		 mov	 dl, 128			; 00000080H
  001d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_load_:

; 3429 : 
; 3430 :         FLOAT64_MAKE_QNAN( op2 );

  001e6	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  001f0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op2$[rsp]
  001f5	48 0b c8	 or	 rcx, rax
  001f8	48 8b c1	 mov	 rax, rcx
  001fb	48 89 44 24 28	 mov	 QWORD PTR op2$[rsp], rax

; 3431 :         SET_FPC_FLAGS_FROM_SF( regs );

  00200	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00205	8b c0		 mov	 eax, eax
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00216	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021e	c1 e0 13	 shl	 eax, 19
  00221	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0022f	c1 e9 08	 shr	 ecx, 8
  00232	f7 d1		 not	 ecx
  00234	23 c1		 and	 eax, ecx
  00236	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  0023b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00243	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00249	0b c8		 or	 ecx, eax
  0024b	8b c1		 mov	 eax, ecx
  0024d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00255	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN9@s370_load_:

; 3432 :     }
; 3433 : 
; 3434 :     op1 = f64_to_f128( op2 );

  0025b	48 8b 54 24 28	 mov	 rdx, QWORD PTR op2$[rsp]
  00260	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  00265	e8 00 00 00 00	 call	 f64_to_f128
  0026a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0026f	48 8b f9	 mov	 rdi, rcx
  00272	48 8b f0	 mov	 rsi, rax
  00275	b9 10 00 00 00	 mov	 ecx, 16
  0027a	f3 a4		 rep movsb

; 3435 : 
; 3436 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0027c	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00280	d1 e0		 shl	 eax, 1
  00282	48 98		 cdqe
  00284	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00294	48 8b d0	 mov	 rdx, rax
  00297	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0029c	e8 00 00 00 00	 call	 s370_put_float128

; 3437 : }

  002a1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a6	48 33 cc	 xor	 rcx, rsp
  002a9	e8 00 00 00 00	 call	 __security_check_cookie
  002ae	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b2	5f		 pop	 rdi
  002b3	5e		 pop	 rsi
  002b4	c3		 ret	 0
s370_load_lengthened_bfp_long_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
x2$ = 44
r1$ = 48
op2$ = 56
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
s370_load_lengthened_bfp_long_to_ext PROC

; 3443 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3444 :     int         r1, x2, b2;
; 3445 :     VADR        effective_addr2;
; 3446 :     float64_t   op2;
; 3447 :     float128_t  op1;
; 3448 : 
; 3449 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00040	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 10	 shr	 eax, 16
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 14	 shr	 eax, 20
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00060	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00065	74 20		 je	 SHORT $LN5@s370_load_
  00067	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  0006c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00087	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 0c	 shr	 eax, 12
  0008e	83 e0 0f	 and	 eax, 15
  00091	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00095	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009a	74 20		 je	 SHORT $LN6@s370_load_
  0009c	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b4	03 c8		 add	 ecx, eax
  000b6	8b c1		 mov	 eax, ecx
  000b8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
  000bc	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_load_:
  000c9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d5	48 83 c0 06	 add	 rax, 6
  000d9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e5	33 c0		 xor	 eax, eax
  000e7	83 f8 06	 cmp	 eax, 6
  000ea	74 0f		 je	 SHORT $LN7@s370_load_
  000ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_load_:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 c8		 jne	 SHORT $LN4@s370_load_

; 3450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3451 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3452 :     BFPINST_CHECK( regs );

  00101	b8 08 00 00 00	 mov	 eax, 8
  00106	48 6b c0 01	 imul	 rax, rax, 1
  0010a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0011e	85 c0		 test	 eax, eax
  00120	74 3f		 je	 SHORT $LN9@s370_load_
  00122	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00130	d1 e8		 shr	 eax, 1
  00132	83 e0 01	 and	 eax, 1
  00135	85 c0		 test	 eax, eax
  00137	74 55		 je	 SHORT $LN8@s370_load_
  00139	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00141	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00148	b9 08 00 00 00	 mov	 ecx, 8
  0014d	48 6b c9 01	 imul	 rcx, rcx, 1
  00151	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00158	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0015d	85 c0		 test	 eax, eax
  0015f	75 2d		 jne	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  00161	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00173	ba 07 00 00 00	 mov	 edx, 7
  00178	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00180	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00188	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3453 :     BFPREGPAIR_CHECK( r1, regs );

  0018e	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00192	83 e0 02	 and	 eax, 2
  00195	85 c0		 test	 eax, eax
  00197	74 1b		 je	 SHORT $LN10@s370_load_
  00199	ba 06 00 00 00	 mov	 edx, 6
  0019e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_load_:

; 3454 : 
; 3455 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001b4	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001bc	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001c0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001c4	e8 00 00 00 00	 call	 s370_vfetch8
  001c9	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 3456 : 
; 3457 :     if (f64_isSignalingNaN( op2 ))

  001ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  001d3	e8 00 00 00 00	 call	 f64_isSignalingNaN
  001d8	0f b6 c0	 movzx	 eax, al
  001db	85 c0		 test	 eax, eax
  001dd	0f 84 e5 00 00
	00		 je	 $LN11@s370_load_

; 3458 :     {
; 3459 :         softfloat_exceptionFlags = softfloat_flag_invalid;

  001e3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e8	8b c0		 mov	 eax, eax
  001ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001fd	c6 04 08 10	 mov	 BYTE PTR [rax+rcx], 16

; 3460 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00201	33 c0		 xor	 eax, eax
  00203	83 f8 01	 cmp	 eax, 1
  00206	74 4b		 je	 SHORT $LN12@s370_load_
  00208	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020d	8b c0		 mov	 eax, eax
  0020f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00215	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00222	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00226	83 e0 10	 and	 eax, 16
  00229	85 c0		 test	 eax, eax
  0022b	74 26		 je	 SHORT $LN12@s370_load_
  0022d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00235	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0023b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00240	85 c0		 test	 eax, eax
  00242	74 0f		 je	 SHORT $LN12@s370_load_
  00244	b2 80		 mov	 dl, 128			; 00000080H
  00246	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024e	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_load_:

; 3461 : 
; 3462 :         FLOAT64_MAKE_QNAN( op2 );

  00253	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  0025d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  00262	48 0b c8	 or	 rcx, rax
  00265	48 8b c1	 mov	 rax, rcx
  00268	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 3463 :         SET_FPC_FLAGS_FROM_SF( regs );

  0026d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00272	8b c0		 mov	 eax, eax
  00274	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0027a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00283	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00287	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028b	c1 e0 13	 shl	 eax, 19
  0028e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00296	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0029c	c1 e9 08	 shr	 ecx, 8
  0029f	f7 d1		 not	 ecx
  002a1	23 c1		 and	 eax, ecx
  002a3	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  002a8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  002b6	0b c8		 or	 ecx, eax
  002b8	8b c1		 mov	 eax, ecx
  002ba	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c2	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN11@s370_load_:

; 3464 :     }
; 3465 : 
; 3466 :     op1 = f64_to_f128( op2 );

  002c8	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  002cd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  002d2	e8 00 00 00 00	 call	 f64_to_f128
  002d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  002dc	48 8b f9	 mov	 rdi, rcx
  002df	48 8b f0	 mov	 rsi, rax
  002e2	b9 10 00 00 00	 mov	 ecx, 16
  002e7	f3 a4		 rep movsb

; 3467 : 
; 3468 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  002e9	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  002ed	d1 e0		 shl	 eax, 1
  002ef	48 98		 cdqe
  002f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f9	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00301	48 8b d0	 mov	 rdx, rax
  00304	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  00309	e8 00 00 00 00	 call	 s370_put_float128

; 3469 : }

  0030e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00313	48 33 cc	 xor	 rcx, rsp
  00316	e8 00 00 00 00	 call	 __security_check_cookie
  0031b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0031f	5f		 pop	 rdi
  00320	5e		 pop	 rsi
  00321	c3		 ret	 0
s370_load_lengthened_bfp_long_to_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
op$ = 40
ieee_trap_conds$ = 44
tv175 = 48
tv181 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s370_load_fp_int_bfp_short_reg PROC

; 3224 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3225 :     int        r1, r2;
; 3226 :     BYTE       m3, m4;
; 3227 :     float32_t  op;
; 3228 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3229 : 
; 3230 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_load_:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_load_
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_load_

; 3231 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3232 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_load_
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_load_
  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3233 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 3234 : 
; 3235 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3236 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	48 6b c0 04	 imul	 rax, rax, 4
  00122	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0012f	83 e0 04	 and	 eax, 4
  00132	85 c0		 test	 eax, eax
  00134	75 05		 jne	 SHORT $LN8@s370_load_

; 3237 : #endif
; 3238 :         m4 = 0;

  00136	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0
$LN8@s370_load_:

; 3239 : 
; 3240 :     GET_FLOAT32_OP( op, r2, regs );

  0013b	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  0013f	d1 e0		 shl	 eax, 1
  00141	48 98		 cdqe
  00143	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00150	48 8b d0	 mov	 rdx, rax
  00153	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op$[rsp]
  00158	e8 00 00 00 00	 call	 s370_get_float32

; 3241 : 
; 3242 :     softfloat_exceptionFlags = 0;

  0015d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00162	8b c0		 mov	 eax, eax
  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0016a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00173	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00177	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3243 :     SET_SF_RM_FROM_MASK( m3 );

  0017b	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00180	85 c0		 test	 eax, eax
  00182	74 16		 je	 SHORT $LN13@s370_load_
  00184	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00190	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00194	89 44 24 30	 mov	 DWORD PTR tv175[rsp], eax
  00198	eb 1f		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  0019a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0019f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001a5	83 e0 07	 and	 eax, 7
  001a8	8b c0		 mov	 eax, eax
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001b1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b5	89 44 24 30	 mov	 DWORD PTR tv175[rsp], eax
$LN14@s370_load_:
  001b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001be	8b c0		 mov	 eax, eax
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001cf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d3	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv175[rsp]
  001d8	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3244 : 
; 3245 :     op = f32_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  001db	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  001e0	83 e0 04	 and	 eax, 4
  001e3	85 c0		 test	 eax, eax
  001e5	75 0a		 jne	 SHORT $LN15@s370_load_
  001e7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv181[rsp], 1
  001ef	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001f1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN16@s370_load_:
  001f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001fe	8b c0		 mov	 eax, eax
  00200	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00206	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0020f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00213	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv181[rsp]
  00219	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0021d	8b 4c 24 28	 mov	 ecx, DWORD PTR op$[rsp]
  00221	e8 00 00 00 00	 call	 f32_roundToInt
  00226	89 44 24 28	 mov	 DWORD PTR op$[rsp], eax

; 3246 : 
; 3247 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0022a	33 c0		 xor	 eax, eax
  0022c	83 f8 01	 cmp	 eax, 1
  0022f	74 45		 je	 SHORT $LN9@s370_load_
  00231	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00236	8b c0		 mov	 eax, eax
  00238	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00247	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024f	83 e0 10	 and	 eax, 16
  00252	85 c0		 test	 eax, eax
  00254	74 20		 je	 SHORT $LN9@s370_load_
  00256	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0025b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00261	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00266	85 c0		 test	 eax, eax
  00268	74 0c		 je	 SHORT $LN9@s370_load_
  0026a	b2 80		 mov	 dl, 128			; 00000080H
  0026c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00271	e8 00 00 00 00	 call	 ieee_trap
$LN9@s370_load_:

; 3248 : 
; 3249 :     PUT_FLOAT32_NOCC( op, r1, regs );

  00276	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0027a	d1 e0		 shl	 eax, 1
  0027c	48 98		 cdqe
  0027e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00283	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0028b	48 8b d0	 mov	 rdx, rax
  0028e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR op$[rsp]
  00293	e8 00 00 00 00	 call	 s370_put_float32

; 3250 : 
; 3251 :     if (softfloat_exceptionFlags)

  00298	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0029d	8b c0		 mov	 eax, eax
  0029f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ae	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b6	85 c0		 test	 eax, eax
  002b8	74 29		 je	 SHORT $LN10@s370_load_

; 3252 :     {
; 3253 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002c4	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3254 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002c8	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cc	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002d1	85 c0		 test	 eax, eax
  002d3	74 0e		 je	 SHORT $LN11@s370_load_
  002d5	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002de	e8 00 00 00 00	 call	 ieee_cond_trap
$LN11@s370_load_:
$LN10@s370_load_:

; 3255 :     }
; 3256 : }

  002e3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002e7	c3		 ret	 0
s370_load_fp_int_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv175 = 44
tv181 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s370_load_fp_int_bfp_long_reg PROC

; 3262 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3263 :     int        r1, r2;
; 3264 :     BYTE m3,   m4;
; 3265 :     float64_t  op;
; 3266 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3267 : 
; 3268 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_load_:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_load_
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_load_

; 3269 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3270 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_load_
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_load_
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3271 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 3272 : 
; 3273 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3274 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	48 6b c0 04	 imul	 rax, rax, 4
  00122	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0012f	83 e0 04	 and	 eax, 4
  00132	85 c0		 test	 eax, eax
  00134	75 05		 jne	 SHORT $LN8@s370_load_

; 3275 : #endif
; 3276 :         m4 = 0;

  00136	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0
$LN8@s370_load_:

; 3277 : 
; 3278 :     GET_FLOAT64_OP( op, r2, regs );

  0013b	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  0013f	d1 e0		 shl	 eax, 1
  00141	48 98		 cdqe
  00143	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00150	48 8b d0	 mov	 rdx, rax
  00153	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00158	e8 00 00 00 00	 call	 s370_get_float64

; 3279 : 
; 3280 :     softfloat_exceptionFlags = 0;

  0015d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00162	8b c0		 mov	 eax, eax
  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0016a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00173	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00177	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3281 :     SET_SF_RM_FROM_MASK( m3 );

  0017b	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00180	85 c0		 test	 eax, eax
  00182	74 16		 je	 SHORT $LN13@s370_load_
  00184	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00190	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00194	89 44 24 2c	 mov	 DWORD PTR tv175[rsp], eax
  00198	eb 1f		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  0019a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0019f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001a5	83 e0 07	 and	 eax, 7
  001a8	8b c0		 mov	 eax, eax
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001b1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b5	89 44 24 2c	 mov	 DWORD PTR tv175[rsp], eax
$LN14@s370_load_:
  001b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001be	8b c0		 mov	 eax, eax
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001cf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001d3	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv175[rsp]
  001d8	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3282 : 
; 3283 :     op = f64_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  001db	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  001e0	83 e0 04	 and	 eax, 4
  001e3	85 c0		 test	 eax, eax
  001e5	75 0a		 jne	 SHORT $LN15@s370_load_
  001e7	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv181[rsp], 1
  001ef	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001f1	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN16@s370_load_:
  001f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001fe	8b c0		 mov	 eax, eax
  00200	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00206	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0020f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00213	44 0f b6 44 24
	30		 movzx	 r8d, BYTE PTR tv181[rsp]
  00219	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0021d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00222	e8 00 00 00 00	 call	 f64_roundToInt
  00227	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax

; 3284 : 
; 3285 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0022c	33 c0		 xor	 eax, eax
  0022e	83 f8 01	 cmp	 eax, 1
  00231	74 45		 je	 SHORT $LN9@s370_load_
  00233	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00238	8b c0		 mov	 eax, eax
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00240	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00249	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00251	83 e0 10	 and	 eax, 16
  00254	85 c0		 test	 eax, eax
  00256	74 20		 je	 SHORT $LN9@s370_load_
  00258	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0025d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00263	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00268	85 c0		 test	 eax, eax
  0026a	74 0c		 je	 SHORT $LN9@s370_load_
  0026c	b2 80		 mov	 dl, 128			; 00000080H
  0026e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	e8 00 00 00 00	 call	 ieee_trap
$LN9@s370_load_:

; 3286 : 
; 3287 :     PUT_FLOAT64_NOCC( op, r1, regs );

  00278	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0027c	d1 e0		 shl	 eax, 1
  0027e	48 98		 cdqe
  00280	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0028d	48 8b d0	 mov	 rdx, rax
  00290	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00295	e8 00 00 00 00	 call	 s370_put_float64

; 3288 : 
; 3289 :     if (softfloat_exceptionFlags)

  0029a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0029f	8b c0		 mov	 eax, eax
  002a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b8	85 c0		 test	 eax, eax
  002ba	74 29		 je	 SHORT $LN10@s370_load_

; 3290 :     {
; 3291 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c1	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002c6	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3292 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  002ca	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002ce	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002d3	85 c0		 test	 eax, eax
  002d5	74 0e		 je	 SHORT $LN11@s370_load_
  002d7	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002db	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e0	e8 00 00 00 00	 call	 ieee_cond_trap
$LN11@s370_load_:
$LN10@s370_load_:

; 3293 :     }
; 3294 : }

  002e5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002e9	c3		 ret	 0
s370_load_fp_int_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
r2$ = 44
tv182 = 48
tv188 = 52
r1$ = 56
tv241 = 64
$T2 = 80
$T3 = 96
op$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
s370_load_fp_int_bfp_ext_reg PROC

; 3300 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3301 :     int         r1, r2;
; 3302 :     BYTE        m3, m4;
; 3303 :     float128_t  op;
; 3304 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3305 : 
; 3306 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_load_:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN5@s370_load_
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s370_load_

; 3307 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3308 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN7@s370_load_
  000d3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN6@s370_load_
  000ea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  00112	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 3309 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  0013f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00143	83 e0 02	 and	 eax, 2
  00146	85 c0		 test	 eax, eax
  00148	75 0b		 jne	 SHORT $LN9@s370_load_
  0014a	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0014e	83 e0 02	 and	 eax, 2
  00151	85 c0		 test	 eax, eax
  00153	74 1b		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  00155	ba 06 00 00 00	 mov	 edx, 6
  0015a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3310 :     BFPRM_CHECK( m3, regs );

  00170	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00175	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 3311 : 
; 3312 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 3313 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00182	b8 01 00 00 00	 mov	 eax, 1
  00187	48 6b c0 04	 imul	 rax, rax, 4
  0018b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00193	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0019b	83 e0 04	 and	 eax, 4
  0019e	85 c0		 test	 eax, eax
  001a0	75 05		 jne	 SHORT $LN10@s370_load_

; 3314 : #endif
; 3315 :         m4 = 0;

  001a2	c6 44 24 21 00	 mov	 BYTE PTR m4$[rsp], 0
$LN10@s370_load_:

; 3316 : 
; 3317 :     GET_FLOAT128_OP( op, r2, regs );

  001a7	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001ab	d1 e0		 shl	 eax, 1
  001ad	48 98		 cdqe
  001af	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001bf	48 8b d0	 mov	 rdx, rax
  001c2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  001c7	e8 00 00 00 00	 call	 s370_get_float128

; 3318 : 
; 3319 :     softfloat_exceptionFlags = 0;

  001cc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d1	8b c0		 mov	 eax, eax
  001d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3320 :     SET_SF_RM_FROM_MASK( m3 );

  001ea	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001ef	85 c0		 test	 eax, eax
  001f1	74 16		 je	 SHORT $LN15@s370_load_
  001f3	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00203	89 44 24 30	 mov	 DWORD PTR tv182[rsp], eax
  00207	eb 22		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  00209	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00211	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00217	83 e0 07	 and	 eax, 7
  0021a	8b c0		 mov	 eax, eax
  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00223	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00227	89 44 24 30	 mov	 DWORD PTR tv182[rsp], eax
$LN16@s370_load_:
  0022b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00230	8b c0		 mov	 eax, eax
  00232	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00238	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00241	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00245	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv182[rsp]
  0024a	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3321 : 
; 3322 :     op = f128_roundToInt( op, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  0024d	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00252	83 e0 04	 and	 eax, 4
  00255	85 c0		 test	 eax, eax
  00257	75 0a		 jne	 SHORT $LN17@s370_load_
  00259	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv188[rsp], 1
  00261	eb 08		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  00263	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
$LN18@s370_load_:
  0026b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00270	8b c0		 mov	 eax, eax
  00272	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00278	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00281	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00285	48 89 4c 24 40	 mov	 QWORD PTR tv241[rsp], rcx
  0028a	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  0028f	4c 8d 44 24 70	 lea	 r8, QWORD PTR op$[rsp]
  00294	48 8b fa	 mov	 rdi, rdx
  00297	49 8b f0	 mov	 rsi, r8
  0029a	b9 10 00 00 00	 mov	 ecx, 16
  0029f	f3 a4		 rep movsb
  002a1	44 0f b6 4c 24
	34		 movzx	 r9d, BYTE PTR tv188[rsp]
  002a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv241[rsp]
  002ac	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  002b1	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  002b6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  002bb	e8 00 00 00 00	 call	 f128_roundToInt
  002c0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  002c5	48 8b f9	 mov	 rdi, rcx
  002c8	48 8b f0	 mov	 rsi, rax
  002cb	b9 10 00 00 00	 mov	 ecx, 16
  002d0	f3 a4		 rep movsb

; 3323 : 
; 3324 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002d2	33 c0		 xor	 eax, eax
  002d4	83 f8 01	 cmp	 eax, 1
  002d7	74 4b		 je	 SHORT $LN11@s370_load_
  002d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002de	8b c0		 mov	 eax, eax
  002e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ef	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f7	83 e0 10	 and	 eax, 16
  002fa	85 c0		 test	 eax, eax
  002fc	74 26		 je	 SHORT $LN11@s370_load_
  002fe	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00306	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0030c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00311	85 c0		 test	 eax, eax
  00313	74 0f		 je	 SHORT $LN11@s370_load_
  00315	b2 80		 mov	 dl, 128			; 00000080H
  00317	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031f	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_load_:

; 3325 : 
; 3326 :     PUT_FLOAT128_NOCC( op, r1, regs );

  00324	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00328	d1 e0		 shl	 eax, 1
  0032a	48 98		 cdqe
  0032c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00334	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0033c	48 8b d0	 mov	 rdx, rax
  0033f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op$[rsp]
  00344	e8 00 00 00 00	 call	 s370_put_float128

; 3327 : 
; 3328 :     if (softfloat_exceptionFlags)

  00349	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0034e	8b c0		 mov	 eax, eax
  00350	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00356	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0035f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00363	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00367	85 c0		 test	 eax, eax
  00369	74 2f		 je	 SHORT $LN12@s370_load_

; 3329 :     {
; 3330 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0036b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00373	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00378	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3331 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0037c	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00380	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00385	85 c0		 test	 eax, eax
  00387	74 11		 je	 SHORT $LN13@s370_load_
  00389	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0038d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00395	e8 00 00 00 00	 call	 ieee_cond_trap
$LN13@s370_load_:
$LN12@s370_load_:

; 3332 :     }
; 3333 : }

  0039a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a2	48 33 cc	 xor	 rcx, rsp
  003a5	e8 00 00 00 00	 call	 __security_check_cookie
  003aa	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  003b1	5f		 pop	 rdi
  003b2	5e		 pop	 rsi
  003b3	c3		 ret	 0
s370_load_fp_int_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv151 = 40
tv154 = 44
tv156 = 48
tv157 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s370_load_complement_bfp_short_reg PROC

; 3629 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3630 :     int        r1, r2;
; 3631 :     float32_t  op;
; 3632 : 
; 3633 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3634 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3635 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3636 : 
; 3637 :     GET_FLOAT32_OP( op, r2, regs );

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float32

; 3638 :     op.v ^= 0x80000000;

  00109	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0010d	0f ba f8 1f	 btc	 eax, 31
  00111	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN7@s370_load_:

; 3639 : 
; 3640 :     PUT_FLOAT32_CC( op, r1, regs );

  00115	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00119	d1 e0		 shl	 eax, 1
  0011b	48 98		 cdqe
  0011d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00132	e8 00 00 00 00	 call	 s370_put_float32
  00137	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0013b	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00140	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00145	75 17		 jne	 SHORT $LN12@s370_load_
  00147	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0014b	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00150	85 c0		 test	 eax, eax
  00152	74 0a		 je	 SHORT $LN12@s370_load_
  00154	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0015c	eb 5e		 jmp	 SHORT $LN19@s370_load_
$LN12@s370_load_:
  0015e	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00162	0f ba f0 1f	 btr	 eax, 31
  00166	85 c0		 test	 eax, eax
  00168	75 0a		 jne	 SHORT $LN13@s370_load_
  0016a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00172	eb 08		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  00174	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s370_load_:
  0017c	83 7c 24 28 00	 cmp	 DWORD PTR tv151[rsp], 0
  00181	74 0a		 je	 SHORT $LN17@s370_load_
  00183	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  0018b	eb 27		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  0018d	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00191	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00196	85 c0		 test	 eax, eax
  00198	74 0a		 je	 SHORT $LN15@s370_load_
  0019a	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001a4	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s370_load_:
  001ac	8b 44 24 2c	 mov	 eax, DWORD PTR tv154[rsp]
  001b0	89 44 24 30	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s370_load_:
  001b4	8b 44 24 30	 mov	 eax, DWORD PTR tv156[rsp]
  001b8	89 44 24 34	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s370_load_:
  001bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv157[rsp]
  001c6	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  001c9	33 c0		 xor	 eax, eax
  001cb	85 c0		 test	 eax, eax
  001cd	0f 85 42 ff ff
	ff		 jne	 $LN7@s370_load_

; 3641 : }

  001d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d7	c3		 ret	 0
s370_load_complement_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv151 = 36
tv154 = 40
tv156 = 44
tv157 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s370_load_complement_bfp_long_reg PROC

; 3611 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3612 :     int        r1, r2;
; 3613 :     float64_t  op;
; 3614 : 
; 3615 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3616 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3617 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_load_
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_load_
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3618 : 
; 3619 :     GET_FLOAT64_OP( op, r2, regs );

  000e7	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float64

; 3620 :     op.v ^= 0x8000000000000000ULL;

  00109	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00118	48 33 c8	 xor	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN7@s370_load_:

; 3621 : 
; 3622 :     PUT_FLOAT64_CC( op, r1, regs );

  00123	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00127	d1 e0		 shl	 eax, 1
  00129	48 98		 cdqe
  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00138	48 8b d0	 mov	 rdx, rax
  0013b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00140	e8 00 00 00 00	 call	 s370_put_float64
  00145	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0014f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00154	48 23 c8	 and	 rcx, rax
  00157	48 8b c1	 mov	 rax, rcx
  0015a	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00164	48 3b c1	 cmp	 rax, rcx
  00167	75 24		 jne	 SHORT $LN12@s370_load_
  00169	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00178	48 23 c8	 and	 rcx, rax
  0017b	48 8b c1	 mov	 rax, rcx
  0017e	48 85 c0	 test	 rax, rax
  00181	74 0a		 je	 SHORT $LN12@s370_load_
  00183	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv157[rsp], 3
  0018b	eb 79		 jmp	 SHORT $LN19@s370_load_
$LN12@s370_load_:
  0018d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00197	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0019c	48 23 c8	 and	 rcx, rax
  0019f	48 8b c1	 mov	 rax, rcx
  001a2	48 85 c0	 test	 rax, rax
  001a5	75 0a		 jne	 SHORT $LN13@s370_load_
  001a7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  001b1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN14@s370_load_:
  001b9	83 7c 24 24 00	 cmp	 DWORD PTR tv151[rsp], 0
  001be	74 0a		 je	 SHORT $LN17@s370_load_
  001c0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  001c8	eb 34		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  001ca	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001d9	48 23 c8	 and	 rcx, rax
  001dc	48 8b c1	 mov	 rax, rcx
  001df	48 85 c0	 test	 rax, rax
  001e2	74 0a		 je	 SHORT $LN15@s370_load_
  001e4	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001ec	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001ee	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN16@s370_load_:
  001f6	8b 44 24 28	 mov	 eax, DWORD PTR tv154[rsp]
  001fa	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN18@s370_load_:
  001fe	8b 44 24 2c	 mov	 eax, DWORD PTR tv156[rsp]
  00202	89 44 24 30	 mov	 DWORD PTR tv157[rsp], eax
$LN19@s370_load_:
  00206	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv157[rsp]
  00210	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 06 ff ff
	ff		 jne	 $LN7@s370_load_

; 3623 : }

  0021d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00221	c3		 ret	 0
s370_load_complement_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv174 = 44
tv179 = 48
tv181 = 52
tv182 = 56
op$ = 64
__$ArrayPad$ = 80
inst$ = 112
regs$ = 120
s370_load_complement_bfp_ext_reg PROC

; 3592 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3593 :     int         r1, r2;
; 3594 :     float128_t  op;
; 3595 : 
; 3596 :     RRE( inst, regs, r1, r2 );

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 03	 imul	 rax, rax, 3
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00055	48 83 c0 04	 add	 rax, 4
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00062	33 c0		 xor	 eax, eax
  00064	83 f8 04	 cmp	 eax, 4
  00067	74 0c		 je	 SHORT $LN8@s370_load_
  00069	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 d1		 jne	 SHORT $LN4@s370_load_

; 3597 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3598 :     BFPINST_CHECK( regs );

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00090	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00095	85 c0		 test	 eax, eax
  00097	74 39		 je	 SHORT $LN10@s370_load_
  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a4	d1 e8		 shr	 eax, 1
  000a6	83 e0 01	 and	 eax, 1
  000a9	85 c0		 test	 eax, eax
  000ab	74 49		 je	 SHORT $LN9@s370_load_
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b9	b9 08 00 00 00	 mov	 ecx, 8
  000be	48 6b c9 01	 imul	 rcx, rcx, 1
  000c2	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000ce	85 c0		 test	 eax, eax
  000d0	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000d2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000e1	ba 07 00 00 00	 mov	 edx, 7
  000e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3599 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  000f6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000fa	83 e0 02	 and	 eax, 2
  000fd	85 c0		 test	 eax, eax
  000ff	75 0b		 jne	 SHORT $LN12@s370_load_
  00101	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00105	83 e0 02	 and	 eax, 2
  00108	85 c0		 test	 eax, eax
  0010a	74 15		 je	 SHORT $LN11@s370_load_
$LN12@s370_load_:
  0010c	ba 06 00 00 00	 mov	 edx, 6
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_load_:

; 3600 : 
; 3601 :     GET_FLOAT128_OP( op, r2, regs );

  00121	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00125	d1 e0		 shl	 eax, 1
  00127	48 98		 cdqe
  00129	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00136	48 8b d0	 mov	 rdx, rax
  00139	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  0013e	e8 00 00 00 00	 call	 s370_get_float128

; 3602 :     op.v[FLOAT128_HI] ^= 0x8000000000000000ULL;

  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 01	 imul	 rax, rax, 1
  0014c	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00156	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0015b	48 33 c1	 xor	 rax, rcx
  0015e	b9 08 00 00 00	 mov	 ecx, 8
  00163	48 6b c9 01	 imul	 rcx, rcx, 1
  00167	48 89 44 0c 40	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN7@s370_load_:

; 3603 : 
; 3604 :     PUT_FLOAT128_CC( op, r1, regs );

  0016c	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00170	d1 e0		 shl	 eax, 1
  00172	48 98		 cdqe
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00181	48 8b d0	 mov	 rdx, rax
  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00189	e8 00 00 00 00	 call	 s370_put_float128
  0018e	b8 08 00 00 00	 mov	 eax, 8
  00193	48 6b c0 01	 imul	 rax, rax, 1
  00197	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001a1	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001a6	48 23 c1	 and	 rax, rcx
  001a9	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001b3	48 3b c1	 cmp	 rax, rcx
  001b6	75 3e		 jne	 SHORT $LN15@s370_load_
  001b8	b8 08 00 00 00	 mov	 eax, 8
  001bd	48 6b c0 01	 imul	 rax, rax, 1
  001c1	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001cb	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  001d0	48 23 c1	 and	 rax, rcx
  001d3	48 85 c0	 test	 rax, rax
  001d6	75 11		 jne	 SHORT $LN14@s370_load_
  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 00	 imul	 rax, rax, 0
  001e1	48 83 7c 04 40
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  001e7	74 0d		 je	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  001e9	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv182[rsp], 3
  001f1	e9 93 00 00 00	 jmp	 $LN22@s370_load_
$LN15@s370_load_:
  001f6	b8 08 00 00 00	 mov	 eax, 8
  001fb	48 6b c0 01	 imul	 rax, rax, 1
  001ff	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00209	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0020e	48 23 c1	 and	 rax, rcx
  00211	b9 08 00 00 00	 mov	 ecx, 8
  00216	48 6b c9 00	 imul	 rcx, rcx, 0
  0021a	48 0b 44 0c 40	 or	 rax, QWORD PTR op$[rsp+rcx]
  0021f	48 85 c0	 test	 rax, rax
  00222	75 0a		 jne	 SHORT $LN16@s370_load_
  00224	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0022c	eb 08		 jmp	 SHORT $LN17@s370_load_
$LN16@s370_load_:
  0022e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN17@s370_load_:
  00236	83 7c 24 2c 00	 cmp	 DWORD PTR tv174[rsp], 0
  0023b	74 0a		 je	 SHORT $LN20@s370_load_
  0023d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
  00245	eb 3a		 jmp	 SHORT $LN21@s370_load_
$LN20@s370_load_:
  00247	b8 08 00 00 00	 mov	 eax, 8
  0024c	48 6b c0 01	 imul	 rax, rax, 1
  00250	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025a	48 8b 44 04 40	 mov	 rax, QWORD PTR op$[rsp+rax]
  0025f	48 23 c1	 and	 rax, rcx
  00262	48 85 c0	 test	 rax, rax
  00265	74 0a		 je	 SHORT $LN18@s370_load_
  00267	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  0026f	eb 08		 jmp	 SHORT $LN19@s370_load_
$LN18@s370_load_:
  00271	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv179[rsp], 2
$LN19@s370_load_:
  00279	8b 44 24 30	 mov	 eax, DWORD PTR tv179[rsp]
  0027d	89 44 24 34	 mov	 DWORD PTR tv181[rsp], eax
$LN21@s370_load_:
  00281	8b 44 24 34	 mov	 eax, DWORD PTR tv181[rsp]
  00285	89 44 24 38	 mov	 DWORD PTR tv182[rsp], eax
$LN22@s370_load_:
  00289	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0028e	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv182[rsp]
  00293	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00296	33 c0		 xor	 eax, eax
  00298	85 c0		 test	 eax, eax
  0029a	0f 85 cc fe ff
	ff		 jne	 $LN7@s370_load_

; 3605 : }

  002a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a5	48 33 cc	 xor	 rcx, rsp
  002a8	e8 00 00 00 00	 call	 __security_check_cookie
  002ad	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b1	c3		 ret	 0
s370_load_complement_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
op$ = 32
i$1 = 36
tv167 = 40
tv170 = 44
tv172 = 48
tv173 = 52
r2$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s370_load_and_test_bfp_short_reg PROC

; 3192 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3193 :     int        r1, r2;
; 3194 :     float32_t  op;
; 3195 : 
; 3196 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3197 : 
; 3198 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3199 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3200 : 
; 3201 :     GET_FLOAT32_OP( op, r2, regs );

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float32

; 3202 : 
; 3203 :     if (FLOAT32_ISNAN( op ))

  00109	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0010d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00112	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00117	75 65		 jne	 SHORT $LN11@s370_load_
  00119	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0011d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00122	85 c0		 test	 eax, eax
  00124	74 58		 je	 SHORT $LN11@s370_load_

; 3204 :     {
; 3205 :         if (f32_isSignalingNaN( op ))

  00126	8b 4c 24 20	 mov	 ecx, DWORD PTR op$[rsp]
  0012a	e8 00 00 00 00	 call	 f32_isSignalingNaN
  0012f	0f b6 c0	 movzx	 eax, al
  00132	85 c0		 test	 eax, eax
  00134	74 48		 je	 SHORT $LN12@s370_load_

; 3206 :         {
; 3207 :             if (regs->fpc & FPC_MASK_IMI)

  00136	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00141	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00146	85 c0		 test	 eax, eax
  00148	74 0e		 je	 SHORT $LN13@s370_load_

; 3208 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  0014a	b2 80		 mov	 dl, 128			; 00000080H
  0014c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	e8 00 00 00 00	 call	 ieee_trap
  00156	eb 26		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:

; 3209 :             else
; 3210 :             {
; 3211 :                 regs->fpc |= FPC_FLAG_SFI;

  00158	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00163	0f ba e8 17	 bts	 eax, 23
  00167	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3212 :                 FLOAT32_MAKE_QNAN( op );

  00172	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  00176	0f ba e8 16	 bts	 eax, 22
  0017a	89 44 24 20	 mov	 DWORD PTR op$[rsp], eax
$LN14@s370_load_:
$LN12@s370_load_:
$LN11@s370_load_:
$LN7@s370_load_:

; 3213 :             }
; 3214 :         }
; 3215 :     }
; 3216 : 
; 3217 :     PUT_FLOAT32_CC( op, r1, regs );

  0017e	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00182	d1 e0		 shl	 eax, 1
  00184	48 98		 cdqe
  00186	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00193	48 8b d0	 mov	 rdx, rax
  00196	48 8d 4c 24 20	 lea	 rcx, QWORD PTR op$[rsp]
  0019b	e8 00 00 00 00	 call	 s370_put_float32
  001a0	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001a4	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  001a9	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  001ae	75 17		 jne	 SHORT $LN16@s370_load_
  001b0	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001b4	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  001b9	85 c0		 test	 eax, eax
  001bb	74 0a		 je	 SHORT $LN16@s370_load_
  001bd	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv173[rsp], 3
  001c5	eb 5e		 jmp	 SHORT $LN23@s370_load_
$LN16@s370_load_:
  001c7	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001cb	0f ba f0 1f	 btr	 eax, 31
  001cf	85 c0		 test	 eax, eax
  001d1	75 0a		 jne	 SHORT $LN17@s370_load_
  001d3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  001db	eb 08		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  001dd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN18@s370_load_:
  001e5	83 7c 24 28 00	 cmp	 DWORD PTR tv167[rsp], 0
  001ea	74 0a		 je	 SHORT $LN21@s370_load_
  001ec	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
  001f4	eb 27		 jmp	 SHORT $LN22@s370_load_
$LN21@s370_load_:
  001f6	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  001fa	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001ff	85 c0		 test	 eax, eax
  00201	74 0a		 je	 SHORT $LN19@s370_load_
  00203	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  0020b	eb 08		 jmp	 SHORT $LN20@s370_load_
$LN19@s370_load_:
  0020d	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv170[rsp], 2
$LN20@s370_load_:
  00215	8b 44 24 2c	 mov	 eax, DWORD PTR tv170[rsp]
  00219	89 44 24 30	 mov	 DWORD PTR tv172[rsp], eax
$LN22@s370_load_:
  0021d	8b 44 24 30	 mov	 eax, DWORD PTR tv172[rsp]
  00221	89 44 24 34	 mov	 DWORD PTR tv173[rsp], eax
$LN23@s370_load_:
  00225	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0022a	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv173[rsp]
  0022f	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00232	33 c0		 xor	 eax, eax
  00234	85 c0		 test	 eax, eax
  00236	0f 85 42 ff ff
	ff		 jne	 $LN7@s370_load_

; 3218 : }

  0023c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00240	c3		 ret	 0
s370_load_and_test_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
tv167 = 36
tv170 = 40
tv172 = 44
tv173 = 48
r2$ = 52
r1$ = 56
op$ = 64
inst$ = 96
regs$ = 104
s370_load_and_test_bfp_long_reg PROC

; 3161 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3162 :     int        r1, r2;
; 3163 :     float64_t  op;
; 3164 : 
; 3165 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_load_
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 3166 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3167 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_load_
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_load_
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3168 : 
; 3169 :     GET_FLOAT64_OP( op, r2, regs );

  000e7	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float64

; 3170 : 
; 3171 :     if (FLOAT64_ISNAN( op ))

  00109	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00118	48 23 c8	 and	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00128	48 3b c1	 cmp	 rax, rcx
  0012b	0f 85 81 00 00
	00		 jne	 $LN11@s370_load_
  00131	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0013b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00140	48 23 c8	 and	 rcx, rax
  00143	48 8b c1	 mov	 rax, rcx
  00146	48 85 c0	 test	 rax, rax
  00149	74 67		 je	 SHORT $LN11@s370_load_

; 3172 :     {
; 3173 :         if (f64_isSignalingNaN( op ))

  0014b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00150	e8 00 00 00 00	 call	 f64_isSignalingNaN
  00155	0f b6 c0	 movzx	 eax, al
  00158	85 c0		 test	 eax, eax
  0015a	74 56		 je	 SHORT $LN12@s370_load_

; 3174 :         {
; 3175 :             if (regs->fpc & FPC_MASK_IMI)

  0015c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00161	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00167	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0016c	85 c0		 test	 eax, eax
  0016e	74 0e		 je	 SHORT $LN13@s370_load_

; 3176 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  00170	b2 80		 mov	 dl, 128			; 00000080H
  00172	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	e8 00 00 00 00	 call	 ieee_trap
  0017c	eb 34		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:

; 3177 :             else
; 3178 :             {
; 3179 :                 regs->fpc |= FPC_FLAG_SFI;

  0017e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00183	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00189	0f ba e8 17	 bts	 eax, 23
  0018d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3180 :                 FLOAT64_MAKE_QNAN( op );

  00198	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001a7	48 0b c8	 or	 rcx, rax
  001aa	48 8b c1	 mov	 rax, rcx
  001ad	48 89 44 24 40	 mov	 QWORD PTR op$[rsp], rax
$LN14@s370_load_:
$LN12@s370_load_:
$LN11@s370_load_:
$LN7@s370_load_:

; 3181 :             }
; 3182 :         }
; 3183 :     }
; 3184 : 
; 3185 :     PUT_FLOAT64_CC( op, r1, regs );

  001b2	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001b6	d1 e0		 shl	 eax, 1
  001b8	48 98		 cdqe
  001ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001c7	48 8b d0	 mov	 rdx, rax
  001ca	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op$[rsp]
  001cf	e8 00 00 00 00	 call	 s370_put_float64
  001d4	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  001de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  001e3	48 23 c8	 and	 rcx, rax
  001e6	48 8b c1	 mov	 rax, rcx
  001e9	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  001f3	48 3b c1	 cmp	 rax, rcx
  001f6	75 24		 jne	 SHORT $LN16@s370_load_
  001f8	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00202	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00207	48 23 c8	 and	 rcx, rax
  0020a	48 8b c1	 mov	 rax, rcx
  0020d	48 85 c0	 test	 rax, rax
  00210	74 0a		 je	 SHORT $LN16@s370_load_
  00212	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv173[rsp], 3
  0021a	eb 79		 jmp	 SHORT $LN23@s370_load_
$LN16@s370_load_:
  0021c	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00226	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0022b	48 23 c8	 and	 rcx, rax
  0022e	48 8b c1	 mov	 rax, rcx
  00231	48 85 c0	 test	 rax, rax
  00234	75 0a		 jne	 SHORT $LN17@s370_load_
  00236	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  0023e	eb 08		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  00240	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN18@s370_load_:
  00248	83 7c 24 24 00	 cmp	 DWORD PTR tv167[rsp], 0
  0024d	74 0a		 je	 SHORT $LN21@s370_load_
  0024f	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
  00257	eb 34		 jmp	 SHORT $LN22@s370_load_
$LN21@s370_load_:
  00259	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00263	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00268	48 23 c8	 and	 rcx, rax
  0026b	48 8b c1	 mov	 rax, rcx
  0026e	48 85 c0	 test	 rax, rax
  00271	74 0a		 je	 SHORT $LN19@s370_load_
  00273	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  0027b	eb 08		 jmp	 SHORT $LN20@s370_load_
$LN19@s370_load_:
  0027d	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv170[rsp], 2
$LN20@s370_load_:
  00285	8b 44 24 28	 mov	 eax, DWORD PTR tv170[rsp]
  00289	89 44 24 2c	 mov	 DWORD PTR tv172[rsp], eax
$LN22@s370_load_:
  0028d	8b 44 24 2c	 mov	 eax, DWORD PTR tv172[rsp]
  00291	89 44 24 30	 mov	 DWORD PTR tv173[rsp], eax
$LN23@s370_load_:
  00295	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv173[rsp]
  0029f	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  002a2	33 c0		 xor	 eax, eax
  002a4	85 c0		 test	 eax, eax
  002a6	0f 85 06 ff ff
	ff		 jne	 $LN7@s370_load_

; 3186 : }

  002ac	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002b0	c3		 ret	 0
s370_load_and_test_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
tv197 = 44
tv202 = 48
tv204 = 52
tv205 = 56
$T2 = 64
op$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
s370_load_and_test_bfp_ext_reg PROC

; 3129 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3130 :     int         r1, r2;
; 3131 :     float128_t  op;
; 3132 : 
; 3133 :     RRE( inst, regs, r1, r2 );

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 03	 imul	 rax, rax, 3
  00028	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00038	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00047	c1 f8 04	 sar	 eax, 4
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  00051	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 83 c0 04	 add	 rax, 4
  00061	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006d	33 c0		 xor	 eax, eax
  0006f	83 f8 04	 cmp	 eax, 4
  00072	74 0f		 je	 SHORT $LN8@s370_load_
  00074	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_load_:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 c8		 jne	 SHORT $LN4@s370_load_

; 3134 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3135 :     BFPINST_CHECK( regs );

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a6	85 c0		 test	 eax, eax
  000a8	74 3f		 je	 SHORT $LN10@s370_load_
  000aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 55		 je	 SHORT $LN9@s370_load_
  000c1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	b9 08 00 00 00	 mov	 ecx, 8
  000d5	48 6b c9 01	 imul	 rcx, rcx, 1
  000d9	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e5	85 c0		 test	 eax, eax
  000e7	75 2d		 jne	 SHORT $LN9@s370_load_
$LN10@s370_load_:
  000e9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fb	ba 07 00 00 00	 mov	 edx, 7
  00100	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_load_:

; 3136 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00116	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011a	83 e0 02	 and	 eax, 2
  0011d	85 c0		 test	 eax, eax
  0011f	75 0b		 jne	 SHORT $LN12@s370_load_
  00121	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00125	83 e0 02	 and	 eax, 2
  00128	85 c0		 test	 eax, eax
  0012a	74 1b		 je	 SHORT $LN11@s370_load_
$LN12@s370_load_:
  0012c	ba 06 00 00 00	 mov	 edx, 6
  00131	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00141	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_load_:

; 3137 : 
; 3138 :     GET_FLOAT128_OP( op, r2, regs );

  00147	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  0014b	d1 e0		 shl	 eax, 1
  0014d	48 98		 cdqe
  0014f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0015f	48 8b d0	 mov	 rdx, rax
  00162	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  00167	e8 00 00 00 00	 call	 s370_get_float128

; 3139 : 
; 3140 :     if (FLOAT128_ISNAN( op ))

  0016c	b8 08 00 00 00	 mov	 eax, 8
  00171	48 6b c0 01	 imul	 rax, rax, 1
  00175	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0017f	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  00184	48 23 c1	 and	 rax, rcx
  00187	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00191	48 3b c1	 cmp	 rax, rcx
  00194	0f 85 ce 00 00
	00		 jne	 $LN13@s370_load_
  0019a	b8 08 00 00 00	 mov	 eax, 8
  0019f	48 6b c0 01	 imul	 rax, rax, 1
  001a3	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001ad	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  001b2	48 23 c1	 and	 rax, rcx
  001b5	48 85 c0	 test	 rax, rax
  001b8	75 15		 jne	 SHORT $LN14@s370_load_
  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 00	 imul	 rax, rax, 0
  001c3	48 83 7c 04 50
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  001c9	0f 84 99 00 00
	00		 je	 $LN13@s370_load_
$LN14@s370_load_:

; 3141 :     {
; 3142 :         if (f128_isSignalingNaN( op ))

  001cf	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  001d4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  001d9	48 8b f8	 mov	 rdi, rax
  001dc	48 8b f1	 mov	 rsi, rcx
  001df	b9 10 00 00 00	 mov	 ecx, 16
  001e4	f3 a4		 rep movsb
  001e6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  001eb	e8 00 00 00 00	 call	 f128_isSignalingNaN
  001f0	0f b6 c0	 movzx	 eax, al
  001f3	85 c0		 test	 eax, eax
  001f5	74 71		 je	 SHORT $LN15@s370_load_

; 3143 :         {
; 3144 :             if (regs->fpc & FPC_MASK_IMI)

  001f7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ff	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00205	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0020a	85 c0		 test	 eax, eax
  0020c	74 11		 je	 SHORT $LN16@s370_load_

; 3145 :                 ieee_trap( regs, DXC_IEEE_INVALID_OP );

  0020e	b2 80		 mov	 dl, 128			; 00000080H
  00210	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	e8 00 00 00 00	 call	 ieee_trap
  0021d	eb 49		 jmp	 SHORT $LN17@s370_load_
$LN16@s370_load_:

; 3146 :             else
; 3147 :             {
; 3148 :                 regs->fpc |= FPC_FLAG_SFI;

  0021f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00227	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0022d	0f ba e8 17	 bts	 eax, 23
  00231	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 3149 :                 FLOAT128_MAKE_QNAN( op );

  0023f	b8 08 00 00 00	 mov	 eax, 8
  00244	48 6b c0 01	 imul	 rax, rax, 1
  00248	48 b9 00 00 00
	00 00 80 00 00	 mov	 rcx, 140737488355328	; 0000800000000000H
  00252	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  00257	48 0b c1	 or	 rax, rcx
  0025a	b9 08 00 00 00	 mov	 ecx, 8
  0025f	48 6b c9 01	 imul	 rcx, rcx, 1
  00263	48 89 44 0c 50	 mov	 QWORD PTR op$[rsp+rcx], rax
$LN17@s370_load_:
$LN15@s370_load_:
$LN13@s370_load_:
$LN7@s370_load_:

; 3150 :             }
; 3151 :         }
; 3152 :     }
; 3153 : 
; 3154 :     PUT_FLOAT128_CC( op, r1, regs );

  00268	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0026c	d1 e0		 shl	 eax, 1
  0026e	48 98		 cdqe
  00270	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00278	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00280	48 8b d0	 mov	 rdx, rax
  00283	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op$[rsp]
  00288	e8 00 00 00 00	 call	 s370_put_float128
  0028d	b8 08 00 00 00	 mov	 eax, 8
  00292	48 6b c0 01	 imul	 rax, rax, 1
  00296	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  002a0	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  002a5	48 23 c1	 and	 rax, rcx
  002a8	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  002b2	48 3b c1	 cmp	 rax, rcx
  002b5	75 3e		 jne	 SHORT $LN20@s370_load_
  002b7	b8 08 00 00 00	 mov	 eax, 8
  002bc	48 6b c0 01	 imul	 rax, rax, 1
  002c0	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  002ca	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  002cf	48 23 c1	 and	 rax, rcx
  002d2	48 85 c0	 test	 rax, rax
  002d5	75 11		 jne	 SHORT $LN19@s370_load_
  002d7	b8 08 00 00 00	 mov	 eax, 8
  002dc	48 6b c0 00	 imul	 rax, rax, 0
  002e0	48 83 7c 04 50
	00		 cmp	 QWORD PTR op$[rsp+rax], 0
  002e6	74 0d		 je	 SHORT $LN20@s370_load_
$LN19@s370_load_:
  002e8	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv205[rsp], 3
  002f0	e9 93 00 00 00	 jmp	 $LN27@s370_load_
$LN20@s370_load_:
  002f5	b8 08 00 00 00	 mov	 eax, 8
  002fa	48 6b c0 01	 imul	 rax, rax, 1
  002fe	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00308	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  0030d	48 23 c1	 and	 rax, rcx
  00310	b9 08 00 00 00	 mov	 ecx, 8
  00315	48 6b c9 00	 imul	 rcx, rcx, 0
  00319	48 0b 44 0c 50	 or	 rax, QWORD PTR op$[rsp+rcx]
  0031e	48 85 c0	 test	 rax, rax
  00321	75 0a		 jne	 SHORT $LN21@s370_load_
  00323	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv197[rsp], 1
  0032b	eb 08		 jmp	 SHORT $LN22@s370_load_
$LN21@s370_load_:
  0032d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv197[rsp], 0
$LN22@s370_load_:
  00335	83 7c 24 2c 00	 cmp	 DWORD PTR tv197[rsp], 0
  0033a	74 0a		 je	 SHORT $LN25@s370_load_
  0033c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
  00344	eb 3a		 jmp	 SHORT $LN26@s370_load_
$LN25@s370_load_:
  00346	b8 08 00 00 00	 mov	 eax, 8
  0034b	48 6b c0 01	 imul	 rax, rax, 1
  0034f	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00359	48 8b 44 04 50	 mov	 rax, QWORD PTR op$[rsp+rax]
  0035e	48 23 c1	 and	 rax, rcx
  00361	48 85 c0	 test	 rax, rax
  00364	74 0a		 je	 SHORT $LN23@s370_load_
  00366	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  0036e	eb 08		 jmp	 SHORT $LN24@s370_load_
$LN23@s370_load_:
  00370	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv202[rsp], 2
$LN24@s370_load_:
  00378	8b 44 24 30	 mov	 eax, DWORD PTR tv202[rsp]
  0037c	89 44 24 34	 mov	 DWORD PTR tv204[rsp], eax
$LN26@s370_load_:
  00380	8b 44 24 34	 mov	 eax, DWORD PTR tv204[rsp]
  00384	89 44 24 38	 mov	 DWORD PTR tv205[rsp], eax
$LN27@s370_load_:
  00388	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00390	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv205[rsp]
  00395	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00398	33 c0		 xor	 eax, eax
  0039a	85 c0		 test	 eax, eax
  0039c	0f 85 c6 fe ff
	ff		 jne	 $LN7@s370_load_

; 3155 : }

  003a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a7	48 33 cc	 xor	 rcx, rsp
  003aa	e8 00 00 00 00	 call	 __security_check_cookie
  003af	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003b3	5f		 pop	 rdi
  003b4	5e		 pop	 rsi
  003b5	c3		 ret	 0
s370_load_and_test_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
quo$ = 36
rem$ = 40
m4$ = 44
op1$ = 48
op2$ = 52
temp$1 = 56
op1_data_class$ = 60
op2_data_class$ = 64
r1$ = 68
r2$ = 72
r3$ = 76
tv190 = 80
ieee_trap_conds$ = 84
intquo64$2 = 88
op164$3 = 96
op264$4 = 104
quo64$5 = 112
rem64$6 = 120
inst$ = 144
regs$ = 152
s370_divide_integer_bfp_short_reg PROC

; 5329 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 5330 :     int        r1, r2, r3;
; 5331 :     BYTE       m4, newcc;
; 5332 :     float32_t  op1, op2;
; 5333 :     float32_t  rem, quo;
; 5334 :     U32        ieee_trap_conds = 0;

  00011	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 5335 :     U32        op1_data_class, op2_data_class;
; 5336 : 
; 5337 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00021	e8 00 00 00 00	 call	 fetch_fw_noswap
  00026	8b c8		 mov	 ecx, eax
  00028	e8 00 00 00 00	 call	 _byteswap_ulong
  0002d	89 44 24 38	 mov	 DWORD PTR temp$1[rsp], eax
  00031	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  0003c	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 04	 shr	 eax, 4
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  0004a	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 08	 shr	 eax, 8
  00051	83 e0 0f	 and	 eax, 15
  00054	88 44 24 2c	 mov	 BYTE PTR m4$[rsp], al
  00058	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 0c	 shr	 eax, 12
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 4c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_divid:
  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00072	48 83 c0 04	 add	 rax, 4
  00076	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00082	33 c0		 xor	 eax, eax
  00084	83 f8 04	 cmp	 eax, 4
  00087	74 0f		 je	 SHORT $LN8@s370_divid
  00089	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_divid:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 c8		 jne	 SHORT $LN4@s370_divid

; 5338 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5339 :     BFPINST_CHECK( regs );

  0009e	b8 08 00 00 00	 mov	 eax, 8
  000a3	48 6b c0 01	 imul	 rax, rax, 1
  000a7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b6	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bb	85 c0		 test	 eax, eax
  000bd	74 3f		 je	 SHORT $LN10@s370_divid
  000bf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000cd	d1 e8		 shr	 eax, 1
  000cf	83 e0 01	 and	 eax, 1
  000d2	85 c0		 test	 eax, eax
  000d4	74 55		 je	 SHORT $LN9@s370_divid
  000d6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e5	b9 08 00 00 00	 mov	 ecx, 8
  000ea	48 6b c9 01	 imul	 rcx, rcx, 1
  000ee	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000fa	85 c0		 test	 eax, eax
  000fc	75 2d		 jne	 SHORT $LN9@s370_divid
$LN10@s370_divid:
  000fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00106	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00110	ba 07 00 00 00	 mov	 edx, 7
  00115	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00125	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_divid:

; 5340 :     BFPRM_CHECK( m4, regs );

  0012b	0f b6 54 24 2c	 movzx	 edx, BYTE PTR m4$[rsp]
  00130	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 5341 : 
; 5342 :     if (r1 == r2 || r2 == r3 || r1 == r3)

  0013d	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  00141	39 44 24 44	 cmp	 DWORD PTR r1$[rsp], eax
  00145	74 14		 je	 SHORT $LN12@s370_divid
  00147	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  0014b	39 44 24 48	 cmp	 DWORD PTR r2$[rsp], eax
  0014f	74 0a		 je	 SHORT $LN12@s370_divid
  00151	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  00155	39 44 24 44	 cmp	 DWORD PTR r1$[rsp], eax
  00159	75 1b		 jne	 SHORT $LN11@s370_divid
$LN12@s370_divid:

; 5343 :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0015b	ba 06 00 00 00	 mov	 edx, 6
  00160	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_divid:
$LN7@s370_divid:

; 5344 : 
; 5345 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  00176	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  0017a	d1 e0		 shl	 eax, 1
  0017c	48 98		 cdqe
  0017e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0018e	48 8b d0	 mov	 rdx, rax
  00191	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op1$[rsp]
  00196	e8 00 00 00 00	 call	 s370_get_float32
  0019b	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  0019f	d1 e0		 shl	 eax, 1
  001a1	48 98		 cdqe
  001a3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b3	48 8b d0	 mov	 rdx, rax
  001b6	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op2$[rsp]
  001bb	e8 00 00 00 00	 call	 s370_get_float32
  001c0	33 c0		 xor	 eax, eax
  001c2	85 c0		 test	 eax, eax
  001c4	75 b0		 jne	 SHORT $LN7@s370_divid

; 5346 : 
; 5347 :     op1_data_class = float32_class( op1 );

  001c6	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  001ca	e8 00 00 00 00	 call	 float32_class
  001cf	89 44 24 3c	 mov	 DWORD PTR op1_data_class$[rsp], eax

; 5348 :     op2_data_class = float32_class( op2 );

  001d3	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  001d7	e8 00 00 00 00	 call	 float32_class
  001dc	89 44 24 40	 mov	 DWORD PTR op2_data_class$[rsp], eax

; 5349 : 
; 5350 :     softfloat_exceptionFlags = 0;

  001e0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e5	8b c0		 mov	 eax, eax
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ed	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001fa	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5351 : 
; 5352 :     /************************************************************************************/
; 5353 :     /* Following if / else if / else implements a decision tree based on SA-22-7832-10  */
; 5354 :     /* Table 19-21 parts 1 and 2 on pages 19-29 and 19-30 respectively.                 */
; 5355 :     /*                                                                                  */
; 5356 :     /* ORDER OF TESTS IS IMPORTANT                                                      */
; 5357 :     /*                                                                                  */
; 5358 :     /*  1. Tests for cases that include two non-finite non-zeroes.                      */
; 5359 :     /*  2. Tests for cases that include one or two NaNs as input values                 */
; 5360 :     /*  3. Tests for cases that always generate the default quiet NaN                   */
; 5361 :     /*  4. Tests for cases that generate non-NaN results.                               */
; 5362 :     /*                                                                                  */
; 5363 :     /* When viewed from the perspective of Table 19-21, this order:                     */
; 5364 :     /*                                                                                  */
; 5365 :     /*  1. Addresses what is likely to be the most frequent case first                  */
; 5366 :     /*  2. Removes the bottom two rows and the right-hand two columns                   */
; 5367 :     /*  3. Removes the center two colums and the top and new bottom rows                */
; 5368 :     /*  4. Leaves only those cases that involve returning a zero or operand as a result.*/
; 5369 :     /*                                                                                  */
; 5370 :     /************************************************************************************/
; 5371 : 
; 5372 :     /************************************************************************************/
; 5373 :     /* Group 1: Tests for cases with finite non-zeros for both operands.  This is seen  */
; 5374 :     /* as the most frequent case, and should therefore be tested first.                 */
; 5375 :     /************************************************************************************/
; 5376 : 
; 5377 :                                                                     /* Both operands finite numbers?*/
; 5378 :     if ((op1_data_class & (float_class_neg_normal
; 5379 :                          | float_class_pos_normal
; 5380 :                          | float_class_neg_subnormal
; 5381 :                          | float_class_pos_subnormal))
; 5382 :         &&

  001fe	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00202	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  00207	85 c0		 test	 eax, eax
  00209	0f 84 a5 04 00
	00		 je	 $LN13@s370_divid
  0020f	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00213	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  00218	85 c0		 test	 eax, eax
  0021a	0f 84 94 04 00
	00		 je	 $LN13@s370_divid

; 5383 :         (op2_data_class & (float_class_neg_normal
; 5384 :                          | float_class_pos_normal
; 5385 :                          | float_class_neg_subnormal
; 5386 :                          | float_class_pos_subnormal))
; 5387 :     )
; 5388 :     {                                                               /* ..yes, we can do division */
; 5389 : 
; 5390 :         newcc = 0;                                                  /* Initial cc set to zero    */

  00220	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 5391 :         SET_SF_RM_FROM_MASK( m4 );

  00225	0f b6 44 24 2c	 movzx	 eax, BYTE PTR m4$[rsp]
  0022a	85 c0		 test	 eax, eax
  0022c	74 16		 je	 SHORT $LN37@s370_divid
  0022e	0f b6 44 24 2c	 movzx	 eax, BYTE PTR m4$[rsp]
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0023a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023e	89 44 24 50	 mov	 DWORD PTR tv190[rsp], eax
  00242	eb 22		 jmp	 SHORT $LN38@s370_divid
$LN37@s370_divid:
  00244	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00252	83 e0 07	 and	 eax, 7
  00255	8b c0		 mov	 eax, eax
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0025e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00262	89 44 24 50	 mov	 DWORD PTR tv190[rsp], eax
$LN38@s370_divid:
  00266	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0026b	8b c0		 mov	 eax, eax
  0026d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00273	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00280	0f b6 54 24 50	 movzx	 edx, BYTE PTR tv190[rsp]
  00285	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 5392 : 
; 5393 :         quo = f32_div( op1, op2 );                                  /* calculate precise quotient                       */

  00288	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0028c	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00290	e8 00 00 00 00	 call	 f32_div
  00295	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5394 :         quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode            */

  00299	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0029e	8b c0		 mov	 eax, eax
  002a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b3	41 b0 01	 mov	 r8b, 1
  002b6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002ba	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  002be	e8 00 00 00 00	 call	 f32_roundToInt
  002c3	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5395 : 
; 5396 :         softfloat_exceptionFlags &= softfloat_flag_overflow;        /* Quotient only cares about overflow               */

  002c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002cc	8b c0		 mov	 eax, eax
  002ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e5	83 e0 04	 and	 eax, 4
  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f7	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  002fd	45 8b c0	 mov	 r8d, r8d
  00300	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00304	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5397 :         SET_SF_RM_FROM_FPC;                                         /* Set rounding mode from FPC for final remainder   */

  00308	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00310	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00316	83 e0 07	 and	 eax, 7
  00319	8b c0		 mov	 eax, eax
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00322	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00327	8b d2		 mov	 edx, edx
  00329	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00330	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00339	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  0033d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00341	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5398 :         quo.v ^= 0x80000000;                                        /* Reverse sign of integer quotient                 */

  00345	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00349	0f ba f8 1f	 btc	 eax, 31
  0034d	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5399 :         rem = f32_mulAdd(quo, op2, op1);                            /* Calculate remainder                              */

  00351	44 8b 44 24 30	 mov	 r8d, DWORD PTR op1$[rsp]
  00356	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0035a	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0035e	e8 00 00 00 00	 call	 f32_mulAdd
  00363	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5400 :         quo.v ^= 0x80000000;                                        /* Return sign of integer quotient to original value*/

  00367	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0036b	0f ba f8 1f	 btc	 eax, 31
  0036f	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5401 : 
; 5402 :         if (!(rem.v & 0x7fffffff))                                  /* Is remainder zero?                               */

  00373	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  00377	0f ba f0 1f	 btr	 eax, 31
  0037b	85 c0		 test	 eax, eax
  0037d	75 17		 jne	 SHORT $LN15@s370_divid

; 5403 :             rem.v = (op1.v & 0x80000000) | (rem.v & 0x7fffffff);    /* ..yes, ensure remainder sign matches dividend    */

  0037f	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00383	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00388	8b 4c 24 28	 mov	 ecx, DWORD PTR rem$[rsp]
  0038c	0f ba f1 1f	 btr	 ecx, 31
  00390	0b c1		 or	 eax, ecx
  00392	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
$LN15@s370_divid:

; 5404 : 
; 5405 :         if (!softfloat_exceptionFlags)                              /* If no exceptions, check for partial results      */

  00396	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0039b	8b c0		 mov	 eax, eax
  0039d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003a3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003ac	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b4	85 c0		 test	 eax, eax
  003b6	0f 85 fb 00 00
	00		 jne	 $LN16@s370_divid

; 5406 :         {
; 5407 :             if (((quo.v & 0x7fffffff) > 0x4B800000) && (rem.v & 0x7fffffff))  /* Quotient > 2^24th & rem <>0?           */

  003bc	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  003c0	0f ba f0 1f	 btr	 eax, 31
  003c4	3d 00 00 80 4b	 cmp	 eax, 1266679808		; 4b800000H
  003c9	0f 86 e3 00 00
	00		 jbe	 $LN18@s370_divid
  003cf	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  003d3	0f ba f0 1f	 btr	 eax, 31
  003d7	85 c0		 test	 eax, eax
  003d9	0f 84 d3 00 00
	00		 je	 $LN18@s370_divid

; 5408 :             {
; 5409 :                 newcc += 2;                                         /* ..yes, indicate partial results in cc            */

  003df	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  003e4	83 c0 02	 add	 eax, 2
  003e7	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5410 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  003eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  003f0	8b c0		 mov	 eax, eax
  003f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003f8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00401	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00405	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5411 :                                                                     /* ..with rounding toward zero                      */
; 5412 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  00409	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0040e	8b c0		 mov	 eax, eax
  00410	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00416	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0041f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00423	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5413 : 
; 5414 :                 quo = f32_div( op1, op2 );                          /* calculate precise quotient                       */

  00427	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0042b	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  0042f	e8 00 00 00 00	 call	 f32_div
  00434	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5415 :                 quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  00438	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0043d	8b c0		 mov	 eax, eax
  0043f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00445	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0044e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00452	41 b0 01	 mov	 r8b, 1
  00455	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00459	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0045d	e8 00 00 00 00	 call	 f32_roundToInt
  00462	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5416 : 
; 5417 :                 quo.v ^= 0x80000000;                                /* Reverse sign of integer quotient                 */

  00466	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0046a	0f ba f8 1f	 btc	 eax, 31
  0046e	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5418 : 
; 5419 :                 rem = f32_mulAdd( quo, op2, op1 );                  /* Calculate remainder                              */

  00472	44 8b 44 24 30	 mov	 r8d, DWORD PTR op1$[rsp]
  00477	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0047b	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0047f	e8 00 00 00 00	 call	 f32_mulAdd
  00484	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5420 : 
; 5421 :                 quo.v ^= 0x80000000;                                /* Return sign of integer quotient to original value*/

  00488	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0048c	0f ba f8 1f	 btc	 eax, 31
  00490	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5422 :                 softfloat_exceptionFlags = 0;                       /* No exceptions or flags on partial results        */

  00494	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00499	8b c0		 mov	 eax, eax
  0049b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004a1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004aa	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004ae	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN18@s370_divid:

; 5423 :             }
; 5424 :         }

  004b2	e9 f8 01 00 00	 jmp	 $LN17@s370_divid
$LN16@s370_divid:

; 5425 :         else                                                        /* Exception flagged...we have work to do.          */
; 5426 :         {                                                                                                          
; 5427 :             if (softfloat_exceptionFlags & softfloat_flag_overflow) /* on oveflow, scale result and set cc=1 or 3       */

  004b7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  004bc	8b c0		 mov	 eax, eax
  004be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004c4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004cd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d5	83 e0 04	 and	 eax, 4
  004d8	85 c0		 test	 eax, eax
  004da	0f 84 85 01 00
	00		 je	 $LN19@s370_divid

; 5428 :                                                                     /* and recalculate the remainder using a scaled     */
; 5429 :                                                                     /* quotient in 64-bit precision                     */
; 5430 :                                                                     /* Note that there is no fractional part to the     */
; 5431 :                                                                     /* quotient when the quotient overflows             */
; 5432 :             {
; 5433 :                 float64_t  quo64, intquo64, rem64;
; 5434 :                 float64_t  op164, op264;
; 5435 : 
; 5436 :                 newcc += 1;                                         /* Set condition code odd for quotient overflow     */

  004e0	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  004e5	ff c0		 inc	 eax
  004e7	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5437 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  004eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  004f0	8b c0		 mov	 eax, eax
  004f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004f8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00501	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00505	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5438 :                                                                     /* ..with rounding toward zero                      */
; 5439 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  00509	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0050e	8b c0		 mov	 eax, eax
  00510	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00516	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0051f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00523	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5440 : 
; 5441 :                 quo = f32_div( op1, op2 );                          /* calculate precise quotient                       */

  00527	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  0052b	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  0052f	e8 00 00 00 00	 call	 f32_div
  00534	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5442 :                 quo = f32_roundToInt( quo, softfloat_roundingMode, TRUE ); /* Partial result, round to zero             */

  00538	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0053d	8b c0		 mov	 eax, eax
  0053f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00545	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0054e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00552	41 b0 01	 mov	 r8b, 1
  00555	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00559	8b 4c 24 24	 mov	 ecx, DWORD PTR quo$[rsp]
  0055d	e8 00 00 00 00	 call	 f32_roundToInt
  00562	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5443 :                 quo = f32_scaledResult( SCALE_FACTOR_ARITH_OFLOW_SHORT );  /* Scale quotient                            */

  00566	b9 40 ff ff ff	 mov	 ecx, -192		; ffffffffffffff40H
  0056b	e8 00 00 00 00	 call	 f32_scaledResult
  00570	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5444 : 
; 5445 :                 op164 = f32_to_f64( op1 );

  00574	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00578	e8 00 00 00 00	 call	 f32_to_f64
  0057d	48 89 44 24 60	 mov	 QWORD PTR op164$3[rsp], rax

; 5446 :                 op264 = f32_to_f64( op2 );

  00582	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  00586	e8 00 00 00 00	 call	 f32_to_f64
  0058b	48 89 44 24 68	 mov	 QWORD PTR op264$4[rsp], rax

; 5447 : 
; 5448 :                 softfloat_roundingMode = softfloat_round_minMag;

  00590	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00595	8b c0		 mov	 eax, eax
  00597	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0059d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005aa	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5449 : 
; 5450 :                 quo64 = f64_div( op164, op264 );

  005ae	48 8b 54 24 68	 mov	 rdx, QWORD PTR op264$4[rsp]
  005b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op164$3[rsp]
  005b8	e8 00 00 00 00	 call	 f64_div
  005bd	48 89 44 24 70	 mov	 QWORD PTR quo64$5[rsp], rax

; 5451 : 
; 5452 :                 intquo64.v = quo64.v & 0xFFFFFFFFE0000000ULL;       /* Truncate significand to BFP Short bits           */

  005c2	48 8b 44 24 70	 mov	 rax, QWORD PTR quo64$5[rsp]
  005c7	48 25 00 00 00
	e0		 and	 rax, -536870912		; ffffffffe0000000H
  005cd	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5453 :                 intquo64.v ^= 0x8000000000000000ULL;                /* flip sign of dividend for fused multiply-add     */

  005d2	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  005dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  005e1	48 33 c8	 xor	 rcx, rax
  005e4	48 8b c1	 mov	 rax, rcx
  005e7	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5454 : 
; 5455 :                 rem64 = f64_mulAdd( intquo64, op264, op164 );       /* -rem = intquo * divisor + (-dividend)            */

  005ec	4c 8b 44 24 60	 mov	 r8, QWORD PTR op164$3[rsp]
  005f1	48 8b 54 24 68	 mov	 rdx, QWORD PTR op264$4[rsp]
  005f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  005fb	e8 00 00 00 00	 call	 f64_mulAdd
  00600	48 89 44 24 78	 mov	 QWORD PTR rem64$6[rsp], rax

; 5456 : 
; 5457 :                 intquo64.v ^= 0x8000000000000000ULL;                /* Restore sign of dividend                         */

  00605	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0060f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR intquo64$2[rsp]
  00614	48 33 c8	 xor	 rcx, rax
  00617	48 8b c1	 mov	 rax, rcx
  0061a	48 89 44 24 58	 mov	 QWORD PTR intquo64$2[rsp], rax

; 5458 :                 softfloat_exceptionFlags = 0;                       /* clear any prior Softfloat flags                  */

  0061f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00624	8b c0		 mov	 eax, eax
  00626	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0062c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00635	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00639	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5459 : 
; 5460 :                 rem = f64_to_f32( rem64 );                          /* should be exact!?)                               */

  0063d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rem64$6[rsp]
  00642	e8 00 00 00 00	 call	 f64_to_f32
  00647	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5461 : 
; 5462 :                 if (rem.v & 0x7fffffff)                             /* non-zero remainder?                              */

  0064b	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  0064f	0f ba f0 1f	 btr	 eax, 31
  00653	85 c0		 test	 eax, eax
  00655	74 0c		 je	 SHORT $LN21@s370_divid

; 5463 :                     newcc += 2;                                     /* yes, indicate partial results                    */

  00657	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  0065c	83 c0 02	 add	 eax, 2
  0065f	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al
$LN21@s370_divid:

; 5464 :             }

  00663	eb 4a		 jmp	 SHORT $LN20@s370_divid
$LN19@s370_divid:

; 5465 :             else if (softfloat_exceptionFlags & (softfloat_flag_tiny | softfloat_flag_underflow))

  00665	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0066a	8b c0		 mov	 eax, eax
  0066c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00672	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0067b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0067f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00683	83 e0 42	 and	 eax, 66			; 00000042H
  00686	85 c0		 test	 eax, eax
  00688	74 25		 je	 SHORT $LN22@s370_divid

; 5466 :             {
; 5467 :                 /* Inexact and underflow'ed remainder issues and traps are handled by code at the end of Divide To Integer  */
; 5468 :                 /* But because this is the only situation where the remainder might need scaling, we will do it here        */
; 5469 :                 if (regs->fpc & FPC_MASK_IMU)

  0068a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00692	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00698	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0069d	85 c0		 test	 eax, eax
  0069f	74 0e		 je	 SHORT $LN23@s370_divid

; 5470 :                     rem = f32_scaledResult(SCALE_FACTOR_ARITH_UFLOW_SHORT);

  006a1	b9 c0 00 00 00	 mov	 ecx, 192		; 000000c0H
  006a6	e8 00 00 00 00	 call	 f32_scaledResult
  006ab	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
$LN23@s370_divid:
$LN22@s370_divid:
$LN20@s370_divid:
$LN17@s370_divid:

; 5471 :             }
; 5472 :         }
; 5473 :     }

  006af	e9 c2 01 00 00	 jmp	 $LN14@s370_divid
$LN13@s370_divid:

; 5474 : 
; 5475 :     /************************************************************************************/
; 5476 :     /* Group 2: tests for cases with NaNs for one or both operands                      */
; 5477 :     /* The sequence is required to ensure that the generated results match the IBM NaN  */
; 5478 :     /* propagation rules shown in Table 19-21                                           */
; 5479 :     /************************************************************************************/
; 5480 : 
; 5481 :     /* ******* NEXT FOUR TESTS, ALL GROUP 2 TESTS, MUST REMAIN IN SEQUENCE *******      */
; 5482 :     else if (op1_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* first case: op1 an SNaN?  */

  006b4	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  006b8	83 e0 03	 and	 eax, 3
  006bb	85 c0		 test	 eax, eax
  006bd	74 67		 je	 SHORT $LN24@s370_divid

; 5483 :     {
; 5484 :         quo = op1;

  006bf	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  006c3	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5485 :         FLOAT32_MAKE_QNAN( quo );

  006c7	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  006cb	0f ba e8 16	 bts	 eax, 22
  006cf	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5486 :         rem = quo;

  006d3	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  006d7	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5487 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  006db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  006e0	8b c0		 mov	 eax, eax
  006e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  006e8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  006f1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  006f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006f9	83 c8 10	 or	 eax, 16
  006fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00702	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0070b	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00711	45 8b c0	 mov	 r8d, r8d
  00714	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00718	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5488 :         newcc = 1;                                                                               /* Any NaN returns cc=1      */

  0071c	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5489 :     }

  00721	e9 50 01 00 00	 jmp	 $LN25@s370_divid
$LN24@s370_divid:

; 5490 :     else if (op2_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* second case: op2 an SNaN? */

  00726	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  0072a	83 e0 03	 and	 eax, 3
  0072d	85 c0		 test	 eax, eax
  0072f	74 67		 je	 SHORT $LN26@s370_divid

; 5491 :     {
; 5492 :         quo = op2;

  00731	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  00735	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5493 :         FLOAT32_MAKE_QNAN( quo );

  00739	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  0073d	0f ba e8 16	 bts	 eax, 22
  00741	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5494 :         rem = quo;

  00745	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  00749	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5495 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  0074d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00752	8b c0		 mov	 eax, eax
  00754	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0075a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00763	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00767	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0076b	83 c8 10	 or	 eax, 16
  0076e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00774	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0077d	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00783	45 8b c0	 mov	 r8d, r8d
  00786	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0078a	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5496 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  0078e	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5497 :     }

  00793	e9 de 00 00 00	 jmp	 $LN27@s370_divid
$LN26@s370_divid:

; 5498 :     else if (op1_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* third case: op1 a QNaN?    */

  00798	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  0079c	83 e0 0c	 and	 eax, 12
  0079f	85 c0		 test	 eax, eax
  007a1	74 1a		 je	 SHORT $LN28@s370_divid

; 5499 :     {
; 5500 :         rem = quo = op1;

  007a3	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  007a7	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax
  007ab	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  007af	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5501 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  007b3	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5502 :     }

  007b8	e9 b9 00 00 00	 jmp	 $LN29@s370_divid
$LN28@s370_divid:

; 5503 :     else if (op2_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* fourth case: op2 a QNaN?   */

  007bd	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  007c1	83 e0 0c	 and	 eax, 12
  007c4	85 c0		 test	 eax, eax
  007c6	74 1a		 je	 SHORT $LN30@s370_divid

; 5504 :     {
; 5505 :         rem = quo = op2;

  007c8	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  007cc	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax
  007d0	8b 44 24 24	 mov	 eax, DWORD PTR quo$[rsp]
  007d4	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5506 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  007d8	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5507 :     }

  007dd	e9 94 00 00 00	 jmp	 $LN31@s370_divid
$LN30@s370_divid:

; 5508 :     /* END OF FOUR TESTS THAT MUST REMAIN IN SEQUENCE                                   */
; 5509 : 
; 5510 :     /************************************************************************************/
; 5511 :     /* NEXT TEST MUST FOLLOW ALL FOUR NAN TESTS                                         */
; 5512 :     /* Group 3: Test cases that generate the default NaN and IEEE exception Invalid     */
; 5513 :     /* If operand 1 is an infinity OR operand two is a zero, and none of the above      */
; 5514 :     /* conditions are met, i.e., neither operand is a NaN, return a default NaN         */
; 5515 :     /************************************************************************************/
; 5516 : 
; 5517 :     else if ((op1_data_class & (float_class_neg_infinity | float_class_pos_infinity))           /* Operand 1 an infinity?     */
; 5518 :          ||  (op2_data_class & (float_class_neg_zero     | float_class_pos_zero))               /* ..or operand 2 a zero?     */

  007e2	8b 44 24 3c	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  007e6	83 e0 30	 and	 eax, 48			; 00000030H
  007e9	85 c0		 test	 eax, eax
  007eb	75 0d		 jne	 SHORT $LN34@s370_divid
  007ed	8b 44 24 40	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  007f1	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  007f6	85 c0		 test	 eax, eax
  007f8	74 5a		 je	 SHORT $LN32@s370_divid
$LN34@s370_divid:

; 5519 :     )
; 5520 :     {                                                                                           /* ..yes, return DNaN, raise invalid  */
; 5521 :         quo = rem = float32_default_qnan;

  007fa	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR float32_default_qnan
  00800	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax
  00804	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  00808	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5522 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  0080c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00811	8b c0		 mov	 eax, eax
  00813	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00819	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00822	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00826	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0082a	83 c8 10	 or	 eax, 16
  0082d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00833	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0083c	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00842	45 8b c0	 mov	 r8d, r8d
  00845	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00849	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5523 :         newcc = 1;

  0084d	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5524 :     }

  00852	eb 22		 jmp	 SHORT $LN33@s370_divid
$LN32@s370_divid:

; 5525 :     /* ABOVE TEST MUST IMMEDIATELY FOLLOW ALL FOUR NAN TESTS                            */
; 5526 : 
; 5527 :     /************************************************************************************/
; 5528 :     /* Group 4: Tests for cases that generate zero or an operand value as a result.     */
; 5529 :     /*                                                                                  */
; 5530 :     /* At this point, only the remaining operand combinations remain:                   */
; 5531 :     /* - Operand 1 is zero and operand 2 is non-zero (either finite or infinity)        */
; 5532 :     /* - Operand 1 is finite and operand 2 is infinity                                  */
; 5533 :     /*                                                                                  */
; 5534 :     /* The result is the same for each of the above: Operand 1 becomes the remainder,   */
; 5535 :     /* and the quotient is zero with a signed determined by the signs of the operands.  */
; 5536 :     /* Exclusive Or sets the sign correctly.                                            */
; 5537 :     /************************************************************************************/
; 5538 :     else
; 5539 :     {
; 5540 :         rem = op1;                                          /* remainder is operand 1                       */

  00854	8b 44 24 30	 mov	 eax, DWORD PTR op1$[rsp]
  00858	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 5541 :         quo.v = (op1.v ^ op2.v) & 0x80000000;               /* quotient zero, sign is exclusive or of operand signs   */

  0085c	8b 44 24 34	 mov	 eax, DWORD PTR op2$[rsp]
  00860	8b 4c 24 30	 mov	 ecx, DWORD PTR op1$[rsp]
  00864	33 c8		 xor	 ecx, eax
  00866	8b c1		 mov	 eax, ecx
  00868	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0086d	89 44 24 24	 mov	 DWORD PTR quo$[rsp], eax

; 5542 :         newcc = 0;

  00871	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0
$LN33@s370_divid:
$LN31@s370_divid:
$LN29@s370_divid:
$LN27@s370_divid:
$LN25@s370_divid:
$LN14@s370_divid:

; 5543 :     }
; 5544 : 
; 5545 :     IEEE_EXCEPTION_TRAP_XI( regs );                         /* IEEE Invalid Exception raised and trappable?         */

  00876	33 c0		 xor	 eax, eax
  00878	83 f8 01	 cmp	 eax, 1
  0087b	74 4b		 je	 SHORT $LN35@s370_divid
  0087d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00882	8b c0		 mov	 eax, eax
  00884	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0088a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00893	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00897	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0089b	83 e0 10	 and	 eax, 16
  0089e	85 c0		 test	 eax, eax
  008a0	74 26		 je	 SHORT $LN35@s370_divid
  008a2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008aa	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  008b0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  008b5	85 c0		 test	 eax, eax
  008b7	74 0f		 je	 SHORT $LN35@s370_divid
  008b9	b2 80		 mov	 dl, 128			; 00000080H
  008bb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008c3	e8 00 00 00 00	 call	 ieee_trap
$LN35@s370_divid:

; 5546 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  008c8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008d0	e8 00 00 00 00	 call	 ieee_exception_test_oux
  008d5	89 44 24 54	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5547 : 
; 5548 :     /* *********** Underflow flag means remainder underflowed.  It has already been scaled if necessary             */
; 5549 : 
; 5550 :     regs->psw.cc = newcc;

  008d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e1	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  008e6	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5551 : 
; 5552 :     PUT_FLOAT32_NOCC( rem, r1, regs );

  008e9	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  008ed	d1 e0		 shl	 eax, 1
  008ef	48 98		 cdqe
  008f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f9	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00901	48 8b d0	 mov	 rdx, rax
  00904	48 8d 4c 24 28	 lea	 rcx, QWORD PTR rem$[rsp]
  00909	e8 00 00 00 00	 call	 s370_put_float32

; 5553 :     PUT_FLOAT32_NOCC( quo, r3, regs );

  0090e	8b 44 24 4c	 mov	 eax, DWORD PTR r3$[rsp]
  00912	d1 e0		 shl	 eax, 1
  00914	48 98		 cdqe
  00916	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0091e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00926	48 8b d0	 mov	 rdx, rax
  00929	48 8d 4c 24 24	 lea	 rcx, QWORD PTR quo$[rsp]
  0092e	e8 00 00 00 00	 call	 s370_put_float32

; 5554 : 
; 5555 :     ieee_cond_trap( regs, ieee_trap_conds );

  00933	8b 54 24 54	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00937	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093f	e8 00 00 00 00	 call	 ieee_cond_trap

; 5556 : }

  00944	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0094b	c3		 ret	 0
s370_divide_integer_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
quo$ = 40
m4$ = 48
rem$ = 56
op1$ = 64
op2$ = 72
temp$1 = 80
op1_data_class$ = 84
op2_data_class$ = 88
r1$ = 92
r2$ = 96
r3$ = 100
tv190 = 104
ieee_trap_conds$ = 108
$T2 = 112
$T3 = 128
$T4 = 144
$T5 = 160
$T6 = 176
$T7 = 192
$T8 = 208
$T9 = 224
$T10 = 240
$T11 = 256
$T12 = 272
$T13 = 288
intquo128$14 = 304
quo128$15 = 320
op1128$16 = 336
op2128$17 = 352
rem128$18 = 368
__$ArrayPad$ = 384
inst$ = 432
regs$ = 440
s370_divide_integer_bfp_long_reg PROC

; 5099 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5100 :     int        r1, r2, r3;
; 5101 :     BYTE       m4, newcc;
; 5102 :     float64_t  op1, op2;
; 5103 :     float64_t  quo, rem;
; 5104 :     U32        ieee_trap_conds = 0;

  00025	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 5105 :     U32        op1_data_class, op2_data_class;
; 5106 : 
; 5107 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  0002d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 60	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 5c	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 30	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	89 44 24 64	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_divid:
  0007a	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN8@s370_divid
  0009d	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_divid:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s370_divid

; 5108 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5109 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN10@s370_divid
  000d3	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN9@s370_divid
  000ea	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN9@s370_divid
$LN10@s370_divid:
  00112	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_divid:

; 5110 :     BFPRM_CHECK( m4,regs );

  0013f	0f b6 54 24 30	 movzx	 edx, BYTE PTR m4$[rsp]
  00144	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 5111 : 
; 5112 :     if (r1 == r2 || r2 == r3 || r1 == r3)

  00151	8b 44 24 60	 mov	 eax, DWORD PTR r2$[rsp]
  00155	39 44 24 5c	 cmp	 DWORD PTR r1$[rsp], eax
  00159	74 14		 je	 SHORT $LN12@s370_divid
  0015b	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  0015f	39 44 24 60	 cmp	 DWORD PTR r2$[rsp], eax
  00163	74 0a		 je	 SHORT $LN12@s370_divid
  00165	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  00169	39 44 24 5c	 cmp	 DWORD PTR r1$[rsp], eax
  0016d	75 1b		 jne	 SHORT $LN11@s370_divid
$LN12@s370_divid:

; 5113 :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0016f	ba 06 00 00 00	 mov	 edx, 6
  00174	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017c	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00184	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_divid:
$LN7@s370_divid:

; 5114 : 
; 5115 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  0018a	8b 44 24 5c	 mov	 eax, DWORD PTR r1$[rsp]
  0018e	d1 e0		 shl	 eax, 1
  00190	48 98		 cdqe
  00192	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001a2	48 8b d0	 mov	 rdx, rax
  001a5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  001aa	e8 00 00 00 00	 call	 s370_get_float64
  001af	8b 44 24 60	 mov	 eax, DWORD PTR r2$[rsp]
  001b3	d1 e0		 shl	 eax, 1
  001b5	48 98		 cdqe
  001b7	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001c7	48 8b d0	 mov	 rdx, rax
  001ca	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  001cf	e8 00 00 00 00	 call	 s370_get_float64
  001d4	33 c0		 xor	 eax, eax
  001d6	85 c0		 test	 eax, eax
  001d8	75 b0		 jne	 SHORT $LN7@s370_divid

; 5116 : 
; 5117 :     op1_data_class = float64_class( op1 );

  001da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  001df	e8 00 00 00 00	 call	 float64_class
  001e4	89 44 24 54	 mov	 DWORD PTR op1_data_class$[rsp], eax

; 5118 :     op2_data_class = float64_class( op2 );

  001e8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  001ed	e8 00 00 00 00	 call	 float64_class
  001f2	89 44 24 58	 mov	 DWORD PTR op2_data_class$[rsp], eax

; 5119 : 
; 5120 :     softfloat_exceptionFlags = 0;

  001f6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001fb	8b c0		 mov	 eax, eax
  001fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00203	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0020c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00210	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5121 : 
; 5122 :     /************************************************************************************/
; 5123 :     /* Following if / else if / else implements a decision tree based on SA-22-7832-10  */
; 5124 :     /* Table 19-21 parts 1 and 2 on pages 19-29 and 19-30 respectively.                 */
; 5125 :     /*                                                                                  */
; 5126 :     /* ORDER OF TESTS IS IMPORTANT                                                      */
; 5127 :     /*                                                                                  */
; 5128 :     /*  1. Tests for cases that include two non-finite non-zeroes.                      */
; 5129 :     /*  2. Tests for cases that include one or two NaNs as input values                 */
; 5130 :     /*  3. Tests for cases that always generate the default quiet NaN                   */
; 5131 :     /*  4. Tests for cases that generate non-NaN results.                               */
; 5132 :     /*                                                                                  */
; 5133 :     /* When viewed from the perspective of Table 19-21, this order:                     */
; 5134 :     /*                                                                                  */
; 5135 :     /*  1. Addresses what is likely to be the most frequent case first                  */
; 5136 :     /*  2. Removes the bottom two rows and the right-hand two columns                   */
; 5137 :     /*  3. Removes the center two colums and the top and new bottom rows                */
; 5138 :     /*  4. Leaves only those cases that involve returning a zero or operand as a result.*/
; 5139 :     /*                                                                                  */
; 5140 :     /************************************************************************************/
; 5141 : 
; 5142 :     /************************************************************************************/
; 5143 :     /* Group 1: Tests for cases with finite non-zeros for both operands.  This is seen  */
; 5144 :     /* as the most frequent case, and should therefore be tested first.                 */
; 5145 :     /************************************************************************************/
; 5146 : 
; 5147 :                                                                     /* Both operands finite numbers?*/
; 5148 :     if ((op1_data_class & (float_class_neg_normal
; 5149 :                          | float_class_pos_normal
; 5150 :                          | float_class_neg_subnormal
; 5151 :                          | float_class_pos_subnormal))
; 5152 :         &&

  00214	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00218	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  0021d	85 c0		 test	 eax, eax
  0021f	0f 84 1f 07 00
	00		 je	 $LN13@s370_divid
  00225	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00229	25 c0 03 00 00	 and	 eax, 960		; 000003c0H
  0022e	85 c0		 test	 eax, eax
  00230	0f 84 0e 07 00
	00		 je	 $LN13@s370_divid

; 5153 :         (op2_data_class & (float_class_neg_normal
; 5154 :                          | float_class_pos_normal
; 5155 :                          | float_class_neg_subnormal
; 5156 :                          | float_class_pos_subnormal))
; 5157 :     )
; 5158 :     {                                                               /* ..yes, we can do division */
; 5159 :         newcc = 0;                                                  /* Initial cc set to zero    */

  00236	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 5160 :         SET_SF_RM_FROM_MASK( m4 );

  0023b	0f b6 44 24 30	 movzx	 eax, BYTE PTR m4$[rsp]
  00240	85 c0		 test	 eax, eax
  00242	74 16		 je	 SHORT $LN37@s370_divid
  00244	0f b6 44 24 30	 movzx	 eax, BYTE PTR m4$[rsp]
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00250	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00254	89 44 24 68	 mov	 DWORD PTR tv190[rsp], eax
  00258	eb 22		 jmp	 SHORT $LN38@s370_divid
$LN37@s370_divid:
  0025a	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00262	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00268	83 e0 07	 and	 eax, 7
  0026b	8b c0		 mov	 eax, eax
  0026d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00274	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00278	89 44 24 68	 mov	 DWORD PTR tv190[rsp], eax
$LN38@s370_divid:
  0027c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00281	8b c0		 mov	 eax, eax
  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00289	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00292	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00296	0f b6 54 24 68	 movzx	 edx, BYTE PTR tv190[rsp]
  0029b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 5161 : 
; 5162 :         quo = f64_div( op1, op2 );                                  /* calculate precise quotient                       */

  0029e	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  002a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  002a8	e8 00 00 00 00	 call	 f64_div
  002ad	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5163 :         quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode            */

  002b2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002b7	8b c0		 mov	 eax, eax
  002b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002bf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002c8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002cc	41 b0 01	 mov	 r8b, 1
  002cf	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  002d8	e8 00 00 00 00	 call	 f64_roundToInt
  002dd	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5164 : 
; 5165 :         softfloat_exceptionFlags &= softfloat_flag_overflow;        /* Quotient only cares about overflow               */

  002e2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e7	8b c0		 mov	 eax, eax
  002e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ef	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00300	83 e0 04	 and	 eax, 4
  00303	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00309	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00312	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00318	45 8b c0	 mov	 r8d, r8d
  0031b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0031f	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 5166 :         SET_SF_RM_FROM_FPC;                                         /* Set rounding mode from FPC for final remainder   */

  00323	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00331	83 e0 07	 and	 eax, 7
  00334	8b c0		 mov	 eax, eax
  00336	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0033d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00342	8b d2		 mov	 edx, edx
  00344	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0034b	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00354	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00358	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035c	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 5167 :         quo.v ^= 0x8000000000000000ULL;                             /* Reverse sign of integer quotient                 */

  00360	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0036a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0036f	48 33 c8	 xor	 rcx, rax
  00372	48 8b c1	 mov	 rax, rcx
  00375	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5168 :         rem = f64_mulAdd( quo, op2, op1 );                          /* Calculate remainder                              */

  0037a	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  0037f	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00384	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00389	e8 00 00 00 00	 call	 f64_mulAdd
  0038e	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5169 :         quo.v ^= 0x8000000000000000ULL;                             /* Return sign of integer quotient to original value*/

  00393	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0039d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  003a2	48 33 c8	 xor	 rcx, rax
  003a5	48 8b c1	 mov	 rax, rcx
  003a8	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5170 : 
; 5171 :         if (!(rem.v & 0x7fffffffffffffffULL))                       /* Is remainder zero?                               */

  003ad	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  003b7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  003bc	48 23 c8	 and	 rcx, rax
  003bf	48 8b c1	 mov	 rax, rcx
  003c2	48 85 c0	 test	 rax, rax
  003c5	75 32		 jne	 SHORT $LN15@s370_divid

; 5172 :             rem.v = (op1.v & 0x8000000000000000ULL) | (rem.v & 0x7fffffffffffffffULL);

  003c7	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  003d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  003d6	48 23 c8	 and	 rcx, rax
  003d9	48 8b c1	 mov	 rax, rcx
  003dc	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  003e6	48 8b 54 24 38	 mov	 rdx, QWORD PTR rem$[rsp]
  003eb	48 23 d1	 and	 rdx, rcx
  003ee	48 8b ca	 mov	 rcx, rdx
  003f1	48 0b c1	 or	 rax, rcx
  003f4	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
$LN15@s370_divid:

; 5173 :                                                                     /* ..yes, ensure remainder sign matches dividend    */
; 5174 :         if (!softfloat_exceptionFlags)                              /* If no exceptions, check for partial results      */

  003f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003fe	8b c0		 mov	 eax, eax
  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00406	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0040f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00413	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00417	85 c0		 test	 eax, eax
  00419	0f 85 42 01 00
	00		 jne	 $LN16@s370_divid

; 5175 :         {
; 5176 :             if (((quo.v & 0x7fffffffffffffffULL) > 0x4340000000000000ULL) && (rem.v & 0x7fffffffffffffffULL))

  0041f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00429	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0042e	48 23 c8	 and	 rcx, rax
  00431	48 8b c1	 mov	 rax, rcx
  00434	48 b9 00 00 00
	00 00 00 40 43	 mov	 rcx, 4845873199050653696 ; 4340000000000000H
  0043e	48 3b c1	 cmp	 rax, rcx
  00441	0f 86 15 01 00
	00		 jbe	 $LN18@s370_divid
  00447	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00451	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  00456	48 23 c8	 and	 rcx, rax
  00459	48 8b c1	 mov	 rax, rcx
  0045c	48 85 c0	 test	 rax, rax
  0045f	0f 84 f7 00 00
	00		 je	 $LN18@s370_divid

; 5177 :             {                                                       /* Quotient > 2^24th & rem <>0?                     */
; 5178 :                 newcc += 2;                                         /* ..yes, indicate partial results in cc            */

  00465	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  0046a	83 c0 02	 add	 eax, 2
  0046d	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5179 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  00471	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00476	8b c0		 mov	 eax, eax
  00478	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0047e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00487	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0048b	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5180 :                                                                     /* ..with rounding toward zero                      */
; 5181 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  0048f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00494	8b c0		 mov	 eax, eax
  00496	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0049c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004a5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004a9	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5182 : 
; 5183 :                 quo = f64_div( op1, op2 );                          /* calculate precise quotient                       */

  004ad	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  004b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  004b7	e8 00 00 00 00	 call	 f64_div
  004bc	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5184 :                 quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  004c1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  004c6	8b c0		 mov	 eax, eax
  004c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  004ce	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  004d7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  004db	41 b0 01	 mov	 r8b, 1
  004de	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  004e2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  004e7	e8 00 00 00 00	 call	 f64_roundToInt
  004ec	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5185 : 
; 5186 :                 quo.v ^= 0x8000000000000000ULL;                     /* Reverse sign of integer quotient                 */

  004f1	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  004fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00500	48 33 c8	 xor	 rcx, rax
  00503	48 8b c1	 mov	 rax, rcx
  00506	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5187 :                 rem = f64_mulAdd( quo, op2, op1 );                  /* Calculate remainder                              */

  0050b	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  00510	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00515	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0051a	e8 00 00 00 00	 call	 f64_mulAdd
  0051f	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5188 :                 quo.v ^= 0x8000000000000000ULL;                     /* Return sign of integer quotient to original value*/

  00524	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0052e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00533	48 33 c8	 xor	 rcx, rax
  00536	48 8b c1	 mov	 rax, rcx
  00539	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5189 :                 softfloat_exceptionFlags = 0;                       /* No exceptions or flags on partial results        */

  0053e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00543	8b c0		 mov	 eax, eax
  00545	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0054b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00554	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00558	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN18@s370_divid:

; 5190 :             }
; 5191 :         }

  0055c	e9 de 03 00 00	 jmp	 $LN17@s370_divid
$LN16@s370_divid:

; 5192 :         else                                                        /* Exception flagged...we have work to do.          */
; 5193 :         {
; 5194 :             if (softfloat_exceptionFlags & softfloat_flag_overflow) /* on oveflow, scale result and set cc=1 or 3       */

  00561	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00566	8b c0		 mov	 eax, eax
  00568	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0056e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00577	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0057b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0057f	83 e0 04	 and	 eax, 4
  00582	85 c0		 test	 eax, eax
  00584	0f 84 6a 03 00
	00		 je	 $LN19@s370_divid

; 5195 :                                                                     /* and recalculate the remainder using a scaled     */
; 5196 :                                                                     /* quotient in 64-bit precision                     */
; 5197 :             {
; 5198 :                 float128_t  quo128, intquo128, rem128;
; 5199 :                 float128_t  op1128, op2128;
; 5200 : 
; 5201 :                 newcc += 1;                                         /* Set condition code odd for quotient overflow     */

  0058a	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  0058f	ff c0		 inc	 eax
  00591	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 5202 :                 softfloat_roundingMode = softfloat_round_minMag;    /* Repeat calculation of quotient/remainder         */

  00595	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0059a	8b c0		 mov	 eax, eax
  0059c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005a2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005ab	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005af	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5203 :                                                                     /* ..with rounding toward zero                      */
; 5204 :                 softfloat_exceptionFlags = 0;                       /* Clear all prior flags                            */

  005b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  005b8	8b c0		 mov	 eax, eax
  005ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005c0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005c9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005cd	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5205 : 
; 5206 :                 quo = f64_div( op1, op2 );                          /* calculate precise quotient                       */

  005d1	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  005d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  005db	e8 00 00 00 00	 call	 f64_div
  005e0	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5207 :                 quo = f64_roundToInt( quo, softfloat_roundingMode, TRUE );  /* Round to integer per m4 rounding mode    */

  005e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  005ea	8b c0		 mov	 eax, eax
  005ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  005f2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  005fb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005ff	41 b0 01	 mov	 r8b, 1
  00602	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00606	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  0060b	e8 00 00 00 00	 call	 f64_roundToInt
  00610	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5208 :                 quo = f64_scaledResult( SCALE_FACTOR_ARITH_OFLOW_LONG );

  00615	b9 00 fa ff ff	 mov	 ecx, -1536		; fffffffffffffa00H
  0061a	e8 00 00 00 00	 call	 f64_scaledResult
  0061f	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5209 : 
; 5210 :                 op1128 = f64_to_f128( op1 );

  00624	48 8b 54 24 40	 mov	 rdx, QWORD PTR op1$[rsp]
  00629	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00631	e8 00 00 00 00	 call	 f64_to_f128
  00636	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  0063e	48 8b f9	 mov	 rdi, rcx
  00641	48 8b f0	 mov	 rsi, rax
  00644	b9 10 00 00 00	 mov	 ecx, 16
  00649	f3 a4		 rep movsb

; 5211 :                 op2128 = f64_to_f128( op2 );

  0064b	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  00650	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  00658	e8 00 00 00 00	 call	 f64_to_f128
  0065d	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  00665	48 8b f9	 mov	 rdi, rcx
  00668	48 8b f0	 mov	 rsi, rax
  0066b	b9 10 00 00 00	 mov	 ecx, 16
  00670	f3 a4		 rep movsb

; 5212 : 
; 5213 :                 softfloat_roundingMode = softfloat_round_minMag;

  00672	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00677	8b c0		 mov	 eax, eax
  00679	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0067f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00688	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0068c	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5214 : 
; 5215 :                 quo128 = f128_div( op1128, op2128 );

  00690	48 8d 44 24 70	 lea	 rax, QWORD PTR $T2[rsp]
  00695	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  0069d	48 8b f8	 mov	 rdi, rax
  006a0	48 8b f1	 mov	 rsi, rcx
  006a3	b9 10 00 00 00	 mov	 ecx, 16
  006a8	f3 a4		 rep movsb
  006aa	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T3[rsp]
  006b2	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  006ba	48 8b f8	 mov	 rdi, rax
  006bd	48 8b f1	 mov	 rsi, rcx
  006c0	b9 10 00 00 00	 mov	 ecx, 16
  006c5	f3 a4		 rep movsb
  006c7	4c 8d 44 24 70	 lea	 r8, QWORD PTR $T2[rsp]
  006cc	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T3[rsp]
  006d4	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  006dc	e8 00 00 00 00	 call	 f128_div
  006e1	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR quo128$15[rsp]
  006e9	48 8b f9	 mov	 rdi, rcx
  006ec	48 8b f0	 mov	 rsi, rax
  006ef	b9 10 00 00 00	 mov	 ecx, 16
  006f4	f3 a4		 rep movsb

; 5216 :                 quo128.v[FLOAT128_LO] &= 0xf000000000000000ULL;     /* truncate to long precision with extended exponent*/

  006f6	b8 08 00 00 00	 mov	 eax, 8
  006fb	48 6b c0 00	 imul	 rax, rax, 0
  006ff	48 b9 00 00 00
	00 00 00 00 f0	 mov	 rcx, -1152921504606846976 ; f000000000000000H
  00709	48 8b 84 04 40
	01 00 00	 mov	 rax, QWORD PTR quo128$15[rsp+rax]
  00711	48 23 c1	 and	 rax, rcx
  00714	b9 08 00 00 00	 mov	 ecx, 8
  00719	48 6b c9 00	 imul	 rcx, rcx, 0
  0071d	48 89 84 0c 40
	01 00 00	 mov	 QWORD PTR quo128$15[rsp+rcx], rax

; 5217 : 
; 5218 :                 intquo128 = f128_roundToInt( quo128, softfloat_round_minMag, FALSE );

  00725	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  0072d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR quo128$15[rsp]
  00735	48 8b f8	 mov	 rdi, rax
  00738	48 8b f1	 mov	 rsi, rcx
  0073b	b9 10 00 00 00	 mov	 ecx, 16
  00740	f3 a4		 rep movsb
  00742	45 33 c9	 xor	 r9d, r9d
  00745	41 b0 01	 mov	 r8b, 1
  00748	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T4[rsp]
  00750	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  00758	e8 00 00 00 00	 call	 f128_roundToInt
  0075d	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR intquo128$14[rsp]
  00765	48 8b f9	 mov	 rdi, rcx
  00768	48 8b f0	 mov	 rsi, rax
  0076b	b9 10 00 00 00	 mov	 ecx, 16
  00770	f3 a4		 rep movsb

; 5219 :                 intquo128.v[FLOAT128_HI] ^= 0x8000000000000000ULL;  /* flip sign of dividend for fused multiply-add     */

  00772	b8 08 00 00 00	 mov	 eax, 8
  00777	48 6b c0 01	 imul	 rax, rax, 1
  0077b	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00785	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR intquo128$14[rsp+rax]
  0078d	48 33 c1	 xor	 rax, rcx
  00790	b9 08 00 00 00	 mov	 ecx, 8
  00795	48 6b c9 01	 imul	 rcx, rcx, 1
  00799	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR intquo128$14[rsp+rcx], rax

; 5220 : 
; 5221 :                 rem128 = f128_mulAdd( intquo128, op2128, op1128 );  /* rem = (-intquo * divisor) + dividend             */

  007a1	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  007a9	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR op1128$16[rsp]
  007b1	48 8b f8	 mov	 rdi, rax
  007b4	48 8b f1	 mov	 rsi, rcx
  007b7	b9 10 00 00 00	 mov	 ecx, 16
  007bc	f3 a4		 rep movsb
  007be	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  007c6	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR op2128$17[rsp]
  007ce	48 8b f8	 mov	 rdi, rax
  007d1	48 8b f1	 mov	 rsi, rcx
  007d4	b9 10 00 00 00	 mov	 ecx, 16
  007d9	f3 a4		 rep movsb
  007db	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  007e3	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR intquo128$14[rsp]
  007eb	48 8b f8	 mov	 rdi, rax
  007ee	48 8b f1	 mov	 rsi, rcx
  007f1	b9 10 00 00 00	 mov	 ecx, 16
  007f6	f3 a4		 rep movsb
  007f8	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR $T5[rsp]
  00800	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR $T6[rsp]
  00808	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  00810	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  00818	e8 00 00 00 00	 call	 f128_mulAdd
  0081d	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR rem128$18[rsp]
  00825	48 8b f9	 mov	 rdi, rcx
  00828	48 8b f0	 mov	 rsi, rax
  0082b	b9 10 00 00 00	 mov	 ecx, 16
  00830	f3 a4		 rep movsb

; 5222 : 
; 5223 :                 intquo128.v[FLOAT128_HI] ^= 0x8000000000000000ULL;  /* Restore sign of dividend                         */

  00832	b8 08 00 00 00	 mov	 eax, 8
  00837	48 6b c0 01	 imul	 rax, rax, 1
  0083b	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00845	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR intquo128$14[rsp+rax]
  0084d	48 33 c1	 xor	 rax, rcx
  00850	b9 08 00 00 00	 mov	 ecx, 8
  00855	48 6b c9 01	 imul	 rcx, rcx, 1
  00859	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR intquo128$14[rsp+rcx], rax

; 5224 :                 softfloat_exceptionFlags = 0;                       /* clear any prior Softfloat flags                  */

  00861	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00866	8b c0		 mov	 eax, eax
  00868	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0086e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00877	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0087b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 5225 :                 softfloat_roundingMode = softfloat_round_minMag;    /* round remainder toward zero (but remainder       */

  0087f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00884	8b c0		 mov	 eax, eax
  00886	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0088c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00895	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00899	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 5226 : 
; 5227 :                 rem = f128_to_f64( rem128 );                        /* should be exact!?)                               */

  0089d	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  008a5	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR rem128$18[rsp]
  008ad	48 8b f8	 mov	 rdi, rax
  008b0	48 8b f1	 mov	 rsi, rcx
  008b3	b9 10 00 00 00	 mov	 ecx, 16
  008b8	f3 a4		 rep movsb
  008ba	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  008c2	e8 00 00 00 00	 call	 f128_to_f64
  008c7	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5228 : 
; 5229 :                 if (rem.v & 0x7fffffffffffffffULL)                  /* non-zero remainder?                              */

  008cc	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  008d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rem$[rsp]
  008db	48 23 c8	 and	 rcx, rax
  008de	48 8b c1	 mov	 rax, rcx
  008e1	48 85 c0	 test	 rax, rax
  008e4	74 0c		 je	 SHORT $LN21@s370_divid

; 5230 :                     newcc += 2;                                     /* yes, indicate partial results                    */

  008e6	0f b6 44 24 20	 movzx	 eax, BYTE PTR newcc$[rsp]
  008eb	83 c0 02	 add	 eax, 2
  008ee	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al
$LN21@s370_divid:

; 5231 : 
; 5232 :             }

  008f2	eb 4b		 jmp	 SHORT $LN20@s370_divid
$LN19@s370_divid:

; 5233 :             else if (softfloat_exceptionFlags & (softfloat_flag_tiny | softfloat_flag_underflow))

  008f4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  008f9	8b c0		 mov	 eax, eax
  008fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00901	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0090a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0090e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00912	83 e0 42	 and	 eax, 66			; 00000042H
  00915	85 c0		 test	 eax, eax
  00917	74 26		 je	 SHORT $LN22@s370_divid

; 5234 :             {
; 5235 :                 /* Inexact and underflow'ed remainder issues and traps are handled by code at the end of Divide To Integer  */
; 5236 :                 /* But because this is the only situation where the remainder might need scaling, we will do it here        */
; 5237 :                 if (regs->fpc & FPC_MASK_IMU)

  00919	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00921	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00927	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0092c	85 c0		 test	 eax, eax
  0092e	74 0f		 je	 SHORT $LN23@s370_divid

; 5238 :                     rem = f64_scaledResult( SCALE_FACTOR_ARITH_UFLOW_LONG );

  00930	b9 00 06 00 00	 mov	 ecx, 1536		; 00000600H
  00935	e8 00 00 00 00	 call	 f64_scaledResult
  0093a	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
$LN23@s370_divid:
$LN22@s370_divid:
$LN20@s370_divid:
$LN17@s370_divid:

; 5239 :             }
; 5240 :         }
; 5241 :     }

  0093f	e9 f8 01 00 00	 jmp	 $LN14@s370_divid
$LN13@s370_divid:

; 5242 : 
; 5243 :     /************************************************************************************/
; 5244 :     /* Group 2: tests for cases with NaNs for one or both operands                      */
; 5245 :     /* The sequence is required to ensure that the generated results match the IBM NaN  */
; 5246 :     /* propagation rules shown in Table 19-21                                           */
; 5247 :     /************************************************************************************/
; 5248 : 
; 5249 :     /* ******* NEXT FOUR TESTS, ALL GROUP 2 TESTS, MUST REMAIN IN SEQUENCE *******      */
; 5250 :     else if (op1_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* first case: op1 an SNaN?  */

  00944	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00948	83 e0 03	 and	 eax, 3
  0094b	85 c0		 test	 eax, eax
  0094d	74 76		 je	 SHORT $LN24@s370_divid

; 5251 :     {
; 5252 :         quo = op1;

  0094f	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  00954	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5253 :         FLOAT64_MAKE_QNAN( quo );

  00959	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  00963	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  00968	48 0b c8	 or	 rcx, rax
  0096b	48 8b c1	 mov	 rax, rcx
  0096e	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5254 :         rem = quo;

  00973	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00978	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5255 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  0097d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00982	8b c0		 mov	 eax, eax
  00984	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0098a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00993	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00997	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0099b	83 c8 10	 or	 eax, 16
  0099e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  009a4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  009ad	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  009b2	8b ff		 mov	 edi, edi
  009b4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  009b8	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5256 :         newcc = 1;                                                                               /* Any NaN returns cc=1      */

  009bb	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5257 :     }

  009c0	e9 77 01 00 00	 jmp	 $LN25@s370_divid
$LN24@s370_divid:

; 5258 :     else if (op2_data_class & (float_class_neg_signaling_nan | float_class_pos_signaling_nan))   /* second case: op2 an SNaN? */

  009c5	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  009c9	83 e0 03	 and	 eax, 3
  009cc	85 c0		 test	 eax, eax
  009ce	74 76		 je	 SHORT $LN26@s370_divid

; 5259 :     {
; 5260 :         quo = op2;

  009d0	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  009d5	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5261 :         FLOAT64_MAKE_QNAN( quo );

  009da	48 b8 00 00 00
	00 00 00 08 00	 mov	 rax, 2251799813685248	; 0008000000000000H
  009e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quo$[rsp]
  009e9	48 0b c8	 or	 rcx, rax
  009ec	48 8b c1	 mov	 rax, rcx
  009ef	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5262 :         rem = quo;

  009f4	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  009f9	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5263 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  009fe	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00a03	8b c0		 mov	 eax, eax
  00a05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00a0b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00a14	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00a18	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a1c	83 c8 10	 or	 eax, 16
  00a1f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00a25	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00a2e	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00a33	8b ff		 mov	 edi, edi
  00a35	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00a39	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5264 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00a3c	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5265 :     }

  00a41	e9 f6 00 00 00	 jmp	 $LN27@s370_divid
$LN26@s370_divid:

; 5266 :     else if (op1_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* third case: op1 a QNaN?    */

  00a46	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00a4a	83 e0 0c	 and	 eax, 12
  00a4d	85 c0		 test	 eax, eax
  00a4f	74 1e		 je	 SHORT $LN28@s370_divid

; 5267 :     {
; 5268 :         rem = quo = op1;

  00a51	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  00a56	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax
  00a5b	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00a60	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5269 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00a65	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5270 :     }

  00a6a	e9 cd 00 00 00	 jmp	 $LN29@s370_divid
$LN28@s370_divid:

; 5271 :     else if (op2_data_class & (float_class_neg_quiet_nan | float_class_pos_quiet_nan))          /* fourth case: op2 a QNaN?   */

  00a6f	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00a73	83 e0 0c	 and	 eax, 12
  00a76	85 c0		 test	 eax, eax
  00a78	74 1e		 je	 SHORT $LN30@s370_divid

; 5272 :     {
; 5273 :         rem = quo = op2;

  00a7a	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  00a7f	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax
  00a84	48 8b 44 24 28	 mov	 rax, QWORD PTR quo$[rsp]
  00a89	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5274 :         newcc = 1;                                                                              /* Any NaN returns cc=1       */

  00a8e	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5275 :     }

  00a93	e9 a4 00 00 00	 jmp	 $LN31@s370_divid
$LN30@s370_divid:

; 5276 :     /* END OF FOUR TESTS THAT MUST REMAIN IN SEQUENCE                                   */
; 5277 : 
; 5278 :     /************************************************************************************/
; 5279 :     /* NEXT TEST MUST FOLLOW ALL FOUR NAN TESTS                                         */
; 5280 :     /* Group 3: Test cases that generate the default NaN and IEEE exception Invalid     */
; 5281 :     /* If operand 1 is an infinity OR operand two is a zero, and none of the above      */
; 5282 :     /* conditions are met, i.e., neither operand is a NaN, return a default NaN         */
; 5283 :     /************************************************************************************/
; 5284 :     else if ((op1_data_class & (float_class_neg_infinity | float_class_pos_infinity))           /* Operand 1 an infinity?             */
; 5285 :          ||  (op2_data_class & (float_class_neg_zero     | float_class_pos_zero))               /* ..or operand 2 a zero?             */

  00a98	8b 44 24 54	 mov	 eax, DWORD PTR op1_data_class$[rsp]
  00a9c	83 e0 30	 and	 eax, 48			; 00000030H
  00a9f	85 c0		 test	 eax, eax
  00aa1	75 0d		 jne	 SHORT $LN34@s370_divid
  00aa3	8b 44 24 58	 mov	 eax, DWORD PTR op2_data_class$[rsp]
  00aa7	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00aac	85 c0		 test	 eax, eax
  00aae	74 5b		 je	 SHORT $LN32@s370_divid
$LN34@s370_divid:

; 5286 :     )
; 5287 :     {                                                                                           /* ..yes, return DNaN, raise invalid  */
; 5288 :         quo = rem = float64_default_qnan;

  00ab0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR float64_default_qnan
  00ab7	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax
  00abc	48 8b 44 24 38	 mov	 rax, QWORD PTR rem$[rsp]
  00ac1	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5289 :         softfloat_exceptionFlags |= softfloat_flag_invalid;

  00ac6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00acb	8b c0		 mov	 eax, eax
  00acd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00ad3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00adc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00ae0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ae4	83 c8 10	 or	 eax, 16
  00ae7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00aed	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00af6	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00afb	8b ff		 mov	 edi, edi
  00afd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b01	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 5290 :         newcc = 1;

  00b04	c6 44 24 20 01	 mov	 BYTE PTR newcc$[rsp], 1

; 5291 :     }

  00b09	eb 31		 jmp	 SHORT $LN33@s370_divid
$LN32@s370_divid:

; 5292 :     /* ABOVE TEST MUST IMMEDIATELY FOLLOW ALL FOUR NAN TESTS                            */
; 5293 : 
; 5294 :     /************************************************************************************/
; 5295 :     /* Group 4: Tests for cases that generate zero or an operand value as a result.     */
; 5296 :     /*                                                                                  */
; 5297 :     /* At this point, only the remaining operand combinations remain:                   */
; 5298 :     /* - Operand 1 is zero and operand 2 is non-zero (either finite or infinity)        */
; 5299 :     /* - Operand 1 is finite and operand 2 is infinity                                  */
; 5300 :     /*                                                                                  */
; 5301 :     /* The result is the same for each of the above: Operand 1 becomes the remainder,   */
; 5302 :     /* and the quotient is zero with a signed determined by the signs of the operands.  */
; 5303 :     /* Exclusive Or sets the sign correctly.                                            */
; 5304 :     /************************************************************************************/
; 5305 :     else
; 5306 :     {
; 5307 :         rem = op1;                                          /* remainder is operand 1                               */

  00b0b	48 8b 44 24 40	 mov	 rax, QWORD PTR op1$[rsp]
  00b10	48 89 44 24 38	 mov	 QWORD PTR rem$[rsp], rax

; 5308 :         quo.v = (op1.v ^ op2.v) & 0x8000000000000000ULL;    /* quotient zero, sign is exclusive or of operand signs */

  00b15	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  00b1a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00b1f	48 33 c8	 xor	 rcx, rax
  00b22	48 8b c1	 mov	 rax, rcx
  00b25	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00b2f	48 23 c1	 and	 rax, rcx
  00b32	48 89 44 24 28	 mov	 QWORD PTR quo$[rsp], rax

; 5309 :         newcc = 0;

  00b37	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0
$LN33@s370_divid:
$LN31@s370_divid:
$LN29@s370_divid:
$LN27@s370_divid:
$LN25@s370_divid:
$LN14@s370_divid:

; 5310 :     }
; 5311 : 
; 5312 :     IEEE_EXCEPTION_TRAP_XI( regs );                         /* IEEE Invalid Exception raised and trappable?         */

  00b3c	33 c0		 xor	 eax, eax
  00b3e	83 f8 01	 cmp	 eax, 1
  00b41	74 4b		 je	 SHORT $LN35@s370_divid
  00b43	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00b48	8b c0		 mov	 eax, eax
  00b4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00b50	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00b59	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b5d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b61	83 e0 10	 and	 eax, 16
  00b64	85 c0		 test	 eax, eax
  00b66	74 26		 je	 SHORT $LN35@s370_divid
  00b68	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b70	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00b76	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00b7b	85 c0		 test	 eax, eax
  00b7d	74 0f		 je	 SHORT $LN35@s370_divid
  00b7f	b2 80		 mov	 dl, 128			; 00000080H
  00b81	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b89	e8 00 00 00 00	 call	 ieee_trap
$LN35@s370_divid:

; 5313 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00b8e	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b96	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00b9b	89 44 24 6c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 5314 : 
; 5315 :     /* *********** Underflow flag means remainder underflowed.  It has already been scaled if necessary             */
; 5316 : 
; 5317 :     regs->psw.cc = newcc;

  00b9f	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba7	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00bac	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5318 : 
; 5319 :     PUT_FLOAT64_NOCC( rem, r1, regs );

  00baf	8b 44 24 5c	 mov	 eax, DWORD PTR r1$[rsp]
  00bb3	d1 e0		 shl	 eax, 1
  00bb5	48 98		 cdqe
  00bb7	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bbf	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00bc7	48 8b d0	 mov	 rdx, rax
  00bca	48 8d 4c 24 38	 lea	 rcx, QWORD PTR rem$[rsp]
  00bcf	e8 00 00 00 00	 call	 s370_put_float64

; 5320 :     PUT_FLOAT64_NOCC( quo, r3, regs );

  00bd4	8b 44 24 64	 mov	 eax, DWORD PTR r3$[rsp]
  00bd8	d1 e0		 shl	 eax, 1
  00bda	48 98		 cdqe
  00bdc	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00be4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00bec	48 8b d0	 mov	 rdx, rax
  00bef	48 8d 4c 24 28	 lea	 rcx, QWORD PTR quo$[rsp]
  00bf4	e8 00 00 00 00	 call	 s370_put_float64

; 5321 : 
; 5322 :     ieee_cond_trap( regs, ieee_trap_conds );

  00bf9	8b 54 24 6c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00bfd	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c05	e8 00 00 00 00	 call	 ieee_cond_trap

; 5323 : }

  00c0a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c12	48 33 cc	 xor	 rcx, rsp
  00c15	e8 00 00 00 00	 call	 __security_check_cookie
  00c1a	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00c21	5f		 pop	 rdi
  00c22	5e		 pop	 rsi
  00c23	c3		 ret	 0
s370_divide_integer_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv209 = 40
r1$ = 44
ans$ = 48
r2$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s370_divide_bfp_short_reg PROC

; 3047 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3048 :     int        r1, r2;
; 3049 :     float32_t  op1, op2, ans;
; 3050 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3051 : 
; 3052 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_divid:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@s370_divid
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_divid:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_divid

; 3053 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3054 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN10@s370_divid
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN9@s370_divid
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN9@s370_divid
$LN10@s370_divid:
  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_divid:
$LN7@s370_divid:

; 3055 : 
; 3056 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float32
  00111	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s370_get_float32
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s370_divid

; 3057 : 
; 3058 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3059 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3060 : 
; 3061 :     ans = f32_div( op1, op2 );

  00191	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00195	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  00199	e8 00 00 00 00	 call	 f32_div
  0019e	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax

; 3062 : 
; 3063 :     if (softfloat_exceptionFlags)

  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a7	8b c0		 mov	 eax, eax
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 df 00 00
	00		 je	 $LN11@s370_divid

; 3064 :     {
; 3065 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001c8	33 c0		 xor	 eax, eax
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	74 45		 je	 SHORT $LN12@s370_divid
  001cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d4	8b c0		 mov	 eax, eax
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	83 e0 10	 and	 eax, 16
  001f0	85 c0		 test	 eax, eax
  001f2	74 20		 je	 SHORT $LN12@s370_divid
  001f4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ff	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00204	85 c0		 test	 eax, eax
  00206	74 0c		 je	 SHORT $LN12@s370_divid
  00208	b2 80		 mov	 dl, 128			; 00000080H
  0020a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_divid:

; 3066 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00214	33 c0		 xor	 eax, eax
  00216	83 f8 01	 cmp	 eax, 1
  00219	74 45		 je	 SHORT $LN13@s370_divid
  0021b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00220	8b c0		 mov	 eax, eax
  00222	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00228	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00231	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00235	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00239	83 e0 08	 and	 eax, 8
  0023c	85 c0		 test	 eax, eax
  0023e	74 20		 je	 SHORT $LN13@s370_divid
  00240	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00245	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0024b	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00250	85 c0		 test	 eax, eax
  00252	74 0c		 je	 SHORT $LN13@s370_divid
  00254	b2 40		 mov	 dl, 64			; 00000040H
  00256	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	e8 00 00 00 00	 call	 ieee_trap
$LN13@s370_divid:

; 3067 : 
; 3068 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00260	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0026a	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3069 : 
; 3070 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0026e	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00272	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00277	85 c0		 test	 eax, eax
  00279	74 2c		 je	 SHORT $LN14@s370_divid

; 3071 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0027b	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0027f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00284	85 c0		 test	 eax, eax
  00286	74 0a		 je	 SHORT $LN17@s370_divid
  00288	c7 44 24 28 40
	ff ff ff	 mov	 DWORD PTR tv209[rsp], -192 ; ffffffffffffff40H
  00290	eb 08		 jmp	 SHORT $LN18@s370_divid
$LN17@s370_divid:
  00292	c7 44 24 28 c0
	00 00 00	 mov	 DWORD PTR tv209[rsp], 192 ; 000000c0H
$LN18@s370_divid:
  0029a	8b 4c 24 28	 mov	 ecx, DWORD PTR tv209[rsp]
  0029e	e8 00 00 00 00	 call	 f32_scaledResult
  002a3	89 44 24 30	 mov	 DWORD PTR ans$[rsp], eax
$LN14@s370_divid:
$LN11@s370_divid:

; 3072 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 3073 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 3074 :     }
; 3075 : 
; 3076 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  002a7	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002ab	d1 e0		 shl	 eax, 1
  002ad	48 98		 cdqe
  002af	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002b4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002bc	48 8b d0	 mov	 rdx, rax
  002bf	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  002c4	e8 00 00 00 00	 call	 s370_put_float32

; 3077 : 
; 3078 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002c9	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cd	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002d2	85 c0		 test	 eax, eax
  002d4	74 0e		 je	 SHORT $LN15@s370_divid
  002d6	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002da	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	e8 00 00 00 00	 call	 ieee_cond_trap
$LN15@s370_divid:

; 3079 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3080 : }

  002e4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002e8	c3		 ret	 0
s370_divide_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv225 = 52
r1$ = 56
ans$ = 60
op2$ = 64
op1$ = 68
inst$ = 96
regs$ = 104
s370_divide_bfp_short PROC

; 3086 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3087 :     int        r1, x2, b2;
; 3088 :     VADR       effective_addr2;
; 3089 :     float32_t  op1, op2, ans;
; 3090 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3091 : 
; 3092 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_divid
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_divid:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_divid
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_divid:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000ae	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_divid:
  000b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f8 06	 cmp	 eax, 6
  000d2	74 0c		 je	 SHORT $LN7@s370_divid
  000d4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_divid:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d1		 jne	 SHORT $LN4@s370_divid

; 3093 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3094 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3095 :     BFPINST_CHECK( regs );

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	74 39		 je	 SHORT $LN9@s370_divid
  00104	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010f	d1 e8		 shr	 eax, 1
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 49		 je	 SHORT $LN8@s370_divid
  00118	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00124	b9 08 00 00 00	 mov	 ecx, 8
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	75 24		 jne	 SHORT $LN8@s370_divid
$LN9@s370_divid:
  0013d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00142	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014c	ba 07 00 00 00	 mov	 edx, 7
  00151	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_divid:

; 3096 : 
; 3097 :     GET_FLOAT32_OP( op1, r1, regs );

  00161	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00165	d1 e0		 shl	 eax, 1
  00167	48 98		 cdqe
  00169	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00176	48 8b d0	 mov	 rdx, rax
  00179	48 8d 4c 24 44	 lea	 rcx, QWORD PTR op1$[rsp]
  0017e	e8 00 00 00 00	 call	 s370_get_float32

; 3098 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00183	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00188	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0018c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00190	e8 00 00 00 00	 call	 s370_vfetch4
  00195	89 44 24 40	 mov	 DWORD PTR op2$[rsp], eax

; 3099 : 
; 3100 :     softfloat_exceptionFlags = 0;

  00199	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019e	8b c0		 mov	 eax, eax
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3101 :     SET_SF_RM_FROM_FPC;

  001b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c2	83 e0 07	 and	 eax, 7
  001c5	8b c0		 mov	 eax, eax
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001d3	8b d2		 mov	 edx, edx
  001d5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001dc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001e5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3102 : 
; 3103 :     ans = f32_div( op1, op2 );

  001f1	8b 54 24 40	 mov	 edx, DWORD PTR op2$[rsp]
  001f5	8b 4c 24 44	 mov	 ecx, DWORD PTR op1$[rsp]
  001f9	e8 00 00 00 00	 call	 f32_div
  001fe	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax

; 3104 : 
; 3105 :     if (softfloat_exceptionFlags)

  00202	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00207	8b c0		 mov	 eax, eax
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00218	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00220	85 c0		 test	 eax, eax
  00222	0f 84 df 00 00
	00		 je	 $LN10@s370_divid

; 3106 :     {
; 3107 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00228	33 c0		 xor	 eax, eax
  0022a	83 f8 01	 cmp	 eax, 1
  0022d	74 45		 je	 SHORT $LN11@s370_divid
  0022f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00234	8b c0		 mov	 eax, eax
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00245	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00249	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024d	83 e0 10	 and	 eax, 16
  00250	85 c0		 test	 eax, eax
  00252	74 20		 je	 SHORT $LN11@s370_divid
  00254	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00259	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0025f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00264	85 c0		 test	 eax, eax
  00266	74 0c		 je	 SHORT $LN11@s370_divid
  00268	b2 80		 mov	 dl, 128			; 00000080H
  0026a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_divid:

; 3108 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00274	33 c0		 xor	 eax, eax
  00276	83 f8 01	 cmp	 eax, 1
  00279	74 45		 je	 SHORT $LN12@s370_divid
  0027b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00280	8b c0		 mov	 eax, eax
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00288	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00291	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00295	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00299	83 e0 08	 and	 eax, 8
  0029c	85 c0		 test	 eax, eax
  0029e	74 20		 je	 SHORT $LN12@s370_divid
  002a0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002a5	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ab	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002b0	85 c0		 test	 eax, eax
  002b2	74 0c		 je	 SHORT $LN12@s370_divid
  002b4	b2 40		 mov	 dl, 64			; 00000040H
  002b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002bb	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_divid:

; 3109 : 
; 3110 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002c5	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002ca	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3111 : 
; 3112 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ce	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002d2	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002d7	85 c0		 test	 eax, eax
  002d9	74 2c		 je	 SHORT $LN13@s370_divid

; 3113 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002db	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002df	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002e4	85 c0		 test	 eax, eax
  002e6	74 0a		 je	 SHORT $LN16@s370_divid
  002e8	c7 44 24 34 40
	ff ff ff	 mov	 DWORD PTR tv225[rsp], -192 ; ffffffffffffff40H
  002f0	eb 08		 jmp	 SHORT $LN17@s370_divid
$LN16@s370_divid:
  002f2	c7 44 24 34 c0
	00 00 00	 mov	 DWORD PTR tv225[rsp], 192 ; 000000c0H
$LN17@s370_divid:
  002fa	8b 4c 24 34	 mov	 ecx, DWORD PTR tv225[rsp]
  002fe	e8 00 00 00 00	 call	 f32_scaledResult
  00303	89 44 24 3c	 mov	 DWORD PTR ans$[rsp], eax
$LN13@s370_divid:
$LN10@s370_divid:

; 3114 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 3115 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 3116 :     }
; 3117 : 
; 3118 :     PUT_FLOAT32_NOCC( ans, r1, regs );

  00307	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  0030b	d1 e0		 shl	 eax, 1
  0030d	48 98		 cdqe
  0030f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00314	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0031c	48 8b d0	 mov	 rdx, rax
  0031f	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR ans$[rsp]
  00324	e8 00 00 00 00	 call	 s370_put_float32

; 3119 : 
; 3120 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00329	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0032d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00332	85 c0		 test	 eax, eax
  00334	74 0e		 je	 SHORT $LN14@s370_divid
  00336	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0033a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0033f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_divid:

; 3121 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3122 : }

  00344	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00348	c3		 ret	 0
s370_divide_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
i$1 = 36
tv209 = 40
r1$ = 44
r2$ = 48
ans$ = 56
op2$ = 64
op1$ = 72
inst$ = 96
regs$ = 104
s370_divide_bfp_long_reg PROC

; 2965 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2966 :     int        r1, r2;
; 2967 :     float64_t  op1, op2, ans;
; 2968 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2969 : 
; 2970 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_divid:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN8@s370_divid
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_divid:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_divid

; 2971 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2972 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN10@s370_divid
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN9@s370_divid
  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN9@s370_divid
$LN10@s370_divid:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_divid:
$LN7@s370_divid:

; 2973 : 
; 2974 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float64
  00111	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s370_get_float64
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s370_divid

; 2975 : 
; 2976 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2977 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 2978 : 
; 2979 :     ans = f64_div( op1, op2 );

  00191	48 8b 54 24 40	 mov	 rdx, QWORD PTR op2$[rsp]
  00196	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 f64_div
  001a0	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax

; 2980 : 
; 2981 :     if (softfloat_exceptionFlags)

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 e0 00 00
	00		 je	 $LN11@s370_divid

; 2982 :     {
; 2983 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001cb	33 c0		 xor	 eax, eax
  001cd	83 f8 01	 cmp	 eax, 1
  001d0	74 45		 je	 SHORT $LN12@s370_divid
  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	83 e0 10	 and	 eax, 16
  001f3	85 c0		 test	 eax, eax
  001f5	74 20		 je	 SHORT $LN12@s370_divid
  001f7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00202	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00207	85 c0		 test	 eax, eax
  00209	74 0c		 je	 SHORT $LN12@s370_divid
  0020b	b2 80		 mov	 dl, 128			; 00000080H
  0020d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_divid:

; 2984 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00217	33 c0		 xor	 eax, eax
  00219	83 f8 01	 cmp	 eax, 1
  0021c	74 45		 je	 SHORT $LN13@s370_divid
  0021e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00223	8b c0		 mov	 eax, eax
  00225	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00234	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00238	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023c	83 e0 08	 and	 eax, 8
  0023f	85 c0		 test	 eax, eax
  00241	74 20		 je	 SHORT $LN13@s370_divid
  00243	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00248	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0024e	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00253	85 c0		 test	 eax, eax
  00255	74 0c		 je	 SHORT $LN13@s370_divid
  00257	b2 40		 mov	 dl, 64			; 00000040H
  00259	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	e8 00 00 00 00	 call	 ieee_trap
$LN13@s370_divid:

; 2985 : 
; 2986 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0026d	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2987 : 
; 2988 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00271	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00275	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0027a	85 c0		 test	 eax, eax
  0027c	74 2d		 je	 SHORT $LN14@s370_divid

; 2989 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0027e	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00282	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00287	85 c0		 test	 eax, eax
  00289	74 0a		 je	 SHORT $LN17@s370_divid
  0028b	c7 44 24 28 00
	fa ff ff	 mov	 DWORD PTR tv209[rsp], -1536 ; fffffffffffffa00H
  00293	eb 08		 jmp	 SHORT $LN18@s370_divid
$LN17@s370_divid:
  00295	c7 44 24 28 00
	06 00 00	 mov	 DWORD PTR tv209[rsp], 1536 ; 00000600H
$LN18@s370_divid:
  0029d	8b 4c 24 28	 mov	 ecx, DWORD PTR tv209[rsp]
  002a1	e8 00 00 00 00	 call	 f64_scaledResult
  002a6	48 89 44 24 38	 mov	 QWORD PTR ans$[rsp], rax
$LN14@s370_divid:
$LN11@s370_divid:

; 2990 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 2991 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 2992 :     }
; 2993 : 
; 2994 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  002ab	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  002af	d1 e0		 shl	 eax, 1
  002b1	48 98		 cdqe
  002b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002b8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002c0	48 8b d0	 mov	 rdx, rax
  002c3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ans$[rsp]
  002c8	e8 00 00 00 00	 call	 s370_put_float64

; 2995 : 
; 2996 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  002cd	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002d1	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  002d6	85 c0		 test	 eax, eax
  002d8	74 0e		 je	 SHORT $LN15@s370_divid
  002da	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  002de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	e8 00 00 00 00	 call	 ieee_cond_trap
$LN15@s370_divid:

; 2997 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 2998 : }

  002e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002ec	c3		 ret	 0
s370_divide_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
tv225 = 52
r1$ = 56
ans$ = 64
op2$ = 72
op1$ = 80
inst$ = 112
regs$ = 120
s370_divide_bfp_long PROC

; 3004 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3005 :     int        r1, x2, b2;
; 3006 :     VADR       effective_addr2;
; 3007 :     float64_t  op1, op2, ans;
; 3008 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 3009 : 
; 3010 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_divid
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_divid:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_divid
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_divid:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000ae	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_divid:
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f8 06	 cmp	 eax, 6
  000d2	74 0c		 je	 SHORT $LN7@s370_divid
  000d4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_divid:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d1		 jne	 SHORT $LN4@s370_divid

; 3011 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 3012 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3013 :     BFPINST_CHECK( regs );

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	74 39		 je	 SHORT $LN9@s370_divid
  00104	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010f	d1 e8		 shr	 eax, 1
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 49		 je	 SHORT $LN8@s370_divid
  00118	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00124	b9 08 00 00 00	 mov	 ecx, 8
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	75 24		 jne	 SHORT $LN8@s370_divid
$LN9@s370_divid:
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014c	ba 07 00 00 00	 mov	 edx, 7
  00151	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_divid:

; 3014 : 
; 3015 :     GET_FLOAT64_OP( op1, r1, regs );

  00161	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00165	d1 e0		 shl	 eax, 1
  00167	48 98		 cdqe
  00169	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00176	48 8b d0	 mov	 rdx, rax
  00179	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0017e	e8 00 00 00 00	 call	 s370_get_float64

; 3016 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  00183	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00188	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0018c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00190	e8 00 00 00 00	 call	 s370_vfetch8
  00195	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 3017 : 
; 3018 :     softfloat_exceptionFlags = 0;

  0019a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019f	8b c0		 mov	 eax, eax
  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 3019 :     SET_SF_RM_FROM_FPC;

  001b8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c3	83 e0 07	 and	 eax, 7
  001c6	8b c0		 mov	 eax, eax
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001cf	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001d4	8b d2		 mov	 edx, edx
  001d6	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001dd	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001e6	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001ea	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ee	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 3020 : 
; 3021 :     ans = f64_div( op1, op2 );

  001f2	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  001f7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op1$[rsp]
  001fc	e8 00 00 00 00	 call	 f64_div
  00201	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax

; 3022 : 
; 3023 :     if (softfloat_exceptionFlags)

  00206	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0020b	8b c0		 mov	 eax, eax
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00213	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0021c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00220	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00224	85 c0		 test	 eax, eax
  00226	0f 84 e0 00 00
	00		 je	 $LN10@s370_divid

; 3024 :     {
; 3025 :         IEEE_EXCEPTION_TRAP_XI( regs );

  0022c	33 c0		 xor	 eax, eax
  0022e	83 f8 01	 cmp	 eax, 1
  00231	74 45		 je	 SHORT $LN11@s370_divid
  00233	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00238	8b c0		 mov	 eax, eax
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00240	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00249	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00251	83 e0 10	 and	 eax, 16
  00254	85 c0		 test	 eax, eax
  00256	74 20		 je	 SHORT $LN11@s370_divid
  00258	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0025d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00263	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00268	85 c0		 test	 eax, eax
  0026a	74 0c		 je	 SHORT $LN11@s370_divid
  0026c	b2 80		 mov	 dl, 128			; 00000080H
  0026e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_divid:

; 3026 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  00278	33 c0		 xor	 eax, eax
  0027a	83 f8 01	 cmp	 eax, 1
  0027d	74 45		 je	 SHORT $LN12@s370_divid
  0027f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00284	8b c0		 mov	 eax, eax
  00286	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0028c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00295	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00299	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029d	83 e0 08	 and	 eax, 8
  002a0	85 c0		 test	 eax, eax
  002a2	74 20		 je	 SHORT $LN12@s370_divid
  002a4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002a9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002af	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002b4	85 c0		 test	 eax, eax
  002b6	74 0c		 je	 SHORT $LN12@s370_divid
  002b8	b2 40		 mov	 dl, 64			; 00000040H
  002ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_divid:

; 3027 : 
; 3028 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002ce	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 3029 : 
; 3030 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002d2	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002d6	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002db	85 c0		 test	 eax, eax
  002dd	74 2d		 je	 SHORT $LN13@s370_divid

; 3031 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002df	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002e3	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002e8	85 c0		 test	 eax, eax
  002ea	74 0a		 je	 SHORT $LN16@s370_divid
  002ec	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv225[rsp], -1536 ; fffffffffffffa00H
  002f4	eb 08		 jmp	 SHORT $LN17@s370_divid
$LN16@s370_divid:
  002f6	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv225[rsp], 1536 ; 00000600H
$LN17@s370_divid:
  002fe	8b 4c 24 34	 mov	 ecx, DWORD PTR tv225[rsp]
  00302	e8 00 00 00 00	 call	 f64_scaledResult
  00307	48 89 44 24 40	 mov	 QWORD PTR ans$[rsp], rax
$LN13@s370_divid:
$LN10@s370_divid:

; 3032 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 3033 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 3034 :     }
; 3035 : 
; 3036 :     PUT_FLOAT64_NOCC( ans, r1, regs );

  0030c	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00310	d1 e0		 shl	 eax, 1
  00312	48 98		 cdqe
  00314	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00321	48 8b d0	 mov	 rdx, rax
  00324	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ans$[rsp]
  00329	e8 00 00 00 00	 call	 s370_put_float64

; 3037 : 
; 3038 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0032e	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00332	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00337	85 c0		 test	 eax, eax
  00339	74 0e		 je	 SHORT $LN14@s370_divid
  0033b	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0033f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00344	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_divid:

; 3039 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 3040 : }

  00349	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0034d	c3		 ret	 0
s370_divide_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv218 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
ans$ = 128
op2$ = 144
op1$ = 160
__$ArrayPad$ = 176
inst$ = 224
regs$ = 232
s370_divide_bfp_ext_reg PROC

; 2925 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2926 :     int         r1, r2;
; 2927 :     float128_t  op1, op2, ans;
; 2928 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2929 : 
; 2930 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_divid:
  0005f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN8@s370_divid
  00082	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_divid:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@s370_divid

; 2931 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2932 :     BFPINST_CHECK( regs );

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 3f		 je	 SHORT $LN10@s370_divid
  000b8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c6	d1 e8		 shr	 eax, 1
  000c8	83 e0 01	 and	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 55		 je	 SHORT $LN9@s370_divid
  000cf	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	b9 08 00 00 00	 mov	 ecx, 8
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ee	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f3	85 c0		 test	 eax, eax
  000f5	75 2d		 jne	 SHORT $LN9@s370_divid
$LN10@s370_divid:
  000f7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00109	ba 07 00 00 00	 mov	 edx, 7
  0010e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_divid:

; 2933 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00124	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN12@s370_divid
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 02	 and	 eax, 2
  00136	85 c0		 test	 eax, eax
  00138	74 1b		 je	 SHORT $LN11@s370_divid
$LN12@s370_divid:
  0013a	ba 06 00 00 00	 mov	 edx, 6
  0013f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_divid:
$LN7@s370_divid:

; 2934 : 
; 2935 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  00155	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00159	d1 e0		 shl	 eax, 1
  0015b	48 98		 cdqe
  0015d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00178	e8 00 00 00 00	 call	 s370_get_float128
  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00181	d1 e0		 shl	 eax, 1
  00183	48 98		 cdqe
  00185	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001a0	e8 00 00 00 00	 call	 s370_get_float128
  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 aa		 jne	 SHORT $LN7@s370_divid

; 2936 : 
; 2937 :     softfloat_exceptionFlags = 0;

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b0	8b c0		 mov	 eax, eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2938 :     SET_SF_RM_FROM_FPC;

  001c9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d7	83 e0 07	 and	 eax, 7
  001da	8b c0		 mov	 eax, eax
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001e8	8b d2		 mov	 edx, edx
  001ea	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001f1	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001fa	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00202	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 2939 : 
; 2940 :     ans = f128_div( op1, op2 );

  00206	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0020b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  00213	48 8b f8	 mov	 rdi, rax
  00216	48 8b f1	 mov	 rsi, rcx
  00219	b9 10 00 00 00	 mov	 ecx, 16
  0021e	f3 a4		 rep movsb
  00220	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00225	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  0022d	48 8b f8	 mov	 rdi, rax
  00230	48 8b f1	 mov	 rsi, rcx
  00233	b9 10 00 00 00	 mov	 ecx, 16
  00238	f3 a4		 rep movsb
  0023a	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  0023f	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  00244	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  00249	e8 00 00 00 00	 call	 f128_div
  0024e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00256	48 8b f9	 mov	 rdi, rcx
  00259	48 8b f0	 mov	 rsi, rax
  0025c	b9 10 00 00 00	 mov	 ecx, 16
  00261	f3 a4		 rep movsb

; 2941 : 
; 2942 :     if (softfloat_exceptionFlags)

  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	85 c0		 test	 eax, eax
  00283	0f 84 04 01 00
	00		 je	 $LN13@s370_divid

; 2943 :     {
; 2944 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00289	33 c0		 xor	 eax, eax
  0028b	83 f8 01	 cmp	 eax, 1
  0028e	74 4b		 je	 SHORT $LN14@s370_divid
  00290	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00295	8b c0		 mov	 eax, eax
  00297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ae	83 e0 10	 and	 eax, 16
  002b1	85 c0		 test	 eax, eax
  002b3	74 26		 je	 SHORT $LN14@s370_divid
  002b5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002c8	85 c0		 test	 eax, eax
  002ca	74 0f		 je	 SHORT $LN14@s370_divid
  002cc	b2 80		 mov	 dl, 128			; 00000080H
  002ce	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_divid:

; 2945 :         IEEE_EXCEPTION_TRAP_XZ( regs );

  002db	33 c0		 xor	 eax, eax
  002dd	83 f8 01	 cmp	 eax, 1
  002e0	74 4b		 je	 SHORT $LN15@s370_divid
  002e2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e7	8b c0		 mov	 eax, eax
  002e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ef	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00300	83 e0 08	 and	 eax, 8
  00303	85 c0		 test	 eax, eax
  00305	74 26		 je	 SHORT $LN15@s370_divid
  00307	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00315	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0031a	85 c0		 test	 eax, eax
  0031c	74 0f		 je	 SHORT $LN15@s370_divid
  0031e	b2 40		 mov	 dl, 64			; 00000040H
  00320	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00328	e8 00 00 00 00	 call	 ieee_trap
$LN15@s370_divid:

; 2946 : 
; 2947 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0032d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00335	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0033a	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2948 : 
; 2949 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  0033e	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00342	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  00347	85 c0		 test	 eax, eax
  00349	74 42		 je	 SHORT $LN16@s370_divid

; 2950 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0034b	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0034f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00354	85 c0		 test	 eax, eax
  00356	74 0a		 je	 SHORT $LN19@s370_divid
  00358	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv218[rsp], -24576 ; ffffffffffffa000H
  00360	eb 08		 jmp	 SHORT $LN20@s370_divid
$LN19@s370_divid:
  00362	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv218[rsp], 24576 ; 00006000H
$LN20@s370_divid:
  0036a	8b 54 24 30	 mov	 edx, DWORD PTR tv218[rsp]
  0036e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  00373	e8 00 00 00 00	 call	 f128_scaledResult
  00378	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00380	48 8b f9	 mov	 rdi, rcx
  00383	48 8b f0	 mov	 rsi, rax
  00386	b9 10 00 00 00	 mov	 ecx, 16
  0038b	f3 a4		 rep movsb
$LN16@s370_divid:
$LN13@s370_divid:

; 2951 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 2952 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 2953 :     }
; 2954 : 
; 2955 :     PUT_FLOAT128_NOCC( ans, r1, regs );

  0038d	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00391	d1 e0		 shl	 eax, 1
  00393	48 98		 cdqe
  00395	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  003a5	48 8b d0	 mov	 rdx, rax
  003a8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  003b0	e8 00 00 00 00	 call	 s370_put_float128

; 2956 : 
; 2957 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003b5	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003b9	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003be	85 c0		 test	 eax, eax
  003c0	74 11		 je	 SHORT $LN17@s370_divid
  003c2	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003c6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ce	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s370_divid:

; 2958 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 2959 : }

  003d3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003db	48 33 cc	 xor	 rcx, rsp
  003de	e8 00 00 00 00	 call	 __security_check_cookie
  003e3	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  003ea	5f		 pop	 rdi
  003eb	5e		 pop	 rsi
  003ec	c3		 ret	 0
s370_divide_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv169 = 44
r2$ = 48
op2$ = 52
r1$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s370_convert_fix32_to_bfp_short_reg PROC

; 1743 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1744 :     int        r1, r2;
; 1745 :     BYTE       m3, m4;
; 1746 :     S32        op2;
; 1747 :     float32_t  op1;
; 1748 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1749 : 
; 1750 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 1751 : 
; 1752 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1753 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 1754 : 
; 1755 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1756 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0010a	b8 01 00 00 00	 mov	 eax, 1
  0010f	48 6b c0 04	 imul	 rax, rax, 4
  00113	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00120	83 e0 04	 and	 eax, 4
  00123	85 c0		 test	 eax, eax
  00125	74 11		 je	 SHORT $LN8@s370_conve

; 1757 :         BFPRM_CHECK( m3, regs );

  00127	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0012c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	e8 00 00 00 00	 call	 s370_BFP_RM_check
  00136	eb 25		 jmp	 SHORT $LN9@s370_conve
$LN8@s370_conve:

; 1758 :     else
; 1759 : #endif
; 1760 :     {
; 1761 :         if (m3 | m4)

  00138	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0013d	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  00142	0b c1		 or	 eax, ecx
  00144	85 c0		 test	 eax, eax
  00146	74 15		 je	 SHORT $LN10@s370_conve

; 1762 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00148	ba 06 00 00 00	 mov	 edx, 6
  0014d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00152	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00157	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_conve:
$LN9@s370_conve:

; 1763 :     }
; 1764 : 
; 1765 :     SET_SF_RM_FROM_MASK( m3 );

  0015d	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00162	85 c0		 test	 eax, eax
  00164	74 16		 je	 SHORT $LN14@s370_conve
  00166	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00172	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00176	89 44 24 2c	 mov	 DWORD PTR tv169[rsp], eax
  0017a	eb 1f		 jmp	 SHORT $LN15@s370_conve
$LN14@s370_conve:
  0017c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00181	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00187	83 e0 07	 and	 eax, 7
  0018a	8b c0		 mov	 eax, eax
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00193	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00197	89 44 24 2c	 mov	 DWORD PTR tv169[rsp], eax
$LN15@s370_conve:
  0019b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001a0	8b c0		 mov	 eax, eax
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b5	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv169[rsp]
  001ba	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1766 :     op2 = regs->GR_L( r2 );

  001bd	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  001c2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001ce	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 1767 :     softfloat_exceptionFlags = 0;

  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1768 :     op1 = i32_to_f32( op2 );

  001f0	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  001f4	e8 00 00 00 00	 call	 i32_to_f32
  001f9	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 1769 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  001fd	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00201	d1 e0		 shl	 eax, 1
  00203	48 98		 cdqe
  00205	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0020a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00212	48 8b d0	 mov	 rdx, rax
  00215	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  0021a	e8 00 00 00 00	 call	 s370_put_float32

; 1770 : 
; 1771 :     /* Inexact occurred and not masked by m4? */
; 1772 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  0021f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00224	8b c0		 mov	 eax, eax
  00226	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00235	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00239	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023d	85 c0		 test	 eax, eax
  0023f	74 35		 je	 SHORT $LN11@s370_conve
  00241	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00246	83 e0 04	 and	 eax, 4
  00249	85 c0		 test	 eax, eax
  0024b	75 29		 jne	 SHORT $LN11@s370_conve

; 1773 :     {
; 1774 :         /* Yes, set FPC flags and test for a trap */
; 1775 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0024d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00252	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00257	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1776 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0025b	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0025f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00264	85 c0		 test	 eax, eax
  00266	74 0e		 je	 SHORT $LN12@s370_conve
  00268	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0026c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00271	e8 00 00 00 00	 call	 ieee_cond_trap
$LN12@s370_conve:
$LN11@s370_conve:

; 1777 :     }
; 1778 : }

  00276	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0027a	c3		 ret	 0
s370_convert_fix32_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
tv169 = 40
r2$ = 44
op2$ = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s370_convert_fix32_to_bfp_long_reg PROC

; 1705 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1706 :     int        r1, r2;
; 1707 :     BYTE       m3, m4;
; 1708 :     S32        op2;
; 1709 :     float64_t  op1;
; 1710 : 
; 1711 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 08	 shr	 eax, 8
  00043	83 e0 0f	 and	 eax, 15
  00046	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 0c	 shr	 eax, 12
  00051	83 e0 0f	 and	 eax, 15
  00054	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 04	 cmp	 eax, 4
  00073	74 0c		 je	 SHORT $LN5@s370_conve
  00075	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 d1		 jne	 SHORT $LN4@s370_conve

; 1712 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1713 :     BFPINST_CHECK( regs );

  00087	b8 08 00 00 00	 mov	 eax, 8
  0008c	48 6b c0 01	 imul	 rax, rax, 1
  00090	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00095	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0009c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a1	85 c0		 test	 eax, eax
  000a3	74 39		 je	 SHORT $LN7@s370_conve
  000a5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b0	d1 e8		 shr	 eax, 1
  000b2	83 e0 01	 and	 eax, 1
  000b5	85 c0		 test	 eax, eax
  000b7	74 49		 je	 SHORT $LN6@s370_conve
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000c5	b9 08 00 00 00	 mov	 ecx, 8
  000ca	48 6b c9 01	 imul	 rcx, rcx, 1
  000ce	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000d5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000da	85 c0		 test	 eax, eax
  000dc	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000de	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000ed	ba 07 00 00 00	 mov	 edx, 7
  000f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 1714 : 
; 1715 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1716 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00102	b8 01 00 00 00	 mov	 eax, 1
  00107	48 6b c0 04	 imul	 rax, rax, 4
  0010b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00118	83 e0 04	 and	 eax, 4
  0011b	85 c0		 test	 eax, eax
  0011d	74 11		 je	 SHORT $LN8@s370_conve

; 1717 :         BFPRM_CHECK( m3, regs );

  0011f	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  00124	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00129	e8 00 00 00 00	 call	 s370_BFP_RM_check
  0012e	eb 25		 jmp	 SHORT $LN9@s370_conve
$LN8@s370_conve:

; 1718 :     else
; 1719 : #endif
; 1720 :     {
; 1721 :         if (m3 | m4)

  00130	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00135	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  0013a	0b c1		 or	 eax, ecx
  0013c	85 c0		 test	 eax, eax
  0013e	74 15		 je	 SHORT $LN10@s370_conve

; 1722 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00140	ba 06 00 00 00	 mov	 edx, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_conve:
$LN9@s370_conve:

; 1723 :     }
; 1724 : 
; 1725 :     SET_SF_RM_FROM_MASK( m3 );

  00155	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0015a	85 c0		 test	 eax, eax
  0015c	74 16		 je	 SHORT $LN12@s370_conve
  0015e	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0016a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0016e	89 44 24 28	 mov	 DWORD PTR tv169[rsp], eax
  00172	eb 1f		 jmp	 SHORT $LN13@s370_conve
$LN12@s370_conve:
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0017f	83 e0 07	 and	 eax, 7
  00182	8b c0		 mov	 eax, eax
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0018b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018f	89 44 24 28	 mov	 DWORD PTR tv169[rsp], eax
$LN13@s370_conve:
  00193	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00198	8b c0		 mov	 eax, eax
  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ad	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv169[rsp]
  001b2	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1726 :     op2 = regs->GR_L( r2 );

  001b5	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  001ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001c6	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 1727 :     softfloat_exceptionFlags = 0;

  001ca	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001cf	8b c0		 mov	 eax, eax
  001d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1728 :     op1 = i32_to_f64( op2 );

  001e8	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  001ec	e8 00 00 00 00	 call	 i32_to_f64
  001f1	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 1729 : 
; 1730 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  001f6	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  001fa	d1 e0		 shl	 eax, 1
  001fc	48 98		 cdqe
  001fe	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0020b	48 8b d0	 mov	 rdx, rax
  0020e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00213	e8 00 00 00 00	 call	 s370_put_float64

; 1731 : }

  00218	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0021c	c3		 ret	 0
s370_convert_fix32_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
tv179 = 40
r1$ = 44
r2$ = 48
op2$ = 52
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
s370_convert_fix32_to_bfp_ext_reg PROC

; 1669 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1670 :     int         r1, r2;
; 1671 :     BYTE        m3, m4;
; 1672 :     S32         op2;
; 1673 :     float128_t  op1;
; 1674 : 
; 1675 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 04	 shr	 eax, 4
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 08	 shr	 eax, 8
  00057	83 e0 0f	 and	 eax, 15
  0005a	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 0c	 shr	 eax, 12
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00088	33 c0		 xor	 eax, eax
  0008a	83 f8 04	 cmp	 eax, 4
  0008d	74 0f		 je	 SHORT $LN5@s370_conve
  0008f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 c8		 jne	 SHORT $LN4@s370_conve

; 1676 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1677 :     BFPINST_CHECK( regs );

  000a4	b8 08 00 00 00	 mov	 eax, 8
  000a9	48 6b c0 01	 imul	 rax, rax, 1
  000ad	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000bc	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c1	85 c0		 test	 eax, eax
  000c3	74 3f		 je	 SHORT $LN7@s370_conve
  000c5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d3	d1 e8		 shr	 eax, 1
  000d5	83 e0 01	 and	 eax, 1
  000d8	85 c0		 test	 eax, eax
  000da	74 55		 je	 SHORT $LN6@s370_conve
  000dc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000eb	b9 08 00 00 00	 mov	 ecx, 8
  000f0	48 6b c9 01	 imul	 rcx, rcx, 1
  000f4	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010c	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00116	ba 07 00 00 00	 mov	 edx, 7
  0011b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 1678 :     BFPREGPAIR_CHECK( r1, regs );

  00131	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00135	83 e0 02	 and	 eax, 2
  00138	85 c0		 test	 eax, eax
  0013a	74 1b		 je	 SHORT $LN8@s370_conve
  0013c	ba 06 00 00 00	 mov	 edx, 6
  00141	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00149	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00151	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 1679 : 
; 1680 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1681 :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	48 6b c0 04	 imul	 rax, rax, 4
  00160	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00170	83 e0 04	 and	 eax, 4
  00173	85 c0		 test	 eax, eax
  00175	74 14		 je	 SHORT $LN9@s370_conve

; 1682 :         BFPRM_CHECK( m3, regs );

  00177	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0017c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	e8 00 00 00 00	 call	 s370_BFP_RM_check
  00189	eb 2b		 jmp	 SHORT $LN10@s370_conve
$LN9@s370_conve:

; 1683 :     else
; 1684 : #endif
; 1685 :     {
; 1686 :         if (m3 | m4)

  0018b	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00190	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR m4$[rsp]
  00195	0b c1		 or	 eax, ecx
  00197	85 c0		 test	 eax, eax
  00199	74 1b		 je	 SHORT $LN11@s370_conve

; 1687 :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  0019b	ba 06 00 00 00	 mov	 edx, 6
  001a0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_conve:
$LN10@s370_conve:

; 1688 :     }
; 1689 : 
; 1690 :     op2 = regs->GR_L( r2 );

  001b6	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  001bb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001ca	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 1691 :     SET_SF_RM_FROM_MASK( m3 );

  001ce	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001d3	85 c0		 test	 eax, eax
  001d5	74 16		 je	 SHORT $LN13@s370_conve
  001d7	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e7	89 44 24 28	 mov	 DWORD PTR tv179[rsp], eax
  001eb	eb 22		 jmp	 SHORT $LN14@s370_conve
$LN13@s370_conve:
  001ed	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f5	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001fb	83 e0 07	 and	 eax, 7
  001fe	8b c0		 mov	 eax, eax
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00207	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020b	89 44 24 28	 mov	 DWORD PTR tv179[rsp], eax
$LN14@s370_conve:
  0020f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00214	8b c0		 mov	 eax, eax
  00216	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00225	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00229	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv179[rsp]
  0022e	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1692 :     softfloat_exceptionFlags = 0;

  00231	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00236	8b c0		 mov	 eax, eax
  00238	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00247	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1693 :     op1 = i32_to_f128( op2 );

  0024f	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  00253	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  00258	e8 00 00 00 00	 call	 i32_to_f128
  0025d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00262	48 8b f9	 mov	 rdi, rcx
  00265	48 8b f0	 mov	 rsi, rax
  00268	b9 10 00 00 00	 mov	 ecx, 16
  0026d	f3 a4		 rep movsb

; 1694 : 
; 1695 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  0026f	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00273	d1 e0		 shl	 eax, 1
  00275	48 98		 cdqe
  00277	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00287	48 8b d0	 mov	 rdx, rax
  0028a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  0028f	e8 00 00 00 00	 call	 s370_put_float128

; 1696 : }

  00294	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00299	48 33 cc	 xor	 rcx, rsp
  0029c	e8 00 00 00 00	 call	 __security_check_cookie
  002a1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002a5	5f		 pop	 rdi
  002a6	5e		 pop	 rsi
  002a7	c3		 ret	 0
s370_convert_fix32_to_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
op2$ = 48
ieee_trap_conds$ = 52
tv180 = 56
tv202 = 60
tv208 = 64
r2$ = 68
r1$ = 72
inst$ = 96
regs$ = 104
s370_convert_bfp_short_to_fix32_reg PROC

; 2098 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2099 :     int        r1, r2;
; 2100 :     BYTE       m3, m4, newcc;
; 2101 :     S32        op1;
; 2102 :     float32_t  op2;
; 2103 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2104 :     U32        op2_dataclass;
; 2105 : 
; 2106 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2107 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2108 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2109 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2110 : 
; 2111 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2112 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	48 6b c0 04	 imul	 rax, rax, 4
  00122	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0012f	83 e0 04	 and	 eax, 4
  00132	85 c0		 test	 eax, eax
  00134	75 05		 jne	 SHORT $LN8@s370_conve

; 2113 : #endif
; 2114 :         m4 = 0;

  00136	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN8@s370_conve:

; 2115 : 
; 2116 :     GET_FLOAT32_OP( op2, r2, regs );

  0013b	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  0013f	d1 e0		 shl	 eax, 1
  00141	48 98		 cdqe
  00143	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00150	48 8b d0	 mov	 rdx, rax
  00153	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00158	e8 00 00 00 00	 call	 s370_get_float32

; 2117 :     op2_dataclass = float32_class( op2 );

  0015d	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  00161	e8 00 00 00 00	 call	 float32_class
  00166	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2118 :     softfloat_exceptionFlags = 0;

  0016a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016f	8b c0		 mov	 eax, eax
  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00177	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00180	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00184	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2119 : 
; 2120 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  00188	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0018c	83 e0 0f	 and	 eax, 15
  0018f	85 c0		 test	 eax, eax
  00191	74 53		 je	 SHORT $LN9@s370_conve

; 2121 :                          float_class_pos_signaling_nan |
; 2122 :                          float_class_neg_quiet_nan     |
; 2123 :                          float_class_pos_quiet_nan ))
; 2124 :     {
; 2125 :         /* NaN input always returns maximum negative integer,
; 2126 :            cc3, and IEEE invalid exception */
; 2127 :         op1 = -0x7FFFFFFF - 1;

  00193	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 2128 :         newcc = 3;

  0019b	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2129 :         softfloat_raiseFlags( softfloat_flag_invalid );

  001a0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a5	8b c0		 mov	 eax, eax
  001a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ad	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001be	83 c8 10	 or	 eax, 16
  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d0	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  001d6	45 8b c0	 mov	 r8d, r8d
  001d9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001dd	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2130 :     }

  001e1	e9 10 01 00 00	 jmp	 $LN10@s370_conve
$LN9@s370_conve:

; 2131 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  001e6	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  001ea	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  001ef	85 c0		 test	 eax, eax
  001f1	74 12		 je	 SHORT $LN11@s370_conve

; 2132 :     {
; 2133 :         newcc = 0;

  001f3	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2134 :         op1 = 0;

  001f8	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2135 :     }

  00200	e9 f1 00 00 00	 jmp	 $LN12@s370_conve
$LN11@s370_conve:

; 2136 :     else
; 2137 :     {
; 2138 :         newcc = (op2.v & 0x80000000) ? 1 : 2;

  00205	8b 44 24 30	 mov	 eax, DWORD PTR op2$[rsp]
  00209	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0020e	85 c0		 test	 eax, eax
  00210	74 0a		 je	 SHORT $LN20@s370_conve
  00212	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  0021a	eb 08		 jmp	 SHORT $LN21@s370_conve
$LN20@s370_conve:
  0021c	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv180[rsp], 2
$LN21@s370_conve:
  00224	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv180[rsp]
  00229	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2139 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  0022d	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00231	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00236	85 c0		 test	 eax, eax
  00238	74 0d		 je	 SHORT $LN13@s370_conve

; 2140 :             op1 = 0;

  0023a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  00242	e9 af 00 00 00	 jmp	 $LN14@s370_conve
$LN13@s370_conve:

; 2141 :         else
; 2142 :         {
; 2143 :             SET_SF_RM_FROM_MASK( m3 );

  00247	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  0024c	85 c0		 test	 eax, eax
  0024e	74 16		 je	 SHORT $LN22@s370_conve
  00250	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0025c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00260	89 44 24 3c	 mov	 DWORD PTR tv202[rsp], eax
  00264	eb 1f		 jmp	 SHORT $LN23@s370_conve
$LN22@s370_conve:
  00266	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00271	83 e0 07	 and	 eax, 7
  00274	8b c0		 mov	 eax, eax
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	89 44 24 3c	 mov	 DWORD PTR tv202[rsp], eax
$LN23@s370_conve:
  00285	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0028a	8b c0		 mov	 eax, eax
  0028c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00292	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0029b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0029f	0f b6 54 24 3c	 movzx	 edx, BYTE PTR tv202[rsp]
  002a4	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2144 :             op1 = f32_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002a7	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  002ac	83 e0 04	 and	 eax, 4
  002af	85 c0		 test	 eax, eax
  002b1	75 0a		 jne	 SHORT $LN24@s370_conve
  002b3	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv208[rsp], 1
  002bb	eb 08		 jmp	 SHORT $LN25@s370_conve
$LN24@s370_conve:
  002bd	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv208[rsp], 0
$LN25@s370_conve:
  002c5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002ca	8b c0		 mov	 eax, eax
  002cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002d2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002db	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002df	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR tv208[rsp]
  002e5	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002e9	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  002ed	e8 00 00 00 00	 call	 f32_to_i32
  002f2	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN14@s370_conve:
$LN12@s370_conve:
$LN10@s370_conve:

; 2145 :         }
; 2146 :     }
; 2147 : 
; 2148 :     IEEE_EXCEPTION_TRAP_XI( regs );

  002f6	33 c0		 xor	 eax, eax
  002f8	83 f8 01	 cmp	 eax, 1
  002fb	74 45		 je	 SHORT $LN15@s370_conve
  002fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00302	8b c0		 mov	 eax, eax
  00304	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0030a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00313	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00317	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031b	83 e0 10	 and	 eax, 16
  0031e	85 c0		 test	 eax, eax
  00320	74 20		 je	 SHORT $LN15@s370_conve
  00322	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00327	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0032d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00332	85 c0		 test	 eax, eax
  00334	74 0c		 je	 SHORT $LN15@s370_conve
  00336	b2 80		 mov	 dl, 128			; 00000080H
  00338	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0033d	e8 00 00 00 00	 call	 ieee_trap
$LN15@s370_conve:

; 2149 : 
; 2150 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00342	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00347	8b c0		 mov	 eax, eax
  00349	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0034f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00358	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0035c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00360	83 e0 10	 and	 eax, 16
  00363	85 c0		 test	 eax, eax
  00365	74 52		 je	 SHORT $LN16@s370_conve

; 2151 :     {
; 2152 :         newcc = 3;

  00367	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2153 : 
; 2154 :         if (!SUPPRESS_INEXACT( m4 ))

  0036c	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00371	83 e0 04	 and	 eax, 4
  00374	85 c0		 test	 eax, eax
  00376	75 41		 jne	 SHORT $LN17@s370_conve

; 2155 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00378	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0037d	8b c0		 mov	 eax, eax
  0037f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00385	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0038e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00392	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00396	83 c8 01	 or	 eax, 1
  00399	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0039f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003a8	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  003ae	45 8b c0	 mov	 r8d, r8d
  003b1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003b5	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN17@s370_conve:
$LN16@s370_conve:

; 2156 :     }
; 2157 : 
; 2158 :     regs->GR_L( r1 ) = op1;

  003b9	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  003be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003c3	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  003c7	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2159 :     regs->psw.cc = newcc;

  003ce	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  003d3	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  003d8	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2160 : 
; 2161 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  003db	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003e0	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003e5	89 44 24 34	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2162 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  003e9	8b 44 24 34	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003ed	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003f2	85 c0		 test	 eax, eax
  003f4	74 0e		 je	 SHORT $LN18@s370_conve
  003f6	8b 54 24 34	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  003fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003ff	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@s370_conve:

; 2163 : }

  00404	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00408	c3		 ret	 0
s370_convert_bfp_short_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
ieee_trap_conds$ = 48
tv180 = 52
tv202 = 56
tv208 = 60
r2$ = 64
r1$ = 68
op2$ = 72
inst$ = 96
regs$ = 104
s370_convert_bfp_long_to_fix32_reg PROC

; 2027 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2028 :     int        r1, r2;
; 2029 :     BYTE       m3, m4, newcc;
; 2030 :     S32        op1;
; 2031 :     float64_t  op2;
; 2032 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2033 :     U32        op2_dataclass;
; 2034 : 
; 2035 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 40	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2036 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2037 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2038 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2039 : 
; 2040 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 2041 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	48 6b c0 04	 imul	 rax, rax, 4
  00122	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0012f	83 e0 04	 and	 eax, 4
  00132	85 c0		 test	 eax, eax
  00134	75 05		 jne	 SHORT $LN8@s370_conve

; 2042 : #endif
; 2043 :         m4 = 0;

  00136	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN8@s370_conve:

; 2044 : 
; 2045 :     GET_FLOAT64_OP( op2, r2, regs );

  0013b	8b 44 24 40	 mov	 eax, DWORD PTR r2$[rsp]
  0013f	d1 e0		 shl	 eax, 1
  00141	48 98		 cdqe
  00143	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00150	48 8b d0	 mov	 rdx, rax
  00153	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  00158	e8 00 00 00 00	 call	 s370_get_float64

; 2046 :     op2_dataclass = float64_class( op2 );

  0015d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00162	e8 00 00 00 00	 call	 float64_class
  00167	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 2047 :     softfloat_exceptionFlags = 0;

  0016b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00170	8b c0		 mov	 eax, eax
  00172	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00178	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00181	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00185	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2048 : 
; 2049 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  00189	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0018d	83 e0 0f	 and	 eax, 15
  00190	85 c0		 test	 eax, eax
  00192	74 53		 je	 SHORT $LN9@s370_conve

; 2050 :                          float_class_pos_signaling_nan |
; 2051 :                          float_class_neg_quiet_nan     |
; 2052 :                          float_class_pos_quiet_nan ))
; 2053 :     {
; 2054 :         /* NaN input always returns maximum negative integer,
; 2055 :            cc3, and IEEE invalid exception */
; 2056 :         op1 = -0x7FFFFFFF - 1;

  00194	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 2057 :         newcc = 3;

  0019c	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2058 :         softfloat_raiseFlags( softfloat_flag_invalid );

  001a1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a6	8b c0		 mov	 eax, eax
  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ae	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001bf	83 c8 10	 or	 eax, 16
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d1	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  001d7	45 8b c0	 mov	 r8d, r8d
  001da	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001de	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2059 :     }

  001e2	e9 1e 01 00 00	 jmp	 $LN10@s370_conve
$LN9@s370_conve:

; 2060 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  001e7	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  001eb	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  001f0	85 c0		 test	 eax, eax
  001f2	74 12		 je	 SHORT $LN11@s370_conve

; 2061 :     {
; 2062 :         newcc = 0;

  001f4	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 2063 :         op1 = 0;

  001f9	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2064 :     }

  00201	e9 ff 00 00 00	 jmp	 $LN12@s370_conve
$LN11@s370_conve:

; 2065 :     else
; 2066 :     {
; 2067 :         newcc = (op2.v & 0x8000000000000000ULL) ? 1 : 2;

  00206	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00210	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00215	48 23 c8	 and	 rcx, rax
  00218	48 8b c1	 mov	 rax, rcx
  0021b	48 85 c0	 test	 rax, rax
  0021e	74 0a		 je	 SHORT $LN20@s370_conve
  00220	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  00228	eb 08		 jmp	 SHORT $LN21@s370_conve
$LN20@s370_conve:
  0022a	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv180[rsp], 2
$LN21@s370_conve:
  00232	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv180[rsp]
  00237	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 2068 : 
; 2069 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  0023b	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0023f	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00244	85 c0		 test	 eax, eax
  00246	74 0d		 je	 SHORT $LN13@s370_conve

; 2070 :             op1 = 0;

  00248	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  00250	e9 b0 00 00 00	 jmp	 $LN14@s370_conve
$LN13@s370_conve:

; 2071 :         else
; 2072 :         {
; 2073 :             SET_SF_RM_FROM_MASK( m3 );

  00255	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  0025a	85 c0		 test	 eax, eax
  0025c	74 16		 je	 SHORT $LN22@s370_conve
  0025e	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0026a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026e	89 44 24 38	 mov	 DWORD PTR tv202[rsp], eax
  00272	eb 1f		 jmp	 SHORT $LN23@s370_conve
$LN22@s370_conve:
  00274	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00279	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0027f	83 e0 07	 and	 eax, 7
  00282	8b c0		 mov	 eax, eax
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0028b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028f	89 44 24 38	 mov	 DWORD PTR tv202[rsp], eax
$LN23@s370_conve:
  00293	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00298	8b c0		 mov	 eax, eax
  0029a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ad	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv202[rsp]
  002b2	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2074 :             op1 = f64_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002b5	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  002ba	83 e0 04	 and	 eax, 4
  002bd	85 c0		 test	 eax, eax
  002bf	75 0a		 jne	 SHORT $LN24@s370_conve
  002c1	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv208[rsp], 1
  002c9	eb 08		 jmp	 SHORT $LN25@s370_conve
$LN24@s370_conve:
  002cb	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv208[rsp], 0
$LN25@s370_conve:
  002d3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002d8	8b c0		 mov	 eax, eax
  002da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002e0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002e9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002ed	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv208[rsp]
  002f3	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002f7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  002fc	e8 00 00 00 00	 call	 f64_to_i32
  00301	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN14@s370_conve:
$LN12@s370_conve:
$LN10@s370_conve:

; 2075 :         }
; 2076 :     }
; 2077 : 
; 2078 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00305	33 c0		 xor	 eax, eax
  00307	83 f8 01	 cmp	 eax, 1
  0030a	74 45		 je	 SHORT $LN15@s370_conve
  0030c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00311	8b c0		 mov	 eax, eax
  00313	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00319	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00322	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00326	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0032a	83 e0 10	 and	 eax, 16
  0032d	85 c0		 test	 eax, eax
  0032f	74 20		 je	 SHORT $LN15@s370_conve
  00331	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00336	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0033c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00341	85 c0		 test	 eax, eax
  00343	74 0c		 je	 SHORT $LN15@s370_conve
  00345	b2 80		 mov	 dl, 128			; 00000080H
  00347	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	e8 00 00 00 00	 call	 ieee_trap
$LN15@s370_conve:

; 2079 : 
; 2080 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00351	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00356	8b c0		 mov	 eax, eax
  00358	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0035e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00367	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0036b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036f	83 e0 10	 and	 eax, 16
  00372	85 c0		 test	 eax, eax
  00374	74 52		 je	 SHORT $LN16@s370_conve

; 2081 :     {
; 2082 :         newcc = 3;

  00376	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2083 :         if (!SUPPRESS_INEXACT( m4 ))

  0037b	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00380	83 e0 04	 and	 eax, 4
  00383	85 c0		 test	 eax, eax
  00385	75 41		 jne	 SHORT $LN17@s370_conve

; 2084 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00387	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0038c	8b c0		 mov	 eax, eax
  0038e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00394	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0039d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003a1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a5	83 c8 01	 or	 eax, 1
  003a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003ae	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003b7	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  003bd	45 8b c0	 mov	 r8d, r8d
  003c0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003c4	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN17@s370_conve:
$LN16@s370_conve:

; 2085 :     }
; 2086 : 
; 2087 :     regs->GR_L( r1 ) = op1;

  003c8	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  003cd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003d2	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  003d6	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2088 :     regs->psw.cc = newcc;

  003dd	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  003e2	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  003e7	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2089 : 
; 2090 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  003ea	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003ef	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003f4	89 44 24 30	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2091 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  003f8	8b 44 24 30	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003fc	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00401	85 c0		 test	 eax, eax
  00403	74 0e		 je	 SHORT $LN18@s370_conve
  00405	8b 54 24 30	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00409	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0040e	e8 00 00 00 00	 call	 ieee_cond_trap
$LN18@s370_conve:

; 2092 : }

  00413	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00417	c3		 ret	 0
s370_convert_bfp_long_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
m3$ = 33
m4$ = 34
temp$1 = 36
op1$ = 40
op2_dataclass$ = 44
ieee_trap_conds$ = 48
r2$ = 52
tv187 = 56
tv209 = 60
tv215 = 64
r1$ = 68
tv357 = 72
tv286 = 80
$T2 = 96
$T3 = 112
op2$ = 128
__$ArrayPad$ = 144
inst$ = 192
regs$ = 200
s370_convert_bfp_ext_to_fix32_reg PROC

; 1952 : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1953 :     int         r1, r2;
; 1954 :     BYTE        m3, m4, newcc;
; 1955 :     S32         op1;
; 1956 :     float128_t  op2;
; 1957 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1958 :     U32         op2_dataclass;
; 1959 : 
; 1960 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 22	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 21	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  0007a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN5@s370_conve
  0009d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s370_conve

; 1961 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1962 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN7@s370_conve
  000d3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN6@s370_conve
  000ea	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00112	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 1963 :     BFPREGPAIR_CHECK( r2, regs );

  0013f	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  00143	83 e0 02	 and	 eax, 2
  00146	85 c0		 test	 eax, eax
  00148	74 1b		 je	 SHORT $LN8@s370_conve
  0014a	ba 06 00 00 00	 mov	 edx, 6
  0014f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 1964 :     BFPRM_CHECK( m3, regs );

  00165	0f b6 54 24 21	 movzx	 edx, BYTE PTR m3$[rsp]
  0016a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00172	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 1965 : 
; 1966 : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 1967 :     if (!FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  00177	b8 01 00 00 00	 mov	 eax, 1
  0017c	48 6b c0 04	 imul	 rax, rax, 4
  00180	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00188	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00190	83 e0 04	 and	 eax, 4
  00193	85 c0		 test	 eax, eax
  00195	75 05		 jne	 SHORT $LN9@s370_conve

; 1968 : #endif
; 1969 :         m4 = 0;

  00197	c6 44 24 22 00	 mov	 BYTE PTR m4$[rsp], 0
$LN9@s370_conve:

; 1970 : 
; 1971 :     GET_FLOAT128_OP( op2, r2, regs );

  0019c	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  001a0	d1 e0		 shl	 eax, 1
  001a2	48 98		 cdqe
  001a4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ac	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b4	48 8b d0	 mov	 rdx, rax
  001b7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001bf	e8 00 00 00 00	 call	 s370_get_float128

; 1972 :     op2_dataclass = float128_class( op2 );

  001c4	48 8d 44 24 60	 lea	 rax, QWORD PTR $T2[rsp]
  001c9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001d1	48 8b f8	 mov	 rdi, rax
  001d4	48 8b f1	 mov	 rsi, rcx
  001d7	b9 10 00 00 00	 mov	 ecx, 16
  001dc	f3 a4		 rep movsb
  001de	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  001e3	e8 00 00 00 00	 call	 float128_class
  001e8	89 44 24 2c	 mov	 DWORD PTR op2_dataclass$[rsp], eax

; 1973 :     softfloat_exceptionFlags = 0;

  001ec	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001f1	8b c0		 mov	 eax, eax
  001f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00202	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00206	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1974 : 
; 1975 :     if (op2_dataclass & (float_class_neg_signaling_nan |

  0020a	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  0020e	83 e0 0f	 and	 eax, 15
  00211	85 c0		 test	 eax, eax
  00213	74 50		 je	 SHORT $LN10@s370_conve

; 1976 :                          float_class_pos_signaling_nan |
; 1977 :                          float_class_neg_quiet_nan     |
; 1978 :                          float_class_pos_quiet_nan ))
; 1979 :     {
; 1980 :         /* NaN input always returns maximum negative integer,
; 1981 :            cc3, and IEEE invalid exception */
; 1982 :         op1 = -0x7FFFFFFF - 1;

  00215	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR op1$[rsp], -2147483648 ; ffffffff80000000H

; 1983 :         newcc = 3;

  0021d	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 1984 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00222	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00227	8b c0		 mov	 eax, eax
  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00238	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00240	83 c8 10	 or	 eax, 16
  00243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00249	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00252	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  00257	8b ff		 mov	 edi, edi
  00259	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025d	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 1985 :     }

  00260	e9 58 01 00 00	 jmp	 $LN11@s370_conve
$LN10@s370_conve:

; 1986 :     else if (op2_dataclass & (float_class_neg_zero | float_class_pos_zero))

  00265	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  00269	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  0026e	85 c0		 test	 eax, eax
  00270	74 12		 je	 SHORT $LN12@s370_conve

; 1987 :     {
; 1988 :         newcc = 0;

  00272	c6 44 24 20 00	 mov	 BYTE PTR newcc$[rsp], 0

; 1989 :         op1 = 0;

  00277	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 1990 :     }

  0027f	e9 39 01 00 00	 jmp	 $LN13@s370_conve
$LN12@s370_conve:

; 1991 :     else
; 1992 :     {
; 1993 :         newcc = (op2.v[FLOAT128_HI] & 0x8000000000000000ULL) ? 1 : 2;

  00284	b8 08 00 00 00	 mov	 eax, 8
  00289	48 6b c0 01	 imul	 rax, rax, 1
  0028d	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00297	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0029f	48 23 c1	 and	 rax, rcx
  002a2	48 85 c0	 test	 rax, rax
  002a5	74 0a		 je	 SHORT $LN21@s370_conve
  002a7	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  002af	eb 08		 jmp	 SHORT $LN22@s370_conve
$LN21@s370_conve:
  002b1	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv187[rsp], 2
$LN22@s370_conve:
  002b9	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv187[rsp]
  002be	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1994 : 
; 1995 :         if (op2_dataclass & (float_class_neg_subnormal | float_class_pos_subnormal))

  002c2	8b 44 24 2c	 mov	 eax, DWORD PTR op2_dataclass$[rsp]
  002c6	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002cb	85 c0		 test	 eax, eax
  002cd	74 0d		 je	 SHORT $LN14@s370_conve

; 1996 :             op1 = 0;

  002cf	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0
  002d7	e9 e1 00 00 00	 jmp	 $LN15@s370_conve
$LN14@s370_conve:

; 1997 :         else
; 1998 :         {
; 1999 :             SET_SF_RM_FROM_MASK( m3 );

  002dc	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002e1	85 c0		 test	 eax, eax
  002e3	74 16		 je	 SHORT $LN23@s370_conve
  002e5	0f b6 44 24 21	 movzx	 eax, BYTE PTR m3$[rsp]
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  002f1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f5	89 44 24 3c	 mov	 DWORD PTR tv209[rsp], eax
  002f9	eb 22		 jmp	 SHORT $LN24@s370_conve
$LN23@s370_conve:
  002fb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00303	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00309	83 e0 07	 and	 eax, 7
  0030c	8b c0		 mov	 eax, eax
  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00315	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00319	89 44 24 3c	 mov	 DWORD PTR tv209[rsp], eax
$LN24@s370_conve:
  0031d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00322	8b c0		 mov	 eax, eax
  00324	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0032a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00333	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00337	0f b6 54 24 3c	 movzx	 edx, BYTE PTR tv209[rsp]
  0033c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2000 :             op1 = f128_to_i32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  0033f	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  00344	83 e0 04	 and	 eax, 4
  00347	85 c0		 test	 eax, eax
  00349	75 0a		 jne	 SHORT $LN25@s370_conve
  0034b	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv215[rsp], 1
  00353	eb 08		 jmp	 SHORT $LN26@s370_conve
$LN25@s370_conve:
  00355	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN26@s370_conve:
  0035d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00362	8b c0		 mov	 eax, eax
  00364	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0036a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00373	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00377	48 89 4c 24 50	 mov	 QWORD PTR tv286[rsp], rcx
  0037c	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T3[rsp]
  00381	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR op2$[rsp]
  00389	48 89 7c 24 48	 mov	 QWORD PTR tv357[rsp], rdi
  0038e	48 8b fa	 mov	 rdi, rdx
  00391	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv357[rsp]
  00396	48 8b f2	 mov	 rsi, rdx
  00399	b9 10 00 00 00	 mov	 ecx, 16
  0039e	f3 a4		 rep movsb
  003a0	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR tv215[rsp]
  003a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv286[rsp]
  003ab	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  003af	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T3[rsp]
  003b4	e8 00 00 00 00	 call	 f128_to_i32
  003b9	89 44 24 28	 mov	 DWORD PTR op1$[rsp], eax
$LN15@s370_conve:
$LN13@s370_conve:
$LN11@s370_conve:

; 2001 :         }
; 2002 :     }
; 2003 : 
; 2004 :     IEEE_EXCEPTION_TRAP_XI( regs );

  003bd	33 c0		 xor	 eax, eax
  003bf	83 f8 01	 cmp	 eax, 1
  003c2	74 4b		 je	 SHORT $LN16@s370_conve
  003c4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003c9	8b c0		 mov	 eax, eax
  003cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003d1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003da	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003de	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e2	83 e0 10	 and	 eax, 16
  003e5	85 c0		 test	 eax, eax
  003e7	74 26		 je	 SHORT $LN16@s370_conve
  003e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  003f7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003fc	85 c0		 test	 eax, eax
  003fe	74 0f		 je	 SHORT $LN16@s370_conve
  00400	b2 80		 mov	 dl, 128			; 00000080H
  00402	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040a	e8 00 00 00 00	 call	 ieee_trap
$LN16@s370_conve:

; 2005 : 
; 2006 :     /* Non-trappable Invalid exception? */
; 2007 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0040f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00414	8b c0		 mov	 eax, eax
  00416	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0041c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00425	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00429	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0042d	83 e0 10	 and	 eax, 16
  00430	85 c0		 test	 eax, eax
  00432	74 4f		 je	 SHORT $LN17@s370_conve

; 2008 :     {
; 2009 :         newcc = 3;

  00434	c6 44 24 20 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2010 : 
; 2011 :         /* Inexact not suppressed? */
; 2012 :         if (!SUPPRESS_INEXACT( m4 ))

  00439	0f b6 44 24 22	 movzx	 eax, BYTE PTR m4$[rsp]
  0043e	83 e0 04	 and	 eax, 4
  00441	85 c0		 test	 eax, eax
  00443	75 3e		 jne	 SHORT $LN18@s370_conve

; 2013 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00445	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0044a	8b c0		 mov	 eax, eax
  0044c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00452	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0045b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0045f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00463	83 c8 01	 or	 eax, 1
  00466	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0046c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00475	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  0047a	8b ff		 mov	 edi, edi
  0047c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00480	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN18@s370_conve:
$LN17@s370_conve:

; 2014 :     }
; 2015 : 
; 2016 :     regs->GR_L( r1 ) = op1;

  00483	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  00488	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00490	8b 54 24 28	 mov	 edx, DWORD PTR op1$[rsp]
  00494	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2017 :     regs->psw.cc = newcc;

  0049b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a3	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  004a8	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2018 : 
; 2019 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  004ab	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  004b8	89 44 24 30	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2020 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  004bc	8b 44 24 30	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  004c0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004c5	85 c0		 test	 eax, eax
  004c7	74 11		 je	 SHORT $LN19@s370_conve
  004c9	8b 54 24 30	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  004cd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d5	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@s370_conve:

; 2021 : }

  004da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004e2	48 33 cc	 xor	 rcx, rsp
  004e5	e8 00 00 00 00	 call	 __security_check_cookie
  004ea	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  004f1	5f		 pop	 rdi
  004f2	5e		 pop	 rsi
  004f3	c3		 ret	 0
s370_convert_bfp_ext_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
s370_compare_bfp_short_reg PROC

; 1471 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1472 :     int        r1, r2;
; 1473 :     float32_t  op1, op2;
; 1474 :     BYTE       newcc;
; 1475 : 
; 1476 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_compa

; 1477 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1478 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_compa
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_compa
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_compa
$LN10@s370_compa:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_compa:
$LN7@s370_compa:

; 1479 : 
; 1480 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float32
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s370_get_float32
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s370_compa

; 1481 : 
; 1482 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1483 :     newcc = FLOAT32_COMPARE( op1, op2 );

  0014f	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  00153	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  00157	e8 00 00 00 00	 call	 s370_float32_compare
  0015c	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1484 : 
; 1485 :     /* Xi is only trap that suppresses result, no return */
; 1486 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00160	33 c0		 xor	 eax, eax
  00162	83 f8 01	 cmp	 eax, 1
  00165	74 45		 je	 SHORT $LN11@s370_compa
  00167	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016c	8b c0		 mov	 eax, eax
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00174	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00181	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00185	83 e0 10	 and	 eax, 16
  00188	85 c0		 test	 eax, eax
  0018a	74 20		 je	 SHORT $LN11@s370_compa
  0018c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00191	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00197	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019c	85 c0		 test	 eax, eax
  0019e	74 0c		 je	 SHORT $LN11@s370_compa
  001a0	b2 80		 mov	 dl, 128			; 00000080H
  001a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_compa:

; 1487 :     SET_FPC_FLAGS_FROM_SF( regs );

  001ac	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b1	8b c0		 mov	 eax, eax
  001b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ca	c1 e0 13	 shl	 eax, 19
  001cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001d8	c1 e9 08	 shr	 ecx, 8
  001db	f7 d1		 not	 ecx
  001dd	23 c1		 and	 eax, ecx
  001df	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001ef	0b c8		 or	 ecx, eax
  001f1	8b c1		 mov	 eax, ecx
  001f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001f8	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1488 :     regs->psw.cc = newcc;

  001fe	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00203	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00208	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1489 : }

  0020b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0020f	c3		 ret	 0
s370_compare_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
effective_addr2$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s370_compare_bfp_short PROC

; 1495 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1496 :     int        r1, x2, b2;
; 1497 :     VADR       effective_addr2;
; 1498 :     float32_t  op1, op2;
; 1499 :     BYTE       newcc;
; 1500 : 
; 1501 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s370_compa
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_compa:
  00070	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s370_compa
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_compa:
  000a2	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000a6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ab	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_compa:
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 06	 add	 rax, 6
  000bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN7@s370_compa
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_compa:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 d1		 jne	 SHORT $LN4@s370_compa

; 1502 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1503 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1504 :     BFPINST_CHECK( regs );

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	85 c0		 test	 eax, eax
  000fa	74 39		 je	 SHORT $LN9@s370_compa
  000fc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00107	d1 e8		 shr	 eax, 1
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	74 49		 je	 SHORT $LN8@s370_compa
  00110	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	48 6b c9 01	 imul	 rcx, rcx, 1
  00125	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	75 24		 jne	 SHORT $LN8@s370_compa
$LN9@s370_compa:
  00135	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00144	ba 07 00 00 00	 mov	 edx, 7
  00149	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00153	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_compa:

; 1505 : 
; 1506 :     GET_FLOAT32_OP( op1, r1, regs );

  00159	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	48 98		 cdqe
  00161	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016e	48 8b d0	 mov	 rdx, rax
  00171	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  00176	e8 00 00 00 00	 call	 s370_get_float32

; 1507 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0017b	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00180	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00184	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00188	e8 00 00 00 00	 call	 s370_vfetch4
  0018d	89 44 24 38	 mov	 DWORD PTR op2$[rsp], eax

; 1508 : 
; 1509 :     softfloat_exceptionFlags = 0;

  00191	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00196	8b c0		 mov	 eax, eax
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ab	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1510 :     newcc = FLOAT32_COMPARE( op1, op2 );

  001af	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  001b3	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  001b7	e8 00 00 00 00	 call	 s370_float32_compare
  001bc	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1511 : 
; 1512 :     /* Xi is only trap that suppresses result, no return */
; 1513 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001c0	33 c0		 xor	 eax, eax
  001c2	83 f8 01	 cmp	 eax, 1
  001c5	74 45		 je	 SHORT $LN10@s370_compa
  001c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001cc	8b c0		 mov	 eax, eax
  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e5	83 e0 10	 and	 eax, 16
  001e8	85 c0		 test	 eax, eax
  001ea	74 20		 je	 SHORT $LN10@s370_compa
  001ec	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001fc	85 c0		 test	 eax, eax
  001fe	74 0c		 je	 SHORT $LN10@s370_compa
  00200	b2 80		 mov	 dl, 128			; 00000080H
  00202	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_compa:

; 1514 :     SET_FPC_FLAGS_FROM_SF( regs );

  0020c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00211	8b c0		 mov	 eax, eax
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00219	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00222	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00226	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022a	c1 e0 13	 shl	 eax, 19
  0022d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00238	c1 e9 08	 shr	 ecx, 8
  0023b	f7 d1		 not	 ecx
  0023d	23 c1		 and	 eax, ecx
  0023f	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00244	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0024f	0b c8		 or	 ecx, eax
  00251	8b c1		 mov	 eax, ecx
  00253	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00258	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1515 :     regs->psw.cc = newcc;

  0025e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00263	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00268	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1516 : }

  0026b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0026f	c3		 ret	 0
s370_compare_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
s370_compare_bfp_long_reg PROC

; 1419 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1420 :     int        r1, r2;
; 1421 :     float64_t  op1, op2;
; 1422 :     BYTE       newcc;
; 1423 : 
; 1424 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_compa

; 1425 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1426 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_compa
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_compa
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_compa
$LN10@s370_compa:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_compa:
$LN7@s370_compa:

; 1427 : 
; 1428 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float64
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s370_get_float64
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s370_compa

; 1429 : 
; 1430 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1431 :     newcc = FLOAT64_COMPARE( op1, op2 );

  0014f	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  00154	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op1$[rsp]
  00159	e8 00 00 00 00	 call	 s370_float64_compare
  0015e	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1432 : 
; 1433 :     /* Xi is only trap that suppresses result, no return */
; 1434 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00162	33 c0		 xor	 eax, eax
  00164	83 f8 01	 cmp	 eax, 1
  00167	74 45		 je	 SHORT $LN11@s370_compa
  00169	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016e	8b c0		 mov	 eax, eax
  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00176	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00183	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00187	83 e0 10	 and	 eax, 16
  0018a	85 c0		 test	 eax, eax
  0018c	74 20		 je	 SHORT $LN11@s370_compa
  0018e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00193	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00199	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019e	85 c0		 test	 eax, eax
  001a0	74 0c		 je	 SHORT $LN11@s370_compa
  001a2	b2 80		 mov	 dl, 128			; 00000080H
  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_compa:

; 1435 :     SET_FPC_FLAGS_FROM_SF( regs );

  001ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b3	8b c0		 mov	 eax, eax
  001b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001bb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cc	c1 e0 13	 shl	 eax, 19
  001cf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001da	c1 e9 08	 shr	 ecx, 8
  001dd	f7 d1		 not	 ecx
  001df	23 c1		 and	 eax, ecx
  001e1	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001f1	0b c8		 or	 ecx, eax
  001f3	8b c1		 mov	 eax, ecx
  001f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001fa	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1436 :     regs->psw.cc = newcc;

  00200	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00205	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0020a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1437 : }

  0020d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00211	c3		 ret	 0
s370_compare_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
effective_addr2$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
s370_compare_bfp_long PROC

; 1443 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1444 :     int        r1, x2, b2;
; 1445 :     VADR       effective_addr2;
; 1446 :     float64_t  op1, op2;
; 1447 :     BYTE       newcc;
; 1448 : 
; 1449 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s370_compa
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_compa:
  00070	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s370_compa
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_compa:
  000a2	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000a6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ab	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_compa:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 06	 add	 rax, 6
  000bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN7@s370_compa
  000cc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_compa:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 d1		 jne	 SHORT $LN4@s370_compa

; 1450 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1451 : 
; 1452 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1453 :     BFPINST_CHECK( regs );

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	85 c0		 test	 eax, eax
  000fa	74 39		 je	 SHORT $LN9@s370_compa
  000fc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00107	d1 e8		 shr	 eax, 1
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	74 49		 je	 SHORT $LN8@s370_compa
  00110	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	48 6b c9 01	 imul	 rcx, rcx, 1
  00125	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	75 24		 jne	 SHORT $LN8@s370_compa
$LN9@s370_compa:
  00135	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00144	ba 07 00 00 00	 mov	 edx, 7
  00149	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00153	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_compa:

; 1454 :     GET_FLOAT64_OP( op1, r1, regs );

  00159	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	48 98		 cdqe
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016e	48 8b d0	 mov	 rdx, rax
  00171	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00176	e8 00 00 00 00	 call	 s370_get_float64

; 1455 : 
; 1456 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0017b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00180	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00184	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00188	e8 00 00 00 00	 call	 s370_vfetch8
  0018d	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 1457 : 
; 1458 :     softfloat_exceptionFlags = 0;

  00192	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00197	8b c0		 mov	 eax, eax
  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ac	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1459 :     newcc = FLOAT64_COMPARE( op1, op2 );

  001b0	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  001b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  001ba	e8 00 00 00 00	 call	 s370_float64_compare
  001bf	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1460 : 
; 1461 :     /* Xi is only trap that suppresses result, no return */
; 1462 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001c3	33 c0		 xor	 eax, eax
  001c5	83 f8 01	 cmp	 eax, 1
  001c8	74 45		 je	 SHORT $LN10@s370_compa
  001ca	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001cf	8b c0		 mov	 eax, eax
  001d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e8	83 e0 10	 and	 eax, 16
  001eb	85 c0		 test	 eax, eax
  001ed	74 20		 je	 SHORT $LN10@s370_compa
  001ef	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f4	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001fa	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001ff	85 c0		 test	 eax, eax
  00201	74 0c		 je	 SHORT $LN10@s370_compa
  00203	b2 80		 mov	 dl, 128			; 00000080H
  00205	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0020a	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_compa:

; 1463 :     SET_FPC_FLAGS_FROM_SF( regs );

  0020f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00214	8b c0		 mov	 eax, eax
  00216	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00225	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00229	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022d	c1 e0 13	 shl	 eax, 19
  00230	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00235	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0023b	c1 e9 08	 shr	 ecx, 8
  0023e	f7 d1		 not	 ecx
  00240	23 c1		 and	 eax, ecx
  00242	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00247	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0024c	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00252	0b c8		 or	 ecx, eax
  00254	8b c1		 mov	 eax, ecx
  00256	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1464 :     regs->psw.cc = newcc;

  00261	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00266	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0026b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1465 : }

  0026e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00272	c3		 ret	 0
s370_compare_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s370_compare_bfp_ext_reg PROC

; 1391 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1392 :     int         r1, r2;
; 1393 :     float128_t  op1, op2;
; 1394 :     BYTE        newcc;
; 1395 : 
; 1396 :     RRE( inst, regs, r1, r2 );

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 03	 imul	 rax, rax, 3
  0002b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00033	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00037	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	c1 f8 04	 sar	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00054	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00060	48 83 c0 04	 add	 rax, 4
  00064	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00070	33 c0		 xor	 eax, eax
  00072	83 f8 04	 cmp	 eax, 4
  00075	74 0f		 je	 SHORT $LN8@s370_compa
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_compa:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 c8		 jne	 SHORT $LN4@s370_compa

; 1397 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1398 :     BFPINST_CHECK( regs );

  0008c	b8 08 00 00 00	 mov	 eax, 8
  00091	48 6b c0 01	 imul	 rax, rax, 1
  00095	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 3f		 je	 SHORT $LN10@s370_compa
  000ad	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bb	d1 e8		 shr	 eax, 1
  000bd	83 e0 01	 and	 eax, 1
  000c0	85 c0		 test	 eax, eax
  000c2	74 55		 je	 SHORT $LN9@s370_compa
  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d3	b9 08 00 00 00	 mov	 ecx, 8
  000d8	48 6b c9 01	 imul	 rcx, rcx, 1
  000dc	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e8	85 c0		 test	 eax, eax
  000ea	75 2d		 jne	 SHORT $LN9@s370_compa
$LN10@s370_compa:
  000ec	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fe	ba 07 00 00 00	 mov	 edx, 7
  00103	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00113	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_compa:

; 1399 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00119	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011d	83 e0 02	 and	 eax, 2
  00120	85 c0		 test	 eax, eax
  00122	75 0b		 jne	 SHORT $LN12@s370_compa
  00124	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	74 1b		 je	 SHORT $LN11@s370_compa
$LN12@s370_compa:
  0012f	ba 06 00 00 00	 mov	 edx, 6
  00134	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00144	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_compa:
$LN7@s370_compa:

; 1400 : 
; 1401 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  0014a	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0014e	d1 e0		 shl	 eax, 1
  00150	48 98		 cdqe
  00152	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00162	48 8b d0	 mov	 rdx, rax
  00165	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_get_float128
  0016f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00173	d1 e0		 shl	 eax, 1
  00175	48 98		 cdqe
  00177	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00187	48 8b d0	 mov	 rdx, rax
  0018a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0018f	e8 00 00 00 00	 call	 s370_get_float128
  00194	33 c0		 xor	 eax, eax
  00196	85 c0		 test	 eax, eax
  00198	75 b0		 jne	 SHORT $LN7@s370_compa

; 1402 : 
; 1403 :     softfloat_exceptionFlags = 0;

  0019a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019f	8b c0		 mov	 eax, eax
  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1404 :     newcc = FLOAT128_COMPARE( op1, op2 );

  001b8	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  001bd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001c2	48 8b f8	 mov	 rdi, rax
  001c5	48 8b f1	 mov	 rsi, rcx
  001c8	b9 10 00 00 00	 mov	 ecx, 16
  001cd	f3 a4		 rep movsb
  001cf	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  001d4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001d9	48 8b f8	 mov	 rdi, rax
  001dc	48 8b f1	 mov	 rsi, rcx
  001df	b9 10 00 00 00	 mov	 ecx, 16
  001e4	f3 a4		 rep movsb
  001e6	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  001eb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  001f0	e8 00 00 00 00	 call	 s370_float128_compare
  001f5	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1405 : 
; 1406 :     /* Xi is only trap that suppresses result, no return */
; 1407 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001f9	33 c0		 xor	 eax, eax
  001fb	83 f8 01	 cmp	 eax, 1
  001fe	74 4b		 je	 SHORT $LN13@s370_compa
  00200	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00205	8b c0		 mov	 eax, eax
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00216	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021e	83 e0 10	 and	 eax, 16
  00221	85 c0		 test	 eax, eax
  00223	74 26		 je	 SHORT $LN13@s370_compa
  00225	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00233	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0f		 je	 SHORT $LN13@s370_compa
  0023c	b2 80		 mov	 dl, 128			; 00000080H
  0023e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	e8 00 00 00 00	 call	 ieee_trap
$LN13@s370_compa:

; 1408 : 
; 1409 :     SET_FPC_FLAGS_FROM_SF( regs );

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00269	c1 e0 13	 shl	 eax, 19
  0026c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0027a	c1 e9 08	 shr	 ecx, 8
  0027d	f7 d1		 not	 ecx
  0027f	23 c1		 and	 eax, ecx
  00281	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00286	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00294	0b c8		 or	 ecx, eax
  00296	8b c1		 mov	 eax, ecx
  00298	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1410 : 
; 1411 :     /* Xi is only possible exception detected for Compare   */
; 1412 :     regs->psw.cc = newcc;

  002a6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ae	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  002b3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1413 : }

  002b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002bb	48 33 cc	 xor	 rcx, rsp
  002be	e8 00 00 00 00	 call	 __security_check_cookie
  002c3	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002ca	5f		 pop	 rdi
  002cb	5e		 pop	 rsi
  002cc	c3		 ret	 0
s370_compare_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 52
inst$ = 80
regs$ = 88
s370_compare_and_signal_bfp_short_reg PROC

; 1598 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1599 :     int        r1, r2;
; 1600 :     float32_t  op1, op2;
; 1601 :     BYTE       newcc;
; 1602 : 
; 1603 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_compa

; 1604 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1605 :     BFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_compa
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_compa
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_compa
$LN10@s370_compa:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_compa:
$LN7@s370_compa:

; 1606 : 
; 1607 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 34	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float32
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s370_get_float32
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s370_compa

; 1608 : 
; 1609 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1610 :     newcc = FLOAT32_COMPARE_AND_SIGNAL( op1, op2 );

  0014f	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  00153	8b 4c 24 34	 mov	 ecx, DWORD PTR op1$[rsp]
  00157	e8 00 00 00 00	 call	 s370_float32_signaling_compare
  0015c	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1611 : 
; 1612 :     /* Xi is only trap that suppresses result, no return */
; 1613 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00160	33 c0		 xor	 eax, eax
  00162	83 f8 01	 cmp	 eax, 1
  00165	74 45		 je	 SHORT $LN11@s370_compa
  00167	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016c	8b c0		 mov	 eax, eax
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00174	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00181	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00185	83 e0 10	 and	 eax, 16
  00188	85 c0		 test	 eax, eax
  0018a	74 20		 je	 SHORT $LN11@s370_compa
  0018c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00191	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00197	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019c	85 c0		 test	 eax, eax
  0019e	74 0c		 je	 SHORT $LN11@s370_compa
  001a0	b2 80		 mov	 dl, 128			; 00000080H
  001a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_compa:

; 1614 :     SET_FPC_FLAGS_FROM_SF( regs );

  001ac	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b1	8b c0		 mov	 eax, eax
  001b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ca	c1 e0 13	 shl	 eax, 19
  001cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001d8	c1 e9 08	 shr	 ecx, 8
  001db	f7 d1		 not	 ecx
  001dd	23 c1		 and	 eax, ecx
  001df	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001ef	0b c8		 or	 ecx, eax
  001f1	8b c1		 mov	 eax, ecx
  001f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001f8	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1615 :     regs->psw.cc = newcc;

  001fe	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00203	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00208	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1616 : }

  0020b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0020f	c3		 ret	 0
s370_compare_and_signal_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
effective_addr2$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s370_compare_and_signal_bfp_short PROC

; 1622 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1623 :     int        r1, x2, b2;
; 1624 :     VADR       effective_addr2;
; 1625 :     float32_t  op1, op2;
; 1626 :     BYTE       newcc;
; 1627 : 
; 1628 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s370_compa
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_compa:
  00070	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s370_compa
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_compa:
  000a2	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000a6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ab	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_compa:
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 06	 add	 rax, 6
  000bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN7@s370_compa
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_compa:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 d1		 jne	 SHORT $LN4@s370_compa

; 1629 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1630 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1631 :     BFPINST_CHECK( regs );

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	85 c0		 test	 eax, eax
  000fa	74 39		 je	 SHORT $LN9@s370_compa
  000fc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00107	d1 e8		 shr	 eax, 1
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	74 49		 je	 SHORT $LN8@s370_compa
  00110	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	48 6b c9 01	 imul	 rcx, rcx, 1
  00125	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	75 24		 jne	 SHORT $LN8@s370_compa
$LN9@s370_compa:
  00135	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00144	ba 07 00 00 00	 mov	 edx, 7
  00149	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00153	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_compa:

; 1632 : 
; 1633 :     GET_FLOAT32_OP( op1, r1, regs );

  00159	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	48 98		 cdqe
  00161	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016e	48 8b d0	 mov	 rdx, rax
  00171	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  00176	e8 00 00 00 00	 call	 s370_get_float32

; 1634 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  0017b	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00180	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00184	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00188	e8 00 00 00 00	 call	 s370_vfetch4
  0018d	89 44 24 38	 mov	 DWORD PTR op2$[rsp], eax

; 1635 : 
; 1636 :     softfloat_exceptionFlags = 0;

  00191	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00196	8b c0		 mov	 eax, eax
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ab	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1637 :     newcc = FLOAT32_COMPARE_AND_SIGNAL( op1, op2 );

  001af	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  001b3	8b 4c 24 3c	 mov	 ecx, DWORD PTR op1$[rsp]
  001b7	e8 00 00 00 00	 call	 s370_float32_signaling_compare
  001bc	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1638 : 
; 1639 :     /* Xi is only trap that suppresses result, no return */
; 1640 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001c0	33 c0		 xor	 eax, eax
  001c2	83 f8 01	 cmp	 eax, 1
  001c5	74 45		 je	 SHORT $LN10@s370_compa
  001c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001cc	8b c0		 mov	 eax, eax
  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e5	83 e0 10	 and	 eax, 16
  001e8	85 c0		 test	 eax, eax
  001ea	74 20		 je	 SHORT $LN10@s370_compa
  001ec	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001fc	85 c0		 test	 eax, eax
  001fe	74 0c		 je	 SHORT $LN10@s370_compa
  00200	b2 80		 mov	 dl, 128			; 00000080H
  00202	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_compa:

; 1641 :     SET_FPC_FLAGS_FROM_SF( regs );

  0020c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00211	8b c0		 mov	 eax, eax
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00219	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00222	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00226	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022a	c1 e0 13	 shl	 eax, 19
  0022d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00238	c1 e9 08	 shr	 ecx, 8
  0023b	f7 d1		 not	 ecx
  0023d	23 c1		 and	 eax, ecx
  0023f	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00244	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0024f	0b c8		 or	 ecx, eax
  00251	8b c1		 mov	 eax, ecx
  00253	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00258	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1642 :     regs->psw.cc = newcc;

  0025e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00263	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00268	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1643 : }

  0026b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0026f	c3		 ret	 0
s370_compare_and_signal_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
op2$ = 48
op1$ = 56
inst$ = 80
regs$ = 88
s370_compare_and_signal_bfp_long_reg PROC

; 1547 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1548 :     int        r1, r2;
; 1549 :     float64_t  op1, op2;
; 1550 :     BYTE       newcc;
; 1551 : 
; 1552 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s370_compa
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_compa:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_compa

; 1553 : 
; 1554 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1555 :     BFPINST_CHECK(regs);

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN10@s370_compa
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN9@s370_compa
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN9@s370_compa
$LN10@s370_compa:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_compa:
$LN7@s370_compa:

; 1556 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000eb	d1 e0		 shl	 eax, 1
  000ed	48 98		 cdqe
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  00104	e8 00 00 00 00	 call	 s370_get_float64
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0010d	d1 e0		 shl	 eax, 1
  0010f	48 98		 cdqe
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00126	e8 00 00 00 00	 call	 s370_get_float64
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b6		 jne	 SHORT $LN7@s370_compa

; 1557 : 
; 1558 :     softfloat_exceptionFlags = 0;

  00131	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00136	8b c0		 mov	 eax, eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00147	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0014b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1559 :     newcc = FLOAT64_COMPARE_AND_SIGNAL( op1, op2 );

  0014f	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  00154	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op1$[rsp]
  00159	e8 00 00 00 00	 call	 s370_float64_signaling_compare
  0015e	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1560 : 
; 1561 :     /* Xi is only trap that suppresses result, no return */
; 1562 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00162	33 c0		 xor	 eax, eax
  00164	83 f8 01	 cmp	 eax, 1
  00167	74 45		 je	 SHORT $LN11@s370_compa
  00169	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0016e	8b c0		 mov	 eax, eax
  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00176	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0017f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00183	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00187	83 e0 10	 and	 eax, 16
  0018a	85 c0		 test	 eax, eax
  0018c	74 20		 je	 SHORT $LN11@s370_compa
  0018e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00193	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00199	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019e	85 c0		 test	 eax, eax
  001a0	74 0c		 je	 SHORT $LN11@s370_compa
  001a2	b2 80		 mov	 dl, 128			; 00000080H
  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	e8 00 00 00 00	 call	 ieee_trap
$LN11@s370_compa:

; 1563 :     SET_FPC_FLAGS_FROM_SF( regs );

  001ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b3	8b c0		 mov	 eax, eax
  001b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001bb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cc	c1 e0 13	 shl	 eax, 19
  001cf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001da	c1 e9 08	 shr	 ecx, 8
  001dd	f7 d1		 not	 ecx
  001df	23 c1		 and	 eax, ecx
  001e1	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001f1	0b c8		 or	 ecx, eax
  001f3	8b c1		 mov	 eax, ecx
  001f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001fa	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1564 :     regs->psw.cc = newcc;

  00200	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00205	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0020a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1565 : }

  0020d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00211	c3		 ret	 0
s370_compare_and_signal_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
effective_addr2$ = 36
temp$1 = 40
b2$ = 44
x2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
s370_compare_and_signal_bfp_long PROC

; 1571 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1572 :     int        r1, x2, b2;
; 1573 :     VADR       effective_addr2;
; 1574 :     float64_t  op1, op2;
; 1575 :     BYTE       newcc;
; 1576 : 
; 1577 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 1d		 je	 SHORT $LN5@s370_compa
  00053	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00058	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_compa:
  00070	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00074	c1 e8 0c	 shr	 eax, 12
  00077	83 e0 0f	 and	 eax, 15
  0007a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 1d		 je	 SHORT $LN6@s370_compa
  00085	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_compa:
  000a2	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000a6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ab	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_compa:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 06	 add	 rax, 6
  000bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN7@s370_compa
  000cc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_compa:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 d1		 jne	 SHORT $LN4@s370_compa

; 1578 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1579 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1580 :     BFPINST_CHECK( regs );

  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	85 c0		 test	 eax, eax
  000fa	74 39		 je	 SHORT $LN9@s370_compa
  000fc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00107	d1 e8		 shr	 eax, 1
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	74 49		 je	 SHORT $LN8@s370_compa
  00110	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	48 6b c9 01	 imul	 rcx, rcx, 1
  00125	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0012c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00131	85 c0		 test	 eax, eax
  00133	75 24		 jne	 SHORT $LN8@s370_compa
$LN9@s370_compa:
  00135	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00144	ba 07 00 00 00	 mov	 edx, 7
  00149	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00153	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_compa:

; 1581 : 
; 1582 :     GET_FLOAT64_OP( op1, r1, regs );

  00159	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	48 98		 cdqe
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016e	48 8b d0	 mov	 rdx, rax
  00171	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  00176	e8 00 00 00 00	 call	 s370_get_float64

; 1583 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  0017b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00180	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00184	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00188	e8 00 00 00 00	 call	 s370_vfetch8
  0018d	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 1584 : 
; 1585 :     softfloat_exceptionFlags = 0;

  00192	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00197	8b c0		 mov	 eax, eax
  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ac	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1586 :     newcc = FLOAT64_COMPARE_AND_SIGNAL( op1, op2 );

  001b0	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  001b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  001ba	e8 00 00 00 00	 call	 s370_float64_signaling_compare
  001bf	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1587 : 
; 1588 :     /* Xi is only trap that suppresses result, no return */
; 1589 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001c3	33 c0		 xor	 eax, eax
  001c5	83 f8 01	 cmp	 eax, 1
  001c8	74 45		 je	 SHORT $LN10@s370_compa
  001ca	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001cf	8b c0		 mov	 eax, eax
  001d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e8	83 e0 10	 and	 eax, 16
  001eb	85 c0		 test	 eax, eax
  001ed	74 20		 je	 SHORT $LN10@s370_compa
  001ef	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f4	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001fa	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001ff	85 c0		 test	 eax, eax
  00201	74 0c		 je	 SHORT $LN10@s370_compa
  00203	b2 80		 mov	 dl, 128			; 00000080H
  00205	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0020a	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_compa:

; 1590 :     SET_FPC_FLAGS_FROM_SF( regs );

  0020f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00214	8b c0		 mov	 eax, eax
  00216	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0021c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00225	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00229	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022d	c1 e0 13	 shl	 eax, 19
  00230	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00235	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0023b	c1 e9 08	 shr	 ecx, 8
  0023e	f7 d1		 not	 ecx
  00240	23 c1		 and	 eax, ecx
  00242	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00247	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0024c	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00252	0b c8		 or	 ecx, eax
  00254	8b c1		 mov	 eax, ecx
  00256	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1591 :     regs->psw.cc = newcc;

  00261	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00266	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0026b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1592 : }

  0026e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00272	c3		 ret	 0
s370_compare_and_signal_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
newcc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
$T2 = 48
$T3 = 64
op2$ = 80
op1$ = 96
__$ArrayPad$ = 112
inst$ = 160
regs$ = 168
s370_compare_and_signal_bfp_ext_reg PROC

; 1522 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1523 :     int         r1, r2;
; 1524 :     float128_t  op1, op2;
; 1525 :     BYTE        newcc;
; 1526 : 
; 1527 :     RRE( inst, regs, r1, r2 );

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 03	 imul	 rax, rax, 3
  0002b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00033	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00037	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	c1 f8 04	 sar	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00054	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00060	48 83 c0 04	 add	 rax, 4
  00064	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00070	33 c0		 xor	 eax, eax
  00072	83 f8 04	 cmp	 eax, 4
  00075	74 0f		 je	 SHORT $LN8@s370_compa
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_compa:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 c8		 jne	 SHORT $LN4@s370_compa

; 1528 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1529 :     BFPINST_CHECK( regs );

  0008c	b8 08 00 00 00	 mov	 eax, 8
  00091	48 6b c0 01	 imul	 rax, rax, 1
  00095	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 3f		 je	 SHORT $LN10@s370_compa
  000ad	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bb	d1 e8		 shr	 eax, 1
  000bd	83 e0 01	 and	 eax, 1
  000c0	85 c0		 test	 eax, eax
  000c2	74 55		 je	 SHORT $LN9@s370_compa
  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d3	b9 08 00 00 00	 mov	 ecx, 8
  000d8	48 6b c9 01	 imul	 rcx, rcx, 1
  000dc	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e8	85 c0		 test	 eax, eax
  000ea	75 2d		 jne	 SHORT $LN9@s370_compa
$LN10@s370_compa:
  000ec	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000fe	ba 07 00 00 00	 mov	 edx, 7
  00103	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00113	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_compa:

; 1530 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00119	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011d	83 e0 02	 and	 eax, 2
  00120	85 c0		 test	 eax, eax
  00122	75 0b		 jne	 SHORT $LN12@s370_compa
  00124	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	74 1b		 je	 SHORT $LN11@s370_compa
$LN12@s370_compa:
  0012f	ba 06 00 00 00	 mov	 edx, 6
  00134	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00144	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_compa:
$LN7@s370_compa:

; 1531 : 
; 1532 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  0014a	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0014e	d1 e0		 shl	 eax, 1
  00150	48 98		 cdqe
  00152	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015a	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00162	48 8b d0	 mov	 rdx, rax
  00165	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_get_float128
  0016f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00173	d1 e0		 shl	 eax, 1
  00175	48 98		 cdqe
  00177	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00187	48 8b d0	 mov	 rdx, rax
  0018a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0018f	e8 00 00 00 00	 call	 s370_get_float128
  00194	33 c0		 xor	 eax, eax
  00196	85 c0		 test	 eax, eax
  00198	75 b0		 jne	 SHORT $LN7@s370_compa

; 1533 : 
; 1534 :     softfloat_exceptionFlags = 0;

  0019a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019f	8b c0		 mov	 eax, eax
  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b0	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1535 :     newcc = FLOAT128_COMPARE_AND_SIGNAL( op1, op2 );

  001b8	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  001bd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  001c2	48 8b f8	 mov	 rdi, rax
  001c5	48 8b f1	 mov	 rsi, rcx
  001c8	b9 10 00 00 00	 mov	 ecx, 16
  001cd	f3 a4		 rep movsb
  001cf	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  001d4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001d9	48 8b f8	 mov	 rdi, rax
  001dc	48 8b f1	 mov	 rsi, rcx
  001df	b9 10 00 00 00	 mov	 ecx, 16
  001e4	f3 a4		 rep movsb
  001e6	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  001eb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  001f0	e8 00 00 00 00	 call	 s370_float128_signaling_compare
  001f5	88 44 24 20	 mov	 BYTE PTR newcc$[rsp], al

; 1536 : 
; 1537 :     /* Xi is only trap that suppresses result, no return */
; 1538 :     IEEE_EXCEPTION_TRAP_XI( regs );

  001f9	33 c0		 xor	 eax, eax
  001fb	83 f8 01	 cmp	 eax, 1
  001fe	74 4b		 je	 SHORT $LN13@s370_compa
  00200	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00205	8b c0		 mov	 eax, eax
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00216	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021e	83 e0 10	 and	 eax, 16
  00221	85 c0		 test	 eax, eax
  00223	74 26		 je	 SHORT $LN13@s370_compa
  00225	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00233	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0f		 je	 SHORT $LN13@s370_compa
  0023c	b2 80		 mov	 dl, 128			; 00000080H
  0023e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	e8 00 00 00 00	 call	 ieee_trap
$LN13@s370_compa:

; 1539 :     SET_FPC_FLAGS_FROM_SF( regs );

  0024b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00250	8b c0		 mov	 eax, eax
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00258	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00261	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00265	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00269	c1 e0 13	 shl	 eax, 19
  0026c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0027a	c1 e9 08	 shr	 ecx, 8
  0027d	f7 d1		 not	 ecx
  0027f	23 c1		 and	 eax, ecx
  00281	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00286	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00294	0b c8		 or	 ecx, eax
  00296	8b c1		 mov	 eax, ecx
  00298	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1540 :     regs->psw.cc = newcc;

  002a6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ae	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR newcc$[rsp]
  002b3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1541 : }

  002b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002bb	48 33 cc	 xor	 rcx, rsp
  002be	e8 00 00 00 00	 call	 __security_check_cookie
  002c3	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002ca	5f		 pop	 rdi
  002cb	5e		 pop	 rsi
  002cc	c3		 ret	 0
s370_compare_and_signal_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ans$ = 32
ieee_trap_conds$ = 36
i$1 = 40
tv194 = 44
r1$ = 48
tv210 = 52
tv213 = 56
tv215 = 60
tv216 = 64
r2$ = 68
op2$ = 72
op1$ = 76
inst$ = 96
regs$ = 104
s370_add_bfp_short_reg PROC

; 1314 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1315 :     int        r1, r2;
; 1316 :     float32_t  op1, op2, ans;
; 1317 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1318 : 
; 1319 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_b:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@s370_add_b
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s370_add_b:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_add_b

; 1320 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1321 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN13@s370_add_b
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN12@s370_add_b
  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN12@s370_add_b
$LN13@s370_add_b:
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_add_b:
$LN7@s370_add_b:

; 1322 : 
; 1323 :     GET_FLOAT32_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float32
  00111	8b 44 24 44	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s370_get_float32
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s370_add_b

; 1324 : 
; 1325 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1326 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1327 : 
; 1328 :     ans = f32_add( op1, op2 );

  00191	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00195	8b 4c 24 4c	 mov	 ecx, DWORD PTR op1$[rsp]
  00199	e8 00 00 00 00	 call	 f32_add
  0019e	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax

; 1329 : 
; 1330 :     if (softfloat_exceptionFlags)

  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a7	8b c0		 mov	 eax, eax
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001af	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 93 00 00
	00		 je	 $LN14@s370_add_b

; 1331 :     {
; 1332 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001c8	33 c0		 xor	 eax, eax
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	74 45		 je	 SHORT $LN15@s370_add_b
  001cf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d4	8b c0		 mov	 eax, eax
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	83 e0 10	 and	 eax, 16
  001f0	85 c0		 test	 eax, eax
  001f2	74 20		 je	 SHORT $LN15@s370_add_b
  001f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ff	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00204	85 c0		 test	 eax, eax
  00206	74 0c		 je	 SHORT $LN15@s370_add_b
  00208	b2 80		 mov	 dl, 128			; 00000080H
  0020a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	e8 00 00 00 00	 call	 ieee_trap
$LN15@s370_add_b:

; 1333 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00214	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0021e	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1334 : 
; 1335 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00222	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00226	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022b	85 c0		 test	 eax, eax
  0022d	74 2c		 je	 SHORT $LN16@s370_add_b

; 1336 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0022f	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00233	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN19@s370_add_b
  0023c	c7 44 24 2c 40
	ff ff ff	 mov	 DWORD PTR tv194[rsp], -192 ; ffffffffffffff40H
  00244	eb 08		 jmp	 SHORT $LN20@s370_add_b
$LN19@s370_add_b:
  00246	c7 44 24 2c c0
	00 00 00	 mov	 DWORD PTR tv194[rsp], 192 ; 000000c0H
$LN20@s370_add_b:
  0024e	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv194[rsp]
  00252	e8 00 00 00 00	 call	 f32_scaledResult
  00257	89 44 24 20	 mov	 DWORD PTR ans$[rsp], eax
$LN16@s370_add_b:
$LN14@s370_add_b:
$LN10@s370_add_b:

; 1337 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 1338 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 1339 :     }
; 1340 : 
; 1341 :     PUT_FLOAT32_CC( ans, r1, regs );

  0025b	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0025f	d1 e0		 shl	 eax, 1
  00261	48 98		 cdqe
  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00270	48 8b d0	 mov	 rdx, rax
  00273	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ans$[rsp]
  00278	e8 00 00 00 00	 call	 s370_put_float32
  0027d	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00281	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00286	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0028b	75 17		 jne	 SHORT $LN21@s370_add_b
  0028d	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  00291	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00296	85 c0		 test	 eax, eax
  00298	74 0a		 je	 SHORT $LN21@s370_add_b
  0029a	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv216[rsp], 3
  002a2	eb 5e		 jmp	 SHORT $LN28@s370_add_b
$LN21@s370_add_b:
  002a4	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  002a8	0f ba f0 1f	 btr	 eax, 31
  002ac	85 c0		 test	 eax, eax
  002ae	75 0a		 jne	 SHORT $LN22@s370_add_b
  002b0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  002b8	eb 08		 jmp	 SHORT $LN23@s370_add_b
$LN22@s370_add_b:
  002ba	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN23@s370_add_b:
  002c2	83 7c 24 34 00	 cmp	 DWORD PTR tv210[rsp], 0
  002c7	74 0a		 je	 SHORT $LN26@s370_add_b
  002c9	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  002d1	eb 27		 jmp	 SHORT $LN27@s370_add_b
$LN26@s370_add_b:
  002d3	8b 44 24 20	 mov	 eax, DWORD PTR ans$[rsp]
  002d7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002dc	85 c0		 test	 eax, eax
  002de	74 0a		 je	 SHORT $LN24@s370_add_b
  002e0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  002e8	eb 08		 jmp	 SHORT $LN25@s370_add_b
$LN24@s370_add_b:
  002ea	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv213[rsp], 2
$LN25@s370_add_b:
  002f2	8b 44 24 38	 mov	 eax, DWORD PTR tv213[rsp]
  002f6	89 44 24 3c	 mov	 DWORD PTR tv215[rsp], eax
$LN27@s370_add_b:
  002fa	8b 44 24 3c	 mov	 eax, DWORD PTR tv215[rsp]
  002fe	89 44 24 40	 mov	 DWORD PTR tv216[rsp], eax
$LN28@s370_add_b:
  00302	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00307	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv216[rsp]
  0030c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0030f	33 c0		 xor	 eax, eax
  00311	85 c0		 test	 eax, eax
  00313	0f 85 42 ff ff
	ff		 jne	 $LN10@s370_add_b

; 1342 : 
; 1343 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00319	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0031d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00322	85 c0		 test	 eax, eax
  00324	74 0e		 je	 SHORT $LN17@s370_add_b
  00326	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0032a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0032f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s370_add_b:

; 1344 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1345 : }

  00334	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00338	c3		 ret	 0
s370_add_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ans$ = 36
ieee_trap_conds$ = 40
temp$1 = 44
b2$ = 48
x2$ = 52
tv210 = 56
r1$ = 60
tv226 = 64
tv229 = 68
tv231 = 72
tv232 = 76
op2$ = 80
op1$ = 84
inst$ = 112
regs$ = 120
s370_add_bfp_short PROC

; 1351 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1352 :     int         r1, x2, b2;
; 1353 :     VADR       effective_addr2;
; 1354 :     float32_t  op1, op2, ans;
; 1355 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1356 : 
; 1357 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00038	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 34 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN8@s370_add_b
  0005b	48 63 44 24 34	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_add_b:
  00078	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN9@s370_add_b
  0008d	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_add_b:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000ae	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_add_b:
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f8 06	 cmp	 eax, 6
  000d2	74 0c		 je	 SHORT $LN10@s370_add_b
  000d4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_add_b:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d1		 jne	 SHORT $LN4@s370_add_b

; 1358 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1359 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1360 :     BFPINST_CHECK( regs );

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000fb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00100	85 c0		 test	 eax, eax
  00102	74 39		 je	 SHORT $LN12@s370_add_b
  00104	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010f	d1 e8		 shr	 eax, 1
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 49		 je	 SHORT $LN11@s370_add_b
  00118	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00124	b9 08 00 00 00	 mov	 ecx, 8
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	75 24		 jne	 SHORT $LN11@s370_add_b
$LN12@s370_add_b:
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0014c	ba 07 00 00 00	 mov	 edx, 7
  00151	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_add_b:

; 1361 : 
; 1362 :     GET_FLOAT32_OP( op1, r1, regs );

  00161	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00165	d1 e0		 shl	 eax, 1
  00167	48 98		 cdqe
  00169	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00176	48 8b d0	 mov	 rdx, rax
  00179	48 8d 4c 24 54	 lea	 rcx, QWORD PTR op1$[rsp]
  0017e	e8 00 00 00 00	 call	 s370_get_float32

; 1363 :     VFETCH_FLOAT32_OP( op2, effective_addr2, b2, regs );

  00183	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00188	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  0018c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00190	e8 00 00 00 00	 call	 s370_vfetch4
  00195	89 44 24 50	 mov	 DWORD PTR op2$[rsp], eax

; 1364 : 
; 1365 :     softfloat_exceptionFlags = 0;

  00199	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0019e	8b c0		 mov	 eax, eax
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001af	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1366 :     SET_SF_RM_FROM_FPC;

  001b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001c2	83 e0 07	 and	 eax, 7
  001c5	8b c0		 mov	 eax, eax
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001d3	8b d2		 mov	 edx, edx
  001d5	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001dc	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001e5	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1367 : 
; 1368 :     ans = f32_add( op1, op2 );

  001f1	8b 54 24 50	 mov	 edx, DWORD PTR op2$[rsp]
  001f5	8b 4c 24 54	 mov	 ecx, DWORD PTR op1$[rsp]
  001f9	e8 00 00 00 00	 call	 f32_add
  001fe	89 44 24 24	 mov	 DWORD PTR ans$[rsp], eax

; 1369 : 
; 1370 :     if (softfloat_exceptionFlags)

  00202	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00207	8b c0		 mov	 eax, eax
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00218	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00220	85 c0		 test	 eax, eax
  00222	0f 84 93 00 00
	00		 je	 $LN13@s370_add_b

; 1371 :     {
; 1372 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00228	33 c0		 xor	 eax, eax
  0022a	83 f8 01	 cmp	 eax, 1
  0022d	74 45		 je	 SHORT $LN14@s370_add_b
  0022f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00234	8b c0		 mov	 eax, eax
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0023c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00245	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00249	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024d	83 e0 10	 and	 eax, 16
  00250	85 c0		 test	 eax, eax
  00252	74 20		 je	 SHORT $LN14@s370_add_b
  00254	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00259	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0025f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00264	85 c0		 test	 eax, eax
  00266	74 0c		 je	 SHORT $LN14@s370_add_b
  00268	b2 80		 mov	 dl, 128			; 00000080H
  0026a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_add_b:

; 1373 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00274	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0027e	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1374 : 
; 1375 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00282	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00286	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0028b	85 c0		 test	 eax, eax
  0028d	74 2c		 je	 SHORT $LN15@s370_add_b

; 1376 :             ans = f32_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  0028f	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00293	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00298	85 c0		 test	 eax, eax
  0029a	74 0a		 je	 SHORT $LN18@s370_add_b
  0029c	c7 44 24 38 40
	ff ff ff	 mov	 DWORD PTR tv210[rsp], -192 ; ffffffffffffff40H
  002a4	eb 08		 jmp	 SHORT $LN19@s370_add_b
$LN18@s370_add_b:
  002a6	c7 44 24 38 c0
	00 00 00	 mov	 DWORD PTR tv210[rsp], 192 ; 000000c0H
$LN19@s370_add_b:
  002ae	8b 4c 24 38	 mov	 ecx, DWORD PTR tv210[rsp]
  002b2	e8 00 00 00 00	 call	 f32_scaledResult
  002b7	89 44 24 24	 mov	 DWORD PTR ans$[rsp], eax
$LN15@s370_add_b:
$LN13@s370_add_b:
$LN7@s370_add_b:

; 1377 :                 SCALE_FACTOR_ARITH_OFLOW_SHORT :
; 1378 :                 SCALE_FACTOR_ARITH_UFLOW_SHORT );
; 1379 :     }
; 1380 : 
; 1381 :     PUT_FLOAT32_CC( ans, r1, regs );

  002bb	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  002bf	d1 e0		 shl	 eax, 1
  002c1	48 98		 cdqe
  002c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  002d0	48 8b d0	 mov	 rdx, rax
  002d3	48 8d 4c 24 24	 lea	 rcx, QWORD PTR ans$[rsp]
  002d8	e8 00 00 00 00	 call	 s370_put_float32
  002dd	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  002e1	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  002e6	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  002eb	75 17		 jne	 SHORT $LN20@s370_add_b
  002ed	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  002f1	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  002f6	85 c0		 test	 eax, eax
  002f8	74 0a		 je	 SHORT $LN20@s370_add_b
  002fa	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv232[rsp], 3
  00302	eb 5e		 jmp	 SHORT $LN27@s370_add_b
$LN20@s370_add_b:
  00304	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  00308	0f ba f0 1f	 btr	 eax, 31
  0030c	85 c0		 test	 eax, eax
  0030e	75 0a		 jne	 SHORT $LN21@s370_add_b
  00310	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  00318	eb 08		 jmp	 SHORT $LN22@s370_add_b
$LN21@s370_add_b:
  0031a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN22@s370_add_b:
  00322	83 7c 24 40 00	 cmp	 DWORD PTR tv226[rsp], 0
  00327	74 0a		 je	 SHORT $LN25@s370_add_b
  00329	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
  00331	eb 27		 jmp	 SHORT $LN26@s370_add_b
$LN25@s370_add_b:
  00333	8b 44 24 24	 mov	 eax, DWORD PTR ans$[rsp]
  00337	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0033c	85 c0		 test	 eax, eax
  0033e	74 0a		 je	 SHORT $LN23@s370_add_b
  00340	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv229[rsp], 1
  00348	eb 08		 jmp	 SHORT $LN24@s370_add_b
$LN23@s370_add_b:
  0034a	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv229[rsp], 2
$LN24@s370_add_b:
  00352	8b 44 24 44	 mov	 eax, DWORD PTR tv229[rsp]
  00356	89 44 24 48	 mov	 DWORD PTR tv231[rsp], eax
$LN26@s370_add_b:
  0035a	8b 44 24 48	 mov	 eax, DWORD PTR tv231[rsp]
  0035e	89 44 24 4c	 mov	 DWORD PTR tv232[rsp], eax
$LN27@s370_add_b:
  00362	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00367	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv232[rsp]
  0036c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0036f	33 c0		 xor	 eax, eax
  00371	85 c0		 test	 eax, eax
  00373	0f 85 42 ff ff
	ff		 jne	 $LN7@s370_add_b

; 1382 : 
; 1383 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00379	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0037d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00382	85 c0		 test	 eax, eax
  00384	74 0e		 je	 SHORT $LN16@s370_add_b
  00386	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0038a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0038f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_add_b:

; 1384 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1385 : }

  00394	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00398	c3		 ret	 0
s370_add_bfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
ans$ = 40
i$1 = 48
tv194 = 52
r1$ = 56
tv210 = 60
tv213 = 64
tv215 = 68
tv216 = 72
r2$ = 76
op2$ = 80
op1$ = 88
inst$ = 112
regs$ = 120
s370_add_bfp_long_reg PROC

; 1237 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1238 :     int        r1, r2;
; 1239 :     float64_t  op1, op2, ans;
; 1240 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1241 : 
; 1242 :     RRE( inst, regs, r1, r2 );

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 03	 imul	 rax, rax, 3
  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00037	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0003b	c1 f8 04	 sar	 eax, 4
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_b:
  00045	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 04	 cmp	 eax, 4
  00060	74 0c		 je	 SHORT $LN11@s370_add_b
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s370_add_b:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d1		 jne	 SHORT $LN4@s370_add_b

; 1243 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1244 :     BFPINST_CHECK( regs );

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 01	 imul	 rax, rax, 1
  0007d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00089	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0008e	85 c0		 test	 eax, eax
  00090	74 39		 je	 SHORT $LN13@s370_add_b
  00092	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00097	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009d	d1 e8		 shr	 eax, 1
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	74 49		 je	 SHORT $LN12@s370_add_b
  000a6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b2	b9 08 00 00 00	 mov	 ecx, 8
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN12@s370_add_b
$LN13@s370_add_b:
  000cb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000da	ba 07 00 00 00	 mov	 edx, 7
  000df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_add_b:
$LN7@s370_add_b:

; 1245 : 
; 1246 :     GET_FLOAT64_OPS( op1, r1, op2, r2, regs );

  000ef	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  000f3	d1 e0		 shl	 eax, 1
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_get_float64
  00111	8b 44 24 4c	 mov	 eax, DWORD PTR r2$[rsp]
  00115	d1 e0		 shl	 eax, 1
  00117	48 98		 cdqe
  00119	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00126	48 8b d0	 mov	 rdx, rax
  00129	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op2$[rsp]
  0012e	e8 00 00 00 00	 call	 s370_get_float64
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 b6		 jne	 SHORT $LN7@s370_add_b

; 1247 : 
; 1248 :     softfloat_exceptionFlags = 0;

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00153	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1249 :     SET_SF_RM_FROM_FPC;

  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00162	83 e0 07	 and	 eax, 7
  00165	8b c0		 mov	 eax, eax
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0016e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00173	8b d2		 mov	 edx, edx
  00175	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0017c	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00185	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00189	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018d	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1250 : 
; 1251 :     ans = f64_add( op1, op2 );

  00191	48 8b 54 24 50	 mov	 rdx, QWORD PTR op2$[rsp]
  00196	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op1$[rsp]
  0019b	e8 00 00 00 00	 call	 f64_add
  001a0	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax

; 1252 : 
; 1253 :     if (softfloat_exceptionFlags)

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001aa	8b c0		 mov	 eax, eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001bb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 94 00 00
	00		 je	 $LN14@s370_add_b

; 1254 :     {
; 1255 :         IEEE_EXCEPTION_TRAP_XI( regs );

  001cb	33 c0		 xor	 eax, eax
  001cd	83 f8 01	 cmp	 eax, 1
  001d0	74 45		 je	 SHORT $LN15@s370_add_b
  001d2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001d7	8b c0		 mov	 eax, eax
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001df	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001e8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f0	83 e0 10	 and	 eax, 16
  001f3	85 c0		 test	 eax, eax
  001f5	74 20		 je	 SHORT $LN15@s370_add_b
  001f7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00202	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00207	85 c0		 test	 eax, eax
  00209	74 0c		 je	 SHORT $LN15@s370_add_b
  0020b	b2 80		 mov	 dl, 128			; 00000080H
  0020d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_trap
$LN15@s370_add_b:

; 1256 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00217	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00221	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1257 : 
; 1258 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  00225	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00229	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  0022e	85 c0		 test	 eax, eax
  00230	74 2d		 je	 SHORT $LN16@s370_add_b

; 1259 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  00232	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00236	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0023b	85 c0		 test	 eax, eax
  0023d	74 0a		 je	 SHORT $LN19@s370_add_b
  0023f	c7 44 24 34 00
	fa ff ff	 mov	 DWORD PTR tv194[rsp], -1536 ; fffffffffffffa00H
  00247	eb 08		 jmp	 SHORT $LN20@s370_add_b
$LN19@s370_add_b:
  00249	c7 44 24 34 00
	06 00 00	 mov	 DWORD PTR tv194[rsp], 1536 ; 00000600H
$LN20@s370_add_b:
  00251	8b 4c 24 34	 mov	 ecx, DWORD PTR tv194[rsp]
  00255	e8 00 00 00 00	 call	 f64_scaledResult
  0025a	48 89 44 24 28	 mov	 QWORD PTR ans$[rsp], rax
$LN16@s370_add_b:
$LN14@s370_add_b:
$LN10@s370_add_b:

; 1260 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 1261 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 1262 :     }
; 1263 : 
; 1264 :     PUT_FLOAT64_CC( ans, r1, regs );

  0025f	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00263	d1 e0		 shl	 eax, 1
  00265	48 98		 cdqe
  00267	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00274	48 8b d0	 mov	 rdx, rax
  00277	48 8d 4c 24 28	 lea	 rcx, QWORD PTR ans$[rsp]
  0027c	e8 00 00 00 00	 call	 s370_put_float64
  00281	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  0028b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00290	48 23 c8	 and	 rcx, rax
  00293	48 8b c1	 mov	 rax, rcx
  00296	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  002a0	48 3b c1	 cmp	 rax, rcx
  002a3	75 24		 jne	 SHORT $LN21@s370_add_b
  002a5	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  002af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  002b4	48 23 c8	 and	 rcx, rax
  002b7	48 8b c1	 mov	 rax, rcx
  002ba	48 85 c0	 test	 rax, rax
  002bd	74 0a		 je	 SHORT $LN21@s370_add_b
  002bf	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR tv216[rsp], 3
  002c7	eb 79		 jmp	 SHORT $LN28@s370_add_b
$LN21@s370_add_b:
  002c9	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  002d8	48 23 c8	 and	 rcx, rax
  002db	48 8b c1	 mov	 rax, rcx
  002de	48 85 c0	 test	 rax, rax
  002e1	75 0a		 jne	 SHORT $LN22@s370_add_b
  002e3	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  002eb	eb 08		 jmp	 SHORT $LN23@s370_add_b
$LN22@s370_add_b:
  002ed	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN23@s370_add_b:
  002f5	83 7c 24 3c 00	 cmp	 DWORD PTR tv210[rsp], 0
  002fa	74 0a		 je	 SHORT $LN26@s370_add_b
  002fc	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  00304	eb 34		 jmp	 SHORT $LN27@s370_add_b
$LN26@s370_add_b:
  00306	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00310	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ans$[rsp]
  00315	48 23 c8	 and	 rcx, rax
  00318	48 8b c1	 mov	 rax, rcx
  0031b	48 85 c0	 test	 rax, rax
  0031e	74 0a		 je	 SHORT $LN24@s370_add_b
  00320	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  00328	eb 08		 jmp	 SHORT $LN25@s370_add_b
$LN24@s370_add_b:
  0032a	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv213[rsp], 2
$LN25@s370_add_b:
  00332	8b 44 24 40	 mov	 eax, DWORD PTR tv213[rsp]
  00336	89 44 24 44	 mov	 DWORD PTR tv215[rsp], eax
$LN27@s370_add_b:
  0033a	8b 44 24 44	 mov	 eax, DWORD PTR tv215[rsp]
  0033e	89 44 24 48	 mov	 DWORD PTR tv216[rsp], eax
$LN28@s370_add_b:
  00342	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00347	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv216[rsp]
  0034c	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0034f	33 c0		 xor	 eax, eax
  00351	85 c0		 test	 eax, eax
  00353	0f 85 06 ff ff
	ff		 jne	 $LN10@s370_add_b

; 1265 : 
; 1266 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  00359	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0035d	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00362	85 c0		 test	 eax, eax
  00364	74 0e		 je	 SHORT $LN17@s370_add_b
  00366	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0036a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0036f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN17@s370_add_b:

; 1267 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1268 : }

  00374	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00378	c3		 ret	 0
s370_add_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
effective_addr2$ = 32
ieee_trap_conds$ = 36
temp$1 = 40
b2$ = 44
ans$ = 48
x2$ = 56
tv210 = 60
r1$ = 64
tv226 = 68
tv229 = 72
tv231 = 76
tv232 = 80
op2$ = 88
op1$ = 96
inst$ = 128
regs$ = 136
s370_add_bfp_long PROC

; 1274 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1275 :     int        r1, x2, b2;
; 1276 :     VADR       effective_addr2;
; 1277 :     float64_t  op1, op2, ans;
; 1278 :     int        ieee_trap_conds = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1279 : 
; 1280 :     RXE( inst, regs, r1, x2, b2, effective_addr2 );

  00016	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 _byteswap_ulong
  0002a	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00037	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	c1 e8 10	 shr	 eax, 16
  00042	83 e0 0f	 and	 eax, 15
  00045	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00049	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 14	 shr	 eax, 20
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00057	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005c	74 20		 je	 SHORT $LN8@s370_add_b
  0005e	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00063	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00072	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00076	03 c8		 add	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_add_b:
  0007e	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 20		 je	 SHORT $LN9@s370_add_b
  00093	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a7	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ab	03 c8		 add	 ecx, eax
  000ad	8b c1		 mov	 eax, ecx
  000af	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_add_b:
  000b3	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000b7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000bc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_add_b:
  000c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000cc	48 83 c0 06	 add	 rax, 6
  000d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000dc	33 c0		 xor	 eax, eax
  000de	83 f8 06	 cmp	 eax, 6
  000e1	74 0f		 je	 SHORT $LN10@s370_add_b
  000e3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_add_b:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 c8		 jne	 SHORT $LN4@s370_add_b

; 1281 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1282 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1283 :     BFPINST_CHECK( regs );

  000f8	b8 08 00 00 00	 mov	 eax, 8
  000fd	48 6b c0 01	 imul	 rax, rax, 1
  00101	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00110	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00115	85 c0		 test	 eax, eax
  00117	74 3f		 je	 SHORT $LN12@s370_add_b
  00119	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00127	d1 e8		 shr	 eax, 1
  00129	83 e0 01	 and	 eax, 1
  0012c	85 c0		 test	 eax, eax
  0012e	74 55		 je	 SHORT $LN11@s370_add_b
  00130	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00138	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013f	b9 08 00 00 00	 mov	 ecx, 8
  00144	48 6b c9 01	 imul	 rcx, rcx, 1
  00148	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0014f	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00154	85 c0		 test	 eax, eax
  00156	75 2d		 jne	 SHORT $LN11@s370_add_b
$LN12@s370_add_b:
  00158	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  0016a	ba 07 00 00 00	 mov	 edx, 7
  0016f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_add_b:

; 1284 : 
; 1285 :     GET_FLOAT64_OP( op1, r1, regs );

  00185	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  00189	d1 e0		 shl	 eax, 1
  0018b	48 98		 cdqe
  0018d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00195	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0019d	48 8b d0	 mov	 rdx, rax
  001a0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1$[rsp]
  001a5	e8 00 00 00 00	 call	 s370_get_float64

; 1286 :     VFETCH_FLOAT64_OP( op2, effective_addr2, b2, regs );

  001aa	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b2	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  001b6	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001ba	e8 00 00 00 00	 call	 s370_vfetch8
  001bf	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 1287 : 
; 1288 :     softfloat_exceptionFlags = 0;

  001c4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001c9	8b c0		 mov	 eax, eax
  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001da	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001de	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1289 :     SET_SF_RM_FROM_FPC;

  001e2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ea	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001f0	83 e0 07	 and	 eax, 7
  001f3	8b c0		 mov	 eax, eax
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001fc	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  00201	8b d2		 mov	 edx, edx
  00203	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0020a	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  00213	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  00217	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021b	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1290 : 
; 1291 :     ans = f64_add( op1, op2 );

  0021f	48 8b 54 24 58	 mov	 rdx, QWORD PTR op2$[rsp]
  00224	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1$[rsp]
  00229	e8 00 00 00 00	 call	 f64_add
  0022e	48 89 44 24 30	 mov	 QWORD PTR ans$[rsp], rax

; 1292 : 
; 1293 :     if (softfloat_exceptionFlags)

  00233	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00238	8b c0		 mov	 eax, eax
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00240	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00249	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0024d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00251	85 c0		 test	 eax, eax
  00253	0f 84 9d 00 00
	00		 je	 $LN13@s370_add_b

; 1294 :     {
; 1295 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00259	33 c0		 xor	 eax, eax
  0025b	83 f8 01	 cmp	 eax, 1
  0025e	74 4b		 je	 SHORT $LN14@s370_add_b
  00260	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00265	8b c0		 mov	 eax, eax
  00267	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0026d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00276	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027e	83 e0 10	 and	 eax, 16
  00281	85 c0		 test	 eax, eax
  00283	74 26		 je	 SHORT $LN14@s370_add_b
  00285	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00293	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00298	85 c0		 test	 eax, eax
  0029a	74 0f		 je	 SHORT $LN14@s370_add_b
  0029c	b2 80		 mov	 dl, 128			; 00000080H
  0029e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a6	e8 00 00 00 00	 call	 ieee_trap
$LN14@s370_add_b:

; 1296 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002ab	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002b8	89 44 24 24	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1297 : 
; 1298 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002bc	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002c0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002c5	85 c0		 test	 eax, eax
  002c7	74 2d		 je	 SHORT $LN15@s370_add_b

; 1299 :             ans = f64_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002c9	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002cd	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002d2	85 c0		 test	 eax, eax
  002d4	74 0a		 je	 SHORT $LN18@s370_add_b
  002d6	c7 44 24 3c 00
	fa ff ff	 mov	 DWORD PTR tv210[rsp], -1536 ; fffffffffffffa00H
  002de	eb 08		 jmp	 SHORT $LN19@s370_add_b
$LN18@s370_add_b:
  002e0	c7 44 24 3c 00
	06 00 00	 mov	 DWORD PTR tv210[rsp], 1536 ; 00000600H
$LN19@s370_add_b:
  002e8	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv210[rsp]
  002ec	e8 00 00 00 00	 call	 f64_scaledResult
  002f1	48 89 44 24 30	 mov	 QWORD PTR ans$[rsp], rax
$LN15@s370_add_b:
$LN13@s370_add_b:
$LN7@s370_add_b:

; 1300 :                 SCALE_FACTOR_ARITH_OFLOW_LONG :
; 1301 :                 SCALE_FACTOR_ARITH_UFLOW_LONG );
; 1302 :     }
; 1303 : 
; 1304 :     PUT_FLOAT64_CC( ans, r1, regs );

  002f6	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  002fa	d1 e0		 shl	 eax, 1
  002fc	48 98		 cdqe
  002fe	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00306	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0030e	48 8b d0	 mov	 rdx, rax
  00311	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ans$[rsp]
  00316	e8 00 00 00 00	 call	 s370_put_float64
  0031b	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00325	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  0032a	48 23 c8	 and	 rcx, rax
  0032d	48 8b c1	 mov	 rax, rcx
  00330	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0033a	48 3b c1	 cmp	 rax, rcx
  0033d	75 24		 jne	 SHORT $LN20@s370_add_b
  0033f	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00349	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  0034e	48 23 c8	 and	 rcx, rax
  00351	48 8b c1	 mov	 rax, rcx
  00354	48 85 c0	 test	 rax, rax
  00357	74 0a		 je	 SHORT $LN20@s370_add_b
  00359	c7 44 24 50 03
	00 00 00	 mov	 DWORD PTR tv232[rsp], 3
  00361	eb 79		 jmp	 SHORT $LN27@s370_add_b
$LN20@s370_add_b:
  00363	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0036d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  00372	48 23 c8	 and	 rcx, rax
  00375	48 8b c1	 mov	 rax, rcx
  00378	48 85 c0	 test	 rax, rax
  0037b	75 0a		 jne	 SHORT $LN21@s370_add_b
  0037d	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  00385	eb 08		 jmp	 SHORT $LN22@s370_add_b
$LN21@s370_add_b:
  00387	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN22@s370_add_b:
  0038f	83 7c 24 44 00	 cmp	 DWORD PTR tv226[rsp], 0
  00394	74 0a		 je	 SHORT $LN25@s370_add_b
  00396	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
  0039e	eb 34		 jmp	 SHORT $LN26@s370_add_b
$LN25@s370_add_b:
  003a0	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  003aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ans$[rsp]
  003af	48 23 c8	 and	 rcx, rax
  003b2	48 8b c1	 mov	 rax, rcx
  003b5	48 85 c0	 test	 rax, rax
  003b8	74 0a		 je	 SHORT $LN23@s370_add_b
  003ba	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv229[rsp], 1
  003c2	eb 08		 jmp	 SHORT $LN24@s370_add_b
$LN23@s370_add_b:
  003c4	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv229[rsp], 2
$LN24@s370_add_b:
  003cc	8b 44 24 48	 mov	 eax, DWORD PTR tv229[rsp]
  003d0	89 44 24 4c	 mov	 DWORD PTR tv231[rsp], eax
$LN26@s370_add_b:
  003d4	8b 44 24 4c	 mov	 eax, DWORD PTR tv231[rsp]
  003d8	89 44 24 50	 mov	 DWORD PTR tv232[rsp], eax
$LN27@s370_add_b:
  003dc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e4	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv232[rsp]
  003e9	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  003ec	33 c0		 xor	 eax, eax
  003ee	85 c0		 test	 eax, eax
  003f0	0f 85 00 ff ff
	ff		 jne	 $LN7@s370_add_b

; 1305 : 
; 1306 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  003f6	8b 44 24 24	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003fa	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  003ff	85 c0		 test	 eax, eax
  00401	74 11		 je	 SHORT $LN16@s370_add_b
  00403	8b 54 24 24	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00407	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_add_b:

; 1307 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1308 : }

  00414	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00418	c3		 ret	 0
s370_add_bfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
ieee_trap_conds$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
tv203 = 48
tv233 = 52
tv238 = 56
tv240 = 60
tv241 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
ans$ = 144
op2$ = 160
op1$ = 176
__$ArrayPad$ = 192
inst$ = 240
regs$ = 248
s370_add_bfp_ext_reg PROC

; 1198 : {

$LN32:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1199 :     int         r1, r2;
; 1200 :     float128_t  op1, op2, ans;
; 1201 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 1202 : 
; 1203 :     RRE( inst, regs, r1, r2 );

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_b:
  0005f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007b	33 c0		 xor	 eax, eax
  0007d	83 f8 04	 cmp	 eax, 4
  00080	74 0f		 je	 SHORT $LN11@s370_add_b
  00082	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s370_add_b:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 c8		 jne	 SHORT $LN4@s370_add_b

; 1204 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1205 :     BFPINST_CHECK( regs );

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 3f		 je	 SHORT $LN13@s370_add_b
  000b8	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c6	d1 e8		 shr	 eax, 1
  000c8	83 e0 01	 and	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 55		 je	 SHORT $LN12@s370_add_b
  000cf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	b9 08 00 00 00	 mov	 ecx, 8
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ee	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f3	85 c0		 test	 eax, eax
  000f5	75 2d		 jne	 SHORT $LN12@s370_add_b
$LN13@s370_add_b:
  000f7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00109	ba 07 00 00 00	 mov	 edx, 7
  0010e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_add_b:

; 1206 :     BFPREGPAIR2_CHECK( r1, r2, regs );

  00124	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00128	83 e0 02	 and	 eax, 2
  0012b	85 c0		 test	 eax, eax
  0012d	75 0b		 jne	 SHORT $LN15@s370_add_b
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00133	83 e0 02	 and	 eax, 2
  00136	85 c0		 test	 eax, eax
  00138	74 1b		 je	 SHORT $LN14@s370_add_b
$LN15@s370_add_b:
  0013a	ba 06 00 00 00	 mov	 edx, 6
  0013f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@s370_add_b:
$LN7@s370_add_b:

; 1207 : 
; 1208 :     GET_FLOAT128_OPS( op1, r1, op2, r2, regs );

  00155	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00159	d1 e0		 shl	 eax, 1
  0015b	48 98		 cdqe
  0015d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  00178	e8 00 00 00 00	 call	 s370_get_float128
  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00181	d1 e0		 shl	 eax, 1
  00183	48 98		 cdqe
  00185	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  001a0	e8 00 00 00 00	 call	 s370_get_float128
  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 aa		 jne	 SHORT $LN7@s370_add_b

; 1209 : 
; 1210 :     softfloat_exceptionFlags = 0;

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001b0	8b c0		 mov	 eax, eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001c5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1211 :     SET_SF_RM_FROM_FPC;

  001c9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001d7	83 e0 07	 and	 eax, 7
  001da	8b c0		 mov	 eax, eax
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:softfloat_roundingMode
  001e8	8b d2		 mov	 edx, edx
  001ea	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  001f1	65 4c 8b 0c 25
	58 00 00 00	 mov	 r9, QWORD PTR gs:88
  001fa	4f 8b 04 c1	 mov	 r8, QWORD PTR [r9+r8*8]
  001fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00202	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al

; 1212 : 
; 1213 :     ans = f128_add( op1, op2 );

  00206	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  0020b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR op2$[rsp]
  00213	48 8b f8	 mov	 rdi, rax
  00216	48 8b f1	 mov	 rsi, rcx
  00219	b9 10 00 00 00	 mov	 ecx, 16
  0021e	f3 a4		 rep movsb
  00220	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  00225	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR op1$[rsp]
  0022d	48 8b f8	 mov	 rdi, rax
  00230	48 8b f1	 mov	 rsi, rcx
  00233	b9 10 00 00 00	 mov	 ecx, 16
  00238	f3 a4		 rep movsb
  0023a	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  0023f	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  00244	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  00249	e8 00 00 00 00	 call	 f128_add
  0024e	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00256	48 8b f9	 mov	 rdi, rcx
  00259	48 8b f0	 mov	 rsi, rax
  0025c	b9 10 00 00 00	 mov	 ecx, 16
  00261	f3 a4		 rep movsb

; 1214 : 
; 1215 :     if (softfloat_exceptionFlags)

  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	85 c0		 test	 eax, eax
  00283	0f 84 b5 00 00
	00		 je	 $LN16@s370_add_b

; 1216 :     {
; 1217 :         IEEE_EXCEPTION_TRAP_XI( regs );

  00289	33 c0		 xor	 eax, eax
  0028b	83 f8 01	 cmp	 eax, 1
  0028e	74 4b		 je	 SHORT $LN17@s370_add_b
  00290	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00295	8b c0		 mov	 eax, eax
  00297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0029d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ae	83 e0 10	 and	 eax, 16
  002b1	85 c0		 test	 eax, eax
  002b3	74 26		 je	 SHORT $LN17@s370_add_b
  002b5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002c3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002c8	85 c0		 test	 eax, eax
  002ca	74 0f		 je	 SHORT $LN17@s370_add_b
  002cc	b2 80		 mov	 dl, 128			; 00000080H
  002ce	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 ieee_trap
$LN17@s370_add_b:

; 1218 : 
; 1219 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  002db	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	e8 00 00 00 00	 call	 ieee_exception_test_oux
  002e8	89 44 24 20	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 1220 : 
; 1221 :         if (ieee_trap_conds & (FPC_MASK_IMO | FPC_MASK_IMU))

  002ec	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002f0	25 00 00 00 30	 and	 eax, 805306368		; 30000000H
  002f5	85 c0		 test	 eax, eax
  002f7	74 45		 je	 SHORT $LN18@s370_add_b

; 1222 :             ans = f128_scaledResult( ieee_trap_conds & FPC_MASK_IMO ?

  002f9	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  002fd	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00302	85 c0		 test	 eax, eax
  00304	74 0a		 je	 SHORT $LN21@s370_add_b
  00306	c7 44 24 30 00
	a0 ff ff	 mov	 DWORD PTR tv203[rsp], -24576 ; ffffffffffffa000H
  0030e	eb 08		 jmp	 SHORT $LN22@s370_add_b
$LN21@s370_add_b:
  00310	c7 44 24 30 00
	60 00 00	 mov	 DWORD PTR tv203[rsp], 24576 ; 00006000H
$LN22@s370_add_b:
  00318	8b 54 24 30	 mov	 edx, DWORD PTR tv203[rsp]
  0031c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00324	e8 00 00 00 00	 call	 f128_scaledResult
  00329	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00331	48 8b f9	 mov	 rdi, rcx
  00334	48 8b f0	 mov	 rsi, rax
  00337	b9 10 00 00 00	 mov	 ecx, 16
  0033c	f3 a4		 rep movsb
$LN18@s370_add_b:
$LN16@s370_add_b:
$LN10@s370_add_b:

; 1223 :                 SCALE_FACTOR_ARITH_OFLOW_EXTD :
; 1224 :                 SCALE_FACTOR_ARITH_UFLOW_EXTD );
; 1225 :     }
; 1226 : 
; 1227 :     PUT_FLOAT128_CC( ans, r1, regs );

  0033e	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00342	d1 e0		 shl	 eax, 1
  00344	48 98		 cdqe
  00346	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034e	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  00356	48 8b d0	 mov	 rdx, rax
  00359	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ans$[rsp]
  00361	e8 00 00 00 00	 call	 s370_put_float128
  00366	b8 08 00 00 00	 mov	 eax, 8
  0036b	48 6b c0 01	 imul	 rax, rax, 1
  0036f	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00379	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  00381	48 23 c1	 and	 rax, rcx
  00384	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0038e	48 3b c1	 cmp	 rax, rcx
  00391	75 44		 jne	 SHORT $LN24@s370_add_b
  00393	b8 08 00 00 00	 mov	 eax, 8
  00398	48 6b c0 01	 imul	 rax, rax, 1
  0039c	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  003a6	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  003ae	48 23 c1	 and	 rax, rcx
  003b1	48 85 c0	 test	 rax, rax
  003b4	75 14		 jne	 SHORT $LN23@s370_add_b
  003b6	b8 08 00 00 00	 mov	 eax, 8
  003bb	48 6b c0 00	 imul	 rax, rax, 0
  003bf	48 83 bc 04 90
	00 00 00 00	 cmp	 QWORD PTR ans$[rsp+rax], 0
  003c8	74 0d		 je	 SHORT $LN24@s370_add_b
$LN23@s370_add_b:
  003ca	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv241[rsp], 3
  003d2	e9 9c 00 00 00	 jmp	 $LN31@s370_add_b
$LN24@s370_add_b:
  003d7	b8 08 00 00 00	 mov	 eax, 8
  003dc	48 6b c0 01	 imul	 rax, rax, 1
  003e0	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  003ea	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  003f2	48 23 c1	 and	 rax, rcx
  003f5	b9 08 00 00 00	 mov	 ecx, 8
  003fa	48 6b c9 00	 imul	 rcx, rcx, 0
  003fe	48 0b 84 0c 90
	00 00 00	 or	 rax, QWORD PTR ans$[rsp+rcx]
  00406	48 85 c0	 test	 rax, rax
  00409	75 0a		 jne	 SHORT $LN25@s370_add_b
  0040b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  00413	eb 08		 jmp	 SHORT $LN26@s370_add_b
$LN25@s370_add_b:
  00415	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
$LN26@s370_add_b:
  0041d	83 7c 24 34 00	 cmp	 DWORD PTR tv233[rsp], 0
  00422	74 0a		 je	 SHORT $LN29@s370_add_b
  00424	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv240[rsp], 0
  0042c	eb 3d		 jmp	 SHORT $LN30@s370_add_b
$LN29@s370_add_b:
  0042e	b8 08 00 00 00	 mov	 eax, 8
  00433	48 6b c0 01	 imul	 rax, rax, 1
  00437	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00441	48 8b 84 04 90
	00 00 00	 mov	 rax, QWORD PTR ans$[rsp+rax]
  00449	48 23 c1	 and	 rax, rcx
  0044c	48 85 c0	 test	 rax, rax
  0044f	74 0a		 je	 SHORT $LN27@s370_add_b
  00451	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv238[rsp], 1
  00459	eb 08		 jmp	 SHORT $LN28@s370_add_b
$LN27@s370_add_b:
  0045b	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv238[rsp], 2
$LN28@s370_add_b:
  00463	8b 44 24 38	 mov	 eax, DWORD PTR tv238[rsp]
  00467	89 44 24 3c	 mov	 DWORD PTR tv240[rsp], eax
$LN30@s370_add_b:
  0046b	8b 44 24 3c	 mov	 eax, DWORD PTR tv240[rsp]
  0046f	89 44 24 40	 mov	 DWORD PTR tv241[rsp], eax
$LN31@s370_add_b:
  00473	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047b	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv241[rsp]
  00480	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00483	33 c0		 xor	 eax, eax
  00485	85 c0		 test	 eax, eax
  00487	0f 85 b1 fe ff
	ff		 jne	 $LN10@s370_add_b

; 1228 : 
; 1229 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds,

  0048d	8b 44 24 20	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00491	25 00 00 00 38	 and	 eax, 939524096		; 38000000H
  00496	85 c0		 test	 eax, eax
  00498	74 11		 je	 SHORT $LN19@s370_add_b
  0049a	8b 54 24 20	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0049e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a6	e8 00 00 00 00	 call	 ieee_cond_trap
$LN19@s370_add_b:

; 1230 :         FPC_MASK_IMO | FPC_MASK_IMU | FPC_MASK_IMX );
; 1231 : }

  004ab	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004b3	48 33 cc	 xor	 rcx, rsp
  004b6	e8 00 00 00 00	 call	 __security_check_cookie
  004bb	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  004c2	5f		 pop	 rdi
  004c3	5e		 pop	 rsi
  004c4	c3		 ret	 0
s370_add_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
op2$ = 36
temp$1 = 40
ieee_trap_conds$ = 44
tv188 = 48
tv194 = 52
tv253 = 56
tv256 = 60
tv258 = 64
tv259 = 68
r2$ = 72
r1$ = 76
op1$ = 80
inst$ = 112
regs$ = 120
s370_convert_bfp_short_to_u64_reg PROC

; 2875 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2876 :     int        r1, r2;
; 2877 :     BYTE       m3, m4, newcc;
; 2878 :     U64        op1;
; 2879 :     float32_t  op2;
; 2880 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2881 : 
; 2882 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2883 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2884 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2885 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2886 : 
; 2887 :     GET_FLOAT32_OP( op2, r2, regs );

  00119	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  0011d	d1 e0		 shl	 eax, 1
  0011f	48 98		 cdqe
  00121	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012e	48 8b d0	 mov	 rdx, rax
  00131	48 8d 4c 24 24	 lea	 rcx, QWORD PTR op2$[rsp]
  00136	e8 00 00 00 00	 call	 s370_get_float32

; 2888 :     softfloat_exceptionFlags = 0;

  0013b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00140	8b c0		 mov	 eax, eax
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00148	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00151	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00155	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2889 : 
; 2890 :     if (FLOAT32_ISNAN( op2 ))

  00159	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  0015d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00162	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00167	75 5c		 jne	 SHORT $LN8@s370_conve
  00169	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  0016d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00172	85 c0		 test	 eax, eax
  00174	74 4f		 je	 SHORT $LN8@s370_conve

; 2891 :     {
; 2892 :         op1 = 0;

  00176	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2893 :         softfloat_raiseFlags( softfloat_flag_invalid );

  0017f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00184	8b c0		 mov	 eax, eax
  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0018c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00195	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00199	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0019d	83 c8 10	 or	 eax, 16
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001af	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  001b5	45 8b c0	 mov	 r8d, r8d
  001b8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bc	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2894 :     }

  001c0	e9 b0 00 00 00	 jmp	 $LN9@s370_conve
$LN8@s370_conve:

; 2895 :     else
; 2896 :     {
; 2897 :         SET_SF_RM_FROM_MASK( m3 );

  001c5	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001ca	85 c0		 test	 eax, eax
  001cc	74 16		 je	 SHORT $LN16@s370_conve
  001ce	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001de	89 44 24 30	 mov	 DWORD PTR tv188[rsp], eax
  001e2	eb 1f		 jmp	 SHORT $LN17@s370_conve
$LN16@s370_conve:
  001e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ef	83 e0 07	 and	 eax, 7
  001f2	8b c0		 mov	 eax, eax
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ff	89 44 24 30	 mov	 DWORD PTR tv188[rsp], eax
$LN17@s370_conve:
  00203	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00208	8b c0		 mov	 eax, eax
  0020a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00210	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00219	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021d	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv188[rsp]
  00222	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2898 :         op1 = f32_to_ui64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00225	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  0022a	83 e0 04	 and	 eax, 4
  0022d	85 c0		 test	 eax, eax
  0022f	75 0a		 jne	 SHORT $LN18@s370_conve
  00231	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  00239	eb 08		 jmp	 SHORT $LN19@s370_conve
$LN18@s370_conve:
  0023b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN19@s370_conve:
  00243	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00248	8b c0		 mov	 eax, eax
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00250	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00259	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025d	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv194[rsp]
  00263	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00267	8b 4c 24 24	 mov	 ecx, DWORD PTR op2$[rsp]
  0026b	e8 00 00 00 00	 call	 f32_to_ui64
  00270	48 89 44 24 50	 mov	 QWORD PTR op1$[rsp], rax
$LN9@s370_conve:

; 2899 :     }
; 2900 : 
; 2901 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00275	33 c0		 xor	 eax, eax
  00277	83 f8 01	 cmp	 eax, 1
  0027a	74 45		 je	 SHORT $LN10@s370_conve
  0027c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00281	8b c0		 mov	 eax, eax
  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00289	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00292	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00296	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029a	83 e0 10	 and	 eax, 16
  0029d	85 c0		 test	 eax, eax
  0029f	74 20		 je	 SHORT $LN10@s370_conve
  002a1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002a6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ac	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002b1	85 c0		 test	 eax, eax
  002b3	74 0c		 je	 SHORT $LN10@s370_conve
  002b5	b2 80		 mov	 dl, 128			; 00000080H
  002b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_conve:

; 2902 : 
; 2903 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  002c1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c6	8b c0		 mov	 eax, eax
  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ce	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002db	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002df	83 e0 10	 and	 eax, 16
  002e2	85 c0		 test	 eax, eax
  002e4	74 57		 je	 SHORT $LN11@s370_conve

; 2904 :     {
; 2905 :         newcc = 3;

  002e6	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2906 : 
; 2907 :         if (!SUPPRESS_INEXACT( m4 ))

  002eb	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002f0	83 e0 04	 and	 eax, 4
  002f3	85 c0		 test	 eax, eax
  002f5	75 41		 jne	 SHORT $LN13@s370_conve

; 2908 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  002f7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002fc	8b c0		 mov	 eax, eax
  002fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00304	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0030d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00311	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00315	83 c8 01	 or	 eax, 1
  00318	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0031e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00327	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0032d	45 8b c0	 mov	 r8d, r8d
  00330	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00334	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN13@s370_conve:

; 2909 :     }

  00338	e9 8e 00 00 00	 jmp	 $LN12@s370_conve
$LN11@s370_conve:

; 2910 :     else
; 2911 :         newcc = FLOAT32_CC( op2 );

  0033d	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  00341	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00346	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  0034b	75 17		 jne	 SHORT $LN20@s370_conve
  0034d	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  00351	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00356	85 c0		 test	 eax, eax
  00358	74 0a		 je	 SHORT $LN20@s370_conve
  0035a	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR tv259[rsp], 3
  00362	eb 5e		 jmp	 SHORT $LN27@s370_conve
$LN20@s370_conve:
  00364	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  00368	0f ba f0 1f	 btr	 eax, 31
  0036c	85 c0		 test	 eax, eax
  0036e	75 0a		 jne	 SHORT $LN21@s370_conve
  00370	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv253[rsp], 1
  00378	eb 08		 jmp	 SHORT $LN22@s370_conve
$LN21@s370_conve:
  0037a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN22@s370_conve:
  00382	83 7c 24 38 00	 cmp	 DWORD PTR tv253[rsp], 0
  00387	74 0a		 je	 SHORT $LN25@s370_conve
  00389	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv258[rsp], 0
  00391	eb 27		 jmp	 SHORT $LN26@s370_conve
$LN25@s370_conve:
  00393	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  00397	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0039c	85 c0		 test	 eax, eax
  0039e	74 0a		 je	 SHORT $LN23@s370_conve
  003a0	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv256[rsp], 1
  003a8	eb 08		 jmp	 SHORT $LN24@s370_conve
$LN23@s370_conve:
  003aa	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tv256[rsp], 2
$LN24@s370_conve:
  003b2	8b 44 24 3c	 mov	 eax, DWORD PTR tv256[rsp]
  003b6	89 44 24 40	 mov	 DWORD PTR tv258[rsp], eax
$LN26@s370_conve:
  003ba	8b 44 24 40	 mov	 eax, DWORD PTR tv258[rsp]
  003be	89 44 24 44	 mov	 DWORD PTR tv259[rsp], eax
$LN27@s370_conve:
  003c2	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv259[rsp]
  003c7	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN12@s370_conve:

; 2912 : 
; 2913 :     regs->GR_G( r1 ) = op1;

  003cb	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r1$[rsp]
  003d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003d5	48 8b 54 24 50	 mov	 rdx, QWORD PTR op1$[rsp]
  003da	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2914 :     regs->psw.cc = newcc;

  003e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003e7	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  003ec	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2915 : 
; 2916 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  003ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f4	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003f9	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2917 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  003fd	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00401	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00406	85 c0		 test	 eax, eax
  00408	74 0e		 je	 SHORT $LN14@s370_conve
  0040a	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0040e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00413	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_conve:

; 2918 : }

  00418	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0041c	c3		 ret	 0
s370_convert_bfp_short_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
temp$1 = 36
ieee_trap_conds$ = 40
op2$ = 48
tv188 = 56
tv194 = 60
tv253 = 64
tv256 = 68
tv258 = 72
tv259 = 76
r2$ = 80
r1$ = 84
op1$ = 88
inst$ = 112
regs$ = 120
s370_convert_bfp_long_to_u64_reg PROC

; 2825 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2826 :     int        r1, r2;
; 2827 :     BYTE       m3, m4, newcc;
; 2828 :     U64        op1;
; 2829 :     float64_t  op2;
; 2830 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2831 : 
; 2832 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 50	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 54	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2833 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2834 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2835 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2836 : 
; 2837 :     GET_FLOAT64_OP( op2, r2, regs );

  00119	8b 44 24 50	 mov	 eax, DWORD PTR r2$[rsp]
  0011d	d1 e0		 shl	 eax, 1
  0011f	48 98		 cdqe
  00121	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012e	48 8b d0	 mov	 rdx, rax
  00131	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00136	e8 00 00 00 00	 call	 s370_get_float64

; 2838 :     softfloat_exceptionFlags = 0;

  0013b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00140	8b c0		 mov	 eax, eax
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00148	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00151	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00155	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2839 : 
; 2840 :     if (FLOAT64_ISNAN( op2 ))

  00159	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00163	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00168	48 23 c8	 and	 rcx, rax
  0016b	48 8b c1	 mov	 rax, rcx
  0016e	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00178	48 3b c1	 cmp	 rax, rcx
  0017b	75 69		 jne	 SHORT $LN8@s370_conve
  0017d	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00187	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0018c	48 23 c8	 and	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	48 85 c0	 test	 rax, rax
  00195	74 4f		 je	 SHORT $LN8@s370_conve

; 2841 :     {
; 2842 :         op1 = 0;

  00197	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2843 :         softfloat_raiseFlags( softfloat_flag_invalid );

  001a0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a5	8b c0		 mov	 eax, eax
  001a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ad	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001be	83 c8 10	 or	 eax, 16
  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001d0	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  001d6	45 8b c0	 mov	 r8d, r8d
  001d9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001dd	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2844 :     }

  001e1	e9 b1 00 00 00	 jmp	 $LN9@s370_conve
$LN8@s370_conve:

; 2845 :     else
; 2846 :     {
; 2847 :         SET_SF_RM_FROM_MASK( m3 );

  001e6	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001eb	85 c0		 test	 eax, eax
  001ed	74 16		 je	 SHORT $LN16@s370_conve
  001ef	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ff	89 44 24 38	 mov	 DWORD PTR tv188[rsp], eax
  00203	eb 1f		 jmp	 SHORT $LN17@s370_conve
$LN16@s370_conve:
  00205	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00210	83 e0 07	 and	 eax, 7
  00213	8b c0		 mov	 eax, eax
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0021c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00220	89 44 24 38	 mov	 DWORD PTR tv188[rsp], eax
$LN17@s370_conve:
  00224	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00229	8b c0		 mov	 eax, eax
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00231	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023e	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv188[rsp]
  00243	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2848 :         op1 = f64_to_ui64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00246	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  0024b	83 e0 04	 and	 eax, 4
  0024e	85 c0		 test	 eax, eax
  00250	75 0a		 jne	 SHORT $LN18@s370_conve
  00252	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  0025a	eb 08		 jmp	 SHORT $LN19@s370_conve
$LN18@s370_conve:
  0025c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN19@s370_conve:
  00264	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00269	8b c0		 mov	 eax, eax
  0026b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00271	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0027a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027e	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv194[rsp]
  00284	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00288	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0028d	e8 00 00 00 00	 call	 f64_to_ui64
  00292	48 89 44 24 58	 mov	 QWORD PTR op1$[rsp], rax
$LN9@s370_conve:

; 2849 :     }
; 2850 : 
; 2851 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00297	33 c0		 xor	 eax, eax
  00299	83 f8 01	 cmp	 eax, 1
  0029c	74 45		 je	 SHORT $LN10@s370_conve
  0029e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a3	8b c0		 mov	 eax, eax
  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ab	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002bc	83 e0 10	 and	 eax, 16
  002bf	85 c0		 test	 eax, eax
  002c1	74 20		 je	 SHORT $LN10@s370_conve
  002c3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002c8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002ce	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002d3	85 c0		 test	 eax, eax
  002d5	74 0c		 je	 SHORT $LN10@s370_conve
  002d7	b2 80		 mov	 dl, 128			; 00000080H
  002d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002de	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_conve:

; 2852 : 
; 2853 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  002e3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e8	8b c0		 mov	 eax, eax
  002ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f0	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f9	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00301	83 e0 10	 and	 eax, 16
  00304	85 c0		 test	 eax, eax
  00306	74 57		 je	 SHORT $LN11@s370_conve

; 2854 :     {
; 2855 :         newcc = 3;

  00308	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2856 : 
; 2857 :         if (!SUPPRESS_INEXACT( m4 ))

  0030d	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00312	83 e0 04	 and	 eax, 4
  00315	85 c0		 test	 eax, eax
  00317	75 41		 jne	 SHORT $LN13@s370_conve

; 2858 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00319	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0031e	8b c0		 mov	 eax, eax
  00320	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00326	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0032f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00333	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00337	83 c8 01	 or	 eax, 1
  0033a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00340	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00349	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0034f	45 8b c0	 mov	 r8d, r8d
  00352	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00356	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN13@s370_conve:

; 2859 :     }

  0035a	e9 ca 00 00 00	 jmp	 $LN12@s370_conve
$LN11@s370_conve:

; 2860 :     else
; 2861 :         newcc = FLOAT64_CC( op2 );

  0035f	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00369	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0036e	48 23 c8	 and	 rcx, rax
  00371	48 8b c1	 mov	 rax, rcx
  00374	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0037e	48 3b c1	 cmp	 rax, rcx
  00381	75 24		 jne	 SHORT $LN20@s370_conve
  00383	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0038d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00392	48 23 c8	 and	 rcx, rax
  00395	48 8b c1	 mov	 rax, rcx
  00398	48 85 c0	 test	 rax, rax
  0039b	74 0a		 je	 SHORT $LN20@s370_conve
  0039d	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv259[rsp], 3
  003a5	eb 79		 jmp	 SHORT $LN27@s370_conve
$LN20@s370_conve:
  003a7	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  003b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  003b6	48 23 c8	 and	 rcx, rax
  003b9	48 8b c1	 mov	 rax, rcx
  003bc	48 85 c0	 test	 rax, rax
  003bf	75 0a		 jne	 SHORT $LN21@s370_conve
  003c1	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv253[rsp], 1
  003c9	eb 08		 jmp	 SHORT $LN22@s370_conve
$LN21@s370_conve:
  003cb	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN22@s370_conve:
  003d3	83 7c 24 40 00	 cmp	 DWORD PTR tv253[rsp], 0
  003d8	74 0a		 je	 SHORT $LN25@s370_conve
  003da	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv258[rsp], 0
  003e2	eb 34		 jmp	 SHORT $LN26@s370_conve
$LN25@s370_conve:
  003e4	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  003ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  003f3	48 23 c8	 and	 rcx, rax
  003f6	48 8b c1	 mov	 rax, rcx
  003f9	48 85 c0	 test	 rax, rax
  003fc	74 0a		 je	 SHORT $LN23@s370_conve
  003fe	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv256[rsp], 1
  00406	eb 08		 jmp	 SHORT $LN24@s370_conve
$LN23@s370_conve:
  00408	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv256[rsp], 2
$LN24@s370_conve:
  00410	8b 44 24 44	 mov	 eax, DWORD PTR tv256[rsp]
  00414	89 44 24 48	 mov	 DWORD PTR tv258[rsp], eax
$LN26@s370_conve:
  00418	8b 44 24 48	 mov	 eax, DWORD PTR tv258[rsp]
  0041c	89 44 24 4c	 mov	 DWORD PTR tv259[rsp], eax
$LN27@s370_conve:
  00420	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv259[rsp]
  00425	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN12@s370_conve:

; 2862 : 
; 2863 :     regs->GR_G( r1 ) = op1;

  00429	48 63 44 24 54	 movsxd	 rax, DWORD PTR r1$[rsp]
  0042e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00433	48 8b 54 24 58	 mov	 rdx, QWORD PTR op1$[rsp]
  00438	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2864 :     regs->psw.cc = newcc;

  00440	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00445	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0044a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2865 : 
; 2866 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  0044d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00452	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00457	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2867 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0045b	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0045f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00464	85 c0		 test	 eax, eax
  00466	74 0e		 je	 SHORT $LN14@s370_conve
  00468	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0046c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00471	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_conve:

; 2868 : }

  00476	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0047a	c3		 ret	 0
s370_convert_bfp_long_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
temp$1 = 36
ieee_trap_conds$ = 40
r2$ = 44
tv200 = 48
tv206 = 52
tv277 = 56
tv282 = 60
tv284 = 64
tv285 = 68
r1$ = 72
op1$ = 80
tv305 = 88
$T2 = 96
op2$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
s370_convert_bfp_ext_to_u64_reg PROC

; 2774 : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2775 :     int         r1, r2;
; 2776 :     BYTE        m3, m4, newcc;
; 2777 :     U64         op1;
; 2778 :     float128_t  op2;
; 2779 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2780 : 
; 2781 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN5@s370_conve
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s370_conve

; 2782 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2783 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN7@s370_conve
  000d3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN6@s370_conve
  000ea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00112	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2784 :     BFPREGPAIR_CHECK( r2, regs );

  0013f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00143	83 e0 02	 and	 eax, 2
  00146	85 c0		 test	 eax, eax
  00148	74 1b		 je	 SHORT $LN8@s370_conve
  0014a	ba 06 00 00 00	 mov	 edx, 6
  0014f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2785 :     BFPRM_CHECK( m3, regs );

  00165	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0016a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00172	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2786 : 
; 2787 :     GET_FLOAT128_OP( op2, r2, regs );

  00177	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0017b	d1 e0		 shl	 eax, 1
  0017d	48 98		 cdqe
  0017f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0018f	48 8b d0	 mov	 rdx, rax
  00192	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  00197	e8 00 00 00 00	 call	 s370_get_float128

; 2788 :     softfloat_exceptionFlags = 0;

  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a1	8b c0		 mov	 eax, eax
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2789 : 
; 2790 :     if (FLOAT128_ISNAN( op2 ))

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001cd	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  001d2	48 23 c1	 and	 rax, rcx
  001d5	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001df	48 3b c1	 cmp	 rax, rcx
  001e2	0f 85 80 00 00
	00		 jne	 $LN9@s370_conve
  001e8	b8 08 00 00 00	 mov	 eax, 8
  001ed	48 6b c0 01	 imul	 rax, rax, 1
  001f1	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001fb	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00200	48 23 c1	 and	 rax, rcx
  00203	48 85 c0	 test	 rax, rax
  00206	75 11		 jne	 SHORT $LN11@s370_conve
  00208	b8 08 00 00 00	 mov	 eax, 8
  0020d	48 6b c0 00	 imul	 rax, rax, 0
  00211	48 83 7c 04 70
	00		 cmp	 QWORD PTR op2$[rsp+rax], 0
  00217	74 4f		 je	 SHORT $LN9@s370_conve
$LN11@s370_conve:

; 2791 :     {
; 2792 :         op1 = 0;

  00219	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR op1$[rsp], 0

; 2793 :         softfloat_raiseFlags( softfloat_flag_invalid );

  00222	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00227	8b c0		 mov	 eax, eax
  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00238	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00240	83 c8 10	 or	 eax, 16
  00243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00249	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00252	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00258	45 8b c0	 mov	 r8d, r8d
  0025b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025f	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2794 :     }

  00263	e9 d5 00 00 00	 jmp	 $LN10@s370_conve
$LN9@s370_conve:

; 2795 :     else
; 2796 :     {
; 2797 :         SET_SF_RM_FROM_MASK( m3 );

  00268	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0026d	85 c0		 test	 eax, eax
  0026f	74 16		 je	 SHORT $LN18@s370_conve
  00271	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0027d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00281	89 44 24 30	 mov	 DWORD PTR tv200[rsp], eax
  00285	eb 22		 jmp	 SHORT $LN19@s370_conve
$LN18@s370_conve:
  00287	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00295	83 e0 07	 and	 eax, 7
  00298	8b c0		 mov	 eax, eax
  0029a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  002a1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a5	89 44 24 30	 mov	 DWORD PTR tv200[rsp], eax
$LN19@s370_conve:
  002a9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002ae	8b c0		 mov	 eax, eax
  002b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002bf	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002c3	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv200[rsp]
  002c8	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2798 :         op1 = f128_to_ui64( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002cb	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002d0	83 e0 04	 and	 eax, 4
  002d3	85 c0		 test	 eax, eax
  002d5	75 0a		 jne	 SHORT $LN20@s370_conve
  002d7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv206[rsp], 1
  002df	eb 08		 jmp	 SHORT $LN21@s370_conve
$LN20@s370_conve:
  002e1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv206[rsp], 0
$LN21@s370_conve:
  002e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002ee	8b c0		 mov	 eax, eax
  002f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ff	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00303	48 89 4c 24 58	 mov	 QWORD PTR tv305[rsp], rcx
  00308	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T2[rsp]
  0030d	4c 8d 44 24 70	 lea	 r8, QWORD PTR op2$[rsp]
  00312	48 8b fa	 mov	 rdi, rdx
  00315	49 8b f0	 mov	 rsi, r8
  00318	b9 10 00 00 00	 mov	 ecx, 16
  0031d	f3 a4		 rep movsb
  0031f	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv206[rsp]
  00325	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv305[rsp]
  0032a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0032e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  00333	e8 00 00 00 00	 call	 f128_to_ui64
  00338	48 89 44 24 50	 mov	 QWORD PTR op1$[rsp], rax
$LN10@s370_conve:

; 2799 :     }
; 2800 : 
; 2801 :     IEEE_EXCEPTION_TRAP_XI( regs );

  0033d	33 c0		 xor	 eax, eax
  0033f	83 f8 01	 cmp	 eax, 1
  00342	74 4b		 je	 SHORT $LN12@s370_conve
  00344	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00349	8b c0		 mov	 eax, eax
  0034b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00351	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0035a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0035e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00362	83 e0 10	 and	 eax, 16
  00365	85 c0		 test	 eax, eax
  00367	74 26		 je	 SHORT $LN12@s370_conve
  00369	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00371	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00377	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0037c	85 c0		 test	 eax, eax
  0037e	74 0f		 je	 SHORT $LN12@s370_conve
  00380	b2 80		 mov	 dl, 128			; 00000080H
  00382	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038a	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_conve:

; 2802 : 
; 2803 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  0038f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00394	8b c0		 mov	 eax, eax
  00396	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0039c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003a5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ad	83 e0 10	 and	 eax, 16
  003b0	85 c0		 test	 eax, eax
  003b2	74 54		 je	 SHORT $LN13@s370_conve

; 2804 :     {
; 2805 :         newcc = 3;

  003b4	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2806 : 
; 2807 :         if (!SUPPRESS_INEXACT( m4 ))

  003b9	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  003be	83 e0 04	 and	 eax, 4
  003c1	85 c0		 test	 eax, eax
  003c3	75 3e		 jne	 SHORT $LN15@s370_conve

; 2808 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  003c5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003ca	8b c0		 mov	 eax, eax
  003cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003d2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003db	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e3	83 c8 01	 or	 eax, 1
  003e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003ec	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003f5	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  003fa	8b ff		 mov	 edi, edi
  003fc	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00400	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN15@s370_conve:

; 2809 :     }

  00403	e9 04 01 00 00	 jmp	 $LN14@s370_conve
$LN13@s370_conve:

; 2810 :     else
; 2811 :         newcc = FLOAT128_CC( op2 );

  00408	b8 08 00 00 00	 mov	 eax, 8
  0040d	48 6b c0 01	 imul	 rax, rax, 1
  00411	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0041b	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00420	48 23 c1	 and	 rax, rcx
  00423	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  0042d	48 3b c1	 cmp	 rax, rcx
  00430	75 3e		 jne	 SHORT $LN23@s370_conve
  00432	b8 08 00 00 00	 mov	 eax, 8
  00437	48 6b c0 01	 imul	 rax, rax, 1
  0043b	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  00445	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0044a	48 23 c1	 and	 rax, rcx
  0044d	48 85 c0	 test	 rax, rax
  00450	75 11		 jne	 SHORT $LN22@s370_conve
  00452	b8 08 00 00 00	 mov	 eax, 8
  00457	48 6b c0 00	 imul	 rax, rax, 0
  0045b	48 83 7c 04 70
	00		 cmp	 QWORD PTR op2$[rsp+rax], 0
  00461	74 0d		 je	 SHORT $LN23@s370_conve
$LN22@s370_conve:
  00463	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR tv285[rsp], 3
  0046b	e9 93 00 00 00	 jmp	 $LN30@s370_conve
$LN23@s370_conve:
  00470	b8 08 00 00 00	 mov	 eax, 8
  00475	48 6b c0 01	 imul	 rax, rax, 1
  00479	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00483	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00488	48 23 c1	 and	 rax, rcx
  0048b	b9 08 00 00 00	 mov	 ecx, 8
  00490	48 6b c9 00	 imul	 rcx, rcx, 0
  00494	48 0b 44 0c 70	 or	 rax, QWORD PTR op2$[rsp+rcx]
  00499	48 85 c0	 test	 rax, rax
  0049c	75 0a		 jne	 SHORT $LN24@s370_conve
  0049e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv277[rsp], 1
  004a6	eb 08		 jmp	 SHORT $LN25@s370_conve
$LN24@s370_conve:
  004a8	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv277[rsp], 0
$LN25@s370_conve:
  004b0	83 7c 24 38 00	 cmp	 DWORD PTR tv277[rsp], 0
  004b5	74 0a		 je	 SHORT $LN28@s370_conve
  004b7	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv284[rsp], 0
  004bf	eb 3a		 jmp	 SHORT $LN29@s370_conve
$LN28@s370_conve:
  004c1	b8 08 00 00 00	 mov	 eax, 8
  004c6	48 6b c0 01	 imul	 rax, rax, 1
  004ca	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  004d4	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  004d9	48 23 c1	 and	 rax, rcx
  004dc	48 85 c0	 test	 rax, rax
  004df	74 0a		 je	 SHORT $LN26@s370_conve
  004e1	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv282[rsp], 1
  004e9	eb 08		 jmp	 SHORT $LN27@s370_conve
$LN26@s370_conve:
  004eb	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tv282[rsp], 2
$LN27@s370_conve:
  004f3	8b 44 24 3c	 mov	 eax, DWORD PTR tv282[rsp]
  004f7	89 44 24 40	 mov	 DWORD PTR tv284[rsp], eax
$LN29@s370_conve:
  004fb	8b 44 24 40	 mov	 eax, DWORD PTR tv284[rsp]
  004ff	89 44 24 44	 mov	 DWORD PTR tv285[rsp], eax
$LN30@s370_conve:
  00503	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv285[rsp]
  00508	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN14@s370_conve:

; 2812 : 
; 2813 :     regs->GR_G( r1 ) = op1;

  0050c	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00511	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00519	48 8b 54 24 50	 mov	 rdx, QWORD PTR op1$[rsp]
  0051e	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 2814 :     regs->psw.cc = newcc;

  00526	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052e	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00533	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2815 : 
; 2816 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00536	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0053e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00543	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2817 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00547	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0054b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00550	85 c0		 test	 eax, eax
  00552	74 11		 je	 SHORT $LN16@s370_conve
  00554	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00558	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00560	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_conve:

; 2818 : }

  00565	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0056d	48 33 cc	 xor	 rcx, rsp
  00570	e8 00 00 00 00	 call	 __security_check_cookie
  00575	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0057c	5f		 pop	 rdi
  0057d	5e		 pop	 rsi
  0057e	c3		 ret	 0
s370_convert_bfp_ext_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
op2$ = 36
temp$1 = 40
ieee_trap_conds$ = 44
tv188 = 48
tv194 = 52
tv253 = 56
tv256 = 60
tv258 = 64
tv259 = 68
op1$ = 72
r2$ = 76
r1$ = 80
inst$ = 112
regs$ = 120
s370_convert_bfp_short_to_u32_reg PROC

; 2725 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2726 :     int        r1, r2;
; 2727 :     BYTE       m3, m4, newcc;
; 2728 :     U32        op1;
; 2729 :     float32_t  op2;
; 2730 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2731 : 
; 2732 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 50	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2733 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2734 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2735 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2736 : 
; 2737 :     GET_FLOAT32_OP( op2, r2, regs );

  00119	8b 44 24 4c	 mov	 eax, DWORD PTR r2$[rsp]
  0011d	d1 e0		 shl	 eax, 1
  0011f	48 98		 cdqe
  00121	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012e	48 8b d0	 mov	 rdx, rax
  00131	48 8d 4c 24 24	 lea	 rcx, QWORD PTR op2$[rsp]
  00136	e8 00 00 00 00	 call	 s370_get_float32

; 2738 :     softfloat_exceptionFlags = 0;

  0013b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00140	8b c0		 mov	 eax, eax
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00148	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00151	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00155	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2739 : 
; 2740 :     if (FLOAT32_ISNAN( op2 ))

  00159	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  0015d	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00162	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00167	75 5b		 jne	 SHORT $LN8@s370_conve
  00169	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  0016d	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00172	85 c0		 test	 eax, eax
  00174	74 4e		 je	 SHORT $LN8@s370_conve

; 2741 :     {
; 2742 :         op1 = 0;

  00176	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2743 :         softfloat_raiseFlags( softfloat_flag_invalid );

  0017e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00183	8b c0		 mov	 eax, eax
  00185	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0018b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00194	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00198	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0019c	83 c8 10	 or	 eax, 16
  0019f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ae	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  001b4	45 8b c0	 mov	 r8d, r8d
  001b7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001bb	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2744 :     }

  001bf	e9 af 00 00 00	 jmp	 $LN9@s370_conve
$LN8@s370_conve:

; 2745 :     else
; 2746 :     {
; 2747 :         SET_SF_RM_FROM_MASK( m3 );

  001c4	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001c9	85 c0		 test	 eax, eax
  001cb	74 16		 je	 SHORT $LN16@s370_conve
  001cd	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001dd	89 44 24 30	 mov	 DWORD PTR tv188[rsp], eax
  001e1	eb 1f		 jmp	 SHORT $LN17@s370_conve
$LN16@s370_conve:
  001e3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ee	83 e0 07	 and	 eax, 7
  001f1	8b c0		 mov	 eax, eax
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fe	89 44 24 30	 mov	 DWORD PTR tv188[rsp], eax
$LN17@s370_conve:
  00202	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00207	8b c0		 mov	 eax, eax
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0020f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00218	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0021c	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv188[rsp]
  00221	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2748 :         op1 = f32_to_ui32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00224	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00229	83 e0 04	 and	 eax, 4
  0022c	85 c0		 test	 eax, eax
  0022e	75 0a		 jne	 SHORT $LN18@s370_conve
  00230	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  00238	eb 08		 jmp	 SHORT $LN19@s370_conve
$LN18@s370_conve:
  0023a	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN19@s370_conve:
  00242	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00247	8b c0		 mov	 eax, eax
  00249	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0024f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00258	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025c	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv194[rsp]
  00262	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00266	8b 4c 24 24	 mov	 ecx, DWORD PTR op2$[rsp]
  0026a	e8 00 00 00 00	 call	 f32_to_ui32
  0026f	89 44 24 48	 mov	 DWORD PTR op1$[rsp], eax
$LN9@s370_conve:

; 2749 :     }
; 2750 : 
; 2751 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00273	33 c0		 xor	 eax, eax
  00275	83 f8 01	 cmp	 eax, 1
  00278	74 45		 je	 SHORT $LN10@s370_conve
  0027a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0027f	8b c0		 mov	 eax, eax
  00281	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00287	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00290	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00294	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00298	83 e0 10	 and	 eax, 16
  0029b	85 c0		 test	 eax, eax
  0029d	74 20		 je	 SHORT $LN10@s370_conve
  0029f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002a4	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002aa	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002af	85 c0		 test	 eax, eax
  002b1	74 0c		 je	 SHORT $LN10@s370_conve
  002b3	b2 80		 mov	 dl, 128			; 00000080H
  002b5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002ba	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_conve:

; 2752 : 
; 2753 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  002bf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002c4	8b c0		 mov	 eax, eax
  002c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002cc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002d5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002dd	83 e0 10	 and	 eax, 16
  002e0	85 c0		 test	 eax, eax
  002e2	74 57		 je	 SHORT $LN11@s370_conve

; 2754 :     {
; 2755 :         newcc = 3;

  002e4	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2756 : 
; 2757 :         if (!SUPPRESS_INEXACT( m4 ))

  002e9	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002ee	83 e0 04	 and	 eax, 4
  002f1	85 c0		 test	 eax, eax
  002f3	75 41		 jne	 SHORT $LN13@s370_conve

; 2758 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  002f5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002fa	8b c0		 mov	 eax, eax
  002fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00302	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0030b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0030f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00313	83 c8 01	 or	 eax, 1
  00316	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0031c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00325	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0032b	45 8b c0	 mov	 r8d, r8d
  0032e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00332	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN13@s370_conve:

; 2759 :     }

  00336	e9 8e 00 00 00	 jmp	 $LN12@s370_conve
$LN11@s370_conve:

; 2760 :     else
; 2761 :         newcc = FLOAT32_CC( op2 );

  0033b	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  0033f	25 00 00 80 7f	 and	 eax, 2139095040		; 7f800000H
  00344	3d 00 00 80 7f	 cmp	 eax, 2139095040		; 7f800000H
  00349	75 17		 jne	 SHORT $LN20@s370_conve
  0034b	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  0034f	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00354	85 c0		 test	 eax, eax
  00356	74 0a		 je	 SHORT $LN20@s370_conve
  00358	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR tv259[rsp], 3
  00360	eb 5e		 jmp	 SHORT $LN27@s370_conve
$LN20@s370_conve:
  00362	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  00366	0f ba f0 1f	 btr	 eax, 31
  0036a	85 c0		 test	 eax, eax
  0036c	75 0a		 jne	 SHORT $LN21@s370_conve
  0036e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv253[rsp], 1
  00376	eb 08		 jmp	 SHORT $LN22@s370_conve
$LN21@s370_conve:
  00378	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN22@s370_conve:
  00380	83 7c 24 38 00	 cmp	 DWORD PTR tv253[rsp], 0
  00385	74 0a		 je	 SHORT $LN25@s370_conve
  00387	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv258[rsp], 0
  0038f	eb 27		 jmp	 SHORT $LN26@s370_conve
$LN25@s370_conve:
  00391	8b 44 24 24	 mov	 eax, DWORD PTR op2$[rsp]
  00395	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0039a	85 c0		 test	 eax, eax
  0039c	74 0a		 je	 SHORT $LN23@s370_conve
  0039e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv256[rsp], 1
  003a6	eb 08		 jmp	 SHORT $LN24@s370_conve
$LN23@s370_conve:
  003a8	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tv256[rsp], 2
$LN24@s370_conve:
  003b0	8b 44 24 3c	 mov	 eax, DWORD PTR tv256[rsp]
  003b4	89 44 24 40	 mov	 DWORD PTR tv258[rsp], eax
$LN26@s370_conve:
  003b8	8b 44 24 40	 mov	 eax, DWORD PTR tv258[rsp]
  003bc	89 44 24 44	 mov	 DWORD PTR tv259[rsp], eax
$LN27@s370_conve:
  003c0	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv259[rsp]
  003c5	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN12@s370_conve:

; 2762 : 
; 2763 :     regs->GR_L( r1 ) = op1;

  003c9	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  003ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003d3	8b 54 24 48	 mov	 edx, DWORD PTR op1$[rsp]
  003d7	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2764 :     regs->psw.cc = newcc;

  003de	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003e3	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  003e8	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2765 : 
; 2766 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  003eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f0	e8 00 00 00 00	 call	 ieee_exception_test_oux
  003f5	89 44 24 2c	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2767 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  003f9	8b 44 24 2c	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  003fd	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00402	85 c0		 test	 eax, eax
  00404	74 0e		 je	 SHORT $LN14@s370_conve
  00406	8b 54 24 2c	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0040a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0040f	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_conve:

; 2768 : }

  00414	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00418	c3		 ret	 0
s370_convert_bfp_short_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
temp$1 = 36
ieee_trap_conds$ = 40
op2$ = 48
tv188 = 56
tv194 = 60
tv253 = 64
tv256 = 68
tv258 = 72
tv259 = 76
op1$ = 80
r2$ = 84
r1$ = 88
inst$ = 112
regs$ = 120
s370_convert_bfp_long_to_u32_reg PROC

; 2676 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2677 :     int        r1, r2;
; 2678 :     BYTE       m3, m4, newcc;
; 2679 :     U32        op1;
; 2680 :     float64_t  op2;
; 2681 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2682 : 
; 2683 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 54	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 58	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2684 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2685 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2686 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2687 : 
; 2688 :     GET_FLOAT64_OP( op2, r2, regs );

  00119	8b 44 24 54	 mov	 eax, DWORD PTR r2$[rsp]
  0011d	d1 e0		 shl	 eax, 1
  0011f	48 98		 cdqe
  00121	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0012e	48 8b d0	 mov	 rdx, rax
  00131	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00136	e8 00 00 00 00	 call	 s370_get_float64

; 2689 :     softfloat_exceptionFlags = 0;

  0013b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00140	8b c0		 mov	 eax, eax
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00148	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00151	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00155	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2690 : 
; 2691 :     if (FLOAT64_ISNAN( op2 ))

  00159	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00163	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00168	48 23 c8	 and	 rcx, rax
  0016b	48 8b c1	 mov	 rax, rcx
  0016e	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  00178	48 3b c1	 cmp	 rax, rcx
  0017b	75 68		 jne	 SHORT $LN8@s370_conve
  0017d	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  00187	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0018c	48 23 c8	 and	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	48 85 c0	 test	 rax, rax
  00195	74 4e		 je	 SHORT $LN8@s370_conve

; 2692 :     {
; 2693 :         op1 = 0x00000000;

  00197	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2694 :         softfloat_raiseFlags( softfloat_flag_invalid );

  0019f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a4	8b c0		 mov	 eax, eax
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ac	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001bd	83 c8 10	 or	 eax, 16
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001cf	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  001d5	45 8b c0	 mov	 r8d, r8d
  001d8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001dc	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2695 :     }

  001e0	e9 b0 00 00 00	 jmp	 $LN9@s370_conve
$LN8@s370_conve:

; 2696 :     else
; 2697 :     {
; 2698 :         SET_SF_RM_FROM_MASK( m3 );

  001e5	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001ea	85 c0		 test	 eax, eax
  001ec	74 16		 je	 SHORT $LN16@s370_conve
  001ee	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  001fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fe	89 44 24 38	 mov	 DWORD PTR tv188[rsp], eax
  00202	eb 1f		 jmp	 SHORT $LN17@s370_conve
$LN16@s370_conve:
  00204	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00209	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0020f	83 e0 07	 and	 eax, 7
  00212	8b c0		 mov	 eax, eax
  00214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0021b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021f	89 44 24 38	 mov	 DWORD PTR tv188[rsp], eax
$LN17@s370_conve:
  00223	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00228	8b c0		 mov	 eax, eax
  0022a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00230	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00239	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0023d	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv188[rsp]
  00242	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2699 :         op1 = f64_to_ui32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  00245	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  0024a	83 e0 04	 and	 eax, 4
  0024d	85 c0		 test	 eax, eax
  0024f	75 0a		 jne	 SHORT $LN18@s370_conve
  00251	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  00259	eb 08		 jmp	 SHORT $LN19@s370_conve
$LN18@s370_conve:
  0025b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN19@s370_conve:
  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  00268	8b c0		 mov	 eax, eax
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00270	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00279	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0027d	44 0f b6 44 24
	3c		 movzx	 r8d, BYTE PTR tv194[rsp]
  00283	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00287	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0028c	e8 00 00 00 00	 call	 f64_to_ui32
  00291	89 44 24 50	 mov	 DWORD PTR op1$[rsp], eax
$LN9@s370_conve:

; 2700 :     }
; 2701 : 
; 2702 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00295	33 c0		 xor	 eax, eax
  00297	83 f8 01	 cmp	 eax, 1
  0029a	74 45		 je	 SHORT $LN10@s370_conve
  0029c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002a1	8b c0		 mov	 eax, eax
  002a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ba	83 e0 10	 and	 eax, 16
  002bd	85 c0		 test	 eax, eax
  002bf	74 20		 je	 SHORT $LN10@s370_conve
  002c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002c6	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  002cc	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002d1	85 c0		 test	 eax, eax
  002d3	74 0c		 je	 SHORT $LN10@s370_conve
  002d5	b2 80		 mov	 dl, 128			; 00000080H
  002d7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002dc	e8 00 00 00 00	 call	 ieee_trap
$LN10@s370_conve:

; 2703 : 
; 2704 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  002e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  002e6	8b c0		 mov	 eax, eax
  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002ee	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002f7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ff	83 e0 10	 and	 eax, 16
  00302	85 c0		 test	 eax, eax
  00304	74 57		 je	 SHORT $LN11@s370_conve

; 2705 :     {
; 2706 :         newcc = 3;

  00306	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2707 : 
; 2708 :         if (!SUPPRESS_INEXACT( m4 ))

  0030b	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00310	83 e0 04	 and	 eax, 4
  00313	85 c0		 test	 eax, eax
  00315	75 41		 jne	 SHORT $LN13@s370_conve

; 2709 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  00317	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0031c	8b c0		 mov	 eax, eax
  0031e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00324	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0032d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00331	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00335	83 c8 01	 or	 eax, 1
  00338	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0033e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00347	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  0034d	45 8b c0	 mov	 r8d, r8d
  00350	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00354	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
$LN13@s370_conve:

; 2710 :     }

  00358	e9 ca 00 00 00	 jmp	 $LN12@s370_conve
$LN11@s370_conve:

; 2711 :     else
; 2712 :         newcc = FLOAT64_CC( op2 );

  0035d	48 b8 00 00 00
	00 00 00 f0 7f	 mov	 rax, 9218868437227405312 ; 7ff0000000000000H
  00367	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  0036c	48 23 c8	 and	 rcx, rax
  0036f	48 8b c1	 mov	 rax, rcx
  00372	48 b9 00 00 00
	00 00 00 f0 7f	 mov	 rcx, 9218868437227405312 ; 7ff0000000000000H
  0037c	48 3b c1	 cmp	 rax, rcx
  0037f	75 24		 jne	 SHORT $LN20@s370_conve
  00381	48 b8 ff ff ff
	ff ff ff 0f 00	 mov	 rax, 4503599627370495	; 000fffffffffffffH
  0038b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00390	48 23 c8	 and	 rcx, rax
  00393	48 8b c1	 mov	 rax, rcx
  00396	48 85 c0	 test	 rax, rax
  00399	74 0a		 je	 SHORT $LN20@s370_conve
  0039b	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv259[rsp], 3
  003a3	eb 79		 jmp	 SHORT $LN27@s370_conve
$LN20@s370_conve:
  003a5	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  003af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  003b4	48 23 c8	 and	 rcx, rax
  003b7	48 8b c1	 mov	 rax, rcx
  003ba	48 85 c0	 test	 rax, rax
  003bd	75 0a		 jne	 SHORT $LN21@s370_conve
  003bf	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv253[rsp], 1
  003c7	eb 08		 jmp	 SHORT $LN22@s370_conve
$LN21@s370_conve:
  003c9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN22@s370_conve:
  003d1	83 7c 24 40 00	 cmp	 DWORD PTR tv253[rsp], 0
  003d6	74 0a		 je	 SHORT $LN25@s370_conve
  003d8	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv258[rsp], 0
  003e0	eb 34		 jmp	 SHORT $LN26@s370_conve
$LN25@s370_conve:
  003e2	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  003ec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  003f1	48 23 c8	 and	 rcx, rax
  003f4	48 8b c1	 mov	 rax, rcx
  003f7	48 85 c0	 test	 rax, rax
  003fa	74 0a		 je	 SHORT $LN23@s370_conve
  003fc	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv256[rsp], 1
  00404	eb 08		 jmp	 SHORT $LN24@s370_conve
$LN23@s370_conve:
  00406	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv256[rsp], 2
$LN24@s370_conve:
  0040e	8b 44 24 44	 mov	 eax, DWORD PTR tv256[rsp]
  00412	89 44 24 48	 mov	 DWORD PTR tv258[rsp], eax
$LN26@s370_conve:
  00416	8b 44 24 48	 mov	 eax, DWORD PTR tv258[rsp]
  0041a	89 44 24 4c	 mov	 DWORD PTR tv259[rsp], eax
$LN27@s370_conve:
  0041e	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv259[rsp]
  00423	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN12@s370_conve:

; 2713 : 
; 2714 :     regs->GR_L( r1 ) = op1;

  00427	48 63 44 24 58	 movsxd	 rax, DWORD PTR r1$[rsp]
  0042c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00431	8b 54 24 50	 mov	 edx, DWORD PTR op1$[rsp]
  00435	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2715 :     regs->psw.cc = newcc;

  0043c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00441	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  00446	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2716 : 
; 2717 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  00449	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0044e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00453	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2718 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00457	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0045b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00460	85 c0		 test	 eax, eax
  00462	74 0e		 je	 SHORT $LN14@s370_conve
  00464	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00468	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0046d	e8 00 00 00 00	 call	 ieee_cond_trap
$LN14@s370_conve:

; 2719 : }

  00472	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00476	c3		 ret	 0
s370_convert_bfp_long_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
newcc$ = 34
temp$1 = 36
ieee_trap_conds$ = 40
r2$ = 44
tv200 = 48
tv206 = 52
tv277 = 56
tv282 = 60
tv284 = 64
tv285 = 68
op1$ = 72
r1$ = 76
tv305 = 80
$T2 = 96
op2$ = 112
__$ArrayPad$ = 128
inst$ = 176
regs$ = 184
s370_convert_bfp_ext_to_u32_reg PROC

; 2626 : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2627 :     int         r1, r2;
; 2628 :     BYTE        m3, m4, newcc;
; 2629 :     U32         op1;
; 2630 :     float128_t  op2;
; 2631 :     U32         ieee_trap_conds = 0;

  00025	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2632 : 
; 2633 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00035	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 _byteswap_ulong
  00041	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
  0005e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 08	 shr	 eax, 8
  00065	83 e0 0f	 and	 eax, 15
  00068	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00070	c1 e8 0c	 shr	 eax, 12
  00073	83 e0 0f	 and	 eax, 15
  00076	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  0007a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00086	48 83 c0 04	 add	 rax, 4
  0008a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00096	33 c0		 xor	 eax, eax
  00098	83 f8 04	 cmp	 eax, 4
  0009b	74 0f		 je	 SHORT $LN5@s370_conve
  0009d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 c8		 jne	 SHORT $LN4@s370_conve

; 2634 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2635 :     BFPINST_CHECK( regs );

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cf	85 c0		 test	 eax, eax
  000d1	74 3f		 je	 SHORT $LN7@s370_conve
  000d3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN6@s370_conve
  000ea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00109	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0010e	85 c0		 test	 eax, eax
  00110	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00112	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2636 :     BFPREGPAIR_CHECK( r2, regs );

  0013f	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00143	83 e0 02	 and	 eax, 2
  00146	85 c0		 test	 eax, eax
  00148	74 1b		 je	 SHORT $LN8@s370_conve
  0014a	ba 06 00 00 00	 mov	 edx, 6
  0014f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2637 :     BFPRM_CHECK( m3, regs );

  00165	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0016a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00172	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2638 : 
; 2639 :     GET_FLOAT128_OP( op2, r2, regs );

  00177	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0017b	d1 e0		 shl	 eax, 1
  0017d	48 98		 cdqe
  0017f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0018f	48 8b d0	 mov	 rdx, rax
  00192	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op2$[rsp]
  00197	e8 00 00 00 00	 call	 s370_get_float128

; 2640 :     softfloat_exceptionFlags = 0;

  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001a1	8b c0		 mov	 eax, eax
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2641 : 
; 2642 :     if (FLOAT128_ISNAN( op2 ))

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001cd	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  001d2	48 23 c1	 and	 rax, rcx
  001d5	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  001df	48 3b c1	 cmp	 rax, rcx
  001e2	75 7f		 jne	 SHORT $LN9@s370_conve
  001e4	b8 08 00 00 00	 mov	 eax, 8
  001e9	48 6b c0 01	 imul	 rax, rax, 1
  001ed	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  001f7	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  001fc	48 23 c1	 and	 rax, rcx
  001ff	48 85 c0	 test	 rax, rax
  00202	75 11		 jne	 SHORT $LN11@s370_conve
  00204	b8 08 00 00 00	 mov	 eax, 8
  00209	48 6b c0 00	 imul	 rax, rax, 0
  0020d	48 83 7c 04 70
	00		 cmp	 QWORD PTR op2$[rsp+rax], 0
  00213	74 4e		 je	 SHORT $LN9@s370_conve
$LN11@s370_conve:

; 2643 :     {
; 2644 :         op1 = 0;

  00215	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR op1$[rsp], 0

; 2645 :         softfloat_raiseFlags( softfloat_flag_invalid );

  0021d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00222	8b c0		 mov	 eax, eax
  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0022a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00233	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00237	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023b	83 c8 10	 or	 eax, 16
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00244	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0024d	41 b8 00 00 00
	00		 mov	 r8d, OFFSET FLAT:softfloat_exceptionFlags
  00253	45 8b c0	 mov	 r8d, r8d
  00256	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0025a	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al

; 2646 :     }

  0025e	e9 d4 00 00 00	 jmp	 $LN10@s370_conve
$LN9@s370_conve:

; 2647 :     else
; 2648 :     {
; 2649 :         SET_SF_RM_FROM_MASK( m3 );

  00263	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00268	85 c0		 test	 eax, eax
  0026a	74 16		 je	 SHORT $LN18@s370_conve
  0026c	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00278	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027c	89 44 24 30	 mov	 DWORD PTR tv200[rsp], eax
  00280	eb 22		 jmp	 SHORT $LN19@s370_conve
$LN18@s370_conve:
  00282	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00290	83 e0 07	 and	 eax, 7
  00293	8b c0		 mov	 eax, eax
  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0029c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a0	89 44 24 30	 mov	 DWORD PTR tv200[rsp], eax
$LN19@s370_conve:
  002a4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002a9	8b c0		 mov	 eax, eax
  002ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002ba	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002be	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv200[rsp]
  002c3	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2650 :         op1 = f128_to_ui32( op2, softfloat_roundingMode, !SUPPRESS_INEXACT( m4 ));

  002c6	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  002cb	83 e0 04	 and	 eax, 4
  002ce	85 c0		 test	 eax, eax
  002d0	75 0a		 jne	 SHORT $LN20@s370_conve
  002d2	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv206[rsp], 1
  002da	eb 08		 jmp	 SHORT $LN21@s370_conve
$LN20@s370_conve:
  002dc	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv206[rsp], 0
$LN21@s370_conve:
  002e4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  002e9	8b c0		 mov	 eax, eax
  002eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  002f1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  002fa	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002fe	48 89 4c 24 50	 mov	 QWORD PTR tv305[rsp], rcx
  00303	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T2[rsp]
  00308	4c 8d 44 24 70	 lea	 r8, QWORD PTR op2$[rsp]
  0030d	48 8b fa	 mov	 rdi, rdx
  00310	49 8b f0	 mov	 rsi, r8
  00313	b9 10 00 00 00	 mov	 ecx, 16
  00318	f3 a4		 rep movsb
  0031a	44 0f b6 44 24
	34		 movzx	 r8d, BYTE PTR tv206[rsp]
  00320	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv305[rsp]
  00325	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00329	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  0032e	e8 00 00 00 00	 call	 f128_to_ui32
  00333	89 44 24 48	 mov	 DWORD PTR op1$[rsp], eax
$LN10@s370_conve:

; 2651 :     }
; 2652 : 
; 2653 :     IEEE_EXCEPTION_TRAP_XI( regs );

  00337	33 c0		 xor	 eax, eax
  00339	83 f8 01	 cmp	 eax, 1
  0033c	74 4b		 je	 SHORT $LN12@s370_conve
  0033e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00343	8b c0		 mov	 eax, eax
  00345	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0034b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00354	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00358	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035c	83 e0 10	 and	 eax, 16
  0035f	85 c0		 test	 eax, eax
  00361	74 26		 je	 SHORT $LN12@s370_conve
  00363	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036b	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00371	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00376	85 c0		 test	 eax, eax
  00378	74 0f		 je	 SHORT $LN12@s370_conve
  0037a	b2 80		 mov	 dl, 128			; 00000080H
  0037c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	e8 00 00 00 00	 call	 ieee_trap
$LN12@s370_conve:

; 2654 : 
; 2655 :     if (softfloat_exceptionFlags & softfloat_flag_invalid)

  00389	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0038e	8b c0		 mov	 eax, eax
  00390	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00396	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0039f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a7	83 e0 10	 and	 eax, 16
  003aa	85 c0		 test	 eax, eax
  003ac	74 54		 je	 SHORT $LN13@s370_conve

; 2656 :     {
; 2657 :         newcc = 3;

  003ae	c6 44 24 22 03	 mov	 BYTE PTR newcc$[rsp], 3

; 2658 : 
; 2659 :         if (!SUPPRESS_INEXACT( m4 ))

  003b3	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  003b8	83 e0 04	 and	 eax, 4
  003bb	85 c0		 test	 eax, eax
  003bd	75 3e		 jne	 SHORT $LN15@s370_conve

; 2660 :             softfloat_exceptionFlags |= softfloat_flag_inexact;

  003bf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  003c4	8b c0		 mov	 eax, eax
  003c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003cc	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003d5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003dd	83 c8 01	 or	 eax, 1
  003e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  003e6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  003ef	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:softfloat_exceptionFlags
  003f4	8b ff		 mov	 edi, edi
  003f6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  003fa	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN15@s370_conve:

; 2661 :     }

  003fd	e9 04 01 00 00	 jmp	 $LN14@s370_conve
$LN13@s370_conve:

; 2662 :     else
; 2663 :         newcc = FLOAT128_CC( op2 );

  00402	b8 08 00 00 00	 mov	 eax, 8
  00407	48 6b c0 01	 imul	 rax, rax, 1
  0040b	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00415	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  0041a	48 23 c1	 and	 rax, rcx
  0041d	48 b9 00 00 00
	00 00 00 ff 7f	 mov	 rcx, 9223090561878065152 ; 7fff000000000000H
  00427	48 3b c1	 cmp	 rax, rcx
  0042a	75 3e		 jne	 SHORT $LN23@s370_conve
  0042c	b8 08 00 00 00	 mov	 eax, 8
  00431	48 6b c0 01	 imul	 rax, rax, 1
  00435	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  0043f	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00444	48 23 c1	 and	 rax, rcx
  00447	48 85 c0	 test	 rax, rax
  0044a	75 11		 jne	 SHORT $LN22@s370_conve
  0044c	b8 08 00 00 00	 mov	 eax, 8
  00451	48 6b c0 00	 imul	 rax, rax, 0
  00455	48 83 7c 04 70
	00		 cmp	 QWORD PTR op2$[rsp+rax], 0
  0045b	74 0d		 je	 SHORT $LN23@s370_conve
$LN22@s370_conve:
  0045d	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR tv285[rsp], 3
  00465	e9 93 00 00 00	 jmp	 $LN30@s370_conve
$LN23@s370_conve:
  0046a	b8 08 00 00 00	 mov	 eax, 8
  0046f	48 6b c0 01	 imul	 rax, rax, 1
  00473	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0047d	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  00482	48 23 c1	 and	 rax, rcx
  00485	b9 08 00 00 00	 mov	 ecx, 8
  0048a	48 6b c9 00	 imul	 rcx, rcx, 0
  0048e	48 0b 44 0c 70	 or	 rax, QWORD PTR op2$[rsp+rcx]
  00493	48 85 c0	 test	 rax, rax
  00496	75 0a		 jne	 SHORT $LN24@s370_conve
  00498	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv277[rsp], 1
  004a0	eb 08		 jmp	 SHORT $LN25@s370_conve
$LN24@s370_conve:
  004a2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv277[rsp], 0
$LN25@s370_conve:
  004aa	83 7c 24 38 00	 cmp	 DWORD PTR tv277[rsp], 0
  004af	74 0a		 je	 SHORT $LN28@s370_conve
  004b1	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv284[rsp], 0
  004b9	eb 3a		 jmp	 SHORT $LN29@s370_conve
$LN28@s370_conve:
  004bb	b8 08 00 00 00	 mov	 eax, 8
  004c0	48 6b c0 01	 imul	 rax, rax, 1
  004c4	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  004ce	48 8b 44 04 70	 mov	 rax, QWORD PTR op2$[rsp+rax]
  004d3	48 23 c1	 and	 rax, rcx
  004d6	48 85 c0	 test	 rax, rax
  004d9	74 0a		 je	 SHORT $LN26@s370_conve
  004db	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv282[rsp], 1
  004e3	eb 08		 jmp	 SHORT $LN27@s370_conve
$LN26@s370_conve:
  004e5	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tv282[rsp], 2
$LN27@s370_conve:
  004ed	8b 44 24 3c	 mov	 eax, DWORD PTR tv282[rsp]
  004f1	89 44 24 40	 mov	 DWORD PTR tv284[rsp], eax
$LN29@s370_conve:
  004f5	8b 44 24 40	 mov	 eax, DWORD PTR tv284[rsp]
  004f9	89 44 24 44	 mov	 DWORD PTR tv285[rsp], eax
$LN30@s370_conve:
  004fd	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv285[rsp]
  00502	88 44 24 22	 mov	 BYTE PTR newcc$[rsp], al
$LN14@s370_conve:

; 2664 : 
; 2665 :     regs->GR_L( r1 ) = op1;

  00506	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0050b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00513	8b 54 24 48	 mov	 edx, DWORD PTR op1$[rsp]
  00517	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2666 :     regs->psw.cc = newcc;

  0051e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00526	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR newcc$[rsp]
  0052b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2667 : 
; 2668 :     ieee_trap_conds = ieee_exception_test_oux( regs );

  0052e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00536	e8 00 00 00 00	 call	 ieee_exception_test_oux
  0053b	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2669 :     IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0053f	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  00543	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00548	85 c0		 test	 eax, eax
  0054a	74 11		 je	 SHORT $LN16@s370_conve
  0054c	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00550	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00558	e8 00 00 00 00	 call	 ieee_cond_trap
$LN16@s370_conve:

; 2670 : }

  0055d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00565	48 33 cc	 xor	 rcx, rsp
  00568	e8 00 00 00 00	 call	 __security_check_cookie
  0056d	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00574	5f		 pop	 rdi
  00575	5e		 pop	 rsi
  00576	c3		 ret	 0
s370_convert_bfp_ext_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv156 = 44
r2$ = 48
r1$ = 52
op1$ = 56
op2$ = 64
inst$ = 96
regs$ = 104
s370_convert_u64_to_bfp_short_reg PROC

; 2568 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2569 :     int        r1, r2;
; 2570 :     BYTE       m3, m4;
; 2571 :     U64        op2;
; 2572 :     float32_t  op1;
; 2573 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2574 : 
; 2575 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2576 : 
; 2577 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2578 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2579 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2580 : 
; 2581 :     SET_SF_RM_FROM_MASK( m3 );

  00119	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0011e	85 c0		 test	 eax, eax
  00120	74 16		 je	 SHORT $LN11@s370_conve
  00122	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0012e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00132	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
  00136	eb 1f		 jmp	 SHORT $LN12@s370_conve
$LN11@s370_conve:
  00138	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00143	83 e0 07	 and	 eax, 7
  00146	8b c0		 mov	 eax, eax
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0014f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00153	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN12@s370_conve:
  00157	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0015c	8b c0		 mov	 eax, eax
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00164	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0016d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00171	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv156[rsp]
  00176	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2582 :     op2 = regs->GR_G( r2 );

  00179	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  0017e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0018b	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 2583 :     softfloat_exceptionFlags = 0;

  00190	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00195	8b c0		 mov	 eax, eax
  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001aa	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2584 : 
; 2585 :     op1 = ui64_to_f32( op2 );

  001ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  001b3	e8 00 00 00 00	 call	 ui64_to_f32
  001b8	89 44 24 38	 mov	 DWORD PTR op1$[rsp], eax

; 2586 : 
; 2587 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  001bc	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  001c0	d1 e0		 shl	 eax, 1
  001c2	48 98		 cdqe
  001c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001c9	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d1	48 8b d0	 mov	 rdx, rax
  001d4	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  001d9	e8 00 00 00 00	 call	 s370_put_float32

; 2588 : 
; 2589 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  001de	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e3	8b c0		 mov	 eax, eax
  001e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001eb	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fc	85 c0		 test	 eax, eax
  001fe	74 35		 je	 SHORT $LN8@s370_conve
  00200	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00205	83 e0 04	 and	 eax, 4
  00208	85 c0		 test	 eax, eax
  0020a	75 29		 jne	 SHORT $LN8@s370_conve

; 2590 :     {
; 2591 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0020c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00211	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00216	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2592 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0021a	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0021e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00223	85 c0		 test	 eax, eax
  00225	74 0e		 je	 SHORT $LN9@s370_conve
  00227	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0022b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00230	e8 00 00 00 00	 call	 ieee_cond_trap
$LN9@s370_conve:
$LN8@s370_conve:

; 2593 :     }
; 2594 : }

  00235	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00239	c3		 ret	 0
s370_convert_u64_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv156 = 44
r2$ = 48
r1$ = 52
op2$ = 56
op1$ = 64
inst$ = 96
regs$ = 104
s370_convert_u64_to_bfp_long_reg PROC

; 2531 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2532 :     int        r1, r2;
; 2533 :     BYTE       m3, m4;
; 2534 :     U64        op2;
; 2535 :     float64_t  op1;
; 2536 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2537 : 
; 2538 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2539 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2540 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2541 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2542 : 
; 2543 :     SET_SF_RM_FROM_MASK( m3 );

  00119	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0011e	85 c0		 test	 eax, eax
  00120	74 16		 je	 SHORT $LN11@s370_conve
  00122	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0012e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00132	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
  00136	eb 1f		 jmp	 SHORT $LN12@s370_conve
$LN11@s370_conve:
  00138	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00143	83 e0 07	 and	 eax, 7
  00146	8b c0		 mov	 eax, eax
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0014f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00153	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN12@s370_conve:
  00157	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0015c	8b c0		 mov	 eax, eax
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00164	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0016d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00171	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv156[rsp]
  00176	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2544 :     op2 = regs->GR_G( r2 );

  00179	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  0017e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0018b	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 2545 :     softfloat_exceptionFlags = 0;

  00190	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00195	8b c0		 mov	 eax, eax
  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001aa	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2546 : 
; 2547 :     op1 = ui64_to_f64( op2 );

  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  001b3	e8 00 00 00 00	 call	 ui64_to_f64
  001b8	48 89 44 24 40	 mov	 QWORD PTR op1$[rsp], rax

; 2548 : 
; 2549 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  001bd	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  001c1	d1 e0		 shl	 eax, 1
  001c3	48 98		 cdqe
  001c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1$[rsp]
  001da	e8 00 00 00 00	 call	 s370_put_float64

; 2550 : 
; 2551 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  001df	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e4	8b c0		 mov	 eax, eax
  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ec	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f5	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fd	85 c0		 test	 eax, eax
  001ff	74 35		 je	 SHORT $LN8@s370_conve
  00201	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00206	83 e0 04	 and	 eax, 4
  00209	85 c0		 test	 eax, eax
  0020b	75 29		 jne	 SHORT $LN8@s370_conve

; 2552 :     {
; 2553 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  0020d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00217	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2554 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  0021b	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0021f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00224	85 c0		 test	 eax, eax
  00226	74 0e		 je	 SHORT $LN9@s370_conve
  00228	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  0022c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00231	e8 00 00 00 00	 call	 ieee_cond_trap
$LN9@s370_conve:
$LN8@s370_conve:

; 2555 :     }
; 2556 : }

  00236	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0023a	c3		 ret	 0
s370_convert_u64_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
temp$1 = 36
tv158 = 40
r1$ = 44
r2$ = 48
op2$ = 56
$T2 = 64
op1$ = 80
__$ArrayPad$ = 96
inst$ = 144
regs$ = 152
s370_convert_u64_to_bfp_ext_reg PROC

; 2500 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2501 :     int         r1, r2;
; 2502 :     BYTE        m3;
; 2503 :     U64         op2;
; 2504 :     float128_t  op1;
; 2505 : 
; 2506 :     RRF_M( inst, regs, r1, r2, m3 );

  0001f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 04	 shr	 eax, 4
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 0c	 shr	 eax, 12
  00057	83 e0 0f	 and	 eax, 15
  0005a	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  0005e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00066	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006a	48 83 c0 04	 add	 rax, 4
  0006e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007a	33 c0		 xor	 eax, eax
  0007c	83 f8 04	 cmp	 eax, 4
  0007f	74 0f		 je	 SHORT $LN5@s370_conve
  00081	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 c8		 jne	 SHORT $LN4@s370_conve

; 2507 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2508 :     BFPINST_CHECK( regs );

  00096	b8 08 00 00 00	 mov	 eax, 8
  0009b	48 6b c0 01	 imul	 rax, rax, 1
  0009f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a7	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ae	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b3	85 c0		 test	 eax, eax
  000b5	74 3f		 je	 SHORT $LN7@s370_conve
  000b7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c5	d1 e8		 shr	 eax, 1
  000c7	83 e0 01	 and	 eax, 1
  000ca	85 c0		 test	 eax, eax
  000cc	74 55		 je	 SHORT $LN6@s370_conve
  000ce	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dd	b9 08 00 00 00	 mov	 ecx, 8
  000e2	48 6b c9 01	 imul	 rcx, rcx, 1
  000e6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ed	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f2	85 c0		 test	 eax, eax
  000f4	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000f6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fe	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00108	ba 07 00 00 00	 mov	 edx, 7
  0010d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00115	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2509 :     BFPREGPAIR_CHECK( r1, regs );

  00123	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00127	83 e0 02	 and	 eax, 2
  0012a	85 c0		 test	 eax, eax
  0012c	74 1b		 je	 SHORT $LN8@s370_conve
  0012e	ba 06 00 00 00	 mov	 edx, 6
  00133	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00143	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2510 :     BFPRM_CHECK( m3, regs );

  00149	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0014e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2511 : 
; 2512 :     SET_SF_RM_FROM_MASK( m3 );

  0015b	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00160	85 c0		 test	 eax, eax
  00162	74 16		 je	 SHORT $LN10@s370_conve
  00164	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00170	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00174	89 44 24 28	 mov	 DWORD PTR tv158[rsp], eax
  00178	eb 22		 jmp	 SHORT $LN11@s370_conve
$LN10@s370_conve:
  0017a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00188	83 e0 07	 and	 eax, 7
  0018b	8b c0		 mov	 eax, eax
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  00194	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00198	89 44 24 28	 mov	 DWORD PTR tv158[rsp], eax
$LN11@s370_conve:
  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001a1	8b c0		 mov	 eax, eax
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a9	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001b6	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv158[rsp]
  001bb	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2513 :     op2 = regs->GR_G( r2 );

  001be	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  001c3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001d3	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 2514 :     softfloat_exceptionFlags = 0;

  001d8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001dd	8b c0		 mov	 eax, eax
  001df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ee	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f2	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2515 : 
; 2516 :     op1 = ui64_to_f128( op2 );

  001f6	48 8b 54 24 38	 mov	 rdx, QWORD PTR op2$[rsp]
  001fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00200	e8 00 00 00 00	 call	 ui64_to_f128
  00205	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  0020a	48 8b f9	 mov	 rdi, rcx
  0020d	48 8b f0	 mov	 rsi, rax
  00210	b9 10 00 00 00	 mov	 ecx, 16
  00215	f3 a4		 rep movsb

; 2517 : 
; 2518 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  00217	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0021b	d1 e0		 shl	 eax, 1
  0021d	48 98		 cdqe
  0021f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00227	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0022f	48 8b d0	 mov	 rdx, rax
  00232	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1$[rsp]
  00237	e8 00 00 00 00	 call	 s370_put_float128

; 2519 : }

  0023c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00241	48 33 cc	 xor	 rcx, rsp
  00244	e8 00 00 00 00	 call	 __security_check_cookie
  00249	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0024d	5f		 pop	 rdi
  0024e	5e		 pop	 rsi
  0024f	c3		 ret	 0
s370_convert_u64_to_bfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
m4$ = 33
temp$1 = 36
ieee_trap_conds$ = 40
tv156 = 44
r2$ = 48
op2$ = 52
r1$ = 56
op1$ = 60
inst$ = 80
regs$ = 88
s370_convert_u32_to_bfp_short_reg PROC

; 2467 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2468 :     int        r1, r2;
; 2469 :     BYTE       m3, m4;
; 2470 :     U32        op2;
; 2471 :     float32_t  op1;
; 2472 :     U32        ieee_trap_conds = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ieee_trap_conds$[rsp], 0

; 2473 : 
; 2474 :     RRF_MM( inst, regs, r1, r2, m3, m4 );

  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 _byteswap_ulong
  00027	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002f	83 e0 0f	 and	 eax, 15
  00032	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00036	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 04	 shr	 eax, 4
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 0f	 and	 eax, 15
  0004e	88 44 24 21	 mov	 BYTE PTR m4$[rsp], al
  00052	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00076	33 c0		 xor	 eax, eax
  00078	83 f8 04	 cmp	 eax, 4
  0007b	74 0c		 je	 SHORT $LN5@s370_conve
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d1		 jne	 SHORT $LN4@s370_conve

; 2475 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2476 :     BFPINST_CHECK( regs );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 01	 imul	 rax, rax, 1
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000a9	85 c0		 test	 eax, eax
  000ab	74 39		 je	 SHORT $LN7@s370_conve
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b8	d1 e8		 shr	 eax, 1
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 49		 je	 SHORT $LN6@s370_conve
  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cd	b9 08 00 00 00	 mov	 ecx, 8
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000dd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2477 :     BFPRM_CHECK( m3, regs );

  0010a	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0010f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2478 : 
; 2479 :     SET_SF_RM_FROM_MASK( m3 );

  00119	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0011e	85 c0		 test	 eax, eax
  00120	74 16		 je	 SHORT $LN11@s370_conve
  00122	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0012e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00132	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
  00136	eb 1f		 jmp	 SHORT $LN12@s370_conve
$LN11@s370_conve:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00143	83 e0 07	 and	 eax, 7
  00146	8b c0		 mov	 eax, eax
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0014f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00153	89 44 24 2c	 mov	 DWORD PTR tv156[rsp], eax
$LN12@s370_conve:
  00157	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0015c	8b c0		 mov	 eax, eax
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00164	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0016d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00171	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv156[rsp]
  00176	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2480 :     op2 = regs->GR_L( r2 );

  00179	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  0017e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0018a	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 2481 :     softfloat_exceptionFlags = 0;

  0018e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  00193	8b c0		 mov	 eax, eax
  00195	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0019b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001a4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001a8	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2482 : 
; 2483 :     op1 = ui32_to_f32( op2 );

  001ac	8b 4c 24 34	 mov	 ecx, DWORD PTR op2$[rsp]
  001b0	e8 00 00 00 00	 call	 ui32_to_f32
  001b5	89 44 24 3c	 mov	 DWORD PTR op1$[rsp], eax

; 2484 : 
; 2485 :     PUT_FLOAT32_NOCC( op1, r1, regs );

  001b9	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  001bd	d1 e0		 shl	 eax, 1
  001bf	48 98		 cdqe
  001c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001c6	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001ce	48 8b d0	 mov	 rdx, rax
  001d1	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR op1$[rsp]
  001d6	e8 00 00 00 00	 call	 s370_put_float32

; 2486 : 
; 2487 :     if (softfloat_exceptionFlags && !SUPPRESS_INEXACT( m4 ))

  001db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001e0	8b c0		 mov	 eax, eax
  001e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001f1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f9	85 c0		 test	 eax, eax
  001fb	74 35		 je	 SHORT $LN8@s370_conve
  001fd	0f b6 44 24 21	 movzx	 eax, BYTE PTR m4$[rsp]
  00202	83 e0 04	 and	 eax, 4
  00205	85 c0		 test	 eax, eax
  00207	75 29		 jne	 SHORT $LN8@s370_conve

; 2488 :     {
; 2489 :         ieee_trap_conds = ieee_exception_test_oux( regs );

  00209	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0020e	e8 00 00 00 00	 call	 ieee_exception_test_oux
  00213	89 44 24 28	 mov	 DWORD PTR ieee_trap_conds$[rsp], eax

; 2490 :         IEEE_EXCEPTION_TRAP( regs, ieee_trap_conds, FPC_MASK_IMX );

  00217	8b 44 24 28	 mov	 eax, DWORD PTR ieee_trap_conds$[rsp]
  0021b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00220	85 c0		 test	 eax, eax
  00222	74 0e		 je	 SHORT $LN9@s370_conve
  00224	8b 54 24 28	 mov	 edx, DWORD PTR ieee_trap_conds$[rsp]
  00228	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0022d	e8 00 00 00 00	 call	 ieee_cond_trap
$LN9@s370_conve:
$LN8@s370_conve:

; 2491 :     }
; 2492 : }

  00232	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00236	c3		 ret	 0
s370_convert_u32_to_bfp_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
temp$1 = 36
tv158 = 40
r2$ = 44
op2$ = 48
r1$ = 52
op1$ = 56
inst$ = 80
regs$ = 88
s370_convert_u32_to_bfp_long_reg PROC

; 2438 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2439 :     int        r1, r2;
; 2440 :     BYTE       m3;
; 2441 :     U32        op2;
; 2442 :     float64_t  op1;
; 2443 : 
; 2444 :     RRF_M( inst, regs, r1, r2, m3 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_conve
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_conve

; 2445 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2446 :     BFPINST_CHECK( regs );

  00079	b8 08 00 00 00	 mov	 eax, 8
  0007e	48 6b c0 01	 imul	 rax, rax, 1
  00082	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0008e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00093	85 c0		 test	 eax, eax
  00095	74 39		 je	 SHORT $LN7@s370_conve
  00097	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a2	d1 e8		 shr	 eax, 1
  000a4	83 e0 01	 and	 eax, 1
  000a7	85 c0		 test	 eax, eax
  000a9	74 49		 je	 SHORT $LN6@s370_conve
  000ab	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b7	b9 08 00 00 00	 mov	 ecx, 8
  000bc	48 6b c9 01	 imul	 rcx, rcx, 1
  000c0	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c7	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cc	85 c0		 test	 eax, eax
  000ce	75 24		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000d0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  000df	ba 07 00 00 00	 mov	 edx, 7
  000e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2447 :     BFPRM_CHECK( m3, regs );

  000f4	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2448 : 
; 2449 :     op2 = regs->GR_L( r2 );

  00103	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00108	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0010d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00114	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 2450 :     SET_SF_RM_FROM_MASK( m3 );

  00118	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  0011d	85 c0		 test	 eax, eax
  0011f	74 16		 je	 SHORT $LN9@s370_conve
  00121	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  0012d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00131	89 44 24 28	 mov	 DWORD PTR tv158[rsp], eax
  00135	eb 1f		 jmp	 SHORT $LN10@s370_conve
$LN9@s370_conve:
  00137	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00142	83 e0 07	 and	 eax, 7
  00145	8b c0		 mov	 eax, eax
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  0014e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00152	89 44 24 28	 mov	 DWORD PTR tv158[rsp], eax
$LN10@s370_conve:
  00156	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  0015b	8b c0		 mov	 eax, eax
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00163	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0016c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00170	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv158[rsp]
  00175	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2451 :     softfloat_exceptionFlags = 0;

  00178	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  0017d	8b c0		 mov	 eax, eax
  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00185	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00192	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2452 : 
; 2453 :     op1 = ui32_to_f64( op2 );

  00196	8b 4c 24 30	 mov	 ecx, DWORD PTR op2$[rsp]
  0019a	e8 00 00 00 00	 call	 ui32_to_f64
  0019f	48 89 44 24 38	 mov	 QWORD PTR op1$[rsp], rax

; 2454 : 
; 2455 :     PUT_FLOAT64_NOCC( op1, r1, regs );

  001a4	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  001a8	d1 e0		 shl	 eax, 1
  001aa	48 98		 cdqe
  001ac	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  001b9	48 8b d0	 mov	 rdx, rax
  001bc	48 8d 4c 24 38	 lea	 rcx, QWORD PTR op1$[rsp]
  001c1	e8 00 00 00 00	 call	 s370_put_float64

; 2456 : }

  001c6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ca	c3		 ret	 0
s370_convert_u32_to_bfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ieee.c
_TEXT	SEGMENT
m3$ = 32
temp$1 = 36
tv163 = 40
r1$ = 44
r2$ = 48
op2$ = 52
$T2 = 56
op1$ = 72
__$ArrayPad$ = 88
inst$ = 128
regs$ = 136
s370_convert_u32_to_bfp_ext_reg PROC

; 2410 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2411 :     int         r1, r2;
; 2412 :     BYTE        m3;
; 2413 :     U32         op2;
; 2414 :     float128_t  op1;
; 2415 : 
; 2416 :     RRF_M( inst, regs, r1, r2, m3 );

  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 04	 shr	 eax, 4
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00050	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 0c	 shr	 eax, 12
  00057	83 e0 0f	 and	 eax, 15
  0005a	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_conve:
  0005e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00066	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006a	48 83 c0 04	 add	 rax, 4
  0006e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007a	33 c0		 xor	 eax, eax
  0007c	83 f8 04	 cmp	 eax, 4
  0007f	74 0f		 je	 SHORT $LN5@s370_conve
  00081	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 c8		 jne	 SHORT $LN4@s370_conve

; 2417 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2418 :     BFPINST_CHECK( regs );

  00096	b8 08 00 00 00	 mov	 eax, 8
  0009b	48 6b c0 01	 imul	 rax, rax, 1
  0009f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a7	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ae	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b3	85 c0		 test	 eax, eax
  000b5	74 3f		 je	 SHORT $LN7@s370_conve
  000b7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c5	d1 e8		 shr	 eax, 1
  000c7	83 e0 01	 and	 eax, 1
  000ca	85 c0		 test	 eax, eax
  000cc	74 55		 je	 SHORT $LN6@s370_conve
  000ce	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dd	b9 08 00 00 00	 mov	 ecx, 8
  000e2	48 6b c9 01	 imul	 rcx, rcx, 1
  000e6	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ed	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f2	85 c0		 test	 eax, eax
  000f4	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000f6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fe	c7 80 08 07 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+1800], 2
  00108	ba 07 00 00 00	 mov	 edx, 7
  0010d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00115	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2419 :     BFPREGPAIR_CHECK( r1, regs );

  00123	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00127	83 e0 02	 and	 eax, 2
  0012a	85 c0		 test	 eax, eax
  0012c	74 1b		 je	 SHORT $LN8@s370_conve
  0012e	ba 06 00 00 00	 mov	 edx, 6
  00133	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00143	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2420 :     BFPRM_CHECK( m3, regs );

  00149	0f b6 54 24 20	 movzx	 edx, BYTE PTR m3$[rsp]
  0014e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	e8 00 00 00 00	 call	 s370_BFP_RM_check

; 2421 : 
; 2422 :     op2 = regs->GR_L( r2 );

  0015b	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  00160	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0016f	89 44 24 34	 mov	 DWORD PTR op2$[rsp], eax

; 2423 :     SET_SF_RM_FROM_MASK( m3 );

  00173	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00178	85 c0		 test	 eax, eax
  0017a	74 16		 je	 SHORT $LN10@s370_conve
  0017c	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_m3_to_sf_rm
  00188	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018c	89 44 24 28	 mov	 DWORD PTR tv163[rsp], eax
  00190	eb 22		 jmp	 SHORT $LN11@s370_conve
$LN10@s370_conve:
  00192	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001a0	83 e0 07	 and	 eax, 7
  001a3	8b c0		 mov	 eax, eax
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map_fpc_brm_to_sf_rm
  001ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b0	89 44 24 28	 mov	 DWORD PTR tv163[rsp], eax
$LN11@s370_conve:
  001b4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_roundingMode
  001b9	8b c0		 mov	 eax, eax
  001bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001c1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ca	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001ce	0f b6 54 24 28	 movzx	 edx, BYTE PTR tv163[rsp]
  001d3	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2424 :     softfloat_exceptionFlags = 0;

  001d6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:softfloat_exceptionFlags
  001db	8b c0		 mov	 eax, eax
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ec	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  001f0	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2425 : 
; 2426 :     op1 = ui32_to_f128( op2 );

  001f4	8b 54 24 34	 mov	 edx, DWORD PTR op2$[rsp]
  001f8	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  001fd	e8 00 00 00 00	 call	 ui32_to_f128
  00202	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00207	48 8b f9	 mov	 rdi, rcx
  0020a	48 8b f0	 mov	 rsi, rax
  0020d	b9 10 00 00 00	 mov	 ecx, 16
  00212	f3 a4		 rep movsb

; 2427 : 
; 2428 :     PUT_FLOAT128_NOCC( op1, r1, regs );

  00214	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00218	d1 e0		 shl	 eax, 1
  0021a	48 98		 cdqe
  0021c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00224	48 8d 84 81 40
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+832]
  0022c	48 8b d0	 mov	 rdx, rax
  0022f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op1$[rsp]
  00234	e8 00 00 00 00	 call	 s370_put_float128

; 2429 : }

  00239	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023e	48 33 cc	 xor	 rcx, rsp
  00241	e8 00 00 00 00	 call	 __security_check_cookie
  00246	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024a	5f		 pop	 rdi
  0024b	5e		 pop	 rsi
  0024c	c3		 ret	 0
s370_convert_u32_to_bfp_ext_reg ENDP
_TEXT	ENDS
END
