; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	opts
PUBLIC	blkptr
PUBLIC	blkidx
PUBLIC	blklen
PUBLIC	recptr
PUBLIC	recidx
PUBLIC	reclen
_BSS	SEGMENT
opts	DB	038H DUP (?)
blkptr	DQ	01H DUP (?)
blkidx	DD	01H DUP (?)
blklen	DD	01H DUP (?)
recptr	DQ	01H DUP (?)
recidx	DD	01H DUP (?)
reclen	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG159337 DB	'U', 00H
	ORG $+2
$SG159338 DB	'UA', 00H
	ORG $+1
$SG159339 DB	'UM', 00H
	ORG $+1
$SG159340 DB	'F', 00H
	ORG $+2
$SG159341 DB	'FA', 00H
	ORG $+1
$SG159342 DB	'FM', 00H
	ORG $+1
$SG159343 DB	'FB', 00H
	ORG $+1
$SG159344 DB	'FBA', 00H
$SG159345 DB	'FBM', 00H
$SG159346 DB	'FS', 00H
	ORG $+1
$SG159347 DB	'FSA', 00H
$SG159348 DB	'FSM', 00H
$SG159349 DB	'FBS', 00H
$SG159350 DB	'FBSA', 00H
	ORG $+3
$SG159351 DB	'FBSM', 00H
	ORG $+3
$SG159352 DB	'V', 00H
	ORG $+2
$SG159353 DB	'VA', 00H
	ORG $+1
$SG159354 DB	'VM', 00H
	ORG $+1
$SG159355 DB	'VB', 00H
	ORG $+1
$SG159356 DB	'VBA', 00H
$SG159357 DB	'VBM', 00H
$SG159358 DB	'VS', 00H
	ORG $+1
$SG159359 DB	'VSA', 00H
$SG159360 DB	'VSM', 00H
$SG159361 DB	'VBS', 00H
$SG159362 DB	'VBSA', 00H
	ORG $+3
$SG159363 DB	'VBSM', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+8
valfm	DQ	FLAT:$SG159337
	DD	080H
	ORG $+4
	DQ	FLAT:$SG159338
	DD	080H
	ORG $+4
	DQ	FLAT:$SG159339
	DD	080H
	ORG $+4
	DQ	FLAT:$SG159340
	DD	040H
	ORG $+4
	DQ	FLAT:$SG159341
	DD	040H
	ORG $+4
	DQ	FLAT:$SG159342
	DD	040H
	ORG $+4
	DQ	FLAT:$SG159343
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159344
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159345
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159346
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159347
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159348
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159349
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159350
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159351
	DD	048H
	ORG $+4
	DQ	FLAT:$SG159352
	DD	020H
	ORG $+4
	DQ	FLAT:$SG159353
	DD	020H
	ORG $+4
	DQ	FLAT:$SG159354
	DD	020H
	ORG $+4
	DQ	FLAT:$SG159355
	DD	028H
	ORG $+4
	DQ	FLAT:$SG159356
	DD	028H
	ORG $+4
	DQ	FLAT:$SG159357
	DD	028H
	ORG $+4
	DQ	FLAT:$SG159358
	DD	024H
	ORG $+4
	DQ	FLAT:$SG159359
	DD	024H
	ORG $+4
	DQ	FLAT:$SG159360
	DD	024H
	ORG $+4
	DQ	FLAT:$SG159361
	DD	02cH
	ORG $+4
	DQ	FLAT:$SG159362
	DD	02cH
	ORG $+4
	DQ	FLAT:$SG159363
	DD	02cH
	ORG $+4
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	merge
PUBLIC	bdw_length
PUBLIC	rdw_length
PUBLIC	getblock
PUBLIC	getrecord
PUBLIC	get_sl
PUBLIC	getfile
PUBLIC	usage
PUBLIC	main
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp__ftelli64:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_het_open:PROC
EXTRN	__imp_het_close:PROC
EXTRN	__imp_het_read:PROC
EXTRN	__imp_het_fsf:PROC
EXTRN	__imp_het_error:PROC
EXTRN	__imp_getopt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_fet_open:PROC
EXTRN	__imp_fet_close:PROC
EXTRN	__imp_fet_read:PROC
EXTRN	__imp_fet_fsf:PROC
EXTRN	__imp_fet_error:PROC
EXTRN	__imp_sl_etoa:PROC
EXTRN	__imp_sl_fmtlab:PROC
EXTRN	__imp_sl_islabel:PROC
EXTRN	__imp_sl_istype:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__imp_optind:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
prevpos	DQ	01H DUP (?)
$SG159644 DB	01H DUP (?)
	ALIGN	4

$SG159645 DB	01H DUP (?)
	ALIGN	4

$SG159646 DB	01H DUP (?)
	ALIGN	4

$SG159647 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$merge DD	imagerel $LN15
	DD	imagerel $LN15+479
	DD	imagerel $unwind$merge
$pdata$bdw_length DD imagerel $LN5
	DD	imagerel $LN5+222
	DD	imagerel $unwind$bdw_length
$pdata$rdw_length DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$rdw_length
$pdata$getblock DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$getblock
$pdata$getrecord DD imagerel $LN15
	DD	imagerel $LN15+295
	DD	imagerel $unwind$getrecord
$pdata$get_sl DD imagerel $LN10
	DD	imagerel $LN10+355
	DD	imagerel $unwind$get_sl
$pdata$getfile DD imagerel $LN58
	DD	imagerel $LN58+2181
	DD	imagerel $unwind$getfile
$pdata$usage DD	imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$usage
$pdata$main DD	imagerel $LN46
	DD	imagerel $LN46+2314
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
	ORG $+3
$SG159393 DB	'I', 00H
	ORG $+2
$SG159394 DB	'HHC02761%s DCB Attributes used:  RECFM=%-4.4s  LRECL=%-5'
	DB	'.5d  BLKSIZE=%d', 0aH, 00H
	ORG $+3
$SG159395 DB	'merge', 00H
	ORG $+2
$SG159445 DB	'E', 00H
	ORG $+2
$SG159396 DB	'hetget.c', 00H
	ORG $+3
$SG159447 DB	'get_sl', 00H
	ORG $+1
$SG159450 DB	'E', 00H
	ORG $+2
$SG159444 DB	'fet_read()', 00H
	ORG $+1
$SG159491 DB	'f', 00H
	ORG $+2
$SG159446 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159448 DB	'hetget.c', 00H
	ORG $+3
$SG159452 DB	'get_sl', 00H
	ORG $+1
$SG159492 DB	'h', 00H
	ORG $+2
$SG159449 DB	'het_read()', 00H
	ORG $+1
$SG159494 DB	'E', 00H
	ORG $+2
$SG159451 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159453 DB	'hetget.c', 00H
	ORG $+3
$SG159501 DB	'E', 00H
	ORG $+2
$SG159493 DB	'%set_fsf() while positioning to file ''%d''', 00H
	ORG $+2
$SG159508 DB	'f', 00H
	ORG $+2
$SG159495 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159496 DB	'getfile', 00H
$SG159497 DB	'hetget.c', 00H
	ORG $+3
$SG159500 DB	'VOL1', 00H
	ORG $+3
$SG159509 DB	'h', 00H
	ORG $+2
$SG159502 DB	'HHC02753%s %s label missing', 0aH, 00H
	ORG $+3
$SG159503 DB	'getfile', 00H
$SG159504 DB	'hetget.c', 00H
	ORG $+3
$SG159511 DB	'E', 00H
	ORG $+2
$SG159510 DB	'%set_fsf() while positioning to file ''%d''', 00H
	ORG $+2
$SG159518 DB	'E', 00H
	ORG $+2
$SG159512 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159513 DB	'getfile', 00H
$SG159514 DB	'hetget.c', 00H
	ORG $+3
$SG159517 DB	'HDR1', 00H
	ORG $+3
$SG159522 DB	'I', 00H
	ORG $+2
$SG159519 DB	'HHC02753%s %s label missing', 0aH, 00H
	ORG $+3
$SG159520 DB	'getfile', 00H
$SG159521 DB	'hetget.c', 00H
	ORG $+3
$SG159529 DB	'E', 00H
	ORG $+2
$SG159523 DB	'HHC02754%s File Info:  DSN=%-17.17s', 0aH, 00H
	ORG $+3
$SG159524 DB	'getfile', 00H
$SG159525 DB	'hetget.c', 00H
	ORG $+3
$SG159528 DB	'HDR2', 00H
	ORG $+3
$SG159539 DB	'E', 00H
	ORG $+2
$SG159530 DB	'HHC02753%s %s label missing', 0aH, 00H
	ORG $+3
$SG159531 DB	'getfile', 00H
$SG159532 DB	'hetget.c', 00H
	ORG $+3
$SG159544 DB	'E', 00H
	ORG $+2
$SG159538 DB	'fet_fsf()', 00H
	ORG $+2
$SG159560 DB	0aH, 00H
	ORG $+2
$SG159540 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159541 DB	'getfile', 00H
$SG159542 DB	'hetget.c', 00H
	ORG $+3
$SG159571 DB	'I', 00H
	ORG $+2
$SG159543 DB	'het_fsf()', 00H
	ORG $+2
$SG159609 DB	'hetget', 00H
	ORG $+1
$SG159620 DB	'E', 00H
	ORG $+2
$SG159545 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159546 DB	'getfile', 00H
$SG159547 DB	'hetget.c', 00H
	ORG $+3
$SG159573 DB	'usage', 00H
	ORG $+2
$SG159610 DB	'abhnsu', 00H
	ORG $+1
$SG159628 DB	'%d', 00H
	ORG $+1
$SG159555 DB	'IPOS=%lld', 0aH, 00H
	ORG $+1
$SG159630 DB	'S', 00H
	ORG $+2
$SG159566 DB	'IPOS=%lld', 0aH, 00H
	ORG $+5
$SG159572 DB	'HHC02728%s Usage: %s [options] hetfile outfile fileno [r'
	DB	'ecfm lrecl blksize]', 0aH, 'HHC02728I   hetfile   input file', 0aH
	DB	'HHC02728I   outfile   output file', 0aH, 'HHC02728I   fileno '
	DB	'   which file to extract (1-9999, default 1)', 0aH, 'HHC02728'
	DB	'I Options:', 0aH, 'HHC02728I   -a    convert to ASCII (implie'
	DB	's -u)', 0aH, 'HHC02728I   -h    display usage summary', 0aH, 'H'
	DB	'HC02728I   -n    file is an NL (or BLP like) tape', 0aH, 'HHC'
	DB	'02728I   -u    unblock (removes BDWs and RDWs if RECFM=V)', 0aH
	DB	'HHC02728I   -s    strip trailing blanks (requires -a)', 0aH, 00H
	ORG $+3
$SG159636 DB	'S', 00H
	ORG $+2
$SG159574 DB	'hetget.c', 00H
	ORG $+3
$SG159648 DB	'I', 00H
	ORG $+2
$SG159608 DB	'Extract Files from AWS, HET or FAKETAPE', 00H
$SG159621 DB	'HHC02446%s Invalid number of arguments', 0aH, 00H
$SG159622 DB	'main', 00H
	ORG $+3
$SG159623 DB	'hetget.c', 00H
	ORG $+3
$SG159625 DB	'.fkt', 00H
	ORG $+3
$SG159653 DB	'I', 00H
	ORG $+2
$SG159629 DB	'; file number must be within the range of 1 to 9999', 00H
$SG159655 DB	'%s', 00H
	ORG $+1
$SG159631 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159632 DB	'main', 00H
	ORG $+3
$SG159658 DB	'0', 00H
	ORG $+2
$SG159633 DB	'hetget.c', 00H
	ORG $+3
$SG159659 DB	'S', 00H
	ORG $+2
$SG159637 DB	'HHC02750%s DCB attributes required for NL tape', 0aH, 00H
$SG159638 DB	'main', 00H
	ORG $+3
$SG159639 DB	'hetget.c', 00H
	ORG $+3
$SG159668 DB	'wb', 00H
	ORG $+1
$SG159649 DB	'HHC02751%s Valid record formats are:', 0aH, 00H
	ORG $+2
$SG159650 DB	'  %-4.4s', 00H
	ORG $+3
$SG159673 DB	'E', 00H
	ORG $+2
$SG159654 DB	'HHC02752%s %s', 0aH, 00H
	ORG $+1
$SG159657 DB	'; block size can''t be zero', 00H
	ORG $+1
$SG159678 DB	'E', 00H
	ORG $+2
$SG159660 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159661 DB	'main', 00H
	ORG $+7
$SG159662 DB	'hetget.c', 00H
	ORG $+7
$SG159672 DB	'fet_open()', 00H
	ORG $+5
$SG159674 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159675 DB	'main', 00H
	ORG $+3
$SG159676 DB	'hetget.c', 00H
	ORG $+7
$SG159677 DB	'het_open()', 00H
	ORG $+5
$SG159679 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159680 DB	'main', 00H
	ORG $+3
$SG159681 DB	'hetget.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01bH
	DD	08f1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:getfile
	DD	016H
	DD	086dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:merge
	DD	016H
	DD	01c7H
voltbl	ENDS
xdata	SEGMENT
$unwind$merge DD 021e19H
	DD	039010cH
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$bdw_length DD 010901H
	DD	02209H
$unwind$rdw_length DD 010901H
	DD	02209H
$unwind$getblock DD 010401H
	DD	06204H
$unwind$getrecord DD 010401H
	DD	06204H
$unwind$get_sl DD 010901H
	DD	0e209H
$unwind$getfile DD 021e19H
	DD	069010cH
	DD	imagerel __GSHandlerCheck
	DD	0330H
$unwind$usage DD 010901H
	DD	08209H
$unwind$main DD	032319H
	DD	0940111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0490H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
rc$ = 80
i$ = 84
tv76 = 88
pgm$ = 96
outf$ = 104
$T1 = 112
tv222 = 120
tv396 = 128
tv409 = 136
msgbuf3$2 = 144
msgbuf$3 = 160
msgbuf2$4 = 192
msgbuf4$5 = 256
pathname$ = 384
msgbuf$6 = 656
__$ArrayPad$ = 1168
argc$ = 1200
argv$ = 1208
main	PROC

; 662  : {

$LN46:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 81 ec a0 04
	00 00		 sub	 rsp, 1184		; 000004a0H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 663  :     char           *pgm;                    /* less any extension (.ext) */
; 664  :     FILE           *outf;
; 665  :     int             rc;
; 666  :     int             i;
; 667  :     char            pathname[MAX_PATH];
; 668  : 
; 669  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00023	48 8d 44 24 60	 lea	 rax, QWORD PTR pgm$[rsp]
  00028	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159608
  00034	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159609
  0003b	48 8b 94 24 b8
	04 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00043	8b 8c 24 b0 04
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00050	89 84 24 b0 04
	00 00		 mov	 DWORD PTR argc$[rsp], eax
$LN2@main:

; 670  : 
; 671  :     /*
; 672  :     || Process option switches
; 673  :     */
; 674  :     while( TRUE )

  00057	33 c0		 xor	 eax, eax
  00059	83 f8 01	 cmp	 eax, 1
  0005c	0f 84 cf 00 00
	00		 je	 $LN3@main

; 675  :     {
; 676  :         rc = getopt( argc, argv, "abhnsu" );

  00062	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159610
  00069	48 8b 94 24 b8
	04 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00071	8b 8c 24 b0 04
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getopt
  0007e	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 677  :         if( rc == -1 )

  00082	83 7c 24 50 ff	 cmp	 DWORD PTR rc$[rsp], -1
  00087	75 05		 jne	 SHORT $LN12@main

; 678  :         {
; 679  :             break;

  00089	e9 a3 00 00 00	 jmp	 $LN3@main
$LN12@main:

; 680  :         }
; 681  : 
; 682  :         switch( rc )

  0008e	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00092	89 44 24 58	 mov	 DWORD PTR tv76[rsp], eax
  00096	83 7c 24 58 61	 cmp	 DWORD PTR tv76[rsp], 97	; 00000061H
  0009b	74 1e		 je	 SHORT $LN13@main
  0009d	83 7c 24 58 68	 cmp	 DWORD PTR tv76[rsp], 104 ; 00000068H
  000a2	74 29		 je	 SHORT $LN14@main
  000a4	83 7c 24 58 6e	 cmp	 DWORD PTR tv76[rsp], 110 ; 0000006eH
  000a9	74 36		 je	 SHORT $LN15@main
  000ab	83 7c 24 58 73	 cmp	 DWORD PTR tv76[rsp], 115 ; 00000073H
  000b0	74 42		 je	 SHORT $LN16@main
  000b2	83 7c 24 58 75	 cmp	 DWORD PTR tv76[rsp], 117 ; 00000075H
  000b7	74 4d		 je	 SHORT $LN17@main
  000b9	eb 5d		 jmp	 SHORT $LN18@main
$LN13@main:

; 683  :         {
; 684  :             case 'a':
; 685  :                 opts.flags |= O_ASCII;

  000bb	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  000c2	83 c8 40	 or	 eax, 64			; 00000040H
  000c5	88 05 30 00 00
	00		 mov	 BYTE PTR opts+48, al

; 686  :             break;

  000cb	eb 5f		 jmp	 SHORT $LN4@main
$LN14@main:

; 687  : 
; 688  :             case 'h':
; 689  :                 usage( pgm );

  000cd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pgm$[rsp]
  000d2	e8 00 00 00 00	 call	 usage

; 690  :                 return 1;

  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	e9 10 08 00 00	 jmp	 $LN1@main
$LN15@main:

; 691  : 
; 692  :             case 'n':
; 693  :                 opts.flags |= O_NL;

  000e1	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  000e8	0f ba e8 07	 bts	 eax, 7
  000ec	88 05 30 00 00
	00		 mov	 BYTE PTR opts+48, al

; 694  :             break;

  000f2	eb 38		 jmp	 SHORT $LN4@main
$LN16@main:

; 695  : 
; 696  :             case 's':
; 697  :                 opts.flags |= O_STRIP;

  000f4	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  000fb	83 c8 20	 or	 eax, 32			; 00000020H
  000fe	88 05 30 00 00
	00		 mov	 BYTE PTR opts+48, al

; 698  :             break;

  00104	eb 26		 jmp	 SHORT $LN4@main
$LN17@main:

; 699  : 
; 700  :             case 'u':
; 701  :                 opts.flags |= O_UNBLOCK;

  00106	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  0010d	83 c8 10	 or	 eax, 16
  00110	88 05 30 00 00
	00		 mov	 BYTE PTR opts+48, al

; 702  :             break;

  00116	eb 14		 jmp	 SHORT $LN4@main
$LN18@main:

; 703  : 
; 704  :             default:
; 705  :                 usage( pgm );

  00118	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pgm$[rsp]
  0011d	e8 00 00 00 00	 call	 usage

; 706  :                 return 1;

  00122	b8 01 00 00 00	 mov	 eax, 1
  00127	e9 c5 07 00 00	 jmp	 $LN1@main
$LN4@main:

; 707  :         }
; 708  :     }

  0012c	e9 26 ff ff ff	 jmp	 $LN2@main
$LN3@main:

; 709  : 
; 710  :     /*
; 711  :     || Calc number of non-switch arguments
; 712  :     */
; 713  :     argc -= optind;

  00131	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00138	8b 00		 mov	 eax, DWORD PTR [rax]
  0013a	8b 8c 24 b0 04
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00141	2b c8		 sub	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	89 84 24 b0 04
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 714  : 
; 715  :     /*
; 716  :     || We must have at least the first 3 parms
; 717  :     */
; 718  :     if(argc < 3)

  0014c	83 bc 24 b0 04
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  00154	7d 66		 jge	 SHORT $LN19@main

; 719  :     {
; 720  :         if ( argc > 1 )

  00156	83 bc 24 b0 04
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0015e	7e 47		 jle	 SHORT $LN20@main

; 721  :             // "Invalid number of arguments"
; 722  :             FWRMSG( stderr, HHC02446, "E" );

  00160	b9 02 00 00 00	 mov	 ecx, 2
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159620
  00172	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159621
  0017e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159622
  00195	ba d2 02 00 00	 mov	 edx, 722		; 000002d2H
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159623
  001a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@main:

; 723  :         usage( pgm );

  001a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pgm$[rsp]
  001ac	e8 00 00 00 00	 call	 usage

; 724  :         exit( 1 );

  001b1	b9 01 00 00 00	 mov	 ecx, 1
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN19@main:

; 725  :     }
; 726  : 
; 727  :     hostpath( pathname, argv[ optind ], sizeof(pathname) );

  001bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  001c3	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  001c6	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  001cc	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001d4	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  001d8	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  001e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 728  :     opts.ifile = strdup( pathname );

  001e6	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  001f4	48 89 05 00 00
	00 00		 mov	 QWORD PTR opts, rax

; 729  :     if ( ( rc = (int)strlen( opts.ifile ) ) > 4
; 730  :       && ( rc = strcasecmp( &opts.ifile[rc-4], ".fkt" ) ) == 0 )

  001fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR opts
  00202	e8 00 00 00 00	 call	 strlen
  00207	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0020b	83 7c 24 50 04	 cmp	 DWORD PTR rc$[rsp], 4
  00210	7e 3b		 jle	 SHORT $LN21@main
  00212	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00216	83 e8 04	 sub	 eax, 4
  00219	48 98		 cdqe
  0021b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR opts
  00222	48 03 c8	 add	 rcx, rax
  00225	48 8b c1	 mov	 rax, rcx
  00228	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159625
  0022f	48 8b c8	 mov	 rcx, rax
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00238	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0023c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00241	75 0a		 jne	 SHORT $LN21@main

; 731  :     {
; 732  :         opts.faketape = TRUE;

  00243	c7 05 20 00 00
	00 01 00 00 00	 mov	 DWORD PTR opts+32, 1
$LN21@main:

; 733  :     }
; 734  : 
; 735  : 
; 736  :     hostpath( pathname, argv[ optind + 1 ], sizeof(pathname) );

  0024d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00254	8b 00		 mov	 eax, DWORD PTR [rax]
  00256	ff c0		 inc	 eax
  00258	48 98		 cdqe
  0025a	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00260	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00268	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0026c	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 737  :     opts.ofile = strdup( pathname );

  0027a	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00288	48 89 05 08 00
	00 00		 mov	 QWORD PTR opts+8, rax

; 738  : 
; 739  :     opts.fileno = atoi( argv[ optind + 2 ] );

  0028f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00296	8b 00		 mov	 eax, DWORD PTR [rax]
  00298	83 c0 02	 add	 eax, 2
  0029b	48 98		 cdqe
  0029d	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002a5	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  002af	89 05 24 00 00
	00		 mov	 DWORD PTR opts+36, eax

; 740  : 
; 741  :     if( opts.fileno == 0 || opts.fileno > 9999 )

  002b5	83 3d 24 00 00
	00 00		 cmp	 DWORD PTR opts+36, 0
  002bc	74 10		 je	 SHORT $LN23@main
  002be	81 3d 24 00 00
	00 0f 27 00 00	 cmp	 DWORD PTR opts+36, 9999	; 0000270fH
  002c8	0f 8e 8c 00 00
	00		 jle	 $LN22@main
$LN23@main:

; 742  :     {
; 743  :         char msgbuf[20];
; 744  :         MSGBUF( msgbuf, "%d", opts.fileno );

  002ce	44 8b 0d 24 00
	00 00		 mov	 r9d, DWORD PTR opts+36
  002d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159628
  002dc	ba 14 00 00 00	 mov	 edx, 20
  002e1	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 745  :         // "Invalid argument %s%s"
; 746  :         FWRMSG( stderr, HHC02205, "S", msgbuf, "; file number must be within the range of 1 to 9999" );

  002ef	b9 02 00 00 00	 mov	 ecx, 2
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159629
  00301	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00306	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  0030e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00313	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159630
  0031a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0031f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159631
  00326	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00330	41 b9 03 00 00
	00		 mov	 r9d, 3
  00336	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159632
  0033d	ba ea 02 00 00	 mov	 edx, 746		; 000002eaH
  00342	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159633
  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 747  :         exit( 1 );

  0034f	b9 01 00 00 00	 mov	 ecx, 1
  00354	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN22@main:

; 748  :     }
; 749  : 
; 750  :     /*
; 751  :     || If NL tape, then we require the DCB attributes
; 752  :     */
; 753  :     if( opts.flags & O_NL )

  0035a	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  00361	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00366	85 c0		 test	 eax, eax
  00368	74 5c		 je	 SHORT $LN24@main

; 754  :     {
; 755  :         if( argc != 6 )

  0036a	83 bc 24 b0 04
	00 00 06	 cmp	 DWORD PTR argc$[rsp], 6
  00372	74 52		 je	 SHORT $LN25@main

; 756  :         {
; 757  :             // "DCB attributes required for NL tape"
; 758  :             FWRMSG( stderr, HHC02750, "S" );

  00374	b9 02 00 00 00	 mov	 ecx, 2
  00379	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0037f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159636
  00386	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0038b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159637
  00392	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00397	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0039c	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159638
  003a9	ba f6 02 00 00	 mov	 edx, 758		; 000002f6H
  003ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159639
  003b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 759  :             exit( 1 );

  003bb	b9 01 00 00 00	 mov	 ecx, 1
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN25@main:
$LN24@main:

; 760  :         }
; 761  :     }
; 762  : 
; 763  :     /*
; 764  :     || If specified, get the DCB attributes
; 765  :     */
; 766  :     if( argc > 3 )

  003c6	83 bc 24 b0 04
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  003ce	0f 8e 51 03 00
	00		 jle	 $LN26@main

; 767  :     {
; 768  :         /*
; 769  :         || Must have only three
; 770  :         */
; 771  :         if( argc != 6 )

  003d4	83 bc 24 b0 04
	00 00 06	 cmp	 DWORD PTR argc$[rsp], 6
  003dc	74 15		 je	 SHORT $LN27@main

; 772  :         {
; 773  :             usage( pgm );

  003de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pgm$[rsp]
  003e3	e8 00 00 00 00	 call	 usage

; 774  :             exit( 1 );

  003e8	b9 01 00 00 00	 mov	 ecx, 1
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN27@main:

; 775  :         }
; 776  : 
; 777  :         /*
; 778  :         || Lookup the specified RECFM in our table
; 779  :         */
; 780  :         opts.recfm = 0;

  003f3	c6 05 31 00 00
	00 00		 mov	 BYTE PTR opts+49, 0

; 781  :         for( i = 0 ; i < (int)VALFMCNT ; i++ )

  003fa	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00402	eb 0a		 jmp	 SHORT $LN8@main
$LN6@main:
  00404	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00408	ff c0		 inc	 eax
  0040a	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN8@main:
  0040e	83 7c 24 54 1b	 cmp	 DWORD PTR i$[rsp], 27
  00413	7d 62		 jge	 SHORT $LN7@main

; 782  :         {
; 783  :             if( strcasecmp( argv[ optind + 3 ], valfm[ i ].recfm ) == 0 )

  00415	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0041a	48 6b c0 10	 imul	 rax, rax, 16
  0041e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  00425	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_optind
  0042c	8b 12		 mov	 edx, DWORD PTR [rdx]
  0042e	83 c2 03	 add	 edx, 3
  00431	48 63 d2	 movsxd	 rdx, edx
  00434	48 89 54 24 78	 mov	 QWORD PTR tv222[rsp], rdx
  00439	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0043d	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00445	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv222[rsp]
  0044a	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00454	85 c0		 test	 eax, eax
  00456	75 1d		 jne	 SHORT $LN28@main

; 784  :             {
; 785  :                 opts.recfm = valfm[ i ].fmt;

  00458	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0045d	48 6b c0 10	 imul	 rax, rax, 16
  00461	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  00468	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  0046d	88 05 31 00 00
	00		 mov	 BYTE PTR opts+49, al

; 786  :                 break;

  00473	eb 02		 jmp	 SHORT $LN7@main
$LN28@main:

; 787  :             }
; 788  :         }

  00475	eb 8d		 jmp	 SHORT $LN6@main
$LN7@main:

; 789  : 
; 790  :         /*
; 791  :         || If we didn't find a match, show the user what the valid ones are
; 792  :         */
; 793  :         if( opts.recfm == 0)

  00477	0f b6 05 31 00
	00 00		 movzx	 eax, BYTE PTR opts+49
  0047e	85 c0		 test	 eax, eax
  00480	0f 85 e0 01 00
	00		 jne	 $LN29@main

; 794  :         {
; 795  :             char msgbuf[512] = "";

  00486	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG159644
  0048d	88 84 24 90 02
	00 00		 mov	 BYTE PTR msgbuf$6[rsp], al
  00494	48 8d 84 24 91
	02 00 00	 lea	 rax, QWORD PTR msgbuf$6[rsp+1]
  0049c	48 8b f8	 mov	 rdi, rax
  0049f	33 c0		 xor	 eax, eax
  004a1	b9 ff 01 00 00	 mov	 ecx, 511		; 000001ffH
  004a6	f3 aa		 rep stosb

; 796  :             char msgbuf2[64] = "";

  004a8	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG159645
  004af	88 84 24 c0 00
	00 00		 mov	 BYTE PTR msgbuf2$4[rsp], al
  004b6	48 8d 84 24 c1
	00 00 00	 lea	 rax, QWORD PTR msgbuf2$4[rsp+1]
  004be	48 8b f8	 mov	 rdi, rax
  004c1	33 c0		 xor	 eax, eax
  004c3	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  004c8	f3 aa		 rep stosb

; 797  :             char msgbuf3[16] = "";

  004ca	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG159646
  004d1	88 84 24 90 00
	00 00		 mov	 BYTE PTR msgbuf3$2[rsp], al
  004d8	48 8d 84 24 91
	00 00 00	 lea	 rax, QWORD PTR msgbuf3$2[rsp+1]
  004e0	48 8b f8	 mov	 rdi, rax
  004e3	33 c0		 xor	 eax, eax
  004e5	b9 0f 00 00 00	 mov	 ecx, 15
  004ea	f3 aa		 rep stosb

; 798  :             char msgbuf4[128] = "";

  004ec	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG159647
  004f3	88 84 24 00 01
	00 00		 mov	 BYTE PTR msgbuf4$5[rsp], al
  004fa	48 8d 84 24 01
	01 00 00	 lea	 rax, QWORD PTR msgbuf4$5[rsp+1]
  00502	48 8b f8	 mov	 rdi, rax
  00505	33 c0		 xor	 eax, eax
  00507	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0050c	f3 aa		 rep stosb

; 799  : 
; 800  :             /*
; 801  :             || Dump out the valid RECFMs
; 802  :             */
; 803  :             // "Valid record formats are:"
; 804  :             MSGBUF( msgbuf, MSG( HHC02751, "I" ) );

  0050e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159648
  00515	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159649
  0051c	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00521	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$6[rsp]
  00529	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 805  :             for( i = 0 ; i < (int)VALFMCNT ; i++ )

  0052f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00537	eb 0a		 jmp	 SHORT $LN11@main
$LN9@main:
  00539	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0053d	ff c0		 inc	 eax
  0053f	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN11@main:
  00543	83 7c 24 54 1b	 cmp	 DWORD PTR i$[rsp], 27
  00548	0f 8d f9 00 00
	00		 jge	 $LN10@main

; 806  :             {
; 807  :                 MSGBUF( msgbuf3, "  %-4.4s", valfm[ i ].recfm );

  0054e	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  00553	48 6b c0 10	 imul	 rax, rax, 16
  00557	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  0055e	4c 8b 0c 01	 mov	 r9, QWORD PTR [rcx+rax]
  00562	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159650
  00569	ba 10 00 00 00	 mov	 edx, 16
  0056e	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR msgbuf3$2[rsp]
  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 808  : 
; 809  :                 if( ( ( i + 1 ) % 3 ) == 0 )

  0057c	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00580	ff c0		 inc	 eax
  00582	99		 cdq
  00583	b9 03 00 00 00	 mov	 ecx, 3
  00588	f7 f9		 idiv	 ecx
  0058a	8b c2		 mov	 eax, edx
  0058c	85 c0		 test	 eax, eax
  0058e	0f 85 92 00 00
	00		 jne	 $LN30@main

; 810  :                 {
; 811  :                     STRLCAT( msgbuf2, msgbuf3 );

  00594	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0059a	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR msgbuf3$2[rsp]
  005a2	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf2$4[rsp]
  005aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 812  :                     // "%s"
; 813  :                     MSGBUF( msgbuf4, MSG( HHC02752, "I", msgbuf2 ) );

  005b0	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR msgbuf2$4[rsp]
  005b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005bd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159653
  005c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159654
  005cb	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  005d0	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR msgbuf4$5[rsp]
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 814  :                     STRLCAT( msgbuf, msgbuf4 );

  005de	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  005e4	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR msgbuf4$5[rsp]
  005ec	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$6[rsp]
  005f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 815  :                     msgbuf2[0] = 0;

  005fa	b8 01 00 00 00	 mov	 eax, 1
  005ff	48 6b c0 00	 imul	 rax, rax, 0
  00603	48 89 44 24 70	 mov	 QWORD PTR $T1[rsp], rax
  00608	48 83 7c 24 70
	40		 cmp	 QWORD PTR $T1[rsp], 64	; 00000040H
  0060e	73 02		 jae	 SHORT $LN44@main
  00610	eb 05		 jmp	 SHORT $LN45@main
$LN44@main:
  00612	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN45@main:
  00617	48 8b 44 24 70	 mov	 rax, QWORD PTR $T1[rsp]
  0061c	c6 84 04 c0 00
	00 00 00	 mov	 BYTE PTR msgbuf2$4[rsp+rax], 0

; 816  :                 }

  00624	eb 1c		 jmp	 SHORT $LN31@main
$LN30@main:

; 817  :                 else
; 818  :                 {
; 819  :                     STRLCAT( msgbuf2, msgbuf3 );

  00626	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0062c	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR msgbuf3$2[rsp]
  00634	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf2$4[rsp]
  0063c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN31@main:

; 820  :                 }
; 821  :             }

  00642	e9 f2 fe ff ff	 jmp	 $LN9@main
$LN10@main:

; 822  :             printf( "%s", msgbuf );

  00647	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR msgbuf$6[rsp]
  0064f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159655
  00656	e8 00 00 00 00	 call	 printf

; 823  :             exit( 1 );

  0065b	b9 01 00 00 00	 mov	 ecx, 1
  00660	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN29@main:

; 824  :         }
; 825  : 
; 826  :         /*
; 827  :         || Get the record length
; 828  :         */
; 829  :         opts.lrecl = atoi( argv[ optind + 4 ] );

  00666	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  0066d	8b 00		 mov	 eax, DWORD PTR [rax]
  0066f	83 c0 04	 add	 eax, 4
  00672	48 98		 cdqe
  00674	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0067c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00680	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00686	89 05 28 00 00
	00		 mov	 DWORD PTR opts+40, eax

; 830  : 
; 831  :         /*
; 832  :         || Get and validate the blksize
; 833  :         */
; 834  :         opts.blksize = atoi( argv[ optind + 5 ] );

  0068c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00693	8b 00		 mov	 eax, DWORD PTR [rax]
  00695	83 c0 05	 add	 eax, 5
  00698	48 98		 cdqe
  0069a	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006a2	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  006a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  006ac	89 05 2c 00 00
	00		 mov	 DWORD PTR opts+44, eax

; 835  :         if( opts.blksize == 0 )

  006b2	83 3d 2c 00 00
	00 00		 cmp	 DWORD PTR opts+44, 0
  006b9	75 6a		 jne	 SHORT $LN32@main

; 836  :         {
; 837  :             // "Invalid argument %s%s"
; 838  :             FWRMSG( stderr, HHC02205, "S", "0", "; block size can't be zero" );

  006bb	b9 02 00 00 00	 mov	 ecx, 2
  006c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159657
  006cd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159658
  006d9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159659
  006e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159660
  006f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00701	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159661
  00708	ba 46 03 00 00	 mov	 edx, 838		; 00000346H
  0070d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159662
  00714	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 839  :             exit( 1 );

  0071a	b9 01 00 00 00	 mov	 ecx, 1
  0071f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN32@main:
$LN26@main:

; 840  :         }
; 841  :     }
; 842  : 
; 843  :     /*
; 844  :     || Open the tape file
; 845  :     */
; 846  :     if ( opts.faketape )

  00725	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  0072c	74 20		 je	 SHORT $LN33@main

; 847  :         rc = fet_open( &opts.fetb, opts.ifile, FETOPEN_READONLY );

  0072e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00734	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR opts
  0073b	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:opts+24
  00742	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_open
  00748	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0074c	eb 1e		 jmp	 SHORT $LN34@main
$LN33@main:

; 848  :     else
; 849  :         rc = het_open( &opts.hetb, opts.ifile, HETOPEN_READONLY );

  0074e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00754	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR opts
  0075b	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:opts+16
  00762	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_open
  00768	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN34@main:

; 850  :     if( rc >= 0 )

  0076c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00771	7c 68		 jl	 SHORT $LN35@main

; 851  :     {
; 852  :         /*
; 853  :         || Get memory for the tape buffer
; 854  :         */
; 855  :         blkptr = malloc( HETMAX_BLOCKSIZE );

  00773	b9 00 00 20 00	 mov	 ecx, 2097152		; 00200000H
  00778	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0077e	48 89 05 00 00
	00 00		 mov	 QWORD PTR blkptr, rax

; 856  :         if( blkptr != NULL )

  00785	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR blkptr, 0
  0078d	74 47		 je	 SHORT $LN37@main

; 857  :         {
; 858  :             /*
; 859  :             || Open the output file
; 860  :             */
; 861  :             outf = fopen( opts.ofile, "wb" );

  0078f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159668
  00796	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR opts+8
  0079d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  007a3	48 89 44 24 68	 mov	 QWORD PTR outf$[rsp], rax

; 862  :             if( outf != NULL )

  007a8	48 83 7c 24 68
	00		 cmp	 QWORD PTR outf$[rsp], 0
  007ae	74 19		 je	 SHORT $LN38@main

; 863  :             {
; 864  :                 /*
; 865  :                 || Go extract the file from the tape
; 866  :                 */
; 867  :                 rc = getfile( outf );

  007b0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR outf$[rsp]
  007b5	e8 00 00 00 00	 call	 getfile
  007ba	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 868  : 
; 869  :                 /*
; 870  :                 || Close the output file
; 871  :                 */
; 872  :                 fclose( outf );

  007be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR outf$[rsp]
  007c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
$LN38@main:

; 873  :             }
; 874  : 
; 875  :             /*
; 876  :             || Free the buffer memory
; 877  :             */
; 878  :             free( blkptr );

  007c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR blkptr
  007d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN37@main:

; 879  :         }
; 880  :     }

  007d6	e9 ef 00 00 00	 jmp	 $LN36@main
$LN35@main:

; 881  :     else
; 882  :     {
; 883  :         // "Error in function %s: %s"
; 884  :         if ( opts.faketape )

  007db	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  007e2	74 74		 je	 SHORT $LN39@main

; 885  :             FWRMSG( stderr, HHC00075, "E", "fet_open()", fet_error( rc ) );

  007e4	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  007e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_error
  007ee	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv396[rsp], rax
  007f6	b9 02 00 00 00	 mov	 ecx, 2
  007fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00801	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv396[rsp]
  00809	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0080e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159672
  00815	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0081a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159673
  00821	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00826	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159674
  0082d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00832	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00837	41 b9 03 00 00
	00		 mov	 r9d, 3
  0083d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159675
  00844	ba 75 03 00 00	 mov	 edx, 885		; 00000375H
  00849	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159676
  00850	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00856	eb 72		 jmp	 SHORT $LN40@main
$LN39@main:

; 886  :         else
; 887  :             FWRMSG( stderr, HHC00075, "E", "het_open()", het_error( rc ) );

  00858	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  0085c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  00862	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv409[rsp], rax
  0086a	b9 02 00 00 00	 mov	 ecx, 2
  0086f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00875	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv409[rsp]
  0087d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00882	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159677
  00889	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0088e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159678
  00895	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0089a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159679
  008a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159680
  008b8	ba 77 03 00 00	 mov	 edx, 887		; 00000377H
  008bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159681
  008c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN40@main:
$LN36@main:

; 888  :     }
; 889  : 
; 890  :     /*
; 891  :     || Close the tape file
; 892  :     */
; 893  :     if ( opts.faketape )

  008ca	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  008d1	74 0f		 je	 SHORT $LN41@main

; 894  :         fet_close( &opts.fetb );

  008d3	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:opts+24
  008da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_close
  008e0	eb 0d		 jmp	 SHORT $LN42@main
$LN41@main:

; 895  :     else
; 896  :         het_close( &opts.hetb );

  008e2	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:opts+16
  008e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_close
$LN42@main:

; 897  : 
; 898  :     return 0;

  008ef	33 c0		 xor	 eax, eax
$LN1@main:
$LN43@main:

; 899  : }

  008f1	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  008f9	48 33 cc	 xor	 rcx, rsp
  008fc	e8 00 00 00 00	 call	 __security_check_cookie
  00901	48 81 c4 a0 04
	00 00		 add	 rsp, 1184		; 000004a0H
  00908	5f		 pop	 rdi
  00909	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
pgm$ = 80
usage	PROC

; 652  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 653  :     // "Usage: %s ...
; 654  :     WRMSG( HHC02728, "I", pgm );

  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pgm$[rsp]
  00019	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159571
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159572
  00031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00036	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159573
  00048	ba 8e 02 00 00	 mov	 edx, 654		; 0000028eH
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159574
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 655  : }

  0005a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005e	c3		 ret	 0
usage	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
rc$ = 80
fileno$ = 84
ptr$ = 88
curpos$1 = 96
curpos$2 = 104
tv78 = 112
tv158 = 120
tv75 = 128
tv155 = 136
tv263 = 144
tv276 = 152
lab$ = 160
fmt$ = 240
msgbuf$3 = 560
msgbuf$4 = 688
__$ArrayPad$ = 816
outf$ = 848
getfile	PROC

; 408  : {

$LN58:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 48 03
	00 00		 sub	 rsp, 840		; 00000348H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 409  :     SLFMT fmt;
; 410  :     SLLABEL lab;
; 411  :     unsigned char *ptr;
; 412  :     int fileno;
; 413  :     int rc;
; 414  : 
; 415  :     /*
; 416  :     || Skip to the desired file
; 417  :     */
; 418  :     if( opts.flags & O_NL )

  0001e	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  00025	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 29 01 00
	00		 je	 $LN18@getfile

; 419  :     {
; 420  :         /*
; 421  :         || For NL tapes, just use the specified file number
; 422  :         */
; 423  :         fileno = opts.fileno;

  00032	8b 05 24 00 00
	00		 mov	 eax, DWORD PTR opts+36
  00038	89 44 24 54	 mov	 DWORD PTR fileno$[rsp], eax
$LN2@getfile:

; 424  : 
; 425  :         /*
; 426  :         || Start skipping
; 427  :         */
; 428  :         while( --fileno )

  0003c	8b 44 24 54	 mov	 eax, DWORD PTR fileno$[rsp]
  00040	ff c8		 dec	 eax
  00042	89 44 24 54	 mov	 DWORD PTR fileno$[rsp], eax
  00046	83 7c 24 54 00	 cmp	 DWORD PTR fileno$[rsp], 0
  0004b	0f 84 05 01 00
	00		 je	 $LN3@getfile

; 429  :         {
; 430  :             /*
; 431  :             || Forward space to beginning of next file
; 432  :             */
; 433  :             if ( opts.faketape )

  00051	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  00058	74 13		 je	 SHORT $LN20@getfile

; 434  :                 rc = fet_fsf ( opts.fetb );

  0005a	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR opts+24
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_fsf
  00067	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0006b	eb 11		 jmp	 SHORT $LN21@getfile
$LN20@getfile:

; 435  :             else
; 436  :                 rc = het_fsf( opts.hetb );

  0006d	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR opts+16
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_fsf
  0007a	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN21@getfile:

; 437  :             if( rc < 0 )

  0007e	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00083	0f 8d c8 00 00
	00		 jge	 $LN22@getfile

; 438  :             {
; 439  :                 char msgbuf[128];
; 440  :                 MSGBUF( msgbuf, "%set_fsf() while positioning to file '%d'",

  00089	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  00090	74 0e		 je	 SHORT $LN54@getfile
  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159491
  00099	48 89 44 24 70	 mov	 QWORD PTR tv78[rsp], rax
  0009e	eb 0c		 jmp	 SHORT $LN55@getfile
$LN54@getfile:
  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159492
  000a7	48 89 44 24 70	 mov	 QWORD PTR tv78[rsp], rax
$LN55@getfile:
  000ac	8b 05 24 00 00
	00		 mov	 eax, DWORD PTR opts+36
  000b2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b6	4c 8b 4c 24 70	 mov	 r9, QWORD PTR tv78[rsp]
  000bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159493
  000c2	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  000c7	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 441  :                     opts.faketape ? "f" : "h",
; 442  :                     opts.fileno );
; 443  :                 // "Error in function %s: %s"
; 444  :                 FWRMSG( stderr, HHC00075, "E", msgbuf, het_error( rc ) );

  000d5	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  000df	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  000e7	b9 02 00 00 00	 mov	 ecx, 2
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  000fa	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ff	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  00107	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159494
  00113	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159495
  0011f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00124	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00129	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159496
  00136	ba bc 01 00 00	 mov	 edx, 444		; 000001bcH
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159497
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 445  :                 return( rc );

  00148	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  0014c	e9 1c 07 00 00	 jmp	 $LN1@getfile
$LN22@getfile:

; 446  :             }
; 447  :         }

  00151	e9 e6 fe ff ff	 jmp	 $LN2@getfile
$LN3@getfile:

; 448  :     }

  00156	e9 85 04 00 00	 jmp	 $LN19@getfile
$LN18@getfile:

; 449  :     else
; 450  :     {
; 451  :         /*
; 452  :         || First block should be a VOL1 record
; 453  :         */
; 454  :         rc = get_sl( &lab );

  0015b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR lab$[rsp]
  00163	e8 00 00 00 00	 call	 get_sl
  00168	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 455  :         if( rc < 0 || !sl_isvol( &lab, 1 ) )

  0016c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00171	7c 1d		 jl	 SHORT $LN24@getfile
  00173	41 b8 01 00 00
	00		 mov	 r8d, 1
  00179	ba 01 00 00 00	 mov	 edx, 1
  0017e	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR lab$[rsp]
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sl_istype
  0018c	85 c0		 test	 eax, eax
  0018e	75 5d		 jne	 SHORT $LN23@getfile
$LN24@getfile:

; 456  :         {
; 457  :             // "%s label missing"
; 458  :             FWRMSG( stderr, HHC02753, "E", "VOL1" );

  00190	b9 02 00 00 00	 mov	 ecx, 2
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159500
  001a2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159501
  001ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159502
  001ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159503
  001d1	ba ca 01 00 00	 mov	 edx, 458		; 000001caH
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159504
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 459  :             return( -1 );

  001e3	b8 ff ff ff ff	 mov	 eax, -1
  001e8	e9 80 06 00 00	 jmp	 $LN1@getfile
$LN23@getfile:

; 460  :         }
; 461  : 
; 462  :         /*
; 463  :         || For SL, adjust the file # so we end up on the label before the data
; 464  :         */
; 465  :         fileno = ( opts.fileno * 3 ) - 2;

  001ed	6b 05 24 00 00
	00 03		 imul	 eax, DWORD PTR opts+36, 3
  001f4	83 e8 02	 sub	 eax, 2
  001f7	89 44 24 54	 mov	 DWORD PTR fileno$[rsp], eax
$LN4@getfile:

; 466  : 
; 467  :         /*
; 468  :         || Start skipping
; 469  :         */
; 470  :         while( --fileno )

  001fb	8b 44 24 54	 mov	 eax, DWORD PTR fileno$[rsp]
  001ff	ff c8		 dec	 eax
  00201	89 44 24 54	 mov	 DWORD PTR fileno$[rsp], eax
  00205	83 7c 24 54 00	 cmp	 DWORD PTR fileno$[rsp], 0
  0020a	0f 84 05 01 00
	00		 je	 $LN5@getfile

; 471  :         {
; 472  :             /*
; 473  :             || Forward space to beginning of next file
; 474  :             */
; 475  :             if ( opts.faketape )

  00210	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  00217	74 13		 je	 SHORT $LN25@getfile

; 476  :                 rc = fet_fsf ( opts.fetb );

  00219	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR opts+24
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_fsf
  00226	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0022a	eb 11		 jmp	 SHORT $LN26@getfile
$LN25@getfile:

; 477  :             else
; 478  :                 rc = het_fsf( opts.hetb );

  0022c	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR opts+16
  00233	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_fsf
  00239	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN26@getfile:

; 479  :             if( rc < 0 )

  0023d	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00242	0f 8d c8 00 00
	00		 jge	 $LN27@getfile

; 480  :             {
; 481  :                 char msgbuf[128];
; 482  :                 MSGBUF( msgbuf, "%set_fsf() while positioning to file '%d'",

  00248	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  0024f	74 0e		 je	 SHORT $LN56@getfile
  00251	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159508
  00258	48 89 44 24 78	 mov	 QWORD PTR tv158[rsp], rax
  0025d	eb 0c		 jmp	 SHORT $LN57@getfile
$LN56@getfile:
  0025f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159509
  00266	48 89 44 24 78	 mov	 QWORD PTR tv158[rsp], rax
$LN57@getfile:
  0026b	8b 05 24 00 00
	00		 mov	 eax, DWORD PTR opts+36
  00271	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00275	4c 8b 4c 24 78	 mov	 r9, QWORD PTR tv158[rsp]
  0027a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159510
  00281	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00286	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$4[rsp]
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 483  :                     opts.faketape ? "f" : "h",
; 484  :                     opts.fileno );
; 485  :                 // "Error in function %s: %s"
; 486  :                 FWRMSG( stderr, HHC00075, "E", msgbuf, het_error( rc ) );

  00294	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  0029e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  002a6	b9 02 00 00 00	 mov	 ecx, 2
  002ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv155[rsp]
  002b9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002be	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$4[rsp]
  002c6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159511
  002d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159512
  002de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159513
  002f5	ba e6 01 00 00	 mov	 edx, 486		; 000001e6H
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159514
  00301	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 487  :                 return( rc );

  00307	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  0030b	e9 5d 05 00 00	 jmp	 $LN1@getfile
$LN27@getfile:

; 488  :             }
; 489  :         }

  00310	e9 e6 fe ff ff	 jmp	 $LN4@getfile
$LN5@getfile:

; 490  : 
; 491  :         /*
; 492  :         || Get the HDR1 label.
; 493  :         */
; 494  :         rc = get_sl( &lab );

  00315	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR lab$[rsp]
  0031d	e8 00 00 00 00	 call	 get_sl
  00322	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 495  :         if( rc < 0 || !sl_ishdr( &lab, 1 ) )

  00326	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0032b	7c 1d		 jl	 SHORT $LN29@getfile
  0032d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00333	ba 02 00 00 00	 mov	 edx, 2
  00338	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR lab$[rsp]
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sl_istype
  00346	85 c0		 test	 eax, eax
  00348	75 5d		 jne	 SHORT $LN28@getfile
$LN29@getfile:

; 496  :         {
; 497  :             // "%s label missing"
; 498  :             FWRMSG( stderr, HHC02753, "E", "HDR1" );

  0034a	b9 02 00 00 00	 mov	 ecx, 2
  0034f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159517
  0035c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159518
  00368	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159519
  00374	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00379	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00384	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159520
  0038b	ba f2 01 00 00	 mov	 edx, 498		; 000001f2H
  00390	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159521
  00397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 499  :             return( -1 );

  0039d	b8 ff ff ff ff	 mov	 eax, -1
  003a2	e9 c6 04 00 00	 jmp	 $LN1@getfile
$LN28@getfile:

; 500  :         }
; 501  : 
; 502  :         /*
; 503  :         || Make the label more managable
; 504  :         */
; 505  :         sl_fmtlab( &fmt, &lab );

  003a7	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR lab$[rsp]
  003af	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR fmt$[rsp]
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sl_fmtlab

; 506  :         // "File Info:  DSN=%-17.17s"
; 507  :         WRMSG( HHC02754, "I", fmt.slds1.dsid );

  003bd	b9 01 00 00 00	 mov	 ecx, 1
  003c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c8	48 8d 8c 24 d5
	01 00 00	 lea	 rcx, QWORD PTR fmt$[rsp+229]
  003d0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159522
  003dc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159523
  003e8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f2	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159524
  003ff	ba fb 01 00 00	 mov	 edx, 507		; 000001fbH
  00404	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159525
  0040b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 508  : 
; 509  :         /*
; 510  :         || Get the HDR2 label.
; 511  :         */
; 512  :         rc = get_sl( &lab );

  00411	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR lab$[rsp]
  00419	e8 00 00 00 00	 call	 get_sl
  0041e	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 513  :         if( rc < 0 || !sl_ishdr( &lab, 2 ) )

  00422	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00427	7c 1d		 jl	 SHORT $LN31@getfile
  00429	41 b8 02 00 00
	00		 mov	 r8d, 2
  0042f	ba 02 00 00 00	 mov	 edx, 2
  00434	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR lab$[rsp]
  0043c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sl_istype
  00442	85 c0		 test	 eax, eax
  00444	75 5d		 jne	 SHORT $LN30@getfile
$LN31@getfile:

; 514  :         {
; 515  :             // "%s label missing"
; 516  :             FWRMSG( stderr, HHC02753, "E", "HDR2" );

  00446	b9 02 00 00 00	 mov	 ecx, 2
  0044b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00451	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159528
  00458	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0045d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159529
  00464	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159530
  00470	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00475	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00480	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159531
  00487	ba 04 02 00 00	 mov	 edx, 516		; 00000204H
  0048c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159532
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 517  :             return( -1 );

  00499	b8 ff ff ff ff	 mov	 eax, -1
  0049e	e9 ca 03 00 00	 jmp	 $LN1@getfile
$LN30@getfile:

; 518  :         }
; 519  : 
; 520  :         /*
; 521  :         || Merge the DCB information
; 522  :         */
; 523  :         merge( &lab );

  004a3	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR lab$[rsp]
  004ab	e8 00 00 00 00	 call	 merge

; 524  : 
; 525  :         /*
; 526  :         || Hop over the tapemark
; 527  :         */
; 528  :         if ( opts.faketape )

  004b0	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  004b7	74 13		 je	 SHORT $LN32@getfile

; 529  :             rc = fet_fsf( opts.fetb );

  004b9	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR opts+24
  004c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_fsf
  004c6	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  004ca	eb 11		 jmp	 SHORT $LN33@getfile
$LN32@getfile:

; 530  :         else
; 531  :             rc = het_fsf( opts.hetb );

  004cc	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR opts+16
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_fsf
  004d9	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN33@getfile:

; 532  :         if( rc < 0 )

  004dd	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  004e2	0f 8d f8 00 00
	00		 jge	 $LN34@getfile

; 533  :         {
; 534  :             // "Error in function %s: %s"
; 535  :             if ( opts.faketape )

  004e8	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  004ef	74 74		 je	 SHORT $LN35@getfile

; 536  :                 FWRMSG( stderr, HHC00075, "E", "fet_fsf()", fet_error( rc ) );

  004f1	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_error
  004fb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv263[rsp], rax
  00503	b9 02 00 00 00	 mov	 ecx, 2
  00508	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0050e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv263[rsp]
  00516	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0051b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159538
  00522	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00527	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159539
  0052e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00533	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159540
  0053a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0053f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00544	41 b9 03 00 00
	00		 mov	 r9d, 3
  0054a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159541
  00551	ba 18 02 00 00	 mov	 edx, 536		; 00000218H
  00556	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159542
  0055d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00563	eb 72		 jmp	 SHORT $LN36@getfile
$LN35@getfile:

; 537  :             else
; 538  :                 FWRMSG( stderr, HHC00075, "E", "het_fsf()", het_error( rc ) );

  00565	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  0056f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv276[rsp], rax
  00577	b9 02 00 00 00	 mov	 ecx, 2
  0057c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00582	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv276[rsp]
  0058a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0058f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159543
  00596	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0059b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159544
  005a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159545
  005ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  005be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159546
  005c5	ba 1a 02 00 00	 mov	 edx, 538		; 0000021aH
  005ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159547
  005d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN36@getfile:

; 539  :             return( rc );

  005d7	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  005db	e9 8d 02 00 00	 jmp	 $LN1@getfile
$LN34@getfile:
$LN19@getfile:

; 540  :         }
; 541  :     }
; 542  : 
; 543  :     /*
; 544  :     || Different processing when converting to ASCII
; 545  :     */
; 546  :     if( opts.flags & ( O_ASCII | O_UNBLOCK ) )

  005e0	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  005e7	83 e0 50	 and	 eax, 80			; 00000050H
  005ea	85 c0		 test	 eax, eax
  005ec	0f 84 98 01 00
	00		 je	 $LN37@getfile
$LN6@getfile:

; 547  :     {
; 548  :         /*
; 549  :         || Get a record
; 550  :         */
; 551  :         while( ( rc = getrecord( ) ) >= 0 )

  005f2	e8 00 00 00 00	 call	 getrecord
  005f7	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  005fb	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00600	0f 8c 7f 01 00
	00		 jl	 $LN7@getfile

; 552  :         {
; 553  :             if( extgui )

  00606	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0060d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00610	0f 84 91 00 00
	00		 je	 $LN39@getfile

; 554  :             {
; 555  :                 off_t curpos;
; 556  :                 /* Report progress every nnnK */
; 557  :                 if ( opts.faketape )

  00616	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  0061d	74 17		 je	 SHORT $LN40@getfile

; 558  :                     curpos = ftell( opts.fetb->fh );

  0061f	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR opts+24
  00626	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00629	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  0062f	48 89 44 24 60	 mov	 QWORD PTR curpos$1[rsp], rax
  00634	eb 15		 jmp	 SHORT $LN41@getfile
$LN40@getfile:

; 559  :                 else
; 560  :                     curpos = ftell( opts.hetb->fh );

  00636	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR opts+16
  0063d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00640	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  00646	48 89 44 24 60	 mov	 QWORD PTR curpos$1[rsp], rax
$LN41@getfile:

; 561  :                 if( ( curpos & PROGRESS_MASK ) != ( prevpos & PROGRESS_MASK ) )

  0064b	48 8b 44 24 60	 mov	 rax, QWORD PTR curpos$1[rsp]
  00650	48 25 00 00 fc
	ff		 and	 rax, -262144		; fffffffffffc0000H
  00656	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR prevpos
  0065d	48 81 e1 00 00
	fc ff		 and	 rcx, -262144		; fffffffffffc0000H
  00664	48 3b c1	 cmp	 rax, rcx
  00667	74 3e		 je	 SHORT $LN42@getfile

; 562  :                 {
; 563  :                     prevpos = curpos;

  00669	48 8b 44 24 60	 mov	 rax, QWORD PTR curpos$1[rsp]
  0066e	48 89 05 00 00
	00 00		 mov	 QWORD PTR prevpos, rax
$LN10@getfile:

; 564  :                     EXTGUIMSG( "IPOS=%"PRId64"\n", (U64)curpos );

  00675	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0067c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0067f	74 20		 je	 SHORT $LN43@getfile
  00681	b9 02 00 00 00	 mov	 ecx, 2
  00686	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0068c	4c 8b 44 24 60	 mov	 r8, QWORD PTR curpos$1[rsp]
  00691	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159555
  00698	48 8b c8	 mov	 rcx, rax
  0069b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN43@getfile:
  006a1	33 c0		 xor	 eax, eax
  006a3	85 c0		 test	 eax, eax
  006a5	75 ce		 jne	 SHORT $LN10@getfile
$LN42@getfile:
$LN39@getfile:

; 565  :                 }
; 566  :             }
; 567  : 
; 568  :             /*
; 569  :             || Get working copy of record ptr
; 570  :             */
; 571  :             ptr = recptr;

  006a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR recptr
  006ae	48 89 44 24 58	 mov	 QWORD PTR ptr$[rsp], rax

; 572  : 
; 573  :             /*
; 574  :             || Only want data portion for RECFM=V records
; 575  :             */
; 576  :             if( opts.recfm & O_VARIABLE )

  006b3	0f b6 05 31 00
	00 00		 movzx	 eax, BYTE PTR opts+49
  006ba	83 e0 20	 and	 eax, 32			; 00000020H
  006bd	85 c0		 test	 eax, eax
  006bf	74 19		 je	 SHORT $LN44@getfile

; 577  :             {
; 578  :                 ptr += 4;

  006c1	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  006c6	48 83 c0 04	 add	 rax, 4
  006ca	48 89 44 24 58	 mov	 QWORD PTR ptr$[rsp], rax

; 579  :                 rc -= 4;

  006cf	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  006d3	83 e8 04	 sub	 eax, 4
  006d6	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN44@getfile:

; 580  :             }
; 581  : 
; 582  :             /*
; 583  :             || Convert record to ASCII
; 584  :             */
; 585  :             if( opts.flags & O_ASCII )

  006da	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  006e1	83 e0 40	 and	 eax, 64			; 00000040H
  006e4	85 c0		 test	 eax, eax
  006e6	74 12		 je	 SHORT $LN45@getfile

; 586  :             {
; 587  :                 sl_etoa( NULL, ptr, rc );

  006e8	44 8b 44 24 50	 mov	 r8d, DWORD PTR rc$[rsp]
  006ed	48 8b 54 24 58	 mov	 rdx, QWORD PTR ptr$[rsp]
  006f2	33 c9		 xor	 ecx, ecx
  006f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sl_etoa
$LN45@getfile:

; 588  :             }
; 589  : 
; 590  :             /*
; 591  :             || Strip trailing blanks
; 592  :             */
; 593  :             if( opts.flags & O_STRIP )

  006fa	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  00701	83 e0 20	 and	 eax, 32			; 00000020H
  00704	85 c0		 test	 eax, eax
  00706	74 29		 je	 SHORT $LN46@getfile
$LN11@getfile:

; 594  :             {
; 595  :                 while( rc > 0 && ptr[ rc - 1 ] == ' ' )

  00708	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0070d	7e 22		 jle	 SHORT $LN12@getfile
  0070f	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00713	ff c8		 dec	 eax
  00715	48 98		 cdqe
  00717	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ptr$[rsp]
  0071c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00720	83 f8 20	 cmp	 eax, 32			; 00000020H
  00723	75 0c		 jne	 SHORT $LN12@getfile

; 596  :                 {
; 597  :                     rc--;

  00725	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00729	ff c8		 dec	 eax
  0072b	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 598  :                 }

  0072f	eb d7		 jmp	 SHORT $LN11@getfile
$LN12@getfile:
$LN46@getfile:

; 599  :             }
; 600  : 
; 601  :             /*
; 602  :             || Write the record out
; 603  :             */
; 604  :             fwrite( ptr, rc, 1, outf );

  00731	48 63 44 24 50	 movsxd	 rax, DWORD PTR rc$[rsp]
  00736	4c 8b 8c 24 50
	03 00 00	 mov	 r9, QWORD PTR outf$[rsp]
  0073e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00744	48 8b d0	 mov	 rdx, rax
  00747	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ptr$[rsp]
  0074c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite

; 605  : 
; 606  :             /*
; 607  :             || Put out a linefeed when converting
; 608  :             */
; 609  :             if( opts.flags & O_ASCII )

  00752	0f b6 05 30 00
	00 00		 movzx	 eax, BYTE PTR opts+48
  00759	83 e0 40	 and	 eax, 64			; 00000040H
  0075c	85 c0		 test	 eax, eax
  0075e	74 20		 je	 SHORT $LN47@getfile

; 610  :             {
; 611  :                 fwrite( "\n", 1, 1, outf );

  00760	4c 8b 8c 24 50
	03 00 00	 mov	 r9, QWORD PTR outf$[rsp]
  00768	41 b8 01 00 00
	00		 mov	 r8d, 1
  0076e	ba 01 00 00 00	 mov	 edx, 1
  00773	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159560
  0077a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
$LN47@getfile:

; 612  :             }
; 613  :         }

  00780	e9 6d fe ff ff	 jmp	 $LN6@getfile
$LN7@getfile:

; 614  :     }

  00785	e9 df 00 00 00	 jmp	 $LN38@getfile
$LN37@getfile:
$LN13@getfile:

; 615  :     else
; 616  :     {
; 617  :         /*
; 618  :         || Get a record
; 619  :         */
; 620  :         while( ( rc = getblock( ) ) >= 0 )

  0078a	e8 00 00 00 00	 call	 getblock
  0078f	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00793	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00798	0f 8c cb 00 00
	00		 jl	 $LN14@getfile

; 621  :         {
; 622  :             if( extgui )

  0079e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  007a5	83 38 00	 cmp	 DWORD PTR [rax], 0
  007a8	0f 84 91 00 00
	00		 je	 $LN48@getfile

; 623  :             {
; 624  :                 off_t curpos;
; 625  :                 /* Report progress every nnnK */
; 626  :                 if ( opts.faketape )

  007ae	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  007b5	74 17		 je	 SHORT $LN49@getfile

; 627  :                     curpos = ftell( opts.fetb->fh );

  007b7	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR opts+24
  007be	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  007c7	48 89 44 24 68	 mov	 QWORD PTR curpos$2[rsp], rax
  007cc	eb 15		 jmp	 SHORT $LN50@getfile
$LN49@getfile:

; 628  :                 else
; 629  :                     curpos = ftell( opts.hetb->fh );

  007ce	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR opts+16
  007d5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  007de	48 89 44 24 68	 mov	 QWORD PTR curpos$2[rsp], rax
$LN50@getfile:

; 630  :                 if( ( curpos & PROGRESS_MASK ) != ( prevpos & PROGRESS_MASK ) )

  007e3	48 8b 44 24 68	 mov	 rax, QWORD PTR curpos$2[rsp]
  007e8	48 25 00 00 fc
	ff		 and	 rax, -262144		; fffffffffffc0000H
  007ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR prevpos
  007f5	48 81 e1 00 00
	fc ff		 and	 rcx, -262144		; fffffffffffc0000H
  007fc	48 3b c1	 cmp	 rax, rcx
  007ff	74 3e		 je	 SHORT $LN51@getfile

; 631  :                 {
; 632  :                     prevpos = curpos;

  00801	48 8b 44 24 68	 mov	 rax, QWORD PTR curpos$2[rsp]
  00806	48 89 05 00 00
	00 00		 mov	 QWORD PTR prevpos, rax
$LN17@getfile:

; 633  :                     EXTGUIMSG( "IPOS=%"PRId64"\n", (U64)curpos );

  0080d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00814	83 38 00	 cmp	 DWORD PTR [rax], 0
  00817	74 20		 je	 SHORT $LN52@getfile
  00819	b9 02 00 00 00	 mov	 ecx, 2
  0081e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00824	4c 8b 44 24 68	 mov	 r8, QWORD PTR curpos$2[rsp]
  00829	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159566
  00830	48 8b c8	 mov	 rcx, rax
  00833	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN52@getfile:
  00839	33 c0		 xor	 eax, eax
  0083b	85 c0		 test	 eax, eax
  0083d	75 ce		 jne	 SHORT $LN17@getfile
$LN51@getfile:
$LN48@getfile:

; 634  :                 }
; 635  :             }
; 636  : 
; 637  :             /*
; 638  :             || Write the record out
; 639  :             */
; 640  :             fwrite( blkptr, blklen, 1, outf );

  0083f	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR blklen
  00846	4c 8b 8c 24 50
	03 00 00	 mov	 r9, QWORD PTR outf$[rsp]
  0084e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00854	48 8b d0	 mov	 rdx, rax
  00857	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR blkptr
  0085e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite

; 641  :         }

  00864	e9 21 ff ff ff	 jmp	 $LN13@getfile
$LN14@getfile:
$LN38@getfile:

; 642  :     }
; 643  : 
; 644  :     return( rc );

  00869	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@getfile:

; 645  : }

  0086d	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00875	48 33 cc	 xor	 rcx, rsp
  00878	e8 00 00 00 00	 call	 __security_check_cookie
  0087d	48 81 c4 48 03
	00 00		 add	 rsp, 840		; 00000348H
  00884	c3		 ret	 0
getfile	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
rc$ = 80
tv78 = 88
tv91 = 96
lab$ = 128
get_sl	PROC

; 371  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 372  :     int rc;
; 373  : 
; 374  :     /*
; 375  :     || Read a block
; 376  :     */
; 377  :     if ( opts.faketape )

  00009	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  00010	74 1a		 je	 SHORT $LN2@get_sl

; 378  :         rc = fet_read( opts.fetb, blkptr );

  00012	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR blkptr
  00019	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR opts+24
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_read
  00026	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0002a	eb 18		 jmp	 SHORT $LN3@get_sl
$LN2@get_sl:

; 379  :     else
; 380  :         rc = het_read( opts.hetb, blkptr );

  0002c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR blkptr
  00033	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR opts+16
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_read
  00040	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN3@get_sl:

; 381  :     if( rc >= 0 )

  00044	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00049	7c 2b		 jl	 SHORT $LN4@get_sl

; 382  :     {
; 383  :         /*
; 384  :         || Does is look like a standard label?
; 385  :         */
; 386  :         if( sl_islabel( lab, blkptr, rc ) == TRUE )

  0004b	44 8b 44 24 50	 mov	 r8d, DWORD PTR rc$[rsp]
  00050	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR blkptr
  00057	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sl_islabel
  00065	83 f8 01	 cmp	 eax, 1
  00068	75 07		 jne	 SHORT $LN6@get_sl

; 387  :         {
; 388  :             return( 0 );

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 ed 00 00 00	 jmp	 $LN1@get_sl
$LN6@get_sl:

; 389  :         }
; 390  :     }

  00071	e9 e3 00 00 00	 jmp	 $LN5@get_sl
$LN4@get_sl:

; 391  :     else
; 392  :     {
; 393  :         // "Error in function %s: %s"
; 394  :         if ( opts.faketape )

  00076	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  0007d	74 6e		 je	 SHORT $LN7@get_sl

; 395  :             FWRMSG( stderr, HHC00075, "E", "fet_read()", fet_error( rc ) );

  0007f	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_error
  00089	48 89 44 24 58	 mov	 QWORD PTR tv78[rsp], rax
  0008e	b9 02 00 00 00	 mov	 ecx, 2
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00099	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv78[rsp]
  0009e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159444
  000aa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159445
  000b6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159446
  000c2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cc	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159447
  000d9	ba 8b 01 00 00	 mov	 edx, 395		; 0000018bH
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159448
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  000eb	eb 6c		 jmp	 SHORT $LN8@get_sl
$LN7@get_sl:

; 396  :         else
; 397  :             FWRMSG( stderr, HHC00075, "E", "het_read()", het_error( rc ) );

  000ed	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  000f7	48 89 44 24 60	 mov	 QWORD PTR tv91[rsp], rax
  000fc	b9 02 00 00 00	 mov	 ecx, 2
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00107	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv91[rsp]
  0010c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159449
  00118	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159450
  00124	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159451
  00130	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00135	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00140	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159452
  00147	ba 8d 01 00 00	 mov	 edx, 397		; 0000018dH
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159453
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@get_sl:
$LN5@get_sl:

; 398  :     }
; 399  : 
; 400  :     return( -1 );

  00159	b8 ff ff ff ff	 mov	 eax, -1
$LN1@get_sl:

; 401  : }

  0015e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00162	c3		 ret	 0
get_sl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
rc$ = 32
getrecord PROC

; 291  : {

$LN15:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 292  :     int rc;
; 293  : 
; 294  :     /*
; 295  :     || Won't be null if we've been here before
; 296  :     */
; 297  :     if( recptr != NULL )

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR recptr, 0
  0000c	74 16		 je	 SHORT $LN2@getrecord

; 298  :     {
; 299  :         recidx += reclen;

  0000e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR reclen
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR recidx
  0001a	03 c8		 add	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	89 05 00 00 00
	00		 mov	 DWORD PTR recidx, eax
$LN2@getrecord:

; 300  :     }
; 301  : 
; 302  :     /*
; 303  :     || Need a new block first time through or we've exhausted current block
; 304  :     */
; 305  :     if( ( recptr == NULL ) || ( recidx >= blklen ) )

  00024	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR recptr, 0
  0002c	74 0e		 je	 SHORT $LN4@getrecord
  0002e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR blklen
  00034	39 05 00 00 00
	00		 cmp	 DWORD PTR recidx, eax
  0003a	7c 4c		 jl	 SHORT $LN3@getrecord
$LN4@getrecord:

; 306  :     {
; 307  :         /*
; 308  :         || Go get another block
; 309  :         */
; 310  :         rc = getblock( );

  0003c	e8 00 00 00 00	 call	 getblock
  00041	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 311  :         if( rc < 0 )

  00045	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004a	7d 09		 jge	 SHORT $LN5@getrecord

; 312  :         {
; 313  :             return( rc );

  0004c	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00050	e9 cd 00 00 00	 jmp	 $LN1@getrecord
$LN5@getrecord:

; 314  :         }
; 315  : 
; 316  :         /*
; 317  :         || For RECFM=V, bump index past BDW
; 318  :         */
; 319  :         recidx = 0;

  00055	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR recidx, 0

; 320  :         if( opts.recfm & O_VARIABLE )

  0005f	0f b6 05 31 00
	00 00		 movzx	 eax, BYTE PTR opts+49
  00066	83 e0 20	 and	 eax, 32			; 00000020H
  00069	85 c0		 test	 eax, eax
  0006b	74 1b		 je	 SHORT $LN6@getrecord

; 321  :         {
; 322  :             /* protect against a corrupt (short) block */
; 323  :             if ( rc < 8 )

  0006d	83 7c 24 20 08	 cmp	 DWORD PTR rc$[rsp], 8
  00072	7d 0a		 jge	 SHORT $LN7@getrecord

; 324  :             {
; 325  :                 return ( -1 );

  00074	b8 ff ff ff ff	 mov	 eax, -1
  00079	e9 a4 00 00 00	 jmp	 $LN1@getrecord
$LN7@getrecord:

; 326  :             }
; 327  :             recidx = 4;

  0007e	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR recidx, 4
$LN6@getrecord:
$LN3@getrecord:

; 328  :         }
; 329  :     }
; 330  : 
; 331  :     /*
; 332  :     || Set the new record pointer
; 333  :     */
; 334  :     recptr = &blkptr[ recidx ];

  00088	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR recidx
  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR blkptr
  00096	48 03 c8	 add	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 89 05 00 00
	00 00		 mov	 QWORD PTR recptr, rax

; 335  : 
; 336  :     /*
; 337  :     || Set the record length depending on record type
; 338  :     */
; 339  :     if( opts.recfm & O_FIXED )

  000a3	0f b6 05 31 00
	00 00		 movzx	 eax, BYTE PTR opts+49
  000aa	83 e0 40	 and	 eax, 64			; 00000040H
  000ad	85 c0		 test	 eax, eax
  000af	74 0e		 je	 SHORT $LN8@getrecord

; 340  :     {
; 341  :         reclen = opts.lrecl;

  000b1	8b 05 28 00 00
	00		 mov	 eax, DWORD PTR opts+40
  000b7	89 05 00 00 00
	00		 mov	 DWORD PTR reclen, eax

; 342  :     }

  000bd	eb 5d		 jmp	 SHORT $LN9@getrecord
$LN8@getrecord:

; 343  :     else if( opts.recfm & O_VARIABLE )

  000bf	0f b6 05 31 00
	00 00		 movzx	 eax, BYTE PTR opts+49
  000c6	83 e0 20	 and	 eax, 32			; 00000020H
  000c9	85 c0		 test	 eax, eax
  000cb	74 43		 je	 SHORT $LN10@getrecord

; 344  :     {
; 345  :         reclen = rdw_length( recptr );

  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR recptr
  000d4	e8 00 00 00 00	 call	 rdw_length
  000d9	89 05 00 00 00
	00		 mov	 DWORD PTR reclen, eax

; 346  : 
; 347  :         /* protect against corrupt (short) block */
; 348  :         if ( reclen + recidx > blklen )

  000df	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR recidx
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR reclen
  000eb	03 c8		 add	 ecx, eax
  000ed	8b c1		 mov	 eax, ecx
  000ef	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR blklen
  000f5	7e 07		 jle	 SHORT $LN12@getrecord

; 349  :         {
; 350  :             return (-1);

  000f7	b8 ff ff ff ff	 mov	 eax, -1
  000fc	eb 24		 jmp	 SHORT $LN1@getrecord
$LN12@getrecord:

; 351  :         }
; 352  :         /* protect against a corrupt (less than 4) RDW */
; 353  :         if ( reclen < 4 )

  000fe	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR reclen, 4
  00105	7d 07		 jge	 SHORT $LN13@getrecord

; 354  :         {
; 355  :             return (-1);

  00107	b8 ff ff ff ff	 mov	 eax, -1
  0010c	eb 14		 jmp	 SHORT $LN1@getrecord
$LN13@getrecord:

; 356  :         }
; 357  :     }

  0010e	eb 0c		 jmp	 SHORT $LN11@getrecord
$LN10@getrecord:

; 358  :     else
; 359  :     {
; 360  :         reclen = blklen;

  00110	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR blklen
  00116	89 05 00 00 00
	00		 mov	 DWORD PTR reclen, eax
$LN11@getrecord:
$LN9@getrecord:

; 361  :     }
; 362  : 
; 363  :     return( reclen );

  0011c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR reclen
$LN1@getrecord:

; 364  : }

  00122	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00126	c3		 ret	 0
getrecord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
rc$ = 32
getblock PROC

; 263  : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 264  :     int rc;
; 265  : 
; 266  :     /*
; 267  :     || Read a block from the tape
; 268  :     */
; 269  :     if ( opts.faketape )

  00004	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR opts+32, 0
  0000b	74 1a		 je	 SHORT $LN2@getblock

; 270  :         rc = fet_read( opts.fetb, blkptr );

  0000d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR blkptr
  00014	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR opts+24
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fet_read
  00021	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00025	eb 18		 jmp	 SHORT $LN3@getblock
$LN2@getblock:

; 271  :     else
; 272  :         rc = het_read( opts.hetb, blkptr );

  00027	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR blkptr
  0002e	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR opts+16
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_read
  0003b	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN3@getblock:

; 273  :     if( rc < 0 )

  0003f	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00044	7d 06		 jge	 SHORT $LN4@getblock

; 274  :     {
; 275  :         return( rc );

  00046	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  0004a	eb 0e		 jmp	 SHORT $LN1@getblock
$LN4@getblock:

; 276  :     }
; 277  : 
; 278  :     /*
; 279  :     || Save the block length (should we use BDW for RECFM=V files???)
; 280  :     */
; 281  :     blklen = rc;

  0004c	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00050	89 05 00 00 00
	00		 mov	 DWORD PTR blklen, eax

; 282  : 
; 283  :     return( rc );

  00056	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@getblock:

; 284  : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
getblock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
len$ = 0
ptr$ = 32
rdw_length PROC

; 246  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 247  :     unsigned int len;
; 248  : 
; 249  :     /*
; 250  :     || Get the record length
; 251  :     */
; 252  :     len  = ptr[ 0 ] << 8;

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 00	 imul	 rax, rax, 0
  00012	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00017	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001b	c1 e0 08	 shl	 eax, 8
  0001e	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 253  :     len += ptr[ 1 ];

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	48 6b c0 01	 imul	 rax, rax, 1
  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  0002f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00033	8b 0c 24	 mov	 ecx, DWORD PTR len$[rsp]
  00036	03 c8		 add	 ecx, eax
  00038	8b c1		 mov	 eax, ecx
  0003a	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 254  : 
; 255  :     return( len );

  0003d	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]

; 256  : }

  00040	48 83 c4 18	 add	 rsp, 24
  00044	c3		 ret	 0
rdw_length ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
len$ = 0
ptr$ = 32
bdw_length PROC

; 212  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 213  :     unsigned int len;
; 214  : 
; 215  :     /*
; 216  :     || Extended format BDW?
; 217  :     */
; 218  :     if( ptr[ 0 ] & 0x80 )

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 00	 imul	 rax, rax, 0
  00012	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00017	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00020	85 c0		 test	 eax, eax
  00022	74 7e		 je	 SHORT $LN2@bdw_length

; 219  :     {
; 220  :         /*
; 221  :         || Length is 31 bits
; 222  :         */
; 223  :         len  = ptr[ 0 ] << 24;

  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	48 6b c0 00	 imul	 rax, rax, 0
  0002d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00032	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00036	c1 e0 18	 shl	 eax, 24
  00039	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 224  :         len += ptr[ 1 ] << 16;

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	48 6b c0 01	 imul	 rax, rax, 1
  00045	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  0004a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004e	c1 e0 10	 shl	 eax, 16
  00051	8b 0c 24	 mov	 ecx, DWORD PTR len$[rsp]
  00054	03 c8		 add	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 225  :         len += ptr[ 2 ] << 8;

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	48 6b c0 02	 imul	 rax, rax, 2
  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00069	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0006d	c1 e0 08	 shl	 eax, 8
  00070	8b 0c 24	 mov	 ecx, DWORD PTR len$[rsp]
  00073	03 c8		 add	 ecx, eax
  00075	8b c1		 mov	 eax, ecx
  00077	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 226  :         len += ptr[ 3 ];

  0007a	b8 01 00 00 00	 mov	 eax, 1
  0007f	48 6b c0 03	 imul	 rax, rax, 3
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00088	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008c	8b 0c 24	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	03 c8		 add	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 227  :         len &= 0x7fffffff;

  00096	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  00099	0f ba f0 1f	 btr	 eax, 31
  0009d	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 228  :     }

  000a0	eb 34		 jmp	 SHORT $LN3@bdw_length
$LN2@bdw_length:

; 229  :     else
; 230  :     {
; 231  :         /*
; 232  :         || Length is 15 bits
; 233  :         */
; 234  :         len  = ptr[ 0 ] << 8;

  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  000b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b4	c1 e0 08	 shl	 eax, 8
  000b7	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 235  :         len += ptr[ 1 ];

  000ba	b8 01 00 00 00	 mov	 eax, 1
  000bf	48 6b c0 01	 imul	 rax, rax, 1
  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  000c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cc	8b 0c 24	 mov	 ecx, DWORD PTR len$[rsp]
  000cf	03 c8		 add	 ecx, eax
  000d1	8b c1		 mov	 eax, ecx
  000d3	89 04 24	 mov	 DWORD PTR len$[rsp], eax
$LN3@bdw_length:

; 236  :     }
; 237  : 
; 238  :     return( len );

  000d6	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]

; 239  : }

  000d9	48 83 c4 18	 add	 rsp, 24
  000dd	c3		 ret	 0
bdw_length ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetget.c
_TEXT	SEGMENT
i$ = 80
tv152 = 88
tv136 = 96
fmt$ = 112
__$ArrayPad$ = 432
lab$ = 464
merge	PROC

; 136  : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 137  :     SLFMT fmt;
; 138  :     int i;
; 139  : 
; 140  :     /*
; 141  :     || Make the label more managable
; 142  :     */
; 143  :     sl_fmtlab( &fmt, lab );

  0001e	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR lab$[rsp]
  00026	48 8d 4c 24 70	 lea	 rcx, QWORD PTR fmt$[rsp]
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sl_fmtlab

; 144  : 
; 145  :     /*
; 146  :     || Merge the record format;
; 147  :     */
; 148  :     if( opts.recfm == 0 )

  00031	0f b6 05 31 00
	00 00		 movzx	 eax, BYTE PTR opts+49
  00038	85 c0		 test	 eax, eax
  0003a	75 67		 jne	 SHORT $LN8@merge

; 149  :     {
; 150  :         opts.recfm = O_UNDEFINED;

  0003c	c6 05 31 00 00
	00 80		 mov	 BYTE PTR opts+49, 128	; 00000080H

; 151  :         for( i = 0 ; i < (int)VALFMCNT ; i++ )

  00043	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004b	eb 0a		 jmp	 SHORT $LN4@merge
$LN2@merge:
  0004d	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00051	ff c0		 inc	 eax
  00053	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN4@merge:
  00057	83 7c 24 50 1b	 cmp	 DWORD PTR i$[rsp], 27
  0005c	7d 45		 jge	 SHORT $LN3@merge

; 152  :         {
; 153  :             if( strcasecmp( fmt.slds2.recfm, valfm[ i ].recfm ) == 0 )

  0005e	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00063	48 6b c0 10	 imul	 rax, rax, 16
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  0006e	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00072	48 8d 8c 24 55
	01 00 00	 lea	 rcx, QWORD PTR fmt$[rsp+229]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00080	85 c0		 test	 eax, eax
  00082	75 1d		 jne	 SHORT $LN9@merge

; 154  :             {
; 155  :                 opts.recfm = valfm[ i ].fmt;

  00084	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00089	48 6b c0 10	 imul	 rax, rax, 16
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  00094	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  00099	88 05 31 00 00
	00		 mov	 BYTE PTR opts+49, al

; 156  :                 break;

  0009f	eb 02		 jmp	 SHORT $LN3@merge
$LN9@merge:

; 157  :             }
; 158  :         }

  000a1	eb aa		 jmp	 SHORT $LN2@merge
$LN3@merge:
$LN8@merge:

; 159  :     }
; 160  : 
; 161  :     /*
; 162  :     || Merge in the record length
; 163  :     */
; 164  :     if( opts.lrecl == 0 )

  000a3	83 3d 28 00 00
	00 00		 cmp	 DWORD PTR opts+40, 0
  000aa	75 14		 jne	 SHORT $LN10@merge

; 165  :     {
; 166  :         opts.lrecl = atoi( fmt.slds2.lrecl );

  000ac	48 8d 8c 24 5d
	01 00 00	 lea	 rcx, QWORD PTR fmt$[rsp+237]
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000ba	89 05 28 00 00
	00		 mov	 DWORD PTR opts+40, eax
$LN10@merge:

; 167  :     }
; 168  : 
; 169  :     /*
; 170  :     || Merge in the block size
; 171  :     */
; 172  :     if( opts.blksize == 0 )

  000c0	83 3d 2c 00 00
	00 00		 cmp	 DWORD PTR opts+44, 0
  000c7	75 31		 jne	 SHORT $LN11@merge

; 173  :     {
; 174  :         /*
; 175  :         || Try the blksize field first
; 176  :         */
; 177  :         opts.blksize = atoi( fmt.slds2.blksize );

  000c9	48 8d 8c 24 57
	01 00 00	 lea	 rcx, QWORD PTR fmt$[rsp+231]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000d7	89 05 2c 00 00
	00		 mov	 DWORD PTR opts+44, eax

; 178  :         if( opts.blksize == 0 )

  000dd	83 3d 2c 00 00
	00 00		 cmp	 DWORD PTR opts+44, 0
  000e4	75 14		 jne	 SHORT $LN12@merge

; 179  :         {
; 180  :             /*
; 181  :             || Still zero, so try the lblkln field
; 182  :             */
; 183  :             opts.blksize = atoi( fmt.slds2.lblkln );

  000e6	48 8d 8c 24 89
	01 00 00	 lea	 rcx, QWORD PTR fmt$[rsp+281]
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000f4	89 05 2c 00 00
	00		 mov	 DWORD PTR opts+44, eax
$LN12@merge:
$LN11@merge:

; 184  :         }
; 185  :     }
; 186  : 
; 187  :     /*
; 188  :     || Locate final RECFM string
; 189  :     */
; 190  :     for( i = 0 ; i < (int)VALFMCNT ; i++ )

  000fa	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00102	eb 0a		 jmp	 SHORT $LN7@merge
$LN5@merge:
  00104	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00108	ff c0		 inc	 eax
  0010a	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN7@merge:
  0010e	83 7c 24 50 1b	 cmp	 DWORD PTR i$[rsp], 27
  00113	7d 2a		 jge	 SHORT $LN6@merge

; 191  :     {
; 192  :         if( strcasecmp( fmt.slds2.recfm, valfm[ i ].recfm ) == 0 )

  00115	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0011a	48 6b c0 10	 imul	 rax, rax, 16
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  00125	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00129	48 8d 8c 24 55
	01 00 00	 lea	 rcx, QWORD PTR fmt$[rsp+229]
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00137	85 c0		 test	 eax, eax
  00139	75 02		 jne	 SHORT $LN13@merge

; 193  :         {
; 194  :             break;

  0013b	eb 02		 jmp	 SHORT $LN6@merge
$LN13@merge:

; 195  :         }
; 196  :     }

  0013d	eb c5		 jmp	 SHORT $LN5@merge
$LN6@merge:

; 197  : 
; 198  :     /*
; 199  :     || Print DCB attributes
; 200  :     */
; 201  :     // "DCB Attributes used:  RECFM=%-4.4s  LRECL=%-5.5d  BLKSIZE=%d"
; 202  :     WRMSG( HHC02761, "I", valfm[ i ].recfm, opts.lrecl, opts.blksize );

  0013f	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00144	48 6b c0 10	 imul	 rax, rax, 16
  00148	48 89 44 24 60	 mov	 QWORD PTR tv136[rsp], rax
  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  00154	48 89 4c 24 58	 mov	 QWORD PTR tv152[rsp], rcx
  00159	b9 01 00 00 00	 mov	 ecx, 1
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00164	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR opts+44
  0016a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0016e	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR opts+40
  00174	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00178	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv152[rsp]
  0017d	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv136[rsp]
  00182	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00186	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0018b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159393
  00192	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159394
  0019e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a8	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159395
  001b5	ba ca 00 00 00	 mov	 edx, 202		; 000000caH
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159396
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 203  : 
; 204  :     return;
; 205  : }

  001c7	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001cf	48 33 cc	 xor	 rcx, rsp
  001d2	e8 00 00 00 00	 call	 __security_check_cookie
  001d7	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  001de	c3		 ret	 0
merge	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
