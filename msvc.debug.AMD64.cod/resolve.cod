; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	gai_strerrorA
PUBLIC	resolve_host
PUBLIC	resolve_ipaddr
PUBLIC	resolve_sa
EXTRN	__imp_FormatMessageA:PROC
EXTRN	__imp_getaddrinfo:PROC
EXTRN	__imp_freeaddrinfo:PROC
EXTRN	__imp_getnameinfo:PROC
EXTRN	__imp_w32_inet_ntop:PROC
EXTRN	__imp_w32_snprintf:PROC
_DATA	SEGMENT
COMM	?buff@?1??gai_strerrorA@@9@9:BYTE:0401H							; `gai_strerrorA'::`2'::buff
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gai_strerrorA DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$gai_strerrorA
pdata	ENDS
pdata	SEGMENT
$pdata$resolve_host DD imagerel $LN14
	DD	imagerel $LN14+878
	DD	imagerel $unwind$resolve_host
$pdata$resolve_ipaddr DD imagerel $LN9
	DD	imagerel $LN9+816
	DD	imagerel $unwind$resolve_ipaddr
$pdata$resolve_sa DD imagerel $LN8
	DD	imagerel $LN8+408
	DD	imagerel $unwind$resolve_sa
pdata	ENDS
_DATA	SEGMENT
$SG159092 DB	'getaddrinfo fail: %d, %s', 00H
	ORG $+7
$SG159099 DB	'resolve fail: host does not resolve to inet or inet6', 00H
	ORG $+3
$SG159110 DB	'getaddrinfo fail: %d, %s', 00H
	ORG $+7
$SG159115 DB	'resolve fail: IP address not inet or inet6', 00H
	ORG $+5
$SG159117 DB	'getnameinfo fail: %d, %s', 00H
	ORG $+7
$SG159127 DB	'resolve fail: address family not inet or inet6', 00H
	ORG $+1
$SG159129 DB	'getnameinfo fail: %d, %s', 00H
_DATA	ENDS
xdata	SEGMENT
$unwind$resolve_host DD 040e01H
	DD	011010eH
	DD	060067007H
$unwind$resolve_ipaddr DD 040e01H
	DD	011010eH
	DD	060067007H
$unwind$resolve_sa DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gai_strerrorA DD 010801H
	DD	08208H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\resolve.c
_TEXT	SEGMENT
pHRB$ = 80
resolve_sa PROC

; 264  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 265  : 
; 266  :     // Clear the output.
; 267  :     memset( &pHRB->host, 0, sizeof(pHRB->host) );

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  0000f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pHRB$[rsp]
  00014	33 c0		 xor	 eax, eax
  00016	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0001b	f3 aa		 rep stosb

; 268  :     pHRB->salen = 0;

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00022	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+320], 0

; 269  :     pHRB->afam = 0;

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00031	c7 80 60 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+352], 0

; 270  :     pHRB->rv = 0;

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00040	c7 80 6c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+364], 0

; 271  :     memset( &pHRB->em, 0, sizeof(pHRB->em) );

  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  0004f	48 05 70 01 00
	00		 add	 rax, 368		; 00000170H
  00055	48 8b f8	 mov	 rdi, rax
  00058	33 c0		 xor	 eax, eax
  0005a	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0005f	f3 aa		 rep stosb

; 272  : 
; 273  :     // Check the sockaddr address family.
; 274  :     if( pHRB->sa.in.sin_family == AF_INET )

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00066	0f b7 80 44 01
	00 00		 movzx	 eax, WORD PTR [rax+324]
  0006d	83 f8 02	 cmp	 eax, 2
  00070	75 20		 jne	 SHORT $LN2@resolve_sa

; 275  :     {
; 276  :         pHRB->salen = sizeof(pHRB->sa.in);

  00072	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00077	c7 80 40 01 00
	00 10 00 00 00	 mov	 DWORD PTR [rax+320], 16

; 277  :         pHRB->afam = AF_INET;

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00086	c7 80 60 01 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+352], 2

; 278  :     }

  00090	eb 5b		 jmp	 SHORT $LN3@resolve_sa
$LN2@resolve_sa:

; 279  :     else if( pHRB->sa.in6.sin6_family == AF_INET6 )

  00092	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00097	0f b7 80 44 01
	00 00		 movzx	 eax, WORD PTR [rax+324]
  0009e	83 f8 17	 cmp	 eax, 23
  000a1	75 20		 jne	 SHORT $LN4@resolve_sa

; 280  :     {
; 281  :         pHRB->salen = sizeof(pHRB->sa.in6);

  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  000a8	c7 80 40 01 00
	00 1c 00 00 00	 mov	 DWORD PTR [rax+320], 28

; 282  :         pHRB->afam = AF_INET6;

  000b2	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  000b7	c7 80 60 01 00
	00 17 00 00 00	 mov	 DWORD PTR [rax+352], 23

; 283  :     }

  000c1	eb 2a		 jmp	 SHORT $LN5@resolve_sa
$LN4@resolve_sa:

; 284  :     else
; 285  :     {
; 286  :         MSGBUF( pHRB->em,

  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  000c8	48 05 70 01 00
	00		 add	 rax, 368		; 00000170H
  000ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159127
  000d5	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  000da	48 8b c8	 mov	 rcx, rax
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 287  :                   "resolve fail: address family not inet or inet6" );
; 288  :         return -1;

  000e3	b8 ff ff ff ff	 mov	 eax, -1
  000e8	e9 a5 00 00 00	 jmp	 $LN1@resolve_sa
$LN5@resolve_sa:
$LN3@resolve_sa:

; 289  :     }
; 290  : 
; 291  :     // Resolve the sockaddr IP address to host name.
; 292  :     pHRB->rv = getnameinfo( (struct sockaddr*)&pHRB->sa, pHRB->salen,

  000ed	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pHRB$[rsp]
  000f7	48 81 c1 44 01
	00 00		 add	 rcx, 324		; 00000144H
  000fe	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00106	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0010e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00117	41 b9 ff 00 00
	00		 mov	 r9d, 255		; 000000ffH
  0011d	4c 8b c0	 mov	 r8, rax
  00120	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00125	8b 90 40 01 00
	00		 mov	 edx, DWORD PTR [rax+320]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo
  00131	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pHRB$[rsp]
  00136	89 81 6c 01 00
	00		 mov	 DWORD PTR [rcx+364], eax

; 293  :                             pHRB->host, sizeof(pHRB->host)-1,
; 294  :                             NULL, 0, 0);
; 295  : 
; 296  :     // If the getnameinfo was not successful, let the caller know why.
; 297  :     if( pHRB->rv != 0 )

  0013c	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00141	83 b8 6c 01 00
	00 00		 cmp	 DWORD PTR [rax+364], 0
  00148	74 46		 je	 SHORT $LN6@resolve_sa

; 298  :     {
; 299  :         MSGBUF( pHRB->em,

  0014a	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  0014f	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [rax+364]
  00155	e8 00 00 00 00	 call	 gai_strerrorA
  0015a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pHRB$[rsp]
  0015f	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  00166	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016b	48 8b 44 24 50	 mov	 rax, QWORD PTR pHRB$[rsp]
  00170	44 8b 88 6c 01
	00 00		 mov	 r9d, DWORD PTR [rax+364]
  00177	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159129
  0017e	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 300  :                   "getnameinfo fail: %d, %s",
; 301  :                   pHRB->rv, gai_strerror(pHRB->rv) );
; 302  :         return -1;

  00189	b8 ff ff ff ff	 mov	 eax, -1
  0018e	eb 02		 jmp	 SHORT $LN1@resolve_sa
$LN6@resolve_sa:

; 303  :     }
; 304  : 
; 305  :     return 0;

  00190	33 c0		 xor	 eax, eax
$LN1@resolve_sa:

; 306  : }   /* End function resolve_sa() */

  00192	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00196	5f		 pop	 rdi
  00197	c3		 ret	 0
resolve_sa ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\resolve.c
_TEXT	SEGMENT
result$ = 64
hints$ = 72
pHRB$ = 160
resolve_ipaddr PROC

; 161  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 162  :     struct addrinfo hints;
; 163  :     struct addrinfo *result = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 164  : 
; 165  : 
; 166  :     // Clear the output.
; 167  :     memset( &pHRB->host, 0, sizeof(pHRB->host) );

  00017	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0001f	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR pHRB$[rsp]
  00027	33 c0		 xor	 eax, eax
  00029	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0002e	f3 aa		 rep stosb

; 168  :     pHRB->salen = 0;

  00030	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00038	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+320], 0

; 169  :     memset( &pHRB->sa, 0, sizeof(pHRB->sa) );

  00042	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0004a	48 05 44 01 00
	00		 add	 rax, 324		; 00000144H
  00050	48 8b f8	 mov	 rdi, rax
  00053	33 c0		 xor	 eax, eax
  00055	b9 1c 00 00 00	 mov	 ecx, 28
  0005a	f3 aa		 rep stosb

; 170  :     pHRB->afam = 0;

  0005c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00064	c7 80 60 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+352], 0

; 171  :     pHRB->rv = 0;

  0006e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00076	c7 80 6c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+364], 0

; 172  :     memset( &pHRB->em, 0, sizeof(pHRB->em) );

  00080	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00088	48 05 70 01 00
	00		 add	 rax, 368		; 00000170H
  0008e	48 8b f8	 mov	 rdi, rax
  00091	33 c0		 xor	 eax, eax
  00093	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00098	f3 aa		 rep stosb

; 173  : 
; 174  :     // Prepare the hints.
; 175  :     memset( &hints, 0, sizeof(hints) );

  0009a	48 8d 44 24 48	 lea	 rax, QWORD PTR hints$[rsp]
  0009f	48 8b f8	 mov	 rdi, rax
  000a2	33 c0		 xor	 eax, eax
  000a4	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  000a9	f3 aa		 rep stosb

; 176  :     hints.ai_flags = AI_NUMERICHOST;

  000ab	c7 44 24 48 04
	00 00 00	 mov	 DWORD PTR hints$[rsp], 4

; 177  : 
; 178  :     // Resolve the character IP address.
; 179  :     pHRB->rv = getaddrinfo( pHRB->ipaddr, NULL, &hints, &result );

  000b3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  000bb	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  000c1	4c 8d 4c 24 40	 lea	 r9, QWORD PTR result$[rsp]
  000c6	4c 8d 44 24 48	 lea	 r8, QWORD PTR hints$[rsp]
  000cb	33 d2		 xor	 edx, edx
  000cd	48 8b c8	 mov	 rcx, rax
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getaddrinfo
  000d6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  000de	89 81 6c 01 00
	00		 mov	 DWORD PTR [rcx+364], eax

; 180  : 
; 181  :     // If the getaddrinfo was not successful, let the caller know why.
; 182  :     if( pHRB->rv != 0 )

  000e4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  000ec	83 b8 6c 01 00
	00 00		 cmp	 DWORD PTR [rax+364], 0
  000f3	74 52		 je	 SHORT $LN2@resolve_ip

; 183  :     {
; 184  :         MSGBUF( pHRB->em,

  000f5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  000fd	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [rax+364]
  00103	e8 00 00 00 00	 call	 gai_strerrorA
  00108	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  00110	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00124	44 8b 88 6c 01
	00 00		 mov	 r9d, DWORD PTR [rax+364]
  0012b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159110
  00132	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 185  :                   "getaddrinfo fail: %d, %s",
; 186  :                   pHRB->rv, gai_strerror(pHRB->rv) );
; 187  :         return -1;

  0013d	b8 ff ff ff ff	 mov	 eax, -1
  00142	e9 df 01 00 00	 jmp	 $LN1@resolve_ip
$LN2@resolve_ip:

; 188  :     }
; 189  : 
; 190  :     // Process the getaddrinfo result.
; 191  :     if( result->ai_family == AF_INET )

  00147	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  0014c	83 78 04 02	 cmp	 DWORD PTR [rax+4], 2
  00150	75 66		 jne	 SHORT $LN3@resolve_ip

; 192  :     {
; 193  :         pHRB->salen = result->ai_addrlen;

  00152	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0015a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  0015f	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00162	89 88 40 01 00
	00		 mov	 DWORD PTR [rax+320], ecx

; 194  :         pHRB->sa.in.sin_family = AF_INET;

  00168	b8 02 00 00 00	 mov	 eax, 2
  0016d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  00175	66 89 81 44 01
	00 00		 mov	 WORD PTR [rcx+324], ax

; 195  :         memcpy( &pHRB->sa, result->ai_addr, result->ai_addrlen );

  0017c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00184	48 05 44 01 00
	00		 add	 rax, 324		; 00000144H
  0018a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  0018f	48 8b 54 24 40	 mov	 rdx, QWORD PTR result$[rsp]
  00194	48 8b f8	 mov	 rdi, rax
  00197	48 8b 71 20	 mov	 rsi, QWORD PTR [rcx+32]
  0019b	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  0019f	f3 a4		 rep movsb

; 196  :         pHRB->afam = AF_INET;

  001a1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  001a9	c7 80 60 01 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+352], 2

; 197  :     }

  001b3	e9 a6 00 00 00	 jmp	 $LN4@resolve_ip
$LN3@resolve_ip:

; 198  :     else if( result->ai_family == AF_INET6 )

  001b8	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  001bd	83 78 04 17	 cmp	 DWORD PTR [rax+4], 23
  001c1	75 63		 jne	 SHORT $LN5@resolve_ip

; 199  :     {
; 200  :         pHRB->salen = result->ai_addrlen;

  001c3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  001cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  001d0	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  001d3	89 88 40 01 00
	00		 mov	 DWORD PTR [rax+320], ecx

; 201  :         pHRB->sa.in6.sin6_family = AF_INET6;

  001d9	b8 17 00 00 00	 mov	 eax, 23
  001de	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  001e6	66 89 81 44 01
	00 00		 mov	 WORD PTR [rcx+324], ax

; 202  :         memcpy( &pHRB->sa, result->ai_addr, result->ai_addrlen );

  001ed	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  001f5	48 05 44 01 00
	00		 add	 rax, 324		; 00000144H
  001fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00200	48 8b 54 24 40	 mov	 rdx, QWORD PTR result$[rsp]
  00205	48 8b f8	 mov	 rdi, rax
  00208	48 8b 71 20	 mov	 rsi, QWORD PTR [rcx+32]
  0020c	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  00210	f3 a4		 rep movsb

; 203  :         pHRB->afam = AF_INET6;

  00212	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0021a	c7 80 60 01 00
	00 17 00 00 00	 mov	 DWORD PTR [rax+352], 23

; 204  :     }

  00224	eb 38		 jmp	 SHORT $LN6@resolve_ip
$LN5@resolve_ip:

; 205  :     else
; 206  :     {
; 207  :         MSGBUF( pHRB->em,

  00226	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0022e	48 05 70 01 00
	00		 add	 rax, 368		; 00000170H
  00234	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159115
  0023b	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00240	48 8b c8	 mov	 rcx, rax
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 208  :                   "resolve fail: IP address not inet or inet6" );
; 209  :         freeaddrinfo( result );

  00249	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_freeaddrinfo

; 210  :         return -1;

  00254	b8 ff ff ff ff	 mov	 eax, -1
  00259	e9 c8 00 00 00	 jmp	 $LN1@resolve_ip
$LN6@resolve_ip:
$LN4@resolve_ip:

; 211  :     }
; 212  : 
; 213  :     // Free the getaddrinfo result.
; 214  :     freeaddrinfo( result );

  0025e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00263	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_freeaddrinfo

; 215  : 
; 216  :     // Resolve the sockaddr IP address to host name.
; 217  :     pHRB->rv = getnameinfo( (struct sockaddr*)&pHRB->sa, pHRB->salen,

  00269	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00271	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  00279	48 81 c1 44 01
	00 00		 add	 rcx, 324		; 00000144H
  00280	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00288	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00290	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00299	41 b9 ff 00 00
	00		 mov	 r9d, 255		; 000000ffH
  0029f	4c 8b c0	 mov	 r8, rax
  002a2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  002aa	8b 90 40 01 00
	00		 mov	 edx, DWORD PTR [rax+320]
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo
  002b6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  002be	89 81 6c 01 00
	00		 mov	 DWORD PTR [rcx+364], eax

; 218  :                             pHRB->host, sizeof(pHRB->host)-1,
; 219  :                             NULL, 0, 0);
; 220  : 
; 221  :     // If the getnameinfo was not successful, let the caller know why.
; 222  :     if( pHRB->rv != 0 )

  002c4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  002cc	83 b8 6c 01 00
	00 00		 cmp	 DWORD PTR [rax+364], 0
  002d3	74 4f		 je	 SHORT $LN7@resolve_ip

; 223  :     {
; 224  :         MSGBUF( pHRB->em,

  002d5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  002dd	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [rax+364]
  002e3	e8 00 00 00 00	 call	 gai_strerrorA
  002e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  002f0	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  002f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00304	44 8b 88 6c 01
	00 00		 mov	 r9d, DWORD PTR [rax+364]
  0030b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159117
  00312	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 225  :                   "getnameinfo fail: %d, %s",
; 226  :                   pHRB->rv, gai_strerror(pHRB->rv) );
; 227  :         return -1;

  0031d	b8 ff ff ff ff	 mov	 eax, -1
  00322	eb 02		 jmp	 SHORT $LN1@resolve_ip
$LN7@resolve_ip:

; 228  :     }
; 229  : 
; 230  :     return 0;

  00324	33 c0		 xor	 eax, eax
$LN1@resolve_ip:

; 231  : }   /* End function resolve_ipaddr() */

  00326	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0032d	5f		 pop	 rdi
  0032e	5e		 pop	 rsi
  0032f	c3		 ret	 0
resolve_ipaddr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\resolve.c
_TEXT	SEGMENT
rv$ = 48
rescon$ = 56
result$ = 64
hints$ = 72
pHRB$ = 160
resolve_host PROC

; 54   : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 55   :     struct addrinfo hints;
; 56   :     struct addrinfo *result = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 57   :     struct addrinfo *rescon = NULL;

  00017	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR rescon$[rsp], 0

; 58   :     int             rv = -1;

  00020	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rv$[rsp], -1

; 59   : 
; 60   : 
; 61   :     // Clear the output.
; 62   :     memset( &pHRB->ipaddr, 0, sizeof(pHRB->ipaddr) );

  00028	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00030	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00040	f3 aa		 rep stosb

; 63   :     pHRB->salen = 0;

  00042	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0004a	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+320], 0

; 64   :     memset( &pHRB->sa, 0, sizeof(pHRB->sa) );

  00054	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0005c	48 05 44 01 00
	00		 add	 rax, 324		; 00000144H
  00062	48 8b f8	 mov	 rdi, rax
  00065	33 c0		 xor	 eax, eax
  00067	b9 1c 00 00 00	 mov	 ecx, 28
  0006c	f3 aa		 rep stosb

; 65   :     pHRB->afam = 0;

  0006e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00076	c7 80 60 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+352], 0

; 66   :     pHRB->rv = 0;

  00080	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00088	c7 80 6c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+364], 0

; 67   :     memset( &pHRB->em, 0, sizeof(pHRB->em) );

  00092	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0009a	48 05 70 01 00
	00		 add	 rax, 368		; 00000170H
  000a0	48 8b f8	 mov	 rdi, rax
  000a3	33 c0		 xor	 eax, eax
  000a5	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  000aa	f3 aa		 rep stosb

; 68   : 
; 69   :     // Prepare the hints.
; 70   :     memset( &hints, 0, sizeof(hints) );

  000ac	48 8d 44 24 48	 lea	 rax, QWORD PTR hints$[rsp]
  000b1	48 8b f8	 mov	 rdi, rax
  000b4	33 c0		 xor	 eax, eax
  000b6	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  000bb	f3 aa		 rep stosb

; 71   :     if( pHRB->numeric )

  000bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  000c5	83 b8 64 01 00
	00 00		 cmp	 DWORD PTR [rax+356], 0
  000cc	74 0b		 je	 SHORT $LN5@resolve_ho

; 72   :         hints.ai_flags |= AI_NUMERICHOST;

  000ce	8b 44 24 48	 mov	 eax, DWORD PTR hints$[rsp]
  000d2	83 c8 04	 or	 eax, 4
  000d5	89 44 24 48	 mov	 DWORD PTR hints$[rsp], eax
$LN5@resolve_ho:

; 73   :     hints.ai_family = pHRB->wantafam;

  000d9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  000e1	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [rax+360]
  000e7	89 44 24 4c	 mov	 DWORD PTR hints$[rsp+4], eax

; 74   : 
; 75   :     // Resolve the host name or IP address.
; 76   :     pHRB->rv = getaddrinfo( pHRB->host, NULL, &hints, &result );

  000eb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  000f3	4c 8d 4c 24 40	 lea	 r9, QWORD PTR result$[rsp]
  000f8	4c 8d 44 24 48	 lea	 r8, QWORD PTR hints$[rsp]
  000fd	33 d2		 xor	 edx, edx
  000ff	48 8b c8	 mov	 rcx, rax
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getaddrinfo
  00108	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  00110	89 81 6c 01 00
	00		 mov	 DWORD PTR [rcx+364], eax

; 77   : 
; 78   :     // If the getaddrinfo was not successful, let the caller know why.
; 79   :     if( pHRB->rv != 0 )

  00116	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0011e	83 b8 6c 01 00
	00 00		 cmp	 DWORD PTR [rax+364], 0
  00125	74 51		 je	 SHORT $LN6@resolve_ho

; 80   :     {
; 81   :         MSGBUF( pHRB->em,

  00127	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0012f	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [rax+364]
  00135	e8 00 00 00 00	 call	 gai_strerrorA
  0013a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  00142	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  00149	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00156	44 8b 88 6c 01
	00 00		 mov	 r9d, DWORD PTR [rax+364]
  0015d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159092
  00164	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 82   :                   "getaddrinfo fail: %d, %s",
; 83   :                   pHRB->rv, gai_strerror(pHRB->rv) );
; 84   :         return rv;

  0016f	8b 44 24 30	 mov	 eax, DWORD PTR rv$[rsp]
  00173	e9 ec 01 00 00	 jmp	 $LN1@resolve_ho
$LN6@resolve_ho:

; 85   :     }
; 86   : 
; 87   :     // Process the getaddrinfo result.
; 88   :     for (rescon = result; rescon != NULL; rescon = rescon->ai_next)

  00178	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  0017d	48 89 44 24 38	 mov	 QWORD PTR rescon$[rsp], rax
  00182	eb 0e		 jmp	 SHORT $LN4@resolve_ho
$LN2@resolve_ho:
  00184	48 8b 44 24 38	 mov	 rax, QWORD PTR rescon$[rsp]
  00189	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0018d	48 89 44 24 38	 mov	 QWORD PTR rescon$[rsp], rax
$LN4@resolve_ho:
  00192	48 83 7c 24 38
	00		 cmp	 QWORD PTR rescon$[rsp], 0
  00198	0f 84 8d 01 00
	00		 je	 $LN3@resolve_ho

; 89   :     {
; 90   :         if( rescon->ai_family == AF_INET &&

  0019e	48 8b 44 24 38	 mov	 rax, QWORD PTR rescon$[rsp]
  001a3	83 78 04 02	 cmp	 DWORD PTR [rax+4], 2
  001a7	0f 85 b9 00 00
	00		 jne	 $LN7@resolve_ho
  001ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  001b5	83 b8 68 01 00
	00 02		 cmp	 DWORD PTR [rax+360], 2
  001bc	74 15		 je	 SHORT $LN9@resolve_ho
  001be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  001c6	83 b8 68 01 00
	00 00		 cmp	 DWORD PTR [rax+360], 0
  001cd	0f 85 93 00 00
	00		 jne	 $LN7@resolve_ho
$LN9@resolve_ho:

; 91   :             ( pHRB->wantafam == AF_INET || pHRB->wantafam == AF_UNSPEC ) )
; 92   :         {
; 93   :             pHRB->afam = AF_INET;

  001d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  001db	c7 80 60 01 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+352], 2

; 94   :             pHRB->salen = rescon->ai_addrlen;

  001e5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  001ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rescon$[rsp]
  001f2	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  001f5	89 88 40 01 00
	00		 mov	 DWORD PTR [rax+320], ecx

; 95   :             memcpy( &pHRB->sa, rescon->ai_addr, rescon->ai_addrlen );

  001fb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00203	48 05 44 01 00
	00		 add	 rax, 324		; 00000144H
  00209	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rescon$[rsp]
  0020e	48 8b 54 24 38	 mov	 rdx, QWORD PTR rescon$[rsp]
  00213	48 8b f8	 mov	 rdi, rax
  00216	48 8b 71 20	 mov	 rsi, QWORD PTR [rcx+32]
  0021a	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  0021e	f3 a4		 rep movsb

; 96   :             hinet_ntop( AF_INET, &pHRB->sa.in.sin_addr, pHRB->ipaddr, sizeof(pHRB->ipaddr)-1 );

  00220	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  00228	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  0022e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  00236	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  0023d	41 b9 3f 00 00
	00		 mov	 r9d, 63			; 0000003fH
  00243	4c 8b c0	 mov	 r8, rax
  00246	48 8b d1	 mov	 rdx, rcx
  00249	b9 02 00 00 00	 mov	 ecx, 2
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 97   :             rv = 0;

  00254	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rv$[rsp], 0

; 98   :             break;

  0025c	e9 ca 00 00 00	 jmp	 $LN3@resolve_ho

; 99   :         }

  00261	e9 c0 00 00 00	 jmp	 $LN8@resolve_ho
$LN7@resolve_ho:

; 100  :         else if( rescon->ai_family == AF_INET6 &&

  00266	48 8b 44 24 38	 mov	 rax, QWORD PTR rescon$[rsp]
  0026b	83 78 04 17	 cmp	 DWORD PTR [rax+4], 23
  0026f	0f 85 b1 00 00
	00		 jne	 $LN10@resolve_ho
  00275	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0027d	83 b8 68 01 00
	00 17		 cmp	 DWORD PTR [rax+360], 23
  00284	74 15		 je	 SHORT $LN11@resolve_ho
  00286	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0028e	83 b8 68 01 00
	00 00		 cmp	 DWORD PTR [rax+360], 0
  00295	0f 85 8b 00 00
	00		 jne	 $LN10@resolve_ho
$LN11@resolve_ho:

; 101  :                  ( pHRB->wantafam == AF_INET6 || pHRB->wantafam == AF_UNSPEC ) )
; 102  :         {
; 103  :             pHRB->afam = AF_INET6;

  0029b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  002a3	c7 80 60 01 00
	00 17 00 00 00	 mov	 DWORD PTR [rax+352], 23

; 104  :             pHRB->salen = rescon->ai_addrlen;

  002ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  002b5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rescon$[rsp]
  002ba	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  002bd	89 88 40 01 00
	00		 mov	 DWORD PTR [rax+320], ecx

; 105  :             memcpy( &pHRB->sa, rescon->ai_addr, rescon->ai_addrlen );

  002c3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  002cb	48 05 44 01 00
	00		 add	 rax, 324		; 00000144H
  002d1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rescon$[rsp]
  002d6	48 8b 54 24 38	 mov	 rdx, QWORD PTR rescon$[rsp]
  002db	48 8b f8	 mov	 rdi, rax
  002de	48 8b 71 20	 mov	 rsi, QWORD PTR [rcx+32]
  002e2	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  002e6	f3 a4		 rep movsb

; 106  :             hinet_ntop( AF_INET6, &pHRB->sa.in6.sin6_addr, pHRB->ipaddr, sizeof(pHRB->ipaddr)-1 );

  002e8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  002f0	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  002f6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pHRB$[rsp]
  002fe	48 81 c1 4c 01
	00 00		 add	 rcx, 332		; 0000014cH
  00305	41 b9 3f 00 00
	00		 mov	 r9d, 63			; 0000003fH
  0030b	4c 8b c0	 mov	 r8, rax
  0030e	48 8b d1	 mov	 rdx, rcx
  00311	b9 17 00 00 00	 mov	 ecx, 23
  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 107  :             rv = 0;

  0031c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rv$[rsp], 0

; 108  :             break;

  00324	eb 05		 jmp	 SHORT $LN3@resolve_ho
$LN10@resolve_ho:
$LN8@resolve_ho:

; 109  :         }
; 110  :     }

  00326	e9 59 fe ff ff	 jmp	 $LN2@resolve_ho
$LN3@resolve_ho:

; 111  : 
; 112  :     // If the getaddrinfo result were not useful, let the caller know we
; 113  :     // don't know why. This could happen if the function is called with
; 114  :     // pHRB->wantafam == AF_UNSPEC and the host name does not resolve to
; 115  :     // an AF_INET or AF_INET6 address, but does resolve to something
; 116  :     // else. This scenario is extremely unlikely I know, but...
; 117  :     if( rv != 0 )

  0032b	83 7c 24 30 00	 cmp	 DWORD PTR rv$[rsp], 0
  00330	74 23		 je	 SHORT $LN12@resolve_ho

; 118  :     {
; 119  :         MSGBUF( pHRB->em,

  00332	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pHRB$[rsp]
  0033a	48 05 70 01 00
	00		 add	 rax, 368		; 00000170H
  00340	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159099
  00347	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0034c	48 8b c8	 mov	 rcx, rax
  0034f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN12@resolve_ho:

; 120  :                   "resolve fail: host does not resolve to inet or inet6" );
; 121  :     }
; 122  : 
; 123  :     // Free the getaddrinfo result.
; 124  :     freeaddrinfo( result );

  00355	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  0035a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_freeaddrinfo

; 125  : 
; 126  :     return rv;

  00360	8b 44 24 30	 mov	 eax, DWORD PTR rv$[rsp]
$LN1@resolve_ho:

; 127  : }   /* End function resolve_host() */

  00364	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0036b	5f		 pop	 rdi
  0036c	5e		 pop	 rsi
  0036d	c3		 ret	 0
resolve_host ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\um\ws2tcpip.h
;	COMDAT gai_strerrorA
_TEXT	SEGMENT
ecode$ = 80
gai_strerrorA PROC					; COMDAT

; 686  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 687  :     static char buff[GAI_STRERROR_BUFFER_SIZE + 1];
; 688  : 
; 689  :     (void)FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM

  00008	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00011	c7 44 24 28 00
	04 00 00	 mov	 DWORD PTR [rsp+40], 1024 ; 00000400H
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
  00020	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00025	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  0002b	44 8b 44 24 50	 mov	 r8d, DWORD PTR ecode$[rsp]
  00030	33 d2		 xor	 edx, edx
  00032	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA

; 690  :                              |FORMAT_MESSAGE_IGNORE_INSERTS
; 691  :                              |FORMAT_MESSAGE_MAX_WIDTH_MASK,
; 692  :                               NULL,
; 693  :                               ecode,
; 694  :                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 695  :                               (LPSTR)buff,
; 696  :                               GAI_STRERROR_BUFFER_SIZE,
; 697  :                               NULL);
; 698  : 
; 699  :     return buff;

  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff

; 700  : }

  00044	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00048	c3		 ret	 0
gai_strerrorA ENDP
_TEXT	ENDS
END
