; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_vm_blockio
PUBLIC	fetch_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__get_storage_key
PUBLIC	s370__or_storage_key
PUBLIC	s370_get_2K_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_get_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	s370_maddr_l
PUBLIC	s370_vstorec
PUBLIC	s370_vfetchc
PUBLIC	s390_vm_blockio
PUBLIC	s390__get_storage_key
PUBLIC	s390__or_storage_key
PUBLIC	s390_get_4K_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_get_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	s390_maddr_l
PUBLIC	s390_vstorec
PUBLIC	s390_vfetchc
PUBLIC	z900_vm_blockio
PUBLIC	z900__get_storage_key
PUBLIC	z900__or_storage_key
PUBLIC	z900_get_4K_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_get_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_maddr_l
PUBLIC	z900_vstorec
PUBLIC	z900_vfetchc
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	__imp_dasd_lookup:PROC
EXTRN	find_device_by_devnum:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	__imp_fbadasd_read_block:PROC
EXTRN	__imp_fbadasd_write_block:PROC
EXTRN	shared_iowait:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$s370_vm_blockio DD imagerel $LN12
	DD	imagerel $LN12+532
	DD	imagerel $unwind$s370_vm_blockio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpus_mask DD imagerel wakeup_cpus_mask
	DD	imagerel wakeup_cpus_mask+106
	DD	imagerel $unwind$wakeup_cpus_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+118
	DD	imagerel $unwind$s370__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$s370_get_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_storage_key DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$s370_get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchc DD imagerel $LN24
	DD	imagerel $LN24+528
	DD	imagerel $unwind$s370_vfetchc
pdata	ENDS
pdata	SEGMENT
$pdata$d250_init32 DD imagerel d250_init32
	DD	imagerel d250_init32+571
	DD	imagerel $unwind$d250_init32
$pdata$d250_init64 DD imagerel d250_init64
	DD	imagerel d250_init64+605
	DD	imagerel $unwind$d250_init64
$pdata$d250_init DD imagerel d250_init
	DD	imagerel d250_init+1369
	DD	imagerel $unwind$d250_init
$pdata$d250_preserve DD imagerel d250_preserve
	DD	imagerel d250_preserve+410
	DD	imagerel $unwind$d250_preserve
$pdata$d250_restore DD imagerel d250_restore
	DD	imagerel d250_restore+397
	DD	imagerel $unwind$d250_restore
$pdata$d250_read DD imagerel d250_read
	DD	imagerel d250_read+651
	DD	imagerel $unwind$d250_read
$pdata$d250_write DD imagerel d250_write
	DD	imagerel d250_write+707
	DD	imagerel $unwind$d250_write
$pdata$d250_remove DD imagerel d250_remove
	DD	imagerel d250_remove+567
	DD	imagerel $unwind$d250_remove
$pdata$d250_bio_interrupt DD imagerel d250_bio_interrupt
	DD	imagerel d250_bio_interrupt+768
	DD	imagerel $unwind$d250_bio_interrupt
$pdata$s370_d250_iorq32 DD imagerel s370_d250_iorq32
	DD	imagerel s370_d250_iorq32+1962
	DD	imagerel $unwind$s370_d250_iorq32
$pdata$s370_d250_list32 DD imagerel s370_d250_list32
	DD	imagerel s370_d250_list32+3149
	DD	imagerel $unwind$s370_d250_list32
$pdata$s370_d250_addrck DD imagerel s370_d250_addrck
	DD	imagerel s370_d250_addrck+364
	DD	imagerel $unwind$s370_d250_addrck
$pdata$s370_d250_async32 DD imagerel s370_d250_async32
	DD	imagerel s370_d250_async32+89
	DD	imagerel $unwind$s370_d250_async32
$pdata$s390_vm_blockio DD imagerel $LN12
	DD	imagerel $LN12+560
	DD	imagerel $unwind$s390_vm_blockio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$s390__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$s390_get_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_storage_key DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$s390_get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
pdata	SEGMENT
$pdata$s390_d250_iorq32 DD imagerel s390_d250_iorq32
	DD	imagerel s390_d250_iorq32+1962
	DD	imagerel $unwind$s390_d250_iorq32
$pdata$s390_d250_list32 DD imagerel s390_d250_list32
	DD	imagerel s390_d250_list32+3048
	DD	imagerel $unwind$s390_d250_list32
$pdata$s390_d250_addrck DD imagerel s390_d250_addrck
	DD	imagerel s390_d250_addrck+254
	DD	imagerel $unwind$s390_d250_addrck
$pdata$s390_d250_async32 DD imagerel s390_d250_async32
	DD	imagerel s390_d250_async32+89
	DD	imagerel $unwind$s390_d250_async32
$pdata$z900_vm_blockio DD imagerel $LN16
	DD	imagerel $LN16+676
	DD	imagerel $unwind$z900_vm_blockio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$z900__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$z900_get_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_storage_key DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$z900_get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
pdata	SEGMENT
$pdata$z900_d250_iorq32 DD imagerel z900_d250_iorq32
	DD	imagerel z900_d250_iorq32+1962
	DD	imagerel $unwind$z900_d250_iorq32
$pdata$z900_d250_list32 DD imagerel z900_d250_list32
	DD	imagerel z900_d250_list32+3048
	DD	imagerel $unwind$z900_d250_list32
$pdata$z900_d250_addrck DD imagerel z900_d250_addrck
	DD	imagerel z900_d250_addrck+251
	DD	imagerel $unwind$z900_d250_addrck
$pdata$z900_d250_iorq64 DD imagerel z900_d250_iorq64
	DD	imagerel z900_d250_iorq64+2023
	DD	imagerel $unwind$z900_d250_iorq64
$pdata$z900_d250_list64 DD imagerel z900_d250_list64
	DD	imagerel z900_d250_list64+3030
	DD	imagerel $unwind$z900_d250_list64
$pdata$z900_d250_async32 DD imagerel z900_d250_async32
	DD	imagerel z900_d250_async32+89
	DD	imagerel $unwind$z900_d250_async32
$pdata$z900_d250_async64 DD imagerel z900_d250_async64
	DD	imagerel z900_d250_async64+88
	DD	imagerel $unwind$z900_d250_async64
pdata	ENDS
_DATA	SEGMENT
$SG169716 DB	'vmd250.c:358', 00H
	ORG $+3
$SG169717 DB	'vmd250.c:364', 00H
	ORG $+3
$SG169718 DB	'vmd250.c:366', 00H
	ORG $+3
$SG169723 DB	'vmd250.c:385', 00H
	ORG $+3
$SG169725 DB	'I', 00H
	ORG $+6
$SG169727 DB	'd250_bio_interrupt', 00H
	ORG $+5
$SG169726 DB	'HHC01905%s %04X triggered block I/O interrupt: code %4.4'
	DB	'X parm %16.16llX status %2.2X subcode %2.2X', 0aH, 00H
	ORG $+3
$SG169728 DB	'vmd250.c', 00H
	ORG $+3
$SG169754 DB	'I', 00H
	ORG $+2
$SG169729 DB	'vmd250.c:399', 00H
	ORG $+3
$SG169755 DB	'HHC01906%s %04X d250_init32 s %i o %lli b %lli e %lli', 0aH
	DB	00H
	ORG $+1
$SG169756 DB	'd250_init32', 00H
$SG169778 DB	'I', 00H
	ORG $+2
$SG169757 DB	'vmd250.c', 00H
	ORG $+3
$SG169819 DB	'I', 00H
	ORG $+2
$SG169779 DB	'HHC01906%s %04X d250_init32 s %i o %lli b %lli e %lli', 0aH
	DB	00H
	ORG $+1
$SG169780 DB	'd250_init64', 00H
$SG169833 DB	'E', 00H
	ORG $+2
$SG169781 DB	'vmd250.c', 00H
	ORG $+7
$SG169821 DB	'd250_init', 00H
	ORG $+6
$SG169832 DB	'malloc(%d)', 00H
	ORG $+5
$SG169834 DB	'HHC01908%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169820 DB	'HHC01907%s %04X d250_init BLKTAB: type %4.4X arch %i 512'
	DB	' %i 1024 %i 2048 %i 4096 %i', 0aH, 00H
	ORG $+3
$SG169822 DB	'vmd250.c', 00H
	ORG $+3
$SG169850 DB	'I', 00H
	ORG $+2
$SG169835 DB	'd250_init', 00H
	ORG $+2
$SG169867 DB	'I', 00H
	ORG $+2
$SG169836 DB	'vmd250.c', 00H
	ORG $+3
$SG169897 DB	'I', 00H
	ORG $+2
$SG169837 DB	'vmd250.c:628', 00H
	ORG $+3
$SG169840 DB	'vmd250.c:634', 00H
	ORG $+3
$SG169843 DB	'vmd250.c:655', 00H
	ORG $+3
$SG169847 DB	'vmd250.c:694', 00H
	ORG $+3
$SG169851 DB	'HHC01909%s %04X d250_preserve pending sense preserved', 0aH
	DB	00H
	ORG $+1
$SG169852 DB	'd250_preserve', 00H
	ORG $+2
$SG169853 DB	'vmd250.c', 00H
	ORG $+3
$SG169916 DB	'I', 00H
	ORG $+2
$SG169856 DB	'vmd250.c:720', 00H
	ORG $+3
$SG169857 DB	'vmd250.c:725', 00H
	ORG $+3
$SG169861 DB	'vmd250.c:735', 00H
	ORG $+3
$SG169863 DB	'vmd250.c:738', 00H
	ORG $+3
$SG169864 DB	'vmd250.c:740', 00H
	ORG $+3
$SG169868 DB	'HHC01920%s %04X d250_restore pending sense restored', 0aH
	DB	00H
	ORG $+3
$SG169869 DB	'd250_restore', 00H
	ORG $+3
$SG169870 DB	'vmd250.c', 00H
	ORG $+3
$SG169925 DB	'I', 00H
	ORG $+2
$SG169871 DB	'vmd250.c:757', 00H
	ORG $+3
$SG169890 DB	'vmd250.c:788', 00H
	ORG $+3
$SG169893 DB	'vmd250.c:795', 00H
	ORG $+3
$SG169895 DB	'vmd250.c:814', 00H
	ORG $+3
$SG169898 DB	'HHC01921%s %04X d250_remove block I/O environment remove'
	DB	'd', 0aH, 00H
	ORG $+1
$SG169948 DB	'I', 00H
	ORG $+2
$SG169899 DB	'd250_remove', 00H
$SG169959 DB	'I', 00H
	ORG $+2
$SG169900 DB	'vmd250.c', 00H
	ORG $+3
$SG170052 DB	'I', 00H
	ORG $+2
$SG169914 DB	'vmd250.c:836', 00H
	ORG $+3
$SG169917 DB	'HHC01922%s %04X d250_read %d-byte block (rel. to 0): %ll'
	DB	'd', 0aH, 00H
	ORG $+1
$SG170058 DB	'E', 00H
	ORG $+2
$SG169918 DB	'd250_read', 00H
	ORG $+2
$SG170065 DB	'E', 00H
	ORG $+2
$SG169919 DB	'vmd250.c', 00H
	ORG $+3
$SG170071 DB	'I', 00H
	ORG $+2
$SG169922 DB	'vmd250.c:844', 00H
	ORG $+3
$SG169926 DB	'HHC01923%s %04X d250_read FBA unit status %2.2X residual'
	DB	' %d', 0aH, 00H
	ORG $+3
$SG169927 DB	'd250_read', 00H
	ORG $+2
$SG170076 DB	'I', 00H
	ORG $+2
$SG169928 DB	'vmd250.c', 00H
	ORG $+3
$SG170086 DB	'I', 00H
	ORG $+2
$SG169930 DB	'vmd250.c:873', 00H
	ORG $+3
$SG169946 DB	'vmd250.c:900', 00H
	ORG $+3
$SG169949 DB	'HHC01922%s %04X d250_read %d-byte block (rel. to 0): %ll'
	DB	'd', 0aH, 00H
	ORG $+1
$SG170123 DB	'I', 00H
	ORG $+2
$SG169950 DB	'd250_write', 00H
	ORG $+1
$SG170129 DB	'I', 00H
	ORG $+2
$SG169951 DB	'vmd250.c', 00H
	ORG $+3
$SG170140 DB	'I', 00H
	ORG $+2
$SG169953 DB	'vmd250.c:908', 00H
	ORG $+3
$SG169956 DB	'vmd250.c:913', 00H
	ORG $+3
$SG169960 DB	'HHC01923%s %04X d250_read FBA unit status %2.2X residual'
	DB	' %d', 0aH, 00H
	ORG $+3
$SG169961 DB	'd250_write', 00H
	ORG $+1
$SG170147 DB	'I', 00H
	ORG $+2
$SG169962 DB	'vmd250.c', 00H
	ORG $+3
$SG170158 DB	'I', 00H
	ORG $+2
$SG169964 DB	'vmd250.c:941', 00H
	ORG $+3
$SG170054 DB	's370_d250_iorq32', 00H
	ORG $+7
$SG170053 DB	'HHC01924%s %04X async biopl %8.8X entries %d key %2.2X i'
	DB	'ntp %8.8X', 0aH, 00H
	ORG $+1
$SG170168 DB	'I', 00H
	ORG $+2
$SG170055 DB	'vmd250.c', 00H
	ORG $+3
$SG170174 DB	'I', 00H
	ORG $+2
$SG170057 DB	'malloc(%d)', 00H
	ORG $+1
$SG180317 DB	'I', 00H
	ORG $+2
$SG170059 DB	'HHC01908%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170060 DB	's370_d250_iorq32', 00H
	ORG $+3
$SG180323 DB	'E', 00H
	ORG $+2
$SG170061 DB	'vmd250.c', 00H
	ORG $+3
$SG180330 DB	'E', 00H
	ORG $+2
$SG170062 DB	'd250_async %4.4X', 00H
	ORG $+3
$SG180336 DB	'I', 00H
	ORG $+2
$SG170063 DB	'vmd250.c:1277', 00H
	ORG $+2
$SG170066 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG180341 DB	'I', 00H
	ORG $+2
$SG170067 DB	's370_d250_iorq32', 00H
	ORG $+3
$SG180351 DB	'I', 00H
	ORG $+2
$SG170068 DB	'vmd250.c', 00H
	ORG $+3
$SG180388 DB	'I', 00H
	ORG $+2
$SG170069 DB	'vmd250.c:1281', 00H
	ORG $+2
$SG170072 DB	'HHC01925%s %04X d250_iorq32 sync bioel %8.8X entries %d '
	DB	'key %2.2X', 0aH, 00H
	ORG $+1
$SG180394 DB	'I', 00H
	ORG $+2
$SG170073 DB	's370_d250_iorq32', 00H
	ORG $+3
$SG180405 DB	'I', 00H
	ORG $+2
$SG170074 DB	'vmd250.c', 00H
	ORG $+3
$SG180412 DB	'I', 00H
	ORG $+2
$SG170077 DB	'HHC01926%s %04X d250_iorq32 psc %d succeeded %d failed %'
	DB	'd', 0aH, 00H
	ORG $+1
$SG180422 DB	'I', 00H
	ORG $+2
$SG170078 DB	's370_d250_iorq32', 00H
	ORG $+3
$SG180431 DB	'I', 00H
	ORG $+2
$SG170079 DB	'vmd250.c', 00H
	ORG $+3
$SG180437 DB	'I', 00H
	ORG $+2
$SG170087 DB	'HHC01927%s d250_list32 error: psc %i', 0aH, 00H
	ORG $+2
$SG170088 DB	's370_d250_iorq32', 00H
	ORG $+3
$SG193467 DB	'I', 00H
	ORG $+2
$SG170089 DB	'vmd250.c', 00H
	ORG $+7
$SG170125 DB	's370_d250_list32', 00H
	ORG $+7
$SG170124 DB	'HHC01928%s %04X d250_list32 bios %i addr %16.16llX I/O k'
	DB	'ey %2.2X', 0aH, 00H
	ORG $+2
$SG193473 DB	'E', 00H
	ORG $+2
$SG170126 DB	'vmd250.c', 00H
	ORG $+7
$SG170131 DB	's370_d250_list32', 00H
	ORG $+7
$SG170130 DB	'HHC01929%s %04X d250_list32 xcode %4.4X bioe32 %8.8llX-%'
	DB	'8.8llX fetch key %2.2X', 0aH, 00H
$SG170132 DB	'vmd250.c', 00H
	ORG $+7
$SG170141 DB	'HHC01930%s %04X d250_list32 bioe %8.8llX oper %2.2X bloc'
	DB	'k %i buffer %8.8llX', 0aH, 00H
	ORG $+3
$SG170142 DB	's370_d250_list32', 00H
	ORG $+3
$SG193480 DB	'E', 00H
	ORG $+2
$SG170143 DB	'vmd250.c', 00H
	ORG $+7
$SG170149 DB	's370_d250_list32', 00H
	ORG $+7
$SG170148 DB	'HHC01931%s %04X d250_list32 xcode %4.4X rdbuf %8.8llX-%8'
	DB	'.8llX fetch key %2.2X', 0aH, 00H
	ORG $+1
$SG170150 DB	'vmd250.c', 00H
	ORG $+7
$SG170159 DB	'HHC01932%s %04X d250_list32 xcode %4.4X wrbuf %8.8llX-%8'
	DB	'.8llX store key %2.2X', 0aH, 00H
	ORG $+1
$SG170160 DB	's370_d250_list32', 00H
	ORG $+3
$SG193486 DB	'I', 00H
	ORG $+2
$SG170161 DB	'vmd250.c', 00H
	ORG $+7
$SG170170 DB	's370_d250_list32', 00H
	ORG $+7
$SG170169 DB	'HHC01933%s %04X d250_list32 xcode %4.4X status %8.8llX-%'
	DB	'8.8llX  store key %2.2X', 0aH, 00H
	ORG $+3
$SG193491 DB	'I', 00H
	ORG $+2
$SG170171 DB	'vmd250.c', 00H
	ORG $+3
$SG193501 DB	'I', 00H
	ORG $+2
$SG170175 DB	'HHC01934%s %04X d250_list32 bioe %8.8llX status %2.2X', 0aH
	DB	00H
	ORG $+1
$SG170176 DB	's370_d250_list32', 00H
	ORG $+3
$SG193538 DB	'I', 00H
	ORG $+2
$SG170177 DB	'vmd250.c', 00H
	ORG $+7
$SG180319 DB	's390_d250_iorq32', 00H
	ORG $+7
$SG180318 DB	'HHC01924%s %04X async biopl %8.8X entries %d key %2.2X i'
	DB	'ntp %8.8X', 0aH, 00H
	ORG $+1
$SG193544 DB	'I', 00H
	ORG $+2
$SG180320 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180322 DB	'malloc(%d)', 00H
	ORG $+1
$SG193555 DB	'I', 00H
	ORG $+2
$SG180324 DB	'HHC01908%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG180325 DB	's390_d250_iorq32', 00H
	ORG $+3
$SG193562 DB	'I', 00H
	ORG $+2
$SG180326 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180327 DB	'd250_async %4.4X', 00H
	ORG $+3
$SG193572 DB	'I', 00H
	ORG $+2
$SG180328 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c:1277', 00H
	ORG $+3
$SG180331 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG193581 DB	'I', 00H
	ORG $+2
$SG180332 DB	's390_d250_iorq32', 00H
	ORG $+3
$SG193587 DB	'I', 00H
	ORG $+2
$SG180333 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180334 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c:1281', 00H
	ORG $+3
$SG180338 DB	's390_d250_iorq32', 00H
	ORG $+7
$SG180337 DB	'HHC01925%s %04X d250_iorq32 sync bioel %8.8X entries %d '
	DB	'key %2.2X', 0aH, 00H
	ORG $+1
$SG193666 DB	'I', 00H
	ORG $+2
$SG180339 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180342 DB	'HHC01926%s %04X d250_iorq32 psc %d succeeded %d failed %'
	DB	'd', 0aH, 00H
	ORG $+1
$SG193672 DB	'E', 00H
	ORG $+2
$SG180343 DB	's390_d250_iorq32', 00H
	ORG $+3
$SG193679 DB	'E', 00H
	ORG $+2
$SG180344 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180352 DB	'HHC01927%s d250_list32 error: psc %i', 0aH, 00H
	ORG $+2
$SG180353 DB	's390_d250_iorq32', 00H
	ORG $+3
$SG193685 DB	'I', 00H
	ORG $+2
$SG180354 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180390 DB	's390_d250_list32', 00H
	ORG $+7
$SG180389 DB	'HHC01928%s %04X d250_list32 bios %i addr %16.16llX I/O k'
	DB	'ey %2.2X', 0aH, 00H
	ORG $+2
$SG193690 DB	'I', 00H
	ORG $+2
$SG180391 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180395 DB	'HHC01929%s %04X d250_list32 xcode %4.4X bioe32 %8.8llX-%'
	DB	'8.8llX fetch key %2.2X', 0aH, 00H
$SG180396 DB	's390_d250_list32', 00H
	ORG $+3
$SG193700 DB	'E', 00H
	ORG $+2
$SG180397 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180406 DB	'HHC01930%s %04X d250_list32 bioe %8.8llX oper %2.2X bloc'
	DB	'k %i buffer %8.8llX', 0aH, 00H
	ORG $+3
$SG180407 DB	's390_d250_list32', 00H
	ORG $+3
$SG193737 DB	'I', 00H
	ORG $+2
$SG180408 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180413 DB	'HHC01931%s %04X d250_list32 xcode %4.4X rdbuf %8.8llX-%8'
	DB	'.8llX fetch key %2.2X', 0aH, 00H
	ORG $+1
$SG180414 DB	's390_d250_list32', 00H
	ORG $+3
$SG193743 DB	'I', 00H
	ORG $+2
$SG180415 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180423 DB	'HHC01932%s %04X d250_list32 xcode %4.4X wrbuf %8.8llX-%8'
	DB	'.8llX store key %2.2X', 0aH, 00H
	ORG $+1
$SG180424 DB	's390_d250_list32', 00H
	ORG $+3
$SG193754 DB	'I', 00H
	ORG $+2
$SG180425 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180432 DB	'HHC01933%s %04X d250_list32 xcode %4.4X status %8.8llX-%'
	DB	'8.8llX  store key %2.2X', 0aH, 00H
	ORG $+3
$SG193761 DB	'I', 00H
	ORG $+2
$SG180433 DB	's390_d250_list32', 00H
	ORG $+3
$SG193771 DB	'I', 00H
	ORG $+2
$SG180434 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG180438 DB	'HHC01934%s %04X d250_list32 bioe %8.8llX status %2.2X', 0aH
	DB	00H
	ORG $+1
$SG180439 DB	's390_d250_list32', 00H
	ORG $+3
$SG193780 DB	'I', 00H
	ORG $+2
$SG180440 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193468 DB	'HHC01924%s %04X async biopl %8.8X entries %d key %2.2X i'
	DB	'ntp %8.8X', 0aH, 00H
	ORG $+1
$SG193786 DB	'I', 00H
	ORG $+2
$SG193469 DB	'z900_d250_iorq32', 00H
	ORG $+7
$SG193470 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193472 DB	'malloc(%d)', 00H
	ORG $+5
$SG193474 DB	'HHC01908%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG193475 DB	'z900_d250_iorq32', 00H
	ORG $+7
$SG193476 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193477 DB	'd250_async %4.4X', 00H
	ORG $+7
$SG193478 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c:1277', 00H
	ORG $+3
$SG193481 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG193482 DB	'z900_d250_iorq32', 00H
	ORG $+7
$SG193483 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193484 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c:1281', 00H
	ORG $+3
$SG193487 DB	'HHC01925%s %04X d250_iorq32 sync bioel %8.8X entries %d '
	DB	'key %2.2X', 0aH, 00H
	ORG $+5
$SG193488 DB	'z900_d250_iorq32', 00H
	ORG $+7
$SG193489 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193492 DB	'HHC01926%s %04X d250_iorq32 psc %d succeeded %d failed %'
	DB	'd', 0aH, 00H
	ORG $+5
$SG193493 DB	'z900_d250_iorq32', 00H
	ORG $+7
$SG193494 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193502 DB	'HHC01927%s d250_list32 error: psc %i', 0aH, 00H
	ORG $+2
$SG193503 DB	'z900_d250_iorq32', 00H
	ORG $+7
$SG193504 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193539 DB	'HHC01928%s %04X d250_list32 bios %i addr %16.16llX I/O k'
	DB	'ey %2.2X', 0aH, 00H
	ORG $+6
$SG193540 DB	'z900_d250_list32', 00H
	ORG $+7
$SG193541 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
	ORG $+8
$SG193545 DB	'HHC01929%s %04X d250_list32 xcode %4.4X bioe32 %8.8llX-%'
	DB	'8.8llX fetch key %2.2X', 0aH, 00H
$SG193546 DB	'z900_d250_list32', 00H
	ORG $+7
$SG193547 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193556 DB	'HHC01930%s %04X d250_list32 bioe %8.8llX oper %2.2X bloc'
	DB	'k %i buffer %8.8llX', 0aH, 00H
	ORG $+3
$SG193557 DB	'z900_d250_list32', 00H
	ORG $+7
$SG193558 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193563 DB	'HHC01931%s %04X d250_list32 xcode %4.4X rdbuf %8.8llX-%8'
	DB	'.8llX fetch key %2.2X', 0aH, 00H
	ORG $+1
$SG193564 DB	'z900_d250_list32', 00H
	ORG $+7
$SG193565 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193573 DB	'HHC01932%s %04X d250_list32 xcode %4.4X wrbuf %8.8llX-%8'
	DB	'.8llX store key %2.2X', 0aH, 00H
	ORG $+1
$SG193574 DB	'z900_d250_list32', 00H
	ORG $+7
$SG193575 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193582 DB	'HHC01933%s %04X d250_list32 xcode %4.4X status %8.8llX-%'
	DB	'8.8llX  store key %2.2X', 0aH, 00H
	ORG $+7
$SG193583 DB	'z900_d250_list32', 00H
	ORG $+7
$SG193584 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193588 DB	'HHC01934%s %04X d250_list32 bioe %8.8llX status %2.2X', 0aH
	DB	00H
	ORG $+1
$SG193589 DB	'z900_d250_list32', 00H
	ORG $+7
$SG193590 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193667 DB	'HHC01935%s %04X async bioel %16.16llX entries %lld key %'
	DB	'2.2X intp %16.16llX', 0aH, 00H
	ORG $+3
$SG193668 DB	'z900_d250_iorq64', 00H
	ORG $+7
$SG193669 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193671 DB	'malloc(%d)', 00H
	ORG $+5
$SG193673 DB	'HHC01908%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG193674 DB	'z900_d250_iorq64', 00H
	ORG $+7
$SG193675 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193676 DB	'd250_async %4.4X', 00H
	ORG $+7
$SG193677 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c:1884', 00H
	ORG $+3
$SG193680 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG193681 DB	'z900_d250_iorq64', 00H
	ORG $+7
$SG193682 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193683 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c:1888', 00H
	ORG $+11
$SG193686 DB	'HHC01936%s %04X d250_iorq64 sync bioel %16.16llX entries'
	DB	' %lld key %2.2X', 0aH, 00H
	ORG $+7
$SG193687 DB	'z900_d250_iorq64', 00H
	ORG $+7
$SG193688 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193691 DB	'HHC01937%s %04X d250_iorq64 psc %d succeeded %d failed %'
	DB	'd', 0aH, 00H
	ORG $+5
$SG193692 DB	'z900_d250_iorq64', 00H
	ORG $+7
$SG193693 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193701 DB	'HHC01938%s d250_list64 error: psc %i', 0aH, 00H
	ORG $+2
$SG193702 DB	'z900_d250_iorq64', 00H
	ORG $+7
$SG193703 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
	ORG $+8
$SG193738 DB	'HHC01939%s %04X d250_list64 bioes %lli addr %16.16llX I/'
	DB	'O key %2.2X', 0aH, 00H
	ORG $+3
$SG193739 DB	'z900_d250_list64', 00H
	ORG $+7
$SG193740 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
	ORG $+8
$SG193744 DB	'HHC01940%s %04X d250_list64 xcode %4.4X bioe64 %16.16llX'
	DB	'-%16.16llX fetch key %2.2X', 0aH, 00H
	ORG $+4
$SG193745 DB	'z900_d250_list64', 00H
	ORG $+7
$SG193746 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
	ORG $+8
$SG193755 DB	'HHC01941%s %04X d250_list64 bioe %16.16llX oper %2.2X bl'
	DB	'ock %lli buffer %16.16llX', 0aH, 00H
	ORG $+5
$SG193756 DB	'z900_d250_list64', 00H
	ORG $+7
$SG193757 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
	ORG $+8
$SG193762 DB	'HHC01942%s %04X d250_list64 xcode %4.4X readbuf %16.16ll'
	DB	'X-%16.16llX fetch key %2.2X', 0aH, 00H
	ORG $+3
$SG193763 DB	'z900_d250_list64', 00H
	ORG $+7
$SG193764 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
	ORG $+8
$SG193772 DB	'HHC01943%s %04X d250_list64 xcode %4.4X writebuf %16.16l'
	DB	'lX-%16.16llX store key %2.2X', 0aH, 00H
	ORG $+2
$SG193773 DB	'z900_d250_list64', 00H
	ORG $+7
$SG193774 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
	ORG $+8
$SG193781 DB	'HHC01944%s %04X d250_list64 xcode %4.4X status %16.16llX'
	DB	'-%16.16llX store key %2.2X', 0aH, 00H
	ORG $+4
$SG193782 DB	'z900_d250_list64', 00H
	ORG $+7
$SG193783 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
$SG193787 DB	'HHC01945%s %04X d250_list64 bioe %16.16llX status %2.2X', 0aH
	DB	00H
	ORG $+7
$SG193788 DB	'z900_d250_list64', 00H
	ORG $+7
$SG193789 DB	'C:\papa\MyGit\hyperion-zvector\vmd250.c', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_4K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_4K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_2K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_d250_list64
	DD	01cH
	DD	0bbcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_d250_iorq64
	DD	027H
	DD	07cdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_d250_list32
	DD	01cH
	DD	0bceH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_d250_iorq32
	DD	027H
	DD	0790H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_vm_blockio
	DD	01eH
	DD	028cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_d250_list32
	DD	01cH
	DD	0bceH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_d250_iorq32
	DD	027H
	DD	0790H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_vm_blockio
	DD	01eH
	DD	0218H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_d250_list32
	DD	01cH
	DD	0c33H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_d250_iorq32
	DD	027H
	DD	0790H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:d250_remove
	DD	027H
	DD	021dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:d250_init
	DD	024H
	DD	0541H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:d250_init64
	DD	026H
	DD	0244H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:d250_init32
	DD	026H
	DD	0222H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_vm_blockio
	DD	01eH
	DD	01fcH
voltbl	ENDS
xdata	SEGMENT
$unwind$s370_vm_blockio DD 022619H
	DD	0150114H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpus_mask DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$d250_init32 DD 032e19H
	DD	01c011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$d250_init64 DD 032e19H
	DD	01c011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$d250_init DD 022c19H
	DD	01d011aH
	DD	imagerel __GSHandlerCheck
	DD	0d8H
$unwind$d250_preserve DD 030b01H
	DD	07007a20bH
	DD	06006H
$unwind$d250_restore DD 030b01H
	DD	07007a20bH
	DD	06006H
$unwind$d250_read DD 011801H
	DD	0e218H
$unwind$d250_write DD 011801H
	DD	0e218H
$unwind$d250_remove DD 042f19H
	DD	015011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$d250_bio_interrupt DD 021b01H
	DD	011011bH
$unwind$s370_d250_iorq32 DD 042f19H
	DD	02f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0168H
$unwind$s370_d250_list32 DD 042419H
	DD	0230112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$s370_d250_addrck DD 011801H
	DD	06218H
$unwind$s370_d250_async32 DD 010901H
	DD	06209H
$unwind$s390_vm_blockio DD 022619H
	DD	0150114H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s390_d250_iorq32 DD 042f19H
	DD	02f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0168H
$unwind$s390_d250_list32 DD 042419H
	DD	0230112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$s390_d250_addrck DD 011801H
	DD	06218H
$unwind$s390_d250_async32 DD 010901H
	DD	06209H
$unwind$z900_vm_blockio DD 022619H
	DD	0150114H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_d250_iorq32 DD 042f19H
	DD	02f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0168H
$unwind$z900_d250_list32 DD 042419H
	DD	0230112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$z900_d250_addrck DD 011801H
	DD	06218H
$unwind$z900_d250_iorq64 DD 042f19H
	DD	033011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0188H
$unwind$z900_d250_list64 DD 042419H
	DD	0250112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$z900_d250_async32 DD 010901H
	DD	06209H
$unwind$z900_d250_async64 DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
psc$ = 32
ioctl$ = 40
ctl$ = 64
z900_d250_async64 PROC

; 1747 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1748 : IOCTL64 *ioctl;    /* 64-bit IO request controls  */
; 1749 : BYTE     psc;      /* List processing status code */
; 1750 : 
; 1751 :    /* Fetch the IO request control structure */
; 1752 :    ioctl=(IOCTL64 *)ctl;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ctl$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR ioctl$[rsp], rax

; 1753 : 
; 1754 :    /* Call the 32-bit BIOE request processor on this async thread*/
; 1755 :    psc=ARCH_DEP(d250_list64)(ioctl, ASYNC);

  00013	ba 01 00 00 00	 mov	 edx, 1
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0001d	e8 00 00 00 00	 call	 z900_d250_list64
  00022	88 44 24 20	 mov	 BYTE PTR psc$[rsp], al

; 1756 : 
; 1757 :    d250_bio_interrupt(ioctl->dev, ioctl->intrparm, psc, 0x07);

  00026	41 b1 07	 mov	 r9b, 7
  00029	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR psc$[rsp]
  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR ioctl$[rsp]
  00034	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR ioctl$[rsp]
  0003d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00041	e8 00 00 00 00	 call	 d250_bio_interrupt

; 1758 : 
; 1759 :    free(ioctl);

  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1760 :    return NULL;

  00051	33 c0		 xor	 eax, eax

; 1761 : 
; 1762 : } /* end function ARCH_DEP(d250_async64) */

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
z900_d250_async64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
psc$ = 32
ioctl$ = 40
ctl$ = 64
z900_d250_async32 PROC

; 1153 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1154 : IOCTL32 *ioctl;    /* 32-bit IO request controls    */
; 1155 : BYTE    psc;       /* List processing status code   */
; 1156 : 
; 1157 :    /* Fetch the IO request control structure */
; 1158 :    ioctl=(IOCTL32 *)ctl;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ctl$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR ioctl$[rsp], rax

; 1159 : 
; 1160 :    /* Call the 32-bit BIOE request processor on this async thread*/
; 1161 :    psc=ARCH_DEP(d250_list32)(ioctl, ASYNC);

  00013	ba 01 00 00 00	 mov	 edx, 1
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0001d	e8 00 00 00 00	 call	 z900_d250_list32
  00022	88 44 24 20	 mov	 BYTE PTR psc$[rsp], al

; 1162 : 
; 1163 :    /* Trigger the external interrupt here */
; 1164 : 
; 1165 :    d250_bio_interrupt(ioctl->dev, ioctl->intrparm, psc, 0x03);

  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR ioctl$[rsp]
  0002b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002e	41 b1 03	 mov	 r9b, 3
  00031	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR psc$[rsp]
  00037	8b d0		 mov	 edx, eax
  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR ioctl$[rsp]
  0003e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00042	e8 00 00 00 00	 call	 d250_bio_interrupt

; 1166 : 
; 1167 :    free(ioctl);

  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1168 :    return NULL;

  00052	33 c0		 xor	 eax, eax

; 1169 : } /* end function ARCH_DEP(d250_async32) */

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
z900_d250_async32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
status$ = 96
xcode$ = 100
bioebeg$ = 104
bufbeg$ = 112
block$ = 120
bufend$ = 128
tv284 = 136
tv343 = 140
physblk$ = 144
blocks$ = 148
blknum$ = 152
tv70 = 160
tv78 = 164
tv149 = 168
tv153 = 172
tv157 = 176
tv226 = 180
tv231 = 184
tv264 = 188
tv268 = 192
tv272 = 196
tv323 = 200
tv327 = 204
tv331 = 208
tv387 = 212
tv429 = 216
tv434 = 220
bioeend$ = 224
tv389 = 232
tv391 = 240
bioe$ = 248
__$ArrayPad$ = 272
ioctl$ = 320
async$ = 328
z900_d250_list64 PROC

; 1948 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1949 : BIOE64 bioe;      /* 32-bit BIOE fetched from absolute storage */
; 1950 : RADR   bioebeg;   /* Starting address of the BIOE              */
; 1951 : RADR   bioeend;   /* Address of last byte of BIOE              */
; 1952 : U16    xcode;     /* Detected exception condition              */
; 1953 : int    blocks;    /* Number of blocks being processed          */
; 1954 : int    block;     /* counter used in block I/O loop            */
; 1955 : S64    blknum;    /* Block number of the request               */
; 1956 : BYTE   status;    /* Returned BIOE status                      */
; 1957 : /* Passed to generic block I/O function                        */
; 1958 : int    physblk;   /* Physical block number                     */
; 1959 : RADR   bufbeg;    /* Address where the read/write will occur   */
; 1960 : RADR   bufend;    /* Last byte read or written                 */
; 1961 : 
; 1962 : 
; 1963 :    xcode = 0;   /* Initialize the address check exception code */

  00024	33 c0		 xor	 eax, eax
  00026	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1964 :    status = 0;

  0002b	c6 44 24 60 00	 mov	 BYTE PTR status$[rsp], 0

; 1965 : 
; 1966 :    /* Preserve pending sense if any and establish my ownership */
; 1967 :    /* of the device by reserving it if shared and locking it   */
; 1968 :    if (ioctl->dev->ccwtrace)

  00030	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00038	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00042	c1 e8 0f	 shr	 eax, 15
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 a9 00 00
	00		 je	 $LN12@z900_d250_

; 1969 :    {
; 1970 :       WRMSG (HHC01939, "I",

  00050	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00058	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  0005c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv70[rsp], eax
  00063	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0006b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0006f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00073	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv78[rsp], ecx
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00085	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv70[rsp]
  0008c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00090	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00098	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0009c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000a1	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  000a9	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000ad	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000b2	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv78[rsp]
  000b9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193737
  000c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193738
  000d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000da	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193739
  000e7	ba b7 07 00 00	 mov	 edx, 1975		; 000007b7H
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193740
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@z900_d250_:

; 1971 :                ioctl->dev->devnum,
; 1972 :                ioctl->blkcount,
; 1973 :                (RADR)ioctl->listaddr,
; 1974 :                ioctl->key
; 1975 :                );
; 1976 :    }
; 1977 : 
; 1978 :    /* Take ownership of the device */
; 1979 :    d250_preserve(ioctl->dev);

  000f9	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00101	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00105	e8 00 00 00 00	 call	 d250_preserve

; 1980 :    /* Note: the DEVBLK is now locked */
; 1981 : 
; 1982 :    if (!ioctl->dev->vmd250env)

  0010a	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00112	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00116	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  0011e	75 1b		 jne	 SHORT $LN13@z900_d250_

; 1983 :    {
; 1984 :        d250_restore(ioctl->dev);

  00120	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00128	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0012c	e8 00 00 00 00	 call	 d250_restore

; 1985 :        /* Note: the device lock is now released */
; 1986 :        return PSC_REMOVED;

  00131	b8 03 00 00 00	 mov	 eax, 3
  00136	e9 81 0a 00 00	 jmp	 $LN1@z900_d250_
$LN13@z900_d250_:

; 1987 :    }
; 1988 : 
; 1989 :    blocks=(int)ioctl->blkcount;

  0013b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00143	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00146	89 84 24 94 00
	00 00		 mov	 DWORD PTR blocks$[rsp], eax

; 1990 :    bioebeg=ioctl->listaddr & AMASK64 ;

  0014d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00155	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00159	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1991 : 
; 1992 :    /* Process each of the BIOE's supplied by the BIOPL count field */
; 1993 :    for ( block = 0 ; block < blocks ; block++ )

  0015e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR block$[rsp], 0
  00166	eb 0a		 jmp	 SHORT $LN4@z900_d250_
$LN2@z900_d250_:
  00168	8b 44 24 78	 mov	 eax, DWORD PTR block$[rsp]
  0016c	ff c0		 inc	 eax
  0016e	89 44 24 78	 mov	 DWORD PTR block$[rsp], eax
$LN4@z900_d250_:
  00172	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR blocks$[rsp]
  00179	39 44 24 78	 cmp	 DWORD PTR block$[rsp], eax
  0017d	0f 8d c7 09 00
	00		 jge	 $LN3@z900_d250_

; 1994 :    {
; 1995 :       status = 0xFF;  /* Set undefined status */

  00183	c6 44 24 60 ff	 mov	 BYTE PTR status$[rsp], 255 ; 000000ffH

; 1996 : 
; 1997 :       bioeend=( bioebeg + sizeof(BIOE32) - 1 ) & AMASK31;

  00188	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  0018d	48 83 c0 0f	 add	 rax, 15
  00191	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  00197	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR bioeend$[rsp], rax

; 1998 :       xcode=ARCH_DEP(d250_addrck)

  0019f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001af	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001b7	44 0f b6 48 30	 movzx	 r9d, BYTE PTR [rax+48]
  001bc	41 b8 04 00 00
	00		 mov	 r8d, 4
  001c2	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR bioeend$[rsp]
  001ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  001cf	e8 00 00 00 00	 call	 z900_d250_addrck
  001d4	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1999 :             (bioebeg,bioeend,ACCTYPE_READ,ioctl->key,ioctl->regs);
; 2000 :       if (ioctl->dev->ccwtrace)

  001d9	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001e1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001e5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001eb	c1 e8 0f	 shr	 eax, 15
  001ee	83 e0 01	 and	 eax, 1
  001f1	85 c0		 test	 eax, eax
  001f3	0f 84 b5 00 00
	00		 je	 $LN14@z900_d250_

; 2001 :       {
; 2002 :          WRMSG(HHC01940, "I",ioctl->dev->devnum,xcode,bioebeg,bioeend,ioctl->key);

  001f9	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00201	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  00205	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  0020c	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00211	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv153[rsp], ecx
  00218	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00220	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00224	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00228	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv157[rsp], edx
  0022f	b9 01 00 00 00	 mov	 ecx, 1
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023a	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  00241	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00245	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR bioeend$[rsp]
  0024d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00252	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00257	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0025c	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  00263	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00267	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv157[rsp]
  0026e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00272	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193743
  00279	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0027e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193744
  00285	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0028a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00295	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193745
  0029c	ba d2 07 00 00	 mov	 edx, 2002		; 000007d2H
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193746
  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@z900_d250_:

; 2003 :       }
; 2004 :       if ( xcode )

  002ae	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  002b3	85 c0		 test	 eax, eax
  002b5	74 05		 je	 SHORT $LN15@z900_d250_

; 2005 :       {
; 2006 :          break;

  002b7	e9 8e 08 00 00	 jmp	 $LN3@z900_d250_
$LN15@z900_d250_:

; 2007 :       }
; 2008 : 
; 2009 :       /* Fetch the BIOE from storage */
; 2010 :       memcpy(&bioe,ioctl->regs->mainstor+bioebeg,sizeof(BIOE64));

  002bc	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  002c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c7	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002ce	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR bioe$[rsp]
  002d6	48 8b 54 24 68	 mov	 rdx, QWORD PTR bioebeg$[rsp]
  002db	48 8b f9	 mov	 rdi, rcx
  002de	48 8d 34 10	 lea	 rsi, QWORD PTR [rax+rdx]
  002e2	b9 18 00 00 00	 mov	 ecx, 24
  002e7	f3 a4		 rep movsb

; 2011 :       ARCH_DEP( or_storage_key )( bioebeg, STORKEY_REF );

  002e9	b2 04		 mov	 dl, 4
  002eb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  002f0	e8 00 00 00 00	 call	 z900_or_storage_key

; 2012 :       ARCH_DEP( or_storage_key )( bioeend, STORKEY_REF );

  002f5	b2 04		 mov	 dl, 4
  002f7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR bioeend$[rsp]
  002ff	e8 00 00 00 00	 call	 z900_or_storage_key
$LN7@z900_d250_:

; 2013 : 
; 2014 :       /* Process a single BIOE */
; 2015 :       do
; 2016 :       {
; 2017 : 
; 2018 :          /* Make sure reserved field is zeros */
; 2019 :          if ( bioe.resv1[0]!=0x00 || bioe.resv1[1]!=0x00 )

  00304	b8 01 00 00 00	 mov	 eax, 1
  00309	48 6b c0 00	 imul	 rax, rax, 0
  0030d	0f b6 84 04 fa
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp+rax+2]
  00315	85 c0		 test	 eax, eax
  00317	75 15		 jne	 SHORT $LN17@z900_d250_
  00319	b8 01 00 00 00	 mov	 eax, 1
  0031e	48 6b c0 01	 imul	 rax, rax, 1
  00322	0f b6 84 04 fa
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp+rax+2]
  0032a	85 c0		 test	 eax, eax
  0032c	74 0a		 je	 SHORT $LN16@z900_d250_
$LN17@z900_d250_:

; 2020 :          {
; 2021 :             status=BIOE_NOTZERO;

  0032e	c6 44 24 60 0b	 mov	 BYTE PTR status$[rsp], 11

; 2022 :             continue;

  00333	e9 9e 05 00 00	 jmp	 $LN5@z900_d250_
$LN16@z900_d250_:

; 2023 :          }
; 2024 : 
; 2025 :          /* Fetch and validate block number */
; 2026 :          FETCH_DW(blknum,&bioe.blknum);

  00338	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bioe$[rsp+8]
  00340	e8 00 00 00 00	 call	 fetch_dw_noswap
  00345	48 8b c8	 mov	 rcx, rax
  00348	e8 00 00 00 00	 call	 _byteswap_uint64
  0034d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR blknum$[rsp], rax

; 2027 :          if ( (blknum < ioctl->dev->vmd250env->begblk) ||

  00355	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0035d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00361	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  00368	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0036c	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR blknum$[rsp], rax
  00374	7c 21		 jl	 SHORT $LN19@z900_d250_
  00376	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0037e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00382	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  00389	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0038d	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR blknum$[rsp], rax
  00395	7e 0a		 jle	 SHORT $LN18@z900_d250_
$LN19@z900_d250_:

; 2028 :               (blknum > ioctl->dev->vmd250env->endblk)
; 2029 :             )
; 2030 :          {
; 2031 :             status=BIOE_BADBLOCK;

  00397	c6 44 24 60 01	 mov	 BYTE PTR status$[rsp], 1

; 2032 :             continue;

  0039c	e9 35 05 00 00	 jmp	 $LN5@z900_d250_
$LN18@z900_d250_:

; 2033 :          }
; 2034 : 
; 2035 :          /* Fetch the storage address used for I/O */
; 2036 :          FETCH_DW(bufbeg,&bioe.bufaddr);

  003a1	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR bioe$[rsp+16]
  003a9	e8 00 00 00 00	 call	 fetch_dw_noswap
  003ae	48 8b c8	 mov	 rcx, rax
  003b1	e8 00 00 00 00	 call	 _byteswap_uint64
  003b6	48 89 44 24 70	 mov	 QWORD PTR bufbeg$[rsp], rax

; 2037 :          bufbeg &= AMASK64;

  003bb	48 8b 44 24 70	 mov	 rax, QWORD PTR bufbeg$[rsp]
  003c0	48 89 44 24 70	 mov	 QWORD PTR bufbeg$[rsp], rax

; 2038 : 
; 2039 :          /* Ensure the environment still exists */
; 2040 :          if (!ioctl->dev->vmd250env)

  003c5	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  003cd	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003d1	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  003d9	75 20		 jne	 SHORT $LN20@z900_d250_

; 2041 :          {
; 2042 :             d250_restore(ioctl->dev);

  003db	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  003e3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003e7	e8 00 00 00 00	 call	 d250_restore

; 2043 :             /* Note: the device lock is now released */
; 2044 :             status=BIOE_ABORTED;

  003ec	c6 44 24 60 0c	 mov	 BYTE PTR status$[rsp], 12

; 2045 :             return PSC_REMOVED;

  003f1	b8 03 00 00 00	 mov	 eax, 3
  003f6	e9 c1 07 00 00	 jmp	 $LN1@z900_d250_
$LN20@z900_d250_:

; 2046 :          }
; 2047 : 
; 2048 :          /* The I/O handler routines are normally called without the  */
; 2049 :          /* device lock being held.  The device is reserved by the    */
; 2050 :          /* busy status.                                              */
; 2051 : 
; 2052 :          /* Determine the last byte of the I/O buffer */
; 2053 :          bufend=( bufbeg + ioctl->dev->vmd250env->blksiz -1 ) & AMASK64 ;

  003fb	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00403	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00407	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0040e	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00412	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00417	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0041c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR bufend$[rsp], rax

; 2054 : 
; 2055 :          if (ioctl->dev->ccwtrace)

  00424	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0042c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00430	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00436	c1 e8 0f	 shr	 eax, 15
  00439	83 e0 01	 and	 eax, 1
  0043c	85 c0		 test	 eax, eax
  0043e	0f 84 a4 00 00
	00		 je	 $LN21@z900_d250_

; 2056 :          {
; 2057 :             WRMSG (HHC01941, "I",

  00444	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  0044c	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv226[rsp], eax
  00453	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0045b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0045f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00463	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv231[rsp], ecx
  0046a	b9 01 00 00 00	 mov	 ecx, 1
  0046f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00475	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  0047a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0047f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR blknum$[rsp]
  00487	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0048c	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv226[rsp]
  00493	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00497	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  0049c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004a1	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv231[rsp]
  004a8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193754
  004b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193755
  004bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  004cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193756
  004d6	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  004db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193757
  004e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@z900_d250_:

; 2058 :                      ioctl->dev->devnum,
; 2059 :                      bioebeg,
; 2060 :                      bioe.type,
; 2061 :                      blknum,
; 2062 :                      bufbeg
; 2063 :                     );
; 2064 :          }
; 2065 : 
; 2066 :          /* Determine the physical block on the device relative to zero */
; 2067 :          physblk=(S64)blknum+ioctl->dev->vmd250env->offset-1;

  004e8	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  004f0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  004f4	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  004fb	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  004ff	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR blknum$[rsp]
  00507	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0050c	89 84 24 90 00
	00 00		 mov	 DWORD PTR physblk$[rsp], eax

; 2068 :          /* The read/write routines will convert this to a physical disk */
; 2069 :          /* location for reading or writing                              */
; 2070 : 
; 2071 :          if (bioe.type == BIOE_READ)

  00513	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  0051b	83 f8 02	 cmp	 eax, 2
  0051e	0f 85 c1 01 00
	00		 jne	 $LN22@z900_d250_

; 2072 :          {
; 2073 :             xcode=ARCH_DEP(d250_addrck)

  00524	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0052c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0052f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00534	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0053c	44 0f b6 48 30	 movzx	 r9d, BYTE PTR [rax+48]
  00541	41 b8 04 00 00
	00		 mov	 r8d, 4
  00547	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufend$[rsp]
  0054f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00554	e8 00 00 00 00	 call	 z900_d250_addrck
  00559	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 2074 :                   (bufbeg,bufend,ACCTYPE_READ,ioctl->key,ioctl->regs);
; 2075 :             if (ioctl->dev->ccwtrace)

  0055e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00566	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0056a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00570	c1 e8 0f	 shr	 eax, 15
  00573	83 e0 01	 and	 eax, 1
  00576	85 c0		 test	 eax, eax
  00578	0f 84 b5 00 00
	00		 je	 $LN24@z900_d250_

; 2076 :             {
; 2077 :                WRMSG(HHC01942,"I",

  0057e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00586	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  0058a	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv264[rsp], eax
  00591	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00596	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv268[rsp], ecx
  0059d	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  005a5	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  005a9	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  005ad	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv272[rsp], edx
  005b4	b9 01 00 00 00	 mov	 ecx, 1
  005b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005bf	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv264[rsp]
  005c6	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  005ca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  005d2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005d7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  005dc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005e1	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv268[rsp]
  005e8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005ec	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv272[rsp]
  005f3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193761
  005fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00603	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193762
  0060a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0060f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00614	41 b9 03 00 00
	00		 mov	 r9d, 3
  0061a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193763
  00621	ba 1e 08 00 00	 mov	 edx, 2078		; 0000081eH
  00626	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193764
  0062d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@z900_d250_:

; 2078 :                        ioctl->dev->devnum,xcode,bufbeg,bufend,ioctl->key);
; 2079 :             }
; 2080 :             switch ( xcode )

  00633	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00638	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv284[rsp], eax
  0063f	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR tv284[rsp], 4
  00647	74 16		 je	 SHORT $LN26@z900_d250_
  00649	83 bc 24 88 00
	00 00 05	 cmp	 DWORD PTR tv284[rsp], 5
  00651	74 02		 je	 SHORT $LN25@z900_d250_
  00653	eb 14		 jmp	 SHORT $LN8@z900_d250_
$LN25@z900_d250_:

; 2081 :             {
; 2082 :                case PGM_ADDRESSING_EXCEPTION:
; 2083 :                   status=BIOE_ADDREXC;

  00655	c6 44 24 60 02	 mov	 BYTE PTR status$[rsp], 2

; 2084 :                   continue;

  0065a	e9 77 02 00 00	 jmp	 $LN5@z900_d250_
$LN26@z900_d250_:

; 2085 :                case PGM_PROTECTION_EXCEPTION:
; 2086 :                   status=BIOE_PROTEXC;

  0065f	c6 44 24 60 07	 mov	 BYTE PTR status$[rsp], 7

; 2087 :                   continue;

  00664	e9 6d 02 00 00	 jmp	 $LN5@z900_d250_
$LN8@z900_d250_:

; 2088 :             }
; 2089 :             /* At this point, the block number has been validated */
; 2090 :             /* and the buffer is addressable and accessible       */
; 2091 :             status=d250_read(ioctl->dev,

  00669	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00671	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00674	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0067b	48 03 44 24 70	 add	 rax, QWORD PTR bufbeg$[rsp]
  00680	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00688	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0068c	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  00693	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR physblk$[rsp]
  0069b	4c 8b c8	 mov	 r9, rax
  0069e	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  006a2	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  006aa	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  006ae	e8 00 00 00 00	 call	 d250_read
  006b3	88 44 24 60	 mov	 BYTE PTR status$[rsp], al

; 2092 :                                physblk,
; 2093 :                                ioctl->dev->vmd250env->blksiz,
; 2094 :                                ioctl->regs->mainstor+bufbeg);
; 2095 : 
; 2096 :             /* Set I/O storage key references if successful */
; 2097 :             if (!status)

  006b7	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  006bc	85 c0		 test	 eax, eax
  006be	75 1b		 jne	 SHORT $LN27@z900_d250_

; 2098 :             {
; 2099 :                ARCH_DEP( or_storage_key )( bufbeg, STORKEY_REF );

  006c0	b2 04		 mov	 dl, 4
  006c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  006c7	e8 00 00 00 00	 call	 z900_or_storage_key

; 2100 :                ARCH_DEP( or_storage_key )( bufend, STORKEY_REF );

  006cc	b2 04		 mov	 dl, 4
  006ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  006d6	e8 00 00 00 00	 call	 z900_or_storage_key
$LN27@z900_d250_:

; 2101 :             }
; 2102 : 
; 2103 :             continue;

  006db	e9 f6 01 00 00	 jmp	 $LN5@z900_d250_

; 2104 :          }  /* end of BIOE_READ */

  006e0	e9 f1 01 00 00	 jmp	 $LN23@z900_d250_
$LN22@z900_d250_:

; 2105 :          else
; 2106 :          {  if (bioe.type == BIOE_WRITE)

  006e5	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  006ed	83 f8 01	 cmp	 eax, 1
  006f0	0f 85 db 01 00
	00		 jne	 $LN28@z900_d250_

; 2107 :             {
; 2108 :                xcode=ARCH_DEP(d250_addrck)

  006f6	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  006fe	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00701	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00706	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0070e	44 0f b6 48 30	 movzx	 r9d, BYTE PTR [rax+48]
  00713	41 b8 02 00 00
	00		 mov	 r8d, 2
  00719	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufend$[rsp]
  00721	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00726	e8 00 00 00 00	 call	 z900_d250_addrck
  0072b	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 2109 :                      (bufbeg,bufend,ACCTYPE_WRITE,ioctl->key,ioctl->regs);
; 2110 :                if (ioctl->dev->ccwtrace)

  00730	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00738	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0073c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00742	c1 e8 0f	 shr	 eax, 15
  00745	83 e0 01	 and	 eax, 1
  00748	85 c0		 test	 eax, eax
  0074a	0f 84 b5 00 00
	00		 je	 $LN30@z900_d250_

; 2111 :                {
; 2112 :                   WRMSG(HHC01943, "I",

  00750	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00758	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  0075c	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv323[rsp], eax
  00763	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00768	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv327[rsp], ecx
  0076f	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00777	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0077b	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0077f	89 94 24 d0 00
	00 00		 mov	 DWORD PTR tv331[rsp], edx
  00786	b9 01 00 00 00	 mov	 ecx, 1
  0078b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00791	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv323[rsp]
  00798	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0079c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  007a4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  007ae	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007b3	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv327[rsp]
  007ba	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007be	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv331[rsp]
  007c5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193771
  007d0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193772
  007dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007e6	41 b9 03 00 00
	00		 mov	 r9d, 3
  007ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193773
  007f3	ba 44 08 00 00	 mov	 edx, 2116		; 00000844H
  007f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193774
  007ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@z900_d250_:

; 2113 :                            ioctl->dev->devnum,
; 2114 :                            xcode,bufbeg,
; 2115 :                            bufend,
; 2116 :                            ioctl->key);
; 2117 :                }
; 2118 : 
; 2119 :                switch ( xcode )

  00805	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  0080a	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv343[rsp], eax
  00811	83 bc 24 8c 00
	00 00 04	 cmp	 DWORD PTR tv343[rsp], 4
  00819	74 16		 je	 SHORT $LN32@z900_d250_
  0081b	83 bc 24 8c 00
	00 00 05	 cmp	 DWORD PTR tv343[rsp], 5
  00823	74 02		 je	 SHORT $LN31@z900_d250_
  00825	eb 14		 jmp	 SHORT $LN10@z900_d250_
$LN31@z900_d250_:

; 2120 :                {
; 2121 :                   case PGM_ADDRESSING_EXCEPTION:
; 2122 :                      status=BIOE_ADDREXC;

  00827	c6 44 24 60 02	 mov	 BYTE PTR status$[rsp], 2

; 2123 :                      continue;

  0082c	e9 a5 00 00 00	 jmp	 $LN5@z900_d250_
$LN32@z900_d250_:

; 2124 :                   case PGM_PROTECTION_EXCEPTION:
; 2125 :                      status=BIOE_PROTEXC;

  00831	c6 44 24 60 07	 mov	 BYTE PTR status$[rsp], 7

; 2126 :                      continue;

  00836	e9 9b 00 00 00	 jmp	 $LN5@z900_d250_
$LN10@z900_d250_:

; 2127 :                }
; 2128 : 
; 2129 :                if (ioctl->dev->vmd250env->isRO)

  0083b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00843	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00847	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0084e	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00852	74 07		 je	 SHORT $LN33@z900_d250_

; 2130 :                {
; 2131 :                   status=BIOE_DASDRO;

  00854	c6 44 24 60 03	 mov	 BYTE PTR status$[rsp], 3

; 2132 :                   continue;

  00859	eb 7b		 jmp	 SHORT $LN5@z900_d250_
$LN33@z900_d250_:

; 2133 :                }
; 2134 :                status=d250_write(ioctl->dev,

  0085b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00863	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00866	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0086d	48 03 44 24 70	 add	 rax, QWORD PTR bufbeg$[rsp]
  00872	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0087a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0087e	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  00885	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR physblk$[rsp]
  0088d	4c 8b c8	 mov	 r9, rax
  00890	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  00894	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0089c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  008a0	e8 00 00 00 00	 call	 d250_write
  008a5	88 44 24 60	 mov	 BYTE PTR status$[rsp], al

; 2135 :                                    physblk,
; 2136 :                                    ioctl->dev->vmd250env->blksiz,
; 2137 :                                    ioctl->regs->mainstor+bufbeg);
; 2138 :                /* Set I/O storage key references if good I/O */
; 2139 :                if (!status)

  008a9	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  008ae	85 c0		 test	 eax, eax
  008b0	75 1b		 jne	 SHORT $LN34@z900_d250_

; 2140 :                {
; 2141 :                   ARCH_DEP( or_storage_key )( bufbeg, (STORKEY_REF | STORKEY_CHANGE) );

  008b2	b2 06		 mov	 dl, 6
  008b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  008b9	e8 00 00 00 00	 call	 z900_or_storage_key

; 2142 :                   ARCH_DEP( or_storage_key )( bufend, (STORKEY_REF | STORKEY_CHANGE) );

  008be	b2 06		 mov	 dl, 6
  008c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  008c8	e8 00 00 00 00	 call	 z900_or_storage_key
$LN34@z900_d250_:

; 2143 :                }
; 2144 :                continue;

  008cd	eb 07		 jmp	 SHORT $LN5@z900_d250_

; 2145 :             } /* end of if BIOE_WRITE */

  008cf	eb 05		 jmp	 SHORT $LN29@z900_d250_
$LN28@z900_d250_:

; 2146 :             else
; 2147 :             {
; 2148 :                status=BIOE_BADREQ;

  008d1	c6 44 24 60 06	 mov	 BYTE PTR status$[rsp], 6
$LN29@z900_d250_:
$LN23@z900_d250_:
$LN5@z900_d250_:

; 2149 :                continue;
; 2150 :             } /* end of else BIOE_WRITE */
; 2151 :          } /* end of else BIOE_READ */
; 2152 :       }while(0); /* end of do */

  008d6	33 c0		 xor	 eax, eax
  008d8	85 c0		 test	 eax, eax
  008da	0f 85 24 fa ff
	ff		 jne	 $LN7@z900_d250_

; 2153 : 
; 2154 :       /* Determine if we can store the status in the BIOE */
; 2155 :       xcode=ARCH_DEP(d250_addrck)

  008e0	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  008e5	48 ff c0	 inc	 rax
  008e8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  008ed	48 ff c1	 inc	 rcx
  008f0	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  008f8	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  008fb	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00900	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00908	44 0f b6 4a 30	 movzx	 r9d, BYTE PTR [rdx+48]
  0090d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00913	48 8b d0	 mov	 rdx, rax
  00916	e8 00 00 00 00	 call	 z900_d250_addrck
  0091b	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 2156 :             (bioebeg+1,bioebeg+1,ACCTYPE_WRITE,ioctl->key,ioctl->regs);
; 2157 :       if (ioctl->dev->ccwtrace)

  00920	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00928	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0092c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00932	c1 e8 0f	 shr	 eax, 15
  00935	83 e0 01	 and	 eax, 1
  00938	85 c0		 test	 eax, eax
  0093a	0f 84 bc 00 00
	00		 je	 $LN35@z900_d250_

; 2158 :       {
; 2159 :          WRMSG(HHC01944,"I",ioctl->dev->devnum,xcode,bioebeg+1,bioebeg+1,ioctl->key);

  00940	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00948	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  0094c	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv387[rsp], eax
  00953	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00958	48 ff c1	 inc	 rcx
  0095b	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv389[rsp], rcx
  00963	48 8b 54 24 68	 mov	 rdx, QWORD PTR bioebeg$[rsp]
  00968	48 ff c2	 inc	 rdx
  0096b	48 89 94 24 f0
	00 00 00	 mov	 QWORD PTR tv391[rsp], rdx
  00973	0f b7 7c 24 64	 movzx	 edi, WORD PTR xcode$[rsp]
  00978	48 8b b4 24 40
	01 00 00	 mov	 rsi, QWORD PTR ioctl$[rsp]
  00980	48 8b 76 08	 mov	 rsi, QWORD PTR [rsi+8]
  00984	0f b7 76 48	 movzx	 esi, WORD PTR [rsi+72]
  00988	b9 01 00 00 00	 mov	 ecx, 1
  0098d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00993	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv387[rsp]
  0099a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0099e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv389[rsp]
  009a6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009ab	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv391[rsp]
  009b3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009b8	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  009bc	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  009c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193780
  009c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193781
  009d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  009e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193782
  009ea	ba 6f 08 00 00	 mov	 edx, 2159		; 0000086fH
  009ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193783
  009f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN35@z900_d250_:

; 2160 :       }
; 2161 : 
; 2162 :       /* If the status byte is store protected, give up on processing any */
; 2163 :       /* more BIOE's.  Leave the BIOE list process for loop               */
; 2164 :       if ( xcode )

  009fc	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00a01	85 c0		 test	 eax, eax
  00a03	74 05		 je	 SHORT $LN36@z900_d250_

; 2165 :       {
; 2166 :          break;

  00a05	e9 40 01 00 00	 jmp	 $LN3@z900_d250_
$LN36@z900_d250_:

; 2167 :       }
; 2168 : 
; 2169 :       /* Store the status in the BIOE */
; 2170 :       memcpy(ioctl->regs->mainstor+bioebeg+1,&status,1);

  00a0a	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00a12	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a15	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00a1c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00a21	0f b6 54 24 60	 movzx	 edx, BYTE PTR status$[rsp]
  00a26	88 54 08 01	 mov	 BYTE PTR [rax+rcx+1], dl

; 2171 : 
; 2172 :       /* Set the storage key change bit */
; 2173 :       ARCH_DEP( or_storage_key )( bioebeg+1, (STORKEY_REF | STORKEY_CHANGE) );

  00a2a	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00a2f	48 ff c0	 inc	 rax
  00a32	b2 06		 mov	 dl, 6
  00a34	48 8b c8	 mov	 rcx, rax
  00a37	e8 00 00 00 00	 call	 z900_or_storage_key

; 2174 : 
; 2175 :       if (ioctl->dev->ccwtrace)

  00a3c	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00a44	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00a48	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00a4e	c1 e8 0f	 shr	 eax, 15
  00a51	83 e0 01	 and	 eax, 1
  00a54	85 c0		 test	 eax, eax
  00a56	0f 84 8a 00 00
	00		 je	 $LN37@z900_d250_

; 2176 :       {
; 2177 :          WRMSG (HHC01945,"I",ioctl->dev->devnum,bioebeg,status);

  00a5c	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00a61	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv429[rsp], eax
  00a68	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00a70	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00a74	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00a78	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv434[rsp], ecx
  00a7f	b9 01 00 00 00	 mov	 ecx, 1
  00a84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a8a	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv429[rsp]
  00a91	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00a95	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00a9a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a9f	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv434[rsp]
  00aa6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00aaa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193786
  00ab1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ab6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193787
  00abd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ac2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ac7	41 b9 03 00 00
	00		 mov	 r9d, 3
  00acd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193788
  00ad4	ba 81 08 00 00	 mov	 edx, 2177		; 00000881H
  00ad9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193789
  00ae0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN37@z900_d250_:

; 2178 :       }
; 2179 : 
; 2180 :       /* Count if this BIOE was a success or failure */
; 2181 :       if ( status )

  00ae6	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00aeb	85 c0		 test	 eax, eax
  00aed	74 26		 je	 SHORT $LN38@z900_d250_

; 2182 :       {
; 2183 :          ioctl->badblks+=1;

  00aef	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00af7	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00afa	ff c0		 inc	 eax
  00afc	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00b04	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 2184 :          if ( status == BIOE_ABORTED )

  00b07	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00b0c	83 f8 0c	 cmp	 eax, 12
  00b0f	75 02		 jne	 SHORT $LN40@z900_d250_

; 2185 :          {
; 2186 :              break;

  00b11	eb 37		 jmp	 SHORT $LN3@z900_d250_
$LN40@z900_d250_:

; 2187 :          }
; 2188 :       }

  00b13	eb 18		 jmp	 SHORT $LN39@z900_d250_
$LN38@z900_d250_:

; 2189 :       else
; 2190 :       {
; 2191 :          ioctl->goodblks+=1;

  00b15	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b1d	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00b20	ff c0		 inc	 eax
  00b22	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00b2a	89 41 34	 mov	 DWORD PTR [rcx+52], eax
$LN39@z900_d250_:

; 2192 :       }
; 2193 : 
; 2194 :       /* Determine the address of the next BIOE */
; 2195 :       bioebeg += sizeof(BIOE64);

  00b2d	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00b32	48 83 c0 18	 add	 rax, 24
  00b36	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 2196 :       bioebeg &= AMASK64;

  00b3b	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00b40	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 2197 :    } /* end of for loop */

  00b45	e9 1e f6 ff ff	 jmp	 $LN2@z900_d250_
$LN3@z900_d250_:

; 2198 : 
; 2199 : #if 0 // remove after testing
; 2200 :    LOGMSG( "(d250_list64) BIOE's processed: %d\n", block );
; 2201 : #endif
; 2202 : 
; 2203 :    /* Restore device to guest ownership */
; 2204 :    d250_restore(ioctl->dev);

  00b4a	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b52	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00b56	e8 00 00 00 00	 call	 d250_restore

; 2205 :    /* Note: device lock not held */
; 2206 : 
; 2207 :    /* If an access exception occurred:                                 */
; 2208 :    /*   If this is a synchronous request, generate a program exception */
; 2209 :    /*   or if this is asynchrnous, just return with a storage error    */
; 2210 :    if ( xcode )

  00b5b	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00b60	85 c0		 test	 eax, eax
  00b62	74 2a		 je	 SHORT $LN41@z900_d250_

; 2211 :    {
; 2212 :       if (async)

  00b64	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR async$[rsp], 0
  00b6c	74 09		 je	 SHORT $LN42@z900_d250_

; 2213 :           return PSC_STGERR;

  00b6e	b8 02 00 00 00	 mov	 eax, 2
  00b73	eb 47		 jmp	 SHORT $LN1@z900_d250_
  00b75	eb 17		 jmp	 SHORT $LN43@z900_d250_
$LN42@z900_d250_:

; 2214 :       else
; 2215 :           ARCH_DEP(program_interrupt)(ioctl->regs, xcode);

  00b77	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00b7c	8b d0		 mov	 edx, eax
  00b7e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b86	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00b89	e8 00 00 00 00	 call	 z900_program_interrupt
$LN43@z900_d250_:
$LN41@z900_d250_:

; 2216 :    }
; 2217 : 
; 2218 :    if ( status == BIOE_ABORTED )

  00b8e	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00b93	83 f8 0c	 cmp	 eax, 12
  00b96	75 07		 jne	 SHORT $LN44@z900_d250_

; 2219 :    {
; 2220 :       return PSC_REMOVED;

  00b98	b8 03 00 00 00	 mov	 eax, 3
  00b9d	eb 1d		 jmp	 SHORT $LN1@z900_d250_
$LN44@z900_d250_:

; 2221 :    }
; 2222 : 
; 2223 :    /* Determine if we were completely successful or only partially     */
; 2224 :    /* successful.  'Partial' includes none successful.                 */
; 2225 :    /* Synchronous and asynchronous requests handle all failed          */
; 2226 :    /* differently. The good and bad blocks field are used by the       */
; 2227 :    /* caller                                                           */
; 2228 :    if (ioctl->goodblks < blocks)

  00b9f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00ba7	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR blocks$[rsp]
  00bae	39 48 34	 cmp	 DWORD PTR [rax+52], ecx
  00bb1	7d 07		 jge	 SHORT $LN45@z900_d250_

; 2229 :    {
; 2230 :       return PSC_PARTIAL;

  00bb3	b8 01 00 00 00	 mov	 eax, 1
  00bb8	eb 02		 jmp	 SHORT $LN1@z900_d250_
$LN45@z900_d250_:

; 2231 :    }
; 2232 :    return PSC_SUCCESS;

  00bba	33 c0		 xor	 eax, eax
$LN1@z900_d250_:

; 2233 : 
; 2234 : } /* end function ARCH_DEP(d250_list64) */

  00bbc	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00bc4	48 33 cc	 xor	 rcx, rsp
  00bc7	e8 00 00 00 00	 call	 __security_check_cookie
  00bcc	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00bd3	5f		 pop	 rdi
  00bd4	5e		 pop	 rsi
  00bd5	c3		 ret	 0
z900_d250_list64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
psc$ = 96
tv298 = 100
rc2$ = 104
tv173 = 108
tv178 = 112
tv257 = 116
tv262 = 120
tv283 = 124
tv286 = 128
tv300 = 132
asyncp$ = 136
$T1 = 144
ioctl$ = 160
tid$ = 224
tv195 = 232
tv238 = 240
bioplx00$ = 256
tname$ = 320
buf$2 = 352
__$ArrayPad$ = 392
dev$ = 432
rc$ = 440
biopl$ = 448
regs$ = 456
z900_d250_iorq64 PROC

; 1769 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1770 : BIOPL_IORQ64   bioplx00;   /* Used to check reserved fields */
; 1771 : IOCTL64 ioctl;             /* Request information */
; 1772 : BYTE    psc;               /* List processing status code   */
; 1773 : 
; 1774 : /* Asynchronous request related fields */
; 1775 : TID     tid;         /* Asynchronous thread ID */
; 1776 : char    tname[32];   /* Thread name */
; 1777 : IOCTL64 *asyncp;     /* Pointer to async thread's free standing storage */
; 1778 : int     rc2;
; 1779 : 
; 1780 : #if 0
; 1781 :    LOGMSG( "(d250_iorq64) Entered\n" );
; 1782 : #endif
; 1783 : 
; 1784 :    /* Clear the reserved BIOPL */
; 1785 :    memset(&bioplx00,0,sizeof(BIOPL_IORQ64));

  0002f	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR bioplx00$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00041	f3 aa		 rep stosb

; 1786 : 
; 1787 :    /* Make sure reserved fields are binary zeros  */
; 1788 :    if ((memcmp(&biopl->resv1,&bioplx00,IORQ64R1_LEN)!=0) ||
; 1789 :        (memcmp(&biopl->resv2,&bioplx00,IORQ64R2_LEN)!=0) ||
; 1790 :        (memcmp(&biopl->resv3,&bioplx00,IORQ64R3_LEN)!=0) ||
; 1791 :        (memcmp(&biopl->resv4,&bioplx00,IORQ64R4_LEN)!=0) ||
; 1792 :        (biopl->flags & BIOPL_FLAGSRSV) ||

  00043	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	41 b8 15 00 00
	00		 mov	 r8d, 21
  00055	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 memcmp
  00065	85 c0		 test	 eax, eax
  00067	0f 85 9a 00 00
	00		 jne	 $LN5@z900_d250_
  0006d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00075	48 83 c0 1a	 add	 rax, 26
  00079	41 b8 02 00 00
	00		 mov	 r8d, 2
  0007f	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  00087	48 8b c8	 mov	 rcx, rax
  0008a	e8 00 00 00 00	 call	 memcmp
  0008f	85 c0		 test	 eax, eax
  00091	75 74		 jne	 SHORT $LN5@z900_d250_
  00093	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  0009b	48 83 c0 24	 add	 rax, 36			; 00000024H
  0009f	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a5	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	e8 00 00 00 00	 call	 memcmp
  000b5	85 c0		 test	 eax, eax
  000b7	75 4e		 jne	 SHORT $LN5@z900_d250_
  000b9	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000c1	48 83 c0 38	 add	 rax, 56			; 00000038H
  000c5	41 b8 08 00 00
	00		 mov	 r8d, 8
  000cb	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 memcmp
  000db	85 c0		 test	 eax, eax
  000dd	75 28		 jne	 SHORT $LN5@z900_d250_
  000df	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000e7	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  000eb	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  000f0	85 c0		 test	 eax, eax
  000f2	75 13		 jne	 SHORT $LN5@z900_d250_
  000f4	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000fc	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00100	83 e0 0f	 and	 eax, 15
  00103	85 c0		 test	 eax, eax
  00105	74 12		 je	 SHORT $LN4@z900_d250_
$LN5@z900_d250_:

; 1793 :        (biopl->key & BIOPL_KEYRSV)
; 1794 :       )
; 1795 :    {
; 1796 :        ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00107	ba 06 00 00 00	 mov	 edx, 6
  0010c	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_program_interrupt
$LN4@z900_d250_:

; 1797 :    }
; 1798 : 
; 1799 :    /* Return with an error return code if the device does not exist */
; 1800 :    if (!dev)

  00119	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00122	75 18		 jne	 SHORT $LN6@z900_d250_

; 1801 :    {
; 1802 :       *rc = RC_NODEV;  /* Set the return code for no device */

  00124	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0012c	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 1803 :       return CC_FAILED; /* Indicate the function failed     */

  00132	b8 02 00 00 00	 mov	 eax, 2
  00137	e9 91 06 00 00	 jmp	 $LN1@z900_d250_
$LN6@z900_d250_:

; 1804 :    }
; 1805 : 
; 1806 :    /* If no environment, return with an error */
; 1807 :    if (!dev->vmd250env)

  0013c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00144	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  0014c	75 18		 jne	 SHORT $LN7@z900_d250_

; 1808 :    {
; 1809 :       *rc = RC_STATERR;

  0014e	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00156	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 1810 :       return CC_FAILED;

  0015c	b8 02 00 00 00	 mov	 eax, 2
  00161	e9 67 06 00 00	 jmp	 $LN1@z900_d250_
$LN7@z900_d250_:

; 1811 :    }
; 1812 : 
; 1813 :    /* Fetch the block count from the BIOPL */
; 1814 :    FETCH_FW(ioctl.blkcount,&biopl->blkcount);

  00166	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  0016e	48 83 c0 1c	 add	 rax, 28
  00172	48 8b c8	 mov	 rcx, rax
  00175	e8 00 00 00 00	 call	 fetch_fw_noswap
  0017a	8b c8		 mov	 ecx, eax
  0017c	e8 00 00 00 00	 call	 _byteswap_ulong
  00181	8b c0		 mov	 eax, eax
  00183	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR ioctl$[rsp+32], rax

; 1815 : 
; 1816 : #if 0
; 1817 :    LOGMSG( "(d250_iorq64) ioctl.blkcount=%d,\n", ioctl.blkcount );
; 1818 : #endif
; 1819 : 
; 1820 :    /* Block count must be between 1 and 256, inclusive */
; 1821 :    if ((ioctl.blkcount<1) || (ioctl.blkcount>256))

  0018b	48 83 bc 24 c0
	00 00 00 01	 cmp	 QWORD PTR ioctl$[rsp+32], 1
  00194	7c 0e		 jl	 SHORT $LN9@z900_d250_
  00196	48 81 bc 24 c0
	00 00 00 00 01
	00 00		 cmp	 QWORD PTR ioctl$[rsp+32], 256 ; 00000100H
  001a2	7e 18		 jle	 SHORT $LN8@z900_d250_
$LN9@z900_d250_:

; 1822 :    {
; 1823 :        *rc = RC_CNT_ERR;

  001a4	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  001ac	c7 00 24 00 00
	00		 mov	 DWORD PTR [rax], 36	; 00000024H

; 1824 :        return CC_FAILED;

  001b2	b8 02 00 00 00	 mov	 eax, 2
  001b7	e9 11 06 00 00	 jmp	 $LN1@z900_d250_
$LN8@z900_d250_:

; 1825 :    }
; 1826 : 
; 1827 :    /* Fetch the address of the BIO entry list from the BIOPL */
; 1828 :    FETCH_DW(ioctl.listaddr,&biopl->bioeladr);

  001bc	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  001c4	48 83 c0 30	 add	 rax, 48			; 00000030H
  001c8	48 8b c8	 mov	 rcx, rax
  001cb	e8 00 00 00 00	 call	 fetch_dw_noswap
  001d0	48 8b c8	 mov	 rcx, rax
  001d3	e8 00 00 00 00	 call	 _byteswap_uint64
  001d8	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR ioctl$[rsp+40], rax

; 1829 : 
; 1830 : #if 0
; 1831 :    LOGMSG( "(d250_iorq64) ioctl.listaddr=%16.16X,\n", ioctl.listaddr );
; 1832 : #endif
; 1833 : 
; 1834 :    /* Extract the storage key from the BIOPL */
; 1835 :    ioctl.key=biopl->key;

  001e0	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  001e8	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  001ec	88 84 24 d0 00
	00 00		 mov	 BYTE PTR ioctl$[rsp+48], al

; 1836 : 
; 1837 :    /* Set the structures that are involved in this request */
; 1838 :    ioctl.dev = dev;

  001f3	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR ioctl$[rsp+8], rax

; 1839 :    ioctl.regs = regs;

  00203	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ioctl$[rsp], rax

; 1840 : 
; 1841 :    /* Set I/O success/failure counts to zero */
; 1842 :    ioctl.goodblks = 0;

  00213	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ioctl$[rsp+52], 0

; 1843 :    ioctl.badblks = 0;

  0021e	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ioctl$[rsp+56], 0

; 1844 : 
; 1845 :    /* Determine if request is an asynchronous or synchronous */
; 1846 :    if (biopl->flags & BIOPL_ASYNC)

  00229	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00231	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00235	83 e0 02	 and	 eax, 2
  00238	85 c0		 test	 eax, eax
  0023a	0f 84 32 03 00
	00		 je	 $LN10@z900_d250_

; 1847 :    {
; 1848 :        /* Build the request structure */
; 1849 : 
; 1850 :        /* Extract the 64-bit interrupt parameter from the BIOPL */
; 1851 :        FETCH_DW(ioctl.intrparm,&biopl->intparm);

  00240	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00248	48 83 c0 28	 add	 rax, 40			; 00000028H
  0024c	48 8b c8	 mov	 rcx, rax
  0024f	e8 00 00 00 00	 call	 fetch_dw_noswap
  00254	48 8b c8	 mov	 rcx, rax
  00257	e8 00 00 00 00	 call	 _byteswap_uint64
  0025c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR ioctl$[rsp+24], rax

; 1852 : 
; 1853 :        if (dev->ccwtrace)

  00264	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00272	c1 e8 0f	 shr	 eax, 15
  00275	83 e0 01	 and	 eax, 1
  00278	85 c0		 test	 eax, eax
  0027a	0f 84 9a 00 00
	00		 je	 $LN12@z900_d250_

; 1854 :        {
; 1855 :           WRMSG(HHC01935, "I",

  00280	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ioctl$[rsp+48]
  00288	89 44 24 6c	 mov	 DWORD PTR tv173[rsp], eax
  0028c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00294	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00298	89 4c 24 70	 mov	 DWORD PTR tv178[rsp], ecx
  0029c	b9 01 00 00 00	 mov	 ecx, 1
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp+24]
  002af	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002b4	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv173[rsp]
  002b8	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002bc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp+32]
  002c4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp+40]
  002d1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002d6	8b 4c 24 70	 mov	 ecx, DWORD PTR tv178[rsp]
  002da	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193666
  002e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193667
  002f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00301	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193668
  00308	ba 44 07 00 00	 mov	 edx, 1860		; 00000744H
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193669
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@z900_d250_:

; 1856 :                    dev->devnum,
; 1857 :                    ioctl.listaddr,
; 1858 :                    ioctl.blkcount,
; 1859 :                    ioctl.key,
; 1860 :                    ioctl.intrparm);
; 1861 :        }
; 1862 : 
; 1863 :        /* Set the default status code to an aborted list */
; 1864 :        /* Note: This should be set correctly from the returned PSC */
; 1865 :        ioctl.statuscod = PSC_STGERR;

  0031a	c6 84 24 b1 00
	00 00 02	 mov	 BYTE PTR ioctl$[rsp+17], 2

; 1866 : 
; 1867 :        /* Get the storage for the thread's parameters */
; 1868 :        if (!(asyncp=(IOCTL64 *)malloc(sizeof(IOCTL64))))

  00322	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0032d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR asyncp$[rsp], rax
  00335	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR asyncp$[rsp], 0
  0033e	0f 85 af 00 00
	00		 jne	 $LN13@z900_d250_

; 1869 :        {
; 1870 :           char buf[40];
; 1871 :           MSGBUF(buf, "malloc(%d)", (int)sizeof(IOCTL64));

  00344	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0034a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193671
  00351	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00356	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0035e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1872 :           WRMSG (HHC01908, "E", buf, strerror(errno));

  00364	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0036a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0036c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00372	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv195[rsp], rax
  0037a	b9 01 00 00 00	 mov	 ecx, 1
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00385	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv195[rsp]
  0038d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00392	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0039a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0039f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193672
  003a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193673
  003b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193674
  003c9	ba 50 07 00 00	 mov	 edx, 1872		; 00000750H
  003ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193675
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1873 :           *rc = RC_ERROR;

  003db	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  003e3	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1874 :           return CC_FAILED;

  003e9	b8 02 00 00 00	 mov	 eax, 2
  003ee	e9 da 03 00 00	 jmp	 $LN1@z900_d250_
$LN13@z900_d250_:

; 1875 :        }
; 1876 : 
; 1877 :        /* Copy the thread's parameters to its own storage */
; 1878 :        memcpy(asyncp,&ioctl,sizeof(IOCTL64));

  003f3	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR ioctl$[rsp]
  003fb	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR asyncp$[rsp]
  00403	48 8b f0	 mov	 rsi, rax
  00406	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0040b	f3 a4		 rep movsb

; 1879 : 
; 1880 :        /* Launch the asynchronous request on a separate thread */
; 1881 :        MSGBUF(tname,"d250_async %4.4X",dev->devnum);

  0040d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00415	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00419	44 8b c8	 mov	 r9d, eax
  0041c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193676
  00423	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00428	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR tname$[rsp]
  00430	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1882 :        tname[sizeof(tname)-1]=0;

  00436	b8 01 00 00 00	 mov	 eax, 1
  0043b	48 6b c0 1f	 imul	 rax, rax, 31
  0043f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00447	48 83 bc 24 90
	00 00 00 20	 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  00450	73 02		 jae	 SHORT $LN24@z900_d250_
  00452	eb 05		 jmp	 SHORT $LN25@z900_d250_
$LN24@z900_d250_:
  00454	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN25@z900_d250_:
  00459	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00461	c6 84 04 40 01
	00 00 00	 mov	 BYTE PTR tname$[rsp+rax], 0

; 1883 :        rc2 = create_thread (&tid, DETACHED, ARCH_DEP(d250_async64),

  00469	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00470	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00476	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193677
  0047d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00482	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR tname$[rsp]
  0048a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0048f	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR asyncp$[rsp]
  00497	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:z900_d250_async64
  0049e	48 8b d0	 mov	 rdx, rax
  004a1	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  004af	89 44 24 68	 mov	 DWORD PTR rc2$[rsp], eax

; 1884 :                asyncp, tname);
; 1885 :        if(rc2)

  004b3	83 7c 24 68 00	 cmp	 DWORD PTR rc2$[rsp], 0
  004b8	0f 84 9a 00 00
	00		 je	 $LN14@z900_d250_

; 1886 :        {
; 1887 :           WRMSG (HHC00102, "E", strerror(rc2));

  004be	8b 4c 24 68	 mov	 ecx, DWORD PTR rc2$[rsp]
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004c8	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv238[rsp], rax
  004d0	b9 01 00 00 00	 mov	 ecx, 1
  004d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004db	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv238[rsp]
  004e3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193679
  004ef	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193680
  004fb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00500	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00505	41 b9 03 00 00
	00		 mov	 r9d, 3
  0050b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193681
  00512	ba 5f 07 00 00	 mov	 edx, 1887		; 0000075fH
  00517	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193682
  0051e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1888 :           release_lock (&dev->lock);

  00524	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00530	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193683
  00537	48 8b c8	 mov	 rcx, rax
  0053a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1889 :           *rc = RC_ERROR;

  00540	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00548	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1890 :           return CC_FAILED;

  0054e	b8 02 00 00 00	 mov	 eax, 2
  00553	e9 75 02 00 00	 jmp	 $LN1@z900_d250_
$LN14@z900_d250_:

; 1891 :        }
; 1892 :        /* Launched the async request successfully */
; 1893 :        *rc = RC_ASYNC;

  00558	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00560	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 1894 :        return CC_SUCCESS;

  00566	33 c0		 xor	 eax, eax
  00568	e9 60 02 00 00	 jmp	 $LN1@z900_d250_

; 1895 :    }

  0056d	e9 64 01 00 00	 jmp	 $LN11@z900_d250_
$LN10@z900_d250_:

; 1896 :    else
; 1897 :    {
; 1898 :        if (dev->ccwtrace)

  00572	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0057a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00580	c1 e8 0f	 shr	 eax, 15
  00583	83 e0 01	 and	 eax, 1
  00586	85 c0		 test	 eax, eax
  00588	0f 84 8d 00 00
	00		 je	 $LN15@z900_d250_

; 1899 :        {
; 1900 :           WRMSG(HHC01936, "I",

  0058e	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ioctl$[rsp+48]
  00596	89 44 24 74	 mov	 DWORD PTR tv257[rsp], eax
  0059a	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005a2	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  005a6	89 4c 24 78	 mov	 DWORD PTR tv262[rsp], ecx
  005aa	b9 01 00 00 00	 mov	 ecx, 1
  005af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005b5	8b 4c 24 74	 mov	 ecx, DWORD PTR tv257[rsp]
  005b9	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  005bd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp+32]
  005c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005ca	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp+40]
  005d2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  005d7	8b 4c 24 78	 mov	 ecx, DWORD PTR tv262[rsp]
  005db	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193685
  005e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193686
  005f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00602	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193687
  00609	ba 70 07 00 00	 mov	 edx, 1904		; 00000770H
  0060e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193688
  00615	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@z900_d250_:

; 1901 :                    dev->devnum,
; 1902 :                    ioctl.listaddr,
; 1903 :                    ioctl.blkcount,
; 1904 :                    ioctl.key);
; 1905 :        }
; 1906 : 
; 1907 :        psc=ARCH_DEP(d250_list64)(&ioctl, SYNC);

  0061b	33 d2		 xor	 edx, edx
  0061d	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ioctl$[rsp]
  00625	e8 00 00 00 00	 call	 z900_d250_list64
  0062a	88 44 24 60	 mov	 BYTE PTR psc$[rsp], al

; 1908 : 
; 1909 :        if (dev->ccwtrace)

  0062e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00636	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0063c	c1 e8 0f	 shr	 eax, 15
  0063f	83 e0 01	 and	 eax, 1
  00642	85 c0		 test	 eax, eax
  00644	0f 84 8c 00 00
	00		 je	 $LN16@z900_d250_

; 1910 :        {
; 1911 :           WRMSG(HHC01937, "I", dev->devnum,psc,ioctl.goodblks,ioctl.badblks);

  0064a	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  0064f	89 44 24 7c	 mov	 DWORD PTR tv283[rsp], eax
  00653	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0065b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0065f	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv286[rsp], ecx
  00666	b9 01 00 00 00	 mov	 ecx, 1
  0066b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00671	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+56]
  00678	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0067c	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+52]
  00683	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00687	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv283[rsp]
  0068b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0068f	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv286[rsp]
  00696	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0069a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193690
  006a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193691
  006ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  006bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193692
  006c4	ba 77 07 00 00	 mov	 edx, 1911		; 00000777H
  006c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193693
  006d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@z900_d250_:
$LN11@z900_d250_:

; 1912 :        }
; 1913 :    }
; 1914 : 
; 1915 :    /* Processor status used to determine return and condition codes */
; 1916 :    switch(psc)

  006d6	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  006db	88 44 24 64	 mov	 BYTE PTR tv298[rsp], al
  006df	80 7c 24 64 00	 cmp	 BYTE PTR tv298[rsp], 0
  006e4	74 10		 je	 SHORT $LN17@z900_d250_
  006e6	80 7c 24 64 01	 cmp	 BYTE PTR tv298[rsp], 1
  006eb	74 1e		 je	 SHORT $LN18@z900_d250_
  006ed	80 7c 24 64 03	 cmp	 BYTE PTR tv298[rsp], 3
  006f2	74 53		 je	 SHORT $LN21@z900_d250_
  006f4	eb 66		 jmp	 SHORT $LN22@z900_d250_
$LN17@z900_d250_:

; 1917 :    {
; 1918 :       case PSC_SUCCESS:
; 1919 :          *rc = RC_SUCCESS;

  006f6	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006fe	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1920 :          return CC_SUCCESS;

  00704	33 c0		 xor	 eax, eax
  00706	e9 c2 00 00 00	 jmp	 $LN1@z900_d250_
$LN18@z900_d250_:

; 1921 :       case PSC_PARTIAL:
; 1922 :          if (ioctl.goodblks == 0)

  0070b	83 bc 24 d4 00
	00 00 00	 cmp	 DWORD PTR ioctl$[rsp+52], 0
  00713	75 1a		 jne	 SHORT $LN19@z900_d250_

; 1923 :          {
; 1924 :             *rc = RC_ALL_BAD;

  00715	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0071d	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 1925 :             return CC_FAILED;

  00723	b8 02 00 00 00	 mov	 eax, 2
  00728	e9 a0 00 00 00	 jmp	 $LN1@z900_d250_

; 1926 :          }

  0072d	eb 18		 jmp	 SHORT $LN20@z900_d250_
$LN19@z900_d250_:

; 1927 :          else
; 1928 :          {
; 1929 :             *rc = RC_SYN_PART;

  0072f	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00737	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 1930 :             return CC_PARTIAL;

  0073d	b8 01 00 00 00	 mov	 eax, 1
  00742	e9 86 00 00 00	 jmp	 $LN1@z900_d250_
$LN20@z900_d250_:
$LN21@z900_d250_:

; 1931 :          }
; 1932 :       case PSC_REMOVED:
; 1933 :          *rc = RC_REM_PART;

  00747	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0074f	c7 00 2c 00 00
	00		 mov	 DWORD PTR [rax], 44	; 0000002cH

; 1934 :          return CC_PARTIAL;

  00755	b8 01 00 00 00	 mov	 eax, 1
  0075a	eb 71		 jmp	 SHORT $LN1@z900_d250_
$LN22@z900_d250_:

; 1935 :       default:
; 1936 :          WRMSG (HHC01938, "E", psc);

  0075c	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  00761	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv300[rsp], eax
  00768	b9 01 00 00 00	 mov	 ecx, 1
  0076d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00773	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv300[rsp]
  0077a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0077e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193700
  00785	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0078a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193701
  00791	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00796	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0079b	41 b9 03 00 00
	00		 mov	 r9d, 3
  007a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193702
  007a8	ba 90 07 00 00	 mov	 edx, 1936		; 00000790H
  007ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193703
  007b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1937 :          *rc = RC_ERROR;

  007ba	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  007c2	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1938 :          return CC_FAILED;

  007c8	b8 02 00 00 00	 mov	 eax, 2
$LN1@z900_d250_:
$LN23@z900_d250_:

; 1939 :    } /* end switch(psc) */
; 1940 : 
; 1941 : } /* end function d250_iorq64 */

  007cd	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007d5	48 33 cc	 xor	 rcx, rsp
  007d8	e8 00 00 00 00	 call	 __security_check_cookie
  007dd	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  007e4	5f		 pop	 rdi
  007e5	5e		 pop	 rsi
  007e6	c3		 ret	 0
z900_d250_iorq64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
sk1$ = 32
sk2$ = 33
beg$ = 64
end$ = 72
acctype$ = 80
key$ = 88
regs$ = 96
z900_d250_addrck PROC

; 1677 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1678 : BYTE   sk1;      /* Storage key of first byte of area         */
; 1679 : BYTE   sk2;      /* Storage key of last byte of area          */
; 1680 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1681 : BYTE   skmid;    /* Storage key of middle byte of area        */
; 1682 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1683 : 
; 1684 : 
; 1685 :     if ( (end > regs->mainlim) || (end > MAXADDRESS) || end < beg )

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00024	48 39 44 24 48	 cmp	 QWORD PTR end$[rsp], rax
  00029	77 14		 ja	 SHORT $LN3@z900_d250_
  0002b	48 83 7c 24 48
	ff		 cmp	 QWORD PTR end$[rsp], -1
  00031	77 0c		 ja	 SHORT $LN3@z900_d250_
  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR beg$[rsp]
  00038	48 39 44 24 48	 cmp	 QWORD PTR end$[rsp], rax
  0003d	73 0a		 jae	 SHORT $LN2@z900_d250_
$LN3@z900_d250_:

; 1686 :     {
; 1687 :        return PGM_ADDRESSING_EXCEPTION;

  0003f	b8 05 00 00 00	 mov	 eax, 5
  00044	e9 ad 00 00 00	 jmp	 $LN1@z900_d250_
$LN2@z900_d250_:

; 1688 :     }
; 1689 : 
; 1690 :     /* Note this logic is inspired by        */
; 1691 :     /* inline.h ARCH_DEP(is_fetch_protected) */
; 1692 :     /* inline.h ARCH_DEP(is_store_protected) */
; 1693 : 
; 1694 :     if (key == 0)

  00049	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  0004e	85 c0		 test	 eax, eax
  00050	75 07		 jne	 SHORT $LN4@z900_d250_

; 1695 :     {
; 1696 :        return 0;

  00052	33 c0		 xor	 eax, eax
  00054	e9 9d 00 00 00	 jmp	 $LN1@z900_d250_
$LN4@z900_d250_:

; 1697 :     }
; 1698 : 
; 1699 :     sk1 = ARCH_DEP( get_storage_key )( beg );

  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR beg$[rsp]
  0005e	e8 00 00 00 00	 call	 z900_get_storage_key
  00063	88 44 24 20	 mov	 BYTE PTR sk1$[rsp], al

; 1700 :     sk2 = ARCH_DEP( get_storage_key )( end );

  00067	48 8b 4c 24 48	 mov	 rcx, QWORD PTR end$[rsp]
  0006c	e8 00 00 00 00	 call	 z900_get_storage_key
  00071	88 44 24 21	 mov	 BYTE PTR sk2$[rsp], al

; 1701 : 
; 1702 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1703 :     if ( ( end - beg ) > 2048 )
; 1704 :     {
; 1705 :        skmid = ARCH_DEP( get_storage_key )( beg + 2048 );
; 1706 :     }
; 1707 :     else
; 1708 :     {
; 1709 :        skmid = sk2;
; 1710 :     }
; 1711 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1712 : 
; 1713 :     if (acctype == ACCTYPE_READ)

  00075	83 7c 24 50 04	 cmp	 DWORD PTR acctype$[rsp], 4
  0007a	75 49		 jne	 SHORT $LN5@z900_d250_

; 1714 :     {  /* Check for fetch protection  */
; 1715 :        if (  ((sk1 & STORKEY_FETCH) && (key != (sk1 & STORKEY_KEY)))
; 1716 :            ||((sk2 & STORKEY_FETCH) && (key != (sk2 & STORKEY_KEY)))

  0007c	0f b6 44 24 20	 movzx	 eax, BYTE PTR sk1$[rsp]
  00081	83 e0 08	 and	 eax, 8
  00084	85 c0		 test	 eax, eax
  00086	74 14		 je	 SHORT $LN9@z900_d250_
  00088	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  0008d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR sk1$[rsp]
  00092	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00098	3b c1		 cmp	 eax, ecx
  0009a	75 20		 jne	 SHORT $LN8@z900_d250_
$LN9@z900_d250_:
  0009c	0f b6 44 24 21	 movzx	 eax, BYTE PTR sk2$[rsp]
  000a1	83 e0 08	 and	 eax, 8
  000a4	85 c0		 test	 eax, eax
  000a6	74 1b		 je	 SHORT $LN7@z900_d250_
  000a8	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  000ad	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR sk2$[rsp]
  000b2	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000b8	3b c1		 cmp	 eax, ecx
  000ba	74 07		 je	 SHORT $LN7@z900_d250_
$LN8@z900_d250_:

; 1717 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1718 :            ||((skmid & STORKEY_FETCH) && (key != (skmid & STORKEY_KEY)))
; 1719 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1720 :           )
; 1721 :        {
; 1722 :           return PGM_PROTECTION_EXCEPTION;

  000bc	b8 04 00 00 00	 mov	 eax, 4
  000c1	eb 33		 jmp	 SHORT $LN1@z900_d250_
$LN7@z900_d250_:

; 1723 :        }
; 1724 :     }

  000c3	eb 2f		 jmp	 SHORT $LN6@z900_d250_
$LN5@z900_d250_:

; 1725 :     else /* assume ACCTYPE_WRITE */
; 1726 :     {  /* Check for store protection */
; 1727 :        if (  (key != (sk1 & STORKEY_KEY))
; 1728 :            ||(key != (sk2 & STORKEY_KEY))

  000c5	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  000ca	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR sk1$[rsp]
  000cf	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000d5	3b c1		 cmp	 eax, ecx
  000d7	75 14		 jne	 SHORT $LN11@z900_d250_
  000d9	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  000de	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR sk2$[rsp]
  000e3	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000e9	3b c1		 cmp	 eax, ecx
  000eb	74 07		 je	 SHORT $LN10@z900_d250_
$LN11@z900_d250_:

; 1729 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1730 :            ||(key != (skmid & STORKEY_KEY))
; 1731 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1732 :           )
; 1733 :        {
; 1734 :           return PGM_PROTECTION_EXCEPTION;

  000ed	b8 04 00 00 00	 mov	 eax, 4
  000f2	eb 02		 jmp	 SHORT $LN1@z900_d250_
$LN10@z900_d250_:
$LN6@z900_d250_:

; 1735 :        }
; 1736 :     }
; 1737 :     return 0;

  000f4	33 c0		 xor	 eax, eax
$LN1@z900_d250_:

; 1738 : } /* end of function ARCH_DEP(d250_addrck) */

  000f6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fa	c3		 ret	 0
z900_d250_addrck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
status$ = 96
xcode$ = 100
bioebeg$ = 104
bufbeg$ = 112
blknum$ = 120
block$ = 124
bufend$ = 128
tv293 = 136
tv352 = 140
physblk$ = 144
blocks$ = 148
tv70 = 152
tv79 = 156
tv152 = 160
tv156 = 164
tv160 = 168
tv234 = 172
tv239 = 176
tv273 = 180
tv277 = 184
tv281 = 188
tv332 = 192
tv336 = 196
tv340 = 200
tv396 = 204
tv438 = 208
tv443 = 212
bioeend$ = 216
tv73 = 224
tv398 = 232
tv400 = 240
bioe$ = 248
__$ArrayPad$ = 264
ioctl$ = 304
async$ = 312
z900_d250_list32 PROC

; 1361 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1362 : BIOE32 bioe;      /* 32-bit BIOE fetched from absolute storage */
; 1363 : RADR   bioebeg;   /* Starting address of the BIOE              */
; 1364 : RADR   bioeend;   /* Address of last byte of BIOE              */
; 1365 : U16    xcode;     /* Detected exception condition              */
; 1366 : int    blocks;    /* Number of blocks being processed          */
; 1367 : int    block;     /* counter used in block I/O loop            */
; 1368 : S32    blknum;    /* Block number of the request               */
; 1369 : BYTE   status;    /* Returned BIOE status                      */
; 1370 : /* Passed to generic block I/O function                        */
; 1371 : int    physblk;   /* Physical block number                     */
; 1372 : RADR   bufbeg;    /* Address where the read/write will occur   */
; 1373 : RADR   bufend;    /* Last byte read or written                 */
; 1374 : 
; 1375 :    xcode = 0;   /* Initialize the address check exception code */

  00024	33 c0		 xor	 eax, eax
  00026	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1376 :    status = 0;

  0002b	c6 44 24 60 00	 mov	 BYTE PTR status$[rsp], 0

; 1377 : 
; 1378 :    /* Preserve pending sense if any and establish my ownership */
; 1379 :    /* of the device by reserving it if shared and locking it   */
; 1380 :    if (ioctl->dev->ccwtrace)

  00030	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00038	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00042	c1 e8 0f	 shr	 eax, 15
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 b6 00 00
	00		 je	 $LN12@z900_d250_

; 1381 :    {
; 1382 :       WRMSG (HHC01928, "I",

  00050	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00058	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0005c	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv70[rsp], eax
  00063	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0006b	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0006e	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv73[rsp], rcx
  00076	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  0007e	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00082	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00086	89 94 24 9c 00
	00 00		 mov	 DWORD PTR tv79[rsp], edx
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00098	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv70[rsp]
  0009f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000a3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv73[rsp]
  000ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000b0	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  000b8	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  000bb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000bf	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv79[rsp]
  000c6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193538
  000d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193539
  000dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193540
  000f4	ba 6b 05 00 00	 mov	 edx, 1387		; 0000056bH
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193541
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@z900_d250_:

; 1383 :                ioctl->dev->devnum,
; 1384 :                ioctl->blkcount,
; 1385 :                (RADR)ioctl->listaddr,
; 1386 :                ioctl->key
; 1387 :                );
; 1388 :    }
; 1389 : 
; 1390 :    /* Take ownership of the device */
; 1391 :    d250_preserve(ioctl->dev);

  00106	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0010e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00112	e8 00 00 00 00	 call	 d250_preserve

; 1392 :    /* Note: the DEVBLK is now locked */
; 1393 : 
; 1394 :    if (!ioctl->dev->vmd250env)

  00117	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0011f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00123	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  0012b	75 1b		 jne	 SHORT $LN13@z900_d250_

; 1395 :    {
; 1396 :        d250_restore(ioctl->dev);

  0012d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00135	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00139	e8 00 00 00 00	 call	 d250_restore

; 1397 :        /* Note: the device lock is now released */
; 1398 :        return PSC_REMOVED;

  0013e	b8 03 00 00 00	 mov	 eax, 3
  00143	e9 86 0a 00 00	 jmp	 $LN1@z900_d250_
$LN13@z900_d250_:

; 1399 :    }
; 1400 : 
; 1401 :    blocks=(int)ioctl->blkcount;

  00148	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00150	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00153	89 84 24 94 00
	00 00		 mov	 DWORD PTR blocks$[rsp], eax

; 1402 :    bioebeg=ioctl->listaddr & AMASK31 ;

  0015a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00162	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00165	0f ba f0 1f	 btr	 eax, 31
  00169	8b c0		 mov	 eax, eax
  0016b	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1403 : 
; 1404 :    /* Process each of the BIOE's supplied by the BIOPL count field */
; 1405 :    for ( block = 0 ; block < blocks ; block++ )

  00170	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR block$[rsp], 0
  00178	eb 0a		 jmp	 SHORT $LN4@z900_d250_
$LN2@z900_d250_:
  0017a	8b 44 24 7c	 mov	 eax, DWORD PTR block$[rsp]
  0017e	ff c0		 inc	 eax
  00180	89 44 24 7c	 mov	 DWORD PTR block$[rsp], eax
$LN4@z900_d250_:
  00184	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR blocks$[rsp]
  0018b	39 44 24 7c	 cmp	 DWORD PTR block$[rsp], eax
  0018f	0f 8d c7 09 00
	00		 jge	 $LN3@z900_d250_

; 1406 :    {
; 1407 :       status = 0xFF;  /* Set undefined status */

  00195	c6 44 24 60 ff	 mov	 BYTE PTR status$[rsp], 255 ; 000000ffH

; 1408 : 
; 1409 :       bioeend=( bioebeg + sizeof(BIOE32) - 1 ) & AMASK31;

  0019a	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  0019f	48 83 c0 0f	 add	 rax, 15
  001a3	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  001a9	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR bioeend$[rsp], rax

; 1410 :       xcode=ARCH_DEP(d250_addrck)

  001b1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001c9	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  001ce	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d4	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR bioeend$[rsp]
  001dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  001e1	e8 00 00 00 00	 call	 z900_d250_addrck
  001e6	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1411 :             (bioebeg,bioeend,ACCTYPE_READ,ioctl->key,ioctl->regs);
; 1412 :       if (ioctl->dev->ccwtrace)

  001eb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001f3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001f7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001fd	c1 e8 0f	 shr	 eax, 15
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	0f 84 b5 00 00
	00		 je	 $LN14@z900_d250_

; 1413 :       {
; 1414 :          WRMSG(HHC01929,"I",ioctl->dev->devnum,xcode,bioebeg,bioeend,ioctl->key);

  0020b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00213	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00217	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv152[rsp], eax
  0021e	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00223	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv156[rsp], ecx
  0022a	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00232	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00236	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0023a	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv160[rsp], edx
  00241	b9 01 00 00 00	 mov	 ecx, 1
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv152[rsp]
  00253	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00257	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR bioeend$[rsp]
  0025f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00264	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00269	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0026e	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv156[rsp]
  00275	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00279	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv160[rsp]
  00280	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193544
  0028b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193545
  00297	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193546
  002ae	ba 86 05 00 00	 mov	 edx, 1414		; 00000586H
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193547
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@z900_d250_:

; 1415 :       }
; 1416 :       if ( xcode )

  002c0	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  002c5	85 c0		 test	 eax, eax
  002c7	74 05		 je	 SHORT $LN15@z900_d250_

; 1417 :       {
; 1418 :          break;

  002c9	e9 8e 08 00 00	 jmp	 $LN3@z900_d250_
$LN15@z900_d250_:

; 1419 :       }
; 1420 : 
; 1421 :       /* Fetch the BIOE from storage */
; 1422 :       memcpy(&bioe,ioctl->regs->mainstor+bioebeg,sizeof(BIOE32));

  002ce	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  002d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d9	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002e0	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR bioe$[rsp]
  002e8	48 8b 54 24 68	 mov	 rdx, QWORD PTR bioebeg$[rsp]
  002ed	48 8b f9	 mov	 rdi, rcx
  002f0	48 8d 34 10	 lea	 rsi, QWORD PTR [rax+rdx]
  002f4	b9 10 00 00 00	 mov	 ecx, 16
  002f9	f3 a4		 rep movsb

; 1423 :       ARCH_DEP( or_storage_key )( bioebeg, STORKEY_REF );

  002fb	b2 04		 mov	 dl, 4
  002fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00302	e8 00 00 00 00	 call	 z900_or_storage_key

; 1424 :       ARCH_DEP( or_storage_key )( bioeend, STORKEY_REF );

  00307	b2 04		 mov	 dl, 4
  00309	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR bioeend$[rsp]
  00311	e8 00 00 00 00	 call	 z900_or_storage_key
$LN7@z900_d250_:

; 1425 : 
; 1426 :       /* Process a single BIOE */
; 1427 :       do
; 1428 :       {
; 1429 : 
; 1430 :          /* Make sure reserved field is zeros */
; 1431 :          if ( bioe.resv1[0]!=0x00 || bioe.resv1[1]!=0x00 )

  00316	b8 01 00 00 00	 mov	 eax, 1
  0031b	48 6b c0 00	 imul	 rax, rax, 0
  0031f	0f b6 84 04 fa
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp+rax+2]
  00327	85 c0		 test	 eax, eax
  00329	75 15		 jne	 SHORT $LN17@z900_d250_
  0032b	b8 01 00 00 00	 mov	 eax, 1
  00330	48 6b c0 01	 imul	 rax, rax, 1
  00334	0f b6 84 04 fa
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp+rax+2]
  0033c	85 c0		 test	 eax, eax
  0033e	74 0a		 je	 SHORT $LN16@z900_d250_
$LN17@z900_d250_:

; 1432 :          {
; 1433 :             status=BIOE_NOTZERO;

  00340	c6 44 24 60 0b	 mov	 BYTE PTR status$[rsp], 11

; 1434 :             continue;

  00345	e9 98 05 00 00	 jmp	 $LN5@z900_d250_
$LN16@z900_d250_:

; 1435 :          }
; 1436 : 
; 1437 :          /* Fetch and validate block number */
; 1438 :          FETCH_FW(blknum,&bioe.blknum);

  0034a	48 8d 8c 24 fc
	00 00 00	 lea	 rcx, QWORD PTR bioe$[rsp+4]
  00352	e8 00 00 00 00	 call	 fetch_fw_noswap
  00357	8b c8		 mov	 ecx, eax
  00359	e8 00 00 00 00	 call	 _byteswap_ulong
  0035e	89 44 24 78	 mov	 DWORD PTR blknum$[rsp], eax

; 1439 :          if ( (blknum < ioctl->dev->vmd250env->begblk) ||

  00362	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  00367	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0036f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00373	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0037a	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]
  0037e	7c 1e		 jl	 SHORT $LN19@z900_d250_
  00380	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  00385	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0038d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00391	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  00398	48 3b 41 20	 cmp	 rax, QWORD PTR [rcx+32]
  0039c	7e 0a		 jle	 SHORT $LN18@z900_d250_
$LN19@z900_d250_:

; 1440 :               (blknum > ioctl->dev->vmd250env->endblk)
; 1441 :             )
; 1442 :          {
; 1443 :             status=BIOE_BADBLOCK;

  0039e	c6 44 24 60 01	 mov	 BYTE PTR status$[rsp], 1

; 1444 :             continue;

  003a3	e9 3a 05 00 00	 jmp	 $LN5@z900_d250_
$LN18@z900_d250_:

; 1445 :          }
; 1446 : 
; 1447 :          /* Fetch the storage address used for I/O */
; 1448 :          FETCH_FW(bufbeg,&bioe.bufaddr);

  003a8	48 8d 8c 24 04
	01 00 00	 lea	 rcx, QWORD PTR bioe$[rsp+12]
  003b0	e8 00 00 00 00	 call	 fetch_fw_noswap
  003b5	8b c8		 mov	 ecx, eax
  003b7	e8 00 00 00 00	 call	 _byteswap_ulong
  003bc	8b c0		 mov	 eax, eax
  003be	48 89 44 24 70	 mov	 QWORD PTR bufbeg$[rsp], rax

; 1449 :          bufbeg &= AMASK31;

  003c3	48 8b 44 24 70	 mov	 rax, QWORD PTR bufbeg$[rsp]
  003c8	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  003ce	48 89 44 24 70	 mov	 QWORD PTR bufbeg$[rsp], rax

; 1450 : 
; 1451 :          /* Ensure the environment still exists */
; 1452 :          if (!ioctl->dev->vmd250env)

  003d3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  003db	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003df	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  003e7	75 20		 jne	 SHORT $LN20@z900_d250_

; 1453 :          {
; 1454 :             d250_restore(ioctl->dev);

  003e9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  003f1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003f5	e8 00 00 00 00	 call	 d250_restore

; 1455 :             /* Note: the device lock is now released */
; 1456 :             status=BIOE_ABORTED;

  003fa	c6 44 24 60 0c	 mov	 BYTE PTR status$[rsp], 12

; 1457 :             return PSC_REMOVED;

  003ff	b8 03 00 00 00	 mov	 eax, 3
  00404	e9 c5 07 00 00	 jmp	 $LN1@z900_d250_
$LN20@z900_d250_:

; 1458 :          }
; 1459 : 
; 1460 :          /* The I/O handler routines are normally called without the  */
; 1461 :          /* device lock being held.  The device is reserved by the    */
; 1462 :          /* busy status.                                              */
; 1463 : 
; 1464 :          /* Determine the last byte of the I/O buffer */
; 1465 :          bufend=( bufbeg + ioctl->dev->vmd250env->blksiz -1 ) & AMASK31 ;

  00409	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00411	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00415	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0041c	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00420	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00425	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0042a	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  00430	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR bufend$[rsp], rax

; 1466 : 
; 1467 :          if (ioctl->dev->ccwtrace)

  00438	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00440	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00444	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0044a	c1 e8 0f	 shr	 eax, 15
  0044d	83 e0 01	 and	 eax, 1
  00450	85 c0		 test	 eax, eax
  00452	0f 84 9f 00 00
	00		 je	 $LN21@z900_d250_

; 1468 :          {
; 1469 :             WRMSG (HHC01930, "I",

  00458	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  00460	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv234[rsp], eax
  00467	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0046f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00473	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00477	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv239[rsp], ecx
  0047e	b9 01 00 00 00	 mov	 ecx, 1
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00489	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  0048e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00493	8b 4c 24 78	 mov	 ecx, DWORD PTR blknum$[rsp]
  00497	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0049b	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv234[rsp]
  004a2	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  004ab	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004b0	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv239[rsp]
  004b7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193555
  004c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193556
  004ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  004de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193557
  004e5	ba c3 05 00 00	 mov	 edx, 1475		; 000005c3H
  004ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193558
  004f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@z900_d250_:

; 1470 :                      ioctl->dev->devnum,
; 1471 :                      bioebeg,
; 1472 :                      bioe.type,
; 1473 :                      blknum,
; 1474 :                      bufbeg
; 1475 :                     );
; 1476 :          }
; 1477 : 
; 1478 :          /* Determine the physical block on the device relative to zero */
; 1479 :          physblk=(S64)blknum+ioctl->dev->vmd250env->offset-1;

  004f7	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  004fc	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00504	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00508	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0050f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00513	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00518	89 84 24 90 00
	00 00		 mov	 DWORD PTR physblk$[rsp], eax

; 1480 :          /* The read/write routines will convert this to a physical disk */
; 1481 :          /* location for reading or writing                              */
; 1482 : 
; 1483 :          if (bioe.type == BIOE_READ)

  0051f	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  00527	83 f8 02	 cmp	 eax, 2
  0052a	0f 85 c1 01 00
	00		 jne	 $LN22@z900_d250_

; 1484 :          {
; 1485 :             xcode=ARCH_DEP(d250_addrck)

  00530	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00538	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0053b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00540	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00548	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  0054d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00553	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufend$[rsp]
  0055b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00560	e8 00 00 00 00	 call	 z900_d250_addrck
  00565	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1486 :                   (bufbeg,bufend,ACCTYPE_READ,ioctl->key,ioctl->regs);
; 1487 :             if (ioctl->dev->ccwtrace)

  0056a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00572	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00576	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0057c	c1 e8 0f	 shr	 eax, 15
  0057f	83 e0 01	 and	 eax, 1
  00582	85 c0		 test	 eax, eax
  00584	0f 84 b5 00 00
	00		 je	 $LN24@z900_d250_

; 1488 :             {
; 1489 :                WRMSG(HHC01931, "I",

  0058a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00592	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00596	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv273[rsp], eax
  0059d	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  005a2	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv277[rsp], ecx
  005a9	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  005b1	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  005b5	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  005b9	89 94 24 bc 00
	00 00		 mov	 DWORD PTR tv281[rsp], edx
  005c0	b9 01 00 00 00	 mov	 ecx, 1
  005c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005cb	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  005d2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  005d6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  005de	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  005e8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005ed	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv277[rsp]
  005f4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005f8	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  005ff	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00603	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193562
  0060a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0060f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193563
  00616	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0061b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00620	41 b9 03 00 00
	00		 mov	 r9d, 3
  00626	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193564
  0062d	ba d2 05 00 00	 mov	 edx, 1490		; 000005d2H
  00632	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193565
  00639	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@z900_d250_:

; 1490 :                        ioctl->dev->devnum,xcode,bufbeg,bufend,ioctl->key);
; 1491 :             }
; 1492 :             switch ( xcode )

  0063f	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00644	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv293[rsp], eax
  0064b	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR tv293[rsp], 4
  00653	74 16		 je	 SHORT $LN26@z900_d250_
  00655	83 bc 24 88 00
	00 00 05	 cmp	 DWORD PTR tv293[rsp], 5
  0065d	74 02		 je	 SHORT $LN25@z900_d250_
  0065f	eb 14		 jmp	 SHORT $LN8@z900_d250_
$LN25@z900_d250_:

; 1493 :             {
; 1494 :                case PGM_ADDRESSING_EXCEPTION:
; 1495 :                   status=BIOE_ADDREXC;

  00661	c6 44 24 60 02	 mov	 BYTE PTR status$[rsp], 2

; 1496 :                   continue;

  00666	e9 77 02 00 00	 jmp	 $LN5@z900_d250_
$LN26@z900_d250_:

; 1497 :                case PGM_PROTECTION_EXCEPTION:
; 1498 :                   status=BIOE_PROTEXC;

  0066b	c6 44 24 60 07	 mov	 BYTE PTR status$[rsp], 7

; 1499 :                   continue;

  00670	e9 6d 02 00 00	 jmp	 $LN5@z900_d250_
$LN8@z900_d250_:

; 1500 :             }
; 1501 :             /* At this point, the block number has been validated */
; 1502 :             /* and the buffer is addressable and accessible       */
; 1503 :             status=d250_read(ioctl->dev,

  00675	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0067d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00680	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00687	48 03 44 24 70	 add	 rax, QWORD PTR bufbeg$[rsp]
  0068c	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00694	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00698	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0069f	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR physblk$[rsp]
  006a7	4c 8b c8	 mov	 r9, rax
  006aa	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  006ae	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  006b6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  006ba	e8 00 00 00 00	 call	 d250_read
  006bf	88 44 24 60	 mov	 BYTE PTR status$[rsp], al

; 1504 :                                physblk,
; 1505 :                                ioctl->dev->vmd250env->blksiz,
; 1506 :                                ioctl->regs->mainstor+bufbeg);
; 1507 : 
; 1508 :             /* Set I/O storage key references if successful */
; 1509 :             if (!status)

  006c3	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  006c8	85 c0		 test	 eax, eax
  006ca	75 1b		 jne	 SHORT $LN27@z900_d250_

; 1510 :             {
; 1511 :                ARCH_DEP( or_storage_key )( bufbeg, STORKEY_REF );

  006cc	b2 04		 mov	 dl, 4
  006ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  006d3	e8 00 00 00 00	 call	 z900_or_storage_key

; 1512 :                ARCH_DEP( or_storage_key )( bufend, STORKEY_REF );

  006d8	b2 04		 mov	 dl, 4
  006da	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  006e2	e8 00 00 00 00	 call	 z900_or_storage_key
$LN27@z900_d250_:

; 1513 : 
; 1514 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1515 :                if ( ioctl->dev->vmd250env->blksiz == 4096 )
; 1516 :                {
; 1517 :                   ARCH_DEP( or_storage_key )( bufbeg+2048, STORKEY_REF );
; 1518 :                }
; 1519 : #endif
; 1520 :             }
; 1521 : 
; 1522 :             continue;

  006e7	e9 f6 01 00 00	 jmp	 $LN5@z900_d250_

; 1523 :          }  /* end of BIOE_READ */

  006ec	e9 f1 01 00 00	 jmp	 $LN23@z900_d250_
$LN22@z900_d250_:

; 1524 :          else
; 1525 :          {  if (bioe.type == BIOE_WRITE)

  006f1	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  006f9	83 f8 01	 cmp	 eax, 1
  006fc	0f 85 db 01 00
	00		 jne	 $LN28@z900_d250_

; 1526 :             {
; 1527 :                xcode=ARCH_DEP(d250_addrck)

  00702	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0070a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0070d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00712	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0071a	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  0071f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00725	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufend$[rsp]
  0072d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00732	e8 00 00 00 00	 call	 z900_d250_addrck
  00737	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1528 :                      (bufbeg,bufend,ACCTYPE_WRITE,ioctl->key,ioctl->regs);
; 1529 :                if (ioctl->dev->ccwtrace)

  0073c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00744	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00748	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0074e	c1 e8 0f	 shr	 eax, 15
  00751	83 e0 01	 and	 eax, 1
  00754	85 c0		 test	 eax, eax
  00756	0f 84 b5 00 00
	00		 je	 $LN30@z900_d250_

; 1530 :                {
; 1531 :                   WRMSG(HHC01932, "I",

  0075c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00764	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00768	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv332[rsp], eax
  0076f	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00774	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv336[rsp], ecx
  0077b	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00783	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00787	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0078b	89 94 24 c8 00
	00 00		 mov	 DWORD PTR tv340[rsp], edx
  00792	b9 01 00 00 00	 mov	 ecx, 1
  00797	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0079d	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv332[rsp]
  007a4	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  007a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  007b0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  007ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007bf	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv336[rsp]
  007c6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007ca	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv340[rsp]
  007d1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193572
  007dc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193573
  007e8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007f2	41 b9 03 00 00
	00		 mov	 r9d, 3
  007f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193574
  007ff	ba ff 05 00 00	 mov	 edx, 1535		; 000005ffH
  00804	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193575
  0080b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@z900_d250_:

; 1532 :                            ioctl->dev->devnum,
; 1533 :                            xcode,bufbeg,
; 1534 :                            bufend,
; 1535 :                            ioctl->key);
; 1536 :                }
; 1537 : 
; 1538 :                switch ( xcode )

  00811	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00816	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv352[rsp], eax
  0081d	83 bc 24 8c 00
	00 00 04	 cmp	 DWORD PTR tv352[rsp], 4
  00825	74 16		 je	 SHORT $LN32@z900_d250_
  00827	83 bc 24 8c 00
	00 00 05	 cmp	 DWORD PTR tv352[rsp], 5
  0082f	74 02		 je	 SHORT $LN31@z900_d250_
  00831	eb 14		 jmp	 SHORT $LN10@z900_d250_
$LN31@z900_d250_:

; 1539 :                {
; 1540 :                   case PGM_ADDRESSING_EXCEPTION:
; 1541 :                      status=BIOE_ADDREXC;

  00833	c6 44 24 60 02	 mov	 BYTE PTR status$[rsp], 2

; 1542 :                      continue;

  00838	e9 a5 00 00 00	 jmp	 $LN5@z900_d250_
$LN32@z900_d250_:

; 1543 :                   case PGM_PROTECTION_EXCEPTION:
; 1544 :                      status=BIOE_PROTEXC;

  0083d	c6 44 24 60 07	 mov	 BYTE PTR status$[rsp], 7

; 1545 :                      continue;

  00842	e9 9b 00 00 00	 jmp	 $LN5@z900_d250_
$LN10@z900_d250_:

; 1546 :                }
; 1547 : 
; 1548 :                if (ioctl->dev->vmd250env->isRO)

  00847	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0084f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00853	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0085a	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0085e	74 07		 je	 SHORT $LN33@z900_d250_

; 1549 :                {
; 1550 :                   status=BIOE_DASDRO;

  00860	c6 44 24 60 03	 mov	 BYTE PTR status$[rsp], 3

; 1551 :                   continue;

  00865	eb 7b		 jmp	 SHORT $LN5@z900_d250_
$LN33@z900_d250_:

; 1552 :                }
; 1553 :                status=d250_write(ioctl->dev,

  00867	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0086f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00872	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00879	48 03 44 24 70	 add	 rax, QWORD PTR bufbeg$[rsp]
  0087e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00886	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0088a	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  00891	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR physblk$[rsp]
  00899	4c 8b c8	 mov	 r9, rax
  0089c	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  008a0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  008a8	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  008ac	e8 00 00 00 00	 call	 d250_write
  008b1	88 44 24 60	 mov	 BYTE PTR status$[rsp], al

; 1554 :                                    physblk,
; 1555 :                                    ioctl->dev->vmd250env->blksiz,
; 1556 :                                    ioctl->regs->mainstor+bufbeg);
; 1557 : 
; 1558 :                /* Set I/O storage key references if good I/O */
; 1559 :                if (!status)

  008b5	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  008ba	85 c0		 test	 eax, eax
  008bc	75 1b		 jne	 SHORT $LN34@z900_d250_

; 1560 :                {
; 1561 :                   ARCH_DEP( or_storage_key )( bufbeg, (STORKEY_REF | STORKEY_CHANGE) );

  008be	b2 06		 mov	 dl, 6
  008c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  008c5	e8 00 00 00 00	 call	 z900_or_storage_key

; 1562 :                   ARCH_DEP( or_storage_key )( bufend, (STORKEY_REF | STORKEY_CHANGE) );

  008ca	b2 06		 mov	 dl, 6
  008cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  008d4	e8 00 00 00 00	 call	 z900_or_storage_key
$LN34@z900_d250_:

; 1563 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1564 :                   if ( ioctl->dev->vmd250env->blksiz == 4096 )
; 1565 :                   {
; 1566 :                      ARCH_DEP( or_storage_key )( bufbeg+2048, (STORKEY_REF | STORKEY_CHANGE) );
; 1567 :                   }
; 1568 : #endif
; 1569 :                }
; 1570 : 
; 1571 :                continue;

  008d9	eb 07		 jmp	 SHORT $LN5@z900_d250_

; 1572 :             } /* end of if BIOE_WRITE */

  008db	eb 05		 jmp	 SHORT $LN29@z900_d250_
$LN28@z900_d250_:

; 1573 :             else
; 1574 :             {
; 1575 :                status=BIOE_BADREQ;

  008dd	c6 44 24 60 06	 mov	 BYTE PTR status$[rsp], 6
$LN29@z900_d250_:
$LN23@z900_d250_:
$LN5@z900_d250_:

; 1576 :                continue;
; 1577 :             } /* end of else BIOE_WRITE */
; 1578 :          } /* end of else BIOE_READ */
; 1579 :       }while(0); /* end of do */

  008e2	33 c0		 xor	 eax, eax
  008e4	85 c0		 test	 eax, eax
  008e6	0f 85 2a fa ff
	ff		 jne	 $LN7@z900_d250_

; 1580 : 
; 1581 :       /* Determine if we can store the status in the BIOE */
; 1582 :       xcode=ARCH_DEP(d250_addrck)

  008ec	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  008f1	48 ff c0	 inc	 rax
  008f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  008f9	48 ff c1	 inc	 rcx
  008fc	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00904	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00907	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0090c	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00914	44 0f b6 4a 20	 movzx	 r9d, BYTE PTR [rdx+32]
  00919	41 b8 02 00 00
	00		 mov	 r8d, 2
  0091f	48 8b d0	 mov	 rdx, rax
  00922	e8 00 00 00 00	 call	 z900_d250_addrck
  00927	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1583 :             (bioebeg+1,bioebeg+1,ACCTYPE_WRITE,ioctl->key,ioctl->regs);
; 1584 :       if (ioctl->dev->ccwtrace)

  0092c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00934	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00938	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0093e	c1 e8 0f	 shr	 eax, 15
  00941	83 e0 01	 and	 eax, 1
  00944	85 c0		 test	 eax, eax
  00946	0f 84 bc 00 00
	00		 je	 $LN35@z900_d250_

; 1585 :       {
; 1586 :          WRMSG(HHC01933, "I",

  0094c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00954	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00958	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv396[rsp], eax
  0095f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00964	48 ff c1	 inc	 rcx
  00967	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv398[rsp], rcx
  0096f	48 8b 54 24 68	 mov	 rdx, QWORD PTR bioebeg$[rsp]
  00974	48 ff c2	 inc	 rdx
  00977	48 89 94 24 f0
	00 00 00	 mov	 QWORD PTR tv400[rsp], rdx
  0097f	0f b7 7c 24 64	 movzx	 edi, WORD PTR xcode$[rsp]
  00984	48 8b b4 24 30
	01 00 00	 mov	 rsi, QWORD PTR ioctl$[rsp]
  0098c	48 8b 76 08	 mov	 rsi, QWORD PTR [rsi+8]
  00990	0f b7 76 48	 movzx	 esi, WORD PTR [rsi+72]
  00994	b9 01 00 00 00	 mov	 ecx, 1
  00999	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0099f	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv396[rsp]
  009a6	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  009aa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv398[rsp]
  009b2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009b7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv400[rsp]
  009bf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009c4	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  009c8	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  009cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193581
  009d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193582
  009df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  009ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193583
  009f6	ba 33 06 00 00	 mov	 edx, 1587		; 00000633H
  009fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193584
  00a02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN35@z900_d250_:

; 1587 :                   ioctl->dev->devnum,xcode,bioebeg+1,bioebeg+1,ioctl->key);
; 1588 :       }
; 1589 : 
; 1590 :       /* If the status byte is store protected, give up on processing any */
; 1591 :       /* more BIOE's.  Leave the BIOE list process for loop               */
; 1592 :       if ( xcode )

  00a08	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00a0d	85 c0		 test	 eax, eax
  00a0f	74 05		 je	 SHORT $LN36@z900_d250_

; 1593 :       {
; 1594 :          break;

  00a11	e9 46 01 00 00	 jmp	 $LN3@z900_d250_
$LN36@z900_d250_:

; 1595 :       }
; 1596 : 
; 1597 :       /* Store the status in the BIOE */
; 1598 :       memcpy(ioctl->regs->mainstor+bioebeg+1,&status,1);

  00a16	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00a1e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a21	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00a28	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00a2d	0f b6 54 24 60	 movzx	 edx, BYTE PTR status$[rsp]
  00a32	88 54 08 01	 mov	 BYTE PTR [rax+rcx+1], dl

; 1599 : 
; 1600 :       /* Set the storage key change bit */
; 1601 :       ARCH_DEP( or_storage_key )( bioebeg+1, (STORKEY_REF | STORKEY_CHANGE) );

  00a36	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00a3b	48 ff c0	 inc	 rax
  00a3e	b2 06		 mov	 dl, 6
  00a40	48 8b c8	 mov	 rcx, rax
  00a43	e8 00 00 00 00	 call	 z900_or_storage_key

; 1602 : 
; 1603 :       if (ioctl->dev->ccwtrace)

  00a48	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00a50	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00a54	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00a5a	c1 e8 0f	 shr	 eax, 15
  00a5d	83 e0 01	 and	 eax, 1
  00a60	85 c0		 test	 eax, eax
  00a62	0f 84 8a 00 00
	00		 je	 $LN37@z900_d250_

; 1604 :       {
; 1605 :          WRMSG (HHC01934, "I", ioctl->dev->devnum,bioebeg,status);

  00a68	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00a6d	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv438[rsp], eax
  00a74	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00a7c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00a80	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00a84	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv443[rsp], ecx
  00a8b	b9 01 00 00 00	 mov	 ecx, 1
  00a90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a96	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv438[rsp]
  00a9d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00aa1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00aa6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00aab	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv443[rsp]
  00ab2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ab6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193587
  00abd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ac2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193588
  00ac9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ace	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ad3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ad9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193589
  00ae0	ba 45 06 00 00	 mov	 edx, 1605		; 00000645H
  00ae5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193590
  00aec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN37@z900_d250_:

; 1606 :       }
; 1607 : 
; 1608 :       /* Count if this BIOE was a success or failure */
; 1609 :       if ( status )

  00af2	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00af7	85 c0		 test	 eax, eax
  00af9	74 26		 je	 SHORT $LN38@z900_d250_

; 1610 :       {
; 1611 :          ioctl->badblks+=1;

  00afb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b03	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b06	ff c0		 inc	 eax
  00b08	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00b10	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1612 :          if ( status == BIOE_ABORTED )

  00b13	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00b18	83 f8 0c	 cmp	 eax, 12
  00b1b	75 02		 jne	 SHORT $LN40@z900_d250_

; 1613 :          {
; 1614 :              break;

  00b1d	eb 3d		 jmp	 SHORT $LN3@z900_d250_
$LN40@z900_d250_:

; 1615 :          }
; 1616 :       }

  00b1f	eb 18		 jmp	 SHORT $LN39@z900_d250_
$LN38@z900_d250_:

; 1617 :       else
; 1618 :       {
; 1619 :          ioctl->goodblks+=1;

  00b21	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b29	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00b2c	ff c0		 inc	 eax
  00b2e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00b36	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN39@z900_d250_:

; 1620 :       }
; 1621 : 
; 1622 :       /* Determine the address of the next BIOE */
; 1623 :       bioebeg += sizeof(BIOE32);

  00b39	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00b3e	48 83 c0 10	 add	 rax, 16
  00b42	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1624 :       bioebeg &= AMASK31;

  00b47	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00b4c	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  00b52	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1625 :    } /* end of for loop */

  00b57	e9 1e f6 ff ff	 jmp	 $LN2@z900_d250_
$LN3@z900_d250_:

; 1626 : 
; 1627 : #if 0
; 1628 :    LOGMSG( "(d250_list32) BIOE's processed: %d\n", block );
; 1629 : #endif
; 1630 : 
; 1631 :    /* Restore device to guest ownership */
; 1632 :    d250_restore(ioctl->dev);

  00b5c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b64	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00b68	e8 00 00 00 00	 call	 d250_restore

; 1633 :    /* Note: device lock not held */
; 1634 : 
; 1635 :    /* If an access exception occurred:                                 */
; 1636 :    /*   If this is a synchronous request, generate a program exception */
; 1637 :    /*   or if this is asynchrnous, just return with a storage error    */
; 1638 :    if ( xcode )

  00b6d	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00b72	85 c0		 test	 eax, eax
  00b74	74 2a		 je	 SHORT $LN41@z900_d250_

; 1639 :    {
; 1640 :       if (async)

  00b76	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR async$[rsp], 0
  00b7e	74 09		 je	 SHORT $LN42@z900_d250_

; 1641 :           return PSC_STGERR;

  00b80	b8 02 00 00 00	 mov	 eax, 2
  00b85	eb 47		 jmp	 SHORT $LN1@z900_d250_
  00b87	eb 17		 jmp	 SHORT $LN43@z900_d250_
$LN42@z900_d250_:

; 1642 :       else
; 1643 :           ARCH_DEP(program_interrupt)(ioctl->regs, xcode);

  00b89	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00b8e	8b d0		 mov	 edx, eax
  00b90	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b98	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00b9b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN43@z900_d250_:
$LN41@z900_d250_:

; 1644 :    }
; 1645 : 
; 1646 :    if ( status == BIOE_ABORTED )

  00ba0	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00ba5	83 f8 0c	 cmp	 eax, 12
  00ba8	75 07		 jne	 SHORT $LN44@z900_d250_

; 1647 :    {
; 1648 :       return PSC_REMOVED;

  00baa	b8 03 00 00 00	 mov	 eax, 3
  00baf	eb 1d		 jmp	 SHORT $LN1@z900_d250_
$LN44@z900_d250_:

; 1649 :    }
; 1650 : 
; 1651 :    /* Determine if we were completely successful or only partially     */
; 1652 :    /* successful.  'Partial' includes none successful.                 */
; 1653 :    /* Synchronous and asynchronous requests handle all failed          */
; 1654 :    /* differently. The good and bad blocks field are used by the       */
; 1655 :    /* caller                                                           */
; 1656 :    if (ioctl->goodblks < blocks)

  00bb1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00bb9	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR blocks$[rsp]
  00bc0	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  00bc3	7d 07		 jge	 SHORT $LN45@z900_d250_

; 1657 :    {
; 1658 :       return PSC_PARTIAL;

  00bc5	b8 01 00 00 00	 mov	 eax, 1
  00bca	eb 02		 jmp	 SHORT $LN1@z900_d250_
$LN45@z900_d250_:

; 1659 :    }
; 1660 :    return PSC_SUCCESS;

  00bcc	33 c0		 xor	 eax, eax
$LN1@z900_d250_:

; 1661 : 
; 1662 : } /* end function d250_list32 */

  00bce	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00bd6	48 33 cc	 xor	 rcx, rsp
  00bd9	e8 00 00 00 00	 call	 __security_check_cookie
  00bde	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00be5	5f		 pop	 rdi
  00be6	5e		 pop	 rsi
  00be7	c3		 ret	 0
z900_d250_list32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
psc$ = 96
tv289 = 100
rc2$ = 104
tv164 = 108
tv169 = 112
tv248 = 116
tv253 = 120
tv274 = 124
tv277 = 128
tv291 = 132
asyncp$ = 136
ioctl$ = 144
$T1 = 192
tid$ = 200
tv186 = 208
tv229 = 216
bioplx00$ = 224
tname$ = 288
buf$2 = 320
__$ArrayPad$ = 360
dev$ = 400
rc$ = 408
biopl$ = 416
regs$ = 424
z900_d250_iorq32 PROC

; 1176 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1177 : BIOPL_IORQ32   bioplx00;  /* Used to check reserved fields */
; 1178 : IOCTL32 ioctl;            /* Request information */
; 1179 : BYTE    psc;              /* List processing status code */
; 1180 : 
; 1181 : /* Asynchronous request related fields */
; 1182 : TID     tid;         /* Asynchronous thread ID */
; 1183 : char    tname[32];   /* Thread name */
; 1184 : IOCTL32 *asyncp;     /* Pointer to async thread's storage */
; 1185 : int     rc2;
; 1186 : 
; 1187 :    /* Clear the reserved BIOPL */
; 1188 :    memset(&bioplx00,0,sizeof(BIOPL_IORQ32));

  0002f	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR bioplx00$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00041	f3 aa		 rep stosb

; 1189 : 
; 1190 :    /* Make sure reserved fields and bits are binary zeros  */
; 1191 :    if ((memcmp(&biopl->resv1,&bioplx00,IORQ32R1_LEN)!=0) ||
; 1192 :        (memcmp(&biopl->resv2,&bioplx00,IORQ32R2_LEN)!=0) ||
; 1193 :        (memcmp(&biopl->resv3,&bioplx00,IORQ32R3_LEN)!=0) ||
; 1194 :        (biopl->flags & BIOPL_FLAGSRSV) ||

  00043	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	41 b8 15 00 00
	00		 mov	 r8d, 21
  00055	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 memcmp
  00065	85 c0		 test	 eax, eax
  00067	75 74		 jne	 SHORT $LN5@z900_d250_
  00069	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00071	48 83 c0 1a	 add	 rax, 26
  00075	41 b8 02 00 00
	00		 mov	 r8d, 2
  0007b	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 memcmp
  0008b	85 c0		 test	 eax, eax
  0008d	75 4e		 jne	 SHORT $LN5@z900_d250_
  0008f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00097	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0009b	41 b8 14 00 00
	00		 mov	 r8d, 20
  000a1	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 memcmp
  000b1	85 c0		 test	 eax, eax
  000b3	75 28		 jne	 SHORT $LN5@z900_d250_
  000b5	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000bd	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  000c1	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  000c6	85 c0		 test	 eax, eax
  000c8	75 13		 jne	 SHORT $LN5@z900_d250_
  000ca	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000d2	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  000d6	83 e0 0f	 and	 eax, 15
  000d9	85 c0		 test	 eax, eax
  000db	74 12		 je	 SHORT $LN4@z900_d250_
$LN5@z900_d250_:

; 1195 :        (biopl->key & BIOPL_KEYRSV)
; 1196 :       )
; 1197 :    {
; 1198 :        ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000dd	ba 06 00 00 00	 mov	 edx, 6
  000e2	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	e8 00 00 00 00	 call	 z900_program_interrupt
$LN4@z900_d250_:

; 1199 :    }
; 1200 : 
; 1201 :    /* Return with an error return code if the device does not exist */
; 1202 :    if (!dev)

  000ef	48 83 bc 24 90
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f8	75 18		 jne	 SHORT $LN6@z900_d250_

; 1203 :    {
; 1204 :       *rc = RC_NODEV;  /* Set the return code for no device */

  000fa	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00102	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 1205 :       return CC_FAILED; /* Indicate the function failed     */

  00108	b8 02 00 00 00	 mov	 eax, 2
  0010d	e9 7e 06 00 00	 jmp	 $LN1@z900_d250_
$LN6@z900_d250_:

; 1206 :    }
; 1207 : 
; 1208 :    /* If no environment, return with an error */
; 1209 :    if (!(dev->vmd250env))

  00112	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011a	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  00122	75 18		 jne	 SHORT $LN7@z900_d250_

; 1210 :    {
; 1211 :       *rc = RC_STATERR;

  00124	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0012c	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 1212 :       return CC_FAILED;

  00132	b8 02 00 00 00	 mov	 eax, 2
  00137	e9 54 06 00 00	 jmp	 $LN1@z900_d250_
$LN7@z900_d250_:

; 1213 :    }
; 1214 : 
; 1215 :    /* Fetch the block count from the BIOPL */
; 1216 :    FETCH_FW(ioctl.blkcount,&biopl->blkcount);

  0013c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00144	48 83 c0 1c	 add	 rax, 28
  00148	48 8b c8	 mov	 rcx, rax
  0014b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00150	8b c8		 mov	 ecx, eax
  00152	e8 00 00 00 00	 call	 _byteswap_ulong
  00157	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+24], eax

; 1217 : 
; 1218 :    /* Block count must be between 1 and 256, inclusive */
; 1219 :    if ((ioctl.blkcount<1) || (ioctl.blkcount>256))

  0015e	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR ioctl$[rsp+24], 1
  00166	7c 0d		 jl	 SHORT $LN9@z900_d250_
  00168	81 bc 24 a8 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR ioctl$[rsp+24], 256 ; 00000100H
  00173	7e 18		 jle	 SHORT $LN8@z900_d250_
$LN9@z900_d250_:

; 1220 :    {
; 1221 :        *rc = RC_CNT_ERR;

  00175	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0017d	c7 00 24 00 00
	00		 mov	 DWORD PTR [rax], 36	; 00000024H

; 1222 :        return CC_FAILED;

  00183	b8 02 00 00 00	 mov	 eax, 2
  00188	e9 03 06 00 00	 jmp	 $LN1@z900_d250_
$LN8@z900_d250_:

; 1223 :    }
; 1224 : 
; 1225 :    /* Fetch the address of the BIO entry list from the BIOPL */
; 1226 :    FETCH_FW(ioctl.listaddr,&biopl->bioeladr);

  0018d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00195	48 83 c0 24	 add	 rax, 36			; 00000024H
  00199	48 8b c8	 mov	 rcx, rax
  0019c	e8 00 00 00 00	 call	 fetch_fw_noswap
  001a1	8b c8		 mov	 ecx, eax
  001a3	e8 00 00 00 00	 call	 _byteswap_ulong
  001a8	89 84 24 ac 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+28], eax

; 1227 : 
; 1228 :    /* Extract the storage key from the BIOPL */
; 1229 :    ioctl.key=biopl->key;

  001af	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  001b7	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  001bb	88 84 24 b0 00
	00 00		 mov	 BYTE PTR ioctl$[rsp+32], al

; 1230 : 
; 1231 :    /* Set the structures that are involved in this request */
; 1232 :    ioctl.dev = dev;

  001c2	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR ioctl$[rsp+8], rax

; 1233 :    ioctl.regs = regs;

  001d2	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001da	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ioctl$[rsp], rax

; 1234 : 
; 1235 :    /* Set I/O success/failure counts to zero */
; 1236 :    ioctl.goodblks = 0;

  001e2	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ioctl$[rsp+36], 0

; 1237 :    ioctl.badblks = 0;

  001ed	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ioctl$[rsp+40], 0

; 1238 : 
; 1239 :    if (biopl->flags & BIOPL_ASYNC)

  001f8	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00200	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00204	83 e0 02	 and	 eax, 2
  00207	85 c0		 test	 eax, eax
  00209	0f 84 2a 03 00
	00		 je	 $LN10@z900_d250_

; 1240 :    {
; 1241 :        /* Build the request structure */
; 1242 : 
; 1243 :        /* Extract the 32-bit interrupt parameter from the BIOPL */
; 1244 :        FETCH_FW(ioctl.intrparm,biopl->intparm);

  0020f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00217	48 83 c0 28	 add	 rax, 40			; 00000028H
  0021b	48 8b c8	 mov	 rcx, rax
  0021e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00223	8b c8		 mov	 ecx, eax
  00225	e8 00 00 00 00	 call	 _byteswap_ulong
  0022a	89 84 24 a4 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+20], eax

; 1245 : 
; 1246 :        if (dev->ccwtrace)

  00231	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00239	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0023f	c1 e8 0f	 shr	 eax, 15
  00242	83 e0 01	 and	 eax, 1
  00245	85 c0		 test	 eax, eax
  00247	0f 84 94 00 00
	00		 je	 $LN12@z900_d250_

; 1247 :        {
; 1248 :           WRMSG(HHC01924, "I",

  0024d	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR ioctl$[rsp+32]
  00255	89 44 24 6c	 mov	 DWORD PTR tv164[rsp], eax
  00259	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00261	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00265	89 4c 24 70	 mov	 DWORD PTR tv169[rsp], ecx
  00269	b9 01 00 00 00	 mov	 ecx, 1
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00274	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+20]
  0027b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0027f	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv164[rsp]
  00283	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00287	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+24]
  0028e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00292	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+28]
  00299	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0029d	8b 4c 24 70	 mov	 ecx, DWORD PTR tv169[rsp]
  002a1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193467
  002ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193468
  002b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193469
  002cf	ba e5 04 00 00	 mov	 edx, 1253		; 000004e5H
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193470
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@z900_d250_:

; 1249 :                    dev->devnum,
; 1250 :                    ioctl.listaddr,
; 1251 :                    ioctl.blkcount,
; 1252 :                    ioctl.key,
; 1253 :                    ioctl.intrparm);
; 1254 :        }
; 1255 : 
; 1256 :        /* Set the default status code to an aborted list */
; 1257 :        /* Note: This should be set correctly from the returned PSC */
; 1258 :        ioctl.statuscod = PSC_STGERR;

  002e1	c6 84 24 a1 00
	00 00 02	 mov	 BYTE PTR ioctl$[rsp+17], 2

; 1259 : 
; 1260 :        /* Get the storage for the thread's parameters */
; 1261 :        if (!(asyncp=(IOCTL32 *)malloc(sizeof(IOCTL32))))

  002e9	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  002f4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR asyncp$[rsp], rax
  002fc	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR asyncp$[rsp], 0
  00305	0f 85 af 00 00
	00		 jne	 $LN13@z900_d250_

; 1262 :        {
; 1263 :           char buf[40];
; 1264 :           MSGBUF(buf, "malloc(%d)", (int)sizeof(IOCTL32));

  0030b	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00311	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193472
  00318	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0031d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1265 :           WRMSG (HHC01908, "E", buf, strerror(errno));

  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00331	8b 08		 mov	 ecx, DWORD PTR [rax]
  00333	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00339	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  00341	b9 01 00 00 00	 mov	 ecx, 1
  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv186[rsp]
  00354	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00359	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00361	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193473
  0036d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193474
  00379	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00383	41 b9 03 00 00
	00		 mov	 r9d, 3
  00389	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193475
  00390	ba f1 04 00 00	 mov	 edx, 1265		; 000004f1H
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193476
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1266 :           *rc = RC_ERROR;

  003a2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  003aa	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1267 :           return CC_FAILED;

  003b0	b8 02 00 00 00	 mov	 eax, 2
  003b5	e9 d6 03 00 00	 jmp	 $LN1@z900_d250_
$LN13@z900_d250_:

; 1268 :        }
; 1269 : 
; 1270 :        /* Copy the thread's parameters to its own storage */
; 1271 :        memcpy(asyncp,&ioctl,sizeof(IOCTL32));

  003ba	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ioctl$[rsp]
  003c2	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR asyncp$[rsp]
  003ca	48 8b f0	 mov	 rsi, rax
  003cd	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  003d2	f3 a4		 rep movsb

; 1272 : 
; 1273 :        /* Launch the asynchronous request on a separate thread */
; 1274 :        MSGBUF(tname,"d250_async %4.4X",dev->devnum);

  003d4	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003e0	44 8b c8	 mov	 r9d, eax
  003e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193477
  003ea	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  003ef	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tname$[rsp]
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1275 :        tname[sizeof(tname)-1]=0;

  003fd	b8 01 00 00 00	 mov	 eax, 1
  00402	48 6b c0 1f	 imul	 rax, rax, 31
  00406	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  0040e	48 83 bc 24 c0
	00 00 00 20	 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  00417	73 02		 jae	 SHORT $LN24@z900_d250_
  00419	eb 05		 jmp	 SHORT $LN25@z900_d250_
$LN24@z900_d250_:
  0041b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN25@z900_d250_:
  00420	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00428	c6 84 04 20 01
	00 00 00	 mov	 BYTE PTR tname$[rsp+rax], 0

; 1276 :        rc2 = create_thread (&tid, DETACHED, ARCH_DEP(d250_async32),

  00430	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00437	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0043d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193478
  00444	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00449	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tname$[rsp]
  00451	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00456	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR asyncp$[rsp]
  0045e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:z900_d250_async32
  00465	48 8b d0	 mov	 rdx, rax
  00468	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  00470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00476	89 44 24 68	 mov	 DWORD PTR rc2$[rsp], eax

; 1277 :                asyncp, tname);
; 1278 :        if(rc2)

  0047a	83 7c 24 68 00	 cmp	 DWORD PTR rc2$[rsp], 0
  0047f	0f 84 9a 00 00
	00		 je	 $LN14@z900_d250_

; 1279 :        {
; 1280 :           WRMSG (HHC00102, "E", strerror(rc2));

  00485	8b 4c 24 68	 mov	 ecx, DWORD PTR rc2$[rsp]
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0048f	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
  00497	b9 01 00 00 00	 mov	 ecx, 1
  0049c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004a2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv229[rsp]
  004aa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193480
  004b6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193481
  004c2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004cc	41 b9 03 00 00
	00		 mov	 r9d, 3
  004d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193482
  004d9	ba 00 05 00 00	 mov	 edx, 1280		; 00000500H
  004de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193483
  004e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1281 :           release_lock (&dev->lock);

  004eb	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f3	48 83 c0 38	 add	 rax, 56			; 00000038H
  004f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193484
  004fe	48 8b c8	 mov	 rcx, rax
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1282 :           *rc = RC_ERROR;

  00507	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0050f	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1283 :           return CC_FAILED;

  00515	b8 02 00 00 00	 mov	 eax, 2
  0051a	e9 71 02 00 00	 jmp	 $LN1@z900_d250_
$LN14@z900_d250_:

; 1284 :        }
; 1285 :        /* Launched the async request successfully */
; 1286 :        *rc = RC_ASYNC;

  0051f	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00527	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 1287 :        return CC_SUCCESS;

  0052d	33 c0		 xor	 eax, eax
  0052f	e9 5c 02 00 00	 jmp	 $LN1@z900_d250_

; 1288 :    }

  00534	e9 60 01 00 00	 jmp	 $LN11@z900_d250_
$LN10@z900_d250_:

; 1289 :    else
; 1290 :    {
; 1291 :        /* Perform the I/O request synchronously on this thread */
; 1292 :        /* Call the 32-bit BIOE request processor */
; 1293 :        if (dev->ccwtrace)

  00539	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00541	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00547	c1 e8 0f	 shr	 eax, 15
  0054a	83 e0 01	 and	 eax, 1
  0054d	85 c0		 test	 eax, eax
  0054f	0f 84 89 00 00
	00		 je	 $LN15@z900_d250_

; 1294 :        {
; 1295 :           WRMSG(HHC01925, "I",

  00555	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR ioctl$[rsp+32]
  0055d	89 44 24 74	 mov	 DWORD PTR tv248[rsp], eax
  00561	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00569	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0056d	89 4c 24 78	 mov	 DWORD PTR tv253[rsp], ecx
  00571	b9 01 00 00 00	 mov	 ecx, 1
  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv248[rsp]
  00580	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00584	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+24]
  0058b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0058f	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+28]
  00596	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0059a	8b 4c 24 78	 mov	 ecx, DWORD PTR tv253[rsp]
  0059e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193486
  005a9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193487
  005b5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005bf	41 b9 03 00 00
	00		 mov	 r9d, 3
  005c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193488
  005cc	ba 13 05 00 00	 mov	 edx, 1299		; 00000513H
  005d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193489
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@z900_d250_:

; 1296 :                    dev->devnum,
; 1297 :                    ioctl.listaddr,
; 1298 :                    ioctl.blkcount,
; 1299 :                    ioctl.key);
; 1300 :        }
; 1301 : 
; 1302 :        psc=ARCH_DEP(d250_list32)(&ioctl, SYNC);

  005de	33 d2		 xor	 edx, edx
  005e0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ioctl$[rsp]
  005e8	e8 00 00 00 00	 call	 z900_d250_list32
  005ed	88 44 24 60	 mov	 BYTE PTR psc$[rsp], al

; 1303 : 
; 1304 :        if (dev->ccwtrace)

  005f1	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005ff	c1 e8 0f	 shr	 eax, 15
  00602	83 e0 01	 and	 eax, 1
  00605	85 c0		 test	 eax, eax
  00607	0f 84 8c 00 00
	00		 je	 $LN16@z900_d250_

; 1305 :        {
; 1306 :           WRMSG(HHC01926, "I", dev->devnum,psc,ioctl.goodblks,ioctl.badblks);

  0060d	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  00612	89 44 24 7c	 mov	 DWORD PTR tv274[rsp], eax
  00616	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0061e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00622	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv277[rsp], ecx
  00629	b9 01 00 00 00	 mov	 ecx, 1
  0062e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00634	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+40]
  0063b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0063f	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+36]
  00646	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0064a	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv274[rsp]
  0064e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00652	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv277[rsp]
  00659	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0065d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193491
  00664	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00669	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193492
  00670	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00675	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0067a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00680	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193493
  00687	ba 1a 05 00 00	 mov	 edx, 1306		; 0000051aH
  0068c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193494
  00693	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@z900_d250_:
$LN11@z900_d250_:

; 1307 :        }
; 1308 : 
; 1309 :    }
; 1310 : 
; 1311 :    /* Processor status used to determine return and condition codes */
; 1312 :    switch(psc)

  00699	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  0069e	88 44 24 64	 mov	 BYTE PTR tv289[rsp], al
  006a2	80 7c 24 64 00	 cmp	 BYTE PTR tv289[rsp], 0
  006a7	74 10		 je	 SHORT $LN17@z900_d250_
  006a9	80 7c 24 64 01	 cmp	 BYTE PTR tv289[rsp], 1
  006ae	74 1e		 je	 SHORT $LN18@z900_d250_
  006b0	80 7c 24 64 03	 cmp	 BYTE PTR tv289[rsp], 3
  006b5	74 53		 je	 SHORT $LN21@z900_d250_
  006b7	eb 66		 jmp	 SHORT $LN22@z900_d250_
$LN17@z900_d250_:

; 1313 :    {
; 1314 :       case PSC_SUCCESS:
; 1315 :          *rc = RC_SUCCESS;

  006b9	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006c1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1316 :          return CC_SUCCESS;

  006c7	33 c0		 xor	 eax, eax
  006c9	e9 c2 00 00 00	 jmp	 $LN1@z900_d250_
$LN18@z900_d250_:

; 1317 :       case PSC_PARTIAL:
; 1318 :          if (ioctl.goodblks == 0)

  006ce	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR ioctl$[rsp+36], 0
  006d6	75 1a		 jne	 SHORT $LN19@z900_d250_

; 1319 :          {
; 1320 :             *rc = RC_ALL_BAD;

  006d8	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006e0	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 1321 :             return CC_FAILED;

  006e6	b8 02 00 00 00	 mov	 eax, 2
  006eb	e9 a0 00 00 00	 jmp	 $LN1@z900_d250_

; 1322 :          }

  006f0	eb 18		 jmp	 SHORT $LN20@z900_d250_
$LN19@z900_d250_:

; 1323 :          else
; 1324 :          {
; 1325 :             *rc = RC_SYN_PART;

  006f2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006fa	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 1326 :             return CC_PARTIAL;

  00700	b8 01 00 00 00	 mov	 eax, 1
  00705	e9 86 00 00 00	 jmp	 $LN1@z900_d250_
$LN20@z900_d250_:
$LN21@z900_d250_:

; 1327 :          }
; 1328 :       case PSC_REMOVED:
; 1329 :          *rc = RC_REM_PART;

  0070a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00712	c7 00 2c 00 00
	00		 mov	 DWORD PTR [rax], 44	; 0000002cH

; 1330 :          return CC_PARTIAL;

  00718	b8 01 00 00 00	 mov	 eax, 1
  0071d	eb 71		 jmp	 SHORT $LN1@z900_d250_
$LN22@z900_d250_:

; 1331 :       default:
; 1332 :          WRMSG (HHC01927, "I", psc);

  0071f	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  00724	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv291[rsp], eax
  0072b	b9 01 00 00 00	 mov	 ecx, 1
  00730	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00736	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  0073d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00741	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193501
  00748	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0074d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193502
  00754	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00759	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0075e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00764	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193503
  0076b	ba 34 05 00 00	 mov	 edx, 1332		; 00000534H
  00770	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193504
  00777	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1333 :          *rc = RC_ERROR;

  0077d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00785	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1334 :          return CC_FAILED;

  0078b	b8 02 00 00 00	 mov	 eax, 2
$LN1@z900_d250_:
$LN23@z900_d250_:

; 1335 :    }
; 1336 : 
; 1337 : } /* end function ARCH_DEP(d250_iorq32) */

  00790	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00798	48 33 cc	 xor	 rcx, rsp
  0079b	e8 00 00 00 00	 call	 __security_check_cookie
  007a0	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  007a7	5f		 pop	 rdi
  007a8	5e		 pop	 rsi
  007a9	c3		 ret	 0
z900_d250_iorq32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_storage_key
_TEXT	SEGMENT
abs$ = 48
z900_get_storage_key PROC				; COMDAT

; 254  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 255  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 256  :     return ARCH_DEP( get_2K_storage_key )( abs );
; 257  : #else
; 258  :     return ARCH_DEP( get_4K_storage_key )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 z900_get_4K_storage_key

; 259  : #endif
; 260  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
z900_get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
z900_get_4K_storage_key PROC				; COMDAT

; 239  :   inline BYTE  ARCH_DEP( get_4K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 z900__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
z900_get_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
z900__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@z900__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $LN5@z900__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0001e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00026	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0002f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00041	0b c8		 or	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00049	eb 16		 jmp	 SHORT $LN6@z900__get_
$LN5@z900__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  0004b	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00055	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@z900__get_:

; 140  :     return skey;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
z900__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
rc$ = 48
cc$ = 52
devnum$ = 56
tv92 = 60
dev$ = 64
biopaddr$ = 72
bioplin$ = 80
__$ArrayPad$ = 144
r1$ = 176
r2$ = 184
regs$ = 192
z900_vm_blockio PROC

; 981  : {

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 982  : /* Guest related paramters and values                                */
; 983  : RADR    biopaddr;                      /* BIOPL address              */
; 984  : 
; 985  : union   parmlist{                      /* BIOPL formats that         */
; 986  :         BIOPL biopl;                   /* May be supplied by the     */
; 987  :         BIOPL_INIT32 init32;           /* guest                      */
; 988  :         BIOPL_IORQ32 iorq32;
; 989  :         BIOPL_REMOVE remove;
; 990  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 991  :         BIOPL_INIT64 init64;
; 992  :         BIOPL_IORQ64 iorq64;
; 993  : #endif /* defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) */
; 994  :         };
; 995  : union   parmlist bioplin;              /* BIOPL from/to guest        */
; 996  : 
; 997  : U16     devnum;                        /* Device number              */
; 998  : DEVBLK *dev;                           /* --> Device block           */
; 999  : int     rc;                            /* return code in Rx+1        */
; 1000 : int     cc;                            /* condition code             */
; 1001 : 
; 1002 :     rc = RC_ERROR; /* Initialize the return code to error */

  00026	c7 44 24 30 ff
	00 00 00	 mov	 DWORD PTR rc$[rsp], 255	; 000000ffH

; 1003 :     cc = CC_FAILED; /* Failure assumed unless otherwise successful */

  0002e	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1004 : 
; 1005 : #if 0 // debug
; 1006 :     if (sizeof(BIOPL) != 64)
; 1007 :     {
; 1008 :             LOGMSG( "BIOPL size not 64: %d\n", sizeof( BIOPL ));
; 1009 :     }
; 1010 :     if (sizeof(BIOPL_INIT32) != 64)
; 1011 :     {
; 1012 :             LOGMSG( "BIOPL_INIT32 size not 64: %d\n", sizeof( BIOPL_INIT32 ));
; 1013 :     }
; 1014 :     if (sizeof(BIOPL_INIT64) != 64)
; 1015 :     {
; 1016 :             LOGMSG( "BIOPL_INIT64 size not 64: %d\n", sizeof( BIOPL_INIT64 ));
; 1017 :     }
; 1018 :     if (sizeof(BIOPL_IORQ32) != 64)
; 1019 :     {
; 1020 :             LOGMSG( "BIOPL_IORQ32 size not 64: %d\n", sizeof( BIOPL_IORQ32 ));
; 1021 :     }
; 1022 :     if (sizeof(BIOPL_REMOVE) != 64)
; 1023 :     {
; 1024 :             LOGMSG( "BIOPL_REMOVE size not 64: %d\n", sizeof( BIOPL_REMOVE ));
; 1025 :     }
; 1026 :     if (sizeof(BIOPL_IORQ64) != 64)
; 1027 :     {
; 1028 :             LOGMSG( "BIOPL_IORQ64 size not 64: %d\n", sizeof( BIOPL_IORQ64 ));
; 1029 :     }
; 1030 :     if (sizeof(BIOE32) != 16)
; 1031 :     {
; 1032 :             LOGMSG( "BIOE32 size not 16: %d\n", sizeof( BIOE32 ));
; 1033 :     }
; 1034 :     if (sizeof(BIOE64) != 24)
; 1035 :     {
; 1036 :             LOGMSG( "BIOE64 size not 24: %d\n", sizeof( BIOE64 ));
; 1037 :     }
; 1038 : #endif
; 1039 : 
; 1040 :     /* Retrieve the BIOPL address from R1 */
; 1041 :     biopaddr = regs->GR(r1);

  00036	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0004e	48 89 44 24 48	 mov	 QWORD PTR biopaddr$[rsp], rax

; 1042 : 
; 1043 :     /* Specification exception if the BIOPL is not on a doubleword boundary */
; 1044 :     if (biopaddr & 0x00000007)

  00053	48 8b 44 24 48	 mov	 rax, QWORD PTR biopaddr$[rsp]
  00058	48 83 e0 07	 and	 rax, 7
  0005c	48 85 c0	 test	 rax, rax
  0005f	74 12		 je	 SHORT $LN4@z900_vm_bl

; 1045 :     {
; 1046 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN4@z900_vm_bl:

; 1047 :     }
; 1048 : 
; 1049 :     /* Fetch the BIOPL from guest storage */
; 1050 :     ARCH_DEP(wfetchc) (&bioplin, sizeof(bioplin)-1,

  00073	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR biopaddr$[rsp]
  00087	48 23 c8	 and	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00095	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0009a	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000a0	4c 8b c0	 mov	 r8, rax
  000a3	b2 3f		 mov	 dl, 63			; 0000003fH
  000a5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  000aa	e8 00 00 00 00	 call	 z900_vfetchc

; 1051 :                        biopaddr, USE_REAL_ADDR, regs);
; 1052 : 
; 1053 :     /* Access the targeted device number from the BIOPL*/
; 1054 :     FETCH_HW(devnum,&bioplin.biopl.devnum);

  000af	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  000b4	e8 00 00 00 00	 call	 fetch_hw_noswap
  000b9	0f b7 c8	 movzx	 ecx, ax
  000bc	e8 00 00 00 00	 call	 _byteswap_ushort
  000c1	66 89 44 24 38	 mov	 WORD PTR devnum$[rsp], ax

; 1055 : 
; 1056 :     /* Locate the device by the number */
; 1057 :     dev = find_device_by_devnum (0,devnum);

  000c6	0f b7 54 24 38	 movzx	 edx, WORD PTR devnum$[rsp]
  000cb	33 c9		 xor	 ecx, ecx
  000cd	e8 00 00 00 00	 call	 find_device_by_devnum
  000d2	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax

; 1058 :     /* Device not found will be checked by the called function */
; 1059 : 
; 1060 :     switch(regs->GR_L(r2))

  000d7	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  000df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ee	89 44 24 3c	 mov	 DWORD PTR tv92[rsp], eax
  000f2	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000f7	74 1b		 je	 SHORT $LN5@z900_vm_bl
  000f9	83 7c 24 3c 01	 cmp	 DWORD PTR tv92[rsp], 1
  000fe	0f 84 83 00 00
	00		 je	 $LN9@z900_vm_bl
  00104	83 7c 24 3c 02	 cmp	 DWORD PTR tv92[rsp], 2
  00109	0f 84 e8 00 00
	00		 je	 $LN13@z900_vm_bl
  0010f	e9 05 01 00 00	 jmp	 $LN14@z900_vm_bl
$LN5@z900_vm_bl:

; 1061 :     {
; 1062 : 
; 1063 : /*--------------------------------------------------------*/
; 1064 : /* Initialize the Block I/O Device Environment            */
; 1065 : /*--------------------------------------------------------*/
; 1066 :     case INIT:
; 1067 : 
; 1068 : #if !defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1069 :          /* 64-bit formats not supported for S/370 or ESA/390 */
; 1070 :          /* and bits 1-7 must be zero                         */
; 1071 :          if (bioplin.biopl.flaga != 0x00)
; 1072 :          {
; 1073 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1074 :          }
; 1075 : 
; 1076 :          /* Call the 32-bit addressing function */
; 1077 :          cc = d250_init32(dev,&rc,&bioplin.init32,regs);
; 1078 : #else
; 1079 :          /* Bits 1-7 must be zero for z/Architecture */
; 1080 :          if (bioplin.biopl.flaga & BIOPL_FLAGARSV)

  00114	0f b6 44 24 52	 movzx	 eax, BYTE PTR bioplin$[rsp+2]
  00119	83 e0 7f	 and	 eax, 127		; 0000007fH
  0011c	85 c0		 test	 eax, eax
  0011e	74 12		 je	 SHORT $LN6@z900_vm_bl

; 1081 :          {
; 1082 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00120	ba 06 00 00 00	 mov	 edx, 6
  00125	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_vm_bl:

; 1083 :          }
; 1084 :          /* Call the addressing sensitive function */
; 1085 :          if (bioplin.biopl.flaga & BIOPL_FLAGAMSK)

  00132	0f b6 44 24 52	 movzx	 eax, BYTE PTR bioplin$[rsp+2]
  00137	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0013c	85 c0		 test	 eax, eax
  0013e	74 22		 je	 SHORT $LN7@z900_vm_bl

; 1086 :          {
; 1087 :             cc = d250_init64(dev,&rc,&bioplin.init64,regs);

  00140	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00148	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  0014d	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00152	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00157	e8 00 00 00 00	 call	 d250_init64
  0015c	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1088 :          }

  00160	eb 20		 jmp	 SHORT $LN8@z900_vm_bl
$LN7@z900_vm_bl:

; 1089 :          else
; 1090 :          {
; 1091 :             cc = d250_init32(dev,&rc,&bioplin.init32,regs);

  00162	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016a	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  0016f	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00174	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00179	e8 00 00 00 00	 call	 d250_init32
  0017e	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax
$LN8@z900_vm_bl:

; 1092 :          }
; 1093 : #endif /* !FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1094 :          break;

  00182	e9 a4 00 00 00	 jmp	 $LN2@z900_vm_bl
$LN9@z900_vm_bl:

; 1095 : 
; 1096 : /*--------------------------------------------------------*/
; 1097 : /* Perform block I/O read/write requests to the device    */
; 1098 : /*--------------------------------------------------------*/
; 1099 :     case IOREQ:
; 1100 : 
; 1101 : #if !defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1102 :          /* 64-bit formats not supported for S/370 or ESA/390 */
; 1103 :          /* and bits 1-7 must be zero                         */
; 1104 :          if (bioplin.biopl.flaga != 0x00)
; 1105 :          {
; 1106 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1107 :          }
; 1108 :          cc = ARCH_DEP(d250_iorq32)(dev,&rc,&bioplin.iorq32,regs);
; 1109 : #else
; 1110 :          /* Bits 1-7 must be zero for z/Architecture */
; 1111 :          if (bioplin.biopl.flaga & BIOPL_FLAGARSV)

  00187	0f b6 44 24 52	 movzx	 eax, BYTE PTR bioplin$[rsp+2]
  0018c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0018f	85 c0		 test	 eax, eax
  00191	74 12		 je	 SHORT $LN10@z900_vm_bl

; 1112 :          {
; 1113 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00193	ba 06 00 00 00	 mov	 edx, 6
  00198	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_vm_bl:

; 1114 :          }
; 1115 : 
; 1116 :          if (bioplin.biopl.flaga & BIOPL_FLAGAMSK)

  001a5	0f b6 44 24 52	 movzx	 eax, BYTE PTR bioplin$[rsp+2]
  001aa	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001af	85 c0		 test	 eax, eax
  001b1	74 22		 je	 SHORT $LN11@z900_vm_bl

; 1117 :          {
; 1118 :             cc = ARCH_DEP(d250_iorq64)(dev,&rc,&bioplin.iorq64,regs);

  001b3	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001bb	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  001c0	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  001c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  001ca	e8 00 00 00 00	 call	 z900_d250_iorq64
  001cf	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1119 :          }

  001d3	eb 20		 jmp	 SHORT $LN12@z900_vm_bl
$LN11@z900_vm_bl:

; 1120 :          else
; 1121 :          {
; 1122 :             cc = ARCH_DEP(d250_iorq32)(dev,&rc,&bioplin.iorq32,regs);

  001d5	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001dd	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  001e2	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  001e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  001ec	e8 00 00 00 00	 call	 z900_d250_iorq32
  001f1	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax
$LN12@z900_vm_bl:

; 1123 :          }
; 1124 : #endif /* !FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1125 :          break;

  001f5	eb 34		 jmp	 SHORT $LN2@z900_vm_bl
$LN13@z900_vm_bl:

; 1126 : 
; 1127 : /*--------------------------------------------------------*/
; 1128 : /* Remove the Block I/O Device Environment                */
; 1129 : /*--------------------------------------------------------*/
; 1130 :     case REMOVE:
; 1131 :          cc = d250_remove(dev,&rc,&bioplin.remove,regs);

  001f7	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001ff	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  00204	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00209	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0020e	e8 00 00 00 00	 call	 d250_remove
  00213	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1132 :          break;

  00217	eb 12		 jmp	 SHORT $LN2@z900_vm_bl
$LN14@z900_vm_bl:

; 1133 :     default:
; 1134 :          ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00219	ba 06 00 00 00	 mov	 edx, 6
  0021e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00226	e8 00 00 00 00	 call	 z900_program_interrupt
$LN2@z900_vm_bl:

; 1135 :     } /* end switch(regs->GR_L(r2)) */
; 1136 : 
; 1137 :     /* Update the BIOPL in main storage */
; 1138 :     ARCH_DEP(wstorec) (&bioplin, sizeof(bioplin)-1,

  0022b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00233	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0023a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR biopaddr$[rsp]
  0023f	48 23 c8	 and	 rcx, rax
  00242	48 8b c1	 mov	 rax, rcx
  00245	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00252	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00258	4c 8b c0	 mov	 r8, rax
  0025b	b2 3f		 mov	 dl, 63			; 0000003fH
  0025d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  00262	e8 00 00 00 00	 call	 z900_vstorec

; 1139 :                        biopaddr, USE_REAL_ADDR, regs);
; 1140 : 
; 1141 :     /* Set the return code in Rx+1 */
; 1142 :     regs->GR_L((r1+1)&0xF) = rc;

  00267	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  0026e	ff c0		 inc	 eax
  00270	83 e0 0f	 and	 eax, 15
  00273	48 98		 cdqe
  00275	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	8b 54 24 30	 mov	 edx, DWORD PTR rc$[rsp]
  00281	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1143 : 
; 1144 :     /* Return the condition code */
; 1145 :     return cc;

  00288	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]

; 1146 : 
; 1147 : } /* end function vm_blockio */

  0028c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00294	48 33 cc	 xor	 rcx, rsp
  00297	e8 00 00 00 00	 call	 __security_check_cookie
  0029c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002a3	c3		 ret	 0
z900_vm_blockio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
psc$ = 32
ioctl$ = 40
ctl$ = 64
s390_d250_async32 PROC

; 1153 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1154 : IOCTL32 *ioctl;    /* 32-bit IO request controls    */
; 1155 : BYTE    psc;       /* List processing status code   */
; 1156 : 
; 1157 :    /* Fetch the IO request control structure */
; 1158 :    ioctl=(IOCTL32 *)ctl;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ctl$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR ioctl$[rsp], rax

; 1159 : 
; 1160 :    /* Call the 32-bit BIOE request processor on this async thread*/
; 1161 :    psc=ARCH_DEP(d250_list32)(ioctl, ASYNC);

  00013	ba 01 00 00 00	 mov	 edx, 1
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0001d	e8 00 00 00 00	 call	 s390_d250_list32
  00022	88 44 24 20	 mov	 BYTE PTR psc$[rsp], al

; 1162 : 
; 1163 :    /* Trigger the external interrupt here */
; 1164 : 
; 1165 :    d250_bio_interrupt(ioctl->dev, ioctl->intrparm, psc, 0x03);

  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR ioctl$[rsp]
  0002b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002e	41 b1 03	 mov	 r9b, 3
  00031	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR psc$[rsp]
  00037	8b d0		 mov	 edx, eax
  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR ioctl$[rsp]
  0003e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00042	e8 00 00 00 00	 call	 d250_bio_interrupt

; 1166 : 
; 1167 :    free(ioctl);

  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1168 :    return NULL;

  00052	33 c0		 xor	 eax, eax

; 1169 : } /* end function ARCH_DEP(d250_async32) */

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
s390_d250_async32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
sk1$ = 32
sk2$ = 33
beg$ = 64
end$ = 72
acctype$ = 80
key$ = 88
regs$ = 96
s390_d250_addrck PROC

; 1677 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1678 : BYTE   sk1;      /* Storage key of first byte of area         */
; 1679 : BYTE   sk2;      /* Storage key of last byte of area          */
; 1680 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1681 : BYTE   skmid;    /* Storage key of middle byte of area        */
; 1682 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1683 : 
; 1684 : 
; 1685 :     if ( (end > regs->mainlim) || (end > MAXADDRESS) || end < beg )

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00024	48 39 44 24 48	 cmp	 QWORD PTR end$[rsp], rax
  00029	77 17		 ja	 SHORT $LN3@s390_d250_
  0002b	48 81 7c 24 48
	ff ff ff 7f	 cmp	 QWORD PTR end$[rsp], 2147483647 ; 7fffffffH
  00034	77 0c		 ja	 SHORT $LN3@s390_d250_
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR beg$[rsp]
  0003b	48 39 44 24 48	 cmp	 QWORD PTR end$[rsp], rax
  00040	73 0a		 jae	 SHORT $LN2@s390_d250_
$LN3@s390_d250_:

; 1686 :     {
; 1687 :        return PGM_ADDRESSING_EXCEPTION;

  00042	b8 05 00 00 00	 mov	 eax, 5
  00047	e9 ad 00 00 00	 jmp	 $LN1@s390_d250_
$LN2@s390_d250_:

; 1688 :     }
; 1689 : 
; 1690 :     /* Note this logic is inspired by        */
; 1691 :     /* inline.h ARCH_DEP(is_fetch_protected) */
; 1692 :     /* inline.h ARCH_DEP(is_store_protected) */
; 1693 : 
; 1694 :     if (key == 0)

  0004c	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  00051	85 c0		 test	 eax, eax
  00053	75 07		 jne	 SHORT $LN4@s390_d250_

; 1695 :     {
; 1696 :        return 0;

  00055	33 c0		 xor	 eax, eax
  00057	e9 9d 00 00 00	 jmp	 $LN1@s390_d250_
$LN4@s390_d250_:

; 1697 :     }
; 1698 : 
; 1699 :     sk1 = ARCH_DEP( get_storage_key )( beg );

  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR beg$[rsp]
  00061	e8 00 00 00 00	 call	 s390_get_storage_key
  00066	88 44 24 20	 mov	 BYTE PTR sk1$[rsp], al

; 1700 :     sk2 = ARCH_DEP( get_storage_key )( end );

  0006a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR end$[rsp]
  0006f	e8 00 00 00 00	 call	 s390_get_storage_key
  00074	88 44 24 21	 mov	 BYTE PTR sk2$[rsp], al

; 1701 : 
; 1702 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1703 :     if ( ( end - beg ) > 2048 )
; 1704 :     {
; 1705 :        skmid = ARCH_DEP( get_storage_key )( beg + 2048 );
; 1706 :     }
; 1707 :     else
; 1708 :     {
; 1709 :        skmid = sk2;
; 1710 :     }
; 1711 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1712 : 
; 1713 :     if (acctype == ACCTYPE_READ)

  00078	83 7c 24 50 04	 cmp	 DWORD PTR acctype$[rsp], 4
  0007d	75 49		 jne	 SHORT $LN5@s390_d250_

; 1714 :     {  /* Check for fetch protection  */
; 1715 :        if (  ((sk1 & STORKEY_FETCH) && (key != (sk1 & STORKEY_KEY)))
; 1716 :            ||((sk2 & STORKEY_FETCH) && (key != (sk2 & STORKEY_KEY)))

  0007f	0f b6 44 24 20	 movzx	 eax, BYTE PTR sk1$[rsp]
  00084	83 e0 08	 and	 eax, 8
  00087	85 c0		 test	 eax, eax
  00089	74 14		 je	 SHORT $LN9@s390_d250_
  0008b	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  00090	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR sk1$[rsp]
  00095	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0009b	3b c1		 cmp	 eax, ecx
  0009d	75 20		 jne	 SHORT $LN8@s390_d250_
$LN9@s390_d250_:
  0009f	0f b6 44 24 21	 movzx	 eax, BYTE PTR sk2$[rsp]
  000a4	83 e0 08	 and	 eax, 8
  000a7	85 c0		 test	 eax, eax
  000a9	74 1b		 je	 SHORT $LN7@s390_d250_
  000ab	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  000b0	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR sk2$[rsp]
  000b5	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000bb	3b c1		 cmp	 eax, ecx
  000bd	74 07		 je	 SHORT $LN7@s390_d250_
$LN8@s390_d250_:

; 1717 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1718 :            ||((skmid & STORKEY_FETCH) && (key != (skmid & STORKEY_KEY)))
; 1719 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1720 :           )
; 1721 :        {
; 1722 :           return PGM_PROTECTION_EXCEPTION;

  000bf	b8 04 00 00 00	 mov	 eax, 4
  000c4	eb 33		 jmp	 SHORT $LN1@s390_d250_
$LN7@s390_d250_:

; 1723 :        }
; 1724 :     }

  000c6	eb 2f		 jmp	 SHORT $LN6@s390_d250_
$LN5@s390_d250_:

; 1725 :     else /* assume ACCTYPE_WRITE */
; 1726 :     {  /* Check for store protection */
; 1727 :        if (  (key != (sk1 & STORKEY_KEY))
; 1728 :            ||(key != (sk2 & STORKEY_KEY))

  000c8	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  000cd	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR sk1$[rsp]
  000d2	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000d8	3b c1		 cmp	 eax, ecx
  000da	75 14		 jne	 SHORT $LN11@s390_d250_
  000dc	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  000e1	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR sk2$[rsp]
  000e6	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000ec	3b c1		 cmp	 eax, ecx
  000ee	74 07		 je	 SHORT $LN10@s390_d250_
$LN11@s390_d250_:

; 1729 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1730 :            ||(key != (skmid & STORKEY_KEY))
; 1731 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1732 :           )
; 1733 :        {
; 1734 :           return PGM_PROTECTION_EXCEPTION;

  000f0	b8 04 00 00 00	 mov	 eax, 4
  000f5	eb 02		 jmp	 SHORT $LN1@s390_d250_
$LN10@s390_d250_:
$LN6@s390_d250_:

; 1735 :        }
; 1736 :     }
; 1737 :     return 0;

  000f7	33 c0		 xor	 eax, eax
$LN1@s390_d250_:

; 1738 : } /* end of function ARCH_DEP(d250_addrck) */

  000f9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fd	c3		 ret	 0
s390_d250_addrck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
status$ = 96
xcode$ = 100
bioebeg$ = 104
bufbeg$ = 112
blknum$ = 120
block$ = 124
bufend$ = 128
tv293 = 136
tv352 = 140
physblk$ = 144
blocks$ = 148
tv70 = 152
tv79 = 156
tv152 = 160
tv156 = 164
tv160 = 168
tv234 = 172
tv239 = 176
tv273 = 180
tv277 = 184
tv281 = 188
tv332 = 192
tv336 = 196
tv340 = 200
tv396 = 204
tv438 = 208
tv443 = 212
bioeend$ = 216
tv73 = 224
tv398 = 232
tv400 = 240
bioe$ = 248
__$ArrayPad$ = 264
ioctl$ = 304
async$ = 312
s390_d250_list32 PROC

; 1361 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1362 : BIOE32 bioe;      /* 32-bit BIOE fetched from absolute storage */
; 1363 : RADR   bioebeg;   /* Starting address of the BIOE              */
; 1364 : RADR   bioeend;   /* Address of last byte of BIOE              */
; 1365 : U16    xcode;     /* Detected exception condition              */
; 1366 : int    blocks;    /* Number of blocks being processed          */
; 1367 : int    block;     /* counter used in block I/O loop            */
; 1368 : S32    blknum;    /* Block number of the request               */
; 1369 : BYTE   status;    /* Returned BIOE status                      */
; 1370 : /* Passed to generic block I/O function                        */
; 1371 : int    physblk;   /* Physical block number                     */
; 1372 : RADR   bufbeg;    /* Address where the read/write will occur   */
; 1373 : RADR   bufend;    /* Last byte read or written                 */
; 1374 : 
; 1375 :    xcode = 0;   /* Initialize the address check exception code */

  00024	33 c0		 xor	 eax, eax
  00026	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1376 :    status = 0;

  0002b	c6 44 24 60 00	 mov	 BYTE PTR status$[rsp], 0

; 1377 : 
; 1378 :    /* Preserve pending sense if any and establish my ownership */
; 1379 :    /* of the device by reserving it if shared and locking it   */
; 1380 :    if (ioctl->dev->ccwtrace)

  00030	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00038	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00042	c1 e8 0f	 shr	 eax, 15
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 b6 00 00
	00		 je	 $LN12@s390_d250_

; 1381 :    {
; 1382 :       WRMSG (HHC01928, "I",

  00050	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00058	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0005c	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv70[rsp], eax
  00063	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0006b	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0006e	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv73[rsp], rcx
  00076	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  0007e	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00082	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00086	89 94 24 9c 00
	00 00		 mov	 DWORD PTR tv79[rsp], edx
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00098	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv70[rsp]
  0009f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000a3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv73[rsp]
  000ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000b0	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  000b8	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  000bb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000bf	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv79[rsp]
  000c6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180388
  000d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180389
  000dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180390
  000f4	ba 6b 05 00 00	 mov	 edx, 1387		; 0000056bH
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180391
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@s390_d250_:

; 1383 :                ioctl->dev->devnum,
; 1384 :                ioctl->blkcount,
; 1385 :                (RADR)ioctl->listaddr,
; 1386 :                ioctl->key
; 1387 :                );
; 1388 :    }
; 1389 : 
; 1390 :    /* Take ownership of the device */
; 1391 :    d250_preserve(ioctl->dev);

  00106	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0010e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00112	e8 00 00 00 00	 call	 d250_preserve

; 1392 :    /* Note: the DEVBLK is now locked */
; 1393 : 
; 1394 :    if (!ioctl->dev->vmd250env)

  00117	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0011f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00123	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  0012b	75 1b		 jne	 SHORT $LN13@s390_d250_

; 1395 :    {
; 1396 :        d250_restore(ioctl->dev);

  0012d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00135	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00139	e8 00 00 00 00	 call	 d250_restore

; 1397 :        /* Note: the device lock is now released */
; 1398 :        return PSC_REMOVED;

  0013e	b8 03 00 00 00	 mov	 eax, 3
  00143	e9 86 0a 00 00	 jmp	 $LN1@s390_d250_
$LN13@s390_d250_:

; 1399 :    }
; 1400 : 
; 1401 :    blocks=(int)ioctl->blkcount;

  00148	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00150	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00153	89 84 24 94 00
	00 00		 mov	 DWORD PTR blocks$[rsp], eax

; 1402 :    bioebeg=ioctl->listaddr & AMASK31 ;

  0015a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00162	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00165	0f ba f0 1f	 btr	 eax, 31
  00169	8b c0		 mov	 eax, eax
  0016b	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1403 : 
; 1404 :    /* Process each of the BIOE's supplied by the BIOPL count field */
; 1405 :    for ( block = 0 ; block < blocks ; block++ )

  00170	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR block$[rsp], 0
  00178	eb 0a		 jmp	 SHORT $LN4@s390_d250_
$LN2@s390_d250_:
  0017a	8b 44 24 7c	 mov	 eax, DWORD PTR block$[rsp]
  0017e	ff c0		 inc	 eax
  00180	89 44 24 7c	 mov	 DWORD PTR block$[rsp], eax
$LN4@s390_d250_:
  00184	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR blocks$[rsp]
  0018b	39 44 24 7c	 cmp	 DWORD PTR block$[rsp], eax
  0018f	0f 8d c7 09 00
	00		 jge	 $LN3@s390_d250_

; 1406 :    {
; 1407 :       status = 0xFF;  /* Set undefined status */

  00195	c6 44 24 60 ff	 mov	 BYTE PTR status$[rsp], 255 ; 000000ffH

; 1408 : 
; 1409 :       bioeend=( bioebeg + sizeof(BIOE32) - 1 ) & AMASK31;

  0019a	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  0019f	48 83 c0 0f	 add	 rax, 15
  001a3	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  001a9	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR bioeend$[rsp], rax

; 1410 :       xcode=ARCH_DEP(d250_addrck)

  001b1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001c9	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  001ce	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d4	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR bioeend$[rsp]
  001dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  001e1	e8 00 00 00 00	 call	 s390_d250_addrck
  001e6	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1411 :             (bioebeg,bioeend,ACCTYPE_READ,ioctl->key,ioctl->regs);
; 1412 :       if (ioctl->dev->ccwtrace)

  001eb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001f3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001f7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001fd	c1 e8 0f	 shr	 eax, 15
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	0f 84 b5 00 00
	00		 je	 $LN14@s390_d250_

; 1413 :       {
; 1414 :          WRMSG(HHC01929,"I",ioctl->dev->devnum,xcode,bioebeg,bioeend,ioctl->key);

  0020b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00213	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00217	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv152[rsp], eax
  0021e	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00223	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv156[rsp], ecx
  0022a	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00232	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00236	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0023a	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv160[rsp], edx
  00241	b9 01 00 00 00	 mov	 ecx, 1
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv152[rsp]
  00253	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00257	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR bioeend$[rsp]
  0025f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00264	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00269	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0026e	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv156[rsp]
  00275	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00279	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv160[rsp]
  00280	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180394
  0028b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180395
  00297	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180396
  002ae	ba 86 05 00 00	 mov	 edx, 1414		; 00000586H
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180397
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@s390_d250_:

; 1415 :       }
; 1416 :       if ( xcode )

  002c0	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  002c5	85 c0		 test	 eax, eax
  002c7	74 05		 je	 SHORT $LN15@s390_d250_

; 1417 :       {
; 1418 :          break;

  002c9	e9 8e 08 00 00	 jmp	 $LN3@s390_d250_
$LN15@s390_d250_:

; 1419 :       }
; 1420 : 
; 1421 :       /* Fetch the BIOE from storage */
; 1422 :       memcpy(&bioe,ioctl->regs->mainstor+bioebeg,sizeof(BIOE32));

  002ce	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  002d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d9	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002e0	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR bioe$[rsp]
  002e8	48 8b 54 24 68	 mov	 rdx, QWORD PTR bioebeg$[rsp]
  002ed	48 8b f9	 mov	 rdi, rcx
  002f0	48 8d 34 10	 lea	 rsi, QWORD PTR [rax+rdx]
  002f4	b9 10 00 00 00	 mov	 ecx, 16
  002f9	f3 a4		 rep movsb

; 1423 :       ARCH_DEP( or_storage_key )( bioebeg, STORKEY_REF );

  002fb	b2 04		 mov	 dl, 4
  002fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00302	e8 00 00 00 00	 call	 s390_or_storage_key

; 1424 :       ARCH_DEP( or_storage_key )( bioeend, STORKEY_REF );

  00307	b2 04		 mov	 dl, 4
  00309	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR bioeend$[rsp]
  00311	e8 00 00 00 00	 call	 s390_or_storage_key
$LN7@s390_d250_:

; 1425 : 
; 1426 :       /* Process a single BIOE */
; 1427 :       do
; 1428 :       {
; 1429 : 
; 1430 :          /* Make sure reserved field is zeros */
; 1431 :          if ( bioe.resv1[0]!=0x00 || bioe.resv1[1]!=0x00 )

  00316	b8 01 00 00 00	 mov	 eax, 1
  0031b	48 6b c0 00	 imul	 rax, rax, 0
  0031f	0f b6 84 04 fa
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp+rax+2]
  00327	85 c0		 test	 eax, eax
  00329	75 15		 jne	 SHORT $LN17@s390_d250_
  0032b	b8 01 00 00 00	 mov	 eax, 1
  00330	48 6b c0 01	 imul	 rax, rax, 1
  00334	0f b6 84 04 fa
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp+rax+2]
  0033c	85 c0		 test	 eax, eax
  0033e	74 0a		 je	 SHORT $LN16@s390_d250_
$LN17@s390_d250_:

; 1432 :          {
; 1433 :             status=BIOE_NOTZERO;

  00340	c6 44 24 60 0b	 mov	 BYTE PTR status$[rsp], 11

; 1434 :             continue;

  00345	e9 98 05 00 00	 jmp	 $LN5@s390_d250_
$LN16@s390_d250_:

; 1435 :          }
; 1436 : 
; 1437 :          /* Fetch and validate block number */
; 1438 :          FETCH_FW(blknum,&bioe.blknum);

  0034a	48 8d 8c 24 fc
	00 00 00	 lea	 rcx, QWORD PTR bioe$[rsp+4]
  00352	e8 00 00 00 00	 call	 fetch_fw_noswap
  00357	8b c8		 mov	 ecx, eax
  00359	e8 00 00 00 00	 call	 _byteswap_ulong
  0035e	89 44 24 78	 mov	 DWORD PTR blknum$[rsp], eax

; 1439 :          if ( (blknum < ioctl->dev->vmd250env->begblk) ||

  00362	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  00367	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0036f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00373	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0037a	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]
  0037e	7c 1e		 jl	 SHORT $LN19@s390_d250_
  00380	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  00385	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0038d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00391	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  00398	48 3b 41 20	 cmp	 rax, QWORD PTR [rcx+32]
  0039c	7e 0a		 jle	 SHORT $LN18@s390_d250_
$LN19@s390_d250_:

; 1440 :               (blknum > ioctl->dev->vmd250env->endblk)
; 1441 :             )
; 1442 :          {
; 1443 :             status=BIOE_BADBLOCK;

  0039e	c6 44 24 60 01	 mov	 BYTE PTR status$[rsp], 1

; 1444 :             continue;

  003a3	e9 3a 05 00 00	 jmp	 $LN5@s390_d250_
$LN18@s390_d250_:

; 1445 :          }
; 1446 : 
; 1447 :          /* Fetch the storage address used for I/O */
; 1448 :          FETCH_FW(bufbeg,&bioe.bufaddr);

  003a8	48 8d 8c 24 04
	01 00 00	 lea	 rcx, QWORD PTR bioe$[rsp+12]
  003b0	e8 00 00 00 00	 call	 fetch_fw_noswap
  003b5	8b c8		 mov	 ecx, eax
  003b7	e8 00 00 00 00	 call	 _byteswap_ulong
  003bc	8b c0		 mov	 eax, eax
  003be	48 89 44 24 70	 mov	 QWORD PTR bufbeg$[rsp], rax

; 1449 :          bufbeg &= AMASK31;

  003c3	48 8b 44 24 70	 mov	 rax, QWORD PTR bufbeg$[rsp]
  003c8	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  003ce	48 89 44 24 70	 mov	 QWORD PTR bufbeg$[rsp], rax

; 1450 : 
; 1451 :          /* Ensure the environment still exists */
; 1452 :          if (!ioctl->dev->vmd250env)

  003d3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  003db	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003df	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  003e7	75 20		 jne	 SHORT $LN20@s390_d250_

; 1453 :          {
; 1454 :             d250_restore(ioctl->dev);

  003e9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  003f1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003f5	e8 00 00 00 00	 call	 d250_restore

; 1455 :             /* Note: the device lock is now released */
; 1456 :             status=BIOE_ABORTED;

  003fa	c6 44 24 60 0c	 mov	 BYTE PTR status$[rsp], 12

; 1457 :             return PSC_REMOVED;

  003ff	b8 03 00 00 00	 mov	 eax, 3
  00404	e9 c5 07 00 00	 jmp	 $LN1@s390_d250_
$LN20@s390_d250_:

; 1458 :          }
; 1459 : 
; 1460 :          /* The I/O handler routines are normally called without the  */
; 1461 :          /* device lock being held.  The device is reserved by the    */
; 1462 :          /* busy status.                                              */
; 1463 : 
; 1464 :          /* Determine the last byte of the I/O buffer */
; 1465 :          bufend=( bufbeg + ioctl->dev->vmd250env->blksiz -1 ) & AMASK31 ;

  00409	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00411	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00415	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0041c	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00420	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00425	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0042a	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  00430	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR bufend$[rsp], rax

; 1466 : 
; 1467 :          if (ioctl->dev->ccwtrace)

  00438	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00440	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00444	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0044a	c1 e8 0f	 shr	 eax, 15
  0044d	83 e0 01	 and	 eax, 1
  00450	85 c0		 test	 eax, eax
  00452	0f 84 9f 00 00
	00		 je	 $LN21@s390_d250_

; 1468 :          {
; 1469 :             WRMSG (HHC01930, "I",

  00458	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  00460	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv234[rsp], eax
  00467	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0046f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00473	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00477	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv239[rsp], ecx
  0047e	b9 01 00 00 00	 mov	 ecx, 1
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00489	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  0048e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00493	8b 4c 24 78	 mov	 ecx, DWORD PTR blknum$[rsp]
  00497	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0049b	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv234[rsp]
  004a2	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  004ab	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004b0	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv239[rsp]
  004b7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180405
  004c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180406
  004ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  004de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180407
  004e5	ba c3 05 00 00	 mov	 edx, 1475		; 000005c3H
  004ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180408
  004f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@s390_d250_:

; 1470 :                      ioctl->dev->devnum,
; 1471 :                      bioebeg,
; 1472 :                      bioe.type,
; 1473 :                      blknum,
; 1474 :                      bufbeg
; 1475 :                     );
; 1476 :          }
; 1477 : 
; 1478 :          /* Determine the physical block on the device relative to zero */
; 1479 :          physblk=(S64)blknum+ioctl->dev->vmd250env->offset-1;

  004f7	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  004fc	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00504	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00508	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0050f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00513	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00518	89 84 24 90 00
	00 00		 mov	 DWORD PTR physblk$[rsp], eax

; 1480 :          /* The read/write routines will convert this to a physical disk */
; 1481 :          /* location for reading or writing                              */
; 1482 : 
; 1483 :          if (bioe.type == BIOE_READ)

  0051f	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  00527	83 f8 02	 cmp	 eax, 2
  0052a	0f 85 c1 01 00
	00		 jne	 $LN22@s390_d250_

; 1484 :          {
; 1485 :             xcode=ARCH_DEP(d250_addrck)

  00530	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00538	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0053b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00540	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00548	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  0054d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00553	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufend$[rsp]
  0055b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00560	e8 00 00 00 00	 call	 s390_d250_addrck
  00565	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1486 :                   (bufbeg,bufend,ACCTYPE_READ,ioctl->key,ioctl->regs);
; 1487 :             if (ioctl->dev->ccwtrace)

  0056a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00572	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00576	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0057c	c1 e8 0f	 shr	 eax, 15
  0057f	83 e0 01	 and	 eax, 1
  00582	85 c0		 test	 eax, eax
  00584	0f 84 b5 00 00
	00		 je	 $LN24@s390_d250_

; 1488 :             {
; 1489 :                WRMSG(HHC01931, "I",

  0058a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00592	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00596	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv273[rsp], eax
  0059d	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  005a2	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv277[rsp], ecx
  005a9	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  005b1	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  005b5	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  005b9	89 94 24 bc 00
	00 00		 mov	 DWORD PTR tv281[rsp], edx
  005c0	b9 01 00 00 00	 mov	 ecx, 1
  005c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005cb	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  005d2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  005d6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  005de	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  005e8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005ed	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv277[rsp]
  005f4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005f8	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  005ff	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00603	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180412
  0060a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0060f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180413
  00616	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0061b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00620	41 b9 03 00 00
	00		 mov	 r9d, 3
  00626	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180414
  0062d	ba d2 05 00 00	 mov	 edx, 1490		; 000005d2H
  00632	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180415
  00639	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@s390_d250_:

; 1490 :                        ioctl->dev->devnum,xcode,bufbeg,bufend,ioctl->key);
; 1491 :             }
; 1492 :             switch ( xcode )

  0063f	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00644	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv293[rsp], eax
  0064b	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR tv293[rsp], 4
  00653	74 16		 je	 SHORT $LN26@s390_d250_
  00655	83 bc 24 88 00
	00 00 05	 cmp	 DWORD PTR tv293[rsp], 5
  0065d	74 02		 je	 SHORT $LN25@s390_d250_
  0065f	eb 14		 jmp	 SHORT $LN8@s390_d250_
$LN25@s390_d250_:

; 1493 :             {
; 1494 :                case PGM_ADDRESSING_EXCEPTION:
; 1495 :                   status=BIOE_ADDREXC;

  00661	c6 44 24 60 02	 mov	 BYTE PTR status$[rsp], 2

; 1496 :                   continue;

  00666	e9 77 02 00 00	 jmp	 $LN5@s390_d250_
$LN26@s390_d250_:

; 1497 :                case PGM_PROTECTION_EXCEPTION:
; 1498 :                   status=BIOE_PROTEXC;

  0066b	c6 44 24 60 07	 mov	 BYTE PTR status$[rsp], 7

; 1499 :                   continue;

  00670	e9 6d 02 00 00	 jmp	 $LN5@s390_d250_
$LN8@s390_d250_:

; 1500 :             }
; 1501 :             /* At this point, the block number has been validated */
; 1502 :             /* and the buffer is addressable and accessible       */
; 1503 :             status=d250_read(ioctl->dev,

  00675	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0067d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00680	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00687	48 03 44 24 70	 add	 rax, QWORD PTR bufbeg$[rsp]
  0068c	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00694	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00698	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0069f	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR physblk$[rsp]
  006a7	4c 8b c8	 mov	 r9, rax
  006aa	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  006ae	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  006b6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  006ba	e8 00 00 00 00	 call	 d250_read
  006bf	88 44 24 60	 mov	 BYTE PTR status$[rsp], al

; 1504 :                                physblk,
; 1505 :                                ioctl->dev->vmd250env->blksiz,
; 1506 :                                ioctl->regs->mainstor+bufbeg);
; 1507 : 
; 1508 :             /* Set I/O storage key references if successful */
; 1509 :             if (!status)

  006c3	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  006c8	85 c0		 test	 eax, eax
  006ca	75 1b		 jne	 SHORT $LN27@s390_d250_

; 1510 :             {
; 1511 :                ARCH_DEP( or_storage_key )( bufbeg, STORKEY_REF );

  006cc	b2 04		 mov	 dl, 4
  006ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  006d3	e8 00 00 00 00	 call	 s390_or_storage_key

; 1512 :                ARCH_DEP( or_storage_key )( bufend, STORKEY_REF );

  006d8	b2 04		 mov	 dl, 4
  006da	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  006e2	e8 00 00 00 00	 call	 s390_or_storage_key
$LN27@s390_d250_:

; 1513 : 
; 1514 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1515 :                if ( ioctl->dev->vmd250env->blksiz == 4096 )
; 1516 :                {
; 1517 :                   ARCH_DEP( or_storage_key )( bufbeg+2048, STORKEY_REF );
; 1518 :                }
; 1519 : #endif
; 1520 :             }
; 1521 : 
; 1522 :             continue;

  006e7	e9 f6 01 00 00	 jmp	 $LN5@s390_d250_

; 1523 :          }  /* end of BIOE_READ */

  006ec	e9 f1 01 00 00	 jmp	 $LN23@s390_d250_
$LN22@s390_d250_:

; 1524 :          else
; 1525 :          {  if (bioe.type == BIOE_WRITE)

  006f1	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  006f9	83 f8 01	 cmp	 eax, 1
  006fc	0f 85 db 01 00
	00		 jne	 $LN28@s390_d250_

; 1526 :             {
; 1527 :                xcode=ARCH_DEP(d250_addrck)

  00702	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0070a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0070d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00712	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0071a	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  0071f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00725	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufend$[rsp]
  0072d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00732	e8 00 00 00 00	 call	 s390_d250_addrck
  00737	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1528 :                      (bufbeg,bufend,ACCTYPE_WRITE,ioctl->key,ioctl->regs);
; 1529 :                if (ioctl->dev->ccwtrace)

  0073c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00744	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00748	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0074e	c1 e8 0f	 shr	 eax, 15
  00751	83 e0 01	 and	 eax, 1
  00754	85 c0		 test	 eax, eax
  00756	0f 84 b5 00 00
	00		 je	 $LN30@s390_d250_

; 1530 :                {
; 1531 :                   WRMSG(HHC01932, "I",

  0075c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00764	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00768	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv332[rsp], eax
  0076f	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00774	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv336[rsp], ecx
  0077b	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00783	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00787	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0078b	89 94 24 c8 00
	00 00		 mov	 DWORD PTR tv340[rsp], edx
  00792	b9 01 00 00 00	 mov	 ecx, 1
  00797	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0079d	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv332[rsp]
  007a4	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  007a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  007b0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  007ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007bf	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv336[rsp]
  007c6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007ca	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv340[rsp]
  007d1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180422
  007dc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180423
  007e8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007f2	41 b9 03 00 00
	00		 mov	 r9d, 3
  007f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180424
  007ff	ba ff 05 00 00	 mov	 edx, 1535		; 000005ffH
  00804	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180425
  0080b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@s390_d250_:

; 1532 :                            ioctl->dev->devnum,
; 1533 :                            xcode,bufbeg,
; 1534 :                            bufend,
; 1535 :                            ioctl->key);
; 1536 :                }
; 1537 : 
; 1538 :                switch ( xcode )

  00811	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00816	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv352[rsp], eax
  0081d	83 bc 24 8c 00
	00 00 04	 cmp	 DWORD PTR tv352[rsp], 4
  00825	74 16		 je	 SHORT $LN32@s390_d250_
  00827	83 bc 24 8c 00
	00 00 05	 cmp	 DWORD PTR tv352[rsp], 5
  0082f	74 02		 je	 SHORT $LN31@s390_d250_
  00831	eb 14		 jmp	 SHORT $LN10@s390_d250_
$LN31@s390_d250_:

; 1539 :                {
; 1540 :                   case PGM_ADDRESSING_EXCEPTION:
; 1541 :                      status=BIOE_ADDREXC;

  00833	c6 44 24 60 02	 mov	 BYTE PTR status$[rsp], 2

; 1542 :                      continue;

  00838	e9 a5 00 00 00	 jmp	 $LN5@s390_d250_
$LN32@s390_d250_:

; 1543 :                   case PGM_PROTECTION_EXCEPTION:
; 1544 :                      status=BIOE_PROTEXC;

  0083d	c6 44 24 60 07	 mov	 BYTE PTR status$[rsp], 7

; 1545 :                      continue;

  00842	e9 9b 00 00 00	 jmp	 $LN5@s390_d250_
$LN10@s390_d250_:

; 1546 :                }
; 1547 : 
; 1548 :                if (ioctl->dev->vmd250env->isRO)

  00847	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0084f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00853	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0085a	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0085e	74 07		 je	 SHORT $LN33@s390_d250_

; 1549 :                {
; 1550 :                   status=BIOE_DASDRO;

  00860	c6 44 24 60 03	 mov	 BYTE PTR status$[rsp], 3

; 1551 :                   continue;

  00865	eb 7b		 jmp	 SHORT $LN5@s390_d250_
$LN33@s390_d250_:

; 1552 :                }
; 1553 :                status=d250_write(ioctl->dev,

  00867	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0086f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00872	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00879	48 03 44 24 70	 add	 rax, QWORD PTR bufbeg$[rsp]
  0087e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00886	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0088a	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  00891	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR physblk$[rsp]
  00899	4c 8b c8	 mov	 r9, rax
  0089c	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  008a0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  008a8	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  008ac	e8 00 00 00 00	 call	 d250_write
  008b1	88 44 24 60	 mov	 BYTE PTR status$[rsp], al

; 1554 :                                    physblk,
; 1555 :                                    ioctl->dev->vmd250env->blksiz,
; 1556 :                                    ioctl->regs->mainstor+bufbeg);
; 1557 : 
; 1558 :                /* Set I/O storage key references if good I/O */
; 1559 :                if (!status)

  008b5	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  008ba	85 c0		 test	 eax, eax
  008bc	75 1b		 jne	 SHORT $LN34@s390_d250_

; 1560 :                {
; 1561 :                   ARCH_DEP( or_storage_key )( bufbeg, (STORKEY_REF | STORKEY_CHANGE) );

  008be	b2 06		 mov	 dl, 6
  008c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  008c5	e8 00 00 00 00	 call	 s390_or_storage_key

; 1562 :                   ARCH_DEP( or_storage_key )( bufend, (STORKEY_REF | STORKEY_CHANGE) );

  008ca	b2 06		 mov	 dl, 6
  008cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  008d4	e8 00 00 00 00	 call	 s390_or_storage_key
$LN34@s390_d250_:

; 1563 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1564 :                   if ( ioctl->dev->vmd250env->blksiz == 4096 )
; 1565 :                   {
; 1566 :                      ARCH_DEP( or_storage_key )( bufbeg+2048, (STORKEY_REF | STORKEY_CHANGE) );
; 1567 :                   }
; 1568 : #endif
; 1569 :                }
; 1570 : 
; 1571 :                continue;

  008d9	eb 07		 jmp	 SHORT $LN5@s390_d250_

; 1572 :             } /* end of if BIOE_WRITE */

  008db	eb 05		 jmp	 SHORT $LN29@s390_d250_
$LN28@s390_d250_:

; 1573 :             else
; 1574 :             {
; 1575 :                status=BIOE_BADREQ;

  008dd	c6 44 24 60 06	 mov	 BYTE PTR status$[rsp], 6
$LN29@s390_d250_:
$LN23@s390_d250_:
$LN5@s390_d250_:

; 1576 :                continue;
; 1577 :             } /* end of else BIOE_WRITE */
; 1578 :          } /* end of else BIOE_READ */
; 1579 :       }while(0); /* end of do */

  008e2	33 c0		 xor	 eax, eax
  008e4	85 c0		 test	 eax, eax
  008e6	0f 85 2a fa ff
	ff		 jne	 $LN7@s390_d250_

; 1580 : 
; 1581 :       /* Determine if we can store the status in the BIOE */
; 1582 :       xcode=ARCH_DEP(d250_addrck)

  008ec	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  008f1	48 ff c0	 inc	 rax
  008f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  008f9	48 ff c1	 inc	 rcx
  008fc	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00904	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00907	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0090c	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00914	44 0f b6 4a 20	 movzx	 r9d, BYTE PTR [rdx+32]
  00919	41 b8 02 00 00
	00		 mov	 r8d, 2
  0091f	48 8b d0	 mov	 rdx, rax
  00922	e8 00 00 00 00	 call	 s390_d250_addrck
  00927	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1583 :             (bioebeg+1,bioebeg+1,ACCTYPE_WRITE,ioctl->key,ioctl->regs);
; 1584 :       if (ioctl->dev->ccwtrace)

  0092c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00934	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00938	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0093e	c1 e8 0f	 shr	 eax, 15
  00941	83 e0 01	 and	 eax, 1
  00944	85 c0		 test	 eax, eax
  00946	0f 84 bc 00 00
	00		 je	 $LN35@s390_d250_

; 1585 :       {
; 1586 :          WRMSG(HHC01933, "I",

  0094c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00954	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00958	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv396[rsp], eax
  0095f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00964	48 ff c1	 inc	 rcx
  00967	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv398[rsp], rcx
  0096f	48 8b 54 24 68	 mov	 rdx, QWORD PTR bioebeg$[rsp]
  00974	48 ff c2	 inc	 rdx
  00977	48 89 94 24 f0
	00 00 00	 mov	 QWORD PTR tv400[rsp], rdx
  0097f	0f b7 7c 24 64	 movzx	 edi, WORD PTR xcode$[rsp]
  00984	48 8b b4 24 30
	01 00 00	 mov	 rsi, QWORD PTR ioctl$[rsp]
  0098c	48 8b 76 08	 mov	 rsi, QWORD PTR [rsi+8]
  00990	0f b7 76 48	 movzx	 esi, WORD PTR [rsi+72]
  00994	b9 01 00 00 00	 mov	 ecx, 1
  00999	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0099f	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv396[rsp]
  009a6	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  009aa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv398[rsp]
  009b2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009b7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv400[rsp]
  009bf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009c4	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  009c8	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  009cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180431
  009d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180432
  009df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  009ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180433
  009f6	ba 33 06 00 00	 mov	 edx, 1587		; 00000633H
  009fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180434
  00a02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN35@s390_d250_:

; 1587 :                   ioctl->dev->devnum,xcode,bioebeg+1,bioebeg+1,ioctl->key);
; 1588 :       }
; 1589 : 
; 1590 :       /* If the status byte is store protected, give up on processing any */
; 1591 :       /* more BIOE's.  Leave the BIOE list process for loop               */
; 1592 :       if ( xcode )

  00a08	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00a0d	85 c0		 test	 eax, eax
  00a0f	74 05		 je	 SHORT $LN36@s390_d250_

; 1593 :       {
; 1594 :          break;

  00a11	e9 46 01 00 00	 jmp	 $LN3@s390_d250_
$LN36@s390_d250_:

; 1595 :       }
; 1596 : 
; 1597 :       /* Store the status in the BIOE */
; 1598 :       memcpy(ioctl->regs->mainstor+bioebeg+1,&status,1);

  00a16	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00a1e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a21	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00a28	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00a2d	0f b6 54 24 60	 movzx	 edx, BYTE PTR status$[rsp]
  00a32	88 54 08 01	 mov	 BYTE PTR [rax+rcx+1], dl

; 1599 : 
; 1600 :       /* Set the storage key change bit */
; 1601 :       ARCH_DEP( or_storage_key )( bioebeg+1, (STORKEY_REF | STORKEY_CHANGE) );

  00a36	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00a3b	48 ff c0	 inc	 rax
  00a3e	b2 06		 mov	 dl, 6
  00a40	48 8b c8	 mov	 rcx, rax
  00a43	e8 00 00 00 00	 call	 s390_or_storage_key

; 1602 : 
; 1603 :       if (ioctl->dev->ccwtrace)

  00a48	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00a50	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00a54	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00a5a	c1 e8 0f	 shr	 eax, 15
  00a5d	83 e0 01	 and	 eax, 1
  00a60	85 c0		 test	 eax, eax
  00a62	0f 84 8a 00 00
	00		 je	 $LN37@s390_d250_

; 1604 :       {
; 1605 :          WRMSG (HHC01934, "I", ioctl->dev->devnum,bioebeg,status);

  00a68	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00a6d	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv438[rsp], eax
  00a74	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00a7c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00a80	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00a84	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv443[rsp], ecx
  00a8b	b9 01 00 00 00	 mov	 ecx, 1
  00a90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a96	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv438[rsp]
  00a9d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00aa1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00aa6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00aab	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv443[rsp]
  00ab2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ab6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180437
  00abd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ac2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180438
  00ac9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ace	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ad3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ad9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180439
  00ae0	ba 45 06 00 00	 mov	 edx, 1605		; 00000645H
  00ae5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180440
  00aec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN37@s390_d250_:

; 1606 :       }
; 1607 : 
; 1608 :       /* Count if this BIOE was a success or failure */
; 1609 :       if ( status )

  00af2	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00af7	85 c0		 test	 eax, eax
  00af9	74 26		 je	 SHORT $LN38@s390_d250_

; 1610 :       {
; 1611 :          ioctl->badblks+=1;

  00afb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b03	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b06	ff c0		 inc	 eax
  00b08	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00b10	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1612 :          if ( status == BIOE_ABORTED )

  00b13	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00b18	83 f8 0c	 cmp	 eax, 12
  00b1b	75 02		 jne	 SHORT $LN40@s390_d250_

; 1613 :          {
; 1614 :              break;

  00b1d	eb 3d		 jmp	 SHORT $LN3@s390_d250_
$LN40@s390_d250_:

; 1615 :          }
; 1616 :       }

  00b1f	eb 18		 jmp	 SHORT $LN39@s390_d250_
$LN38@s390_d250_:

; 1617 :       else
; 1618 :       {
; 1619 :          ioctl->goodblks+=1;

  00b21	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b29	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00b2c	ff c0		 inc	 eax
  00b2e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00b36	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN39@s390_d250_:

; 1620 :       }
; 1621 : 
; 1622 :       /* Determine the address of the next BIOE */
; 1623 :       bioebeg += sizeof(BIOE32);

  00b39	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00b3e	48 83 c0 10	 add	 rax, 16
  00b42	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1624 :       bioebeg &= AMASK31;

  00b47	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00b4c	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  00b52	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1625 :    } /* end of for loop */

  00b57	e9 1e f6 ff ff	 jmp	 $LN2@s390_d250_
$LN3@s390_d250_:

; 1626 : 
; 1627 : #if 0
; 1628 :    LOGMSG( "(d250_list32) BIOE's processed: %d\n", block );
; 1629 : #endif
; 1630 : 
; 1631 :    /* Restore device to guest ownership */
; 1632 :    d250_restore(ioctl->dev);

  00b5c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b64	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00b68	e8 00 00 00 00	 call	 d250_restore

; 1633 :    /* Note: device lock not held */
; 1634 : 
; 1635 :    /* If an access exception occurred:                                 */
; 1636 :    /*   If this is a synchronous request, generate a program exception */
; 1637 :    /*   or if this is asynchrnous, just return with a storage error    */
; 1638 :    if ( xcode )

  00b6d	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00b72	85 c0		 test	 eax, eax
  00b74	74 2a		 je	 SHORT $LN41@s390_d250_

; 1639 :    {
; 1640 :       if (async)

  00b76	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR async$[rsp], 0
  00b7e	74 09		 je	 SHORT $LN42@s390_d250_

; 1641 :           return PSC_STGERR;

  00b80	b8 02 00 00 00	 mov	 eax, 2
  00b85	eb 47		 jmp	 SHORT $LN1@s390_d250_
  00b87	eb 17		 jmp	 SHORT $LN43@s390_d250_
$LN42@s390_d250_:

; 1642 :       else
; 1643 :           ARCH_DEP(program_interrupt)(ioctl->regs, xcode);

  00b89	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00b8e	8b d0		 mov	 edx, eax
  00b90	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b98	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00b9b	e8 00 00 00 00	 call	 s390_program_interrupt
$LN43@s390_d250_:
$LN41@s390_d250_:

; 1644 :    }
; 1645 : 
; 1646 :    if ( status == BIOE_ABORTED )

  00ba0	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00ba5	83 f8 0c	 cmp	 eax, 12
  00ba8	75 07		 jne	 SHORT $LN44@s390_d250_

; 1647 :    {
; 1648 :       return PSC_REMOVED;

  00baa	b8 03 00 00 00	 mov	 eax, 3
  00baf	eb 1d		 jmp	 SHORT $LN1@s390_d250_
$LN44@s390_d250_:

; 1649 :    }
; 1650 : 
; 1651 :    /* Determine if we were completely successful or only partially     */
; 1652 :    /* successful.  'Partial' includes none successful.                 */
; 1653 :    /* Synchronous and asynchronous requests handle all failed          */
; 1654 :    /* differently. The good and bad blocks field are used by the       */
; 1655 :    /* caller                                                           */
; 1656 :    if (ioctl->goodblks < blocks)

  00bb1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00bb9	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR blocks$[rsp]
  00bc0	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  00bc3	7d 07		 jge	 SHORT $LN45@s390_d250_

; 1657 :    {
; 1658 :       return PSC_PARTIAL;

  00bc5	b8 01 00 00 00	 mov	 eax, 1
  00bca	eb 02		 jmp	 SHORT $LN1@s390_d250_
$LN45@s390_d250_:

; 1659 :    }
; 1660 :    return PSC_SUCCESS;

  00bcc	33 c0		 xor	 eax, eax
$LN1@s390_d250_:

; 1661 : 
; 1662 : } /* end function d250_list32 */

  00bce	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00bd6	48 33 cc	 xor	 rcx, rsp
  00bd9	e8 00 00 00 00	 call	 __security_check_cookie
  00bde	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00be5	5f		 pop	 rdi
  00be6	5e		 pop	 rsi
  00be7	c3		 ret	 0
s390_d250_list32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
psc$ = 96
tv289 = 100
rc2$ = 104
tv164 = 108
tv169 = 112
tv248 = 116
tv253 = 120
tv274 = 124
tv277 = 128
tv291 = 132
asyncp$ = 136
ioctl$ = 144
$T1 = 192
tid$ = 200
tv186 = 208
tv229 = 216
bioplx00$ = 224
tname$ = 288
buf$2 = 320
__$ArrayPad$ = 360
dev$ = 400
rc$ = 408
biopl$ = 416
regs$ = 424
s390_d250_iorq32 PROC

; 1176 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1177 : BIOPL_IORQ32   bioplx00;  /* Used to check reserved fields */
; 1178 : IOCTL32 ioctl;            /* Request information */
; 1179 : BYTE    psc;              /* List processing status code */
; 1180 : 
; 1181 : /* Asynchronous request related fields */
; 1182 : TID     tid;         /* Asynchronous thread ID */
; 1183 : char    tname[32];   /* Thread name */
; 1184 : IOCTL32 *asyncp;     /* Pointer to async thread's storage */
; 1185 : int     rc2;
; 1186 : 
; 1187 :    /* Clear the reserved BIOPL */
; 1188 :    memset(&bioplx00,0,sizeof(BIOPL_IORQ32));

  0002f	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR bioplx00$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00041	f3 aa		 rep stosb

; 1189 : 
; 1190 :    /* Make sure reserved fields and bits are binary zeros  */
; 1191 :    if ((memcmp(&biopl->resv1,&bioplx00,IORQ32R1_LEN)!=0) ||
; 1192 :        (memcmp(&biopl->resv2,&bioplx00,IORQ32R2_LEN)!=0) ||
; 1193 :        (memcmp(&biopl->resv3,&bioplx00,IORQ32R3_LEN)!=0) ||
; 1194 :        (biopl->flags & BIOPL_FLAGSRSV) ||

  00043	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	41 b8 15 00 00
	00		 mov	 r8d, 21
  00055	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 memcmp
  00065	85 c0		 test	 eax, eax
  00067	75 74		 jne	 SHORT $LN5@s390_d250_
  00069	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00071	48 83 c0 1a	 add	 rax, 26
  00075	41 b8 02 00 00
	00		 mov	 r8d, 2
  0007b	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 memcmp
  0008b	85 c0		 test	 eax, eax
  0008d	75 4e		 jne	 SHORT $LN5@s390_d250_
  0008f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00097	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0009b	41 b8 14 00 00
	00		 mov	 r8d, 20
  000a1	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 memcmp
  000b1	85 c0		 test	 eax, eax
  000b3	75 28		 jne	 SHORT $LN5@s390_d250_
  000b5	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000bd	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  000c1	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  000c6	85 c0		 test	 eax, eax
  000c8	75 13		 jne	 SHORT $LN5@s390_d250_
  000ca	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000d2	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  000d6	83 e0 0f	 and	 eax, 15
  000d9	85 c0		 test	 eax, eax
  000db	74 12		 je	 SHORT $LN4@s390_d250_
$LN5@s390_d250_:

; 1195 :        (biopl->key & BIOPL_KEYRSV)
; 1196 :       )
; 1197 :    {
; 1198 :        ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000dd	ba 06 00 00 00	 mov	 edx, 6
  000e2	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	e8 00 00 00 00	 call	 s390_program_interrupt
$LN4@s390_d250_:

; 1199 :    }
; 1200 : 
; 1201 :    /* Return with an error return code if the device does not exist */
; 1202 :    if (!dev)

  000ef	48 83 bc 24 90
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f8	75 18		 jne	 SHORT $LN6@s390_d250_

; 1203 :    {
; 1204 :       *rc = RC_NODEV;  /* Set the return code for no device */

  000fa	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00102	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 1205 :       return CC_FAILED; /* Indicate the function failed     */

  00108	b8 02 00 00 00	 mov	 eax, 2
  0010d	e9 7e 06 00 00	 jmp	 $LN1@s390_d250_
$LN6@s390_d250_:

; 1206 :    }
; 1207 : 
; 1208 :    /* If no environment, return with an error */
; 1209 :    if (!(dev->vmd250env))

  00112	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011a	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  00122	75 18		 jne	 SHORT $LN7@s390_d250_

; 1210 :    {
; 1211 :       *rc = RC_STATERR;

  00124	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0012c	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 1212 :       return CC_FAILED;

  00132	b8 02 00 00 00	 mov	 eax, 2
  00137	e9 54 06 00 00	 jmp	 $LN1@s390_d250_
$LN7@s390_d250_:

; 1213 :    }
; 1214 : 
; 1215 :    /* Fetch the block count from the BIOPL */
; 1216 :    FETCH_FW(ioctl.blkcount,&biopl->blkcount);

  0013c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00144	48 83 c0 1c	 add	 rax, 28
  00148	48 8b c8	 mov	 rcx, rax
  0014b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00150	8b c8		 mov	 ecx, eax
  00152	e8 00 00 00 00	 call	 _byteswap_ulong
  00157	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+24], eax

; 1217 : 
; 1218 :    /* Block count must be between 1 and 256, inclusive */
; 1219 :    if ((ioctl.blkcount<1) || (ioctl.blkcount>256))

  0015e	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR ioctl$[rsp+24], 1
  00166	7c 0d		 jl	 SHORT $LN9@s390_d250_
  00168	81 bc 24 a8 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR ioctl$[rsp+24], 256 ; 00000100H
  00173	7e 18		 jle	 SHORT $LN8@s390_d250_
$LN9@s390_d250_:

; 1220 :    {
; 1221 :        *rc = RC_CNT_ERR;

  00175	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0017d	c7 00 24 00 00
	00		 mov	 DWORD PTR [rax], 36	; 00000024H

; 1222 :        return CC_FAILED;

  00183	b8 02 00 00 00	 mov	 eax, 2
  00188	e9 03 06 00 00	 jmp	 $LN1@s390_d250_
$LN8@s390_d250_:

; 1223 :    }
; 1224 : 
; 1225 :    /* Fetch the address of the BIO entry list from the BIOPL */
; 1226 :    FETCH_FW(ioctl.listaddr,&biopl->bioeladr);

  0018d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00195	48 83 c0 24	 add	 rax, 36			; 00000024H
  00199	48 8b c8	 mov	 rcx, rax
  0019c	e8 00 00 00 00	 call	 fetch_fw_noswap
  001a1	8b c8		 mov	 ecx, eax
  001a3	e8 00 00 00 00	 call	 _byteswap_ulong
  001a8	89 84 24 ac 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+28], eax

; 1227 : 
; 1228 :    /* Extract the storage key from the BIOPL */
; 1229 :    ioctl.key=biopl->key;

  001af	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  001b7	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  001bb	88 84 24 b0 00
	00 00		 mov	 BYTE PTR ioctl$[rsp+32], al

; 1230 : 
; 1231 :    /* Set the structures that are involved in this request */
; 1232 :    ioctl.dev = dev;

  001c2	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR ioctl$[rsp+8], rax

; 1233 :    ioctl.regs = regs;

  001d2	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001da	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ioctl$[rsp], rax

; 1234 : 
; 1235 :    /* Set I/O success/failure counts to zero */
; 1236 :    ioctl.goodblks = 0;

  001e2	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ioctl$[rsp+36], 0

; 1237 :    ioctl.badblks = 0;

  001ed	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ioctl$[rsp+40], 0

; 1238 : 
; 1239 :    if (biopl->flags & BIOPL_ASYNC)

  001f8	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00200	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00204	83 e0 02	 and	 eax, 2
  00207	85 c0		 test	 eax, eax
  00209	0f 84 2a 03 00
	00		 je	 $LN10@s390_d250_

; 1240 :    {
; 1241 :        /* Build the request structure */
; 1242 : 
; 1243 :        /* Extract the 32-bit interrupt parameter from the BIOPL */
; 1244 :        FETCH_FW(ioctl.intrparm,biopl->intparm);

  0020f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00217	48 83 c0 28	 add	 rax, 40			; 00000028H
  0021b	48 8b c8	 mov	 rcx, rax
  0021e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00223	8b c8		 mov	 ecx, eax
  00225	e8 00 00 00 00	 call	 _byteswap_ulong
  0022a	89 84 24 a4 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+20], eax

; 1245 : 
; 1246 :        if (dev->ccwtrace)

  00231	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00239	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0023f	c1 e8 0f	 shr	 eax, 15
  00242	83 e0 01	 and	 eax, 1
  00245	85 c0		 test	 eax, eax
  00247	0f 84 94 00 00
	00		 je	 $LN12@s390_d250_

; 1247 :        {
; 1248 :           WRMSG(HHC01924, "I",

  0024d	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR ioctl$[rsp+32]
  00255	89 44 24 6c	 mov	 DWORD PTR tv164[rsp], eax
  00259	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00261	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00265	89 4c 24 70	 mov	 DWORD PTR tv169[rsp], ecx
  00269	b9 01 00 00 00	 mov	 ecx, 1
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00274	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+20]
  0027b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0027f	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv164[rsp]
  00283	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00287	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+24]
  0028e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00292	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+28]
  00299	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0029d	8b 4c 24 70	 mov	 ecx, DWORD PTR tv169[rsp]
  002a1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180317
  002ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180318
  002b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180319
  002cf	ba e5 04 00 00	 mov	 edx, 1253		; 000004e5H
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180320
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@s390_d250_:

; 1249 :                    dev->devnum,
; 1250 :                    ioctl.listaddr,
; 1251 :                    ioctl.blkcount,
; 1252 :                    ioctl.key,
; 1253 :                    ioctl.intrparm);
; 1254 :        }
; 1255 : 
; 1256 :        /* Set the default status code to an aborted list */
; 1257 :        /* Note: This should be set correctly from the returned PSC */
; 1258 :        ioctl.statuscod = PSC_STGERR;

  002e1	c6 84 24 a1 00
	00 00 02	 mov	 BYTE PTR ioctl$[rsp+17], 2

; 1259 : 
; 1260 :        /* Get the storage for the thread's parameters */
; 1261 :        if (!(asyncp=(IOCTL32 *)malloc(sizeof(IOCTL32))))

  002e9	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  002f4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR asyncp$[rsp], rax
  002fc	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR asyncp$[rsp], 0
  00305	0f 85 af 00 00
	00		 jne	 $LN13@s390_d250_

; 1262 :        {
; 1263 :           char buf[40];
; 1264 :           MSGBUF(buf, "malloc(%d)", (int)sizeof(IOCTL32));

  0030b	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00311	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180322
  00318	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0031d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1265 :           WRMSG (HHC01908, "E", buf, strerror(errno));

  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00331	8b 08		 mov	 ecx, DWORD PTR [rax]
  00333	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00339	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  00341	b9 01 00 00 00	 mov	 ecx, 1
  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv186[rsp]
  00354	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00359	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00361	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180323
  0036d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180324
  00379	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00383	41 b9 03 00 00
	00		 mov	 r9d, 3
  00389	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180325
  00390	ba f1 04 00 00	 mov	 edx, 1265		; 000004f1H
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180326
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1266 :           *rc = RC_ERROR;

  003a2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  003aa	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1267 :           return CC_FAILED;

  003b0	b8 02 00 00 00	 mov	 eax, 2
  003b5	e9 d6 03 00 00	 jmp	 $LN1@s390_d250_
$LN13@s390_d250_:

; 1268 :        }
; 1269 : 
; 1270 :        /* Copy the thread's parameters to its own storage */
; 1271 :        memcpy(asyncp,&ioctl,sizeof(IOCTL32));

  003ba	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ioctl$[rsp]
  003c2	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR asyncp$[rsp]
  003ca	48 8b f0	 mov	 rsi, rax
  003cd	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  003d2	f3 a4		 rep movsb

; 1272 : 
; 1273 :        /* Launch the asynchronous request on a separate thread */
; 1274 :        MSGBUF(tname,"d250_async %4.4X",dev->devnum);

  003d4	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003e0	44 8b c8	 mov	 r9d, eax
  003e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180327
  003ea	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  003ef	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tname$[rsp]
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1275 :        tname[sizeof(tname)-1]=0;

  003fd	b8 01 00 00 00	 mov	 eax, 1
  00402	48 6b c0 1f	 imul	 rax, rax, 31
  00406	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  0040e	48 83 bc 24 c0
	00 00 00 20	 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  00417	73 02		 jae	 SHORT $LN24@s390_d250_
  00419	eb 05		 jmp	 SHORT $LN25@s390_d250_
$LN24@s390_d250_:
  0041b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN25@s390_d250_:
  00420	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00428	c6 84 04 20 01
	00 00 00	 mov	 BYTE PTR tname$[rsp+rax], 0

; 1276 :        rc2 = create_thread (&tid, DETACHED, ARCH_DEP(d250_async32),

  00430	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00437	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0043d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180328
  00444	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00449	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tname$[rsp]
  00451	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00456	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR asyncp$[rsp]
  0045e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:s390_d250_async32
  00465	48 8b d0	 mov	 rdx, rax
  00468	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  00470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00476	89 44 24 68	 mov	 DWORD PTR rc2$[rsp], eax

; 1277 :                asyncp, tname);
; 1278 :        if(rc2)

  0047a	83 7c 24 68 00	 cmp	 DWORD PTR rc2$[rsp], 0
  0047f	0f 84 9a 00 00
	00		 je	 $LN14@s390_d250_

; 1279 :        {
; 1280 :           WRMSG (HHC00102, "E", strerror(rc2));

  00485	8b 4c 24 68	 mov	 ecx, DWORD PTR rc2$[rsp]
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0048f	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
  00497	b9 01 00 00 00	 mov	 ecx, 1
  0049c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004a2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv229[rsp]
  004aa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180330
  004b6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180331
  004c2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004cc	41 b9 03 00 00
	00		 mov	 r9d, 3
  004d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180332
  004d9	ba 00 05 00 00	 mov	 edx, 1280		; 00000500H
  004de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180333
  004e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1281 :           release_lock (&dev->lock);

  004eb	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f3	48 83 c0 38	 add	 rax, 56			; 00000038H
  004f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180334
  004fe	48 8b c8	 mov	 rcx, rax
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1282 :           *rc = RC_ERROR;

  00507	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0050f	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1283 :           return CC_FAILED;

  00515	b8 02 00 00 00	 mov	 eax, 2
  0051a	e9 71 02 00 00	 jmp	 $LN1@s390_d250_
$LN14@s390_d250_:

; 1284 :        }
; 1285 :        /* Launched the async request successfully */
; 1286 :        *rc = RC_ASYNC;

  0051f	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00527	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 1287 :        return CC_SUCCESS;

  0052d	33 c0		 xor	 eax, eax
  0052f	e9 5c 02 00 00	 jmp	 $LN1@s390_d250_

; 1288 :    }

  00534	e9 60 01 00 00	 jmp	 $LN11@s390_d250_
$LN10@s390_d250_:

; 1289 :    else
; 1290 :    {
; 1291 :        /* Perform the I/O request synchronously on this thread */
; 1292 :        /* Call the 32-bit BIOE request processor */
; 1293 :        if (dev->ccwtrace)

  00539	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00541	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00547	c1 e8 0f	 shr	 eax, 15
  0054a	83 e0 01	 and	 eax, 1
  0054d	85 c0		 test	 eax, eax
  0054f	0f 84 89 00 00
	00		 je	 $LN15@s390_d250_

; 1294 :        {
; 1295 :           WRMSG(HHC01925, "I",

  00555	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR ioctl$[rsp+32]
  0055d	89 44 24 74	 mov	 DWORD PTR tv248[rsp], eax
  00561	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00569	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0056d	89 4c 24 78	 mov	 DWORD PTR tv253[rsp], ecx
  00571	b9 01 00 00 00	 mov	 ecx, 1
  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv248[rsp]
  00580	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00584	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+24]
  0058b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0058f	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+28]
  00596	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0059a	8b 4c 24 78	 mov	 ecx, DWORD PTR tv253[rsp]
  0059e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180336
  005a9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180337
  005b5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005bf	41 b9 03 00 00
	00		 mov	 r9d, 3
  005c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180338
  005cc	ba 13 05 00 00	 mov	 edx, 1299		; 00000513H
  005d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180339
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@s390_d250_:

; 1296 :                    dev->devnum,
; 1297 :                    ioctl.listaddr,
; 1298 :                    ioctl.blkcount,
; 1299 :                    ioctl.key);
; 1300 :        }
; 1301 : 
; 1302 :        psc=ARCH_DEP(d250_list32)(&ioctl, SYNC);

  005de	33 d2		 xor	 edx, edx
  005e0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ioctl$[rsp]
  005e8	e8 00 00 00 00	 call	 s390_d250_list32
  005ed	88 44 24 60	 mov	 BYTE PTR psc$[rsp], al

; 1303 : 
; 1304 :        if (dev->ccwtrace)

  005f1	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005ff	c1 e8 0f	 shr	 eax, 15
  00602	83 e0 01	 and	 eax, 1
  00605	85 c0		 test	 eax, eax
  00607	0f 84 8c 00 00
	00		 je	 $LN16@s390_d250_

; 1305 :        {
; 1306 :           WRMSG(HHC01926, "I", dev->devnum,psc,ioctl.goodblks,ioctl.badblks);

  0060d	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  00612	89 44 24 7c	 mov	 DWORD PTR tv274[rsp], eax
  00616	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0061e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00622	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv277[rsp], ecx
  00629	b9 01 00 00 00	 mov	 ecx, 1
  0062e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00634	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+40]
  0063b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0063f	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+36]
  00646	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0064a	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv274[rsp]
  0064e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00652	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv277[rsp]
  00659	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0065d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180341
  00664	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00669	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180342
  00670	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00675	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0067a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00680	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180343
  00687	ba 1a 05 00 00	 mov	 edx, 1306		; 0000051aH
  0068c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180344
  00693	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@s390_d250_:
$LN11@s390_d250_:

; 1307 :        }
; 1308 : 
; 1309 :    }
; 1310 : 
; 1311 :    /* Processor status used to determine return and condition codes */
; 1312 :    switch(psc)

  00699	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  0069e	88 44 24 64	 mov	 BYTE PTR tv289[rsp], al
  006a2	80 7c 24 64 00	 cmp	 BYTE PTR tv289[rsp], 0
  006a7	74 10		 je	 SHORT $LN17@s390_d250_
  006a9	80 7c 24 64 01	 cmp	 BYTE PTR tv289[rsp], 1
  006ae	74 1e		 je	 SHORT $LN18@s390_d250_
  006b0	80 7c 24 64 03	 cmp	 BYTE PTR tv289[rsp], 3
  006b5	74 53		 je	 SHORT $LN21@s390_d250_
  006b7	eb 66		 jmp	 SHORT $LN22@s390_d250_
$LN17@s390_d250_:

; 1313 :    {
; 1314 :       case PSC_SUCCESS:
; 1315 :          *rc = RC_SUCCESS;

  006b9	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006c1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1316 :          return CC_SUCCESS;

  006c7	33 c0		 xor	 eax, eax
  006c9	e9 c2 00 00 00	 jmp	 $LN1@s390_d250_
$LN18@s390_d250_:

; 1317 :       case PSC_PARTIAL:
; 1318 :          if (ioctl.goodblks == 0)

  006ce	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR ioctl$[rsp+36], 0
  006d6	75 1a		 jne	 SHORT $LN19@s390_d250_

; 1319 :          {
; 1320 :             *rc = RC_ALL_BAD;

  006d8	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006e0	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 1321 :             return CC_FAILED;

  006e6	b8 02 00 00 00	 mov	 eax, 2
  006eb	e9 a0 00 00 00	 jmp	 $LN1@s390_d250_

; 1322 :          }

  006f0	eb 18		 jmp	 SHORT $LN20@s390_d250_
$LN19@s390_d250_:

; 1323 :          else
; 1324 :          {
; 1325 :             *rc = RC_SYN_PART;

  006f2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006fa	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 1326 :             return CC_PARTIAL;

  00700	b8 01 00 00 00	 mov	 eax, 1
  00705	e9 86 00 00 00	 jmp	 $LN1@s390_d250_
$LN20@s390_d250_:
$LN21@s390_d250_:

; 1327 :          }
; 1328 :       case PSC_REMOVED:
; 1329 :          *rc = RC_REM_PART;

  0070a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00712	c7 00 2c 00 00
	00		 mov	 DWORD PTR [rax], 44	; 0000002cH

; 1330 :          return CC_PARTIAL;

  00718	b8 01 00 00 00	 mov	 eax, 1
  0071d	eb 71		 jmp	 SHORT $LN1@s390_d250_
$LN22@s390_d250_:

; 1331 :       default:
; 1332 :          WRMSG (HHC01927, "I", psc);

  0071f	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  00724	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv291[rsp], eax
  0072b	b9 01 00 00 00	 mov	 ecx, 1
  00730	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00736	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  0073d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00741	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180351
  00748	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0074d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180352
  00754	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00759	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0075e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00764	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180353
  0076b	ba 34 05 00 00	 mov	 edx, 1332		; 00000534H
  00770	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180354
  00777	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1333 :          *rc = RC_ERROR;

  0077d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00785	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1334 :          return CC_FAILED;

  0078b	b8 02 00 00 00	 mov	 eax, 2
$LN1@s390_d250_:
$LN23@s390_d250_:

; 1335 :    }
; 1336 : 
; 1337 : } /* end function ARCH_DEP(d250_iorq32) */

  00790	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00798	48 33 cc	 xor	 rcx, rsp
  0079b	e8 00 00 00 00	 call	 __security_check_cookie
  007a0	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  007a7	5f		 pop	 rdi
  007a8	5e		 pop	 rsi
  007a9	c3		 ret	 0
s390_d250_iorq32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_storage_key
_TEXT	SEGMENT
abs$ = 48
s390_get_storage_key PROC				; COMDAT

; 254  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 255  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 256  :     return ARCH_DEP( get_2K_storage_key )( abs );
; 257  : #else
; 258  :     return ARCH_DEP( get_4K_storage_key )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 s390_get_4K_storage_key

; 259  : #endif
; 260  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
s390_get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
s390_get_4K_storage_key PROC				; COMDAT

; 239  :   inline BYTE  ARCH_DEP( get_4K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 s390__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
s390_get_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
s390__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@s390__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $LN5@s390__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0001e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00026	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0002f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00041	0b c8		 or	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00049	eb 16		 jmp	 SHORT $LN6@s390__get_
$LN5@s390__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  0004b	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00055	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s390__get_:

; 140  :     return skey;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
s390__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
rc$ = 48
cc$ = 52
devnum$ = 56
tv95 = 60
dev$ = 64
biopaddr$ = 72
bioplin$ = 80
__$ArrayPad$ = 144
r1$ = 176
r2$ = 184
regs$ = 192
s390_vm_blockio PROC

; 981  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 982  : /* Guest related paramters and values                                */
; 983  : RADR    biopaddr;                      /* BIOPL address              */
; 984  : 
; 985  : union   parmlist{                      /* BIOPL formats that         */
; 986  :         BIOPL biopl;                   /* May be supplied by the     */
; 987  :         BIOPL_INIT32 init32;           /* guest                      */
; 988  :         BIOPL_IORQ32 iorq32;
; 989  :         BIOPL_REMOVE remove;
; 990  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 991  :         BIOPL_INIT64 init64;
; 992  :         BIOPL_IORQ64 iorq64;
; 993  : #endif /* defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) */
; 994  :         };
; 995  : union   parmlist bioplin;              /* BIOPL from/to guest        */
; 996  : 
; 997  : U16     devnum;                        /* Device number              */
; 998  : DEVBLK *dev;                           /* --> Device block           */
; 999  : int     rc;                            /* return code in Rx+1        */
; 1000 : int     cc;                            /* condition code             */
; 1001 : 
; 1002 :     rc = RC_ERROR; /* Initialize the return code to error */

  00026	c7 44 24 30 ff
	00 00 00	 mov	 DWORD PTR rc$[rsp], 255	; 000000ffH

; 1003 :     cc = CC_FAILED; /* Failure assumed unless otherwise successful */

  0002e	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1004 : 
; 1005 : #if 0 // debug
; 1006 :     if (sizeof(BIOPL) != 64)
; 1007 :     {
; 1008 :             LOGMSG( "BIOPL size not 64: %d\n", sizeof( BIOPL ));
; 1009 :     }
; 1010 :     if (sizeof(BIOPL_INIT32) != 64)
; 1011 :     {
; 1012 :             LOGMSG( "BIOPL_INIT32 size not 64: %d\n", sizeof( BIOPL_INIT32 ));
; 1013 :     }
; 1014 :     if (sizeof(BIOPL_INIT64) != 64)
; 1015 :     {
; 1016 :             LOGMSG( "BIOPL_INIT64 size not 64: %d\n", sizeof( BIOPL_INIT64 ));
; 1017 :     }
; 1018 :     if (sizeof(BIOPL_IORQ32) != 64)
; 1019 :     {
; 1020 :             LOGMSG( "BIOPL_IORQ32 size not 64: %d\n", sizeof( BIOPL_IORQ32 ));
; 1021 :     }
; 1022 :     if (sizeof(BIOPL_REMOVE) != 64)
; 1023 :     {
; 1024 :             LOGMSG( "BIOPL_REMOVE size not 64: %d\n", sizeof( BIOPL_REMOVE ));
; 1025 :     }
; 1026 :     if (sizeof(BIOPL_IORQ64) != 64)
; 1027 :     {
; 1028 :             LOGMSG( "BIOPL_IORQ64 size not 64: %d\n", sizeof( BIOPL_IORQ64 ));
; 1029 :     }
; 1030 :     if (sizeof(BIOE32) != 16)
; 1031 :     {
; 1032 :             LOGMSG( "BIOE32 size not 16: %d\n", sizeof( BIOE32 ));
; 1033 :     }
; 1034 :     if (sizeof(BIOE64) != 24)
; 1035 :     {
; 1036 :             LOGMSG( "BIOE64 size not 24: %d\n", sizeof( BIOE64 ));
; 1037 :     }
; 1038 : #endif
; 1039 : 
; 1040 :     /* Retrieve the BIOPL address from R1 */
; 1041 :     biopaddr = regs->GR(r1);

  00036	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004d	48 89 44 24 48	 mov	 QWORD PTR biopaddr$[rsp], rax

; 1042 : 
; 1043 :     /* Specification exception if the BIOPL is not on a doubleword boundary */
; 1044 :     if (biopaddr & 0x00000007)

  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR biopaddr$[rsp]
  00057	48 83 e0 07	 and	 rax, 7
  0005b	48 85 c0	 test	 rax, rax
  0005e	74 12		 je	 SHORT $LN4@s390_vm_bl

; 1045 :     {
; 1046 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00060	ba 06 00 00 00	 mov	 edx, 6
  00065	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	e8 00 00 00 00	 call	 s390_program_interrupt
$LN4@s390_vm_bl:

; 1047 :     }
; 1048 : 
; 1049 :     /* Fetch the BIOPL from guest storage */
; 1050 :     ARCH_DEP(wfetchc) (&bioplin, sizeof(bioplin)-1,

  00072	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00080	48 8b 4c 24 48	 mov	 rcx, QWORD PTR biopaddr$[rsp]
  00085	48 23 c8	 and	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00093	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00098	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0009e	44 8b c0	 mov	 r8d, eax
  000a1	b2 3f		 mov	 dl, 63			; 0000003fH
  000a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  000a8	e8 00 00 00 00	 call	 s390_vfetchc

; 1051 :                        biopaddr, USE_REAL_ADDR, regs);
; 1052 : 
; 1053 :     /* Access the targeted device number from the BIOPL*/
; 1054 :     FETCH_HW(devnum,&bioplin.biopl.devnum);

  000ad	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  000b2	e8 00 00 00 00	 call	 fetch_hw_noswap
  000b7	0f b7 c8	 movzx	 ecx, ax
  000ba	e8 00 00 00 00	 call	 _byteswap_ushort
  000bf	66 89 44 24 38	 mov	 WORD PTR devnum$[rsp], ax

; 1055 : 
; 1056 :     /* Locate the device by the number */
; 1057 :     dev = find_device_by_devnum (0,devnum);

  000c4	0f b7 54 24 38	 movzx	 edx, WORD PTR devnum$[rsp]
  000c9	33 c9		 xor	 ecx, ecx
  000cb	e8 00 00 00 00	 call	 find_device_by_devnum
  000d0	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax

; 1058 :     /* Device not found will be checked by the called function */
; 1059 : 
; 1060 :     switch(regs->GR_L(r2))

  000d5	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  000dd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ec	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
  000f0	83 7c 24 3c 00	 cmp	 DWORD PTR tv95[rsp], 0
  000f5	74 13		 je	 SHORT $LN5@s390_vm_bl
  000f7	83 7c 24 3c 01	 cmp	 DWORD PTR tv95[rsp], 1
  000fc	74 49		 je	 SHORT $LN7@s390_vm_bl
  000fe	83 7c 24 3c 02	 cmp	 DWORD PTR tv95[rsp], 2
  00103	74 7f		 je	 SHORT $LN9@s390_vm_bl
  00105	e9 9c 00 00 00	 jmp	 $LN10@s390_vm_bl
$LN5@s390_vm_bl:

; 1061 :     {
; 1062 : 
; 1063 : /*--------------------------------------------------------*/
; 1064 : /* Initialize the Block I/O Device Environment            */
; 1065 : /*--------------------------------------------------------*/
; 1066 :     case INIT:
; 1067 : 
; 1068 : #if !defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1069 :          /* 64-bit formats not supported for S/370 or ESA/390 */
; 1070 :          /* and bits 1-7 must be zero                         */
; 1071 :          if (bioplin.biopl.flaga != 0x00)

  0010a	0f b6 44 24 52	 movzx	 eax, BYTE PTR bioplin$[rsp+2]
  0010f	85 c0		 test	 eax, eax
  00111	74 12		 je	 SHORT $LN6@s390_vm_bl

; 1072 :          {
; 1073 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00113	ba 06 00 00 00	 mov	 edx, 6
  00118	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00120	e8 00 00 00 00	 call	 s390_program_interrupt
$LN6@s390_vm_bl:

; 1074 :          }
; 1075 : 
; 1076 :          /* Call the 32-bit addressing function */
; 1077 :          cc = d250_init32(dev,&rc,&bioplin.init32,regs);

  00125	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0012d	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  00132	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00137	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0013c	e8 00 00 00 00	 call	 d250_init32
  00141	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1078 : #else
; 1079 :          /* Bits 1-7 must be zero for z/Architecture */
; 1080 :          if (bioplin.biopl.flaga & BIOPL_FLAGARSV)
; 1081 :          {
; 1082 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1083 :          }
; 1084 :          /* Call the addressing sensitive function */
; 1085 :          if (bioplin.biopl.flaga & BIOPL_FLAGAMSK)
; 1086 :          {
; 1087 :             cc = d250_init64(dev,&rc,&bioplin.init64,regs);
; 1088 :          }
; 1089 :          else
; 1090 :          {
; 1091 :             cc = d250_init32(dev,&rc,&bioplin.init32,regs);
; 1092 :          }
; 1093 : #endif /* !FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1094 :          break;

  00145	eb 71		 jmp	 SHORT $LN2@s390_vm_bl
$LN7@s390_vm_bl:

; 1095 : 
; 1096 : /*--------------------------------------------------------*/
; 1097 : /* Perform block I/O read/write requests to the device    */
; 1098 : /*--------------------------------------------------------*/
; 1099 :     case IOREQ:
; 1100 : 
; 1101 : #if !defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1102 :          /* 64-bit formats not supported for S/370 or ESA/390 */
; 1103 :          /* and bits 1-7 must be zero                         */
; 1104 :          if (bioplin.biopl.flaga != 0x00)

  00147	0f b6 44 24 52	 movzx	 eax, BYTE PTR bioplin$[rsp+2]
  0014c	85 c0		 test	 eax, eax
  0014e	74 12		 je	 SHORT $LN8@s390_vm_bl

; 1105 :          {
; 1106 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00150	ba 06 00 00 00	 mov	 edx, 6
  00155	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015d	e8 00 00 00 00	 call	 s390_program_interrupt
$LN8@s390_vm_bl:

; 1107 :          }
; 1108 :          cc = ARCH_DEP(d250_iorq32)(dev,&rc,&bioplin.iorq32,regs);

  00162	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016a	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  0016f	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00174	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00179	e8 00 00 00 00	 call	 s390_d250_iorq32
  0017e	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1109 : #else
; 1110 :          /* Bits 1-7 must be zero for z/Architecture */
; 1111 :          if (bioplin.biopl.flaga & BIOPL_FLAGARSV)
; 1112 :          {
; 1113 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1114 :          }
; 1115 : 
; 1116 :          if (bioplin.biopl.flaga & BIOPL_FLAGAMSK)
; 1117 :          {
; 1118 :             cc = ARCH_DEP(d250_iorq64)(dev,&rc,&bioplin.iorq64,regs);
; 1119 :          }
; 1120 :          else
; 1121 :          {
; 1122 :             cc = ARCH_DEP(d250_iorq32)(dev,&rc,&bioplin.iorq32,regs);
; 1123 :          }
; 1124 : #endif /* !FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1125 :          break;

  00182	eb 34		 jmp	 SHORT $LN2@s390_vm_bl
$LN9@s390_vm_bl:

; 1126 : 
; 1127 : /*--------------------------------------------------------*/
; 1128 : /* Remove the Block I/O Device Environment                */
; 1129 : /*--------------------------------------------------------*/
; 1130 :     case REMOVE:
; 1131 :          cc = d250_remove(dev,&rc,&bioplin.remove,regs);

  00184	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018c	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  00191	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00196	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0019b	e8 00 00 00 00	 call	 d250_remove
  001a0	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1132 :          break;

  001a4	eb 12		 jmp	 SHORT $LN2@s390_vm_bl
$LN10@s390_vm_bl:

; 1133 :     default:
; 1134 :          ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001a6	ba 06 00 00 00	 mov	 edx, 6
  001ab	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	e8 00 00 00 00	 call	 s390_program_interrupt
$LN2@s390_vm_bl:

; 1135 :     } /* end switch(regs->GR_L(r2)) */
; 1136 : 
; 1137 :     /* Update the BIOPL in main storage */
; 1138 :     ARCH_DEP(wstorec) (&bioplin, sizeof(bioplin)-1,

  001b8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c0	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  001c6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR biopaddr$[rsp]
  001cb	48 23 c8	 and	 rcx, rax
  001ce	48 8b c1	 mov	 rax, rcx
  001d1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001de	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  001e4	44 8b c0	 mov	 r8d, eax
  001e7	b2 3f		 mov	 dl, 63			; 0000003fH
  001e9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  001ee	e8 00 00 00 00	 call	 s390_vstorec

; 1139 :                        biopaddr, USE_REAL_ADDR, regs);
; 1140 : 
; 1141 :     /* Set the return code in Rx+1 */
; 1142 :     regs->GR_L((r1+1)&0xF) = rc;

  001f3	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  001fa	ff c0		 inc	 eax
  001fc	83 e0 0f	 and	 eax, 15
  001ff	48 98		 cdqe
  00201	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00209	8b 54 24 30	 mov	 edx, DWORD PTR rc$[rsp]
  0020d	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1143 : 
; 1144 :     /* Return the condition code */
; 1145 :     return cc;

  00214	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]

; 1146 : 
; 1147 : } /* end function vm_blockio */

  00218	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00220	48 33 cc	 xor	 rcx, rsp
  00223	e8 00 00 00 00	 call	 __security_check_cookie
  00228	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0022f	c3		 ret	 0
s390_vm_blockio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
psc$ = 32
ioctl$ = 40
ctl$ = 64
s370_d250_async32 PROC

; 1153 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1154 : IOCTL32 *ioctl;    /* 32-bit IO request controls    */
; 1155 : BYTE    psc;       /* List processing status code   */
; 1156 : 
; 1157 :    /* Fetch the IO request control structure */
; 1158 :    ioctl=(IOCTL32 *)ctl;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ctl$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR ioctl$[rsp], rax

; 1159 : 
; 1160 :    /* Call the 32-bit BIOE request processor on this async thread*/
; 1161 :    psc=ARCH_DEP(d250_list32)(ioctl, ASYNC);

  00013	ba 01 00 00 00	 mov	 edx, 1
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0001d	e8 00 00 00 00	 call	 s370_d250_list32
  00022	88 44 24 20	 mov	 BYTE PTR psc$[rsp], al

; 1162 : 
; 1163 :    /* Trigger the external interrupt here */
; 1164 : 
; 1165 :    d250_bio_interrupt(ioctl->dev, ioctl->intrparm, psc, 0x03);

  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR ioctl$[rsp]
  0002b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002e	41 b1 03	 mov	 r9b, 3
  00031	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR psc$[rsp]
  00037	8b d0		 mov	 edx, eax
  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR ioctl$[rsp]
  0003e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00042	e8 00 00 00 00	 call	 d250_bio_interrupt

; 1166 : 
; 1167 :    free(ioctl);

  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1168 :    return NULL;

  00052	33 c0		 xor	 eax, eax

; 1169 : } /* end function ARCH_DEP(d250_async32) */

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
s370_d250_async32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
sk2$ = 32
skmid$ = 33
sk1$ = 34
beg$ = 64
end$ = 72
acctype$ = 80
key$ = 88
regs$ = 96
s370_d250_addrck PROC

; 1677 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1678 : BYTE   sk1;      /* Storage key of first byte of area         */
; 1679 : BYTE   sk2;      /* Storage key of last byte of area          */
; 1680 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1681 : BYTE   skmid;    /* Storage key of middle byte of area        */
; 1682 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1683 : 
; 1684 : 
; 1685 :     if ( (end > regs->mainlim) || (end > MAXADDRESS) || end < beg )

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00024	48 39 44 24 48	 cmp	 QWORD PTR end$[rsp], rax
  00029	77 17		 ja	 SHORT $LN3@s370_d250_
  0002b	48 81 7c 24 48
	ff ff ff 00	 cmp	 QWORD PTR end$[rsp], 16777215 ; 00ffffffH
  00034	77 0c		 ja	 SHORT $LN3@s370_d250_
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR beg$[rsp]
  0003b	48 39 44 24 48	 cmp	 QWORD PTR end$[rsp], rax
  00040	73 0a		 jae	 SHORT $LN2@s370_d250_
$LN3@s370_d250_:

; 1686 :     {
; 1687 :        return PGM_ADDRESSING_EXCEPTION;

  00042	b8 05 00 00 00	 mov	 eax, 5
  00047	e9 1b 01 00 00	 jmp	 $LN1@s370_d250_
$LN2@s370_d250_:

; 1688 :     }
; 1689 : 
; 1690 :     /* Note this logic is inspired by        */
; 1691 :     /* inline.h ARCH_DEP(is_fetch_protected) */
; 1692 :     /* inline.h ARCH_DEP(is_store_protected) */
; 1693 : 
; 1694 :     if (key == 0)

  0004c	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  00051	85 c0		 test	 eax, eax
  00053	75 07		 jne	 SHORT $LN4@s370_d250_

; 1695 :     {
; 1696 :        return 0;

  00055	33 c0		 xor	 eax, eax
  00057	e9 0b 01 00 00	 jmp	 $LN1@s370_d250_
$LN4@s370_d250_:

; 1697 :     }
; 1698 : 
; 1699 :     sk1 = ARCH_DEP( get_storage_key )( beg );

  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR beg$[rsp]
  00061	e8 00 00 00 00	 call	 s370_get_storage_key
  00066	88 44 24 22	 mov	 BYTE PTR sk1$[rsp], al

; 1700 :     sk2 = ARCH_DEP( get_storage_key )( end );

  0006a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR end$[rsp]
  0006f	e8 00 00 00 00	 call	 s370_get_storage_key
  00074	88 44 24 20	 mov	 BYTE PTR sk2$[rsp], al

; 1701 : 
; 1702 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1703 :     if ( ( end - beg ) > 2048 )

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR beg$[rsp]
  0007d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR end$[rsp]
  00082	48 2b c8	 sub	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 3d 00 08 00
	00		 cmp	 rax, 2048		; 00000800H
  0008e	76 19		 jbe	 SHORT $LN5@s370_d250_

; 1704 :     {
; 1705 :        skmid = ARCH_DEP( get_storage_key )( beg + 2048 );

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR beg$[rsp]
  00095	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 s370_get_storage_key
  000a3	88 44 24 21	 mov	 BYTE PTR skmid$[rsp], al

; 1706 :     }

  000a7	eb 09		 jmp	 SHORT $LN6@s370_d250_
$LN5@s370_d250_:

; 1707 :     else
; 1708 :     {
; 1709 :        skmid = sk2;

  000a9	0f b6 44 24 20	 movzx	 eax, BYTE PTR sk2$[rsp]
  000ae	88 44 24 21	 mov	 BYTE PTR skmid$[rsp], al
$LN6@s370_d250_:

; 1710 :     }
; 1711 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1712 : 
; 1713 :     if (acctype == ACCTYPE_READ)

  000b2	83 7c 24 50 04	 cmp	 DWORD PTR acctype$[rsp], 4
  000b7	75 69		 jne	 SHORT $LN7@s370_d250_

; 1714 :     {  /* Check for fetch protection  */
; 1715 :        if (  ((sk1 & STORKEY_FETCH) && (key != (sk1 & STORKEY_KEY)))
; 1716 :            ||((sk2 & STORKEY_FETCH) && (key != (sk2 & STORKEY_KEY)))
; 1717 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1718 :            ||((skmid & STORKEY_FETCH) && (key != (skmid & STORKEY_KEY)))

  000b9	0f b6 44 24 22	 movzx	 eax, BYTE PTR sk1$[rsp]
  000be	83 e0 08	 and	 eax, 8
  000c1	85 c0		 test	 eax, eax
  000c3	74 14		 je	 SHORT $LN11@s370_d250_
  000c5	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  000ca	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR sk1$[rsp]
  000cf	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000d5	3b c1		 cmp	 eax, ecx
  000d7	75 40		 jne	 SHORT $LN10@s370_d250_
$LN11@s370_d250_:
  000d9	0f b6 44 24 20	 movzx	 eax, BYTE PTR sk2$[rsp]
  000de	83 e0 08	 and	 eax, 8
  000e1	85 c0		 test	 eax, eax
  000e3	74 14		 je	 SHORT $LN12@s370_d250_
  000e5	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  000ea	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR sk2$[rsp]
  000ef	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000f5	3b c1		 cmp	 eax, ecx
  000f7	75 20		 jne	 SHORT $LN10@s370_d250_
$LN12@s370_d250_:
  000f9	0f b6 44 24 21	 movzx	 eax, BYTE PTR skmid$[rsp]
  000fe	83 e0 08	 and	 eax, 8
  00101	85 c0		 test	 eax, eax
  00103	74 1b		 je	 SHORT $LN9@s370_d250_
  00105	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  0010a	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR skmid$[rsp]
  0010f	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00115	3b c1		 cmp	 eax, ecx
  00117	74 07		 je	 SHORT $LN9@s370_d250_
$LN10@s370_d250_:

; 1719 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1720 :           )
; 1721 :        {
; 1722 :           return PGM_PROTECTION_EXCEPTION;

  00119	b8 04 00 00 00	 mov	 eax, 4
  0011e	eb 47		 jmp	 SHORT $LN1@s370_d250_
$LN9@s370_d250_:

; 1723 :        }
; 1724 :     }

  00120	eb 43		 jmp	 SHORT $LN8@s370_d250_
$LN7@s370_d250_:

; 1725 :     else /* assume ACCTYPE_WRITE */
; 1726 :     {  /* Check for store protection */
; 1727 :        if (  (key != (sk1 & STORKEY_KEY))
; 1728 :            ||(key != (sk2 & STORKEY_KEY))
; 1729 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1730 :            ||(key != (skmid & STORKEY_KEY))

  00122	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  00127	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR sk1$[rsp]
  0012c	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00132	3b c1		 cmp	 eax, ecx
  00134	75 28		 jne	 SHORT $LN14@s370_d250_
  00136	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  0013b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR sk2$[rsp]
  00140	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00146	3b c1		 cmp	 eax, ecx
  00148	75 14		 jne	 SHORT $LN14@s370_d250_
  0014a	0f b6 44 24 58	 movzx	 eax, BYTE PTR key$[rsp]
  0014f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR skmid$[rsp]
  00154	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0015a	3b c1		 cmp	 eax, ecx
  0015c	74 07		 je	 SHORT $LN13@s370_d250_
$LN14@s370_d250_:

; 1731 : #endif /* defined(FEATURE_2K_STORAGE_KEYS) */
; 1732 :           )
; 1733 :        {
; 1734 :           return PGM_PROTECTION_EXCEPTION;

  0015e	b8 04 00 00 00	 mov	 eax, 4
  00163	eb 02		 jmp	 SHORT $LN1@s370_d250_
$LN13@s370_d250_:
$LN8@s370_d250_:

; 1735 :        }
; 1736 :     }
; 1737 :     return 0;

  00165	33 c0		 xor	 eax, eax
$LN1@s370_d250_:

; 1738 : } /* end of function ARCH_DEP(d250_addrck) */

  00167	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0016b	c3		 ret	 0
s370_d250_addrck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
status$ = 96
xcode$ = 100
bioebeg$ = 104
bufbeg$ = 112
blknum$ = 120
block$ = 124
bufend$ = 128
tv293 = 136
tv359 = 140
physblk$ = 144
blocks$ = 148
tv70 = 152
tv79 = 156
tv152 = 160
tv156 = 164
tv160 = 168
tv234 = 172
tv239 = 176
tv273 = 180
tv277 = 184
tv281 = 188
tv339 = 192
tv343 = 196
tv347 = 200
tv410 = 204
tv452 = 208
tv457 = 212
bioeend$ = 216
tv73 = 224
tv412 = 232
tv414 = 240
bioe$ = 248
__$ArrayPad$ = 264
ioctl$ = 304
async$ = 312
s370_d250_list32 PROC

; 1361 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1362 : BIOE32 bioe;      /* 32-bit BIOE fetched from absolute storage */
; 1363 : RADR   bioebeg;   /* Starting address of the BIOE              */
; 1364 : RADR   bioeend;   /* Address of last byte of BIOE              */
; 1365 : U16    xcode;     /* Detected exception condition              */
; 1366 : int    blocks;    /* Number of blocks being processed          */
; 1367 : int    block;     /* counter used in block I/O loop            */
; 1368 : S32    blknum;    /* Block number of the request               */
; 1369 : BYTE   status;    /* Returned BIOE status                      */
; 1370 : /* Passed to generic block I/O function                        */
; 1371 : int    physblk;   /* Physical block number                     */
; 1372 : RADR   bufbeg;    /* Address where the read/write will occur   */
; 1373 : RADR   bufend;    /* Last byte read or written                 */
; 1374 : 
; 1375 :    xcode = 0;   /* Initialize the address check exception code */

  00024	33 c0		 xor	 eax, eax
  00026	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1376 :    status = 0;

  0002b	c6 44 24 60 00	 mov	 BYTE PTR status$[rsp], 0

; 1377 : 
; 1378 :    /* Preserve pending sense if any and establish my ownership */
; 1379 :    /* of the device by reserving it if shared and locking it   */
; 1380 :    if (ioctl->dev->ccwtrace)

  00030	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00038	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00042	c1 e8 0f	 shr	 eax, 15
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 b6 00 00
	00		 je	 $LN12@s370_d250_

; 1381 :    {
; 1382 :       WRMSG (HHC01928, "I",

  00050	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00058	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0005c	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv70[rsp], eax
  00063	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0006b	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0006e	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv73[rsp], rcx
  00076	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  0007e	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00082	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00086	89 94 24 9c 00
	00 00		 mov	 DWORD PTR tv79[rsp], edx
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00098	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv70[rsp]
  0009f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000a3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv73[rsp]
  000ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000b0	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  000b8	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  000bb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000bf	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv79[rsp]
  000c6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170123
  000d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170124
  000dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170125
  000f4	ba 6b 05 00 00	 mov	 edx, 1387		; 0000056bH
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170126
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@s370_d250_:

; 1383 :                ioctl->dev->devnum,
; 1384 :                ioctl->blkcount,
; 1385 :                (RADR)ioctl->listaddr,
; 1386 :                ioctl->key
; 1387 :                );
; 1388 :    }
; 1389 : 
; 1390 :    /* Take ownership of the device */
; 1391 :    d250_preserve(ioctl->dev);

  00106	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0010e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00112	e8 00 00 00 00	 call	 d250_preserve

; 1392 :    /* Note: the DEVBLK is now locked */
; 1393 : 
; 1394 :    if (!ioctl->dev->vmd250env)

  00117	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0011f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00123	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  0012b	75 1b		 jne	 SHORT $LN13@s370_d250_

; 1395 :    {
; 1396 :        d250_restore(ioctl->dev);

  0012d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00135	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00139	e8 00 00 00 00	 call	 d250_restore

; 1397 :        /* Note: the device lock is now released */
; 1398 :        return PSC_REMOVED;

  0013e	b8 03 00 00 00	 mov	 eax, 3
  00143	e9 eb 0a 00 00	 jmp	 $LN1@s370_d250_
$LN13@s370_d250_:

; 1399 :    }
; 1400 : 
; 1401 :    blocks=(int)ioctl->blkcount;

  00148	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00150	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00153	89 84 24 94 00
	00 00		 mov	 DWORD PTR blocks$[rsp], eax

; 1402 :    bioebeg=ioctl->listaddr & AMASK31 ;

  0015a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00162	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00165	0f ba f0 1f	 btr	 eax, 31
  00169	8b c0		 mov	 eax, eax
  0016b	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1403 : 
; 1404 :    /* Process each of the BIOE's supplied by the BIOPL count field */
; 1405 :    for ( block = 0 ; block < blocks ; block++ )

  00170	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR block$[rsp], 0
  00178	eb 0a		 jmp	 SHORT $LN4@s370_d250_
$LN2@s370_d250_:
  0017a	8b 44 24 7c	 mov	 eax, DWORD PTR block$[rsp]
  0017e	ff c0		 inc	 eax
  00180	89 44 24 7c	 mov	 DWORD PTR block$[rsp], eax
$LN4@s370_d250_:
  00184	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR blocks$[rsp]
  0018b	39 44 24 7c	 cmp	 DWORD PTR block$[rsp], eax
  0018f	0f 8d 2c 0a 00
	00		 jge	 $LN3@s370_d250_

; 1406 :    {
; 1407 :       status = 0xFF;  /* Set undefined status */

  00195	c6 44 24 60 ff	 mov	 BYTE PTR status$[rsp], 255 ; 000000ffH

; 1408 : 
; 1409 :       bioeend=( bioebeg + sizeof(BIOE32) - 1 ) & AMASK31;

  0019a	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  0019f	48 83 c0 0f	 add	 rax, 15
  001a3	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  001a9	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR bioeend$[rsp], rax

; 1410 :       xcode=ARCH_DEP(d250_addrck)

  001b1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001c9	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  001ce	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d4	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR bioeend$[rsp]
  001dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  001e1	e8 00 00 00 00	 call	 s370_d250_addrck
  001e6	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1411 :             (bioebeg,bioeend,ACCTYPE_READ,ioctl->key,ioctl->regs);
; 1412 :       if (ioctl->dev->ccwtrace)

  001eb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  001f3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001f7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001fd	c1 e8 0f	 shr	 eax, 15
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	0f 84 b5 00 00
	00		 je	 $LN14@s370_d250_

; 1413 :       {
; 1414 :          WRMSG(HHC01929,"I",ioctl->dev->devnum,xcode,bioebeg,bioeend,ioctl->key);

  0020b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00213	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00217	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv152[rsp], eax
  0021e	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00223	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv156[rsp], ecx
  0022a	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00232	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00236	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0023a	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv160[rsp], edx
  00241	b9 01 00 00 00	 mov	 ecx, 1
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv152[rsp]
  00253	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00257	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR bioeend$[rsp]
  0025f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00264	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00269	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0026e	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv156[rsp]
  00275	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00279	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv160[rsp]
  00280	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170129
  0028b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170130
  00297	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170131
  002ae	ba 86 05 00 00	 mov	 edx, 1414		; 00000586H
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170132
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@s370_d250_:

; 1415 :       }
; 1416 :       if ( xcode )

  002c0	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  002c5	85 c0		 test	 eax, eax
  002c7	74 05		 je	 SHORT $LN15@s370_d250_

; 1417 :       {
; 1418 :          break;

  002c9	e9 f3 08 00 00	 jmp	 $LN3@s370_d250_
$LN15@s370_d250_:

; 1419 :       }
; 1420 : 
; 1421 :       /* Fetch the BIOE from storage */
; 1422 :       memcpy(&bioe,ioctl->regs->mainstor+bioebeg,sizeof(BIOE32));

  002ce	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  002d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d9	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002e0	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR bioe$[rsp]
  002e8	48 8b 54 24 68	 mov	 rdx, QWORD PTR bioebeg$[rsp]
  002ed	48 8b f9	 mov	 rdi, rcx
  002f0	48 8d 34 10	 lea	 rsi, QWORD PTR [rax+rdx]
  002f4	b9 10 00 00 00	 mov	 ecx, 16
  002f9	f3 a4		 rep movsb

; 1423 :       ARCH_DEP( or_storage_key )( bioebeg, STORKEY_REF );

  002fb	b2 04		 mov	 dl, 4
  002fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00302	e8 00 00 00 00	 call	 s370_or_storage_key

; 1424 :       ARCH_DEP( or_storage_key )( bioeend, STORKEY_REF );

  00307	b2 04		 mov	 dl, 4
  00309	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR bioeend$[rsp]
  00311	e8 00 00 00 00	 call	 s370_or_storage_key
$LN7@s370_d250_:

; 1425 : 
; 1426 :       /* Process a single BIOE */
; 1427 :       do
; 1428 :       {
; 1429 : 
; 1430 :          /* Make sure reserved field is zeros */
; 1431 :          if ( bioe.resv1[0]!=0x00 || bioe.resv1[1]!=0x00 )

  00316	b8 01 00 00 00	 mov	 eax, 1
  0031b	48 6b c0 00	 imul	 rax, rax, 0
  0031f	0f b6 84 04 fa
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp+rax+2]
  00327	85 c0		 test	 eax, eax
  00329	75 15		 jne	 SHORT $LN17@s370_d250_
  0032b	b8 01 00 00 00	 mov	 eax, 1
  00330	48 6b c0 01	 imul	 rax, rax, 1
  00334	0f b6 84 04 fa
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp+rax+2]
  0033c	85 c0		 test	 eax, eax
  0033e	74 0a		 je	 SHORT $LN16@s370_d250_
$LN17@s370_d250_:

; 1432 :          {
; 1433 :             status=BIOE_NOTZERO;

  00340	c6 44 24 60 0b	 mov	 BYTE PTR status$[rsp], 11

; 1434 :             continue;

  00345	e9 fd 05 00 00	 jmp	 $LN5@s370_d250_
$LN16@s370_d250_:

; 1435 :          }
; 1436 : 
; 1437 :          /* Fetch and validate block number */
; 1438 :          FETCH_FW(blknum,&bioe.blknum);

  0034a	48 8d 8c 24 fc
	00 00 00	 lea	 rcx, QWORD PTR bioe$[rsp+4]
  00352	e8 00 00 00 00	 call	 fetch_fw_noswap
  00357	8b c8		 mov	 ecx, eax
  00359	e8 00 00 00 00	 call	 _byteswap_ulong
  0035e	89 44 24 78	 mov	 DWORD PTR blknum$[rsp], eax

; 1439 :          if ( (blknum < ioctl->dev->vmd250env->begblk) ||

  00362	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  00367	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0036f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00373	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0037a	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]
  0037e	7c 1e		 jl	 SHORT $LN19@s370_d250_
  00380	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  00385	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0038d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00391	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  00398	48 3b 41 20	 cmp	 rax, QWORD PTR [rcx+32]
  0039c	7e 0a		 jle	 SHORT $LN18@s370_d250_
$LN19@s370_d250_:

; 1440 :               (blknum > ioctl->dev->vmd250env->endblk)
; 1441 :             )
; 1442 :          {
; 1443 :             status=BIOE_BADBLOCK;

  0039e	c6 44 24 60 01	 mov	 BYTE PTR status$[rsp], 1

; 1444 :             continue;

  003a3	e9 9f 05 00 00	 jmp	 $LN5@s370_d250_
$LN18@s370_d250_:

; 1445 :          }
; 1446 : 
; 1447 :          /* Fetch the storage address used for I/O */
; 1448 :          FETCH_FW(bufbeg,&bioe.bufaddr);

  003a8	48 8d 8c 24 04
	01 00 00	 lea	 rcx, QWORD PTR bioe$[rsp+12]
  003b0	e8 00 00 00 00	 call	 fetch_fw_noswap
  003b5	8b c8		 mov	 ecx, eax
  003b7	e8 00 00 00 00	 call	 _byteswap_ulong
  003bc	8b c0		 mov	 eax, eax
  003be	48 89 44 24 70	 mov	 QWORD PTR bufbeg$[rsp], rax

; 1449 :          bufbeg &= AMASK31;

  003c3	48 8b 44 24 70	 mov	 rax, QWORD PTR bufbeg$[rsp]
  003c8	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  003ce	48 89 44 24 70	 mov	 QWORD PTR bufbeg$[rsp], rax

; 1450 : 
; 1451 :          /* Ensure the environment still exists */
; 1452 :          if (!ioctl->dev->vmd250env)

  003d3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  003db	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003df	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  003e7	75 20		 jne	 SHORT $LN20@s370_d250_

; 1453 :          {
; 1454 :             d250_restore(ioctl->dev);

  003e9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  003f1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003f5	e8 00 00 00 00	 call	 d250_restore

; 1455 :             /* Note: the device lock is now released */
; 1456 :             status=BIOE_ABORTED;

  003fa	c6 44 24 60 0c	 mov	 BYTE PTR status$[rsp], 12

; 1457 :             return PSC_REMOVED;

  003ff	b8 03 00 00 00	 mov	 eax, 3
  00404	e9 2a 08 00 00	 jmp	 $LN1@s370_d250_
$LN20@s370_d250_:

; 1458 :          }
; 1459 : 
; 1460 :          /* The I/O handler routines are normally called without the  */
; 1461 :          /* device lock being held.  The device is reserved by the    */
; 1462 :          /* busy status.                                              */
; 1463 : 
; 1464 :          /* Determine the last byte of the I/O buffer */
; 1465 :          bufend=( bufbeg + ioctl->dev->vmd250env->blksiz -1 ) & AMASK31 ;

  00409	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00411	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00415	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0041c	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00420	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00425	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0042a	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  00430	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR bufend$[rsp], rax

; 1466 : 
; 1467 :          if (ioctl->dev->ccwtrace)

  00438	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00440	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00444	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0044a	c1 e8 0f	 shr	 eax, 15
  0044d	83 e0 01	 and	 eax, 1
  00450	85 c0		 test	 eax, eax
  00452	0f 84 9f 00 00
	00		 je	 $LN21@s370_d250_

; 1468 :          {
; 1469 :             WRMSG (HHC01930, "I",

  00458	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  00460	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv234[rsp], eax
  00467	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  0046f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00473	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00477	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv239[rsp], ecx
  0047e	b9 01 00 00 00	 mov	 ecx, 1
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00489	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  0048e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00493	8b 4c 24 78	 mov	 ecx, DWORD PTR blknum$[rsp]
  00497	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0049b	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv234[rsp]
  004a2	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  004ab	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004b0	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv239[rsp]
  004b7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170140
  004c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170141
  004ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  004de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170142
  004e5	ba c3 05 00 00	 mov	 edx, 1475		; 000005c3H
  004ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170143
  004f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@s370_d250_:

; 1470 :                      ioctl->dev->devnum,
; 1471 :                      bioebeg,
; 1472 :                      bioe.type,
; 1473 :                      blknum,
; 1474 :                      bufbeg
; 1475 :                     );
; 1476 :          }
; 1477 : 
; 1478 :          /* Determine the physical block on the device relative to zero */
; 1479 :          physblk=(S64)blknum+ioctl->dev->vmd250env->offset-1;

  004f7	48 63 44 24 78	 movsxd	 rax, DWORD PTR blknum$[rsp]
  004fc	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00504	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00508	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0050f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00513	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00518	89 84 24 90 00
	00 00		 mov	 DWORD PTR physblk$[rsp], eax

; 1480 :          /* The read/write routines will convert this to a physical disk */
; 1481 :          /* location for reading or writing                              */
; 1482 : 
; 1483 :          if (bioe.type == BIOE_READ)

  0051f	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  00527	83 f8 02	 cmp	 eax, 2
  0052a	0f 85 f2 01 00
	00		 jne	 $LN22@s370_d250_

; 1484 :          {
; 1485 :             xcode=ARCH_DEP(d250_addrck)

  00530	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00538	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0053b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00540	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00548	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  0054d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00553	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufend$[rsp]
  0055b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00560	e8 00 00 00 00	 call	 s370_d250_addrck
  00565	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1486 :                   (bufbeg,bufend,ACCTYPE_READ,ioctl->key,ioctl->regs);
; 1487 :             if (ioctl->dev->ccwtrace)

  0056a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00572	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00576	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0057c	c1 e8 0f	 shr	 eax, 15
  0057f	83 e0 01	 and	 eax, 1
  00582	85 c0		 test	 eax, eax
  00584	0f 84 b5 00 00
	00		 je	 $LN24@s370_d250_

; 1488 :             {
; 1489 :                WRMSG(HHC01931, "I",

  0058a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00592	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00596	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv273[rsp], eax
  0059d	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  005a2	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv277[rsp], ecx
  005a9	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  005b1	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  005b5	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  005b9	89 94 24 bc 00
	00 00		 mov	 DWORD PTR tv281[rsp], edx
  005c0	b9 01 00 00 00	 mov	 ecx, 1
  005c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005cb	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  005d2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  005d6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  005de	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  005e8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005ed	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv277[rsp]
  005f4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005f8	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  005ff	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00603	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170147
  0060a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0060f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170148
  00616	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0061b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00620	41 b9 03 00 00
	00		 mov	 r9d, 3
  00626	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170149
  0062d	ba d2 05 00 00	 mov	 edx, 1490		; 000005d2H
  00632	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170150
  00639	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@s370_d250_:

; 1490 :                        ioctl->dev->devnum,xcode,bufbeg,bufend,ioctl->key);
; 1491 :             }
; 1492 :             switch ( xcode )

  0063f	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00644	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv293[rsp], eax
  0064b	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR tv293[rsp], 4
  00653	74 16		 je	 SHORT $LN26@s370_d250_
  00655	83 bc 24 88 00
	00 00 05	 cmp	 DWORD PTR tv293[rsp], 5
  0065d	74 02		 je	 SHORT $LN25@s370_d250_
  0065f	eb 14		 jmp	 SHORT $LN8@s370_d250_
$LN25@s370_d250_:

; 1493 :             {
; 1494 :                case PGM_ADDRESSING_EXCEPTION:
; 1495 :                   status=BIOE_ADDREXC;

  00661	c6 44 24 60 02	 mov	 BYTE PTR status$[rsp], 2

; 1496 :                   continue;

  00666	e9 dc 02 00 00	 jmp	 $LN5@s370_d250_
$LN26@s370_d250_:

; 1497 :                case PGM_PROTECTION_EXCEPTION:
; 1498 :                   status=BIOE_PROTEXC;

  0066b	c6 44 24 60 07	 mov	 BYTE PTR status$[rsp], 7

; 1499 :                   continue;

  00670	e9 d2 02 00 00	 jmp	 $LN5@s370_d250_
$LN8@s370_d250_:

; 1500 :             }
; 1501 :             /* At this point, the block number has been validated */
; 1502 :             /* and the buffer is addressable and accessible       */
; 1503 :             status=d250_read(ioctl->dev,

  00675	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0067d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00680	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00687	48 03 44 24 70	 add	 rax, QWORD PTR bufbeg$[rsp]
  0068c	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00694	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00698	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  0069f	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR physblk$[rsp]
  006a7	4c 8b c8	 mov	 r9, rax
  006aa	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  006ae	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  006b6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  006ba	e8 00 00 00 00	 call	 d250_read
  006bf	88 44 24 60	 mov	 BYTE PTR status$[rsp], al

; 1504 :                                physblk,
; 1505 :                                ioctl->dev->vmd250env->blksiz,
; 1506 :                                ioctl->regs->mainstor+bufbeg);
; 1507 : 
; 1508 :             /* Set I/O storage key references if successful */
; 1509 :             if (!status)

  006c3	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  006c8	85 c0		 test	 eax, eax
  006ca	75 4c		 jne	 SHORT $LN27@s370_d250_

; 1510 :             {
; 1511 :                ARCH_DEP( or_storage_key )( bufbeg, STORKEY_REF );

  006cc	b2 04		 mov	 dl, 4
  006ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  006d3	e8 00 00 00 00	 call	 s370_or_storage_key

; 1512 :                ARCH_DEP( or_storage_key )( bufend, STORKEY_REF );

  006d8	b2 04		 mov	 dl, 4
  006da	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  006e2	e8 00 00 00 00	 call	 s370_or_storage_key

; 1513 : 
; 1514 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1515 :                if ( ioctl->dev->vmd250env->blksiz == 4096 )

  006e7	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  006ef	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  006f3	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  006fa	81 78 08 00 10
	00 00		 cmp	 DWORD PTR [rax+8], 4096	; 00001000H
  00701	75 15		 jne	 SHORT $LN28@s370_d250_

; 1516 :                {
; 1517 :                   ARCH_DEP( or_storage_key )( bufbeg+2048, STORKEY_REF );

  00703	48 8b 44 24 70	 mov	 rax, QWORD PTR bufbeg$[rsp]
  00708	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  0070e	b2 04		 mov	 dl, 4
  00710	48 8b c8	 mov	 rcx, rax
  00713	e8 00 00 00 00	 call	 s370_or_storage_key
$LN28@s370_d250_:
$LN27@s370_d250_:

; 1518 :                }
; 1519 : #endif
; 1520 :             }
; 1521 : 
; 1522 :             continue;

  00718	e9 2a 02 00 00	 jmp	 $LN5@s370_d250_

; 1523 :          }  /* end of BIOE_READ */

  0071d	e9 25 02 00 00	 jmp	 $LN23@s370_d250_
$LN22@s370_d250_:

; 1524 :          else
; 1525 :          {  if (bioe.type == BIOE_WRITE)

  00722	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bioe$[rsp]
  0072a	83 f8 01	 cmp	 eax, 1
  0072d	0f 85 0f 02 00
	00		 jne	 $LN29@s370_d250_

; 1526 :             {
; 1527 :                xcode=ARCH_DEP(d250_addrck)

  00733	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0073b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0073e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00743	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  0074b	44 0f b6 48 20	 movzx	 r9d, BYTE PTR [rax+32]
  00750	41 b8 02 00 00
	00		 mov	 r8d, 2
  00756	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufend$[rsp]
  0075e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  00763	e8 00 00 00 00	 call	 s370_d250_addrck
  00768	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1528 :                      (bufbeg,bufend,ACCTYPE_WRITE,ioctl->key,ioctl->regs);
; 1529 :                if (ioctl->dev->ccwtrace)

  0076d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00775	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00779	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0077f	c1 e8 0f	 shr	 eax, 15
  00782	83 e0 01	 and	 eax, 1
  00785	85 c0		 test	 eax, eax
  00787	0f 84 b5 00 00
	00		 je	 $LN31@s370_d250_

; 1530 :                {
; 1531 :                   WRMSG(HHC01932, "I",

  0078d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00795	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00799	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv339[rsp], eax
  007a0	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  007a5	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv343[rsp], ecx
  007ac	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  007b4	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  007b8	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  007bc	89 94 24 c8 00
	00 00		 mov	 DWORD PTR tv347[rsp], edx
  007c3	b9 01 00 00 00	 mov	 ecx, 1
  007c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007ce	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv339[rsp]
  007d5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  007d9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  007e1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  007eb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007f0	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv343[rsp]
  007f7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007fb	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv347[rsp]
  00802	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00806	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170158
  0080d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00812	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170159
  00819	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0081e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00823	41 b9 03 00 00
	00		 mov	 r9d, 3
  00829	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170160
  00830	ba ff 05 00 00	 mov	 edx, 1535		; 000005ffH
  00835	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170161
  0083c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@s370_d250_:

; 1532 :                            ioctl->dev->devnum,
; 1533 :                            xcode,bufbeg,
; 1534 :                            bufend,
; 1535 :                            ioctl->key);
; 1536 :                }
; 1537 : 
; 1538 :                switch ( xcode )

  00842	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00847	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv359[rsp], eax
  0084e	83 bc 24 8c 00
	00 00 04	 cmp	 DWORD PTR tv359[rsp], 4
  00856	74 16		 je	 SHORT $LN33@s370_d250_
  00858	83 bc 24 8c 00
	00 00 05	 cmp	 DWORD PTR tv359[rsp], 5
  00860	74 02		 je	 SHORT $LN32@s370_d250_
  00862	eb 14		 jmp	 SHORT $LN10@s370_d250_
$LN32@s370_d250_:

; 1539 :                {
; 1540 :                   case PGM_ADDRESSING_EXCEPTION:
; 1541 :                      status=BIOE_ADDREXC;

  00864	c6 44 24 60 02	 mov	 BYTE PTR status$[rsp], 2

; 1542 :                      continue;

  00869	e9 d9 00 00 00	 jmp	 $LN5@s370_d250_
$LN33@s370_d250_:

; 1543 :                   case PGM_PROTECTION_EXCEPTION:
; 1544 :                      status=BIOE_PROTEXC;

  0086e	c6 44 24 60 07	 mov	 BYTE PTR status$[rsp], 7

; 1545 :                      continue;

  00873	e9 cf 00 00 00	 jmp	 $LN5@s370_d250_
$LN10@s370_d250_:

; 1546 :                }
; 1547 : 
; 1548 :                if (ioctl->dev->vmd250env->isRO)

  00878	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00880	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00884	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0088b	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0088f	74 0a		 je	 SHORT $LN34@s370_d250_

; 1549 :                {
; 1550 :                   status=BIOE_DASDRO;

  00891	c6 44 24 60 03	 mov	 BYTE PTR status$[rsp], 3

; 1551 :                   continue;

  00896	e9 ac 00 00 00	 jmp	 $LN5@s370_d250_
$LN34@s370_d250_:

; 1552 :                }
; 1553 :                status=d250_write(ioctl->dev,

  0089b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  008a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008a6	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  008ad	48 03 44 24 70	 add	 rax, QWORD PTR bufbeg$[rsp]
  008b2	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  008ba	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  008be	48 8b 89 18 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1560]
  008c5	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR physblk$[rsp]
  008cd	4c 8b c8	 mov	 r9, rax
  008d0	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  008d4	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  008dc	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  008e0	e8 00 00 00 00	 call	 d250_write
  008e5	88 44 24 60	 mov	 BYTE PTR status$[rsp], al

; 1554 :                                    physblk,
; 1555 :                                    ioctl->dev->vmd250env->blksiz,
; 1556 :                                    ioctl->regs->mainstor+bufbeg);
; 1557 : 
; 1558 :                /* Set I/O storage key references if good I/O */
; 1559 :                if (!status)

  008e9	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  008ee	85 c0		 test	 eax, eax
  008f0	75 4c		 jne	 SHORT $LN35@s370_d250_

; 1560 :                {
; 1561 :                   ARCH_DEP( or_storage_key )( bufbeg, (STORKEY_REF | STORKEY_CHANGE) );

  008f2	b2 06		 mov	 dl, 6
  008f4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufbeg$[rsp]
  008f9	e8 00 00 00 00	 call	 s370_or_storage_key

; 1562 :                   ARCH_DEP( or_storage_key )( bufend, (STORKEY_REF | STORKEY_CHANGE) );

  008fe	b2 06		 mov	 dl, 6
  00900	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bufend$[rsp]
  00908	e8 00 00 00 00	 call	 s370_or_storage_key

; 1563 : #if defined(FEATURE_2K_STORAGE_KEYS)
; 1564 :                   if ( ioctl->dev->vmd250env->blksiz == 4096 )

  0090d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00915	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00919	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  00920	81 78 08 00 10
	00 00		 cmp	 DWORD PTR [rax+8], 4096	; 00001000H
  00927	75 15		 jne	 SHORT $LN36@s370_d250_

; 1565 :                   {
; 1566 :                      ARCH_DEP( or_storage_key )( bufbeg+2048, (STORKEY_REF | STORKEY_CHANGE) );

  00929	48 8b 44 24 70	 mov	 rax, QWORD PTR bufbeg$[rsp]
  0092e	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00934	b2 06		 mov	 dl, 6
  00936	48 8b c8	 mov	 rcx, rax
  00939	e8 00 00 00 00	 call	 s370_or_storage_key
$LN36@s370_d250_:
$LN35@s370_d250_:

; 1567 :                   }
; 1568 : #endif
; 1569 :                }
; 1570 : 
; 1571 :                continue;

  0093e	eb 07		 jmp	 SHORT $LN5@s370_d250_

; 1572 :             } /* end of if BIOE_WRITE */

  00940	eb 05		 jmp	 SHORT $LN30@s370_d250_
$LN29@s370_d250_:

; 1573 :             else
; 1574 :             {
; 1575 :                status=BIOE_BADREQ;

  00942	c6 44 24 60 06	 mov	 BYTE PTR status$[rsp], 6
$LN30@s370_d250_:
$LN23@s370_d250_:
$LN5@s370_d250_:

; 1576 :                continue;
; 1577 :             } /* end of else BIOE_WRITE */
; 1578 :          } /* end of else BIOE_READ */
; 1579 :       }while(0); /* end of do */

  00947	33 c0		 xor	 eax, eax
  00949	85 c0		 test	 eax, eax
  0094b	0f 85 c5 f9 ff
	ff		 jne	 $LN7@s370_d250_

; 1580 : 
; 1581 :       /* Determine if we can store the status in the BIOE */
; 1582 :       xcode=ARCH_DEP(d250_addrck)

  00951	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00956	48 ff c0	 inc	 rax
  00959	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  0095e	48 ff c1	 inc	 rcx
  00961	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00969	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0096c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00971	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ioctl$[rsp]
  00979	44 0f b6 4a 20	 movzx	 r9d, BYTE PTR [rdx+32]
  0097e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00984	48 8b d0	 mov	 rdx, rax
  00987	e8 00 00 00 00	 call	 s370_d250_addrck
  0098c	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 1583 :             (bioebeg+1,bioebeg+1,ACCTYPE_WRITE,ioctl->key,ioctl->regs);
; 1584 :       if (ioctl->dev->ccwtrace)

  00991	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00999	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0099d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  009a3	c1 e8 0f	 shr	 eax, 15
  009a6	83 e0 01	 and	 eax, 1
  009a9	85 c0		 test	 eax, eax
  009ab	0f 84 bc 00 00
	00		 je	 $LN37@s370_d250_

; 1585 :       {
; 1586 :          WRMSG(HHC01933, "I",

  009b1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  009b9	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  009bd	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv410[rsp], eax
  009c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  009c9	48 ff c1	 inc	 rcx
  009cc	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv412[rsp], rcx
  009d4	48 8b 54 24 68	 mov	 rdx, QWORD PTR bioebeg$[rsp]
  009d9	48 ff c2	 inc	 rdx
  009dc	48 89 94 24 f0
	00 00 00	 mov	 QWORD PTR tv414[rsp], rdx
  009e4	0f b7 7c 24 64	 movzx	 edi, WORD PTR xcode$[rsp]
  009e9	48 8b b4 24 30
	01 00 00	 mov	 rsi, QWORD PTR ioctl$[rsp]
  009f1	48 8b 76 08	 mov	 rsi, QWORD PTR [rsi+8]
  009f5	0f b7 76 48	 movzx	 esi, WORD PTR [rsi+72]
  009f9	b9 01 00 00 00	 mov	 ecx, 1
  009fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a04	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv410[rsp]
  00a0b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00a0f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv412[rsp]
  00a17	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a1c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv414[rsp]
  00a24	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a29	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00a2d	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  00a31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170168
  00a38	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170169
  00a44	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a49	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a4e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a54	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170170
  00a5b	ba 33 06 00 00	 mov	 edx, 1587		; 00000633H
  00a60	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170171
  00a67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN37@s370_d250_:

; 1587 :                   ioctl->dev->devnum,xcode,bioebeg+1,bioebeg+1,ioctl->key);
; 1588 :       }
; 1589 : 
; 1590 :       /* If the status byte is store protected, give up on processing any */
; 1591 :       /* more BIOE's.  Leave the BIOE list process for loop               */
; 1592 :       if ( xcode )

  00a6d	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00a72	85 c0		 test	 eax, eax
  00a74	74 05		 je	 SHORT $LN38@s370_d250_

; 1593 :       {
; 1594 :          break;

  00a76	e9 46 01 00 00	 jmp	 $LN3@s370_d250_
$LN38@s370_d250_:

; 1595 :       }
; 1596 : 
; 1597 :       /* Store the status in the BIOE */
; 1598 :       memcpy(ioctl->regs->mainstor+bioebeg+1,&status,1);

  00a7b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00a83	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a86	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00a8d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00a92	0f b6 54 24 60	 movzx	 edx, BYTE PTR status$[rsp]
  00a97	88 54 08 01	 mov	 BYTE PTR [rax+rcx+1], dl

; 1599 : 
; 1600 :       /* Set the storage key change bit */
; 1601 :       ARCH_DEP( or_storage_key )( bioebeg+1, (STORKEY_REF | STORKEY_CHANGE) );

  00a9b	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00aa0	48 ff c0	 inc	 rax
  00aa3	b2 06		 mov	 dl, 6
  00aa5	48 8b c8	 mov	 rcx, rax
  00aa8	e8 00 00 00 00	 call	 s370_or_storage_key

; 1602 : 
; 1603 :       if (ioctl->dev->ccwtrace)

  00aad	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00ab5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00ab9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00abf	c1 e8 0f	 shr	 eax, 15
  00ac2	83 e0 01	 and	 eax, 1
  00ac5	85 c0		 test	 eax, eax
  00ac7	0f 84 8a 00 00
	00		 je	 $LN39@s370_d250_

; 1604 :       {
; 1605 :          WRMSG (HHC01934, "I", ioctl->dev->devnum,bioebeg,status);

  00acd	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00ad2	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv452[rsp], eax
  00ad9	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00ae1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00ae5	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00ae9	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv457[rsp], ecx
  00af0	b9 01 00 00 00	 mov	 ecx, 1
  00af5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00afb	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv452[rsp]
  00b02	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00b06	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioebeg$[rsp]
  00b0b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00b10	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv457[rsp]
  00b17	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170174
  00b22	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b27	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170175
  00b2e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b33	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b38	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b3e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170176
  00b45	ba 45 06 00 00	 mov	 edx, 1605		; 00000645H
  00b4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170177
  00b51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN39@s370_d250_:

; 1606 :       }
; 1607 : 
; 1608 :       /* Count if this BIOE was a success or failure */
; 1609 :       if ( status )

  00b57	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00b5c	85 c0		 test	 eax, eax
  00b5e	74 26		 je	 SHORT $LN40@s370_d250_

; 1610 :       {
; 1611 :          ioctl->badblks+=1;

  00b60	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b68	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b6b	ff c0		 inc	 eax
  00b6d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00b75	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1612 :          if ( status == BIOE_ABORTED )

  00b78	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00b7d	83 f8 0c	 cmp	 eax, 12
  00b80	75 02		 jne	 SHORT $LN42@s370_d250_

; 1613 :          {
; 1614 :              break;

  00b82	eb 3d		 jmp	 SHORT $LN3@s370_d250_
$LN42@s370_d250_:

; 1615 :          }
; 1616 :       }

  00b84	eb 18		 jmp	 SHORT $LN41@s370_d250_
$LN40@s370_d250_:

; 1617 :       else
; 1618 :       {
; 1619 :          ioctl->goodblks+=1;

  00b86	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00b8e	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00b91	ff c0		 inc	 eax
  00b93	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioctl$[rsp]
  00b9b	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN41@s370_d250_:

; 1620 :       }
; 1621 : 
; 1622 :       /* Determine the address of the next BIOE */
; 1623 :       bioebeg += sizeof(BIOE32);

  00b9e	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00ba3	48 83 c0 10	 add	 rax, 16
  00ba7	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1624 :       bioebeg &= AMASK31;

  00bac	48 8b 44 24 68	 mov	 rax, QWORD PTR bioebeg$[rsp]
  00bb1	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  00bb7	48 89 44 24 68	 mov	 QWORD PTR bioebeg$[rsp], rax

; 1625 :    } /* end of for loop */

  00bbc	e9 b9 f5 ff ff	 jmp	 $LN2@s370_d250_
$LN3@s370_d250_:

; 1626 : 
; 1627 : #if 0
; 1628 :    LOGMSG( "(d250_list32) BIOE's processed: %d\n", block );
; 1629 : #endif
; 1630 : 
; 1631 :    /* Restore device to guest ownership */
; 1632 :    d250_restore(ioctl->dev);

  00bc1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00bc9	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00bcd	e8 00 00 00 00	 call	 d250_restore

; 1633 :    /* Note: device lock not held */
; 1634 : 
; 1635 :    /* If an access exception occurred:                                 */
; 1636 :    /*   If this is a synchronous request, generate a program exception */
; 1637 :    /*   or if this is asynchrnous, just return with a storage error    */
; 1638 :    if ( xcode )

  00bd2	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00bd7	85 c0		 test	 eax, eax
  00bd9	74 2a		 je	 SHORT $LN43@s370_d250_

; 1639 :    {
; 1640 :       if (async)

  00bdb	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR async$[rsp], 0
  00be3	74 09		 je	 SHORT $LN44@s370_d250_

; 1641 :           return PSC_STGERR;

  00be5	b8 02 00 00 00	 mov	 eax, 2
  00bea	eb 47		 jmp	 SHORT $LN1@s370_d250_
  00bec	eb 17		 jmp	 SHORT $LN45@s370_d250_
$LN44@s370_d250_:

; 1642 :       else
; 1643 :           ARCH_DEP(program_interrupt)(ioctl->regs, xcode);

  00bee	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00bf3	8b d0		 mov	 edx, eax
  00bf5	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00bfd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00c00	e8 00 00 00 00	 call	 s370_program_interrupt
$LN45@s370_d250_:
$LN43@s370_d250_:

; 1644 :    }
; 1645 : 
; 1646 :    if ( status == BIOE_ABORTED )

  00c05	0f b6 44 24 60	 movzx	 eax, BYTE PTR status$[rsp]
  00c0a	83 f8 0c	 cmp	 eax, 12
  00c0d	75 07		 jne	 SHORT $LN46@s370_d250_

; 1647 :    {
; 1648 :       return PSC_REMOVED;

  00c0f	b8 03 00 00 00	 mov	 eax, 3
  00c14	eb 1d		 jmp	 SHORT $LN1@s370_d250_
$LN46@s370_d250_:

; 1649 :    }
; 1650 : 
; 1651 :    /* Determine if we were completely successful or only partially     */
; 1652 :    /* successful.  'Partial' includes none successful.                 */
; 1653 :    /* Synchronous and asynchronous requests handle all failed          */
; 1654 :    /* differently. The good and bad blocks field are used by the       */
; 1655 :    /* caller                                                           */
; 1656 :    if (ioctl->goodblks < blocks)

  00c16	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR ioctl$[rsp]
  00c1e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR blocks$[rsp]
  00c25	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  00c28	7d 07		 jge	 SHORT $LN47@s370_d250_

; 1657 :    {
; 1658 :       return PSC_PARTIAL;

  00c2a	b8 01 00 00 00	 mov	 eax, 1
  00c2f	eb 02		 jmp	 SHORT $LN1@s370_d250_
$LN47@s370_d250_:

; 1659 :    }
; 1660 :    return PSC_SUCCESS;

  00c31	33 c0		 xor	 eax, eax
$LN1@s370_d250_:

; 1661 : 
; 1662 : } /* end function d250_list32 */

  00c33	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c3b	48 33 cc	 xor	 rcx, rsp
  00c3e	e8 00 00 00 00	 call	 __security_check_cookie
  00c43	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00c4a	5f		 pop	 rdi
  00c4b	5e		 pop	 rsi
  00c4c	c3		 ret	 0
s370_d250_list32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
psc$ = 96
tv289 = 100
rc2$ = 104
tv164 = 108
tv169 = 112
tv248 = 116
tv253 = 120
tv274 = 124
tv277 = 128
tv291 = 132
asyncp$ = 136
ioctl$ = 144
$T1 = 192
tid$ = 200
tv186 = 208
tv229 = 216
bioplx00$ = 224
tname$ = 288
buf$2 = 320
__$ArrayPad$ = 360
dev$ = 400
rc$ = 408
biopl$ = 416
regs$ = 424
s370_d250_iorq32 PROC

; 1176 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1177 : BIOPL_IORQ32   bioplx00;  /* Used to check reserved fields */
; 1178 : IOCTL32 ioctl;            /* Request information */
; 1179 : BYTE    psc;              /* List processing status code */
; 1180 : 
; 1181 : /* Asynchronous request related fields */
; 1182 : TID     tid;         /* Asynchronous thread ID */
; 1183 : char    tname[32];   /* Thread name */
; 1184 : IOCTL32 *asyncp;     /* Pointer to async thread's storage */
; 1185 : int     rc2;
; 1186 : 
; 1187 :    /* Clear the reserved BIOPL */
; 1188 :    memset(&bioplx00,0,sizeof(BIOPL_IORQ32));

  0002f	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR bioplx00$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00041	f3 aa		 rep stosb

; 1189 : 
; 1190 :    /* Make sure reserved fields and bits are binary zeros  */
; 1191 :    if ((memcmp(&biopl->resv1,&bioplx00,IORQ32R1_LEN)!=0) ||
; 1192 :        (memcmp(&biopl->resv2,&bioplx00,IORQ32R2_LEN)!=0) ||
; 1193 :        (memcmp(&biopl->resv3,&bioplx00,IORQ32R3_LEN)!=0) ||
; 1194 :        (biopl->flags & BIOPL_FLAGSRSV) ||

  00043	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  0004b	48 83 c0 03	 add	 rax, 3
  0004f	41 b8 15 00 00
	00		 mov	 r8d, 21
  00055	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 memcmp
  00065	85 c0		 test	 eax, eax
  00067	75 74		 jne	 SHORT $LN5@s370_d250_
  00069	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00071	48 83 c0 1a	 add	 rax, 26
  00075	41 b8 02 00 00
	00		 mov	 r8d, 2
  0007b	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 memcmp
  0008b	85 c0		 test	 eax, eax
  0008d	75 4e		 jne	 SHORT $LN5@s370_d250_
  0008f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00097	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0009b	41 b8 14 00 00
	00		 mov	 r8d, 20
  000a1	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 memcmp
  000b1	85 c0		 test	 eax, eax
  000b3	75 28		 jne	 SHORT $LN5@s370_d250_
  000b5	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000bd	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  000c1	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  000c6	85 c0		 test	 eax, eax
  000c8	75 13		 jne	 SHORT $LN5@s370_d250_
  000ca	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000d2	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  000d6	83 e0 0f	 and	 eax, 15
  000d9	85 c0		 test	 eax, eax
  000db	74 12		 je	 SHORT $LN4@s370_d250_
$LN5@s370_d250_:

; 1195 :        (biopl->key & BIOPL_KEYRSV)
; 1196 :       )
; 1197 :    {
; 1198 :        ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000dd	ba 06 00 00 00	 mov	 edx, 6
  000e2	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	e8 00 00 00 00	 call	 s370_program_interrupt
$LN4@s370_d250_:

; 1199 :    }
; 1200 : 
; 1201 :    /* Return with an error return code if the device does not exist */
; 1202 :    if (!dev)

  000ef	48 83 bc 24 90
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f8	75 18		 jne	 SHORT $LN6@s370_d250_

; 1203 :    {
; 1204 :       *rc = RC_NODEV;  /* Set the return code for no device */

  000fa	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00102	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 1205 :       return CC_FAILED; /* Indicate the function failed     */

  00108	b8 02 00 00 00	 mov	 eax, 2
  0010d	e9 7e 06 00 00	 jmp	 $LN1@s370_d250_
$LN6@s370_d250_:

; 1206 :    }
; 1207 : 
; 1208 :    /* If no environment, return with an error */
; 1209 :    if (!(dev->vmd250env))

  00112	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011a	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  00122	75 18		 jne	 SHORT $LN7@s370_d250_

; 1210 :    {
; 1211 :       *rc = RC_STATERR;

  00124	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0012c	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 1212 :       return CC_FAILED;

  00132	b8 02 00 00 00	 mov	 eax, 2
  00137	e9 54 06 00 00	 jmp	 $LN1@s370_d250_
$LN7@s370_d250_:

; 1213 :    }
; 1214 : 
; 1215 :    /* Fetch the block count from the BIOPL */
; 1216 :    FETCH_FW(ioctl.blkcount,&biopl->blkcount);

  0013c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00144	48 83 c0 1c	 add	 rax, 28
  00148	48 8b c8	 mov	 rcx, rax
  0014b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00150	8b c8		 mov	 ecx, eax
  00152	e8 00 00 00 00	 call	 _byteswap_ulong
  00157	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+24], eax

; 1217 : 
; 1218 :    /* Block count must be between 1 and 256, inclusive */
; 1219 :    if ((ioctl.blkcount<1) || (ioctl.blkcount>256))

  0015e	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR ioctl$[rsp+24], 1
  00166	7c 0d		 jl	 SHORT $LN9@s370_d250_
  00168	81 bc 24 a8 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR ioctl$[rsp+24], 256 ; 00000100H
  00173	7e 18		 jle	 SHORT $LN8@s370_d250_
$LN9@s370_d250_:

; 1220 :    {
; 1221 :        *rc = RC_CNT_ERR;

  00175	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0017d	c7 00 24 00 00
	00		 mov	 DWORD PTR [rax], 36	; 00000024H

; 1222 :        return CC_FAILED;

  00183	b8 02 00 00 00	 mov	 eax, 2
  00188	e9 03 06 00 00	 jmp	 $LN1@s370_d250_
$LN8@s370_d250_:

; 1223 :    }
; 1224 : 
; 1225 :    /* Fetch the address of the BIO entry list from the BIOPL */
; 1226 :    FETCH_FW(ioctl.listaddr,&biopl->bioeladr);

  0018d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00195	48 83 c0 24	 add	 rax, 36			; 00000024H
  00199	48 8b c8	 mov	 rcx, rax
  0019c	e8 00 00 00 00	 call	 fetch_fw_noswap
  001a1	8b c8		 mov	 ecx, eax
  001a3	e8 00 00 00 00	 call	 _byteswap_ulong
  001a8	89 84 24 ac 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+28], eax

; 1227 : 
; 1228 :    /* Extract the storage key from the BIOPL */
; 1229 :    ioctl.key=biopl->key;

  001af	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  001b7	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  001bb	88 84 24 b0 00
	00 00		 mov	 BYTE PTR ioctl$[rsp+32], al

; 1230 : 
; 1231 :    /* Set the structures that are involved in this request */
; 1232 :    ioctl.dev = dev;

  001c2	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR ioctl$[rsp+8], rax

; 1233 :    ioctl.regs = regs;

  001d2	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001da	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ioctl$[rsp], rax

; 1234 : 
; 1235 :    /* Set I/O success/failure counts to zero */
; 1236 :    ioctl.goodblks = 0;

  001e2	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ioctl$[rsp+36], 0

; 1237 :    ioctl.badblks = 0;

  001ed	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ioctl$[rsp+40], 0

; 1238 : 
; 1239 :    if (biopl->flags & BIOPL_ASYNC)

  001f8	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00200	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00204	83 e0 02	 and	 eax, 2
  00207	85 c0		 test	 eax, eax
  00209	0f 84 2a 03 00
	00		 je	 $LN10@s370_d250_

; 1240 :    {
; 1241 :        /* Build the request structure */
; 1242 : 
; 1243 :        /* Extract the 32-bit interrupt parameter from the BIOPL */
; 1244 :        FETCH_FW(ioctl.intrparm,biopl->intparm);

  0020f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00217	48 83 c0 28	 add	 rax, 40			; 00000028H
  0021b	48 8b c8	 mov	 rcx, rax
  0021e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00223	8b c8		 mov	 ecx, eax
  00225	e8 00 00 00 00	 call	 _byteswap_ulong
  0022a	89 84 24 a4 00
	00 00		 mov	 DWORD PTR ioctl$[rsp+20], eax

; 1245 : 
; 1246 :        if (dev->ccwtrace)

  00231	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00239	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0023f	c1 e8 0f	 shr	 eax, 15
  00242	83 e0 01	 and	 eax, 1
  00245	85 c0		 test	 eax, eax
  00247	0f 84 94 00 00
	00		 je	 $LN12@s370_d250_

; 1247 :        {
; 1248 :           WRMSG(HHC01924, "I",

  0024d	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR ioctl$[rsp+32]
  00255	89 44 24 6c	 mov	 DWORD PTR tv164[rsp], eax
  00259	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00261	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00265	89 4c 24 70	 mov	 DWORD PTR tv169[rsp], ecx
  00269	b9 01 00 00 00	 mov	 ecx, 1
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00274	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+20]
  0027b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0027f	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv164[rsp]
  00283	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00287	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+24]
  0028e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00292	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+28]
  00299	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0029d	8b 4c 24 70	 mov	 ecx, DWORD PTR tv169[rsp]
  002a1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170052
  002ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170053
  002b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170054
  002cf	ba e5 04 00 00	 mov	 edx, 1253		; 000004e5H
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170055
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@s370_d250_:

; 1249 :                    dev->devnum,
; 1250 :                    ioctl.listaddr,
; 1251 :                    ioctl.blkcount,
; 1252 :                    ioctl.key,
; 1253 :                    ioctl.intrparm);
; 1254 :        }
; 1255 : 
; 1256 :        /* Set the default status code to an aborted list */
; 1257 :        /* Note: This should be set correctly from the returned PSC */
; 1258 :        ioctl.statuscod = PSC_STGERR;

  002e1	c6 84 24 a1 00
	00 00 02	 mov	 BYTE PTR ioctl$[rsp+17], 2

; 1259 : 
; 1260 :        /* Get the storage for the thread's parameters */
; 1261 :        if (!(asyncp=(IOCTL32 *)malloc(sizeof(IOCTL32))))

  002e9	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  002f4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR asyncp$[rsp], rax
  002fc	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR asyncp$[rsp], 0
  00305	0f 85 af 00 00
	00		 jne	 $LN13@s370_d250_

; 1262 :        {
; 1263 :           char buf[40];
; 1264 :           MSGBUF(buf, "malloc(%d)", (int)sizeof(IOCTL32));

  0030b	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00311	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170057
  00318	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0031d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1265 :           WRMSG (HHC01908, "E", buf, strerror(errno));

  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00331	8b 08		 mov	 ecx, DWORD PTR [rax]
  00333	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00339	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  00341	b9 01 00 00 00	 mov	 ecx, 1
  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv186[rsp]
  00354	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00359	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00361	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170058
  0036d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170059
  00379	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00383	41 b9 03 00 00
	00		 mov	 r9d, 3
  00389	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170060
  00390	ba f1 04 00 00	 mov	 edx, 1265		; 000004f1H
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170061
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1266 :           *rc = RC_ERROR;

  003a2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  003aa	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1267 :           return CC_FAILED;

  003b0	b8 02 00 00 00	 mov	 eax, 2
  003b5	e9 d6 03 00 00	 jmp	 $LN1@s370_d250_
$LN13@s370_d250_:

; 1268 :        }
; 1269 : 
; 1270 :        /* Copy the thread's parameters to its own storage */
; 1271 :        memcpy(asyncp,&ioctl,sizeof(IOCTL32));

  003ba	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ioctl$[rsp]
  003c2	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR asyncp$[rsp]
  003ca	48 8b f0	 mov	 rsi, rax
  003cd	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  003d2	f3 a4		 rep movsb

; 1272 : 
; 1273 :        /* Launch the asynchronous request on a separate thread */
; 1274 :        MSGBUF(tname,"d250_async %4.4X",dev->devnum);

  003d4	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003e0	44 8b c8	 mov	 r9d, eax
  003e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170062
  003ea	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  003ef	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tname$[rsp]
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1275 :        tname[sizeof(tname)-1]=0;

  003fd	b8 01 00 00 00	 mov	 eax, 1
  00402	48 6b c0 1f	 imul	 rax, rax, 31
  00406	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  0040e	48 83 bc 24 c0
	00 00 00 20	 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  00417	73 02		 jae	 SHORT $LN24@s370_d250_
  00419	eb 05		 jmp	 SHORT $LN25@s370_d250_
$LN24@s370_d250_:
  0041b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN25@s370_d250_:
  00420	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00428	c6 84 04 20 01
	00 00 00	 mov	 BYTE PTR tname$[rsp+rax], 0

; 1276 :        rc2 = create_thread (&tid, DETACHED, ARCH_DEP(d250_async32),

  00430	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00437	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0043d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170063
  00444	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00449	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR tname$[rsp]
  00451	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00456	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR asyncp$[rsp]
  0045e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:s370_d250_async32
  00465	48 8b d0	 mov	 rdx, rax
  00468	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  00470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00476	89 44 24 68	 mov	 DWORD PTR rc2$[rsp], eax

; 1277 :                asyncp, tname);
; 1278 :        if(rc2)

  0047a	83 7c 24 68 00	 cmp	 DWORD PTR rc2$[rsp], 0
  0047f	0f 84 9a 00 00
	00		 je	 $LN14@s370_d250_

; 1279 :        {
; 1280 :           WRMSG (HHC00102, "E", strerror(rc2));

  00485	8b 4c 24 68	 mov	 ecx, DWORD PTR rc2$[rsp]
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0048f	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
  00497	b9 01 00 00 00	 mov	 ecx, 1
  0049c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004a2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv229[rsp]
  004aa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170065
  004b6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170066
  004c2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004cc	41 b9 03 00 00
	00		 mov	 r9d, 3
  004d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170067
  004d9	ba 00 05 00 00	 mov	 edx, 1280		; 00000500H
  004de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170068
  004e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1281 :           release_lock (&dev->lock);

  004eb	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f3	48 83 c0 38	 add	 rax, 56			; 00000038H
  004f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170069
  004fe	48 8b c8	 mov	 rcx, rax
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1282 :           *rc = RC_ERROR;

  00507	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0050f	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1283 :           return CC_FAILED;

  00515	b8 02 00 00 00	 mov	 eax, 2
  0051a	e9 71 02 00 00	 jmp	 $LN1@s370_d250_
$LN14@s370_d250_:

; 1284 :        }
; 1285 :        /* Launched the async request successfully */
; 1286 :        *rc = RC_ASYNC;

  0051f	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00527	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 1287 :        return CC_SUCCESS;

  0052d	33 c0		 xor	 eax, eax
  0052f	e9 5c 02 00 00	 jmp	 $LN1@s370_d250_

; 1288 :    }

  00534	e9 60 01 00 00	 jmp	 $LN11@s370_d250_
$LN10@s370_d250_:

; 1289 :    else
; 1290 :    {
; 1291 :        /* Perform the I/O request synchronously on this thread */
; 1292 :        /* Call the 32-bit BIOE request processor */
; 1293 :        if (dev->ccwtrace)

  00539	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00541	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00547	c1 e8 0f	 shr	 eax, 15
  0054a	83 e0 01	 and	 eax, 1
  0054d	85 c0		 test	 eax, eax
  0054f	0f 84 89 00 00
	00		 je	 $LN15@s370_d250_

; 1294 :        {
; 1295 :           WRMSG(HHC01925, "I",

  00555	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR ioctl$[rsp+32]
  0055d	89 44 24 74	 mov	 DWORD PTR tv248[rsp], eax
  00561	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00569	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0056d	89 4c 24 78	 mov	 DWORD PTR tv253[rsp], ecx
  00571	b9 01 00 00 00	 mov	 ecx, 1
  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv248[rsp]
  00580	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00584	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+24]
  0058b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0058f	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+28]
  00596	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0059a	8b 4c 24 78	 mov	 ecx, DWORD PTR tv253[rsp]
  0059e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170071
  005a9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170072
  005b5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005bf	41 b9 03 00 00
	00		 mov	 r9d, 3
  005c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170073
  005cc	ba 13 05 00 00	 mov	 edx, 1299		; 00000513H
  005d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170074
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@s370_d250_:

; 1296 :                    dev->devnum,
; 1297 :                    ioctl.listaddr,
; 1298 :                    ioctl.blkcount,
; 1299 :                    ioctl.key);
; 1300 :        }
; 1301 : 
; 1302 :        psc=ARCH_DEP(d250_list32)(&ioctl, SYNC);

  005de	33 d2		 xor	 edx, edx
  005e0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR ioctl$[rsp]
  005e8	e8 00 00 00 00	 call	 s370_d250_list32
  005ed	88 44 24 60	 mov	 BYTE PTR psc$[rsp], al

; 1303 : 
; 1304 :        if (dev->ccwtrace)

  005f1	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005ff	c1 e8 0f	 shr	 eax, 15
  00602	83 e0 01	 and	 eax, 1
  00605	85 c0		 test	 eax, eax
  00607	0f 84 8c 00 00
	00		 je	 $LN16@s370_d250_

; 1305 :        {
; 1306 :           WRMSG(HHC01926, "I", dev->devnum,psc,ioctl.goodblks,ioctl.badblks);

  0060d	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  00612	89 44 24 7c	 mov	 DWORD PTR tv274[rsp], eax
  00616	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0061e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00622	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv277[rsp], ecx
  00629	b9 01 00 00 00	 mov	 ecx, 1
  0062e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00634	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+40]
  0063b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0063f	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR ioctl$[rsp+36]
  00646	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0064a	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv274[rsp]
  0064e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00652	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv277[rsp]
  00659	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0065d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170076
  00664	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00669	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170077
  00670	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00675	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0067a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00680	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170078
  00687	ba 1a 05 00 00	 mov	 edx, 1306		; 0000051aH
  0068c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170079
  00693	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@s370_d250_:
$LN11@s370_d250_:

; 1307 :        }
; 1308 : 
; 1309 :    }
; 1310 : 
; 1311 :    /* Processor status used to determine return and condition codes */
; 1312 :    switch(psc)

  00699	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  0069e	88 44 24 64	 mov	 BYTE PTR tv289[rsp], al
  006a2	80 7c 24 64 00	 cmp	 BYTE PTR tv289[rsp], 0
  006a7	74 10		 je	 SHORT $LN17@s370_d250_
  006a9	80 7c 24 64 01	 cmp	 BYTE PTR tv289[rsp], 1
  006ae	74 1e		 je	 SHORT $LN18@s370_d250_
  006b0	80 7c 24 64 03	 cmp	 BYTE PTR tv289[rsp], 3
  006b5	74 53		 je	 SHORT $LN21@s370_d250_
  006b7	eb 66		 jmp	 SHORT $LN22@s370_d250_
$LN17@s370_d250_:

; 1313 :    {
; 1314 :       case PSC_SUCCESS:
; 1315 :          *rc = RC_SUCCESS;

  006b9	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006c1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1316 :          return CC_SUCCESS;

  006c7	33 c0		 xor	 eax, eax
  006c9	e9 c2 00 00 00	 jmp	 $LN1@s370_d250_
$LN18@s370_d250_:

; 1317 :       case PSC_PARTIAL:
; 1318 :          if (ioctl.goodblks == 0)

  006ce	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR ioctl$[rsp+36], 0
  006d6	75 1a		 jne	 SHORT $LN19@s370_d250_

; 1319 :          {
; 1320 :             *rc = RC_ALL_BAD;

  006d8	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006e0	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 1321 :             return CC_FAILED;

  006e6	b8 02 00 00 00	 mov	 eax, 2
  006eb	e9 a0 00 00 00	 jmp	 $LN1@s370_d250_

; 1322 :          }

  006f0	eb 18		 jmp	 SHORT $LN20@s370_d250_
$LN19@s370_d250_:

; 1323 :          else
; 1324 :          {
; 1325 :             *rc = RC_SYN_PART;

  006f2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  006fa	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 1326 :             return CC_PARTIAL;

  00700	b8 01 00 00 00	 mov	 eax, 1
  00705	e9 86 00 00 00	 jmp	 $LN1@s370_d250_
$LN20@s370_d250_:
$LN21@s370_d250_:

; 1327 :          }
; 1328 :       case PSC_REMOVED:
; 1329 :          *rc = RC_REM_PART;

  0070a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00712	c7 00 2c 00 00
	00		 mov	 DWORD PTR [rax], 44	; 0000002cH

; 1330 :          return CC_PARTIAL;

  00718	b8 01 00 00 00	 mov	 eax, 1
  0071d	eb 71		 jmp	 SHORT $LN1@s370_d250_
$LN22@s370_d250_:

; 1331 :       default:
; 1332 :          WRMSG (HHC01927, "I", psc);

  0071f	0f b6 44 24 60	 movzx	 eax, BYTE PTR psc$[rsp]
  00724	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv291[rsp], eax
  0072b	b9 01 00 00 00	 mov	 ecx, 1
  00730	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00736	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  0073d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00741	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170086
  00748	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0074d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170087
  00754	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00759	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0075e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00764	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170088
  0076b	ba 34 05 00 00	 mov	 edx, 1332		; 00000534H
  00770	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170089
  00777	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1333 :          *rc = RC_ERROR;

  0077d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00785	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 1334 :          return CC_FAILED;

  0078b	b8 02 00 00 00	 mov	 eax, 2
$LN1@s370_d250_:
$LN23@s370_d250_:

; 1335 :    }
; 1336 : 
; 1337 : } /* end function ARCH_DEP(d250_iorq32) */

  00790	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00798	48 33 cc	 xor	 rcx, rsp
  0079b	e8 00 00 00 00	 call	 __security_check_cookie
  007a0	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  007a7	5f		 pop	 rdi
  007a8	5e		 pop	 rsi
  007a9	c3		 ret	 0
s370_d250_iorq32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
i$1 = 96
tv160 = 100
tv163 = 104
tv168 = 108
tv172 = 112
mask$2 = 120
dev$ = 144
intparm$ = 152
status$ = 160
subcode$ = 168
d250_bio_interrupt PROC

; 356  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 357  : 
; 358  :    OBTAIN_INTLOCK(NULL);

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169716
  00022	33 c9		 xor	 ecx, ecx
  00024	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN2@d250_bio_i:

; 359  : 
; 360  :    /* This is inspired by sclp_attn_thread function in service.c */
; 361  :    /* Make sure a service signal interrupt is not pending */
; 362  :    while(IS_IC_SERVSIG)

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00036	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0003b	85 c0		 test	 eax, eax
  0003d	74 24		 je	 SHORT $LN3@d250_bio_i

; 363  :    {
; 364  :        RELEASE_INTLOCK(NULL);

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169717
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 365  :        sched_yield();

  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 366  :        OBTAIN_INTLOCK(NULL);

  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169718
  0005a	33 c9		 xor	 ecx, ecx
  0005c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 367  :    }

  00061	eb c6		 jmp	 SHORT $LN2@d250_bio_i
$LN3@d250_bio_i:

; 368  : 
; 369  :    /* Can now safely store my interrupt information */
; 370  :    sysblk.bioparm  = intparm;   /* Trigger with the interrupt parameter */

  00063	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR intparm$[rsp]
  00072	48 89 88 70 12
	00 00		 mov	 QWORD PTR [rax+4720], rcx

; 371  :    sysblk.biostat  = status;    /* Trigger with the status */

  00079	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00080	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR status$[rsp]
  00088	88 88 6b 12 00
	00		 mov	 BYTE PTR [rax+4715], cl

; 372  :    sysblk.biosubcd = subcode;   /* Trigger with the subcode */

  0008e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00095	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR subcode$[rsp]
  0009d	88 88 6a 12 00
	00		 mov	 BYTE PTR [rax+4714], cl

; 373  :    sysblk.biodev   = dev;       /* Trigger for this device  */

  000a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000aa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b2	48 89 88 78 12
	00 00		 mov	 QWORD PTR [rax+4728], rcx

; 374  :    sysblk.servcode = EXT_BLOCKIO_INTERRUPT;

  000b9	b8 03 26 00 00	 mov	 eax, 9731		; 00002603H
  000be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c5	66 89 81 68 12
	00 00		 mov	 WORD PTR [rcx+4712], ax
$LN6@d250_bio_i:

; 375  : 
; 376  :    /* The Block I/O external interrupt is enabled by the same CR0 bit */
; 377  :    /* as are service signal interrupts.  This means the guest will    */
; 378  :    /* be interrupted when it has enabled service signals.  For this   */
; 379  :    /* reason the Block I/O is being treated like a service signal and */
; 380  :    /* handled by the service signal handling logic in external.c      */
; 381  : 
; 382  :    /* Make the "service signal" interrupt pending                     */
; 383  :    ON_IC_SERVSIG;

  000cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d3	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000d9	25 00 02 00 00	 and	 eax, 512		; 00000200H
  000de	85 c0		 test	 eax, eax
  000e0	0f 85 fc 00 00
	00		 jne	 $LN10@d250_bio_i
  000e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ed	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000f3	0f ba e8 09	 bts	 eax, 9
  000f7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000fe	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00104	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0010b	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00112	48 89 44 24 78	 mov	 QWORD PTR mask$2[rsp], rax
  00117	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0011f	eb 0a		 jmp	 SHORT $LN9@d250_bio_i
$LN7@d250_bio_i:
  00121	8b 44 24 60	 mov	 eax, DWORD PTR i$1[rsp]
  00125	ff c0		 inc	 eax
  00127	89 44 24 60	 mov	 DWORD PTR i$1[rsp], eax
$LN9@d250_bio_i:
  0012b	48 83 7c 24 78
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  00131	0f 84 ab 00 00
	00		 je	 $LN8@d250_bio_i
  00137	48 8b 44 24 78	 mov	 rax, QWORD PTR mask$2[rsp]
  0013c	48 83 e0 01	 and	 rax, 1
  00140	48 85 c0	 test	 rax, rax
  00143	0f 84 87 00 00
	00		 je	 $LN11@d250_bio_i
  00149	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$1[rsp]
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00155	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0015d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00160	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00165	85 c0		 test	 eax, eax
  00167	74 35		 je	 SHORT $LN12@d250_bio_i
  00169	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$1[rsp]
  0016e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00175	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0017d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00180	0d 00 02 00 80	 or	 eax, -2147483136	; 80000200H
  00185	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0018a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00191	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00199	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0019c	eb 32		 jmp	 SHORT $LN13@d250_bio_i
$LN12@d250_bio_i:
  0019e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$1[rsp]
  001a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001aa	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001b2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001b5	0f ba e8 09	 bts	 eax, 9
  001b9	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  001be	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001c5	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  001cd	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN13@d250_bio_i:
$LN11@d250_bio_i:
  001d0	48 8b 44 24 78	 mov	 rax, QWORD PTR mask$2[rsp]
  001d5	48 d1 e8	 shr	 rax, 1
  001d8	48 89 44 24 78	 mov	 QWORD PTR mask$2[rsp], rax
  001dd	e9 3f ff ff ff	 jmp	 $LN7@d250_bio_i
$LN8@d250_bio_i:
$LN10@d250_bio_i:
  001e2	33 c0		 xor	 eax, eax
  001e4	85 c0		 test	 eax, eax
  001e6	0f 85 e0 fe ff
	ff		 jne	 $LN6@d250_bio_i

; 384  :    /* Wake up any waiters */
; 385  :    WAKEUP_CPUS_MASK (sysblk.waiting_mask);

  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169723
  001f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001fa	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  00201	e8 00 00 00 00	 call	 wakeup_cpus_mask

; 386  : 
; 387  :    if (dev->ccwtrace)

  00206	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00214	c1 e8 0f	 shr	 eax, 15
  00217	83 e0 01	 and	 eax, 1
  0021a	85 c0		 test	 eax, eax
  0021c	0f 84 c8 00 00
	00		 je	 $LN14@d250_bio_i

; 388  :    {
; 389  :       WRMSG (HHC01905, "I",

  00222	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00229	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  00230	89 44 24 64	 mov	 DWORD PTR tv160[rsp], eax
  00234	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0023b	0f b6 89 6b 12
	00 00		 movzx	 ecx, BYTE PTR [rcx+4715]
  00242	89 4c 24 68	 mov	 DWORD PTR tv163[rsp], ecx
  00246	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0024d	0f b7 92 68 12
	00 00		 movzx	 edx, WORD PTR [rdx+4712]
  00254	89 54 24 6c	 mov	 DWORD PTR tv168[rsp], edx
  00258	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0025f	4d 8b 80 78 12
	00 00		 mov	 r8, QWORD PTR [r8+4728]
  00266	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  0026b	44 89 44 24 70	 mov	 DWORD PTR tv172[rsp], r8d
  00270	b9 01 00 00 00	 mov	 ecx, 1
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0027b	8b 4c 24 64	 mov	 ecx, DWORD PTR tv160[rsp]
  0027f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00283	8b 4c 24 68	 mov	 ecx, DWORD PTR tv163[rsp]
  00287	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0028b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00292	48 8b 89 70 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4720]
  00299	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0029e	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv168[rsp]
  002a2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a6	8b 4c 24 70	 mov	 ecx, DWORD PTR tv172[rsp]
  002aa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169725
  002b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169726
  002c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169727
  002d8	ba 8b 01 00 00	 mov	 edx, 395		; 0000018bH
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169728
  002e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@d250_bio_i:

; 390  :               sysblk.biodev->devnum,
; 391  :               sysblk.servcode,
; 392  :               sysblk.bioparm,
; 393  :               sysblk.biostat,
; 394  :               sysblk.biosubcd
; 395  :            );
; 396  :    }
; 397  : 
; 398  :    /* Free the interrupt lock */
; 399  :    RELEASE_INTLOCK(NULL);

  002ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169729
  002f1	33 c9		 xor	 ecx, ecx
  002f3	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 400  : }

  002f8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002ff	c3		 ret	 0
d250_bio_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
cc$ = 64
tv144 = 68
bioenv$ = 72
bioplx00$ = 80
__$ArrayPad$ = 144
dev$ = 192
rc$ = 200
biopl$ = 208
regs$ = 216
d250_remove PROC

; 764  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 765  : BIOPL_REMOVE bioplx00;               /* Use to check reserved fields */
; 766  : struct VMBIOENV *bioenv;             /* -->allocated environement    */
; 767  : int       cc;                        /* Condition code to return     */
; 768  : 
; 769  :    /* Clear the reserved BIOPL */
; 770  :    memset(&bioplx00,0,sizeof(BIOPL_REMOVE));

  0002f	48 8d 44 24 50	 lea	 rax, QWORD PTR bioplx00$[rsp]
  00034	48 8b f8	 mov	 rdi, rax
  00037	33 c0		 xor	 eax, eax
  00039	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0003e	f3 aa		 rep stosb

; 771  : 
; 772  : 
; 773  :    /* Make sure reserved fields are binary zeros  */
; 774  :    if (memcmp(&biopl->resv1,&bioplx00,REMOVER1_LEN)!=0)

  00040	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00048	48 83 c0 02	 add	 rax, 2
  0004c	41 b8 3e 00 00
	00		 mov	 r8d, 62			; 0000003eH
  00052	48 8d 54 24 50	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 memcmp
  0005f	85 c0		 test	 eax, eax
  00061	74 12		 je	 SHORT $LN2@d250_remov

; 775  :    {
; 776  :        ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00063	ba 06 00 00 00	 mov	 edx, 6
  00068	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	e8 00 00 00 00	 call	 s370_program_interrupt
$LN2@d250_remov:

; 777  :    }
; 778  : 
; 779  :    /* Return with an error if the device does not exist */
; 780  :    if (!dev)

  00075	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0007e	75 18		 jne	 SHORT $LN3@d250_remov

; 781  :    {
; 782  :       *rc = RC_NODEV;  /* Set the return code for no device */

  00080	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00088	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 783  :       return CC_FAILED; /* Indicate the function failed     */

  0008e	b8 02 00 00 00	 mov	 eax, 2
  00093	e9 85 01 00 00	 jmp	 $LN1@d250_remov
$LN3@d250_remov:

; 784  :    }
; 785  : 
; 786  :    /* Attach the environment to the DEVBLK */
; 787  :    /* Lock the DEVBLK in case another CPU is trying something */
; 788  :    obtain_lock (&dev->lock);

  00098	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a0	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169890
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 789  :    bioenv=dev->vmd250env;

  000b4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000bc	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  000c3	48 89 44 24 48	 mov	 QWORD PTR bioenv$[rsp], rax

; 790  :    if (dev->vmd250env == NULL)

  000c8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d0	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  000d8	75 37		 jne	 SHORT $LN4@d250_remov

; 791  :    {
; 792  :        /* If an environment does not exist, it should be */
; 793  :        /* Return the environment state error return code */
; 794  :        /* and failed condition code                      */
; 795  :        release_lock (&dev->lock);

  000da	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	48 83 c0 38	 add	 rax, 56			; 00000038H
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169893
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 796  :        *rc = RC_STATERR;

  000f6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  000fe	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 797  :        cc = CC_FAILED;

  00104	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 798  :    }

  0010c	e9 08 01 00 00	 jmp	 $LN5@d250_remov
$LN4@d250_remov:

; 799  :    else
; 800  :    {
; 801  :        /*   1. Restore pending sense, if any                     */
; 802  :        /*   2. Free the environment previously established       */
; 803  :        /*   3. Set the device environment pointer to NULL,       */
; 804  :        /*      telling others that the environment doesn't exist */
; 805  :        /*   4. Release the device block                          */
; 806  :        /*   5. Free the environment previously established       */
; 807  :        /*   6. Return successful return and condition codes      */
; 808  :        if (dev->sns_pending)

  00111	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00119	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  0011f	c1 e8 02	 shr	 eax, 2
  00122	83 e0 01	 and	 eax, 1
  00125	85 c0		 test	 eax, eax
  00127	74 29		 je	 SHORT $LN6@d250_remov

; 809  :        {
; 810  :            memcpy(&dev->sense,dev->vmd250env->sense,sizeof(dev->sense));

  00129	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00131	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  00138	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00140	48 8d b9 64 03
	00 00		 lea	 rdi, QWORD PTR [rcx+868]
  00147	48 8d 70 34	 lea	 rsi, QWORD PTR [rax+52]
  0014b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00150	f3 a4		 rep movsb
$LN6@d250_remov:

; 811  :        }
; 812  :        dev->vmd250env = NULL ;

  00152	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015a	48 c7 80 18 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1560], 0

; 813  :        /* No need to hold the device lock while freeing the environment */
; 814  :        release_lock (&dev->lock);

  00165	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0016d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169895
  00178	48 8b c8	 mov	 rcx, rax
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 815  :        free(bioenv);

  00181	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bioenv$[rsp]
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 816  :        if (dev->ccwtrace)

  0018c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00194	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0019a	c1 e8 0f	 shr	 eax, 15
  0019d	83 e0 01	 and	 eax, 1
  001a0	85 c0		 test	 eax, eax
  001a2	74 5f		 je	 SHORT $LN7@d250_remov

; 817  :        {
; 818  :            WRMSG(HHC01921, "I", dev->devnum);

  001a4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ac	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001b0	89 44 24 44	 mov	 DWORD PTR tv144[rsp], eax
  001b4	b9 01 00 00 00	 mov	 ecx, 1
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bf	8b 4c 24 44	 mov	 ecx, DWORD PTR tv144[rsp]
  001c3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169897
  001ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169898
  001da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169899
  001f1	ba 32 03 00 00	 mov	 edx, 818		; 00000332H
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169900
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@d250_remov:

; 819  :        }
; 820  :        *rc = RC_SUCCESS;

  00203	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0020b	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 821  :        cc = CC_SUCCESS ; /* Set that the function has succeeded */

  00211	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN5@d250_remov:

; 822  :    }
; 823  :    return cc ;

  00219	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
$LN1@d250_remov:

; 824  : } /* end function d250_remove */

  0021d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00225	48 33 cc	 xor	 rcx, rsp
  00228	e8 00 00 00 00	 call	 __security_check_cookie
  0022d	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00234	5f		 pop	 rdi
  00235	5e		 pop	 rsi
  00236	c3		 ret	 0
d250_remove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
unitstat$ = 80
residual$ = 84
tv74 = 88
tv148 = 92
tv151 = 96
dev$ = 128
pblknum$ = 136
blksize$ = 144
buffer$ = 152
d250_write PROC

; 896  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 897  : BYTE unitstat;     /* Device unit status */
; 898  : U32  residual;     /* Residual byte count */
; 899  : 
; 900  :     obtain_lock(&dev->lock);

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00020	48 83 c0 38	 add	 rax, 56			; 00000038H
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169946
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 901  :     if (dev->ccwtrace)

  00034	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00042	c1 e8 0f	 shr	 eax, 15
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 77		 je	 SHORT $LN2@d250_write

; 902  :     {
; 903  :        WRMSG(HHC01922, "I", dev->devnum, blksize, pblknum);

  0004c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00054	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00058	89 44 24 58	 mov	 DWORD PTR tv74[rsp], eax
  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00067	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pblknum$[rsp]
  0006f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00074	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  0007b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0007f	8b 4c 24 58	 mov	 ecx, DWORD PTR tv74[rsp]
  00083	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169948
  0008e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169949
  0009a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169950
  000b1	ba 87 03 00 00	 mov	 edx, 903		; 00000387H
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169951
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@d250_write:

; 904  :     }
; 905  : 
; 906  :     if (!dev->vmd250env)

  000c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  000d3	75 26		 jne	 SHORT $LN3@d250_write

; 907  :     {
; 908  :        release_lock(&dev->lock);

  000d5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	48 83 c0 38	 add	 rax, 56			; 00000038H
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169953
  000e8	48 8b c8	 mov	 rcx, rax
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 909  :        return BIOE_ABORTED;

  000f1	b8 0c 00 00 00	 mov	 eax, 12
  000f6	e9 c3 01 00 00	 jmp	 $LN1@d250_write
$LN3@d250_write:

; 910  :     }
; 911  :     if (dev->vmd250env->isCKD)

  000fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00103	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0010a	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0010e	74 2b		 je	 SHORT $LN4@d250_write

; 912  :     {
; 913  :         release_lock(&dev->lock);

  00110	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00118	48 83 c0 38	 add	 rax, 56			; 00000038H
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169956
  00123	48 8b c8	 mov	 rcx, rax
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 914  :         /* Do CKD I/O */
; 915  : 
; 916  :         /* CKD to be supplied */
; 917  : 
; 918  :         return BIOE_IOERROR;

  0012c	b8 05 00 00 00	 mov	 eax, 5
  00131	e9 88 01 00 00	 jmp	 $LN1@d250_write

; 919  :     }

  00136	e9 62 01 00 00	 jmp	 $LN5@d250_write
$LN4@d250_write:

; 920  :     else
; 921  :     {
; 922  :        /* Do FBA I/O */
; 923  : 
; 924  :        /* Call the I/O start exit */
; 925  :        if (dev->hnd->start) (dev->hnd->start) (dev);

  0013b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00143	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0014a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0014f	74 1a		 je	 SHORT $LN6@d250_write
  00151	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00159	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00160	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00168	ff 50 28	 call	 QWORD PTR [rax+40]
$LN6@d250_write:

; 926  : 
; 927  :        unitstat = 0;

  0016b	c6 44 24 50 00	 mov	 BYTE PTR unitstat$[rsp], 0

; 928  : 
; 929  :        /* Call the FBA driver's write standard block routine */
; 930  :        fbadasd_write_block(dev, (int)pblknum, (int)blksize,

  00170	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00178	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  0017f	48 8d 4c 24 54	 lea	 rcx, QWORD PTR residual$[rsp]
  00184	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00189	48 8d 4c 24 50	 lea	 rcx, QWORD PTR unitstat$[rsp]
  0018e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00193	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0019b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001a0	44 8b 48 30	 mov	 r9d, DWORD PTR [rax+48]
  001a4	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR blksize$[rsp]
  001ac	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR pblknum$[rsp]
  001b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fbadasd_write_block

; 931  :                            dev->vmd250env->blkphys,
; 932  :                            buffer, &unitstat, &residual );
; 933  :        if (dev->ccwtrace)

  001c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001cf	c1 e8 0f	 shr	 eax, 15
  001d2	83 e0 01	 and	 eax, 1
  001d5	85 c0		 test	 eax, eax
  001d7	74 78		 je	 SHORT $LN7@d250_write

; 934  :        {
; 935  :           WRMSG(HHC01923, "I", dev->devnum, unitstat, residual );

  001d9	0f b6 44 24 50	 movzx	 eax, BYTE PTR unitstat$[rsp]
  001de	89 44 24 5c	 mov	 DWORD PTR tv148[rsp], eax
  001e2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ea	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001ee	89 4c 24 60	 mov	 DWORD PTR tv151[rsp], ecx
  001f2	b9 01 00 00 00	 mov	 ecx, 1
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001fd	8b 4c 24 54	 mov	 ecx, DWORD PTR residual$[rsp]
  00201	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00205	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv148[rsp]
  00209	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0020d	8b 4c 24 60	 mov	 ecx, DWORD PTR tv151[rsp]
  00211	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169959
  0021c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169960
  00228	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0022d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00232	41 b9 03 00 00
	00		 mov	 r9d, 3
  00238	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169961
  0023f	ba a7 03 00 00	 mov	 edx, 935		; 000003a7H
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169962
  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@d250_write:

; 936  :        }
; 937  : 
; 938  :        /* Call the I/O end exit */
; 939  :        if (dev->hnd->end) (dev->hnd->end) (dev);

  00251	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00259	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00260	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00265	74 1a		 je	 SHORT $LN8@d250_write
  00267	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00276	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0027e	ff 50 30	 call	 QWORD PTR [rax+48]
$LN8@d250_write:

; 940  : 
; 941  :        release_lock(&dev->lock);

  00281	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00289	48 83 c0 38	 add	 rax, 56			; 00000038H
  0028d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169964
  00294	48 8b c8	 mov	 rcx, rax
  00297	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN5@d250_write:

; 942  :     }
; 943  : 
; 944  :     /* If an I/O error occurred, return status of 1 */
; 945  :     if ( unitstat != ( CSW_CE | CSW_DE ) )

  0029d	0f b6 44 24 50	 movzx	 eax, BYTE PTR unitstat$[rsp]
  002a2	83 f8 0c	 cmp	 eax, 12
  002a5	74 07		 je	 SHORT $LN9@d250_write

; 946  :     {
; 947  :        return BIOE_IOERROR;

  002a7	b8 05 00 00 00	 mov	 eax, 5
  002ac	eb 10		 jmp	 SHORT $LN1@d250_write
$LN9@d250_write:

; 948  :     }
; 949  : 
; 950  :     /* If there was a residual count, block size error, return status of 2 */
; 951  :     /* Note: This can only happen for CKD devices                          */
; 952  :     if ( residual != 0 )

  002ae	83 7c 24 54 00	 cmp	 DWORD PTR residual$[rsp], 0
  002b3	74 07		 je	 SHORT $LN10@d250_write

; 953  :     {
; 954  :        return BIOE_CKDRECL;

  002b5	b8 04 00 00 00	 mov	 eax, 4
  002ba	eb 02		 jmp	 SHORT $LN1@d250_write
$LN10@d250_write:

; 955  :     }
; 956  : 
; 957  :     /* Success! */
; 958  :     return BIOE_SUCCESS;

  002bc	33 c0		 xor	 eax, eax
$LN1@d250_write:

; 959  : }

  002be	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002c2	c3		 ret	 0
d250_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
unitstat$ = 80
residual$ = 84
tv74 = 88
tv143 = 92
tv146 = 96
dev$ = 128
pblknum$ = 136
blksize$ = 144
buffer$ = 152
d250_read PROC

; 830  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 831  : BYTE unitstat;     /* Device unit status */
; 832  : U32  residual;     /* Residual byte count */
; 833  : 
; 834  : /* Note: Not called with device lock held */
; 835  : 
; 836  :     obtain_lock(&dev->lock);

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00020	48 83 c0 38	 add	 rax, 56			; 00000038H
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169914
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 837  :     if (dev->ccwtrace)

  00034	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00042	c1 e8 0f	 shr	 eax, 15
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 77		 je	 SHORT $LN2@d250_read

; 838  :     {
; 839  :        WRMSG(HHC01922, "I", dev->devnum, blksize, pblknum);

  0004c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00054	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00058	89 44 24 58	 mov	 DWORD PTR tv74[rsp], eax
  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00067	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pblknum$[rsp]
  0006f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00074	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  0007b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0007f	8b 4c 24 58	 mov	 ecx, DWORD PTR tv74[rsp]
  00083	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169916
  0008e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169917
  0009a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169918
  000b1	ba 47 03 00 00	 mov	 edx, 839		; 00000347H
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169919
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@d250_read:

; 840  :     }
; 841  : 
; 842  :     if (dev->vmd250env->isCKD)

  000c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  000d2	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000d6	74 2b		 je	 SHORT $LN3@d250_read

; 843  :     {
; 844  :        release_lock(&dev->lock);

  000d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e0	48 83 c0 38	 add	 rax, 56			; 00000038H
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169922
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 845  :        /* Do CKD I/O */
; 846  : 
; 847  :        /* CKD to be supplied */
; 848  : 
; 849  :        return BIOE_IOERROR;

  000f4	b8 05 00 00 00	 mov	 eax, 5
  000f9	e9 88 01 00 00	 jmp	 $LN1@d250_read

; 850  :     }

  000fe	e9 62 01 00 00	 jmp	 $LN4@d250_read
$LN3@d250_read:

; 851  :     else
; 852  :     {
; 853  :        /* Do FBA I/O */
; 854  : 
; 855  :        /* Call the I/O start exit */
; 856  :        if (dev->hnd->start) (dev->hnd->start) (dev);

  00103	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010b	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00112	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00117	74 1a		 je	 SHORT $LN5@d250_read
  00119	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00121	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00128	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00130	ff 50 28	 call	 QWORD PTR [rax+40]
$LN5@d250_read:

; 857  : 
; 858  :        unitstat = 0;

  00133	c6 44 24 50 00	 mov	 BYTE PTR unitstat$[rsp], 0

; 859  : 
; 860  :        /* Call the FBA driver's read standard block routine */
; 861  :        fbadasd_read_block(dev, (int)pblknum, (int)blksize,

  00138	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00140	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  00147	48 8d 4c 24 54	 lea	 rcx, QWORD PTR residual$[rsp]
  0014c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00151	48 8d 4c 24 50	 lea	 rcx, QWORD PTR unitstat$[rsp]
  00156	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00163	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00168	44 8b 48 30	 mov	 r9d, DWORD PTR [rax+48]
  0016c	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR blksize$[rsp]
  00174	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR pblknum$[rsp]
  0017b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fbadasd_read_block

; 862  :                           dev->vmd250env->blkphys,
; 863  :                           buffer, &unitstat, &residual );
; 864  : 
; 865  :        if (dev->ccwtrace)

  00189	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00191	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00197	c1 e8 0f	 shr	 eax, 15
  0019a	83 e0 01	 and	 eax, 1
  0019d	85 c0		 test	 eax, eax
  0019f	74 78		 je	 SHORT $LN6@d250_read

; 866  :        {
; 867  :           WRMSG(HHC01923, "I", dev->devnum, unitstat, residual );

  001a1	0f b6 44 24 50	 movzx	 eax, BYTE PTR unitstat$[rsp]
  001a6	89 44 24 5c	 mov	 DWORD PTR tv143[rsp], eax
  001aa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001b2	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001b6	89 4c 24 60	 mov	 DWORD PTR tv146[rsp], ecx
  001ba	b9 01 00 00 00	 mov	 ecx, 1
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c5	8b 4c 24 54	 mov	 ecx, DWORD PTR residual$[rsp]
  001c9	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001cd	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv143[rsp]
  001d1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001d5	8b 4c 24 60	 mov	 ecx, DWORD PTR tv146[rsp]
  001d9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169925
  001e4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169926
  001f0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fa	41 b9 03 00 00
	00		 mov	 r9d, 3
  00200	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169927
  00207	ba 63 03 00 00	 mov	 edx, 867		; 00000363H
  0020c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169928
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@d250_read:

; 868  :        }
; 869  : 
; 870  :        /* Call the I/O end exit */
; 871  :        if (dev->hnd->end) (dev->hnd->end) (dev);

  00219	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00221	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00228	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0022d	74 1a		 je	 SHORT $LN7@d250_read
  0022f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00237	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0023e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00246	ff 50 30	 call	 QWORD PTR [rax+48]
$LN7@d250_read:

; 872  : 
; 873  :        release_lock(&dev->lock);

  00249	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00251	48 83 c0 38	 add	 rax, 56			; 00000038H
  00255	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169930
  0025c	48 8b c8	 mov	 rcx, rax
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN4@d250_read:

; 874  :     }
; 875  :     /* If an I/O error occurred, return status of I/O Error */
; 876  :     if ( unitstat != ( CSW_CE | CSW_DE ) )

  00265	0f b6 44 24 50	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0026a	83 f8 0c	 cmp	 eax, 12
  0026d	74 07		 je	 SHORT $LN8@d250_read

; 877  :     {
; 878  :        return BIOE_IOERROR;

  0026f	b8 05 00 00 00	 mov	 eax, 5
  00274	eb 10		 jmp	 SHORT $LN1@d250_read
$LN8@d250_read:

; 879  :     }
; 880  : 
; 881  :     /* If there was a residual count, block size error, return status of 2 */
; 882  :     /* Note: This can only happen for CKD devices                          */
; 883  :     if ( residual != 0 )

  00276	83 7c 24 54 00	 cmp	 DWORD PTR residual$[rsp], 0
  0027b	74 07		 je	 SHORT $LN9@d250_read

; 884  :     {
; 885  :        return BIOE_CKDRECL;

  0027d	b8 04 00 00 00	 mov	 eax, 4
  00282	eb 02		 jmp	 SHORT $LN1@d250_read
$LN9@d250_read:

; 886  :     }
; 887  : 
; 888  :     /* Success! return 0 status */
; 889  :     return BIOE_SUCCESS;

  00284	33 c0		 xor	 eax, eax
$LN1@d250_read:

; 890  : }

  00286	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0028a	c3		 ret	 0
d250_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
tv133 = 64
dev$ = 112
d250_restore PROC

; 734  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 735  :     obtain_lock(&dev->lock);

  0000b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00010	48 83 c0 38	 add	 rax, 56			; 00000038H
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169861
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 736  :     if (dev->hnd->release)

  00024	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00029	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00030	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00035	74 46		 je	 SHORT $LN2@d250_resto

; 737  :     {
; 738  :        release_lock(&dev->lock);

  00037	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169863
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 739  :        (dev->hnd->release)(dev);

  00050	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00055	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0005c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00061	ff 50 70	 call	 QWORD PTR [rax+112]

; 740  :        obtain_lock(&dev->lock);

  00064	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00069	48 83 c0 38	 add	 rax, 56			; 00000038H
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169864
  00074	48 8b c8	 mov	 rcx, rax
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@d250_resto:

; 741  :     }
; 742  :     /* Both fbadasd.c and ckddasd.c reset the local reserved flag     */
; 743  :     /* after calling the shared device client                         */
; 744  :     dev->reserved = 0;

  0007d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00082	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00088	0f ba f0 14	 btr	 eax, 20
  0008c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00091	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 745  :     if (dev->sns_pending)

  00097	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0009c	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  000a2	c1 e8 02	 shr	 eax, 2
  000a5	83 e0 01	 and	 eax, 1
  000a8	85 c0		 test	 eax, eax
  000aa	0f 84 94 00 00
	00		 je	 $LN3@d250_resto

; 746  :     {
; 747  :        /* Restore the pending sense */
; 748  :        memcpy(&dev->sense,&dev->vmd250env->sense,sizeof(dev->sense));

  000b0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000b5	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  000bc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000c1	48 8d b9 64 03
	00 00		 lea	 rdi, QWORD PTR [rcx+868]
  000c8	48 8d 70 34	 lea	 rsi, QWORD PTR [rax+52]
  000cc	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  000d1	f3 a4		 rep movsb

; 749  :        if (dev->ccwtrace)

  000d3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000d8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000de	c1 e8 0f	 shr	 eax, 15
  000e1	83 e0 01	 and	 eax, 1
  000e4	85 c0		 test	 eax, eax
  000e6	74 5c		 je	 SHORT $LN4@d250_resto

; 750  :        {  WRMSG (HHC01920, "I", dev->devnum);

  000e8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000ed	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000f1	89 44 24 40	 mov	 DWORD PTR tv133[rsp], eax
  000f5	b9 01 00 00 00	 mov	 ecx, 1
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00100	8b 4c 24 40	 mov	 ecx, DWORD PTR tv133[rsp]
  00104	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169867
  0010f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169868
  0011b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00120	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00125	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169869
  00132	ba ee 02 00 00	 mov	 edx, 750		; 000002eeH
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169870
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@d250_resto:
$LN3@d250_resto:

; 751  :        }
; 752  :     }
; 753  : #if defined( OPTION_SHARED_DEVICES )
; 754  :     dev->shioactive = DEV_SYS_NONE;

  00144	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00149	c7 80 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1508], 0

; 755  : #endif // defined( OPTION_SHARED_DEVICES )
; 756  :     dev->busy = 0;

  00153	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00158	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0015e	0f ba f0 13	 btr	 eax, 19
  00162	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00167	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 757  :     release_lock(&dev->lock);

  0016d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00172	48 83 c0 38	 add	 rax, 56			; 00000038H
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169871
  0017d	48 8b c8	 mov	 rcx, rax
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 758  : }

  00186	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018a	5f		 pop	 rdi
  0018b	5e		 pop	 rsi
  0018c	c3		 ret	 0
d250_restore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
tv94 = 64
dev$ = 112
d250_preserve PROC

; 693  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 694  :     obtain_lock(&dev->lock);

  0000b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00010	48 83 c0 38	 add	 rax, 56			; 00000038H
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169847
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 695  : 
; 696  : #if defined( OPTION_SHARED_DEVICES )
; 697  :     /* Wait for the device to become available      */
; 698  :     /* Note: this logic comes from the beginning of */
; 699  :     /* channel.c ARCH_DEP(execute_ccw_chain)        */
; 700  :     shared_iowait( dev );

  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00029	e8 00 00 00 00	 call	 shared_iowait

; 701  :     dev->shioactive = DEV_SYS_LOCAL;

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00033	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 702  : #endif // defined( OPTION_SHARED_DEVICES )
; 703  : 
; 704  :     dev->busy = 1;

  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00042	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00048	0f ba e8 13	 bts	 eax, 19
  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 705  :     dev->startpending = 0;

  00057	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0005c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00062	0f ba f0 19	 btr	 eax, 25
  00066	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0006b	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 706  :     if (dev->sns_pending)

  00071	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00076	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  0007c	c1 e8 02	 shr	 eax, 2
  0007f	83 e0 01	 and	 eax, 1
  00082	85 c0		 test	 eax, eax
  00084	0f 84 94 00 00
	00		 je	 $LN2@d250_prese

; 707  :     {
; 708  :        /* Save the pending sense */
; 709  :        memcpy(&dev->vmd250env->sense,&dev->sense,sizeof(dev->sense));

  0008a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0008f	48 8b 80 18 06
	00 00		 mov	 rax, QWORD PTR [rax+1560]
  00096	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0009b	48 8d 78 34	 lea	 rdi, QWORD PTR [rax+52]
  0009f	48 8d b1 64 03
	00 00		 lea	 rsi, QWORD PTR [rcx+868]
  000a6	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  000ab	f3 a4		 rep movsb

; 710  :        if (dev->ccwtrace)

  000ad	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000b2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000b8	c1 e8 0f	 shr	 eax, 15
  000bb	83 e0 01	 and	 eax, 1
  000be	85 c0		 test	 eax, eax
  000c0	74 5c		 je	 SHORT $LN3@d250_prese

; 711  :        {  WRMSG(HHC01909, "I", dev->devnum);

  000c2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000c7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000cb	89 44 24 40	 mov	 DWORD PTR tv94[rsp], eax
  000cf	b9 01 00 00 00	 mov	 ecx, 1
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000da	8b 4c 24 40	 mov	 ecx, DWORD PTR tv94[rsp]
  000de	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169850
  000e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169851
  000f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00105	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169852
  0010c	ba c7 02 00 00	 mov	 edx, 711		; 000002c7H
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169853
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@d250_prese:
$LN2@d250_prese:

; 712  :        }
; 713  :     }
; 714  : 
; 715  :     /* Both fbadasd.c and ckddasd.c set the local reserved flag before  */
; 716  :     /* calling the shared device client                                 */
; 717  :     dev->reserved = 1;

  0011e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00123	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00129	0f ba e8 14	 bts	 eax, 20
  0012d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00132	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 718  :     if (dev->hnd->reserve)

  00138	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0013d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00144	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00149	74 2f		 je	 SHORT $LN4@d250_prese

; 719  :     {
; 720  :        release_lock(&dev->lock);

  0014b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00150	48 83 c0 38	 add	 rax, 56			; 00000038H
  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169856
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 721  :        (dev->hnd->reserve)(dev);

  00164	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00169	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00170	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00175	ff 50 68	 call	 QWORD PTR [rax+104]

; 722  :     }

  00178	eb 19		 jmp	 SHORT $LN5@d250_prese
$LN4@d250_prese:

; 723  :     else
; 724  :     {
; 725  :        release_lock(&dev->lock);

  0017a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0017f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169857
  0018a	48 8b c8	 mov	 rcx, rax
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN5@d250_prese:

; 726  :     }
; 727  : }

  00193	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00197	5f		 pop	 rdi
  00198	5e		 pop	 rsi
  00199	c3		 ret	 0
d250_preserve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
bioenv$ = 112
blktab$ = 120
seccyl$ = 128
tv135 = 132
isRO$ = 136
numblks$ = 140
isCKD$ = 144
tv88 = 148
tv91 = 152
begblk$ = 156
endblk$ = 160
tv172 = 168
buf$1 = 176
__$ArrayPad$ = 216
dev$ = 240
blksize$ = 248
offset$ = 256
cc$ = 264
rc$ = 272
d250_init PROC

; 519  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 520  : int      isCKD;         /* Flag for CKD device                       */
; 521  : int      isRO;          /* Flag for readonly device                  */
; 522  : int      seccyl;/* Number of sectors/block or records/track for dev. */
; 523  : int      numblks;       /* Number of blocks on the device            */
; 524  : S32      begblk;        /* Starting block number                     */
; 525  : S32      endblk;        /* Ending block number                       */
; 526  : BLKTAB  *blktab;     /* Pointer to device std block-to-physical info */
; 527  : /* Established environement                                          */
; 528  : struct VMBIOENV *bioenv;  /* -->allocated environement               */
; 529  : 
; 530  :    /* Return with an error if the device does not exist */
; 531  :    if (!dev)

  0002c	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00035	75 23		 jne	 SHORT $LN4@d250_init

; 532  :    {
; 533  :       *rc = RC_NODEV;  /* Set the return code for no device */

  00037	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0003f	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 534  :       *cc = CC_FAILED; /* Indicate the function failed      */

  00045	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR cc$[rsp]
  0004d	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 535  :       return 0;

  00053	33 c0		 xor	 eax, eax
  00055	e9 e7 04 00 00	 jmp	 $LN1@d250_init
$LN4@d250_init:

; 536  :    }
; 537  : 
; 538  :    /* Look up the block-to-phyical mapping information */
; 539  :    blktab=dasd_lookup(DASD_STDBLK,NULL,(U32)dev->devtype,0);

  0005a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00062	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00066	45 33 c9	 xor	 r9d, r9d
  00069	44 8b c0	 mov	 r8d, eax
  0006c	33 d2		 xor	 edx, edx
  0006e	b9 04 00 00 00	 mov	 ecx, 4
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  00079	48 89 44 24 78	 mov	 QWORD PTR blktab$[rsp], rax

; 540  :    if (!blktab)

  0007e	48 83 7c 24 78
	00		 cmp	 QWORD PTR blktab$[rsp], 0
  00084	75 23		 jne	 SHORT $LN5@d250_init

; 541  :    {
; 542  :        *rc = RC_NOSUPP; /* Set the return code for unsuppored device */

  00086	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  0008e	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20

; 543  :        *cc = CC_FAILED; /* Indicate the function failed      */

  00094	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR cc$[rsp]
  0009c	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 544  :        return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	e9 98 04 00 00	 jmp	 $LN1@d250_init
$LN5@d250_init:

; 545  :    }
; 546  : 
; 547  :    if (dev->ccwtrace)

  000a9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000b7	c1 e8 0f	 shr	 eax, 15
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	0f 84 bc 00 00
	00		 je	 $LN6@d250_init

; 548  :    {
; 549  :       WRMSG (HHC01907, "I",

  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR blktab$[rsp]
  000ca	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  000ce	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv88[rsp], eax
  000d5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000dd	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000e1	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv91[rsp], ecx
  000e8	b9 01 00 00 00	 mov	 ecx, 1
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR blktab$[rsp]
  000f8	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  000fb	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  000ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR blktab$[rsp]
  00104	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00107	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0010b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR blktab$[rsp]
  00110	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00113	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00117	48 8b 4c 24 78	 mov	 rcx, QWORD PTR blktab$[rsp]
  0011c	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0011f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00123	48 8b 4c 24 78	 mov	 rcx, QWORD PTR blktab$[rsp]
  00128	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  0012b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0012f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv88[rsp]
  00136	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0013a	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv91[rsp]
  00141	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169819
  0014c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169820
  00158	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00162	41 b9 03 00 00
	00		 mov	 r9d, 3
  00168	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169821
  0016f	ba 2d 02 00 00	 mov	 edx, 557		; 0000022dH
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169822
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@d250_init:

; 550  :               dev->devnum,
; 551  :               blktab->devt,
; 552  :               blktab->darch,
; 553  :               blktab->phys512,
; 554  :               blktab->phys1024,
; 555  :               blktab->phys2048,
; 556  :               blktab->phys4096
; 557  :              );
; 558  :    }
; 559  : 
; 560  :    /* Save the device architecture */
; 561  :    isCKD = blktab->darch;

  00181	48 8b 44 24 78	 mov	 rax, QWORD PTR blktab$[rsp]
  00186	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00189	89 84 24 90 00
	00 00		 mov	 DWORD PTR isCKD$[rsp], eax

; 562  : 
; 563  :    /* Determine if the blocksize is valid and its physical/block value */
; 564  :    switch(blksize)

  00190	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR blksize$[rsp]
  00197	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv135[rsp], eax
  0019e	81 bc 24 84 00
	00 00 00 02 00
	00		 cmp	 DWORD PTR tv135[rsp], 512 ; 00000200H
  001a9	74 3a		 je	 SHORT $LN8@d250_init
  001ab	81 bc 24 84 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR tv135[rsp], 1024 ; 00000400H
  001b6	74 3e		 je	 SHORT $LN9@d250_init
  001b8	81 bc 24 84 00
	00 00 00 08 00
	00		 cmp	 DWORD PTR tv135[rsp], 2048 ; 00000800H
  001c3	74 42		 je	 SHORT $LN10@d250_init
  001c5	81 bc 24 84 00
	00 00 00 10 00
	00		 cmp	 DWORD PTR tv135[rsp], 4096 ; 00001000H
  001d0	74 02		 je	 SHORT $LN7@d250_init
  001d2	eb 44		 jmp	 SHORT $LN11@d250_init
$LN7@d250_init:

; 565  :    {
; 566  :       case 4096:
; 567  :          seccyl=blktab->phys4096;

  001d4	48 8b 44 24 78	 mov	 rax, QWORD PTR blktab$[rsp]
  001d9	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  001dc	89 84 24 80 00
	00 00		 mov	 DWORD PTR seccyl$[rsp], eax

; 568  :          break;

  001e3	eb 56		 jmp	 SHORT $LN2@d250_init
$LN8@d250_init:

; 569  :       case 512:
; 570  :          seccyl=blktab->phys512;

  001e5	48 8b 44 24 78	 mov	 rax, QWORD PTR blktab$[rsp]
  001ea	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001ed	89 84 24 80 00
	00 00		 mov	 DWORD PTR seccyl$[rsp], eax

; 571  :          break;

  001f4	eb 45		 jmp	 SHORT $LN2@d250_init
$LN9@d250_init:

; 572  :       case 1024:
; 573  :          seccyl=blktab->phys1024;

  001f6	48 8b 44 24 78	 mov	 rax, QWORD PTR blktab$[rsp]
  001fb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001fe	89 84 24 80 00
	00 00		 mov	 DWORD PTR seccyl$[rsp], eax

; 574  :          break;

  00205	eb 34		 jmp	 SHORT $LN2@d250_init
$LN10@d250_init:

; 575  :       case 2048:
; 576  :          seccyl=blktab->phys2048;

  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR blktab$[rsp]
  0020c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0020f	89 84 24 80 00
	00 00		 mov	 DWORD PTR seccyl$[rsp], eax

; 577  :          break;

  00216	eb 23		 jmp	 SHORT $LN2@d250_init
$LN11@d250_init:

; 578  :       default:
; 579  :          *rc = RC_BADBLKSZ;

  00218	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00220	c7 00 18 00 00
	00		 mov	 DWORD PTR [rax], 24

; 580  :          *cc = CC_FAILED;

  00226	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR cc$[rsp]
  0022e	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 581  :          return NULL;

  00234	33 c0		 xor	 eax, eax
  00236	e9 06 03 00 00	 jmp	 $LN1@d250_init
$LN2@d250_init:

; 582  :    }
; 583  : 
; 584  :    isRO = 0;  /* Assume device is read-write */

  0023b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR isRO$[rsp], 0

; 585  :    if (isCKD)

  00246	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR isCKD$[rsp], 0
  0024e	74 5d		 je	 SHORT $LN12@d250_init

; 586  :    {
; 587  :       /* Number of standard blocks is based upon number of primary */
; 588  :       /* cylinders                                                 */
; 589  :       numblks=(dev->ckdtab->cyls * dev->ckdtab->heads * seccyl);

  00250	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00258	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0025f	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  00263	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0026b	48 8b 89 a0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4768]
  00272	0f b7 49 12	 movzx	 ecx, WORD PTR [rcx+18]
  00276	0f af c1	 imul	 eax, ecx
  00279	0f af 84 24 80
	00 00 00	 imul	 eax, DWORD PTR seccyl$[rsp]
  00281	89 84 24 8c 00
	00 00		 mov	 DWORD PTR numblks$[rsp], eax

; 590  :       if (dev->ckdrdonly)

  00288	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00290	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00296	c1 e8 12	 shr	 eax, 18
  00299	83 e0 01	 and	 eax, 1
  0029c	85 c0		 test	 eax, eax
  0029e	74 0b		 je	 SHORT $LN14@d250_init

; 591  :       {
; 592  :          isRO = 1;

  002a0	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR isRO$[rsp], 1
$LN14@d250_init:

; 593  :       }
; 594  :    }

  002ab	eb 2d		 jmp	 SHORT $LN13@d250_init
$LN12@d250_init:

; 595  :    else
; 596  :    {
; 597  :       numblks=(dev->fbanumblk*dev->fbablksiz)/blksize;

  002ad	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002bd	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  002c3	0f af 81 8c 11
	00 00		 imul	 eax, DWORD PTR [rcx+4492]
  002ca	33 d2		 xor	 edx, edx
  002cc	f7 b4 24 f8 00
	00 00		 div	 DWORD PTR blksize$[rsp]
  002d3	89 84 24 8c 00
	00 00		 mov	 DWORD PTR numblks$[rsp], eax
$LN13@d250_init:

; 598  :       /* FBA devices are never read only */
; 599  :    }
; 600  : 
; 601  :    /* Establish the environment's beginning and ending block numbers */
; 602  :    /* Block numbers in the environment are relative to 1, not zero   */
; 603  :    begblk=1-offset;

  002da	b8 01 00 00 00	 mov	 eax, 1
  002df	48 2b 84 24 00
	01 00 00	 sub	 rax, QWORD PTR offset$[rsp]
  002e7	89 84 24 9c 00
	00 00		 mov	 DWORD PTR begblk$[rsp], eax

; 604  :    endblk=numblks-offset;

  002ee	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR numblks$[rsp]
  002f6	48 2b 84 24 00
	01 00 00	 sub	 rax, QWORD PTR offset$[rsp]
  002fe	89 84 24 a0 00
	00 00		 mov	 DWORD PTR endblk$[rsp], eax

; 605  : 
; 606  :    if (!(bioenv=(struct VMBIOENV *)malloc(sizeof(struct VMBIOENV))))

  00305	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00310	48 89 44 24 70	 mov	 QWORD PTR bioenv$[rsp], rax
  00315	48 83 7c 24 70
	00		 cmp	 QWORD PTR bioenv$[rsp], 0
  0031b	0f 85 ba 00 00
	00		 jne	 $LN15@d250_init

; 607  :    {
; 608  :       char buf[40];
; 609  :       MSGBUF(buf, "malloc(%d)",(int)sizeof(struct VMBIOENV));

  00321	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  00327	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169832
  0032e	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00333	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0033b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 610  :       WRMSG (HHC01908, "E", buf, strerror(errno));

  00341	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00347	8b 08		 mov	 ecx, DWORD PTR [rax]
  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0034f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
  00357	b9 01 00 00 00	 mov	 ecx, 1
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00362	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv172[rsp]
  0036a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0036f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00377	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0037c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169833
  00383	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00388	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169834
  0038f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00394	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00399	41 b9 03 00 00
	00		 mov	 r9d, 3
  0039f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169835
  003a6	ba 62 02 00 00	 mov	 edx, 610		; 00000262H
  003ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169836
  003b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 611  :       *rc = RC_ERROR;  /* Indicate an irrecoverable error occurred */

  003b8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  003c0	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 612  :       *cc = CC_FAILED;

  003c6	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR cc$[rsp]
  003ce	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 613  :       return NULL;

  003d4	33 c0		 xor	 eax, eax
  003d6	e9 66 01 00 00	 jmp	 $LN1@d250_init
$LN15@d250_init:

; 614  :    }
; 615  : 
; 616  :    /* Set the fields in the environment structure                */
; 617  :    bioenv->dev     = dev     ; /* Set device block pointer       */

  003db	48 8b 44 24 70	 mov	 rax, QWORD PTR bioenv$[rsp]
  003e0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 618  :    bioenv->blksiz  = blksize ; /* Pass the block size            */

  003eb	48 8b 44 24 70	 mov	 rax, QWORD PTR bioenv$[rsp]
  003f0	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  003f7	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 619  :    bioenv->offset  = offset  ; /* Pass the offset                */

  003fa	48 8b 44 24 70	 mov	 rax, QWORD PTR bioenv$[rsp]
  003ff	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00407	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 620  :    bioenv->begblk  = begblk  ; /* Save the starting block        */

  0040b	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR begblk$[rsp]
  00413	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bioenv$[rsp]
  00418	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 621  :    bioenv->endblk  = endblk  ; /* Save the ending block          */

  0041c	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR endblk$[rsp]
  00424	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bioenv$[rsp]
  00429	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 622  :    bioenv->isCKD   = isCKD   ; /* Save the device type           */

  0042d	48 8b 44 24 70	 mov	 rax, QWORD PTR bioenv$[rsp]
  00432	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR isCKD$[rsp]
  00439	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 623  :    bioenv->isRO    = isRO    ; /* Save the read/write status     */

  0043c	48 8b 44 24 70	 mov	 rax, QWORD PTR bioenv$[rsp]
  00441	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR isRO$[rsp]
  00448	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 624  :    bioenv->blkphys = seccyl  ; /* Save the block-to-phys mapping */

  0044b	48 8b 44 24 70	 mov	 rax, QWORD PTR bioenv$[rsp]
  00450	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR seccyl$[rsp]
  00457	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 625  : 
; 626  :    /* Attach the environment to the DEVBLK */
; 627  :    /* Lock the DEVBLK in case another thread wants it */
; 628  :    obtain_lock (&dev->lock);

  0045a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00462	48 83 c0 38	 add	 rax, 56			; 00000038H
  00466	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169837
  0046d	48 8b c8	 mov	 rcx, rax
  00470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 629  :    if (dev->vmd250env == NULL)

  00476	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0047e	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  00486	75 68		 jne	 SHORT $LN16@d250_init

; 630  :    {
; 631  :        /* If an environment does not exist, establish it */
; 632  :        dev->vmd250env = bioenv ;

  00488	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00490	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bioenv$[rsp]
  00495	48 89 88 18 06
	00 00		 mov	 QWORD PTR [rax+1560], rcx

; 633  :        /* No need to hold the device lock now, environment is set */
; 634  :        release_lock (&dev->lock);

  0049c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a4	48 83 c0 38	 add	 rax, 56			; 00000038H
  004a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169840
  004af	48 8b c8	 mov	 rcx, rax
  004b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 635  : 
; 636  :        /* Set the appropriate successful return and condition codes */
; 637  :        if (isRO)

  004b8	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR isRO$[rsp], 0
  004c0	74 10		 je	 SHORT $LN18@d250_init

; 638  :        {
; 639  :            *rc = RC_READONLY ; /* Set READ ONLY success return code */

  004c2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  004ca	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 640  :        }

  004d0	eb 0e		 jmp	 SHORT $LN19@d250_init
$LN18@d250_init:

; 641  :        else
; 642  :        {
; 643  :            *rc = RC_SUCCESS  ; /* Set the READ/WRITE success return code */

  004d2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  004da	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN19@d250_init:

; 644  :        }
; 645  :        *cc = CC_SUCCESS ; /* Set that the function has succeeded */

  004e0	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR cc$[rsp]
  004e8	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 646  :    }

  004ee	eb 4c		 jmp	 SHORT $LN17@d250_init
$LN16@d250_init:

; 647  :    else
; 648  :    {
; 649  :        /* If an environment already exists, this is an error:    */
; 650  :        /*   1. Release the device block                          */
; 651  :        /*   2. free the environment just built                   */
; 652  :        /*   3. Reset the retuned environment to NULL and         */
; 653  :        /*   4. Reset return and condition codes to reflect       */
; 654  :        /*      the error condition                               */
; 655  :        release_lock (&dev->lock);

  004f0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f8	48 83 c0 38	 add	 rax, 56			; 00000038H
  004fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169843
  00503	48 8b c8	 mov	 rcx, rax
  00506	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 656  :        free(bioenv);

  0050c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bioenv$[rsp]
  00511	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 657  :        bioenv = NULL ;

  00517	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR bioenv$[rsp], 0

; 658  :        *rc = RC_STATERR;

  00520	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rc$[rsp]
  00528	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 659  :        *cc = CC_FAILED;

  0052e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR cc$[rsp]
  00536	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN17@d250_init:

; 660  :    }
; 661  : 
; 662  :    /* Return the bioenv so that the start and end blocks can     */
; 663  :    /* be returned to the guest in the addressing mode specific   */
; 664  :    /* BIOPL format                                               */
; 665  :    return bioenv ;

  0053c	48 8b 44 24 70	 mov	 rax, QWORD PTR bioenv$[rsp]
$LN1@d250_init:

; 666  : 
; 667  : } /* end function d250_init */

  00541	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00549	48 33 cc	 xor	 rcx, rsp
  0054c	e8 00 00 00 00	 call	 __security_check_cookie
  00551	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00558	c3		 ret	 0
d250_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
blksize$ = 96
bioenv$ = 104
tv166 = 112
rc$ = 116
cc$ = 120
offset$ = 128
bioplx00$ = 144
__$ArrayPad$ = 208
dev$ = 240
diag_rc$ = 248
biopl$ = 256
regs$ = 264
d250_init64 PROC

; 463  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 464  : BIOPL_INIT64   bioplx00;             /* Use to check reserved fields */
; 465  : 
; 466  : /* Passed to the generic INIT function */
; 467  : U32     blksize;                     /* Blocksize                    */
; 468  : S64     offset;                      /* Offset                       */
; 469  : 
; 470  : /* Returned by generic INIT function */
; 471  : struct VMBIOENV *bioenv;             /* -->allocated environement    */
; 472  : int     rc;                          /* return code                  */
; 473  : int     cc;                          /* condition code               */
; 474  : 
; 475  :    /* Clear the reserved BIOPL */
; 476  :    memset(&bioplx00,0,sizeof(BIOPL_INIT64));

  0002e	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR bioplx00$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00040	f3 aa		 rep stosb

; 477  : 
; 478  :    /* Make sure reserved fields are binary zeros  */
; 479  :    if ((memcmp(&biopl->resv1,&bioplx00,INIT64R1_LEN)!=0) ||
; 480  :        (memcmp(&biopl->resv2,&bioplx00,INIT64R2_LEN)!=0) ||

  00042	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  0004a	48 83 c0 03	 add	 rax, 3
  0004e	41 b8 15 00 00
	00		 mov	 r8d, 21
  00054	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 memcmp
  00064	85 c0		 test	 eax, eax
  00066	75 4c		 jne	 SHORT $LN3@d250_init6
  00068	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00070	48 83 c0 1c	 add	 rax, 28
  00074	41 b8 04 00 00
	00		 mov	 r8d, 4
  0007a	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 memcmp
  0008a	85 c0		 test	 eax, eax
  0008c	75 26		 jne	 SHORT $LN3@d250_init6
  0008e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00096	48 83 c0 38	 add	 rax, 56			; 00000038H
  0009a	41 b8 08 00 00
	00		 mov	 r8d, 8
  000a0	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	e8 00 00 00 00	 call	 memcmp
  000b0	85 c0		 test	 eax, eax
  000b2	74 12		 je	 SHORT $LN2@d250_init6
$LN3@d250_init6:

; 481  :        (memcmp(&biopl->resv3,&bioplx00,INIT64R3_LEN)!=0))
; 482  :    {
; 483  :        ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000b4	ba 06 00 00 00	 mov	 edx, 6
  000b9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	e8 00 00 00 00	 call	 s370_program_interrupt
$LN2@d250_init6:

; 484  :    }
; 485  : 
; 486  :    /* Fetch the block size from the BIOPL */
; 487  :    FETCH_FW(blksize,&biopl->blksize);

  000c6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000ce	48 83 c0 18	 add	 rax, 24
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 fetch_fw_noswap
  000da	8b c8		 mov	 ecx, eax
  000dc	e8 00 00 00 00	 call	 _byteswap_ulong
  000e1	89 44 24 60	 mov	 DWORD PTR blksize$[rsp], eax

; 488  : 
; 489  :    /* Fetch the offset from the BIOPL provided by the guest */
; 490  :    FETCH_DW(offset,&biopl->offset);

  000e5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000ed	48 83 c0 20	 add	 rax, 32			; 00000020H
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 fetch_dw_noswap
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 _byteswap_uint64
  00101	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 491  : 
; 492  :    bioenv=d250_init(dev, blksize, offset, &cc, &rc);

  00109	48 8d 44 24 74	 lea	 rax, QWORD PTR rc$[rsp]
  0010e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00113	4c 8d 4c 24 78	 lea	 r9, QWORD PTR cc$[rsp]
  00118	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR offset$[rsp]
  00120	8b 54 24 60	 mov	 edx, DWORD PTR blksize$[rsp]
  00124	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012c	e8 00 00 00 00	 call	 d250_init
  00131	48 89 44 24 68	 mov	 QWORD PTR bioenv$[rsp], rax

; 493  : 
; 494  :    if (bioenv)

  00136	48 83 7c 24 68
	00		 cmp	 QWORD PTR bioenv$[rsp], 0
  0013c	0f 84 f0 00 00
	00		 je	 $LN4@d250_init6

; 495  :    {
; 496  :       /* Save the values in the BIOPL for return to guest */
; 497  :       STORE_DW(&biopl->startblk,bioenv->begblk);

  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR bioenv$[rsp]
  00147	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0014b	e8 00 00 00 00	 call	 _byteswap_uint64
  00150	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR biopl$[rsp]
  00158	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0015c	48 8b d0	 mov	 rdx, rax
  0015f	e8 00 00 00 00	 call	 store_dw_noswap

; 498  :       STORE_DW(&biopl->endblk,bioenv->endblk);

  00164	48 8b 44 24 68	 mov	 rax, QWORD PTR bioenv$[rsp]
  00169	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0016d	e8 00 00 00 00	 call	 _byteswap_uint64
  00172	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR biopl$[rsp]
  0017a	48 83 c1 30	 add	 rcx, 48			; 00000030H
  0017e	48 8b d0	 mov	 rdx, rax
  00181	e8 00 00 00 00	 call	 store_dw_noswap

; 499  :       if (dev->ccwtrace)

  00186	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00194	c1 e8 0f	 shr	 eax, 15
  00197	83 e0 01	 and	 eax, 1
  0019a	85 c0		 test	 eax, eax
  0019c	0f 84 90 00 00
	00		 je	 $LN5@d250_init6

; 500  :       {
; 501  :          WRMSG (HHC01906, "I",

  001a2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001aa	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ae	89 44 24 70	 mov	 DWORD PTR tv166[rsp], eax
  001b2	b9 01 00 00 00	 mov	 ecx, 1
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioenv$[rsp]
  001c2	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001c6	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioenv$[rsp]
  001d0	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001d4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001d9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  001e1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001e6	8b 4c 24 60	 mov	 ecx, DWORD PTR blksize$[rsp]
  001ea	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001ee	8b 4c 24 70	 mov	 ecx, DWORD PTR tv166[rsp]
  001f2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169778
  001fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169779
  00209	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00213	41 b9 03 00 00
	00		 mov	 r9d, 3
  00219	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169780
  00220	ba fb 01 00 00	 mov	 edx, 507		; 000001fbH
  00225	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169781
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@d250_init6:
$LN4@d250_init6:

; 502  :               dev->devnum,
; 503  :               blksize,
; 504  :               offset,
; 505  :               bioenv->begblk,
; 506  :               bioenv->endblk
; 507  :              );
; 508  :       }
; 509  :    }
; 510  :    *diag_rc = rc;

  00232	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR diag_rc$[rsp]
  0023a	8b 4c 24 74	 mov	 ecx, DWORD PTR rc$[rsp]
  0023e	89 08		 mov	 DWORD PTR [rax], ecx

; 511  :    return cc;

  00240	8b 44 24 78	 mov	 eax, DWORD PTR cc$[rsp]

; 512  : } /* end function d250_init64 */

  00244	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0024c	48 33 cc	 xor	 rcx, rsp
  0024f	e8 00 00 00 00	 call	 __security_check_cookie
  00254	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  0025b	5f		 pop	 rdi
  0025c	c3		 ret	 0
d250_init64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
offset$ = 96
blksize$ = 100
bioenv$ = 104
tv160 = 112
rc$ = 116
cc$ = 120
tv156 = 128
bioplx00$ = 144
__$ArrayPad$ = 208
dev$ = 240
diag_rc$ = 248
biopl$ = 256
regs$ = 264
d250_init32 PROC

; 407  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 408  : BIOPL_INIT32   bioplx00;             /* Use to check reserved fields */
; 409  : 
; 410  : /* Passed to the generic INIT function */
; 411  : U32     blksize;                     /* Blocksize                    */
; 412  : S32     offset;                      /* Offset                       */
; 413  : 
; 414  : /* Returned by generic INIT function */
; 415  : struct VMBIOENV *bioenv;            /* -->allocated environement     */
; 416  : int     rc;                         /* return code                   */
; 417  : int     cc;                         /* Condition code to return      */
; 418  : 
; 419  :    /* Clear the reserved BIOPL */
; 420  :    memset(&bioplx00,0,sizeof(BIOPL_INIT32));

  0002e	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR bioplx00$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00040	f3 aa		 rep stosb

; 421  : 
; 422  :    /* Make sure reserved fields are binary zeros                     */
; 423  :    if ((memcmp(&biopl->resv1,&bioplx00,INIT32R1_LEN)!=0) ||

  00042	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  0004a	48 83 c0 03	 add	 rax, 3
  0004e	41 b8 15 00 00
	00		 mov	 r8d, 21
  00054	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 memcmp
  00064	85 c0		 test	 eax, eax
  00066	75 26		 jne	 SHORT $LN3@d250_init3
  00068	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  00070	48 83 c0 28	 add	 rax, 40			; 00000028H
  00074	41 b8 18 00 00
	00		 mov	 r8d, 24
  0007a	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR bioplx00$[rsp]
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 memcmp
  0008a	85 c0		 test	 eax, eax
  0008c	74 12		 je	 SHORT $LN2@d250_init3
$LN3@d250_init3:

; 424  :        (memcmp(&biopl->resv2,&bioplx00,INIT32R2_LEN)!=0))
; 425  :    {
; 426  :        ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0008e	ba 06 00 00 00	 mov	 edx, 6
  00093	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	e8 00 00 00 00	 call	 s370_program_interrupt
$LN2@d250_init3:

; 427  :    }
; 428  : 
; 429  :    /* Fetch the block size from the BIOPL */
; 430  :    FETCH_FW(blksize,&biopl->blksize);

  000a0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000a8	48 83 c0 18	 add	 rax, 24
  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 fetch_fw_noswap
  000b4	8b c8		 mov	 ecx, eax
  000b6	e8 00 00 00 00	 call	 _byteswap_ulong
  000bb	89 44 24 64	 mov	 DWORD PTR blksize$[rsp], eax

; 431  : 
; 432  :    /* Fetch the offset from the BIOPL provided by the guest */
; 433  :    FETCH_FW(offset,&biopl->offset);

  000bf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR biopl$[rsp]
  000c7	48 83 c0 1c	 add	 rax, 28
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 fetch_fw_noswap
  000d3	8b c8		 mov	 ecx, eax
  000d5	e8 00 00 00 00	 call	 _byteswap_ulong
  000da	89 44 24 60	 mov	 DWORD PTR offset$[rsp], eax

; 434  : 
; 435  :    /* Call the addressing independent initialization function */
; 436  :    bioenv=d250_init(dev, blksize, (S64)offset, &cc, &rc);

  000de	48 63 44 24 60	 movsxd	 rax, DWORD PTR offset$[rsp]
  000e3	48 8d 4c 24 74	 lea	 rcx, QWORD PTR rc$[rsp]
  000e8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ed	4c 8d 4c 24 78	 lea	 r9, QWORD PTR cc$[rsp]
  000f2	4c 8b c0	 mov	 r8, rax
  000f5	8b 54 24 64	 mov	 edx, DWORD PTR blksize$[rsp]
  000f9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00101	e8 00 00 00 00	 call	 d250_init
  00106	48 89 44 24 68	 mov	 QWORD PTR bioenv$[rsp], rax

; 437  : 
; 438  :    if (bioenv)

  0010b	48 83 7c 24 68
	00		 cmp	 QWORD PTR bioenv$[rsp], 0
  00111	0f 84 f9 00 00
	00		 je	 $LN4@d250_init3

; 439  :    {
; 440  :       /* Save the values in the BIOPL for return to guest */
; 441  :       STORE_FW(&biopl->startblk,(U32)bioenv->begblk);

  00117	48 8b 44 24 68	 mov	 rax, QWORD PTR bioenv$[rsp]
  0011c	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0011f	e8 00 00 00 00	 call	 _byteswap_ulong
  00124	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR biopl$[rsp]
  0012c	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00130	8b d0		 mov	 edx, eax
  00132	e8 00 00 00 00	 call	 store_fw_noswap

; 442  :       STORE_FW(&biopl->endblk,(U32)bioenv->endblk);

  00137	48 8b 44 24 68	 mov	 rax, QWORD PTR bioenv$[rsp]
  0013c	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  0013f	e8 00 00 00 00	 call	 _byteswap_ulong
  00144	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR biopl$[rsp]
  0014c	48 83 c1 24	 add	 rcx, 36			; 00000024H
  00150	8b d0		 mov	 edx, eax
  00152	e8 00 00 00 00	 call	 store_fw_noswap

; 443  :       if (dev->ccwtrace)

  00157	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00165	c1 e8 0f	 shr	 eax, 15
  00168	83 e0 01	 and	 eax, 1
  0016b	85 c0		 test	 eax, eax
  0016d	0f 84 9d 00 00
	00		 je	 $LN5@d250_init3

; 444  :       {
; 445  :          WRMSG (HHC01906, "I",

  00173	48 63 44 24 60	 movsxd	 rax, DWORD PTR offset$[rsp]
  00178	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  00180	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00188	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0018c	89 4c 24 70	 mov	 DWORD PTR tv160[rsp], ecx
  00190	b9 01 00 00 00	 mov	 ecx, 1
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioenv$[rsp]
  001a0	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001a4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bioenv$[rsp]
  001ae	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001b2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001b7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv156[rsp]
  001bf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001c4	8b 4c 24 64	 mov	 ecx, DWORD PTR blksize$[rsp]
  001c8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001cc	8b 4c 24 70	 mov	 ecx, DWORD PTR tv160[rsp]
  001d0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169754
  001db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169755
  001e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169756
  001fe	ba c3 01 00 00	 mov	 edx, 451		; 000001c3H
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169757
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@d250_init3:
$LN4@d250_init3:

; 446  :               dev->devnum,
; 447  :               blksize,
; 448  :               (S64)offset,
; 449  :               bioenv->begblk,
; 450  :               bioenv->endblk
; 451  :              );
; 452  :       }
; 453  :    }
; 454  :    *diag_rc = rc;

  00210	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR diag_rc$[rsp]
  00218	8b 4c 24 74	 mov	 ecx, DWORD PTR rc$[rsp]
  0021c	89 08		 mov	 DWORD PTR [rax], ecx

; 455  :    return cc;

  0021e	8b 44 24 78	 mov	 eax, DWORD PTR cc$[rsp]

; 456  : } /* end function d250_init32 */

  00222	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0022a	48 33 cc	 xor	 rcx, rsp
  0022d	e8 00 00 00 00	 call	 __security_check_cookie
  00232	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00239	5f		 pop	 rdi
  0023a	c3		 ret	 0
d250_init32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv80 = 56
tv94 = 60
main1$ = 64
main2$ = 72
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetchc PROC					; COMDAT

; 631  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN11@s370_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN12@s370_vfetc
$LN11@s370_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	0f 84 c6 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );

  00054	83 bc 24 80 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0005c	73 0a		 jae	 SHORT $LN15@s370_vfetc
  0005e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN16@s370_vfetc
$LN15@s370_vfetc:
  00068	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@s370_vfetc:
  00070	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00075	74 1f		 je	 SHORT $LN17@s370_vfetc
  00077	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008a	72 0a		 jb	 SHORT $LN17@s370_vfetc
  0008c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00094	eb 08		 jmp	 SHORT $LN23@s370_vfetc
$LN17@s370_vfetc:
  00096	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN23@s370_vfetc:
  0009e	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000a3	74 0d		 je	 SHORT $LN7@s370_vfetc
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 9c		 jne	 SHORT $LN4@s370_vfetc

; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b8	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  000bd	ff c0		 inc	 eax
  000bf	48 98		 cdqe
  000c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000cd	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000d1	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d9	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e1	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	e8 00 00 00 00	 call	 s370_maddr_l
  000f8	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  000fd	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00102	ff c0		 inc	 eax
  00104	48 98		 cdqe
  00106	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  0010b	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  00110	48 8b c8	 mov	 rcx, rax
  00113	f3 a4		 rep movsb

; 640  :     }

  00115	e9 ef 00 00 00	 jmp	 $LN6@s370_vfetc
$LN5@s370_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0011a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00121	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00126	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0012b	2b c8		 sub	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00133	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00138	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00144	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00148	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00150	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00158	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00160	48 8b d0	 mov	 rdx, rax
  00163	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_maddr_l
  0016f	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00174	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00179	ff c0		 inc	 eax
  0017b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0017f	48 98		 cdqe
  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00185	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0018c	03 d1		 add	 edx, ecx
  0018e	8b ca		 mov	 ecx, edx
  00190	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00196	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001a2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001a6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001ae	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001be	48 8b d0	 mov	 rdx, rax
  001c1	e8 00 00 00 00	 call	 s370_maddr_l
  001c6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  001cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001d0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  001d5	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  001da	48 8b c8	 mov	 rcx, rax
  001dd	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  001df	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  001e4	ff c0		 inc	 eax
  001e6	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001ea	48 98		 cdqe
  001ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001f6	48 03 d1	 add	 rdx, rcx
  001f9	48 8b ca	 mov	 rcx, rdx
  001fc	48 8b f9	 mov	 rdi, rcx
  001ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR main2$[rsp]
  00204	48 8b c8	 mov	 rcx, rax
  00207	f3 a4		 rep movsb
$LN6@s370_vfetc:

; 649  :     }
; 650  : }

  00209	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020d	5f		 pop	 rdi
  0020e	5e		 pop	 rsi
  0020f	c3		 ret	 0
s370_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_storage_key
_TEXT	SEGMENT
abs$ = 48
s370_get_storage_key PROC				; COMDAT

; 254  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 255  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 256  :     return ARCH_DEP( get_2K_storage_key )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 s370_get_2K_storage_key

; 257  : #else
; 258  :     return ARCH_DEP( get_4K_storage_key )( abs );
; 259  : #endif
; 260  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
s370_get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
s370_get_2K_storage_key PROC				; COMDAT

; 228  :   inline BYTE  ARCH_DEP( get_2K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 2 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 02		 mov	 dl, 2
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 s370__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
s370_get_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
s370__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@s370__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	0f b6 44 24 48	 movzx	 eax, BYTE PTR K$[rsp]
  00018	83 f8 04	 cmp	 eax, 4
  0001b	75 39		 jne	 SHORT $LN5@s370__get_
  0001d	33 c0		 xor	 eax, eax
  0001f	83 f8 01	 cmp	 eax, 1
  00022	74 32		 je	 SHORT $LN5@s370__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00029	e8 00 00 00 00	 call	 _get_storekey1_ptr
  0002e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00031	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0003a	e8 00 00 00 00	 call	 _get_storekey2_ptr
  0003f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00042	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  00047	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  0004c	0b c8		 or	 ecx, eax
  0004e	8b c1		 mov	 eax, ecx
  00050	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00054	eb 16		 jmp	 SHORT $LN6@s370__get_
$LN5@s370__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  00056	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00060	e8 00 00 00 00	 call	 _get_storekey_ptr
  00065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00068	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s370__get_:

; 140  :     return skey;

  0006c	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
s370__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
mask$ = 64
location$ = 72
wakeup_cpus_mask PROC

; 325  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 326  :     int i;
; 327  : 
; 328  :     for (i=0; mask; mask >>= 1, i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0001d	48 d1 e8	 shr	 rax, 1
  00020	48 89 44 24 40	 mov	 QWORD PTR mask$[rsp], rax
  00025	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00035	74 2e		 je	 SHORT $LN3@wakeup_cpu

; 329  :     {
; 330  :         if (mask & 1)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0003c	48 83 e0 01	 and	 rax, 1
  00040	48 85 c0	 test	 rax, rax
  00043	74 1e		 je	 SHORT $LN5@wakeup_cpu

; 331  :             wakeup_cpu( sysblk.regs[i], location );

  00045	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00056	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0005e	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 332  :     }

  00063	eb b3		 jmp	 SHORT $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 333  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
wakeup_cpus_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmd250.c
_TEXT	SEGMENT
rc$ = 48
cc$ = 52
devnum$ = 56
tv93 = 60
dev$ = 64
biopaddr$ = 72
bioplin$ = 80
__$ArrayPad$ = 144
r1$ = 176
r2$ = 184
regs$ = 192
s370_vm_blockio PROC

; 981  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 982  : /* Guest related paramters and values                                */
; 983  : RADR    biopaddr;                      /* BIOPL address              */
; 984  : 
; 985  : union   parmlist{                      /* BIOPL formats that         */
; 986  :         BIOPL biopl;                   /* May be supplied by the     */
; 987  :         BIOPL_INIT32 init32;           /* guest                      */
; 988  :         BIOPL_IORQ32 iorq32;
; 989  :         BIOPL_REMOVE remove;
; 990  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 991  :         BIOPL_INIT64 init64;
; 992  :         BIOPL_IORQ64 iorq64;
; 993  : #endif /* defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) */
; 994  :         };
; 995  : union   parmlist bioplin;              /* BIOPL from/to guest        */
; 996  : 
; 997  : U16     devnum;                        /* Device number              */
; 998  : DEVBLK *dev;                           /* --> Device block           */
; 999  : int     rc;                            /* return code in Rx+1        */
; 1000 : int     cc;                            /* condition code             */
; 1001 : 
; 1002 :     rc = RC_ERROR; /* Initialize the return code to error */

  00026	c7 44 24 30 ff
	00 00 00	 mov	 DWORD PTR rc$[rsp], 255	; 000000ffH

; 1003 :     cc = CC_FAILED; /* Failure assumed unless otherwise successful */

  0002e	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1004 : 
; 1005 : #if 0 // debug
; 1006 :     if (sizeof(BIOPL) != 64)
; 1007 :     {
; 1008 :             LOGMSG( "BIOPL size not 64: %d\n", sizeof( BIOPL ));
; 1009 :     }
; 1010 :     if (sizeof(BIOPL_INIT32) != 64)
; 1011 :     {
; 1012 :             LOGMSG( "BIOPL_INIT32 size not 64: %d\n", sizeof( BIOPL_INIT32 ));
; 1013 :     }
; 1014 :     if (sizeof(BIOPL_INIT64) != 64)
; 1015 :     {
; 1016 :             LOGMSG( "BIOPL_INIT64 size not 64: %d\n", sizeof( BIOPL_INIT64 ));
; 1017 :     }
; 1018 :     if (sizeof(BIOPL_IORQ32) != 64)
; 1019 :     {
; 1020 :             LOGMSG( "BIOPL_IORQ32 size not 64: %d\n", sizeof( BIOPL_IORQ32 ));
; 1021 :     }
; 1022 :     if (sizeof(BIOPL_REMOVE) != 64)
; 1023 :     {
; 1024 :             LOGMSG( "BIOPL_REMOVE size not 64: %d\n", sizeof( BIOPL_REMOVE ));
; 1025 :     }
; 1026 :     if (sizeof(BIOPL_IORQ64) != 64)
; 1027 :     {
; 1028 :             LOGMSG( "BIOPL_IORQ64 size not 64: %d\n", sizeof( BIOPL_IORQ64 ));
; 1029 :     }
; 1030 :     if (sizeof(BIOE32) != 16)
; 1031 :     {
; 1032 :             LOGMSG( "BIOE32 size not 16: %d\n", sizeof( BIOE32 ));
; 1033 :     }
; 1034 :     if (sizeof(BIOE64) != 24)
; 1035 :     {
; 1036 :             LOGMSG( "BIOE64 size not 24: %d\n", sizeof( BIOE64 ));
; 1037 :     }
; 1038 : #endif
; 1039 : 
; 1040 :     /* Retrieve the BIOPL address from R1 */
; 1041 :     biopaddr = regs->GR(r1);

  00036	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004d	48 89 44 24 48	 mov	 QWORD PTR biopaddr$[rsp], rax

; 1042 : 
; 1043 :     /* Specification exception if the BIOPL is not on a doubleword boundary */
; 1044 :     if (biopaddr & 0x00000007)

  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR biopaddr$[rsp]
  00057	48 83 e0 07	 and	 rax, 7
  0005b	48 85 c0	 test	 rax, rax
  0005e	74 12		 je	 SHORT $LN4@s370_vm_bl

; 1045 :     {
; 1046 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00060	ba 06 00 00 00	 mov	 edx, 6
  00065	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	e8 00 00 00 00	 call	 s370_program_interrupt
$LN4@s370_vm_bl:

; 1047 :     }
; 1048 : 
; 1049 :     /* Fetch the BIOPL from guest storage */
; 1050 :     ARCH_DEP(wfetchc) (&bioplin, sizeof(bioplin)-1,

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR biopaddr$[rsp]
  00077	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0007d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0008a	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00090	44 8b c0	 mov	 r8d, eax
  00093	b2 3f		 mov	 dl, 63			; 0000003fH
  00095	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  0009a	e8 00 00 00 00	 call	 s370_vfetchc

; 1051 :                        biopaddr, USE_REAL_ADDR, regs);
; 1052 : 
; 1053 :     /* Access the targeted device number from the BIOPL*/
; 1054 :     FETCH_HW(devnum,&bioplin.biopl.devnum);

  0009f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  000a4	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a9	0f b7 c8	 movzx	 ecx, ax
  000ac	e8 00 00 00 00	 call	 _byteswap_ushort
  000b1	66 89 44 24 38	 mov	 WORD PTR devnum$[rsp], ax

; 1055 : 
; 1056 :     /* Locate the device by the number */
; 1057 :     dev = find_device_by_devnum (0,devnum);

  000b6	0f b7 54 24 38	 movzx	 edx, WORD PTR devnum$[rsp]
  000bb	33 c9		 xor	 ecx, ecx
  000bd	e8 00 00 00 00	 call	 find_device_by_devnum
  000c2	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax

; 1058 :     /* Device not found will be checked by the called function */
; 1059 : 
; 1060 :     switch(regs->GR_L(r2))

  000c7	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  000cf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000de	89 44 24 3c	 mov	 DWORD PTR tv93[rsp], eax
  000e2	83 7c 24 3c 00	 cmp	 DWORD PTR tv93[rsp], 0
  000e7	74 13		 je	 SHORT $LN5@s370_vm_bl
  000e9	83 7c 24 3c 01	 cmp	 DWORD PTR tv93[rsp], 1
  000ee	74 49		 je	 SHORT $LN7@s370_vm_bl
  000f0	83 7c 24 3c 02	 cmp	 DWORD PTR tv93[rsp], 2
  000f5	74 7f		 je	 SHORT $LN9@s370_vm_bl
  000f7	e9 9c 00 00 00	 jmp	 $LN10@s370_vm_bl
$LN5@s370_vm_bl:

; 1061 :     {
; 1062 : 
; 1063 : /*--------------------------------------------------------*/
; 1064 : /* Initialize the Block I/O Device Environment            */
; 1065 : /*--------------------------------------------------------*/
; 1066 :     case INIT:
; 1067 : 
; 1068 : #if !defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1069 :          /* 64-bit formats not supported for S/370 or ESA/390 */
; 1070 :          /* and bits 1-7 must be zero                         */
; 1071 :          if (bioplin.biopl.flaga != 0x00)

  000fc	0f b6 44 24 52	 movzx	 eax, BYTE PTR bioplin$[rsp+2]
  00101	85 c0		 test	 eax, eax
  00103	74 12		 je	 SHORT $LN6@s370_vm_bl

; 1072 :          {
; 1073 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00105	ba 06 00 00 00	 mov	 edx, 6
  0010a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	e8 00 00 00 00	 call	 s370_program_interrupt
$LN6@s370_vm_bl:

; 1074 :          }
; 1075 : 
; 1076 :          /* Call the 32-bit addressing function */
; 1077 :          cc = d250_init32(dev,&rc,&bioplin.init32,regs);

  00117	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0011f	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  00124	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0012e	e8 00 00 00 00	 call	 d250_init32
  00133	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1078 : #else
; 1079 :          /* Bits 1-7 must be zero for z/Architecture */
; 1080 :          if (bioplin.biopl.flaga & BIOPL_FLAGARSV)
; 1081 :          {
; 1082 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1083 :          }
; 1084 :          /* Call the addressing sensitive function */
; 1085 :          if (bioplin.biopl.flaga & BIOPL_FLAGAMSK)
; 1086 :          {
; 1087 :             cc = d250_init64(dev,&rc,&bioplin.init64,regs);
; 1088 :          }
; 1089 :          else
; 1090 :          {
; 1091 :             cc = d250_init32(dev,&rc,&bioplin.init32,regs);
; 1092 :          }
; 1093 : #endif /* !FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1094 :          break;

  00137	eb 71		 jmp	 SHORT $LN2@s370_vm_bl
$LN7@s370_vm_bl:

; 1095 : 
; 1096 : /*--------------------------------------------------------*/
; 1097 : /* Perform block I/O read/write requests to the device    */
; 1098 : /*--------------------------------------------------------*/
; 1099 :     case IOREQ:
; 1100 : 
; 1101 : #if !defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1102 :          /* 64-bit formats not supported for S/370 or ESA/390 */
; 1103 :          /* and bits 1-7 must be zero                         */
; 1104 :          if (bioplin.biopl.flaga != 0x00)

  00139	0f b6 44 24 52	 movzx	 eax, BYTE PTR bioplin$[rsp+2]
  0013e	85 c0		 test	 eax, eax
  00140	74 12		 je	 SHORT $LN8@s370_vm_bl

; 1105 :          {
; 1106 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00142	ba 06 00 00 00	 mov	 edx, 6
  00147	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_vm_bl:

; 1107 :          }
; 1108 :          cc = ARCH_DEP(d250_iorq32)(dev,&rc,&bioplin.iorq32,regs);

  00154	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0015c	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  00161	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00166	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_d250_iorq32
  00170	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1109 : #else
; 1110 :          /* Bits 1-7 must be zero for z/Architecture */
; 1111 :          if (bioplin.biopl.flaga & BIOPL_FLAGARSV)
; 1112 :          {
; 1113 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1114 :          }
; 1115 : 
; 1116 :          if (bioplin.biopl.flaga & BIOPL_FLAGAMSK)
; 1117 :          {
; 1118 :             cc = ARCH_DEP(d250_iorq64)(dev,&rc,&bioplin.iorq64,regs);
; 1119 :          }
; 1120 :          else
; 1121 :          {
; 1122 :             cc = ARCH_DEP(d250_iorq32)(dev,&rc,&bioplin.iorq32,regs);
; 1123 :          }
; 1124 : #endif /* !FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1125 :          break;

  00174	eb 34		 jmp	 SHORT $LN2@s370_vm_bl
$LN9@s370_vm_bl:

; 1126 : 
; 1127 : /*--------------------------------------------------------*/
; 1128 : /* Remove the Block I/O Device Environment                */
; 1129 : /*--------------------------------------------------------*/
; 1130 :     case REMOVE:
; 1131 :          cc = d250_remove(dev,&rc,&bioplin.remove,regs);

  00176	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017e	4c 8d 44 24 50	 lea	 r8, QWORD PTR bioplin$[rsp]
  00183	48 8d 54 24 30	 lea	 rdx, QWORD PTR rc$[rsp]
  00188	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	e8 00 00 00 00	 call	 d250_remove
  00192	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1132 :          break;

  00196	eb 12		 jmp	 SHORT $LN2@s370_vm_bl
$LN10@s370_vm_bl:

; 1133 :     default:
; 1134 :          ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00198	ba 06 00 00 00	 mov	 edx, 6
  0019d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a5	e8 00 00 00 00	 call	 s370_program_interrupt
$LN2@s370_vm_bl:

; 1135 :     } /* end switch(regs->GR_L(r2)) */
; 1136 : 
; 1137 :     /* Update the BIOPL in main storage */
; 1138 :     ARCH_DEP(wstorec) (&bioplin, sizeof(bioplin)-1,

  001aa	48 8b 44 24 48	 mov	 rax, QWORD PTR biopaddr$[rsp]
  001af	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  001b5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001c2	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  001c8	44 8b c0	 mov	 r8d, eax
  001cb	b2 3f		 mov	 dl, 63			; 0000003fH
  001cd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bioplin$[rsp]
  001d2	e8 00 00 00 00	 call	 s370_vstorec

; 1139 :                        biopaddr, USE_REAL_ADDR, regs);
; 1140 : 
; 1141 :     /* Set the return code in Rx+1 */
; 1142 :     regs->GR_L((r1+1)&0xF) = rc;

  001d7	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  001de	ff c0		 inc	 eax
  001e0	83 e0 0f	 and	 eax, 15
  001e3	48 98		 cdqe
  001e5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	8b 54 24 30	 mov	 edx, DWORD PTR rc$[rsp]
  001f1	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1143 : 
; 1144 :     /* Return the condition code */
; 1145 :     return cc;

  001f8	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]

; 1146 : 
; 1147 : } /* end function vm_blockio */

  001fc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00204	48 33 cc	 xor	 rcx, rsp
  00207	e8 00 00 00 00	 call	 __security_check_cookie
  0020c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00213	c3		 ret	 0
s370_vm_blockio ENDP
_TEXT	ENDS
END
