; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_define_devtypes_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_access:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp_getc:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_close_socket:PROC
EXTRN	__imp_w32_fdopen:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	bind_device_ex:PROC
EXTRN	unbind_device_ex:PROC
EXTRN	__imp_read_socket:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG159197 DB	01H DUP (?)
$SG159199 DB	01H DUP (?)
$SG159201 DB	01H DUP (?)
$SG159203 DB	01H DUP (?)
$SG159205 DB	01H DUP (?)
$SG159207 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$bind_device DD imagerel bind_device
	DD	imagerel bind_device+40
	DD	imagerel $unwind$bind_device
$pdata$unbind_device DD imagerel unbind_device
	DD	imagerel unbind_device+26
	DD	imagerel $unwind$unbind_device
$pdata$cardrdr_init_handler DD imagerel cardrdr_init_handler
	DD	imagerel cardrdr_init_handler+4817
	DD	imagerel $unwind$cardrdr_init_handler
$pdata$cardrdr_query_device DD imagerel cardrdr_query_device
	DD	imagerel cardrdr_query_device+907
	DD	imagerel $unwind$cardrdr_query_device
$pdata$cardrdr_close_device DD imagerel cardrdr_close_device
	DD	imagerel cardrdr_close_device+863
	DD	imagerel $unwind$cardrdr_close_device
$pdata$clear_cardrdr DD imagerel clear_cardrdr
	DD	imagerel clear_cardrdr+323
	DD	imagerel $unwind$clear_cardrdr
$pdata$open_cardrdr DD imagerel open_cardrdr
	DD	imagerel open_cardrdr+2006
	DD	imagerel $unwind$open_cardrdr
$pdata$read_ebcdic DD imagerel read_ebcdic
	DD	imagerel read_ebcdic+993
	DD	imagerel $unwind$read_ebcdic
$pdata$read_ascii DD imagerel read_ascii
	DD	imagerel read_ascii+1321
	DD	imagerel $unwind$read_ascii
$pdata$cardrdr_execute_ccw DD imagerel cardrdr_execute_ccw
	DD	imagerel cardrdr_execute_ccw+1193
	DD	imagerel $unwind$cardrdr_execute_ccw
$pdata$hdl_check_depends_ep DD imagerel $LN15
	DD	imagerel $LN15+152
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
_DATA	SEGMENT
$SG159083 DB	'%hx', 00H
$SG159088 DB	'E', 00H
	ORG $+2
$SG159086 DB	'malloc(%d)', 00H
	ORG $+1
$SG159087 DB	'Card', 00H
	ORG $+3
$SG159097 DB	'eof', 00H
$SG159089 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG159101 DB	'ebcdic', 00H
	ORG $+1
$SG159109 DB	'E', 00H
	ORG $+2
$SG159090 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159091 DB	'cardrdr.c', 00H
	ORG $+2
$SG159116 DB	'E', 00H
	ORG $+2
$SG159093 DB	'sockdev', 00H
$SG159095 DB	'multifile', 00H
	ORG $+2
$SG159099 DB	'intrq', 00H
	ORG $+2
$SG159103 DB	'ascii', 00H
	ORG $+2
$SG159105 DB	'trunc', 00H
	ORG $+2
$SG159123 DB	'E', 00H
	ORG $+2
$SG159107 DB	'autopad', 00H
$SG159110 DB	'HHC01201%s %1d:%04X Card: filename %s too long, maximum '
	DB	'length is %d', 0aH, 00H
	ORG $+2
$SG159111 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159112 DB	'cardrdr.c', 00H
	ORG $+2
$SG159128 DB	'E', 00H
	ORG $+2
$SG159114 DB	'access()', 00H
	ORG $+3
$SG159115 DB	'Card', 00H
	ORG $+3
$SG159134 DB	'E', 00H
	ORG $+2
$SG159117 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG159139 DB	'I', 00H
	ORG $+2
$SG159118 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159119 DB	'cardrdr.c', 00H
	ORG $+2
$SG159144 DB	'W', 00H
	ORG $+2
$SG159121 DB	'strdup()', 00H
	ORG $+3
$SG159122 DB	'Card', 00H
	ORG $+3
$SG159151 DB	'E', 00H
	ORG $+2
$SG159124 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG159161 DB	'E', 00H
	ORG $+2
$SG159125 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159126 DB	'cardrdr.c', 00H
	ORG $+6
$SG159129 DB	'HHC01202%s %1d:%04X Card: options ascii and ebcdic are m'
	DB	'utually exclusive', 0aH, 00H
	ORG $+1
$SG159187 DB	'RDR', 00H
$SG159130 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159131 DB	'cardrdr.c', 00H
	ORG $+6
$SG159136 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159135 DB	'HHC01203%s %1d:%04X Card: only one filename (sock_spec) '
	DB	'allowed for socket device', 0aH, 00H
	ORG $+1
$SG159193 DB	'.', 00H
	ORG $+2
$SG159137 DB	'cardrdr.c', 00H
	ORG $+6
$SG159141 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159140 DB	'HHC01204%s %1d:%04X Card: option ascii is default for so'
	DB	'cket device', 0aH, 00H
	ORG $+3
$SG159142 DB	'cardrdr.c', 00H
	ORG $+6
$SG159146 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159145 DB	'HHC01205%s %1d:%04X Card: option multifile ignored: only'
	DB	' one file specified', 0aH, 00H
	ORG $+3
$SG159147 DB	'cardrdr.c', 00H
	ORG $+6
$SG159152 DB	'HHC01201%s %1d:%04X Card: filename %s too long, maximum '
	DB	'length is %d', 0aH, 00H
	ORG $+2
$SG159153 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159154 DB	'cardrdr.c', 00H
	ORG $+2
$SG159195 DB	' intrq', 00H
	ORG $+1
$SG159208 DB	'*', 00H
	ORG $+2
$SG159159 DB	'access()', 00H
	ORG $+3
$SG159160 DB	'Card', 00H
	ORG $+3
$SG159196 DB	' trunc', 00H
	ORG $+1
$SG159224 DB	'E', 00H
	ORG $+2
$SG159162 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG159202 DB	' ascii', 00H
	ORG $+1
$SG159230 DB	'I', 00H
	ORG $+2
$SG159163 DB	'cardrdr_init_handler', 00H
	ORG $+3
$SG159164 DB	'cardrdr.c', 00H
	ORG $+2
$SG159271 DB	'open()', 00H
	ORG $+1
$SG159273 DB	'E', 00H
	ORG $+2
$SG159170 DB	'cardrdr.c:376', 00H
	ORG $+2
$SG159171 DB	'cardrdr.c:378', 00H
	ORG $+2
$SG159194 DB	' eof', 00H
	ORG $+3
$SG159198 DB	' autopad', 00H
	ORG $+3
$SG159277 DB	'rb', 00H
	ORG $+1
$SG159200 DB	' ebcdic', 00H
$SG159204 DB	' multifile', 00H
	ORG $+1
$SG159282 DB	'E', 00H
	ORG $+2
$SG159206 DB	' sockdev', 00H
	ORG $+3
$SG159291 DB	'E', 00H
	ORG $+2
$SG159209 DB	'%s%s%s%s%s%s%s%s IO[%llu]', 00H
	ORG $+2
$SG159328 DB	'E', 00H
	ORG $+2
$SG159222 DB	'close_socket() or fclose()', 00H
	ORG $+1
$SG159223 DB	'Card', 00H
	ORG $+3
$SG159335 DB	'E', 00H
	ORG $+2
$SG159225 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG159371 DB	'E', 00H
	ORG $+2
$SG159226 DB	'cardrdr_close_device', 00H
	ORG $+3
$SG159227 DB	'cardrdr.c', 00H
	ORG $+6
$SG159231 DB	'HHC01206%s %1d:%04X Card: client %s, IP %s disconnected '
	DB	'from device %s', 0aH, 00H
$SG159232 DB	'cardrdr_close_device', 00H
	ORG $+3
$SG159233 DB	'cardrdr.c', 00H
	ORG $+2
$SG159272 DB	'Card', 00H
	ORG $+3
$SG159381 DB	'E', 00H
	ORG $+2
$SG159274 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG159494 DB	'DEVBLK', 00H
	ORG $+5
$SG159275 DB	'open_cardrdr', 00H
	ORG $+3
$SG159276 DB	'cardrdr.c', 00H
	ORG $+6
$SG159280 DB	'fread()', 00H
$SG159281 DB	'Card', 00H
	ORG $+3
$SG159283 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG159284 DB	'open_cardrdr', 00H
	ORG $+3
$SG159285 DB	'cardrdr.c', 00H
	ORG $+6
$SG159289 DB	'fseek()', 00H
$SG159290 DB	'Card', 00H
	ORG $+3
$SG159292 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG159293 DB	'open_cardrdr', 00H
	ORG $+3
$SG159294 DB	'cardrdr.c', 00H
	ORG $+6
$SG159297 DB	'open_cardrdr', 00H
	ORG $+3
$SG159298 DB	'cardrdr.c', 00H
	ORG $+6
$SG159301 DB	'open_cardrdr', 00H
	ORG $+3
$SG159327 DB	'Card', 00H
	ORG $+3
$SG159299 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159302 DB	'cardrdr.c', 00H
	ORG $+6
$SG159329 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG159303 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159326 DB	'read_socket() or fread()', 00H
	ORG $+7
$SG159330 DB	'read_ebcdic', 00H
	ORG $+4
$SG159331 DB	'cardrdr.c', 00H
	ORG $+6
$SG159332 DB	'unexpected end of file', 00H
	ORG $+1
$SG159333 DB	'read_socket() or fread()', 00H
	ORG $+3
$SG159334 DB	'Card', 00H
	ORG $+7
$SG159336 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG159337 DB	'read_ebcdic', 00H
	ORG $+4
$SG159338 DB	'cardrdr.c', 00H
	ORG $+6
$SG159369 DB	'read_socket() or getc()', 00H
$SG159370 DB	'Card', 00H
	ORG $+3
$SG159372 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG159373 DB	'read_ascii', 00H
	ORG $+5
$SG159374 DB	'cardrdr.c', 00H
	ORG $+6
$SG159383 DB	'read_ascii', 00H
	ORG $+5
$SG159496 DB	'SDL 4.2', 00H
$SG159382 DB	'HHC01207%s %1d:%04X Card: file %s: card image exceeds ma'
	DB	'ximum %d bytes', 0aH, 00H
$SG159384 DB	'cardrdr.c', 00H
	ORG $+2
$SG159497 DB	'SYSBLK', 00H
	ORG $+5
cardrdr_device_hndinfo DQ FLAT:cardrdr_init_handler
	DQ	FLAT:cardrdr_execute_ccw
	DQ	FLAT:cardrdr_close_device
	DQ	FLAT:cardrdr_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG159490 DB	'SDL 4.60', 00H
	ORG $+7
$SG159491 DB	'HERCULES', 00H
	ORG $+7
$SG159493 DB	'SDL 4.00', 00H
	ORG $+3
$SG159502 DB	'1442', 00H
	ORG $+3
$SG159503 DB	'2501', 00H
	ORG $+3
$SG159504 DB	'3505', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:open_cardrdr
	DD	01bH
	DD	07beH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cardrdr_query_device
	DD	025H
	DD	0373H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cardrdr_init_handler
	DD	01fH
	DD	012b9H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$bind_device DD 010e01H
	DD	0420eH
$unwind$unbind_device DD 010901H
	DD	04209H
$unwind$cardrdr_init_handler DD 022719H
	DD	0490115H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$cardrdr_query_device DD 022d19H
	DD	03b011bH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
$unwind$cardrdr_close_device DD 020c01H
	DD	015010cH
$unwind$clear_cardrdr DD 010901H
	DD	06209H
$unwind$open_cardrdr DD 022319H
	DD	02b0111H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$read_ebcdic DD 031201H
	DD	0120112H
	DD	0700bH
$unwind$read_ascii DD 031201H
	DD	0120112H
	DD	0700bH
$unwind$cardrdr_execute_ccw DD 031901H
	DD	070158219H
	DD	06014H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 1021 : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1022 : {
; 1023 :     HDL_DEVICE(1442, cardrdr_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cardrdr_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159502
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1024 :     HDL_DEVICE(2501, cardrdr_device_hndinfo );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cardrdr_device_hndinfo
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159503
  00029	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1025 :     HDL_DEVICE(3505, cardrdr_device_hndinfo );

  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cardrdr_device_hndinfo
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159504
  0003b	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1026 : }
; 1027 : END_DEVICE_SECTION

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 1002 : HDL_DEPENDENCY_SECTION;

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 1003 : {
; 1004 :      HDL_DEPENDENCY(HERCULES);

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159490
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159491
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN11@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN11@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 1005 :      HDL_DEPENDENCY(DEVBLK);

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159493
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159494
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN12@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN12@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 1006 :      HDL_DEPENDENCY(SYSBLK);

  00065	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159496
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159497
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN13@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN13@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_

; 1007 : }
; 1008 : END_DEPENDENCY_SECTION

  0008f	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
num$ = 32
rc$ = 36
tv87 = 40
tv148 = 44
tv171 = 48
tv214 = 52
dev$ = 96
code$ = 104
flags$ = 112
chained$ = 120
count$ = 128
prevcode$ = 136
ccwseq$ = 144
iobuf$ = 152
more$ = 160
unitstat$ = 168
residual$ = 176
cardrdr_execute_ccw PROC

; 812  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@cardrdr_ex:

; 813  : int     rc;                             /* Return code               */
; 814  : U32     num;                            /* Number of bytes to move   */
; 815  : 
; 816  :     UNREFERENCED(flags);

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN4@cardrdr_ex
$LN7@cardrdr_ex:

; 817  :     UNREFERENCED(prevcode);

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN7@cardrdr_ex
$LN10@cardrdr_ex:

; 818  :     UNREFERENCED(ccwseq);

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN10@cardrdr_ex

; 819  : 
; 820  :     /* Open the device file if necessary */
; 821  :     if ( !IS_CCW_SENSE(code) &&

  0002b	0f b6 44 24 68	 movzx	 eax, BYTE PTR code$[rsp]
  00030	83 e0 0f	 and	 eax, 15
  00033	83 f8 04	 cmp	 eax, 4
  00036	74 4e		 je	 SHORT $LN16@cardrdr_ex
  00038	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0003d	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00044	7c 1e		 jl	 SHORT $LN17@cardrdr_ex
  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00053	75 31		 jne	 SHORT $LN16@cardrdr_ex
  00055	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	48 83 b8 b0 01
	00 00 00	 cmp	 QWORD PTR [rax+432], 0
  00062	75 22		 jne	 SHORT $LN16@cardrdr_ex
$LN17@cardrdr_ex:

; 822  :         (dev->fd < 0 || (!dev->bs && !dev->fh)))
; 823  :     {
; 824  :         rc = open_cardrdr (dev, unitstat);

  00064	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00071	e8 00 00 00 00	 call	 open_cardrdr
  00076	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 825  :         if (rc) return;

  0007a	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0007f	74 05		 je	 SHORT $LN18@cardrdr_ex
  00081	e9 1c 04 00 00	 jmp	 $LN1@cardrdr_ex
$LN18@cardrdr_ex:
$LN16@cardrdr_ex:

; 826  :     }
; 827  : 
; 828  :     /* Turn all read/feed commands into read, feed, select stacker 1 */
; 829  :     if ((code & 0x17) == 0x02) code = 0x02;

  00086	0f b6 44 24 68	 movzx	 eax, BYTE PTR code$[rsp]
  0008b	83 e0 17	 and	 eax, 23
  0008e	83 f8 02	 cmp	 eax, 2
  00091	75 05		 jne	 SHORT $LN19@cardrdr_ex
  00093	c6 44 24 68 02	 mov	 BYTE PTR code$[rsp], 2
$LN19@cardrdr_ex:

; 830  : 
; 831  :     /* Turn all feed-only commands into NOP. This is ugly, and should
; 832  :         really be thought out more. --JRM */
; 833  :     if ((code & 0x37) == 0x23) code = 0x03;

  00098	0f b6 44 24 68	 movzx	 eax, BYTE PTR code$[rsp]
  0009d	83 e0 37	 and	 eax, 55			; 00000037H
  000a0	83 f8 23	 cmp	 eax, 35			; 00000023H
  000a3	75 05		 jne	 SHORT $LN20@cardrdr_ex
  000a5	c6 44 24 68 03	 mov	 BYTE PTR code$[rsp], 3
$LN20@cardrdr_ex:

; 834  : 
; 835  :     /* Process depending on CCW opcode */
; 836  :     switch (code) {

  000aa	0f b6 44 24 68	 movzx	 eax, BYTE PTR code$[rsp]
  000af	88 44 24 28	 mov	 BYTE PTR tv87[rsp], al
  000b3	80 7c 24 28 02	 cmp	 BYTE PTR tv87[rsp], 2
  000b8	74 26		 je	 SHORT $LN21@cardrdr_ex
  000ba	80 7c 24 28 03	 cmp	 BYTE PTR tv87[rsp], 3
  000bf	0f 84 b4 01 00
	00		 je	 $LN29@cardrdr_ex
  000c5	80 7c 24 28 04	 cmp	 BYTE PTR tv87[rsp], 4
  000ca	0f 84 c7 01 00
	00		 je	 $LN30@cardrdr_ex
  000d0	80 7c 24 28 e4	 cmp	 BYTE PTR tv87[rsp], 228	; 000000e4H
  000d5	0f 84 ef 02 00
	00		 je	 $LN35@cardrdr_ex
  000db	e9 a1 03 00 00	 jmp	 $LN38@cardrdr_ex
$LN21@cardrdr_ex:

; 837  : 
; 838  :     case 0x02:
; 839  :     /*---------------------------------------------------------------*/
; 840  :     /* READ                                                          */
; 841  :     /*---------------------------------------------------------------*/
; 842  :         /* Read next card if not data-chained from previous CCW */
; 843  :         if ((chained & CCW_FLAGS_CD) == 0)

  000e0	0f b6 44 24 78	 movzx	 eax, BYTE PTR chained$[rsp]
  000e5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 a6 00 00
	00		 jne	 $LN22@cardrdr_ex
$LN13@cardrdr_ex:

; 844  :         {
; 845  :             for (;;)
; 846  :             {
; 847  :                 /* Read ASCII or EBCDIC card image */
; 848  :                 if (dev->ascii)

  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000f7	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  000fd	c1 e8 03	 shr	 eax, 3
  00100	83 e0 01	 and	 eax, 1
  00103	85 c0		 test	 eax, eax
  00105	74 18		 je	 SHORT $LN23@cardrdr_ex

; 849  :                     rc = read_ascii (dev, unitstat);

  00107	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00114	e8 00 00 00 00	 call	 read_ascii
  00119	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  0011d	eb 16		 jmp	 SHORT $LN24@cardrdr_ex
$LN23@cardrdr_ex:

; 850  :                 else
; 851  :                     rc = read_ebcdic (dev, unitstat);

  0011f	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  00127	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0012c	e8 00 00 00 00	 call	 read_ebcdic
  00131	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
$LN24@cardrdr_ex:

; 852  : 
; 853  :                 if (0
; 854  :                     || rc != -2
; 855  :                     || !dev->multifile
; 856  :                     || open_cardrdr (dev, unitstat) != 0

  00135	33 c0		 xor	 eax, eax
  00137	85 c0		 test	 eax, eax
  00139	75 2f		 jne	 SHORT $LN26@cardrdr_ex
  0013b	83 7c 24 24 fe	 cmp	 DWORD PTR rc$[rsp], -2
  00140	75 28		 jne	 SHORT $LN26@cardrdr_ex
  00142	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00147	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0014d	83 e0 01	 and	 eax, 1
  00150	85 c0		 test	 eax, eax
  00152	74 16		 je	 SHORT $LN26@cardrdr_ex
  00154	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  0015c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00161	e8 00 00 00 00	 call	 open_cardrdr
  00166	85 c0		 test	 eax, eax
  00168	74 02		 je	 SHORT $LN25@cardrdr_ex
$LN26@cardrdr_ex:

; 857  :                 )
; 858  :                     break;

  0016a	eb 02		 jmp	 SHORT $LN14@cardrdr_ex
$LN25@cardrdr_ex:

; 859  :             }

  0016c	eb 84		 jmp	 SHORT $LN13@cardrdr_ex
$LN14@cardrdr_ex:

; 860  : 
; 861  :             /* Return error status if read was unsuccessful */
; 862  :             if (rc) break;

  0016e	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00173	74 05		 je	 SHORT $LN27@cardrdr_ex
  00175	e9 28 03 00 00	 jmp	 $LN11@cardrdr_ex
$LN27@cardrdr_ex:

; 863  : 
; 864  :             /* Initialize number of bytes in current card */
; 865  :             dev->cardpos = 0;

  0017a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0017f	c7 80 f0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1776], 0

; 866  :             dev->cardrem = CARD_SIZE;

  00189	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0018e	c7 80 f4 06 00
	00 50 00 00 00	 mov	 DWORD PTR [rax+1780], 80 ; 00000050H
$LN22@cardrdr_ex:

; 867  : 
; 868  :         } /* end if(!data-chained) */
; 869  : 
; 870  :         /* Calculate number of bytes to read and set residual count */
; 871  :         num = (count < (U32)dev->cardrem) ? count : (U32)dev->cardrem;

  00198	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0019d	8b 80 f4 06 00
	00		 mov	 eax, DWORD PTR [rax+1780]
  001a3	39 84 24 80 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  001aa	73 0d		 jae	 SHORT $LN40@cardrdr_ex
  001ac	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  001b3	89 44 24 2c	 mov	 DWORD PTR tv148[rsp], eax
  001b7	eb 0f		 jmp	 SHORT $LN41@cardrdr_ex
$LN40@cardrdr_ex:
  001b9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001be	8b 80 f4 06 00
	00		 mov	 eax, DWORD PTR [rax+1780]
  001c4	89 44 24 2c	 mov	 DWORD PTR tv148[rsp], eax
$LN41@cardrdr_ex:
  001c8	8b 44 24 2c	 mov	 eax, DWORD PTR tv148[rsp]
  001cc	89 44 24 20	 mov	 DWORD PTR num$[rsp], eax

; 872  :         *residual = count - num;

  001d0	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  001d4	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  001db	2b c8		 sub	 ecx, eax
  001dd	8b c1		 mov	 eax, ecx
  001df	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  001e7	89 01		 mov	 DWORD PTR [rcx], eax

; 873  :         if (count < (U32)dev->cardrem) *more = 1;

  001e9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001ee	8b 80 f4 06 00
	00		 mov	 eax, DWORD PTR [rax+1780]
  001f4	39 84 24 80 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  001fb	73 0b		 jae	 SHORT $LN28@cardrdr_ex
  001fd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00205	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN28@cardrdr_ex:

; 874  : 
; 875  :         /* Copy data from card image buffer into channel buffer */
; 876  :         memcpy (iobuf, dev->buf + dev->cardpos, num);

  00208	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  0020c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00211	48 63 89 f0 06
	00 00		 movsxd	 rcx, DWORD PTR [rcx+1776]
  00218	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  0021d	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00224	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0022c	48 8b f1	 mov	 rsi, rcx
  0022f	8b c8		 mov	 ecx, eax
  00231	f3 a4		 rep movsb

; 877  : 
; 878  :         /* Update number of bytes remaining in card image buffer */
; 879  :         dev->cardpos += num;

  00233	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00238	8b 80 f0 06 00
	00		 mov	 eax, DWORD PTR [rax+1776]
  0023e	03 44 24 20	 add	 eax, DWORD PTR num$[rsp]
  00242	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00247	89 81 f0 06 00
	00		 mov	 DWORD PTR [rcx+1776], eax

; 880  :         dev->cardrem -= num;

  0024d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00252	8b 4c 24 20	 mov	 ecx, DWORD PTR num$[rsp]
  00256	8b 80 f4 06 00
	00		 mov	 eax, DWORD PTR [rax+1780]
  0025c	2b c1		 sub	 eax, ecx
  0025e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00263	89 81 f4 06 00
	00		 mov	 DWORD PTR [rcx+1780], eax

; 881  : 
; 882  :         /* Return normal status */
; 883  :         *unitstat = CSW_CE | CSW_DE;

  00269	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00271	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 884  :         break;

  00274	e9 29 02 00 00	 jmp	 $LN11@cardrdr_ex
$LN29@cardrdr_ex:

; 885  : 
; 886  :     case 0x03:
; 887  :     /*---------------------------------------------------------------*/
; 888  :     /* CONTROL NO-OPERATION                                          */
; 889  :     /*---------------------------------------------------------------*/
; 890  :         *residual = 0;

  00279	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00281	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 891  :         *unitstat = CSW_CE | CSW_DE;

  00287	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0028f	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 892  :         break;

  00292	e9 0b 02 00 00	 jmp	 $LN11@cardrdr_ex
$LN30@cardrdr_ex:

; 893  : 
; 894  :     case 0x04:
; 895  :     /*---------------------------------------------------------------*/
; 896  :     /* SENSE                                                         */
; 897  :     /*---------------------------------------------------------------*/
; 898  :         /* Calculate residual byte count */
; 899  :         num = (count < dev->numsense) ? count : dev->numsense;

  00297	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0029c	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  002a2	39 84 24 80 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  002a9	73 0d		 jae	 SHORT $LN42@cardrdr_ex
  002ab	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  002b2	89 44 24 30	 mov	 DWORD PTR tv171[rsp], eax
  002b6	eb 0f		 jmp	 SHORT $LN43@cardrdr_ex
$LN42@cardrdr_ex:
  002b8	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002bd	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  002c3	89 44 24 30	 mov	 DWORD PTR tv171[rsp], eax
$LN43@cardrdr_ex:
  002c7	8b 44 24 30	 mov	 eax, DWORD PTR tv171[rsp]
  002cb	89 44 24 20	 mov	 DWORD PTR num$[rsp], eax

; 900  :         *residual = count - num;

  002cf	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  002d3	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  002da	2b c8		 sub	 ecx, eax
  002dc	8b c1		 mov	 eax, ecx
  002de	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  002e6	89 01		 mov	 DWORD PTR [rcx], eax

; 901  :         if (count < dev->numsense) *more = 1;

  002e8	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002ed	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  002f3	39 84 24 80 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  002fa	73 0b		 jae	 SHORT $LN31@cardrdr_ex
  002fc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00304	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN31@cardrdr_ex:

; 902  : 
; 903  :         /* If sense is clear AND filename = "" OR sockdev and fd=-1 */
; 904  :         /* Put an IR sense - so that an unsolicited sense can see the intreq */
; 905  :         if(dev->sense[0]==0)

  00307	b8 01 00 00 00	 mov	 eax, 1
  0030c	48 6b c0 00	 imul	 rax, rax, 0
  00310	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00315	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0031d	85 c0		 test	 eax, eax
  0031f	75 63		 jne	 SHORT $LN32@cardrdr_ex

; 906  :         {
; 907  :             if(dev->filename[0]==0x00 ||

  00321	b8 01 00 00 00	 mov	 eax, 1
  00326	48 6b c0 00	 imul	 rax, rax, 0
  0032a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0032f	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  00337	85 c0		 test	 eax, eax
  00339	74 1d		 je	 SHORT $LN34@cardrdr_ex
  0033b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00340	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00348	74 3a		 je	 SHORT $LN33@cardrdr_ex
  0034a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0034f	83 b8 ac 01 00
	00 ff		 cmp	 DWORD PTR [rax+428], -1
  00356	75 2c		 jne	 SHORT $LN33@cardrdr_ex
$LN34@cardrdr_ex:

; 908  :                     (dev->bs && dev->fd==-1))
; 909  :             {
; 910  :                 dev->sense[0] = SENSE_IR;

  00358	b8 01 00 00 00	 mov	 eax, 1
  0035d	48 6b c0 00	 imul	 rax, rax, 0
  00361	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00366	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 911  :                 dev->sense[1] = SENSE1_RDR_RAIC; /* Retry when IntReq Cleared */

  0036e	b8 01 00 00 00	 mov	 eax, 1
  00373	48 6b c0 01	 imul	 rax, rax, 1
  00377	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0037c	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16
$LN33@cardrdr_ex:
$LN32@cardrdr_ex:

; 912  :             }
; 913  :         }
; 914  : 
; 915  :         /* Copy device sense bytes to channel I/O buffer */
; 916  :         memcpy (iobuf, dev->sense, num);

  00384	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  00388	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0038d	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  00394	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0039c	48 8b f1	 mov	 rsi, rcx
  0039f	8b c8		 mov	 ecx, eax
  003a1	f3 a4		 rep movsb

; 917  : 
; 918  :         /* Clear the device sense bytes */
; 919  :         memset (dev->sense, 0, sizeof(dev->sense));

  003a3	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003a8	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  003ae	48 8b f8	 mov	 rdi, rax
  003b1	33 c0		 xor	 eax, eax
  003b3	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  003b8	f3 aa		 rep stosb

; 920  : 
; 921  :         /* Return unit status */
; 922  :         *unitstat = CSW_CE | CSW_DE;

  003ba	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  003c2	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 923  :         break;

  003c5	e9 d8 00 00 00	 jmp	 $LN11@cardrdr_ex
$LN35@cardrdr_ex:

; 924  : 
; 925  :     case 0xE4:
; 926  :     /*---------------------------------------------------------------*/
; 927  :     /* SENSE ID                                                      */
; 928  :     /*---------------------------------------------------------------*/
; 929  : 
; 930  :         /* SENSE ID is only supported if LEGACYSENSEID is ON;
; 931  :          * otherwise, fall through to invalid operation.
; 932  :          */
; 933  :         if (sysblk.legacysenseid)

  003ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003d1	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  003d7	c1 e8 14	 shr	 eax, 20
  003da	83 e0 01	 and	 eax, 1
  003dd	85 c0		 test	 eax, eax
  003df	0f 84 9c 00 00
	00		 je	 $LN36@cardrdr_ex

; 934  :         {
; 935  :             /* Calculate residual byte count */
; 936  :             num = (count < dev->numdevid) ? count : dev->numdevid;

  003e5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003ea	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  003f0	39 84 24 80 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  003f7	73 0d		 jae	 SHORT $LN44@cardrdr_ex
  003f9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00400	89 44 24 34	 mov	 DWORD PTR tv214[rsp], eax
  00404	eb 0f		 jmp	 SHORT $LN45@cardrdr_ex
$LN44@cardrdr_ex:
  00406	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0040b	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00411	89 44 24 34	 mov	 DWORD PTR tv214[rsp], eax
$LN45@cardrdr_ex:
  00415	8b 44 24 34	 mov	 eax, DWORD PTR tv214[rsp]
  00419	89 44 24 20	 mov	 DWORD PTR num$[rsp], eax

; 937  :             *residual = count - num;

  0041d	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  00421	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00428	2b c8		 sub	 ecx, eax
  0042a	8b c1		 mov	 eax, ecx
  0042c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00434	89 01		 mov	 DWORD PTR [rcx], eax

; 938  :             if (count < dev->numdevid) *more = 1;

  00436	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0043b	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00441	39 84 24 80 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00448	73 0b		 jae	 SHORT $LN37@cardrdr_ex
  0044a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00452	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN37@cardrdr_ex:

; 939  : 
; 940  :             /* Copy device identifier bytes to channel I/O buffer */
; 941  :             memcpy (iobuf, dev->devid, num);

  00455	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  00459	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0045e	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  00465	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0046d	48 8b f1	 mov	 rsi, rcx
  00470	8b c8		 mov	 ecx, eax
  00472	f3 a4		 rep movsb

; 942  : 
; 943  :             /* Return unit status */
; 944  :             *unitstat = CSW_CE | CSW_DE;

  00474	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0047c	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 945  :             break;

  0047f	eb 21		 jmp	 SHORT $LN11@cardrdr_ex
$LN36@cardrdr_ex:
$LN38@cardrdr_ex:

; 946  :         }
; 947  :         /* FALLTHRU */
; 948  : 
; 949  :     default:
; 950  :     /*---------------------------------------------------------------*/
; 951  :     /* INVALID OPERATION                                             */
; 952  :     /*---------------------------------------------------------------*/
; 953  :         /* Set command reject sense byte, and unit check status */
; 954  :         dev->sense[0] = SENSE_CR;

  00481	b8 01 00 00 00	 mov	 eax, 1
  00486	48 6b c0 00	 imul	 rax, rax, 0
  0048a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0048f	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 955  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00497	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0049f	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN11@cardrdr_ex:
$LN1@cardrdr_ex:

; 956  : 
; 957  :     } /* end switch(code) */
; 958  : 
; 959  : } /* end function cardrdr_execute_ccw */

  004a2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  004a6	5f		 pop	 rdi
  004a7	5e		 pop	 rsi
  004a8	c3		 ret	 0
cardrdr_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
c$ = 96
rc$ = 100
i$ = 104
tv167 = 108
tv173 = 112
tv208 = 116
tv214 = 120
tv158 = 128
tv203 = 136
dev$ = 160
unitstat$ = 168
read_ascii PROC

; 682  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 683  : int   rc  = 0;                          /* Return code               */

  00012	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 684  : int   i   = 0;                          /* Array subscript           */

  0001a	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 685  : BYTE  c   = 0;                          /* Input character           */

  00022	c6 44 24 60 00	 mov	 BYTE PTR c$[rsp], 0

; 686  : 
; 687  :     /* Prefill the card image with EBCDIC blanks */
; 688  :     memset (dev->buf, HEX40, CARD_SIZE);

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 8b b8 c8 01
	00 00		 mov	 rdi, QWORD PTR [rax+456]
  00036	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0003b	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00040	f3 aa		 rep stosb
$LN2@read_ascii:

; 689  : 
; 690  :     /* Read up to 80 bytes into device buffer */
; 691  :     for (;;)
; 692  :     {
; 693  :         /* Read next byte of card image */
; 694  :         if (dev->bs)

  00042	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004a	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00052	0f 84 27 01 00
	00		 je	 $LN8@read_ascii

; 695  :         {
; 696  :             /* Out of data? */
; 697  :             if (dev->bufoff >= dev->buflen)

  00058	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00060	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00068	8b 89 dc 01 00
	00		 mov	 ecx, DWORD PTR [rcx+476]
  0006e	39 88 e0 01 00
	00		 cmp	 DWORD PTR [rax+480], ecx
  00074	0f 8c b7 00 00
	00		 jl	 $LN10@read_ascii

; 698  :             {
; 699  :                 // Read more data */
; 700  :                 rc = read_socket( dev->fd, &dev->buf[ CARD_SIZE ],

  0007a	b8 01 00 00 00	 mov	 eax, 1
  0007f	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  00083	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0008b	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  00092	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  00098	48 8b d0	 mov	 rdx, rax
  0009b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a3	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_socket
  000af	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 701  :                     TRAY_CARDS * CARD_SIZE );
; 702  :                 if (rc <= 0)

  000b3	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  000b8	7f 0a		 jg	 SHORT $LN12@read_ascii

; 703  :                     rc = EOF;

  000ba	c7 44 24 64 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
  000c2	eb 6b		 jmp	 SHORT $LN13@read_ascii
$LN12@read_ascii:

; 704  :                 else
; 705  :                 {
; 706  :                     dev->buflen = CARD_SIZE + rc;

  000c4	8b 44 24 64	 mov	 eax, DWORD PTR rc$[rsp]
  000c8	83 c0 50	 add	 eax, 80			; 00000050H
  000cb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d3	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 707  :                     dev->bufoff = CARD_SIZE;

  000d9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e1	c7 80 e0 01 00
	00 50 00 00 00	 mov	 DWORD PTR [rax+480], 80	; 00000050H

; 708  :                     c = dev->buf[ dev->bufoff++ ];

  000eb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f3	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  000fa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00102	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00109	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0010d	88 44 24 60	 mov	 BYTE PTR c$[rsp], al
  00111	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00119	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  0011f	ff c0		 inc	 eax
  00121	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00129	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN13@read_ascii:

; 709  :                 }
; 710  :             }

  0012f	eb 4c		 jmp	 SHORT $LN11@read_ascii
$LN10@read_ascii:

; 711  :             else /* grab next byte of data */
; 712  :             {
; 713  :                 rc = 0;

  00131	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 714  :                 c = dev->buf[ dev->bufoff++ ];

  00139	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00141	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  00148	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00150	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00157	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0015b	88 44 24 60	 mov	 BYTE PTR c$[rsp], al
  0015f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00167	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  0016d	ff c0		 inc	 eax
  0016f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00177	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN11@read_ascii:

; 715  :             }
; 716  :         }

  0017d	eb 22		 jmp	 SHORT $LN9@read_ascii
$LN8@read_ascii:

; 717  :         else /* grab next byte of data */
; 718  :         {
; 719  :             rc = getc(dev->fh);

  0017f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00187	48 8b 88 b0 01
	00 00		 mov	 rcx, QWORD PTR [rax+432]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getc
  00194	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 720  :             c = (BYTE)rc;

  00198	0f b6 44 24 64	 movzx	 eax, BYTE PTR rc$[rsp]
  0019d	88 44 24 60	 mov	 BYTE PTR c$[rsp], al
$LN9@read_ascii:

; 721  :         }
; 722  : 
; 723  :         /* Handle end-of-file condition */
; 724  :         if (rc == EOF || c == '\x1A')

  001a1	83 7c 24 64 ff	 cmp	 DWORD PTR rc$[rsp], -1
  001a6	74 0e		 je	 SHORT $LN15@read_ascii
  001a8	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  001ad	83 f8 1a	 cmp	 eax, 26
  001b0	0f 85 b6 00 00
	00		 jne	 $LN14@read_ascii
$LN15@read_ascii:

; 725  :         {
; 726  :             /* End of record if there is any data in buffer */
; 727  :             if (i > 0)

  001b6	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  001bb	7e 05		 jle	 SHORT $LN16@read_ascii

; 728  :                 break;

  001bd	e9 5c 03 00 00	 jmp	 $LN3@read_ascii
$LN16@read_ascii:

; 729  : 
; 730  :             /* Return unit exception or intervention required */
; 731  :             if (dev->rdreof)

  001c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  001d0	d1 e8		 shr	 eax, 1
  001d2	83 e0 01	 and	 eax, 1
  001d5	85 c0		 test	 eax, eax
  001d7	74 0d		 je	 SHORT $LN17@read_ascii

; 732  :             {
; 733  :                 *unitstat = CSW_CE | CSW_DE | CSW_UX;

  001d9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  001e1	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 734  :             }

  001e4	eb 3d		 jmp	 SHORT $LN18@read_ascii
$LN17@read_ascii:

; 735  :             else
; 736  :             {
; 737  :                 dev->sense[0] = SENSE_IR;

  001e6	b8 01 00 00 00	 mov	 eax, 1
  001eb	48 6b c0 00	 imul	 rax, rax, 0
  001ef	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f7	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 738  :                 dev->sense[1] = SENSE1_RDR_RAIC; /* Retry when IntReq Cleared */

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	48 6b c0 01	 imul	 rax, rax, 1
  00208	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00210	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 739  :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00218	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00220	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN18@read_ascii:

; 740  :             }
; 741  : 
; 742  :             /* Close the file and clear the file name and flags */
; 743  :             if (clear_cardrdr(dev) != 0)

  00223	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0022b	e8 00 00 00 00	 call	 clear_cardrdr
  00230	85 c0		 test	 eax, eax
  00232	74 2e		 je	 SHORT $LN19@read_ascii

; 744  :             {
; 745  :                 /* Set unit check with equipment check */
; 746  :                 dev->sense[0] = SENSE_EC;

  00234	b8 01 00 00 00	 mov	 eax, 1
  00239	48 6b c0 00	 imul	 rax, rax, 0
  0023d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00245	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 747  :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0024d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00255	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 748  :                 return -1;

  00258	b8 ff ff ff ff	 mov	 eax, -1
  0025d	e9 be 02 00 00	 jmp	 $LN1@read_ascii
$LN19@read_ascii:

; 749  :             }
; 750  : 
; 751  :             return -2;  /* EOF */

  00262	b8 fe ff ff ff	 mov	 eax, -2
  00267	e9 b4 02 00 00	 jmp	 $LN1@read_ascii
$LN14@read_ascii:

; 752  :         }
; 753  : 
; 754  :         /* Handle read error condition */
; 755  :         if (rc < 0)

  0026c	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00271	0f 8d 0c 01 00
	00		 jge	 $LN20@read_ascii

; 756  :         {
; 757  :             // "%1d:%04X %s: error in function %s: %s"
; 758  :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  00277	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00280	74 12		 je	 SHORT $LN28@read_ascii
  00282	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0028a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0028e	89 44 24 6c	 mov	 DWORD PTR tv167[rsp], eax
  00292	eb 08		 jmp	 SHORT $LN29@read_ascii
$LN28@read_ascii:
  00294	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN29@read_ascii:
  0029c	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002a5	74 14		 je	 SHORT $LN30@read_ascii
  002a7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002af	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002b3	d1 f8		 sar	 eax, 1
  002b5	89 44 24 70	 mov	 DWORD PTR tv173[rsp], eax
  002b9	eb 08		 jmp	 SHORT $LN31@read_ascii
$LN30@read_ascii:
  002bb	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN31@read_ascii:
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002c9	8b 08		 mov	 ecx, DWORD PTR [rax]
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002d1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv158[rsp], rax
  002d9	b9 01 00 00 00	 mov	 ecx, 1
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv158[rsp]
  002ec	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159369
  002f8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159370
  00304	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00309	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv167[rsp]
  0030d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00311	8b 4c 24 70	 mov	 ecx, DWORD PTR tv173[rsp]
  00315	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159371
  00320	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00325	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159372
  0032c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00331	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00336	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159373
  00343	ba f7 02 00 00	 mov	 edx, 759		; 000002f7H
  00348	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159374
  0034f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 759  :                 "Card", "read_socket() or getc()", strerror( errno ));
; 760  : 
; 761  :             /* Set unit check with equipment check */
; 762  :             dev->sense[0] = SENSE_EC;

  00355	b8 01 00 00 00	 mov	 eax, 1
  0035a	48 6b c0 00	 imul	 rax, rax, 0
  0035e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00366	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 763  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0036e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00376	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 764  :             return -1;

  00379	b8 ff ff ff ff	 mov	 eax, -1
  0037e	e9 9d 01 00 00	 jmp	 $LN1@read_ascii
$LN20@read_ascii:

; 765  :         }
; 766  : 
; 767  :         /* Ignore carriage return */
; 768  :         if (c == '\r')

  00383	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  00388	83 f8 0d	 cmp	 eax, 13
  0038b	75 05		 jne	 SHORT $LN21@read_ascii

; 769  :             continue;

  0038d	e9 b0 fc ff ff	 jmp	 $LN2@read_ascii
$LN21@read_ascii:

; 770  : 
; 771  :         /* Line-feed indicates end of variable length record */
; 772  :         if (c == '\n')

  00392	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  00397	83 f8 0a	 cmp	 eax, 10
  0039a	75 05		 jne	 SHORT $LN22@read_ascii

; 773  :             break;

  0039c	e9 7d 01 00 00	 jmp	 $LN3@read_ascii
$LN22@read_ascii:

; 774  : 
; 775  :         /* Expand tabs to spaces */
; 776  :         if (c == '\t')

  003a1	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  003a6	83 f8 09	 cmp	 eax, 9
  003a9	75 21		 jne	 SHORT $LN23@read_ascii
$LN7@read_ascii:

; 777  :         {
; 778  :             do {i++;} while ((i & 7) && (i < CARD_SIZE));

  003ab	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  003af	ff c0		 inc	 eax
  003b1	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  003b5	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  003b9	83 e0 07	 and	 eax, 7
  003bc	85 c0		 test	 eax, eax
  003be	74 07		 je	 SHORT $LN24@read_ascii
  003c0	83 7c 24 68 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  003c5	7c e4		 jl	 SHORT $LN7@read_ascii
$LN24@read_ascii:

; 779  :             continue;

  003c7	e9 76 fc ff ff	 jmp	 $LN2@read_ascii
$LN23@read_ascii:

; 780  :         }
; 781  : 
; 782  :         /* Test for overlength record */
; 783  :         if (i >= CARD_SIZE)

  003cc	83 7c 24 68 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  003d1	0f 8c 16 01 00
	00		 jl	 $LN25@read_ascii

; 784  :         {
; 785  :             /* Ignore excess characters if trunc option specified */
; 786  :             if (dev->trunc)

  003d7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003df	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  003e5	c1 e8 04	 shr	 eax, 4
  003e8	83 e0 01	 and	 eax, 1
  003eb	85 c0		 test	 eax, eax
  003ed	74 05		 je	 SHORT $LN26@read_ascii

; 787  :                 continue;

  003ef	e9 4e fc ff ff	 jmp	 $LN2@read_ascii
$LN26@read_ascii:

; 788  : 
; 789  :             WRMSG (HHC01207, "E", LCSS_DEVNUM, dev->filename, CARD_SIZE);

  003f4	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003fd	74 12		 je	 SHORT $LN32@read_ascii
  003ff	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00407	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0040b	89 44 24 74	 mov	 DWORD PTR tv208[rsp], eax
  0040f	eb 08		 jmp	 SHORT $LN33@read_ascii
$LN32@read_ascii:
  00411	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv208[rsp], 0
$LN33@read_ascii:
  00419	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00422	74 14		 je	 SHORT $LN34@read_ascii
  00424	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0042c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00430	d1 f8		 sar	 eax, 1
  00432	89 44 24 78	 mov	 DWORD PTR tv214[rsp], eax
  00436	eb 08		 jmp	 SHORT $LN35@read_ascii
$LN34@read_ascii:
  00438	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN35@read_ascii:
  00440	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00448	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0044e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv203[rsp], rax
  00456	b9 01 00 00 00	 mov	 ecx, 1
  0045b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00461	c7 44 24 50 50
	00 00 00	 mov	 DWORD PTR [rsp+80], 80	; 00000050H
  00469	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv203[rsp]
  00471	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00476	8b 4c 24 74	 mov	 ecx, DWORD PTR tv208[rsp]
  0047a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0047e	8b 4c 24 78	 mov	 ecx, DWORD PTR tv214[rsp]
  00482	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00486	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159381
  0048d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00492	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159382
  00499	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0049e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a3	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159383
  004b0	ba 15 03 00 00	 mov	 edx, 789		; 00000315H
  004b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159384
  004bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 790  : 
; 791  :             /* Set unit check with data check */
; 792  :             dev->sense[0] = SENSE_DC;

  004c2	b8 01 00 00 00	 mov	 eax, 1
  004c7	48 6b c0 00	 imul	 rax, rax, 0
  004cb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004d3	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 793  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  004db	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004e3	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 794  :             return -1;

  004e6	b8 ff ff ff ff	 mov	 eax, -1
  004eb	eb 33		 jmp	 SHORT $LN1@read_ascii
$LN25@read_ascii:

; 795  :         }
; 796  : 
; 797  :         /* Convert character to EBCDIC and store in device buffer */
; 798  :         dev->buf[i++] = host_to_guest(c);

  004ed	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR c$[rsp]
  004f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  004f8	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR i$[rsp]
  004fd	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00505	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  0050c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0050f	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00513	ff c0		 inc	 eax
  00515	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 799  : 
; 800  :     } /* end for(;;) */

  00519	e9 24 fb ff ff	 jmp	 $LN2@read_ascii
$LN3@read_ascii:

; 801  : 
; 802  :     return 0;

  0051e	33 c0		 xor	 eax, eax
$LN1@read_ascii:

; 803  : } /* end function read_ascii */

  00520	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00527	5f		 pop	 rdi
  00528	c3		 ret	 0
read_ascii ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
rc$ = 96
tv165 = 100
tv171 = 104
tv188 = 108
tv194 = 112
tv89 = 120
tv156 = 128
dev$ = 160
unitstat$ = 168
read_ebcdic PROC

; 612  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 613  : int     rc;                             /* Return code               */
; 614  : 
; 615  :     /* Read 80 bytes of card image data into the device buffer */
; 616  :     if (dev->bs)

  00012	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001a	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00022	74 2f		 je	 SHORT $LN2@read_ebcdi

; 617  :         rc = read_socket( dev->fd, dev->buf, CARD_SIZE );

  00024	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0002a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00039	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00041	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_socket
  0004d	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax
  00051	eb 33		 jmp	 SHORT $LN3@read_ebcdi
$LN2@read_ebcdi:

; 618  :     else
; 619  :         rc = (int)fread(dev->buf, 1, CARD_SIZE, dev->fh);

  00053	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005b	4c 8b 88 b0 01
	00 00		 mov	 r9, QWORD PTR [rax+432]
  00062	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00068	ba 01 00 00 00	 mov	 edx, 1
  0006d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00075	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00082	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax
$LN3@read_ebcdi:

; 620  : 
; 621  :     if ((rc > 0) && (rc < CARD_SIZE) && dev->autopad)

  00086	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0008b	7e 62		 jle	 SHORT $LN4@read_ebcdi
  0008d	83 7c 24 60 50	 cmp	 DWORD PTR rc$[rsp], 80	; 00000050H
  00092	7d 5b		 jge	 SHORT $LN4@read_ebcdi
  00094	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009c	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  000a2	c1 e8 05	 shr	 eax, 5
  000a5	83 e0 01	 and	 eax, 1
  000a8	85 c0		 test	 eax, eax
  000aa	74 43		 je	 SHORT $LN4@read_ebcdi

; 622  :     {
; 623  :         memset(&dev->buf[rc], 0, CARD_SIZE - rc);

  000ac	b8 50 00 00 00	 mov	 eax, 80			; 00000050H
  000b1	2b 44 24 60	 sub	 eax, DWORD PTR rc$[rsp]
  000b5	48 98		 cdqe
  000b7	48 89 44 24 78	 mov	 QWORD PTR tv89[rsp], rax
  000bc	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR rc$[rsp]
  000c1	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000c9	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  000d0	48 03 d1	 add	 rdx, rcx
  000d3	48 8b ca	 mov	 rcx, rdx
  000d6	48 8b f9	 mov	 rdi, rcx
  000d9	33 c0		 xor	 eax, eax
  000db	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv89[rsp]
  000e0	f3 aa		 rep stosb

; 624  :         rc = CARD_SIZE;

  000e2	c7 44 24 60 50
	00 00 00	 mov	 DWORD PTR rc$[rsp], 80	; 00000050H

; 625  :     }

  000ea	e9 fc 00 00 00	 jmp	 $LN5@read_ebcdi
$LN4@read_ebcdi:

; 626  :     else if /* Check for End of file */
; 627  :     (0
; 628  :         || ( dev->bs && rc <= 0)
; 629  :         || (!dev->bs && feof(dev->fh))

  000ef	33 c0		 xor	 eax, eax
  000f1	85 c0		 test	 eax, eax
  000f3	75 4c		 jne	 SHORT $LN7@read_ebcdi
  000f5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fd	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00105	74 07		 je	 SHORT $LN8@read_ebcdi
  00107	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0010c	7e 33		 jle	 SHORT $LN7@read_ebcdi
$LN8@read_ebcdi:
  0010e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00116	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  0011e	0f 85 c7 00 00
	00		 jne	 $LN6@read_ebcdi
  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012c	48 8b 88 b0 01
	00 00		 mov	 rcx, QWORD PTR [rax+432]
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  00139	85 c0		 test	 eax, eax
  0013b	0f 84 aa 00 00
	00		 je	 $LN6@read_ebcdi
$LN7@read_ebcdi:

; 630  :     )
; 631  :     {
; 632  :         /* Return unit exception or intervention required */
; 633  :         if (dev->rdreof)

  00141	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00149	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0014f	d1 e8		 shr	 eax, 1
  00151	83 e0 01	 and	 eax, 1
  00154	85 c0		 test	 eax, eax
  00156	74 0d		 je	 SHORT $LN9@read_ebcdi

; 634  :         {
; 635  :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  00158	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00160	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 636  :         }

  00163	eb 3d		 jmp	 SHORT $LN10@read_ebcdi
$LN9@read_ebcdi:

; 637  :         else
; 638  :         {
; 639  :             dev->sense[0] = SENSE_IR;

  00165	b8 01 00 00 00	 mov	 eax, 1
  0016a	48 6b c0 00	 imul	 rax, rax, 0
  0016e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00176	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 640  :             dev->sense[1] = SENSE1_RDR_RAIC; /* Retry when IntReq Cleared */

  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 01	 imul	 rax, rax, 1
  00187	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018f	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 641  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00197	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0019f	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN10@read_ebcdi:

; 642  :         }
; 643  : 
; 644  :         /* Close the file and clear the file name and flags */
; 645  :         if (clear_cardrdr(dev) != 0)

  001a2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001aa	e8 00 00 00 00	 call	 clear_cardrdr
  001af	85 c0		 test	 eax, eax
  001b1	74 2e		 je	 SHORT $LN11@read_ebcdi

; 646  :         {
; 647  :             /* Set unit check with equipment check */
; 648  :             dev->sense[0] = SENSE_EC;

  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	48 6b c0 00	 imul	 rax, rax, 0
  001bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c4	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 649  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  001cc	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  001d4	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 650  :             return -1;

  001d7	b8 ff ff ff ff	 mov	 eax, -1
  001dc	e9 f7 01 00 00	 jmp	 $LN1@read_ebcdi
$LN11@read_ebcdi:

; 651  :         }
; 652  : 
; 653  :         return -2;

  001e1	b8 fe ff ff ff	 mov	 eax, -2
  001e6	e9 ed 01 00 00	 jmp	 $LN1@read_ebcdi
$LN6@read_ebcdi:
$LN5@read_ebcdi:

; 654  :     }
; 655  : 
; 656  :     /* Handle read error condition */
; 657  :     if (rc < CARD_SIZE)

  001eb	83 7c 24 60 50	 cmp	 DWORD PTR rc$[rsp], 80	; 00000050H
  001f0	0f 8d e0 01 00
	00		 jge	 $LN12@read_ebcdi

; 658  :     {
; 659  :         if (rc < 0)

  001f6	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  001fb	0f 8d e3 00 00
	00		 jge	 $LN13@read_ebcdi

; 660  :             // "%1d:%04X %s: error in function %s: %s"
; 661  :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  00201	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0020a	74 12		 je	 SHORT $LN16@read_ebcdi
  0020c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00214	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00218	89 44 24 64	 mov	 DWORD PTR tv165[rsp], eax
  0021c	eb 08		 jmp	 SHORT $LN17@read_ebcdi
$LN16@read_ebcdi:
  0021e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN17@read_ebcdi:
  00226	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0022f	74 14		 je	 SHORT $LN18@read_ebcdi
  00231	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00239	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0023d	d1 f8		 sar	 eax, 1
  0023f	89 44 24 68	 mov	 DWORD PTR tv171[rsp], eax
  00243	eb 08		 jmp	 SHORT $LN19@read_ebcdi
$LN18@read_ebcdi:
  00245	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN19@read_ebcdi:
  0024d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00253	8b 08		 mov	 ecx, DWORD PTR [rax]
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0025b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  00263	b9 01 00 00 00	 mov	 ecx, 1
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0026e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv156[rsp]
  00276	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159326
  00282	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159327
  0028e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00293	8b 4c 24 64	 mov	 ecx, DWORD PTR tv165[rsp]
  00297	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0029b	8b 4c 24 68	 mov	 ecx, DWORD PTR tv171[rsp]
  0029f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159328
  002aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159329
  002b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159330
  002cd	ba 96 02 00 00	 mov	 edx, 662		; 00000296H
  002d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159331
  002d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  002df	e9 c7 00 00 00	 jmp	 $LN14@read_ebcdi
$LN13@read_ebcdi:

; 662  :                 "Card", "read_socket() or fread()", strerror( errno ));
; 663  :         else
; 664  :             // "%1d:%04X %s: error in function %s: %s"
; 665  :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  002e4	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002ed	74 12		 je	 SHORT $LN20@read_ebcdi
  002ef	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002fb	89 44 24 6c	 mov	 DWORD PTR tv188[rsp], eax
  002ff	eb 08		 jmp	 SHORT $LN21@read_ebcdi
$LN20@read_ebcdi:
  00301	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
$LN21@read_ebcdi:
  00309	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00312	74 14		 je	 SHORT $LN22@read_ebcdi
  00314	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00320	d1 f8		 sar	 eax, 1
  00322	89 44 24 70	 mov	 DWORD PTR tv194[rsp], eax
  00326	eb 08		 jmp	 SHORT $LN23@read_ebcdi
$LN22@read_ebcdi:
  00328	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN23@read_ebcdi:
  00330	b9 01 00 00 00	 mov	 ecx, 1
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0033b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159332
  00342	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00347	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159333
  0034e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159334
  0035a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0035f	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv188[rsp]
  00363	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00367	8b 4c 24 70	 mov	 ecx, DWORD PTR tv194[rsp]
  0036b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159335
  00376	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0037b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159336
  00382	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00387	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00392	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159337
  00399	ba 9a 02 00 00	 mov	 edx, 666		; 0000029aH
  0039e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159338
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@read_ebcdi:

; 666  :                 "Card", "read_socket() or fread()", "unexpected end of file");
; 667  : 
; 668  :         /* Set unit check with equipment check */
; 669  :         dev->sense[0] = SENSE_EC;

  003ab	b8 01 00 00 00	 mov	 eax, 1
  003b0	48 6b c0 00	 imul	 rax, rax, 0
  003b4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003bc	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 670  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  003c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  003cc	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 671  :         return -1;

  003cf	b8 ff ff ff ff	 mov	 eax, -1
  003d4	eb 02		 jmp	 SHORT $LN1@read_ebcdi
$LN12@read_ebcdi:

; 672  :     }
; 673  : 
; 674  :     return 0;

  003d6	33 c0		 xor	 eax, eax
$LN1@read_ebcdi:

; 675  : } /* end function read_ebcdic */

  003d8	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  003df	5f		 pop	 rdi
  003e0	c3		 ret	 0
read_ebcdic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
i$ = 96
rc$ = 100
tv148 = 104
tv154 = 108
tv199 = 112
tv205 = 116
len$ = 120
tv279 = 124
tv285 = 128
tv139 = 136
tv190 = 144
tv270 = 152
buf$ = 160
__$ArrayPad$ = 320
dev$ = 352
unitstat$ = 360
open_cardrdr PROC

; 483  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 484  : int     rc;                             /* Return code               */
; 485  : int     i;                              /* Array subscript           */
; 486  : int     len;                            /* Length of data            */
; 487  : BYTE    buf[160];                       /* Auto-detection buffer     */
; 488  : 
; 489  :     *unitstat = 0;

  00023	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 490  : 
; 491  :     // Socket device?
; 492  : 
; 493  :     if (dev->bs)

  0002e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00036	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  0003e	0f 84 8b 00 00
	00		 je	 $LN11@open_cardr

; 494  :     {
; 495  :         // Intervention required if no one has connected yet
; 496  : 
; 497  :         if (dev->fd == -1)

  00044	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004c	83 b8 ac 01 00
	00 ff		 cmp	 DWORD PTR [rax+428], -1
  00053	75 73		 jne	 SHORT $LN12@open_cardr

; 498  :         {
; 499  :             if(dev->rdreof)

  00055	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005d	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00063	d1 e8		 shr	 eax, 1
  00065	83 e0 01	 and	 eax, 1
  00068	85 c0		 test	 eax, eax
  0006a	74 15		 je	 SHORT $LN13@open_cardr

; 500  :             {
; 501  :                 *unitstat=CSW_CE|CSW_DE|CSW_UX;

  0006c	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00074	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 502  :                 return -1;

  00077	b8 ff ff ff ff	 mov	 eax, -1
  0007c	e9 3d 07 00 00	 jmp	 $LN1@open_cardr
$LN13@open_cardr:

; 503  :             }
; 504  :             dev->sense[0] = SENSE_IR;

  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	48 6b c0 00	 imul	 rax, rax, 0
  0008a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00092	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 505  :             dev->sense[1] = SENSE1_RDR_RAIC; /* Retry when IntReq Cleared */

  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ab	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 506  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  000b3	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  000bb	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 507  :             return -1;

  000be	b8 ff ff ff ff	 mov	 eax, -1
  000c3	e9 f6 06 00 00	 jmp	 $LN1@open_cardr
$LN12@open_cardr:

; 508  :         }
; 509  : 
; 510  :         return 0;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 ef 06 00 00	 jmp	 $LN1@open_cardr
$LN11@open_cardr:

; 511  :     }
; 512  : 
; 513  :     /* Intervention required if device has no file name */
; 514  :     if (dev->filename[0] == '\0' || ( strlen(dev->filename) == 1 && dev->filename[0] == '*') )

  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	48 6b c0 00	 imul	 rax, rax, 0
  000d8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e0	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  000e8	85 c0		 test	 eax, eax
  000ea	74 3e		 je	 SHORT $LN15@open_cardr
  000ec	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f4	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000fa	48 8b c8	 mov	 rcx, rax
  000fd	e8 00 00 00 00	 call	 strlen
  00102	48 83 f8 01	 cmp	 rax, 1
  00106	0f 85 91 00 00
	00		 jne	 $LN14@open_cardr
  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	48 6b c0 00	 imul	 rax, rax, 0
  00115	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0011d	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  00125	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00128	75 73		 jne	 SHORT $LN14@open_cardr
$LN15@open_cardr:

; 515  :     {
; 516  :         if(dev->rdreof)

  0012a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00132	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00138	d1 e8		 shr	 eax, 1
  0013a	83 e0 01	 and	 eax, 1
  0013d	85 c0		 test	 eax, eax
  0013f	74 15		 je	 SHORT $LN16@open_cardr

; 517  :         {
; 518  :             *unitstat=CSW_CE|CSW_DE|CSW_UX;

  00141	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00149	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 519  :             return -1;

  0014c	b8 ff ff ff ff	 mov	 eax, -1
  00151	e9 68 06 00 00	 jmp	 $LN1@open_cardr
$LN16@open_cardr:

; 520  :         }
; 521  :         dev->sense[0] = SENSE_IR;

  00156	b8 01 00 00 00	 mov	 eax, 1
  0015b	48 6b c0 00	 imul	 rax, rax, 0
  0015f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00167	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 522  :         dev->sense[1] = SENSE1_RDR_RAIC; /* Retry when IntReq Cleared */

  0016f	b8 01 00 00 00	 mov	 eax, 1
  00174	48 6b c0 01	 imul	 rax, rax, 1
  00178	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00180	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 523  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00188	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00190	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 524  :         return -1;

  00193	b8 ff ff ff ff	 mov	 eax, -1
  00198	e9 21 06 00 00	 jmp	 $LN1@open_cardr
$LN14@open_cardr:

; 525  :     }
; 526  : 
; 527  :     /* Open the device file */
; 528  :     rc = HOPEN (dev->filename, O_RDONLY | O_BINARY);

  0019d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a5	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  001ab	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  001b0	48 8b c8	 mov	 rcx, rax
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  001b9	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 529  :     if (rc < 0)

  001bd	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  001c2	0f 8d 0c 01 00
	00		 jge	 $LN17@open_cardr

; 530  :     {
; 531  :         // "%1d:%04X %s: error in function %s: %s"
; 532  :         WRMSG( HHC01250, "E", LCSS_DEVNUM,

  001c8	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001d1	74 12		 je	 SHORT $LN28@open_cardr
  001d3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001db	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001df	89 44 24 68	 mov	 DWORD PTR tv148[rsp], eax
  001e3	eb 08		 jmp	 SHORT $LN29@open_cardr
$LN28@open_cardr:
  001e5	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv148[rsp], 0
$LN29@open_cardr:
  001ed	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f6	74 14		 je	 SHORT $LN30@open_cardr
  001f8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00200	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00204	d1 f8		 sar	 eax, 1
  00206	89 44 24 6c	 mov	 DWORD PTR tv154[rsp], eax
  0020a	eb 08		 jmp	 SHORT $LN31@open_cardr
$LN30@open_cardr:
  0020c	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN31@open_cardr:
  00214	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0021a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00222	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
  0022a	b9 01 00 00 00	 mov	 ecx, 1
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00235	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv139[rsp]
  0023d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159271
  00249	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159272
  00255	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0025a	8b 4c 24 68	 mov	 ecx, DWORD PTR tv148[rsp]
  0025e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00262	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv154[rsp]
  00266	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0026a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159273
  00271	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159274
  0027d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00282	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00287	41 b9 03 00 00
	00		 mov	 r9d, 3
  0028d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159275
  00294	ba 15 02 00 00	 mov	 edx, 533		; 00000215H
  00299	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159276
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 533  :             "Card", "open()", strerror( errno ));
; 534  : 
; 535  :         /* Set unit check with equipment check */
; 536  :         dev->sense[0] = SENSE_EC;

  002a6	b8 01 00 00 00	 mov	 eax, 1
  002ab	48 6b c0 00	 imul	 rax, rax, 0
  002af	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b7	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 537  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  002bf	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  002c7	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 538  :         return -1;

  002ca	b8 ff ff ff ff	 mov	 eax, -1
  002cf	e9 ea 04 00 00	 jmp	 $LN1@open_cardr
$LN17@open_cardr:

; 539  :     }
; 540  : 
; 541  :     /* Save the file descriptor in the device block */
; 542  :     dev->fd = rc;

  002d4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002dc	8b 4c 24 64	 mov	 ecx, DWORD PTR rc$[rsp]
  002e0	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx

; 543  :     dev->fh = fdopen(dev->fd, "rb");

  002e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159277
  002ed	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f5	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fdopen
  00301	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00309	48 89 81 b0 01
	00 00		 mov	 QWORD PTR [rcx+432], rax

; 544  : 
; 545  :     /* If neither EBCDIC nor ASCII was specified, attempt to
; 546  :        detect the format by inspecting the first 160 bytes */
; 547  :     if (dev->ebcdic == 0 && dev->ascii == 0)

  00310	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00318	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0031e	c1 e8 02	 shr	 eax, 2
  00321	83 e0 01	 and	 eax, 1
  00324	85 c0		 test	 eax, eax
  00326	0f 85 07 04 00
	00		 jne	 $LN18@open_cardr
  0032c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00334	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0033a	c1 e8 03	 shr	 eax, 3
  0033d	83 e0 01	 and	 eax, 1
  00340	85 c0		 test	 eax, eax
  00342	0f 85 eb 03 00
	00		 jne	 $LN18@open_cardr

; 548  :     {
; 549  :         /* Read first 160 bytes of file into the buffer */
; 550  :         len = (int)fread(buf, 1, sizeof(buf), dev->fh);

  00348	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00350	4c 8b 88 b0 01
	00 00		 mov	 r9, QWORD PTR [rax+432]
  00357	41 b8 a0 00 00
	00		 mov	 r8d, 160		; 000000a0H
  0035d	ba 01 00 00 00	 mov	 edx, 1
  00362	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00370	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 551  :         if (len < 0)

  00374	83 7c 24 78 00	 cmp	 DWORD PTR len$[rsp], 0
  00379	0f 8d 46 01 00
	00		 jge	 $LN19@open_cardr

; 552  :         {
; 553  :             // "%1d:%04X %s: error in function %s: %s"
; 554  :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  0037f	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00388	74 12		 je	 SHORT $LN32@open_cardr
  0038a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00392	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00396	89 44 24 70	 mov	 DWORD PTR tv199[rsp], eax
  0039a	eb 08		 jmp	 SHORT $LN33@open_cardr
$LN32@open_cardr:
  0039c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv199[rsp], 0
$LN33@open_cardr:
  003a4	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003ad	74 14		 je	 SHORT $LN34@open_cardr
  003af	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003bb	d1 f8		 sar	 eax, 1
  003bd	89 44 24 74	 mov	 DWORD PTR tv205[rsp], eax
  003c1	eb 08		 jmp	 SHORT $LN35@open_cardr
$LN34@open_cardr:
  003c3	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv205[rsp], 0
$LN35@open_cardr:
  003cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003d1	8b 08		 mov	 ecx, DWORD PTR [rax]
  003d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003d9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv190[rsp], rax
  003e1	b9 01 00 00 00	 mov	 ecx, 1
  003e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003ec	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv190[rsp]
  003f4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  003f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159280
  00400	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00405	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159281
  0040c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00411	8b 4c 24 70	 mov	 ecx, DWORD PTR tv199[rsp]
  00415	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00419	8b 4c 24 74	 mov	 ecx, DWORD PTR tv205[rsp]
  0041d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00421	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159282
  00428	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0042d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159283
  00434	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00439	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00444	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159284
  0044b	ba 2b 02 00 00	 mov	 edx, 555		; 0000022bH
  00450	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159285
  00457	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 555  :                 "Card", "fread()", strerror( errno ));
; 556  : 
; 557  :             /* Close the file */
; 558  :             fclose(dev->fh);

  0045d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00465	48 8b 88 b0 01
	00 00		 mov	 rcx, QWORD PTR [rax+432]
  0046c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 559  :             dev->fd = -1;

  00472	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0047a	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 560  :             dev->fh = NULL;

  00484	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048c	48 c7 80 b0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+432], 0

; 561  : 
; 562  :             /* Set unit check with equipment check */
; 563  :             dev->sense[0] = SENSE_EC;

  00497	b8 01 00 00 00	 mov	 eax, 1
  0049c	48 6b c0 00	 imul	 rax, rax, 0
  004a0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a8	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 564  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  004b0	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004b8	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 565  :             return -1;

  004bb	b8 ff ff ff ff	 mov	 eax, -1
  004c0	e9 f9 02 00 00	 jmp	 $LN1@open_cardr
$LN19@open_cardr:

; 566  :         }
; 567  : 
; 568  :         /* Assume ASCII format if first 160 bytes contain only ASCII
; 569  :            characters, carriage return, line feed, tab, or EOF */
; 570  :         for (i = 0, dev->ascii = 1; i < len && buf[i] != '\x1A'; i++)

  004c5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004cd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004d5	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  004db	83 c8 08	 or	 eax, 8
  004de	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004e6	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax
  004ec	eb 0a		 jmp	 SHORT $LN4@open_cardr
$LN2@open_cardr:
  004ee	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  004f2	ff c0		 inc	 eax
  004f4	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@open_cardr:
  004f8	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  004fc	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00500	0f 8d b5 00 00
	00		 jge	 $LN3@open_cardr
  00506	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0050b	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00513	83 f8 1a	 cmp	 eax, 26
  00516	0f 84 9f 00 00
	00		 je	 $LN3@open_cardr

; 571  :         {
; 572  :             if ((buf[i] < 0x20 || buf[i] > 0x7F)
; 573  :                 && buf[i] != '\r' && buf[i] != '\n'
; 574  :                 && buf[i] != '\t')

  0051c	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00521	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00529	83 f8 20	 cmp	 eax, 32			; 00000020H
  0052c	7c 12		 jl	 SHORT $LN21@open_cardr
  0052e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00533	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  0053b	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0053e	7e 76		 jle	 SHORT $LN20@open_cardr
$LN21@open_cardr:
  00540	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00545	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  0054d	83 f8 0d	 cmp	 eax, 13
  00550	74 64		 je	 SHORT $LN20@open_cardr
  00552	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00557	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  0055f	83 f8 0a	 cmp	 eax, 10
  00562	74 52		 je	 SHORT $LN20@open_cardr
  00564	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00569	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00571	83 f8 09	 cmp	 eax, 9
  00574	74 40		 je	 SHORT $LN20@open_cardr

; 575  :             {
; 576  :                 dev->ascii = 0;

  00576	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0057e	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00584	83 e0 f7	 and	 eax, -9			; fffffff7H
  00587	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0058f	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 577  :                 dev->ebcdic = 1;

  00595	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0059d	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  005a3	83 c8 04	 or	 eax, 4
  005a6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005ae	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 578  :                 break;

  005b4	eb 05		 jmp	 SHORT $LN3@open_cardr
$LN20@open_cardr:

; 579  :             }
; 580  :         } /* end for(i) */

  005b6	e9 33 ff ff ff	 jmp	 $LN2@open_cardr
$LN3@open_cardr:

; 581  : 
; 582  :         /* Rewind to start of file */
; 583  :         rc = fseek (dev->fh, 0, SEEK_SET);

  005bb	45 33 c0	 xor	 r8d, r8d
  005be	33 d2		 xor	 edx, edx
  005c0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005c8	48 8b 88 b0 01
	00 00		 mov	 rcx, QWORD PTR [rax+432]
  005cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  005d5	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 584  :         if (rc < 0)

  005d9	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  005de	0f 8d 4f 01 00
	00		 jge	 $LN22@open_cardr

; 585  :         {
; 586  :             // "%1d:%04X %s: error in function %s: %s"
; 587  :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  005e4	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005ed	74 12		 je	 SHORT $LN36@open_cardr
  005ef	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005fb	89 44 24 7c	 mov	 DWORD PTR tv279[rsp], eax
  005ff	eb 08		 jmp	 SHORT $LN37@open_cardr
$LN36@open_cardr:
  00601	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv279[rsp], 0
$LN37@open_cardr:
  00609	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00612	74 17		 je	 SHORT $LN38@open_cardr
  00614	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0061c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00620	d1 f8		 sar	 eax, 1
  00622	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv285[rsp], eax
  00629	eb 0b		 jmp	 SHORT $LN39@open_cardr
$LN38@open_cardr:
  0062b	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv285[rsp], 0
$LN39@open_cardr:
  00636	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0063c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0063e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00644	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv270[rsp], rax
  0064c	b9 01 00 00 00	 mov	 ecx, 1
  00651	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00657	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv270[rsp]
  0065f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00664	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159289
  0066b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00670	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159290
  00677	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0067c	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv279[rsp]
  00680	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00684	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv285[rsp]
  0068b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0068f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159291
  00696	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0069b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159292
  006a2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006ac	41 b9 03 00 00
	00		 mov	 r9d, 3
  006b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159293
  006b9	ba 4c 02 00 00	 mov	 edx, 588		; 0000024cH
  006be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159294
  006c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 588  :                 "Card", "fseek()", strerror( errno ));
; 589  : 
; 590  :             /* Close the file */
; 591  :             fclose (dev->fh);

  006cb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006d3	48 8b 88 b0 01
	00 00		 mov	 rcx, QWORD PTR [rax+432]
  006da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 592  :             dev->fd = -1;

  006e0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006e8	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 593  :             dev->fh = NULL;

  006f2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006fa	48 c7 80 b0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+432], 0

; 594  : 
; 595  :             /* Set unit check with equipment check */
; 596  :             dev->sense[0] = SENSE_EC;

  00705	b8 01 00 00 00	 mov	 eax, 1
  0070a	48 6b c0 00	 imul	 rax, rax, 0
  0070e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00716	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 597  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0071e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00726	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 598  :             return -1;

  00729	b8 ff ff ff ff	 mov	 eax, -1
  0072e	e9 8b 00 00 00	 jmp	 $LN1@open_cardr
$LN22@open_cardr:
$LN18@open_cardr:
$LN7@open_cardr:

; 599  :         }
; 600  : 
; 601  :     } /* end if(auto-detect) */
; 602  : 
; 603  :     ASSERT(dev->fd != -1 && dev->fh);

  00733	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0073b	83 b8 ac 01 00
	00 ff		 cmp	 DWORD PTR [rax+428], -1
  00742	74 12		 je	 SHORT $LN24@open_cardr
  00744	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0074c	48 83 b8 b0 01
	00 00 00	 cmp	 QWORD PTR [rax+432], 0
  00754	75 5c		 jne	 SHORT $LN23@open_cardr
$LN24@open_cardr:
$LN10@open_cardr:
  00756	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159297
  0075d	41 b8 5b 02 00
	00		 mov	 r8d, 603		; 0000025bH
  00763	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159298
  0076a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159299
  00771	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00777	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0077d	85 c0		 test	 eax, eax
  0077f	74 20		 je	 SHORT $LN25@open_cardr
  00781	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159301
  00788	41 b8 5b 02 00
	00		 mov	 r8d, 603		; 0000025bH
  0078e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159302
  00795	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159303
  0079c	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@open_cardr:
  007a1	33 c0		 xor	 eax, eax
  007a3	85 c0		 test	 eax, eax
  007a5	75 af		 jne	 SHORT $LN10@open_cardr
  007a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  007ad	85 c0		 test	 eax, eax
  007af	74 01		 je	 SHORT $LN26@open_cardr
  007b1	cc		 int	 3
$LN26@open_cardr:
$LN23@open_cardr:
  007b2	33 c0		 xor	 eax, eax
  007b4	85 c0		 test	 eax, eax
  007b6	0f 85 77 ff ff
	ff		 jne	 $LN7@open_cardr

; 604  : 
; 605  :     return 0;

  007bc	33 c0		 xor	 eax, eax
$LN1@open_cardr:

; 606  : } /* end function open_cardrdr */

  007be	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007c6	48 33 cc	 xor	 rcx, rsp
  007c9	e8 00 00 00 00	 call	 __security_check_cookie
  007ce	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  007d5	c3		 ret	 0
open_cardrdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
tv84 = 32
dev$ = 64
clear_cardrdr PROC

; 450  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 451  :     /* Close the card image file */
; 452  :     if (cardrdr_close_device(dev) != 0) return -1;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0000e	e8 00 00 00 00	 call	 cardrdr_close_device
  00013	85 c0		 test	 eax, eax
  00015	74 0a		 je	 SHORT $LN2@clear_card
  00017	b8 ff ff ff ff	 mov	 eax, -1
  0001c	e9 1d 01 00 00	 jmp	 $LN1@clear_card
$LN2@clear_card:

; 453  : 
; 454  :     if (dev->bs) return 0;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00026	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  0002e	74 07		 je	 SHORT $LN3@clear_card
  00030	33 c0		 xor	 eax, eax
  00032	e9 07 01 00 00	 jmp	 $LN1@clear_card
$LN3@clear_card:

; 455  : 
; 456  :     /* Clear the file name */
; 457  :     dev->filename[0] = '\0';

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	48 6b c0 00	 imul	 rax, rax, 0
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00045	c6 84 01 a4 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+164], 0

; 458  : 
; 459  :     /* If next file is available, open it */
; 460  :     if (dev->current_file && *(dev->current_file))

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 83 b8 e8 06
	00 00 00	 cmp	 QWORD PTR [rax+1768], 0
  0005a	74 63		 je	 SHORT $LN4@clear_card
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00061	48 8b 80 e8 06
	00 00		 mov	 rax, QWORD PTR [rax+1768]
  00068	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006c	74 51		 je	 SHORT $LN4@clear_card

; 461  :     {
; 462  :         hostpath(dev->filename, *(dev->current_file++), sizeof(dev->filename));

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00073	48 8b 80 e8 06
	00 00		 mov	 rax, QWORD PTR [rax+1768]
  0007a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007d	48 89 44 24 20	 mov	 QWORD PTR tv84[rsp], rax
  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00087	48 8b 80 e8 06
	00 00		 mov	 rax, QWORD PTR [rax+1768]
  0008e	48 83 c0 08	 add	 rax, 8
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00097	48 89 81 e8 06
	00 00		 mov	 QWORD PTR [rcx+1768], rax
  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000a3	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000a9	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000af	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv84[rsp]
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 463  :     }

  000bd	eb 7d		 jmp	 SHORT $LN5@clear_card
$LN4@clear_card:

; 464  :     else
; 465  :     {
; 466  :         /* Reset the device dependent flags */
; 467  :         dev->multifile = 0;

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c4	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  000ca	83 e0 fe	 and	 eax, -2			; fffffffeH
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000d2	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 468  :         dev->ascii = 0;

  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  000e3	83 e0 f7	 and	 eax, -9			; fffffff7H
  000e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000eb	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 469  :         dev->ebcdic = 0;

  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000f6	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  000fc	83 e0 fb	 and	 eax, -5			; fffffffbH
  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00104	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 470  : //      dev->rdreof = 0;
; 471  :         dev->trunc = 0;

  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0010f	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00115	83 e0 ef	 and	 eax, -17		; ffffffefH
  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0011d	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 472  :         dev->autopad = 0;

  00123	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00128	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0012e	83 e0 df	 and	 eax, -33		; ffffffdfH
  00131	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00136	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax
$LN5@clear_card:

; 473  :     }
; 474  : 
; 475  :     return 0;

  0013c	33 c0		 xor	 eax, eax
$LN1@clear_card:

; 476  : } /* end function clear_cardrdr */

  0013e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00142	c3		 ret	 0
clear_cardrdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
tv85 = 96
tv94 = 100
tv132 = 104
tv165 = 108
tv171 = 112
errnum$1 = 116
tv86 = 120
tv186 = 128
tv185 = 136
tv184 = 144
dev$ = 176
cardrdr_close_device PROC

; 417  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 418  :     /* Close the device file */
; 419  : 
; 420  :     if (0
; 421  :         || (  dev->bs && dev->fd >=  0   && close_socket( dev->fd ) <  0 )
; 422  :         || ( !dev->bs && dev->fh != NULL &&    fclose(    dev->fh ) != 0 )

  0000c	33 c0		 xor	 eax, eax
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 84 00 00
	00		 jne	 $LN3@cardrdr_cl
  00016	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00026	74 29		 je	 SHORT $LN4@cardrdr_cl
  00028	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00030	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00037	7c 18		 jl	 SHORT $LN4@cardrdr_cl
  00039	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00041	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
  0004d	85 c0		 test	 eax, eax
  0004f	7c 49		 jl	 SHORT $LN3@cardrdr_cl
$LN4@cardrdr_cl:
  00051	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00059	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00061	0f 85 68 01 00
	00		 jne	 $LN2@cardrdr_cl
  00067	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006f	48 83 b8 b0 01
	00 00 00	 cmp	 QWORD PTR [rax+432], 0
  00077	0f 84 52 01 00
	00		 je	 $LN2@cardrdr_cl
  0007d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00085	48 8b 88 b0 01
	00 00		 mov	 rcx, QWORD PTR [rax+432]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  00092	85 c0		 test	 eax, eax
  00094	0f 84 35 01 00
	00		 je	 $LN2@cardrdr_cl
$LN3@cardrdr_cl:

; 423  :     )
; 424  :     {
; 425  :         int errnum = dev->bs ? get_HSO_errno() : errno;

  0009a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a2	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  000aa	74 0c		 je	 SHORT $LN8@cardrdr_cl
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000b2	89 44 24 60	 mov	 DWORD PTR tv85[rsp], eax
  000b6	eb 0c		 jmp	 SHORT $LN9@cardrdr_cl
$LN8@cardrdr_cl:
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000be	8b 00		 mov	 eax, DWORD PTR [rax]
  000c0	89 44 24 60	 mov	 DWORD PTR tv85[rsp], eax
$LN9@cardrdr_cl:
  000c4	8b 44 24 60	 mov	 eax, DWORD PTR tv85[rsp]
  000c8	89 44 24 74	 mov	 DWORD PTR errnum$1[rsp], eax

; 426  :         // "%1d:%04X %s: error in function %s: %s"
; 427  :         WRMSG( HHC01250, "E", LCSS_DEVNUM,

  000cc	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d5	74 12		 je	 SHORT $LN10@cardrdr_cl
  000d7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000df	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000e3	89 44 24 64	 mov	 DWORD PTR tv94[rsp], eax
  000e7	eb 08		 jmp	 SHORT $LN11@cardrdr_cl
$LN10@cardrdr_cl:
  000e9	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN11@cardrdr_cl:
  000f1	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000fa	74 14		 je	 SHORT $LN12@cardrdr_cl
  000fc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00104	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00108	d1 f8		 sar	 eax, 1
  0010a	89 44 24 68	 mov	 DWORD PTR tv132[rsp], eax
  0010e	eb 08		 jmp	 SHORT $LN13@cardrdr_cl
$LN12@cardrdr_cl:
  00110	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN13@cardrdr_cl:
  00118	8b 4c 24 74	 mov	 ecx, DWORD PTR errnum$1[rsp]
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00122	48 89 44 24 78	 mov	 QWORD PTR tv86[rsp], rax
  00127	b9 01 00 00 00	 mov	 ecx, 1
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00132	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv86[rsp]
  00137	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159222
  00143	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159223
  0014f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00154	8b 4c 24 64	 mov	 ecx, DWORD PTR tv94[rsp]
  00158	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0015c	8b 4c 24 68	 mov	 ecx, DWORD PTR tv132[rsp]
  00160	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159224
  0016b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159225
  00177	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00181	41 b9 03 00 00
	00		 mov	 r9d, 3
  00187	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159226
  0018e	ba ac 01 00 00	 mov	 edx, 428		; 000001acH
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159227
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 428  :             "Card", "close_socket() or fclose()", strerror( errnum ));
; 429  :         dev->fd = -1;

  001a0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a8	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 430  :         dev->fh = NULL;

  001b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ba	48 c7 80 b0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+432], 0

; 431  :         return -1;

  001c5	b8 ff ff ff ff	 mov	 eax, -1
  001ca	e9 88 01 00 00	 jmp	 $LN1@cardrdr_cl
$LN2@cardrdr_cl:

; 432  :     }
; 433  : 
; 434  :     if (dev->bs && (dev->bs->clientip || dev->bs->clientname))

  001cf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d7	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  001df	0f 84 4b 01 00
	00		 je	 $LN5@cardrdr_cl
  001e5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ed	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  001f4	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  001f9	75 1a		 jne	 SHORT $LN6@cardrdr_cl
  001fb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00203	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  0020a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0020f	0f 84 1b 01 00
	00		 je	 $LN5@cardrdr_cl
$LN6@cardrdr_cl:

; 435  :     {
; 436  :         WRMSG (HHC01206, "I", LCSS_DEVNUM, dev->bs->clientname, dev->bs->clientip, dev->bs->spec);

  00215	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0021e	74 12		 je	 SHORT $LN14@cardrdr_cl
  00220	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00228	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0022c	89 44 24 6c	 mov	 DWORD PTR tv165[rsp], eax
  00230	eb 08		 jmp	 SHORT $LN15@cardrdr_cl
$LN14@cardrdr_cl:
  00232	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN15@cardrdr_cl:
  0023a	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00243	74 14		 je	 SHORT $LN16@cardrdr_cl
  00245	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0024d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00251	d1 f8		 sar	 eax, 1
  00253	89 44 24 70	 mov	 DWORD PTR tv171[rsp], eax
  00257	eb 08		 jmp	 SHORT $LN17@cardrdr_cl
$LN16@cardrdr_cl:
  00259	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN17@cardrdr_cl:
  00261	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00269	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  00270	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  00278	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00280	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  00287	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv185[rsp], rcx
  0028f	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00297	48 8b 92 b8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+440]
  0029e	48 89 94 24 90
	00 00 00	 mov	 QWORD PTR tv184[rsp], rdx
  002a6	b9 01 00 00 00	 mov	 ecx, 1
  002ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv186[rsp]
  002b9	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002bd	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002c2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv185[rsp]
  002ca	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  002ce	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002d3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv184[rsp]
  002db	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002df	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002e4	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv165[rsp]
  002e8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002ec	8b 4c 24 70	 mov	 ecx, DWORD PTR tv171[rsp]
  002f0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159230
  002fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159231
  00307	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0030c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00311	41 b9 03 00 00
	00		 mov	 r9d, 3
  00317	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159232
  0031e	ba b4 01 00 00	 mov	 edx, 436		; 000001b4H
  00323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159233
  0032a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@cardrdr_cl:

; 437  :     }
; 438  : 
; 439  :     dev->fd = -1;

  00330	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00338	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 440  :     dev->fh = NULL;

  00342	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0034a	48 c7 80 b0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+432], 0

; 441  : 
; 442  :     return 0;

  00355	33 c0		 xor	 eax, eax
$LN1@cardrdr_cl:

; 443  : } /* end function cardrdr_close_device */

  00357	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0035e	c3		 ret	 0
cardrdr_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
$T1 = 96
tv129 = 104
tv139 = 112
tv145 = 120
tv151 = 128
tv157 = 136
tv162 = 144
tv166 = 152
tv172 = 160
filename$ = 176
__$ArrayPad$ = 448
dev$ = 480
devclass$ = 488
buflen$ = 496
buffer$ = 504
cardrdr_query_device PROC

; 395  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 396  :     char  filename[ PATH_MAX + 1 ];     /* full path or just name    */
; 397  : 
; 398  :     BEGIN_DEVICE_CLASS_QUERY( "RDR", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 e8
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@cardrdr_qu
  00038	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159187
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@cardrdr_qu:
  0004a	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@cardrdr_qu
  00055	48 83 bc 24 e8
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@cardrdr_qu
  00060	83 bc 24 f0 01
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@cardrdr_qu
  0006a	48 83 bc 24 f8
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@cardrdr_qu
$LN4@cardrdr_qu:
  00075	e9 f9 02 00 00	 jmp	 $LN1@cardrdr_qu
$LN3@cardrdr_qu:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 75		 je	 SHORT $LN5@cardrdr_qu
  00091	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159193
  000c6	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000ce	e8 00 00 00 00	 call	 strcmp
  000d3	85 c0		 test	 eax, eax
  000d5	75 2d		 jne	 SHORT $LN7@cardrdr_qu
  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 6b c0 00	 imul	 rax, rax, 0
  000e0	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  000e5	48 81 7c 24 60
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000ee	73 02		 jae	 SHORT $LN9@cardrdr_qu
  000f0	eb 05		 jmp	 SHORT $LN10@cardrdr_qu
$LN9@cardrdr_qu:
  000f2	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@cardrdr_qu:
  000f7	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  000fc	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@cardrdr_qu:
  00104	eb 25		 jmp	 SHORT $LN6@cardrdr_qu
$LN5@cardrdr_qu:
  00106	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010e	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00114	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0011a	48 8b d0	 mov	 rdx, rax
  0011d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@cardrdr_qu:

; 399  : 
; 400  :     snprintf (buffer, buflen, "%s%s%s%s%s%s%s%s IO[%"PRIu64"]",

  0012b	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00133	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00139	d1 e8		 shr	 eax, 1
  0013b	83 e0 01	 and	 eax, 1
  0013e	85 c0		 test	 eax, eax
  00140	74 0e		 je	 SHORT $LN11@cardrdr_qu
  00142	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159194
  00149	48 89 44 24 68	 mov	 QWORD PTR tv129[rsp], rax
  0014e	eb 0c		 jmp	 SHORT $LN12@cardrdr_qu
$LN11@cardrdr_qu:
  00150	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159195
  00157	48 89 44 24 68	 mov	 QWORD PTR tv129[rsp], rax
$LN12@cardrdr_qu:
  0015c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00164	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0016a	c1 e8 03	 shr	 eax, 3
  0016d	83 e0 01	 and	 eax, 1
  00170	85 c0		 test	 eax, eax
  00172	74 26		 je	 SHORT $LN13@cardrdr_qu
  00174	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017c	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00182	c1 e8 04	 shr	 eax, 4
  00185	83 e0 01	 and	 eax, 1
  00188	85 c0		 test	 eax, eax
  0018a	74 0e		 je	 SHORT $LN13@cardrdr_qu
  0018c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159196
  00193	48 89 44 24 70	 mov	 QWORD PTR tv139[rsp], rax
  00198	eb 0c		 jmp	 SHORT $LN14@cardrdr_qu
$LN13@cardrdr_qu:
  0019a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159197
  001a1	48 89 44 24 70	 mov	 QWORD PTR tv139[rsp], rax
$LN14@cardrdr_qu:
  001a6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ae	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  001b4	c1 e8 05	 shr	 eax, 5
  001b7	83 e0 01	 and	 eax, 1
  001ba	85 c0		 test	 eax, eax
  001bc	74 0e		 je	 SHORT $LN15@cardrdr_qu
  001be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159198
  001c5	48 89 44 24 78	 mov	 QWORD PTR tv145[rsp], rax
  001ca	eb 0c		 jmp	 SHORT $LN16@cardrdr_qu
$LN15@cardrdr_qu:
  001cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159199
  001d3	48 89 44 24 78	 mov	 QWORD PTR tv145[rsp], rax
$LN16@cardrdr_qu:
  001d8	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e0	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  001e6	c1 e8 02	 shr	 eax, 2
  001e9	83 e0 01	 and	 eax, 1
  001ec	85 c0		 test	 eax, eax
  001ee	74 11		 je	 SHORT $LN17@cardrdr_qu
  001f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159200
  001f7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
  001ff	eb 0f		 jmp	 SHORT $LN18@cardrdr_qu
$LN17@cardrdr_qu:
  00201	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159201
  00208	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
$LN18@cardrdr_qu:
  00210	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00218	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0021e	c1 e8 03	 shr	 eax, 3
  00221	83 e0 01	 and	 eax, 1
  00224	85 c0		 test	 eax, eax
  00226	74 11		 je	 SHORT $LN19@cardrdr_qu
  00228	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159202
  0022f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv157[rsp], rax
  00237	eb 0f		 jmp	 SHORT $LN20@cardrdr_qu
$LN19@cardrdr_qu:
  00239	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159203
  00240	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv157[rsp], rax
$LN20@cardrdr_qu:
  00248	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00250	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00256	83 e0 01	 and	 eax, 1
  00259	85 c0		 test	 eax, eax
  0025b	74 11		 je	 SHORT $LN21@cardrdr_qu
  0025d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159204
  00264	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv162[rsp], rax
  0026c	eb 0f		 jmp	 SHORT $LN22@cardrdr_qu
$LN21@cardrdr_qu:
  0026e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159205
  00275	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv162[rsp], rax
$LN22@cardrdr_qu:
  0027d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00285	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  0028d	74 11		 je	 SHORT $LN23@cardrdr_qu
  0028f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159206
  00296	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  0029e	eb 0f		 jmp	 SHORT $LN24@cardrdr_qu
$LN23@cardrdr_qu:
  002a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159207
  002a7	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
$LN24@cardrdr_qu:
  002af	b8 01 00 00 00	 mov	 eax, 1
  002b4	48 6b c0 00	 imul	 rax, rax, 0
  002b8	0f be 84 04 b0
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  002c0	85 c0		 test	 eax, eax
  002c2	75 11		 jne	 SHORT $LN25@cardrdr_qu
  002c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159208
  002cb	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
  002d3	eb 10		 jmp	 SHORT $LN26@cardrdr_qu
$LN25@cardrdr_qu:
  002d5	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR filename$[rsp]
  002dd	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
$LN26@cardrdr_qu:
  002e5	48 63 84 24 f0
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  002ed	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002f5	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  002fc	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00301	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv129[rsp]
  00306	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0030b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv139[rsp]
  00310	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00315	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv145[rsp]
  0031a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0031f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv151[rsp]
  00327	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv157[rsp]
  00334	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00339	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv162[rsp]
  00341	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00346	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv166[rsp]
  0034e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00353	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR tv172[rsp]
  0035b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159209
  00362	48 8b d0	 mov	 rdx, rax
  00365	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0036d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@cardrdr_qu:
$LN8@cardrdr_qu:

; 401  :         ((filename[0] == '\0')      ? "*"          : (char*)filename),
; 402  :         (dev->bs                    ? " sockdev"   : ""),
; 403  :         (dev->multifile             ? " multifile" : ""),
; 404  :         (dev->ascii                 ? " ascii"     : ""),
; 405  :         (dev->ebcdic                ? " ebcdic"    : ""),
; 406  :         (dev->autopad               ? " autopad"   : ""),
; 407  :         ((dev->ascii && dev->trunc) ? " trunc"     : ""),
; 408  :         (dev->rdreof                ? " eof"       : " intrq"),
; 409  :         dev->excps );
; 410  : 
; 411  : } /* end function cardrdr_query_device */

  00373	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0037b	48 33 cc	 xor	 rcx, rsp
  0037e	e8 00 00 00 00	 call	 __security_check_cookie
  00383	48 81 c4 d8 01
	00 00		 add	 rsp, 472		; 000001d8H
  0038a	c3		 ret	 0
cardrdr_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cardrdr.c
_TEXT	SEGMENT
i$ = 96
fc$ = 100
sockdev$ = 104
tv166 = 108
tv172 = 112
tv280 = 116
tv286 = 120
tv313 = 124
tv319 = 128
tv365 = 132
tv371 = 136
tv399 = 140
tv405 = 144
tv453 = 148
tv459 = 152
tv481 = 156
tv487 = 160
tv508 = 164
tv514 = 168
tv541 = 172
tv547 = 176
tv583 = 180
tv589 = 184
attn$ = 188
tv152 = 192
tv273 = 200
tv304 = 208
tv356 = 216
tv535 = 224
tv574 = 232
buf$1 = 240
pathname$ = 288
__$ArrayPad$ = 560
dev$ = 592
argc$ = 600
argv$ = 608
cardrdr_init_handler PROC

; 82   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 83   : int     i;                              /* Array subscript           */
; 84   : int     fc;                             /* File counter              */
; 85   : char    pathname[MAX_PATH];             /* file path in host format  */
; 86   : int     sockdev = 0;

  00027	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR sockdev$[rsp], 0

; 87   : int     attn = 0;

  0002f	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR attn$[rsp], 0

; 88   : 
; 89   : 
; 90   :     /* Raise attention for re-init */
; 91   :     if(dev->devtype)

  0003a	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00042	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00046	85 c0		 test	 eax, eax
  00048	74 0b		 je	 SHORT $LN5@cardrdr_in

; 92   :         attn = 1;

  0004a	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR attn$[rsp], 1
$LN5@cardrdr_in:

; 93   : 
; 94   :     /* For re-initialisarion close the existing file */
; 95   :     if (dev->fd >= 0)

  00055	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005d	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00064	7c 1a		 jl	 SHORT $LN6@cardrdr_in

; 96   :         (dev->hnd->close)(dev);

  00066	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006e	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00075	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0007d	ff 50 10	 call	 QWORD PTR [rax+16]
$LN6@cardrdr_in:

; 97   : 
; 98   :     if (dev->bs)

  00080	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00088	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00090	74 1b		 je	 SHORT $LN7@cardrdr_in

; 99   :     {
; 100  :         if (!unbind_device(dev))

  00092	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009a	e8 00 00 00 00	 call	 unbind_device
  0009f	85 c0		 test	 eax, eax
  000a1	75 0a		 jne	 SHORT $LN8@cardrdr_in

; 101  :         {
; 102  :             // (error message already issued)
; 103  :             return -1;

  000a3	b8 ff ff ff ff	 mov	 eax, -1
  000a8	e9 0c 12 00 00	 jmp	 $LN1@cardrdr_in
$LN8@cardrdr_in:
$LN7@cardrdr_in:

; 104  :         }
; 105  :     }
; 106  : 
; 107  :     /* Initialize device dependent fields */
; 108  : 
; 109  :     dev->fd = -1;

  000ad	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b5	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 110  :     dev->fh = NULL;

  000bf	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c7	48 c7 80 b0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+432], 0

; 111  :     dev->multifile = 0;

  000d2	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000da	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  000e0	83 e0 fe	 and	 eax, -2			; fffffffeH
  000e3	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000eb	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 112  :     dev->ebcdic = 0;

  000f1	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f9	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  000ff	83 e0 fb	 and	 eax, -5			; fffffffbH
  00102	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010a	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 113  :     dev->ascii = 0;

  00110	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00118	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0011e	83 e0 f7	 and	 eax, -9			; fffffff7H
  00121	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00129	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 114  :     dev->trunc = 0;

  0012f	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00137	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0013d	83 e0 ef	 and	 eax, -17		; ffffffefH
  00140	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00148	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 115  :     dev->cardpos = 0;

  0014e	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00156	c7 80 f0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1776], 0

; 116  :     dev->cardrem = 0;

  00160	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00168	c7 80 f4 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1780], 0

; 117  :     dev->autopad = 0;

  00172	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00180	83 e0 df	 and	 eax, -33		; ffffffdfH
  00183	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018b	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 118  : 
; 119  :     dev->excps = 0;

  00191	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00199	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 120  : 
; 121  :     if(!sscanf(dev->typname,"%hx",&(dev->devtype)))

  001a4	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ac	48 83 c0 4a	 add	 rax, 74			; 0000004aH
  001b0	4c 8b c0	 mov	 r8, rax
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159083
  001ba	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c2	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  001c6	e8 00 00 00 00	 call	 sscanf
  001cb	85 c0		 test	 eax, eax
  001cd	75 11		 jne	 SHORT $LN9@cardrdr_in

; 122  :         dev->devtype = 0x2501;

  001cf	b8 01 25 00 00	 mov	 eax, 9473		; 00002501H
  001d4	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001dc	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax
$LN9@cardrdr_in:

; 123  : 
; 124  :     fc = 0;

  001e0	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR fc$[rsp], 0

; 125  : 
; 126  :     if (dev->more_files) free (dev->more_files);

  001e8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f0	48 83 b8 e0 06
	00 00 00	 cmp	 QWORD PTR [rax+1760], 0
  001f8	74 15		 je	 SHORT $LN10@cardrdr_in
  001fa	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00202	48 8b 88 e0 06
	00 00		 mov	 rcx, QWORD PTR [rax+1760]
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN10@cardrdr_in:

; 127  : 
; 128  :     dev->more_files = malloc(sizeof(char*) * (fc + 1));

  0020f	8b 44 24 64	 mov	 eax, DWORD PTR fc$[rsp]
  00213	ff c0		 inc	 eax
  00215	48 98		 cdqe
  00217	48 c1 e0 03	 shl	 rax, 3
  0021b	48 8b c8	 mov	 rcx, rax
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00224	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0022c	48 89 81 e0 06
	00 00		 mov	 QWORD PTR [rcx+1760], rax

; 129  : 
; 130  :     if (!dev->more_files)

  00233	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023b	48 83 b8 e0 06
	00 00 00	 cmp	 QWORD PTR [rax+1760], 0
  00243	0f 85 0c 01 00
	00		 jne	 $LN11@cardrdr_in

; 131  :     {
; 132  :         char buf[40];
; 133  :         MSGBUF(buf, "malloc(%d)", (int)(sizeof(char) * (fc + 1)) );

  00249	8b 44 24 64	 mov	 eax, DWORD PTR fc$[rsp]
  0024d	ff c0		 inc	 eax
  0024f	44 8b c8	 mov	 r9d, eax
  00252	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159086
  00259	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0025e	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00266	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 134  :         // "%1d:%04X %s: error in function %s: %s"
; 135  :         WRMSG( HHC01250, "E", LCSS_DEVNUM,

  0026c	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00275	74 12		 je	 SHORT $LN42@cardrdr_in
  00277	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0027f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00283	89 44 24 6c	 mov	 DWORD PTR tv166[rsp], eax
  00287	eb 08		 jmp	 SHORT $LN43@cardrdr_in
$LN42@cardrdr_in:
  00289	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN43@cardrdr_in:
  00291	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0029a	74 14		 je	 SHORT $LN44@cardrdr_in
  0029c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002a8	d1 f8		 sar	 eax, 1
  002aa	89 44 24 70	 mov	 DWORD PTR tv172[rsp], eax
  002ae	eb 08		 jmp	 SHORT $LN45@cardrdr_in
$LN44@cardrdr_in:
  002b0	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN45@cardrdr_in:
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002be	8b 08		 mov	 ecx, DWORD PTR [rax]
  002c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002c6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
  002ce	b9 01 00 00 00	 mov	 ecx, 1
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  002e1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002e6	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  002ee	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159087
  002fa	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002ff	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv166[rsp]
  00303	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00307	8b 4c 24 70	 mov	 ecx, DWORD PTR tv172[rsp]
  0030b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159088
  00316	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159089
  00322	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00327	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00332	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159090
  00339	ba 88 00 00 00	 mov	 edx, 136		; 00000088H
  0033e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159091
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 136  :             "Card", buf, strerror( errno ));
; 137  :         return -1;

  0034b	b8 ff ff ff ff	 mov	 eax, -1
  00350	e9 64 0f 00 00	 jmp	 $LN1@cardrdr_in
$LN11@cardrdr_in:

; 138  :     }
; 139  : 
; 140  :     dev->more_files[fc] = NULL;

  00355	48 63 44 24 64	 movsxd	 rax, DWORD PTR fc$[rsp]
  0035a	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00362	48 8b 89 e0 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1760]
  00369	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 141  : 
; 142  :     /* Process the driver arguments starting with the SECOND
; 143  :        argument. (The FIRST argument is the filename and is
; 144  :        checked later further below.) */
; 145  : 
; 146  :     for (i = 1; i < argc; i++)

  00371	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00379	eb 0a		 jmp	 SHORT $LN4@cardrdr_in
$LN2@cardrdr_in:
  0037b	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0037f	ff c0		 inc	 eax
  00381	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@cardrdr_in:
  00385	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0038c	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00390	0f 8d e1 05 00
	00		 jge	 $LN3@cardrdr_in

; 147  :     {
; 148  :         /* sockdev means the device file is actually
; 149  :            a connected socket instead of a disk file.
; 150  :            The file name is the socket_spec (host:port)
; 151  :            to listen for connections on. */
; 152  : 
; 153  :         if (strcasecmp(argv[i], "sockdev") == 0)

  00396	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0039b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159093
  003a2	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003aa	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  003ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003b4	85 c0		 test	 eax, eax
  003b6	75 0a		 jne	 SHORT $LN12@cardrdr_in

; 154  :         {
; 155  :             sockdev = 1;

  003b8	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR sockdev$[rsp], 1

; 156  :             continue;

  003c0	eb b9		 jmp	 SHORT $LN2@cardrdr_in
$LN12@cardrdr_in:

; 157  :         }
; 158  : 
; 159  :         /* multifile means to automatically open the next
; 160  :            i/p file if multiple i/p files are defined.   */
; 161  : 
; 162  :         if (strcasecmp(argv[i], "multifile") == 0)

  003c2	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  003c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159095
  003ce	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003d6	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  003da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003e0	85 c0		 test	 eax, eax
  003e2	75 24		 jne	 SHORT $LN13@cardrdr_in

; 163  :         {
; 164  :             dev->multifile = 1;

  003e4	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ec	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  003f2	83 c8 01	 or	 eax, 1
  003f5	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003fd	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 165  :             continue;

  00403	e9 73 ff ff ff	 jmp	 $LN2@cardrdr_in
$LN13@cardrdr_in:

; 166  :         }
; 167  : 
; 168  :         /* eof means that unit exception will be returned at
; 169  :            end of file, instead of intervention required */
; 170  : 
; 171  :         if (strcasecmp(argv[i], "eof") == 0)

  00408	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0040d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159097
  00414	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0041c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00420	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00426	85 c0		 test	 eax, eax
  00428	75 24		 jne	 SHORT $LN14@cardrdr_in

; 172  :         {
; 173  :             dev->rdreof = 1;

  0042a	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00432	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00438	83 c8 02	 or	 eax, 2
  0043b	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00443	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 174  :             continue;

  00449	e9 2d ff ff ff	 jmp	 $LN2@cardrdr_in
$LN14@cardrdr_in:

; 175  :         }
; 176  : 
; 177  :         /* intrq means that intervention required will be returned at
; 178  :            end of file, instead of unit exception */
; 179  : 
; 180  :         if (strcasecmp(argv[i], "intrq") == 0)

  0044e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00453	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159099
  0045a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00462	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0046c	85 c0		 test	 eax, eax
  0046e	75 24		 jne	 SHORT $LN15@cardrdr_in

; 181  :         {
; 182  :             dev->rdreof = 0;

  00470	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00478	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0047e	83 e0 fd	 and	 eax, -3			; fffffffdH
  00481	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00489	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 183  :             continue;

  0048f	e9 e7 fe ff ff	 jmp	 $LN2@cardrdr_in
$LN15@cardrdr_in:

; 184  :         }
; 185  : 
; 186  :         /* ebcdic means that the card image file consists of
; 187  :            fixed length 80-byte EBCDIC card images with no
; 188  :            line-end delimiters */
; 189  : 
; 190  :         if (strcasecmp(argv[i], "ebcdic") == 0)

  00494	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00499	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159101
  004a0	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004a8	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  004b2	85 c0		 test	 eax, eax
  004b4	75 24		 jne	 SHORT $LN16@cardrdr_in

; 191  :         {
; 192  :             dev->ebcdic = 1;

  004b6	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004be	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  004c4	83 c8 04	 or	 eax, 4
  004c7	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004cf	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 193  :             continue;

  004d5	e9 a1 fe ff ff	 jmp	 $LN2@cardrdr_in
$LN16@cardrdr_in:

; 194  :         }
; 195  : 
; 196  :         /* ascii means that the card image file consists of
; 197  :            variable length ASCII records delimited by either
; 198  :            line-feed or carriage-return line-feed sequences */
; 199  : 
; 200  :         if (strcasecmp(argv[i], "ascii") == 0)

  004da	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  004df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159103
  004e6	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004ee	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  004f8	85 c0		 test	 eax, eax
  004fa	75 24		 jne	 SHORT $LN17@cardrdr_in

; 201  :         {
; 202  :             dev->ascii = 1;

  004fc	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00504	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0050a	83 c8 08	 or	 eax, 8
  0050d	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00515	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 203  :             continue;

  0051b	e9 5b fe ff ff	 jmp	 $LN2@cardrdr_in
$LN17@cardrdr_in:

; 204  :         }
; 205  : 
; 206  :         /* trunc means that records longer than 80 bytes will
; 207  :            be silently truncated to 80 bytes when processing a
; 208  :            variable length ASCII file.  The default behaviour
; 209  :            is to present a data check if an overlength record
; 210  :            is encountered.  The trunc option is ignored except
; 211  :            when processing an ASCII card image file. */
; 212  : 
; 213  :         if (strcasecmp(argv[i], "trunc") == 0)

  00520	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00525	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159105
  0052c	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00534	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00538	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0053e	85 c0		 test	 eax, eax
  00540	75 24		 jne	 SHORT $LN18@cardrdr_in

; 214  :         {
; 215  :             dev->trunc = 1;

  00542	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0054a	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00550	83 c8 10	 or	 eax, 16
  00553	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0055b	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 216  :             continue;

  00561	e9 15 fe ff ff	 jmp	 $LN2@cardrdr_in
$LN18@cardrdr_in:

; 217  :         }
; 218  : 
; 219  :         /* autopad means that if reading fixed sized records
; 220  :          * (ebcdic) and end of file is reached in the middle of
; 221  :          * a record, the record is automatically padded to 80 bytes.
; 222  :          */
; 223  : 
; 224  :         if (strcasecmp(argv[i], "autopad") == 0)

  00566	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0056b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159107
  00572	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0057a	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0057e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00584	85 c0		 test	 eax, eax
  00586	75 24		 jne	 SHORT $LN19@cardrdr_in

; 225  :         {
; 226  :             dev->autopad = 1;

  00588	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00590	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00596	83 c8 20	 or	 eax, 32			; 00000020H
  00599	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005a1	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax

; 227  :             continue;

  005a7	e9 cf fd ff ff	 jmp	 $LN2@cardrdr_in
$LN19@cardrdr_in:

; 228  :         }
; 229  : 
; 230  :         // add additional file arguments
; 231  : 
; 232  :         if (strlen(argv[i]) >= sizeof(dev->filename))

  005ac	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  005b1	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005b9	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  005bd	e8 00 00 00 00	 call	 strlen
  005c2	48 3d 05 01 00
	00		 cmp	 rax, 261		; 00000105H
  005c8	0f 82 db 00 00
	00		 jb	 $LN20@cardrdr_in

; 233  :         {
; 234  :             WRMSG (HHC01201, "E", LCSS_DEVNUM, argv[i], (unsigned int)sizeof(dev->filename)-1);

  005ce	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005d7	74 12		 je	 SHORT $LN46@cardrdr_in
  005d9	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005e5	89 44 24 74	 mov	 DWORD PTR tv280[rsp], eax
  005e9	eb 08		 jmp	 SHORT $LN47@cardrdr_in
$LN46@cardrdr_in:
  005eb	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv280[rsp], 0
$LN47@cardrdr_in:
  005f3	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005fc	74 14		 je	 SHORT $LN48@cardrdr_in
  005fe	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00606	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0060a	d1 f8		 sar	 eax, 1
  0060c	89 44 24 78	 mov	 DWORD PTR tv286[rsp], eax
  00610	eb 08		 jmp	 SHORT $LN49@cardrdr_in
$LN48@cardrdr_in:
  00612	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv286[rsp], 0
$LN49@cardrdr_in:
  0061a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0061f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  00627	b9 01 00 00 00	 mov	 ecx, 1
  0062c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00632	c7 44 24 50 04
	01 00 00	 mov	 DWORD PTR [rsp+80], 260	; 00000104H
  0063a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00642	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv273[rsp]
  0064a	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0064e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00653	8b 4c 24 74	 mov	 ecx, DWORD PTR tv280[rsp]
  00657	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0065b	8b 4c 24 78	 mov	 ecx, DWORD PTR tv286[rsp]
  0065f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00663	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159109
  0066a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0066f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159110
  00676	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0067b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00680	41 b9 03 00 00
	00		 mov	 r9d, 3
  00686	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159111
  0068d	ba ea 00 00 00	 mov	 edx, 234		; 000000eaH
  00692	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159112
  00699	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 235  :             return -1;

  0069f	b8 ff ff ff ff	 mov	 eax, -1
  006a4	e9 10 0c 00 00	 jmp	 $LN1@cardrdr_in
$LN20@cardrdr_in:

; 236  :         }
; 237  : 
; 238  :         if (access(argv[i], R_OK | F_OK) != 0)

  006a9	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  006ae	ba 04 00 00 00	 mov	 edx, 4
  006b3	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006bb	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  006bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_access
  006c5	85 c0		 test	 eax, eax
  006c7	0f 84 f1 00 00
	00		 je	 $LN21@cardrdr_in

; 239  :         {
; 240  :             // "%1d:%04X %s: error in function %s: %s"
; 241  :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  006cd	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006d6	74 12		 je	 SHORT $LN50@cardrdr_in
  006d8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006e0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006e4	89 44 24 7c	 mov	 DWORD PTR tv313[rsp], eax
  006e8	eb 08		 jmp	 SHORT $LN51@cardrdr_in
$LN50@cardrdr_in:
  006ea	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv313[rsp], 0
$LN51@cardrdr_in:
  006f2	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006fb	74 17		 je	 SHORT $LN52@cardrdr_in
  006fd	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00705	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00709	d1 f8		 sar	 eax, 1
  0070b	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv319[rsp], eax
  00712	eb 0b		 jmp	 SHORT $LN53@cardrdr_in
$LN52@cardrdr_in:
  00714	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv319[rsp], 0
$LN53@cardrdr_in:
  0071f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00725	8b 08		 mov	 ecx, DWORD PTR [rax]
  00727	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0072d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv304[rsp], rax
  00735	b9 01 00 00 00	 mov	 ecx, 1
  0073a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00740	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv304[rsp]
  00748	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0074d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159114
  00754	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00759	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159115
  00760	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00765	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv313[rsp]
  00769	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0076d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv319[rsp]
  00774	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00778	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159116
  0077f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00784	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159117
  0078b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00790	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00795	41 b9 03 00 00
	00		 mov	 r9d, 3
  0079b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159118
  007a2	ba f2 00 00 00	 mov	 edx, 242		; 000000f2H
  007a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159119
  007ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 242  :                 "Card", "access()", strerror( errno ));
; 243  :             return -1;

  007b4	b8 ff ff ff ff	 mov	 eax, -1
  007b9	e9 fb 0a 00 00	 jmp	 $LN1@cardrdr_in
$LN21@cardrdr_in:

; 244  :         }
; 245  :         hostpath(pathname, argv[i], sizeof(pathname));

  007be	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  007c3	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  007c9	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007d1	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  007d5	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  007dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 246  :         dev->more_files[fc++] = strdup(pathname);

  007e3	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  007eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  007f1	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR fc$[rsp]
  007f6	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  007fe	48 8b 92 e0 06
	00 00		 mov	 rdx, QWORD PTR [rdx+1760]
  00805	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  00809	8b 44 24 64	 mov	 eax, DWORD PTR fc$[rsp]
  0080d	ff c0		 inc	 eax
  0080f	89 44 24 64	 mov	 DWORD PTR fc$[rsp], eax

; 247  :         dev->more_files = realloc(dev->more_files, sizeof(char*) * (fc + 1));

  00813	8b 44 24 64	 mov	 eax, DWORD PTR fc$[rsp]
  00817	ff c0		 inc	 eax
  00819	48 98		 cdqe
  0081b	48 c1 e0 03	 shl	 rax, 3
  0081f	48 8b d0	 mov	 rdx, rax
  00822	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0082a	48 8b 88 e0 06
	00 00		 mov	 rcx, QWORD PTR [rax+1760]
  00831	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00837	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0083f	48 89 81 e0 06
	00 00		 mov	 QWORD PTR [rcx+1760], rax

; 248  : 
; 249  :         if (!dev->more_files)

  00846	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0084e	48 83 b8 e0 06
	00 00 00	 cmp	 QWORD PTR [rax+1760], 0
  00856	0f 85 fa 00 00
	00		 jne	 $LN22@cardrdr_in

; 250  :         {
; 251  :             // "%1d:%04X %s: error in function %s: %s"
; 252  :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  0085c	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00865	74 15		 je	 SHORT $LN54@cardrdr_in
  00867	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0086f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00873	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv365[rsp], eax
  0087a	eb 0b		 jmp	 SHORT $LN55@cardrdr_in
$LN54@cardrdr_in:
  0087c	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv365[rsp], 0
$LN55@cardrdr_in:
  00887	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00890	74 17		 je	 SHORT $LN56@cardrdr_in
  00892	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0089a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0089e	d1 f8		 sar	 eax, 1
  008a0	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv371[rsp], eax
  008a7	eb 0b		 jmp	 SHORT $LN57@cardrdr_in
$LN56@cardrdr_in:
  008a9	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv371[rsp], 0
$LN57@cardrdr_in:
  008b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  008ba	8b 08		 mov	 ecx, DWORD PTR [rax]
  008bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  008c2	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
  008ca	b9 01 00 00 00	 mov	 ecx, 1
  008cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008d5	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv356[rsp]
  008dd	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  008e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159121
  008e9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  008ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159122
  008f5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008fa	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv365[rsp]
  00901	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00905	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv371[rsp]
  0090c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00910	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159123
  00917	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0091c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159124
  00923	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00928	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0092d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00933	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159125
  0093a	ba fd 00 00 00	 mov	 edx, 253		; 000000fdH
  0093f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159126
  00946	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 253  :                 "Card", "strdup()", strerror( errno ));
; 254  :             return -1;

  0094c	b8 ff ff ff ff	 mov	 eax, -1
  00951	e9 63 09 00 00	 jmp	 $LN1@cardrdr_in
$LN22@cardrdr_in:

; 255  :         }
; 256  : 
; 257  :         dev->more_files[fc] = NULL;

  00956	48 63 44 24 64	 movsxd	 rax, DWORD PTR fc$[rsp]
  0095b	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00963	48 8b 89 e0 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1760]
  0096a	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 258  :     }

  00972	e9 04 fa ff ff	 jmp	 $LN2@cardrdr_in
$LN3@cardrdr_in:

; 259  : 
; 260  :     dev->current_file = dev->more_files;

  00977	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0097f	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00987	48 8b 89 e0 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1760]
  0098e	48 89 88 e8 06
	00 00		 mov	 QWORD PTR [rax+1768], rcx

; 261  : 
; 262  :     /* Check for conflicting arguments */
; 263  : 
; 264  :     if (dev->ebcdic && dev->ascii)

  00995	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0099d	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  009a3	c1 e8 02	 shr	 eax, 2
  009a6	83 e0 01	 and	 eax, 1
  009a9	85 c0		 test	 eax, eax
  009ab	0f 84 db 00 00
	00		 je	 $LN23@cardrdr_in
  009b1	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009b9	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  009bf	c1 e8 03	 shr	 eax, 3
  009c2	83 e0 01	 and	 eax, 1
  009c5	85 c0		 test	 eax, eax
  009c7	0f 84 bf 00 00
	00		 je	 $LN23@cardrdr_in

; 265  :     {
; 266  :         WRMSG (HHC01202, "E", LCSS_DEVNUM);

  009cd	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  009d6	74 15		 je	 SHORT $LN58@cardrdr_in
  009d8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009e0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009e4	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv399[rsp], eax
  009eb	eb 0b		 jmp	 SHORT $LN59@cardrdr_in
$LN58@cardrdr_in:
  009ed	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv399[rsp], 0
$LN59@cardrdr_in:
  009f8	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00a01	74 17		 je	 SHORT $LN60@cardrdr_in
  00a03	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a0b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00a0f	d1 f8		 sar	 eax, 1
  00a11	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv405[rsp], eax
  00a18	eb 0b		 jmp	 SHORT $LN61@cardrdr_in
$LN60@cardrdr_in:
  00a1a	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv405[rsp], 0
$LN61@cardrdr_in:
  00a25	b9 01 00 00 00	 mov	 ecx, 1
  00a2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a30	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv399[rsp]
  00a37	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a3b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv405[rsp]
  00a42	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159128
  00a4d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159129
  00a59	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a5e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a63	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a69	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159130
  00a70	ba 0a 01 00 00	 mov	 edx, 266		; 0000010aH
  00a75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159131
  00a7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 267  :         return -1;

  00a82	b8 ff ff ff ff	 mov	 eax, -1
  00a87	e9 2d 08 00 00	 jmp	 $LN1@cardrdr_in
$LN23@cardrdr_in:

; 268  :     }
; 269  : 
; 270  :     if (sockdev)

  00a8c	83 7c 24 68 00	 cmp	 DWORD PTR sockdev$[rsp], 0
  00a91	0f 84 d6 01 00
	00		 je	 $LN24@cardrdr_in

; 271  :     {
; 272  :         if (fc)

  00a97	83 7c 24 64 00	 cmp	 DWORD PTR fc$[rsp], 0
  00a9c	0f 84 bf 00 00
	00		 je	 $LN25@cardrdr_in

; 273  :         {
; 274  :             WRMSG (HHC01203, "E", LCSS_DEVNUM);

  00aa2	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00aab	74 15		 je	 SHORT $LN62@cardrdr_in
  00aad	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ab5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ab9	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv453[rsp], eax
  00ac0	eb 0b		 jmp	 SHORT $LN63@cardrdr_in
$LN62@cardrdr_in:
  00ac2	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv453[rsp], 0
$LN63@cardrdr_in:
  00acd	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ad6	74 17		 je	 SHORT $LN64@cardrdr_in
  00ad8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ae0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00ae4	d1 f8		 sar	 eax, 1
  00ae6	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv459[rsp], eax
  00aed	eb 0b		 jmp	 SHORT $LN65@cardrdr_in
$LN64@cardrdr_in:
  00aef	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv459[rsp], 0
$LN65@cardrdr_in:
  00afa	b9 01 00 00 00	 mov	 ecx, 1
  00aff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b05	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv453[rsp]
  00b0c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b10	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv459[rsp]
  00b17	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159134
  00b22	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b27	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159135
  00b2e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b33	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b38	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b3e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159136
  00b45	ba 12 01 00 00	 mov	 edx, 274		; 00000112H
  00b4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159137
  00b51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 275  :             return -1;

  00b57	b8 ff ff ff ff	 mov	 eax, -1
  00b5c	e9 58 07 00 00	 jmp	 $LN1@cardrdr_in
$LN25@cardrdr_in:

; 276  :         }
; 277  : 
; 278  :         // If neither ascii nor ebcdic is specified, default to ascii.
; 279  :         // This is required for socket devices because the open logic,
; 280  :         // if neither is specified, attempts to determine whether the data
; 281  :         // is actually ascii or ebcdic by reading the 1st 160 bytes of
; 282  :         // data and then rewinding to the beginning of the file afterwards.
; 283  :         //  Since you can't "rewind" a socket, we must therefore default
; 284  :         // to one of them.
; 285  : 
; 286  :         if (!dev->ebcdic && !dev->ascii)

  00b61	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b69	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00b6f	c1 e8 02	 shr	 eax, 2
  00b72	83 e0 01	 and	 eax, 1
  00b75	85 c0		 test	 eax, eax
  00b77	0f 85 f0 00 00
	00		 jne	 $LN26@cardrdr_in
  00b7d	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b85	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00b8b	c1 e8 03	 shr	 eax, 3
  00b8e	83 e0 01	 and	 eax, 1
  00b91	85 c0		 test	 eax, eax
  00b93	0f 85 d4 00 00
	00		 jne	 $LN26@cardrdr_in

; 287  :         {
; 288  :             WRMSG (HHC01204, "I", LCSS_DEVNUM);

  00b99	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ba2	74 15		 je	 SHORT $LN66@cardrdr_in
  00ba4	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bac	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00bb0	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv481[rsp], eax
  00bb7	eb 0b		 jmp	 SHORT $LN67@cardrdr_in
$LN66@cardrdr_in:
  00bb9	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv481[rsp], 0
$LN67@cardrdr_in:
  00bc4	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00bcd	74 17		 je	 SHORT $LN68@cardrdr_in
  00bcf	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bd7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00bdb	d1 f8		 sar	 eax, 1
  00bdd	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv487[rsp], eax
  00be4	eb 0b		 jmp	 SHORT $LN69@cardrdr_in
$LN68@cardrdr_in:
  00be6	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv487[rsp], 0
$LN69@cardrdr_in:
  00bf1	b9 01 00 00 00	 mov	 ecx, 1
  00bf6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bfc	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv481[rsp]
  00c03	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c07	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv487[rsp]
  00c0e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159139
  00c19	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159140
  00c25	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c2a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c2f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c35	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159141
  00c3c	ba 20 01 00 00	 mov	 edx, 288		; 00000120H
  00c41	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159142
  00c48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 289  :             dev->ascii = 1;

  00c4e	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c56	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00c5c	83 c8 08	 or	 eax, 8
  00c5f	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c67	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax
$LN26@cardrdr_in:
$LN24@cardrdr_in:

; 290  :         }
; 291  :     }
; 292  : 
; 293  :     if (dev->multifile && !fc)

  00c6d	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c75	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00c7b	83 e0 01	 and	 eax, 1
  00c7e	85 c0		 test	 eax, eax
  00c80	0f 84 df 00 00
	00		 je	 $LN27@cardrdr_in
  00c86	83 7c 24 64 00	 cmp	 DWORD PTR fc$[rsp], 0
  00c8b	0f 85 d4 00 00
	00		 jne	 $LN27@cardrdr_in

; 294  :     {
; 295  :         WRMSG (HHC01205, "W", LCSS_DEVNUM);

  00c91	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c9a	74 15		 je	 SHORT $LN70@cardrdr_in
  00c9c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ca4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ca8	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv508[rsp], eax
  00caf	eb 0b		 jmp	 SHORT $LN71@cardrdr_in
$LN70@cardrdr_in:
  00cb1	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv508[rsp], 0
$LN71@cardrdr_in:
  00cbc	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00cc5	74 17		 je	 SHORT $LN72@cardrdr_in
  00cc7	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ccf	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00cd3	d1 f8		 sar	 eax, 1
  00cd5	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv514[rsp], eax
  00cdc	eb 0b		 jmp	 SHORT $LN73@cardrdr_in
$LN72@cardrdr_in:
  00cde	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv514[rsp], 0
$LN73@cardrdr_in:
  00ce9	b9 01 00 00 00	 mov	 ecx, 1
  00cee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cf4	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv508[rsp]
  00cfb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cff	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv514[rsp]
  00d06	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159144
  00d11	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159145
  00d1d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d22	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d27	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d2d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159146
  00d34	ba 27 01 00 00	 mov	 edx, 295		; 00000127H
  00d39	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159147
  00d40	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 296  :         dev->multifile = 0;

  00d46	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d4e	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  00d54	83 e0 fe	 and	 eax, -2			; fffffffeH
  00d57	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d5f	89 81 f8 06 00
	00		 mov	 DWORD PTR [rcx+1784], eax
$LN27@cardrdr_in:

; 297  :     }
; 298  : 
; 299  :     /* The first argument is the file name */
; 300  : 
; 301  :     if (argc > 0)

  00d65	83 bc 24 58 02
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00d6d	0f 8e bb 02 00
	00		 jle	 $LN28@cardrdr_in

; 302  :     {
; 303  :         /* Check for valid file name */
; 304  : 
; 305  :         if (strlen(argv[0]) >= sizeof(dev->filename))

  00d73	b8 08 00 00 00	 mov	 eax, 8
  00d78	48 6b c0 00	 imul	 rax, rax, 0
  00d7c	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00d84	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00d88	e8 00 00 00 00	 call	 strlen
  00d8d	48 3d 05 01 00
	00		 cmp	 rax, 261		; 00000105H
  00d93	0f 82 f1 00 00
	00		 jb	 $LN30@cardrdr_in

; 306  :         {
; 307  :             WRMSG (HHC01201, "E", LCSS_DEVNUM, argv[0], (unsigned int)sizeof(dev->filename)-1);

  00d99	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00da2	74 15		 je	 SHORT $LN74@cardrdr_in
  00da4	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dac	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00db0	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv541[rsp], eax
  00db7	eb 0b		 jmp	 SHORT $LN75@cardrdr_in
$LN74@cardrdr_in:
  00db9	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv541[rsp], 0
$LN75@cardrdr_in:
  00dc4	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00dcd	74 17		 je	 SHORT $LN76@cardrdr_in
  00dcf	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dd7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00ddb	d1 f8		 sar	 eax, 1
  00ddd	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv547[rsp], eax
  00de4	eb 0b		 jmp	 SHORT $LN77@cardrdr_in
$LN76@cardrdr_in:
  00de6	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv547[rsp], 0
$LN77@cardrdr_in:
  00df1	b8 08 00 00 00	 mov	 eax, 8
  00df6	48 6b c0 00	 imul	 rax, rax, 0
  00dfa	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv535[rsp], rax
  00e02	b9 01 00 00 00	 mov	 ecx, 1
  00e07	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e0d	c7 44 24 50 04
	01 00 00	 mov	 DWORD PTR [rsp+80], 260	; 00000104H
  00e15	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00e1d	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR tv535[rsp]
  00e25	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00e29	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e2e	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv541[rsp]
  00e35	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e39	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv547[rsp]
  00e40	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e44	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159151
  00e4b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159152
  00e57	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e5c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e61	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e67	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159153
  00e6e	ba 33 01 00 00	 mov	 edx, 307		; 00000133H
  00e73	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159154
  00e7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 308  :             return -1;

  00e80	b8 ff ff ff ff	 mov	 eax, -1
  00e85	e9 2f 04 00 00	 jmp	 $LN1@cardrdr_in
$LN30@cardrdr_in:

; 309  :         }
; 310  : 
; 311  :         if (!sockdev)

  00e8a	83 7c 24 68 00	 cmp	 DWORD PTR sockdev$[rsp], 0
  00e8f	0f 85 67 01 00
	00		 jne	 $LN31@cardrdr_in

; 312  :         {
; 313  :             /* Check for specification of no file mounted on reader */
; 314  :             if (argv[0][0] == '*')

  00e95	b8 08 00 00 00	 mov	 eax, 8
  00e9a	48 6b c0 00	 imul	 rax, rax, 0
  00e9e	b9 01 00 00 00	 mov	 ecx, 1
  00ea3	48 6b c9 00	 imul	 rcx, rcx, 0
  00ea7	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00eaf	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00eb3	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00eb7	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00eba	75 1e		 jne	 SHORT $LN32@cardrdr_in

; 315  :             {
; 316  :                 dev->filename[0] = '\0';

  00ebc	b8 01 00 00 00	 mov	 eax, 1
  00ec1	48 6b c0 00	 imul	 rax, rax, 0
  00ec5	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ecd	c6 84 01 a4 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+164], 0

; 317  :             }

  00ed5	e9 22 01 00 00	 jmp	 $LN33@cardrdr_in
$LN32@cardrdr_in:

; 318  :             else if (access(argv[0], R_OK | F_OK) != 0)

  00eda	b8 08 00 00 00	 mov	 eax, 8
  00edf	48 6b c0 00	 imul	 rax, rax, 0
  00ee3	ba 04 00 00 00	 mov	 edx, 4
  00ee8	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00ef0	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00ef4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_access
  00efa	85 c0		 test	 eax, eax
  00efc	0f 84 fa 00 00
	00		 je	 $LN34@cardrdr_in

; 319  :             {
; 320  :                 // "%1d:%04X %s: error in function %s: %s"
; 321  :                 WRMSG( HHC01250, "E", LCSS_DEVNUM,

  00f02	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f0b	74 15		 je	 SHORT $LN78@cardrdr_in
  00f0d	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f15	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00f19	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv583[rsp], eax
  00f20	eb 0b		 jmp	 SHORT $LN79@cardrdr_in
$LN78@cardrdr_in:
  00f22	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv583[rsp], 0
$LN79@cardrdr_in:
  00f2d	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f36	74 17		 je	 SHORT $LN80@cardrdr_in
  00f38	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f40	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00f44	d1 f8		 sar	 eax, 1
  00f46	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv589[rsp], eax
  00f4d	eb 0b		 jmp	 SHORT $LN81@cardrdr_in
$LN80@cardrdr_in:
  00f4f	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv589[rsp], 0
$LN81@cardrdr_in:
  00f5a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00f60	8b 08		 mov	 ecx, DWORD PTR [rax]
  00f62	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00f68	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv574[rsp], rax
  00f70	b9 01 00 00 00	 mov	 ecx, 1
  00f75	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f7b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv574[rsp]
  00f83	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00f88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159159
  00f8f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00f94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159160
  00f9b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00fa0	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv583[rsp]
  00fa7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00fab	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv589[rsp]
  00fb2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00fb6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159161
  00fbd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fc2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159162
  00fc9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fd3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fd9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159163
  00fe0	ba 42 01 00 00	 mov	 edx, 322		; 00000142H
  00fe5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159164
  00fec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 322  :                     "Card", "access()", strerror( errno ));
; 323  :                 return -1;

  00ff2	b8 ff ff ff ff	 mov	 eax, -1
  00ff7	e9 bd 02 00 00	 jmp	 $LN1@cardrdr_in
$LN34@cardrdr_in:
$LN33@cardrdr_in:
$LN31@cardrdr_in:

; 324  :             }
; 325  :         }
; 326  : 
; 327  :         /* Save the file name in the device block */
; 328  :         hostpath(dev->filename, argv[0], sizeof(dev->filename));

  00ffc	b8 08 00 00 00	 mov	 eax, 8
  01001	48 6b c0 00	 imul	 rax, rax, 0
  01005	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0100d	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  01014	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0101a	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  01022	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  01026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 329  :     }

  0102c	eb 19		 jmp	 SHORT $LN29@cardrdr_in
$LN28@cardrdr_in:

; 330  :     else
; 331  :     {
; 332  :         dev->filename[0] = '\0';

  0102e	b8 01 00 00 00	 mov	 eax, 1
  01033	48 6b c0 00	 imul	 rax, rax, 0
  01037	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0103f	c6 84 01 a4 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+164], 0
$LN29@cardrdr_in:

; 333  :     }
; 334  : 
; 335  :     /* Set size of i/o buffer */
; 336  :     dev->bufsize = CARD_SIZE;

  01047	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0104f	c7 80 d8 01 00
	00 50 00 00 00	 mov	 DWORD PTR [rax+472], 80	; 00000050H

; 337  : 
; 338  :     if (sockdev && dev->ascii)

  01059	83 7c 24 68 00	 cmp	 DWORD PTR sockdev$[rsp], 0
  0105e	74 71		 je	 SHORT $LN35@cardrdr_in
  01060	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01068	8b 80 f8 06 00
	00		 mov	 eax, DWORD PTR [rax+1784]
  0106e	c1 e8 03	 shr	 eax, 3
  01071	83 e0 01	 and	 eax, 1
  01074	85 c0		 test	 eax, eax
  01076	74 59		 je	 SHORT $LN35@cardrdr_in

; 339  :     {
; 340  :         /* Allocate extra room for socket i/o buffer */
; 341  :         dev->bufsize += (TRAY_CARDS * CARD_SIZE);

  01078	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01080	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  01086	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  0108b	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01093	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 342  :         dev->buflen = dev->bufsize;

  01099	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010a1	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010a9	8b 89 d8 01 00
	00		 mov	 ecx, DWORD PTR [rcx+472]
  010af	89 88 dc 01 00
	00		 mov	 DWORD PTR [rax+476], ecx

; 343  :         dev->bufoff = dev->buflen;

  010b5	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010bd	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010c5	8b 89 dc 01 00
	00		 mov	 ecx, DWORD PTR [rcx+476]
  010cb	89 88 e0 01 00
	00		 mov	 DWORD PTR [rax+480], ecx
$LN35@cardrdr_in:

; 344  :     }
; 345  : 
; 346  :     /* Set number of sense bytes */
; 347  : 
; 348  :     /* ISW 20030307 : Empirical knowledge : DOS/VS R34 Erep */
; 349  :     /*                indicates 4 bytes in 3505 sense       */
; 350  :     dev->numsense = 4;

  010d1	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010d9	c7 80 60 03 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+864], 4

; 351  : 
; 352  :     /* Initialize the device identifier bytes */
; 353  : 
; 354  :     dev->devid[0] = 0xFF;

  010e3	b8 01 00 00 00	 mov	 eax, 1
  010e8	48 6b c0 00	 imul	 rax, rax, 0
  010ec	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010f4	c6 84 01 68 04
	00 00 ff	 mov	 BYTE PTR [rcx+rax+1128], 255 ; 000000ffH

; 355  :     if (0x3505 == dev->devtype || 0x2501 == dev->devtype)

  010fc	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01104	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01108	3d 05 35 00 00	 cmp	 eax, 13573		; 00003505H
  0110d	74 13		 je	 SHORT $LN38@cardrdr_in
  0110f	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01117	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0111b	3d 01 25 00 00	 cmp	 eax, 9473		; 00002501H
  01120	75 4d		 jne	 SHORT $LN36@cardrdr_in
$LN38@cardrdr_in:

; 356  :     {
; 357  :         dev->devid[1] = dev->devtype >> 8;

  01122	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0112a	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0112e	c1 f8 08	 sar	 eax, 8
  01131	b9 01 00 00 00	 mov	 ecx, 1
  01136	48 6b c9 01	 imul	 rcx, rcx, 1
  0113a	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01142	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 358  :         dev->devid[2] = dev->devtype;

  01149	b8 01 00 00 00	 mov	 eax, 1
  0114e	48 6b c0 02	 imul	 rax, rax, 2
  01152	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0115a	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01162	0f b6 52 4a	 movzx	 edx, BYTE PTR [rdx+74]
  01166	88 94 01 68 04
	00 00		 mov	 BYTE PTR [rcx+rax+1128], dl

; 359  :     }

  0116d	eb 32		 jmp	 SHORT $LN37@cardrdr_in
$LN36@cardrdr_in:

; 360  :     else                              /* 2540 and unknown            */
; 361  :     {
; 362  :         dev->devid[1] = 0x28;         /* Control unit type is 2821-1 */

  0116f	b8 01 00 00 00	 mov	 eax, 1
  01174	48 6b c0 01	 imul	 rax, rax, 1
  01178	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01180	c6 84 01 68 04
	00 00 28	 mov	 BYTE PTR [rcx+rax+1128], 40 ; 00000028H

; 363  :         dev->devid[2] = 0x21;

  01188	b8 01 00 00 00	 mov	 eax, 1
  0118d	48 6b c0 02	 imul	 rax, rax, 2
  01191	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01199	c6 84 01 68 04
	00 00 21	 mov	 BYTE PTR [rcx+rax+1128], 33 ; 00000021H
$LN37@cardrdr_in:

; 364  :     }
; 365  :     dev->devid[3] = 0x01;

  011a1	b8 01 00 00 00	 mov	 eax, 1
  011a6	48 6b c0 03	 imul	 rax, rax, 3
  011aa	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011b2	c6 84 01 68 04
	00 00 01	 mov	 BYTE PTR [rcx+rax+1128], 1

; 366  :     dev->devid[4] = dev->devtype >> 8;

  011ba	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011c2	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  011c6	c1 f8 08	 sar	 eax, 8
  011c9	b9 01 00 00 00	 mov	 ecx, 1
  011ce	48 6b c9 04	 imul	 rcx, rcx, 4
  011d2	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  011da	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 367  :     dev->devid[5] = dev->devtype & 0xFF;

  011e1	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011e9	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  011ed	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  011f2	b9 01 00 00 00	 mov	 ecx, 1
  011f7	48 6b c9 05	 imul	 rcx, rcx, 5
  011fb	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01203	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 368  :     dev->devid[6] = 0x01;

  0120a	b8 01 00 00 00	 mov	 eax, 1
  0120f	48 6b c0 06	 imul	 rax, rax, 6
  01213	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0121b	c6 84 01 68 04
	00 00 01	 mov	 BYTE PTR [rcx+rax+1128], 1

; 369  :     dev->numdevid = 7;

  01223	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0122b	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 370  : 
; 371  :     // If socket device, create a listening socket
; 372  :     // to accept connections on.
; 373  : 
; 374  :     if(attn)

  01235	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR attn$[rsp], 0
  0123d	74 48		 je	 SHORT $LN39@cardrdr_in

; 375  :     {
; 376  :         release_lock (&dev->lock);

  0123f	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01247	48 83 c0 38	 add	 rax, 56			; 00000038H
  0124b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159170
  01252	48 8b c8	 mov	 rcx, rax
  01255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 377  :         device_attention (dev, CSW_DE);

  0125b	b2 04		 mov	 dl, 4
  0125d	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01265	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention

; 378  :         obtain_lock (&dev->lock);

  0126b	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01273	48 83 c0 38	 add	 rax, 56			; 00000038H
  01277	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159171
  0127e	48 8b c8	 mov	 rcx, rax
  01281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN39@cardrdr_in:

; 379  :     }
; 380  : 
; 381  :     if (sockdev && !bind_device(dev,dev->filename))

  01287	83 7c 24 68 00	 cmp	 DWORD PTR sockdev$[rsp], 0
  0128c	74 29		 je	 SHORT $LN40@cardrdr_in
  0128e	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01296	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0129c	48 8b d0	 mov	 rdx, rax
  0129f	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012a7	e8 00 00 00 00	 call	 bind_device
  012ac	85 c0		 test	 eax, eax
  012ae	75 07		 jne	 SHORT $LN40@cardrdr_in

; 382  :     {
; 383  :         // (error message already issued)
; 384  :         return -1;

  012b0	b8 ff ff ff ff	 mov	 eax, -1
  012b5	eb 02		 jmp	 SHORT $LN1@cardrdr_in
$LN40@cardrdr_in:

; 385  :     }
; 386  : 
; 387  :     return 0;

  012b7	33 c0		 xor	 eax, eax
$LN1@cardrdr_in:

; 388  : } /* end function cardrdr_init_handler */

  012b9	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  012c1	48 33 cc	 xor	 rcx, rsp
  012c4	e8 00 00 00 00	 call	 __security_check_cookie
  012c9	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  012d0	c3		 ret	 0
cardrdr_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.h
_TEXT	SEGMENT
dev$ = 48
unbind_device PROC

; 54   : static inline int unbind_device    (DEVBLK* dev)             { return unbind_device_ex ( dev, 0 );                }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00010	e8 00 00 00 00	 call	 unbind_device_ex
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
unbind_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.h
_TEXT	SEGMENT
dev$ = 48
spec$ = 56
bind_device PROC

; 53   : static inline int bind_device      (DEVBLK* dev, char* spec) { return bind_device_ex   ( dev, spec, NULL, NULL ); }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c9	 xor	 r9d, r9d
  00011	45 33 c0	 xor	 r8d, r8d
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR spec$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0001e	e8 00 00 00 00	 call	 bind_device_ex
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
bind_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
