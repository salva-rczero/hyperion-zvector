; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	w32_open_tape
PUBLIC	w32_define_BOT
PUBLIC	w32_ioctl_tape
PUBLIC	w32_close_tape
PUBLIC	w32_read_tape
PUBLIC	w32_write_tape
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp__errno:PROC
EXTRN	memchr:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_WriteFile:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_SetTapePosition:PROC
EXTRN	__imp_GetTapePosition:PROC
EXTRN	__imp_PrepareTape:PROC
EXTRN	__imp_EraseTape:PROC
EXTRN	__imp_WriteTapemark:PROC
EXTRN	__imp_GetTapeStatus:PROC
EXTRN	__imp_GetTapeParameters:PROC
EXTRN	__imp_SetTapeParameters:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_w32_trans_w32error:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
g_ifds	DB	020H DUP (?)
g_handles DQ	020H DUP (?)
g_fnames DQ	020H DUP (?)
g_fstats DD	020H DUP (?)
g_BOTmsk DD	020H DUP (?)
g_BOTbot DD	020H DUP (?)
g_drive_parms DB 0400H DUP (?)
g_lock	DQ	01H DUP (?)
?bDidInit@?1??obtain_w32stape_lock@@9@9 DD 01H DUP (?)	; `obtain_w32stape_lock'::`2'::bDidInit
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$w32_open_tape DD imagerel $LN75
	DD	imagerel $LN75+1651
	DD	imagerel $unwind$w32_open_tape
$pdata$w32_define_BOT DD imagerel $LN5
	DD	imagerel $LN5+179
	DD	imagerel $unwind$w32_define_BOT
$pdata$w32_ioctl_tape DD imagerel $LN12
	DD	imagerel $LN12+530
	DD	imagerel $unwind$w32_ioctl_tape
$pdata$w32_close_tape DD imagerel $LN17
	DD	imagerel $LN17+485
	DD	imagerel $unwind$w32_close_tape
$pdata$w32_read_tape DD imagerel $LN50
	DD	imagerel $LN50+870
	DD	imagerel $unwind$w32_read_tape
$pdata$w32_write_tape DD imagerel $LN40
	DD	imagerel $LN40+735
	DD	imagerel $unwind$w32_write_tape
$pdata$obtain_w32stape_lock DD imagerel obtain_w32stape_lock
	DD	imagerel obtain_w32stape_lock+231
	DD	imagerel $unwind$obtain_w32stape_lock
$pdata$w32_alloc_ifd DD imagerel w32_alloc_ifd
	DD	imagerel w32_alloc_ifd+155
	DD	imagerel $unwind$w32_alloc_ifd
$pdata$w32_free_ifd_nolock DD imagerel w32_free_ifd_nolock
	DD	imagerel w32_free_ifd_nolock+114
	DD	imagerel $unwind$w32_free_ifd_nolock
$pdata$w32_free_ifd DD imagerel w32_free_ifd
	DD	imagerel w32_free_ifd+75
	DD	imagerel $unwind$w32_free_ifd
$pdata$w32_get_tape_status DD imagerel w32_get_tape_status
	DD	imagerel w32_get_tape_status+43
	DD	imagerel $unwind$w32_get_tape_status
$pdata$w32_internal_rc DD imagerel w32_internal_rc
	DD	imagerel w32_internal_rc+855
	DD	imagerel $unwind$w32_internal_rc
$pdata$w32_internal_mtop DD imagerel w32_internal_mtop
	DD	imagerel w32_internal_mtop+2052
	DD	imagerel $unwind$w32_internal_mtop
$pdata$w32_internal_mtget DD imagerel w32_internal_mtget
	DD	imagerel w32_internal_mtget+1058
	DD	imagerel $unwind$w32_internal_mtget
$pdata$w32_internal_mtpos DD imagerel w32_internal_mtpos
	DD	imagerel w32_internal_mtpos+470
	DD	imagerel $unwind$w32_internal_mtpos
pdata	ENDS
_DATA	SEGMENT
?bInitBusy@?1??obtain_w32stape_lock@@9@9 DD 01H		; `obtain_w32stape_lock'::`2'::bInitBusy
$SG169318 DB	'nst', 00H
$SG169214 DB	'w32stape.c:61', 00H
	ORG $+2
$SG169215 DB	'&g_lock', 00H
$SG169216 DB	'w32stape.c:71', 00H
	ORG $+2
$SG169225 DB	'w32stape.c:99', 00H
	ORG $+2
$SG169239 DB	'w32stape.c:137', 00H
	ORG $+1
$SG169313 DB	'\\.\', 00H
	ORG $+3
$SG169316 DB	'/dev/', 00H
	ORG $+2
$SG169319 DB	'st', 00H
	ORG $+5
$SG169320 DB	'\\.\Tape0', 00H
	ORG $+6
$SG169322 DB	'w32_open_tape', 00H
	ORG $+2
$SG169323 DB	'w32stape.c', 00H
	ORG $+13
$SG169324 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169326 DB	'w32_open_tape', 00H
	ORG $+2
$SG169327 DB	'w32stape.c', 00H
	ORG $+13
$SG169328 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169332 DB	'w32_open_tape', 00H
	ORG $+2
$SG169333 DB	'w32stape.c', 00H
	ORG $+13
$SG169334 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169336 DB	'w32_open_tape', 00H
	ORG $+2
$SG169337 DB	'w32stape.c', 00H
	ORG $+13
$SG169338 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169343 DB	'w32_open_tape', 00H
	ORG $+2
$SG169344 DB	'w32stape.c', 00H
	ORG $+13
$SG169345 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169347 DB	'w32_open_tape', 00H
	ORG $+2
$SG169348 DB	'w32stape.c', 00H
	ORG $+13
$SG169349 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169354 DB	'w32_open_tape', 00H
	ORG $+2
$SG169355 DB	'w32stape.c', 00H
	ORG $+13
$SG169356 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169358 DB	'w32_open_tape', 00H
	ORG $+2
$SG169359 DB	'w32stape.c', 00H
	ORG $+13
$SG169360 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169363 DB	'w32_open_tape', 00H
	ORG $+2
$SG169364 DB	'w32stape.c', 00H
	ORG $+13
$SG169365 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169367 DB	'w32_open_tape', 00H
	ORG $+2
$SG169368 DB	'w32stape.c', 00H
	ORG $+13
$SG169369 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169372 DB	'w32_open_tape', 00H
	ORG $+2
$SG169373 DB	'w32stape.c', 00H
	ORG $+13
$SG169374 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169376 DB	'w32_open_tape', 00H
	ORG $+2
$SG169377 DB	'w32stape.c', 00H
	ORG $+13
$SG169378 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169391 DB	'w32stape.c:335', 00H
	ORG $+1
$SG169392 DB	'w32stape.c:343', 00H
	ORG $+1
$SG169406 DB	'w32_internal_rc', 00H
$SG169407 DB	'w32stape.c', 00H
	ORG $+13
$SG169408 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169410 DB	'w32_internal_rc', 00H
$SG169411 DB	'w32stape.c', 00H
	ORG $+13
$SG169412 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169478 DB	'w32_close_tape', 00H
	ORG $+1
$SG169479 DB	'w32stape.c', 00H
	ORG $+13
$SG169480 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169482 DB	'w32_close_tape', 00H
	ORG $+1
$SG169483 DB	'w32stape.c', 00H
	ORG $+13
$SG169484 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169486 DB	'w32stape.c:580', 00H
	ORG $+1
$SG169535 DB	'w32stape.c:613', 00H
	ORG $+1
$SG169536 DB	'w32stape.c:618', 00H
	ORG $+1
$SG169541 DB	'w32_read_tape', 00H
	ORG $+2
$SG169542 DB	'w32stape.c', 00H
	ORG $+13
$SG169543 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169545 DB	'w32_read_tape', 00H
	ORG $+2
$SG169546 DB	'w32stape.c', 00H
	ORG $+13
$SG169547 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169551 DB	'w32_read_tape', 00H
	ORG $+2
$SG169552 DB	'w32stape.c', 00H
	ORG $+13
$SG169553 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169555 DB	'w32_read_tape', 00H
	ORG $+2
$SG169556 DB	'w32stape.c', 00H
	ORG $+13
$SG169557 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169561 DB	'w32_read_tape', 00H
	ORG $+2
$SG169562 DB	'w32stape.c', 00H
	ORG $+13
$SG169563 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169565 DB	'w32_read_tape', 00H
	ORG $+2
$SG169566 DB	'w32stape.c', 00H
	ORG $+13
$SG169567 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169570 DB	'w32_read_tape', 00H
	ORG $+2
$SG169571 DB	'w32stape.c', 00H
	ORG $+13
$SG169572 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169574 DB	'w32_read_tape', 00H
	ORG $+2
$SG169575 DB	'w32stape.c', 00H
	ORG $+13
$SG169576 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169621 DB	'w32stape.c:687', 00H
	ORG $+1
$SG169622 DB	'w32stape.c:692', 00H
	ORG $+1
$SG169627 DB	'w32_write_tape', 00H
	ORG $+1
$SG169628 DB	'w32stape.c', 00H
	ORG $+13
$SG169629 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169631 DB	'w32_write_tape', 00H
	ORG $+1
$SG169632 DB	'w32stape.c', 00H
	ORG $+13
$SG169633 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169636 DB	'w32_write_tape', 00H
	ORG $+1
$SG169637 DB	'w32stape.c', 00H
	ORG $+13
$SG169638 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169640 DB	'w32_write_tape', 00H
	ORG $+1
$SG169641 DB	'w32stape.c', 00H
	ORG $+13
$SG169642 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169646 DB	'w32_write_tape', 00H
	ORG $+1
$SG169647 DB	'w32stape.c', 00H
	ORG $+13
$SG169648 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169650 DB	'w32_write_tape', 00H
	ORG $+1
$SG169651 DB	'w32stape.c', 00H
	ORG $+13
$SG169652 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169693 DB	'w32stape.c:745', 00H
	ORG $+1
$SG169694 DB	'w32stape.c:750', 00H
	ORG $+1
$SG169756 DB	'w32_internal_mtop', 00H
	ORG $+6
$SG169757 DB	'w32stape.c', 00H
	ORG $+5
$SG169758 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169760 DB	'w32_internal_mtop', 00H
	ORG $+6
$SG169761 DB	'w32stape.c', 00H
	ORG $+5
$SG169762 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169824 DB	'w32_internal_mtget', 00H
	ORG $+5
$SG169825 DB	'w32stape.c', 00H
	ORG $+5
$SG169826 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169828 DB	'w32_internal_mtget', 00H
	ORG $+5
$SG169829 DB	'w32stape.c', 00H
	ORG $+5
$SG169830 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169837 DB	'w32_internal_mtget', 00H
	ORG $+5
$SG169838 DB	'w32stape.c', 00H
	ORG $+5
$SG169839 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169841 DB	'w32_internal_mtget', 00H
	ORG $+5
$SG169842 DB	'w32stape.c', 00H
	ORG $+5
$SG169843 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169881 DB	'w32_internal_mtpos', 00H
	ORG $+5
$SG169882 DB	'w32stape.c', 00H
	ORG $+5
$SG169883 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169885 DB	'w32_internal_mtpos', 00H
	ORG $+5
$SG169886 DB	'w32stape.c', 00H
	ORG $+5
$SG169887 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_internal_mtget
	DD	023H
	DD	040fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_open_tape
	DD	025H
	DD	065aH
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$w32_open_tape DD 032d19H
	DD	012011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$w32_define_BOT DD 011101H
	DD	06211H
$unwind$w32_ioctl_tape DD 021a01H
	DD	07013f21aH
$unwind$w32_close_tape DD 010801H
	DD	08208H
$unwind$w32_read_tape DD 011201H
	DD	0c212H
$unwind$w32_write_tape DD 011201H
	DD	0c212H
$unwind$obtain_w32stape_lock DD 020601H
	DD	070023206H
$unwind$w32_alloc_ifd DD 010401H
	DD	06204H
$unwind$w32_free_ifd_nolock DD 010801H
	DD	06208H
$unwind$w32_free_ifd DD 010801H
	DD	06208H
$unwind$w32_get_tape_status DD 010901H
	DD	06209H
$unwind$w32_internal_rc DD 010901H
	DD	06209H
$unwind$w32_internal_mtop DD 021b01H
	DD	019011bH
$unwind$w32_internal_mtget DD 022819H
	DD	07015d219H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$w32_internal_mtpos DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
tv81 = 48
dummy_stat$1 = 52
tv88 = 56
dwDummyPositionHigh$ = 60
dwDummyPartition$ = 64
tv128 = 68
dummy_stat$2 = 72
tv135 = 76
hFile$ = 96
pStat$ = 104
pdwLogPos$ = 112
pdwAbsPos$ = 120
ifd$ = 128
w32_internal_mtpos PROC

; 1158 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@w32_intern:

; 1159 :     DWORD dwDummyPartition, dwDummyPositionHigh;
; 1160 : 
; 1161 :     ASSERT( pStat && pdwLogPos );    // (sanity check)

  00018	48 83 7c 24 68
	00		 cmp	 QWORD PTR pStat$[rsp], 0
  0001e	74 08		 je	 SHORT $LN15@w32_intern
  00020	48 83 7c 24 70
	00		 cmp	 QWORD PTR pdwLogPos$[rsp], 0
  00026	75 5c		 jne	 SHORT $LN14@w32_intern
$LN15@w32_intern:
$LN7@w32_intern:
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169881
  0002f	41 b8 89 04 00
	00		 mov	 r8d, 1161		; 00000489H
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169882
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169883
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0004f	85 c0		 test	 eax, eax
  00051	74 20		 je	 SHORT $LN16@w32_intern
  00053	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169885
  0005a	41 b8 89 04 00
	00		 mov	 r8d, 1161		; 00000489H
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169886
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169887
  0006e	e8 00 00 00 00	 call	 DebuggerTrace
$LN16@w32_intern:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 af		 jne	 SHORT $LN7@w32_intern
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0007f	85 c0		 test	 eax, eax
  00081	74 01		 je	 SHORT $LN17@w32_intern
  00083	cc		 int	 3
$LN17@w32_intern:
$LN14@w32_intern:
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	75 8e		 jne	 SHORT $LN4@w32_intern
$LN10@w32_intern:

; 1162 : 
; 1163 :     // PROGRAMMING NOTE: the SDK docs state that for the 'lpdwOffsetHigh'
; 1164 :     // parameter (i.e. dwDummyPositionHigh, the 5th paramater):
; 1165 :     //
; 1166 :     //    "This parameter can be NULL if the
; 1167 :     //     high-order bits are not required."
; 1168 :     //
; 1169 :     // But it LIES! Simple expirical observation reveals that ALL parameters
; 1170 :     // are in fact required. If any are NULL then 'GetTapePosition' crashes
; 1171 :     // and burns (which is unusual since usually when you pass invalid args
; 1172 :     // to an API it usually just returns an error code, but in this case it
; 1173 :     // doesn't. It actually crashes)
; 1174 : 
; 1175 :     do
; 1176 :     {
; 1177 :         U32 dummy_stat = 0;

  0008a	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR dummy_stat$1[rsp], 0

; 1178 :         errno = GetTapePosition

  00092	48 8d 44 24 3c	 lea	 rax, QWORD PTR dwDummyPositionHigh$[rsp]
  00097	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pdwLogPos$[rsp]
  000a1	4c 8d 44 24 40	 lea	 r8, QWORD PTR dwDummyPartition$[rsp]
  000a6	ba 01 00 00 00	 mov	 edx, 1
  000ab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hFile$[rsp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTapePosition
  000b6	89 44 24 30	 mov	 DWORD PTR tv81[rsp], eax
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c0	8b 4c 24 30	 mov	 ecx, DWORD PTR tv81[rsp]
  000c4	89 08		 mov	 DWORD PTR [rax], ecx

; 1179 :         (
; 1180 :             hFile,
; 1181 :             TAPE_LOGICAL_POSITION,
; 1182 :             &dwDummyPartition,
; 1183 :             pdwLogPos,
; 1184 :             &dwDummyPositionHigh
; 1185 :         );
; 1186 :         errno = w32_internal_rc ( &dummy_stat );

  000c6	48 8d 4c 24 34	 lea	 rcx, QWORD PTR dummy_stat$1[rsp]
  000cb	e8 00 00 00 00	 call	 w32_internal_rc
  000d0	89 44 24 38	 mov	 DWORD PTR tv88[rsp], eax
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000da	8b 4c 24 38	 mov	 ecx, DWORD PTR tv88[rsp]
  000de	89 08		 mov	 DWORD PTR [rax], ecx

; 1187 :     }
; 1188 :     while ( EINTR == errno );

  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e6	83 38 04	 cmp	 DWORD PTR [rax], 4
  000e9	74 9f		 je	 SHORT $LN10@w32_intern

; 1189 : 
; 1190 :     if (errno)

  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f1	83 38 00	 cmp	 DWORD PTR [rax], 0
  000f4	74 0a		 je	 SHORT $LN18@w32_intern

; 1191 :         return -1;

  000f6	b8 ff ff ff ff	 mov	 eax, -1
  000fb	e9 d1 00 00 00	 jmp	 $LN1@w32_intern
$LN18@w32_intern:

; 1192 : 
; 1193 :     if (pdwAbsPos)  // (may be NULL if they're not interested in it)

  00100	48 83 7c 24 78
	00		 cmp	 QWORD PTR pdwAbsPos$[rsp], 0
  00106	74 70		 je	 SHORT $LN19@w32_intern
$LN13@w32_intern:

; 1194 :     {
; 1195 :         do
; 1196 :         {
; 1197 :             U32 dummy_stat = 0;

  00108	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR dummy_stat$2[rsp], 0

; 1198 :             errno = GetTapePosition

  00110	48 8d 44 24 3c	 lea	 rax, QWORD PTR dwDummyPositionHigh$[rsp]
  00115	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR pdwAbsPos$[rsp]
  0011f	4c 8d 44 24 40	 lea	 r8, QWORD PTR dwDummyPartition$[rsp]
  00124	33 d2		 xor	 edx, edx
  00126	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hFile$[rsp]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTapePosition
  00131	89 44 24 44	 mov	 DWORD PTR tv128[rsp], eax
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013b	8b 4c 24 44	 mov	 ecx, DWORD PTR tv128[rsp]
  0013f	89 08		 mov	 DWORD PTR [rax], ecx

; 1199 :             (
; 1200 :                 hFile,
; 1201 :                 TAPE_ABSOLUTE_POSITION,
; 1202 :                 &dwDummyPartition,
; 1203 :                 pdwAbsPos,
; 1204 :                 &dwDummyPositionHigh
; 1205 :             );
; 1206 :             errno = w32_internal_rc ( &dummy_stat );

  00141	48 8d 4c 24 48	 lea	 rcx, QWORD PTR dummy_stat$2[rsp]
  00146	e8 00 00 00 00	 call	 w32_internal_rc
  0014b	89 44 24 4c	 mov	 DWORD PTR tv135[rsp], eax
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00155	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv135[rsp]
  00159	89 08		 mov	 DWORD PTR [rax], ecx

; 1207 :         }
; 1208 :         while ( EINTR == errno );

  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00161	83 38 04	 cmp	 DWORD PTR [rax], 4
  00164	74 a2		 je	 SHORT $LN13@w32_intern

; 1209 : 
; 1210 :         if (errno)

  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0016c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0016f	74 07		 je	 SHORT $LN20@w32_intern

; 1211 :             return -1;

  00171	b8 ff ff ff ff	 mov	 eax, -1
  00176	eb 59		 jmp	 SHORT $LN1@w32_intern
$LN20@w32_intern:
$LN19@w32_intern:

; 1212 :     }
; 1213 : 
; 1214 :     // PROGRAMMING NOTE: the Windows 'GetTapePosition' API returns either
; 1215 :     // a LOGICAL position value or an ABSOLUTE position value. Based on
; 1216 :     // trial and error it was determined the LOGICAL position corresponds
; 1217 :     // to the SCSI "READ POSITION" command's "first block location" value,
; 1218 :     // and the ABSOLUTE tape position appears to correspond to the SCSI
; 1219 :     // "last block location".
; 1220 : 
; 1221 :     // Since what we want is what IBM calls the "Channel block ID" (which
; 1222 :     // itself appears to correspond to what the SCSI documentation refers
; 1223 :     // to as the "First block location"), then what we want here is what
; 1224 :     // Windows refers to as the LOGICAL position, not the ABSOLUTE (i.e.
; 1225 :     // device-relative) position I originally thought we needed/wanted.
; 1226 : 
; 1227 :     if ( ( *pdwLogPos & g_BOTmsk[ ifd ] ) == g_BOTbot[ ifd ] )

  00178	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_BOTmsk
  00187	48 8b 54 24 70	 mov	 rdx, QWORD PTR pdwLogPos$[rsp]
  0018c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0018f	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  00191	23 c8		 and	 ecx, eax
  00193	8b c1		 mov	 eax, ecx
  00195	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR ifd$[rsp]
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_BOTbot
  001a4	3b 04 8a	 cmp	 eax, DWORD PTR [rdx+rcx*4]
  001a7	75 14		 jne	 SHORT $LN21@w32_intern

; 1228 :         *pStat |=  GMT_BOT (0xFFFFFFFF);

  001a9	48 8b 44 24 68	 mov	 rax, QWORD PTR pStat$[rsp]
  001ae	8b 00		 mov	 eax, DWORD PTR [rax]
  001b0	0f ba e8 1e	 bts	 eax, 30
  001b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pStat$[rsp]
  001b9	89 01		 mov	 DWORD PTR [rcx], eax
  001bb	eb 12		 jmp	 SHORT $LN22@w32_intern
$LN21@w32_intern:

; 1229 :     else
; 1230 :         *pStat &= ~GMT_BOT (0xFFFFFFFF);

  001bd	48 8b 44 24 68	 mov	 rax, QWORD PTR pStat$[rsp]
  001c2	8b 00		 mov	 eax, DWORD PTR [rax]
  001c4	0f ba f0 1e	 btr	 eax, 30
  001c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pStat$[rsp]
  001cd	89 01		 mov	 DWORD PTR [rcx], eax
$LN22@w32_intern:

; 1231 : 
; 1232 :     return 0;

  001cf	33 c0		 xor	 eax, eax
$LN1@w32_intern:

; 1233 : }

  001d1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d5	c3		 ret	 0
w32_internal_mtpos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
dwRetCode$ = 48
dwSize$ = 52
tv168 = 56
dwLogicalPosition$ = 60
tv136 = 64
media_parms$ = 72
__$ArrayPad$ = 104
hFile$ = 128
pStat$ = 136
mtget$ = 144
ifd$ = 152
w32_internal_mtget PROC

; 1059 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@w32_intern:

; 1060 :     TAPE_GET_MEDIA_PARAMETERS   media_parms;
; 1061 :     DWORD                       dwRetCode, dwSize, dwLogicalPosition;
; 1062 : 
; 1063 :     ASSERT( pStat && mtget );

  00028	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pStat$[rsp], 0
  00031	74 0b		 je	 SHORT $LN15@w32_intern
  00033	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR mtget$[rsp], 0
  0003c	75 5c		 jne	 SHORT $LN14@w32_intern
$LN15@w32_intern:
$LN7@w32_intern:
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169824
  00045	41 b8 27 04 00
	00		 mov	 r8d, 1063		; 00000427H
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169825
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169826
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00065	85 c0		 test	 eax, eax
  00067	74 20		 je	 SHORT $LN16@w32_intern
  00069	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169828
  00070	41 b8 27 04 00
	00		 mov	 r8d, 1063		; 00000427H
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169829
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169830
  00084	e8 00 00 00 00	 call	 DebuggerTrace
$LN16@w32_intern:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 af		 jne	 SHORT $LN7@w32_intern
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00095	85 c0		 test	 eax, eax
  00097	74 01		 je	 SHORT $LN17@w32_intern
  00099	cc		 int	 3
$LN17@w32_intern:
$LN14@w32_intern:
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 88		 jne	 SHORT $LN4@w32_intern

; 1064 : 
; 1065 :     mtget->mt_resid   =   0;            // (unknown/unsupported)

  000a0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  000a8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1066 :     mtget->mt_erreg   =   0;            // (unknown/unsupported)

  000af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  000b7	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 1067 :     mtget->mt_fileno  =  -1;            // (unknown/unsupported)

  000be	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  000c6	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [rax+20], -1

; 1068 :     mtget->mt_blkno   =  -1;            // (unknown as of yet; set further below)

  000cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  000d5	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1

; 1069 :     mtget->mt_type    =  MT_ISSCSI2;    // "Generic ANSI SCSI-2 tape unit"

  000dc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  000e4	c7 00 72 00 00
	00		 mov	 DWORD PTR [rax], 114	; 00000072H

; 1070 :     mtget->mt_gstat   =  -1;            // (purposely invalid; set correctly below)

  000ea	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  000f2	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [rax+12], -1

; 1071 : 
; 1072 :     // Reset the mounted status; it will get set further below...
; 1073 : 
; 1074 :     *pStat &= ~GMT_DR_OPEN (0xFFFFFFFF);

  000f9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  00101	8b 00		 mov	 eax, DWORD PTR [rax]
  00103	0f ba f0 12	 btr	 eax, 18
  00107	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  0010f	89 01		 mov	 DWORD PTR [rcx], eax

; 1075 : 
; 1076 :     // Attempt to retrieve the status of the tape-drive...
; 1077 : 
; 1078 :     dwRetCode = w32_get_tape_status( hFile );

  00111	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  00119	e8 00 00 00 00	 call	 w32_get_tape_status
  0011e	89 44 24 30	 mov	 DWORD PTR dwRetCode$[rsp], eax

; 1079 : 
; 1080 :     // Windows returns 'ERROR_NOT_READY' if no tape is mounted
; 1081 :     // instead of the usual expected 'ERROR_NO_MEDIA_IN_DRIVE'
; 1082 : 
; 1083 :     if ( ERROR_NOT_READY == dwRetCode )

  00122	83 7c 24 30 15	 cmp	 DWORD PTR dwRetCode$[rsp], 21
  00127	75 08		 jne	 SHORT $LN18@w32_intern

; 1084 :         dwRetCode = ERROR_NO_MEDIA_IN_DRIVE;

  00129	c7 44 24 30 58
	04 00 00	 mov	 DWORD PTR dwRetCode$[rsp], 1112 ; 00000458H
$LN18@w32_intern:

; 1085 : 
; 1086 :     // If there is not tape mounted OR a new tape was mounted,
; 1087 :     // then the following status bits are now unknown/obsolete
; 1088 : 
; 1089 :     if (0
; 1090 :         || ERROR_NO_MEDIA_IN_DRIVE == dwRetCode
; 1091 :         || ERROR_MEDIA_CHANGED     == dwRetCode

  00131	33 c0		 xor	 eax, eax
  00133	85 c0		 test	 eax, eax
  00135	75 18		 jne	 SHORT $LN20@w32_intern
  00137	81 7c 24 30 58
	04 00 00	 cmp	 DWORD PTR dwRetCode$[rsp], 1112 ; 00000458H
  0013f	74 0e		 je	 SHORT $LN20@w32_intern
  00141	81 7c 24 30 56
	04 00 00	 cmp	 DWORD PTR dwRetCode$[rsp], 1110 ; 00000456H
  00149	0f 85 90 00 00
	00		 jne	 $LN19@w32_intern
$LN20@w32_intern:

; 1092 :     )
; 1093 :     {
; 1094 :         // (these statuse are now obsolete)
; 1095 :         *pStat  &=  ~GMT_WR_PROT (0xFFFFFFFF);

  0014f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  00157	8b 00		 mov	 eax, DWORD PTR [rax]
  00159	0f ba f0 1a	 btr	 eax, 26
  0015d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00165	89 01		 mov	 DWORD PTR [rcx], eax

; 1096 :         *pStat  &=  ~GMT_BOT     (0xFFFFFFFF);

  00167	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  0016f	8b 00		 mov	 eax, DWORD PTR [rax]
  00171	0f ba f0 1e	 btr	 eax, 30
  00175	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  0017d	89 01		 mov	 DWORD PTR [rcx], eax

; 1097 :         *pStat  &=  ~GMT_EOT     (0xFFFFFFFF);

  0017f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  00187	8b 00		 mov	 eax, DWORD PTR [rax]
  00189	0f ba f0 1d	 btr	 eax, 29
  0018d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00195	89 01		 mov	 DWORD PTR [rcx], eax

; 1098 :         *pStat  &=  ~GMT_EOD     (0xFFFFFFFF);

  00197	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  0019f	8b 00		 mov	 eax, DWORD PTR [rax]
  001a1	0f ba f0 1b	 btr	 eax, 27
  001a5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  001ad	89 01		 mov	 DWORD PTR [rcx], eax

; 1099 :         *pStat  &=  ~GMT_EOF     (0xFFFFFFFF);

  001af	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  001b7	8b 00		 mov	 eax, DWORD PTR [rax]
  001b9	0f ba f0 1f	 btr	 eax, 31
  001bd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  001c5	89 01		 mov	 DWORD PTR [rcx], eax

; 1100 :         *pStat  &=  ~GMT_SM      (0xFFFFFFFF);

  001c7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  001cf	8b 00		 mov	 eax, DWORD PTR [rax]
  001d1	0f ba f0 1c	 btr	 eax, 28
  001d5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  001dd	89 01		 mov	 DWORD PTR [rcx], eax
$LN19@w32_intern:

; 1101 :     }
; 1102 : 
; 1103 :     // There's no sense trying to get media parameters
; 1104 :     // unless there's some media loaded on the drive!
; 1105 : 
; 1106 :     if ( ERROR_NO_MEDIA_IN_DRIVE == dwRetCode )

  001df	81 7c 24 30 58
	04 00 00	 cmp	 DWORD PTR dwRetCode$[rsp], 1112 ; 00000458H
  001e7	75 34		 jne	 SHORT $LN21@w32_intern

; 1107 :     {
; 1108 :         *pStat |= GMT_DR_OPEN (0xFFFFFFFF);     // (no tape mounted in drive)

  001e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  001f1	8b 00		 mov	 eax, DWORD PTR [rax]
  001f3	0f ba e8 12	 bts	 eax, 18
  001f7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  001ff	89 01		 mov	 DWORD PTR [rcx], eax

; 1109 :         mtget->mt_gstat = *pStat;               // (return current status)

  00201	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  00209	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00211	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00213	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 1110 :         return 0;                               // (nothing more we can do)

  00216	33 c0		 xor	 eax, eax
  00218	e9 f2 01 00 00	 jmp	 $LN1@w32_intern
$LN21@w32_intern:

; 1111 :     }
; 1112 : 
; 1113 :     // A tape appears to be mounted on the drive...
; 1114 :     // Retrieve the media parameters information...
; 1115 : 
; 1116 :     dwSize = sizeof(media_parms);

  0021d	c7 44 24 34 20
	00 00 00	 mov	 DWORD PTR dwSize$[rsp], 32 ; 00000020H

; 1117 :     memset( &media_parms, 0, dwSize );

  00225	8b 44 24 34	 mov	 eax, DWORD PTR dwSize$[rsp]
  00229	48 89 44 24 40	 mov	 QWORD PTR tv136[rsp], rax
  0022e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR media_parms$[rsp]
  00233	48 8b f9	 mov	 rdi, rcx
  00236	33 c0		 xor	 eax, eax
  00238	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv136[rsp]
  0023d	f3 aa		 rep stosb

; 1118 :     dwRetCode = GetTapeParameters( hFile, GET_TAPE_MEDIA_INFORMATION, &dwSize, &media_parms );

  0023f	4c 8d 4c 24 48	 lea	 r9, QWORD PTR media_parms$[rsp]
  00244	4c 8d 44 24 34	 lea	 r8, QWORD PTR dwSize$[rsp]
  00249	33 d2		 xor	 edx, edx
  0024b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTapeParameters
  00259	89 44 24 30	 mov	 DWORD PTR dwRetCode$[rsp], eax
$LN10@w32_intern:

; 1119 :     ASSERT( sizeof(media_parms) == dwSize );

  0025d	8b 44 24 34	 mov	 eax, DWORD PTR dwSize$[rsp]
  00261	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  00265	74 5c		 je	 SHORT $LN22@w32_intern
$LN13@w32_intern:
  00267	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169837
  0026e	41 b8 5f 04 00
	00		 mov	 r8d, 1119		; 0000045fH
  00274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169838
  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169839
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0028e	85 c0		 test	 eax, eax
  00290	74 20		 je	 SHORT $LN23@w32_intern
  00292	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169841
  00299	41 b8 5f 04 00
	00		 mov	 r8d, 1119		; 0000045fH
  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169842
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169843
  002ad	e8 00 00 00 00	 call	 DebuggerTrace
$LN23@w32_intern:
  002b2	33 c0		 xor	 eax, eax
  002b4	85 c0		 test	 eax, eax
  002b6	75 af		 jne	 SHORT $LN13@w32_intern
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002be	85 c0		 test	 eax, eax
  002c0	74 01		 je	 SHORT $LN24@w32_intern
  002c2	cc		 int	 3
$LN24@w32_intern:
$LN22@w32_intern:
  002c3	33 c0		 xor	 eax, eax
  002c5	85 c0		 test	 eax, eax
  002c7	75 94		 jne	 SHORT $LN10@w32_intern

; 1120 : 
; 1121 :     if ( NO_ERROR == dwRetCode )

  002c9	83 7c 24 30 00	 cmp	 DWORD PTR dwRetCode$[rsp], 0
  002ce	75 4c		 jne	 SHORT $LN25@w32_intern

; 1122 :     {
; 1123 :         mtget->mt_dsreg = media_parms.BlockSize;

  002d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  002d8	8b 4c 24 58	 mov	 ecx, DWORD PTR media_parms$[rsp+16]
  002dc	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 1124 : 
; 1125 :         if (media_parms.WriteProtected)

  002df	0f b6 44 24 60	 movzx	 eax, BYTE PTR media_parms$[rsp+24]
  002e4	85 c0		 test	 eax, eax
  002e6	74 1a		 je	 SHORT $LN27@w32_intern

; 1126 :             *pStat |=  GMT_WR_PROT (0xFFFFFFFF);

  002e8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  002f0	8b 00		 mov	 eax, DWORD PTR [rax]
  002f2	0f ba e8 1a	 bts	 eax, 26
  002f6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  002fe	89 01		 mov	 DWORD PTR [rcx], eax
  00300	eb 18		 jmp	 SHORT $LN28@w32_intern
$LN27@w32_intern:

; 1127 :         else
; 1128 :             *pStat &= ~GMT_WR_PROT (0xFFFFFFFF);

  00302	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  0030a	8b 00		 mov	 eax, DWORD PTR [rax]
  0030c	0f ba f0 1a	 btr	 eax, 26
  00310	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00318	89 01		 mov	 DWORD PTR [rcx], eax
$LN28@w32_intern:

; 1129 :     }

  0031a	eb 0f		 jmp	 SHORT $LN26@w32_intern
$LN25@w32_intern:

; 1130 :     else
; 1131 :         mtget->mt_dsreg = 0;    // (unknown; variable blocks presumed)

  0031c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  00324	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
$LN26@w32_intern:

; 1132 : 
; 1133 :     // Lastly, attempt to determine if we are at BOT (i.e. load-point)...
; 1134 : 
; 1135 :     if ( 0 != ( errno = w32_internal_mtpos( hFile, pStat, &dwLogicalPosition, NULL, ifd ) ) )

  0032b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR ifd$[rsp]
  00332	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00336	45 33 c9	 xor	 r9d, r9d
  00339	4c 8d 44 24 3c	 lea	 r8, QWORD PTR dwLogicalPosition$[rsp]
  0033e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pStat$[rsp]
  00346	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  0034e	e8 00 00 00 00	 call	 w32_internal_mtpos
  00353	89 44 24 38	 mov	 DWORD PTR tv168[rsp], eax
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0035d	8b 4c 24 38	 mov	 ecx, DWORD PTR tv168[rsp]
  00361	89 08		 mov	 DWORD PTR [rax], ecx
  00363	83 7c 24 38 00	 cmp	 DWORD PTR tv168[rsp], 0
  00368	74 1f		 je	 SHORT $LN29@w32_intern

; 1136 :     {
; 1137 :         mtget->mt_gstat = *pStat;

  0036a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  00372	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  0037a	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0037c	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 1138 :         return -1;

  0037f	b8 ff ff ff ff	 mov	 eax, -1
  00384	e9 86 00 00 00	 jmp	 $LN1@w32_intern
$LN29@w32_intern:

; 1139 :     }
; 1140 : 
; 1141 :     mtget->mt_blkno = dwLogicalPosition;

  00389	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  00391	8b 4c 24 3c	 mov	 ecx, DWORD PTR dwLogicalPosition$[rsp]
  00395	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 1142 : 
; 1143 :     if ( ( dwLogicalPosition & g_BOTmsk[ ifd ] ) == g_BOTbot[ ifd ] )

  00398	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR ifd$[rsp]
  003a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_BOTmsk
  003a7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  003aa	8b 4c 24 3c	 mov	 ecx, DWORD PTR dwLogicalPosition$[rsp]
  003ae	23 c8		 and	 ecx, eax
  003b0	8b c1		 mov	 eax, ecx
  003b2	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR ifd$[rsp]
  003ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_BOTbot
  003c1	3b 04 8a	 cmp	 eax, DWORD PTR [rdx+rcx*4]
  003c4	75 1a		 jne	 SHORT $LN30@w32_intern

; 1144 :         *pStat |=  GMT_BOT (0xFFFFFFFF);

  003c6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  003ce	8b 00		 mov	 eax, DWORD PTR [rax]
  003d0	0f ba e8 1e	 bts	 eax, 30
  003d4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  003dc	89 01		 mov	 DWORD PTR [rcx], eax
  003de	eb 18		 jmp	 SHORT $LN31@w32_intern
$LN30@w32_intern:

; 1145 :     else
; 1146 :         *pStat &= ~GMT_BOT (0xFFFFFFFF);

  003e0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pStat$[rsp]
  003e8	8b 00		 mov	 eax, DWORD PTR [rax]
  003ea	0f ba f0 1e	 btr	 eax, 30
  003ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  003f6	89 01		 mov	 DWORD PTR [rcx], eax
$LN31@w32_intern:

; 1147 : 
; 1148 :     mtget->mt_gstat = *pStat;

  003f8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  00400	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00408	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0040a	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 1149 :     return 0;

  0040d	33 c0		 xor	 eax, eax
$LN1@w32_intern:

; 1150 : }

  0040f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00414	48 33 cc	 xor	 rcx, rsp
  00417	e8 00 00 00 00	 call	 __security_check_cookie
  0041c	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00420	5f		 pop	 rdi
  00421	c3		 ret	 0
w32_internal_mtget ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
rc$ = 48
tv82 = 52
dwTapemarkType$1 = 56
tv282 = 60
tv301 = 64
set_drive_parms$2 = 72
liCount$3 = 80
liCount$4 = 88
tv87 = 96
tv92 = 100
tv132 = 104
tv137 = 108
tv142 = 112
tv151 = 116
tv159 = 120
tv167 = 124
tv181 = 128
tv189 = 132
tv203 = 136
tv211 = 140
media_parms$5 = 144
tv217 = 148
tv222 = 152
tv244 = 156
tv249 = 160
tv263 = 164
tv270 = 168
dwEraseType$6 = 172
tv284 = 176
tv289 = 180
hFile$ = 208
pStat$ = 216
mtop$ = 224
ifd$ = 232
w32_internal_mtop PROC

; 805  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 806  :     int rc = 0;

  0001b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@w32_intern:

; 807  : 
; 808  :     ASSERT( pStat && mtop );    // (sanity check)

  00023	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR pStat$[rsp], 0
  0002c	74 0b		 je	 SHORT $LN41@w32_intern
  0002e	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR mtop$[rsp], 0
  00037	75 5c		 jne	 SHORT $LN40@w32_intern
$LN41@w32_intern:
$LN7@w32_intern:
  00039	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169756
  00040	41 b8 28 03 00
	00		 mov	 r8d, 808		; 00000328H
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169757
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169758
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00060	85 c0		 test	 eax, eax
  00062	74 20		 je	 SHORT $LN42@w32_intern
  00064	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169760
  0006b	41 b8 28 03 00
	00		 mov	 r8d, 808		; 00000328H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169761
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169762
  0007f	e8 00 00 00 00	 call	 DebuggerTrace
$LN42@w32_intern:
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	75 af		 jne	 SHORT $LN7@w32_intern
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00090	85 c0		 test	 eax, eax
  00092	74 01		 je	 SHORT $LN43@w32_intern
  00094	cc		 int	 3
$LN43@w32_intern:
$LN40@w32_intern:
  00095	33 c0		 xor	 eax, eax
  00097	85 c0		 test	 eax, eax
  00099	75 88		 jne	 SHORT $LN4@w32_intern

; 809  : 
; 810  :     // General technique: do the i/o, save results, update the
; 811  :     // device status (based on the results), then check results...
; 812  : 
; 813  :     switch ( mtop->mt_op )

  0009b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  000a3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000a6	89 44 24 34	 mov	 DWORD PTR tv82[rsp], eax
  000aa	8b 44 24 34	 mov	 eax, DWORD PTR tv82[rsp]
  000ae	ff c8		 dec	 eax
  000b0	89 44 24 34	 mov	 DWORD PTR tv82[rsp], eax
  000b4	83 7c 24 34 1e	 cmp	 DWORD PTR tv82[rsp], 30
  000b9	0f 87 79 06 00
	00		 ja	 $LN75@w32_intern
  000bf	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv82[rsp]
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000cb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN81@w32_intern[rcx+rax*4]
  000d2	48 03 c1	 add	 rax, rcx
  000d5	ff e0		 jmp	 rax
$LN44@w32_intern:

; 814  :     {
; 815  :         case MTLOAD:    // (load media)
; 816  :         {
; 817  :             if ( 1 != mtop->mt_count )

  000d7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  000df	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  000e3	74 16		 je	 SHORT $LN45@w32_intern

; 818  :             {
; 819  :                 errno = EINVAL;

  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000eb	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 820  :                 rc = -1;

  000f1	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 821  :             }

  000f9	eb 4b		 jmp	 SHORT $LN46@w32_intern
$LN45@w32_intern:
$LN12@w32_intern:

; 822  :             else
; 823  :             {
; 824  :                 do
; 825  :                 {
; 826  :                     errno = PrepareTape( hFile, TAPE_LOAD, FALSE );

  000fb	45 33 c0	 xor	 r8d, r8d
  000fe	33 d2		 xor	 edx, edx
  00100	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PrepareTape
  0010e	89 44 24 60	 mov	 DWORD PTR tv87[rsp], eax
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00118	8b 4c 24 60	 mov	 ecx, DWORD PTR tv87[rsp]
  0011c	89 08		 mov	 DWORD PTR [rax], ecx

; 827  :                     errno = w32_internal_rc ( pStat );

  0011e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00126	e8 00 00 00 00	 call	 w32_internal_rc
  0012b	89 44 24 64	 mov	 DWORD PTR tv92[rsp], eax
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00135	8b 4c 24 64	 mov	 ecx, DWORD PTR tv92[rsp]
  00139	89 08		 mov	 DWORD PTR [rax], ecx

; 828  :                 }
; 829  :                 while ( EINTR == errno );

  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00141	83 38 04	 cmp	 DWORD PTR [rax], 4
  00144	74 b5		 je	 SHORT $LN12@w32_intern
$LN46@w32_intern:

; 830  :             }
; 831  :         }
; 832  :         break;

  00146	e9 01 06 00 00	 jmp	 $LN8@w32_intern
$LN47@w32_intern:
$LN48@w32_intern:

; 833  : 
; 834  :         case MTUNLOAD:  // (unload media)
; 835  :         case MTOFFL:    // (make media offline (same as unload))
; 836  :         {
; 837  :             if ( 1 != mtop->mt_count )

  0014b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  00153	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  00157	74 16		 je	 SHORT $LN49@w32_intern

; 838  :             {
; 839  :                 errno = EINVAL;

  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0015f	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 840  :                 rc = -1;

  00165	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 841  :             }

  0016d	eb 4e		 jmp	 SHORT $LN50@w32_intern
$LN49@w32_intern:
$LN15@w32_intern:

; 842  :             else
; 843  :             {
; 844  :                 do
; 845  :                 {
; 846  :                     errno = PrepareTape( hFile, TAPE_UNLOAD, FALSE );

  0016f	45 33 c0	 xor	 r8d, r8d
  00172	ba 01 00 00 00	 mov	 edx, 1
  00177	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PrepareTape
  00185	89 44 24 68	 mov	 DWORD PTR tv132[rsp], eax
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0018f	8b 4c 24 68	 mov	 ecx, DWORD PTR tv132[rsp]
  00193	89 08		 mov	 DWORD PTR [rax], ecx

; 847  :                     errno = w32_internal_rc ( pStat );

  00195	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  0019d	e8 00 00 00 00	 call	 w32_internal_rc
  001a2	89 44 24 6c	 mov	 DWORD PTR tv137[rsp], eax
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ac	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv137[rsp]
  001b0	89 08		 mov	 DWORD PTR [rax], ecx

; 848  :                 }
; 849  :                 while ( EINTR == errno );

  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001b8	83 38 04	 cmp	 DWORD PTR [rax], 4
  001bb	74 b2		 je	 SHORT $LN15@w32_intern
$LN50@w32_intern:

; 850  :             }
; 851  :         }
; 852  :         break;

  001bd	e9 8a 05 00 00	 jmp	 $LN8@w32_intern
$LN51@w32_intern:
$LN18@w32_intern:

; 853  : 
; 854  :         case MTSEEK:    // (position media)
; 855  :         {
; 856  :             do
; 857  :             {
; 858  :                 errno = SetTapePosition( hFile, TAPE_LOGICAL_BLOCK, 0, mtop->mt_count, 0, FALSE );

  001c2	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  001ca	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  001d2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  001da	44 8b 48 04	 mov	 r9d, DWORD PTR [rax+4]
  001de	45 33 c0	 xor	 r8d, r8d
  001e1	ba 02 00 00 00	 mov	 edx, 2
  001e6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetTapePosition
  001f4	89 44 24 70	 mov	 DWORD PTR tv142[rsp], eax
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001fe	8b 4c 24 70	 mov	 ecx, DWORD PTR tv142[rsp]
  00202	89 08		 mov	 DWORD PTR [rax], ecx

; 859  :                 errno = w32_internal_rc ( pStat );

  00204	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  0020c	e8 00 00 00 00	 call	 w32_internal_rc
  00211	89 44 24 74	 mov	 DWORD PTR tv151[rsp], eax
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0021b	8b 4c 24 74	 mov	 ecx, DWORD PTR tv151[rsp]
  0021f	89 08		 mov	 DWORD PTR [rax], ecx

; 860  :             }
; 861  :             while ( EINTR == errno );

  00221	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00227	83 38 04	 cmp	 DWORD PTR [rax], 4
  0022a	74 96		 je	 SHORT $LN18@w32_intern

; 862  :         }
; 863  :         break;

  0022c	e9 1b 05 00 00	 jmp	 $LN8@w32_intern
$LN52@w32_intern:

; 864  : 
; 865  :         case MTREW:     // (rewind)
; 866  :         {
; 867  :             if ( 1 != mtop->mt_count )

  00231	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  00239	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  0023d	74 16		 je	 SHORT $LN53@w32_intern

; 868  :             {
; 869  :                 errno = EINVAL;

  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00245	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 870  :                 rc = -1;

  0024b	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 871  :             }

  00253	eb 5e		 jmp	 SHORT $LN54@w32_intern
$LN53@w32_intern:
$LN21@w32_intern:

; 872  :             else
; 873  :             {
; 874  :                 do
; 875  :                 {
; 876  :                     errno = SetTapePosition( hFile, TAPE_REWIND, 0, 0, 0, FALSE );

  00255	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0025d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00265	45 33 c9	 xor	 r9d, r9d
  00268	45 33 c0	 xor	 r8d, r8d
  0026b	33 d2		 xor	 edx, edx
  0026d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetTapePosition
  0027b	89 44 24 78	 mov	 DWORD PTR tv159[rsp], eax
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00285	8b 4c 24 78	 mov	 ecx, DWORD PTR tv159[rsp]
  00289	89 08		 mov	 DWORD PTR [rax], ecx

; 877  :                     errno = w32_internal_rc ( pStat );

  0028b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00293	e8 00 00 00 00	 call	 w32_internal_rc
  00298	89 44 24 7c	 mov	 DWORD PTR tv167[rsp], eax
  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a2	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv167[rsp]
  002a6	89 08		 mov	 DWORD PTR [rax], ecx

; 878  :                 }
; 879  :                 while ( EINTR == errno );

  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002ae	83 38 04	 cmp	 DWORD PTR [rax], 4
  002b1	74 a2		 je	 SHORT $LN21@w32_intern
$LN54@w32_intern:

; 880  :             }
; 881  :         }
; 882  :         break;

  002b3	e9 94 04 00 00	 jmp	 $LN8@w32_intern
$LN55@w32_intern:
$LN56@w32_intern:

; 883  : 
; 884  :         case MTFSF:     // (FORWARD  space FILE)
; 885  :         case MTBSF:     // (BACKWARD space FILE)
; 886  :         {
; 887  :             if ( !mtop->mt_count )

  002b8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  002c0	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  002c4	75 19		 jne	 SHORT $LN57@w32_intern

; 888  :             {
; 889  :                 errno = EINVAL;

  002c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002cc	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 890  :                 rc = -1;

  002d2	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 891  :             }

  002da	e9 9d 00 00 00	 jmp	 $LN58@w32_intern
$LN57@w32_intern:

; 892  :             else
; 893  :             {
; 894  :                 LARGE_INTEGER liCount;
; 895  : 
; 896  :                 liCount.QuadPart = mtop->mt_count;

  002df	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  002e7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002eb	48 89 44 24 50	 mov	 QWORD PTR liCount$3[rsp], rax

; 897  : 
; 898  :                 if ( MTBSF == mtop->mt_op )

  002f0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  002f8	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002fb	83 f8 02	 cmp	 eax, 2
  002fe	75 0d		 jne	 SHORT $LN59@w32_intern

; 899  :                     liCount.QuadPart = -liCount.QuadPart; // (negative == backwards)

  00300	48 8b 44 24 50	 mov	 rax, QWORD PTR liCount$3[rsp]
  00305	48 f7 d8	 neg	 rax
  00308	48 89 44 24 50	 mov	 QWORD PTR liCount$3[rsp], rax
$LN59@w32_intern:
$LN24@w32_intern:

; 900  : 
; 901  :                 do
; 902  :                 {
; 903  :                     errno = SetTapePosition( hFile, TAPE_SPACE_FILEMARKS, 0, liCount.LowPart, liCount.HighPart, FALSE );

  0030d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00315	8b 44 24 54	 mov	 eax, DWORD PTR liCount$3[rsp+4]
  00319	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0031d	44 8b 4c 24 50	 mov	 r9d, DWORD PTR liCount$3[rsp]
  00322	45 33 c0	 xor	 r8d, r8d
  00325	ba 06 00 00 00	 mov	 edx, 6
  0032a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  00332	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetTapePosition
  00338	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv181[rsp], eax
  0033f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00345	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv181[rsp]
  0034c	89 08		 mov	 DWORD PTR [rax], ecx

; 904  :                     errno = w32_internal_rc ( pStat );

  0034e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00356	e8 00 00 00 00	 call	 w32_internal_rc
  0035b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv189[rsp], eax
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00368	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  0036f	89 08		 mov	 DWORD PTR [rax], ecx

; 905  :                 }
; 906  :                 while ( EINTR == errno );

  00371	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00377	83 38 04	 cmp	 DWORD PTR [rax], 4
  0037a	74 91		 je	 SHORT $LN24@w32_intern
$LN58@w32_intern:

; 907  :             }
; 908  :         }
; 909  :         break;

  0037c	e9 cb 03 00 00	 jmp	 $LN8@w32_intern
$LN60@w32_intern:
$LN61@w32_intern:

; 910  : 
; 911  :         case MTFSR:     // (FORWARD  space BLOCK)
; 912  :         case MTBSR:     // (BACKWARD space BLOCK)
; 913  :         {
; 914  :             if ( !mtop->mt_count )

  00381	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  00389	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0038d	75 19		 jne	 SHORT $LN62@w32_intern

; 915  :             {
; 916  :                 errno = EINVAL;

  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00395	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 917  :                 rc = -1;

  0039b	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 918  :             }

  003a3	e9 9d 00 00 00	 jmp	 $LN63@w32_intern
$LN62@w32_intern:

; 919  :             else
; 920  :             {
; 921  :                 LARGE_INTEGER liCount;
; 922  : 
; 923  :                 liCount.QuadPart = mtop->mt_count;

  003a8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  003b0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  003b4	48 89 44 24 58	 mov	 QWORD PTR liCount$4[rsp], rax

; 924  : 
; 925  :                 if ( MTBSR == mtop->mt_op )

  003b9	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  003c1	0f bf 00	 movsx	 eax, WORD PTR [rax]
  003c4	83 f8 04	 cmp	 eax, 4
  003c7	75 0d		 jne	 SHORT $LN64@w32_intern

; 926  :                     liCount.QuadPart = -liCount.QuadPart; // (negative == backwards)

  003c9	48 8b 44 24 58	 mov	 rax, QWORD PTR liCount$4[rsp]
  003ce	48 f7 d8	 neg	 rax
  003d1	48 89 44 24 58	 mov	 QWORD PTR liCount$4[rsp], rax
$LN64@w32_intern:
$LN27@w32_intern:

; 927  : 
; 928  :                 do
; 929  :                 {
; 930  :                     errno = SetTapePosition( hFile, TAPE_SPACE_RELATIVE_BLOCKS, 0, liCount.LowPart, liCount.HighPart, FALSE );

  003d6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  003de	8b 44 24 5c	 mov	 eax, DWORD PTR liCount$4[rsp+4]
  003e2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003e6	44 8b 4c 24 58	 mov	 r9d, DWORD PTR liCount$4[rsp]
  003eb	45 33 c0	 xor	 r8d, r8d
  003ee	ba 05 00 00 00	 mov	 edx, 5
  003f3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetTapePosition
  00401	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  00408	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0040e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  00415	89 08		 mov	 DWORD PTR [rax], ecx

; 931  :                     errno = w32_internal_rc ( pStat );

  00417	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  0041f	e8 00 00 00 00	 call	 w32_internal_rc
  00424	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv211[rsp], eax
  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00431	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv211[rsp]
  00438	89 08		 mov	 DWORD PTR [rax], ecx

; 932  :                 }
; 933  :                 while ( EINTR == errno );

  0043a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00440	83 38 04	 cmp	 DWORD PTR [rax], 4
  00443	74 91		 je	 SHORT $LN27@w32_intern
$LN63@w32_intern:

; 934  :             }
; 935  :         }
; 936  :         break;

  00445	e9 02 03 00 00	 jmp	 $LN8@w32_intern
$LN65@w32_intern:

; 937  : 
; 938  :         case MTSETBLK:  // (set blocksize)
; 939  :         {
; 940  :             TAPE_SET_MEDIA_PARAMETERS  media_parms;
; 941  : 
; 942  :             media_parms.BlockSize = mtop->mt_count;

  0044a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  00452	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00455	89 84 24 90 00
	00 00		 mov	 DWORD PTR media_parms$5[rsp], eax
$LN30@w32_intern:

; 943  : 
; 944  :             do
; 945  :             {
; 946  :                 errno = SetTapeParameters( hFile, SET_TAPE_MEDIA_INFORMATION, &media_parms );

  0045c	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR media_parms$5[rsp]
  00464	33 d2		 xor	 edx, edx
  00466	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  0046e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetTapeParameters
  00474	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv217[rsp], eax
  0047b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00481	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv217[rsp]
  00488	89 08		 mov	 DWORD PTR [rax], ecx

; 947  :                 errno = w32_internal_rc ( pStat );

  0048a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00492	e8 00 00 00 00	 call	 w32_internal_rc
  00497	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv222[rsp], eax
  0049e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004a4	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv222[rsp]
  004ab	89 08		 mov	 DWORD PTR [rax], ecx

; 948  :             }
; 949  :             while ( EINTR == errno );

  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004b3	83 38 04	 cmp	 DWORD PTR [rax], 4
  004b6	74 a4		 je	 SHORT $LN30@w32_intern

; 950  :         }
; 951  :         break;

  004b8	e9 8f 02 00 00	 jmp	 $LN8@w32_intern
$LN66@w32_intern:

; 952  : 
; 953  :         case MTEOTWARN:   // (set EOT Warning Zone size in bytes)
; 954  :         {
; 955  :             TAPE_SET_DRIVE_PARAMETERS   set_drive_parms;
; 956  : 
; 957  :             set_drive_parms.ECC                = g_drive_parms[ifd].ECC;

  004bd	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR ifd$[rsp]
  004c5	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_drive_parms
  004d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d4	88 44 24 48	 mov	 BYTE PTR set_drive_parms$2[rsp], al

; 958  :             set_drive_parms.Compression        = g_drive_parms[ifd].Compression;

  004d8	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR ifd$[rsp]
  004e0	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_drive_parms
  004eb	0f b6 44 01 01	 movzx	 eax, BYTE PTR [rcx+rax+1]
  004f0	88 44 24 49	 mov	 BYTE PTR set_drive_parms$2[rsp+1], al

; 959  :             set_drive_parms.DataPadding        = g_drive_parms[ifd].DataPadding;

  004f4	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR ifd$[rsp]
  004fc	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00500	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_drive_parms
  00507	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  0050c	88 44 24 4a	 mov	 BYTE PTR set_drive_parms$2[rsp+2], al

; 960  :             set_drive_parms.ReportSetmarks     = g_drive_parms[ifd].ReportSetmarks;

  00510	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00518	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0051c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_drive_parms
  00523	0f b6 44 01 03	 movzx	 eax, BYTE PTR [rcx+rax+3]
  00528	88 44 24 4b	 mov	 BYTE PTR set_drive_parms$2[rsp+3], al

; 961  :             set_drive_parms.EOTWarningZoneSize = mtop->mt_count;

  0052c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  00534	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00537	89 44 24 4c	 mov	 DWORD PTR set_drive_parms$2[rsp+4], eax
$LN33@w32_intern:

; 962  : 
; 963  :             do
; 964  :             {
; 965  :                 errno = SetTapeParameters( hFile, SET_TAPE_DRIVE_INFORMATION, &set_drive_parms );

  0053b	4c 8d 44 24 48	 lea	 r8, QWORD PTR set_drive_parms$2[rsp]
  00540	ba 01 00 00 00	 mov	 edx, 1
  00545	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  0054d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetTapeParameters
  00553	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv244[rsp], eax
  0055a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00560	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv244[rsp]
  00567	89 08		 mov	 DWORD PTR [rax], ecx

; 966  :                 errno = w32_internal_rc ( pStat );

  00569	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00571	e8 00 00 00 00	 call	 w32_internal_rc
  00576	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv249[rsp], eax
  0057d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00583	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv249[rsp]
  0058a	89 08		 mov	 DWORD PTR [rax], ecx

; 967  :             }
; 968  :             while ( EINTR == errno );

  0058c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00592	83 38 04	 cmp	 DWORD PTR [rax], 4
  00595	74 a4		 je	 SHORT $LN33@w32_intern

; 969  :         }
; 970  :         break;

  00597	e9 b0 01 00 00	 jmp	 $LN8@w32_intern
$LN67@w32_intern:

; 971  : 
; 972  :         case MTWEOF:    // (write TAPEMARK)
; 973  :         {
; 974  :             if ( mtop->mt_count < 0 )

  0059c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  005a4	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  005a8	7d 19		 jge	 SHORT $LN68@w32_intern

; 975  :             {
; 976  :                 errno = EINVAL;

  005aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005b0	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 977  :                 rc = -1;

  005b6	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 978  :             }

  005be	e9 95 00 00 00	 jmp	 $LN69@w32_intern
$LN68@w32_intern:

; 979  :             else
; 980  :             {
; 981  :                 // PROGRAMMING NOTE: We prefer "long" filemarks over any other type
; 982  :                 // because, according to the SDK documentaion:
; 983  :                 //
; 984  :                 //    "A short filemark contains a short erase gap that cannot be
; 985  :                 //     overwritten unless the write operation is performed from the
; 986  :                 //     beginning of the partition or from an earlier long filemark."
; 987  :                 //
; 988  :                 //    "A long filemark contains a long erase gap that allows an
; 989  :                 //     application to position the tape at the beginning of the filemark
; 990  :                 //     and to overwrite the filemark and the erase gap."
; 991  :                 //
; 992  :                 // Thus if TAPE_LONG_FILEMARKS is not supported we try ONLY the generic
; 993  :                 // TAPE_FILEMARKS variety and return an error if that fails; we do NOT
; 994  :                 // ever attempt the TAPE_SHORT_FILEMARKS or TAPE_SETMARKS variety.
; 995  : 
; 996  :                 DWORD  dwTapemarkType = TAPE_LONG_FILEMARKS;

  005c3	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR dwTapemarkType$1[rsp], 3

; 997  : 
; 998  :                 if ( !( g_drive_parms[ifd].FeaturesHigh & TAPE_DRIVE_WRITE_LONG_FMKS ) )

  005cb	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR ifd$[rsp]
  005d3	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  005d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_drive_parms
  005de	8b 44 01 18	 mov	 eax, DWORD PTR [rcx+rax+24]
  005e2	25 00 00 00 88	 and	 eax, -2013265920	; 88000000H
  005e7	85 c0		 test	 eax, eax
  005e9	75 08		 jne	 SHORT $LN70@w32_intern

; 999  :                     dwTapemarkType = TAPE_FILEMARKS;

  005eb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR dwTapemarkType$1[rsp], 1
$LN70@w32_intern:
$LN36@w32_intern:

; 1000 : 
; 1001 :                 do
; 1002 :                 {
; 1003 :                     errno = WriteTapemark( hFile, dwTapemarkType, mtop->mt_count, FALSE );

  005f3	45 33 c9	 xor	 r9d, r9d
  005f6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  005fe	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00602	8b 54 24 38	 mov	 edx, DWORD PTR dwTapemarkType$1[rsp]
  00606	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  0060e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteTapemark
  00614	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv263[rsp], eax
  0061b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00621	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv263[rsp]
  00628	89 08		 mov	 DWORD PTR [rax], ecx

; 1004 :                     errno = w32_internal_rc ( pStat );

  0062a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  00632	e8 00 00 00 00	 call	 w32_internal_rc
  00637	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv270[rsp], eax
  0063e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00644	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv270[rsp]
  0064b	89 08		 mov	 DWORD PTR [rax], ecx

; 1005 :                 }
; 1006 :                 while ( EINTR == errno );

  0064d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00653	83 38 04	 cmp	 DWORD PTR [rax], 4
  00656	74 9b		 je	 SHORT $LN36@w32_intern
$LN69@w32_intern:

; 1007 :             }
; 1008 :         }
; 1009 :         break;

  00658	e9 ef 00 00 00	 jmp	 $LN8@w32_intern
$LN71@w32_intern:

; 1010 : 
; 1011 :         case MTERASE: // (write erase gap or erase entire tape (data security erase))
; 1012 :         {
; 1013 :             if (1
; 1014 :                 && 0 != mtop->mt_count  // (0 == write erase gap at current position)
; 1015 :                 && 1 != mtop->mt_count  // (1 == erases the remainder of entire tape)

  0065d	33 c0		 xor	 eax, eax
  0065f	83 f8 01	 cmp	 eax, 1
  00662	74 35		 je	 SHORT $LN72@w32_intern
  00664	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  0066c	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00670	74 27		 je	 SHORT $LN72@w32_intern
  00672	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  0067a	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  0067e	74 19		 je	 SHORT $LN72@w32_intern

; 1016 :             )
; 1017 :             {
; 1018 :                 errno = EINVAL;

  00680	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00686	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 1019 :                 rc = -1;

  0068c	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 1020 :             }

  00694	e9 87 00 00 00	 jmp	 $LN73@w32_intern
$LN72@w32_intern:

; 1021 :             else
; 1022 :             {
; 1023 :                 DWORD  dwEraseType  =

  00699	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mtop$[rsp]
  006a1	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  006a5	74 0a		 je	 SHORT $LN77@w32_intern
  006a7	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv282[rsp], 1
  006af	eb 08		 jmp	 SHORT $LN78@w32_intern
$LN77@w32_intern:
  006b1	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv282[rsp], 0
$LN78@w32_intern:
  006b9	8b 44 24 3c	 mov	 eax, DWORD PTR tv282[rsp]
  006bd	89 84 24 ac 00
	00 00		 mov	 DWORD PTR dwEraseType$6[rsp], eax
$LN39@w32_intern:

; 1024 :                     mtop->mt_count ? TAPE_ERASE_LONG : TAPE_ERASE_SHORT;
; 1025 : 
; 1026 :                 do
; 1027 :                 {
; 1028 :                     errno = EraseTape( hFile, dwEraseType, FALSE );

  006c4	45 33 c0	 xor	 r8d, r8d
  006c7	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR dwEraseType$6[rsp]
  006ce	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  006d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EraseTape
  006dc	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv284[rsp], eax
  006e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006e9	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv284[rsp]
  006f0	89 08		 mov	 DWORD PTR [rax], ecx

; 1029 :                     errno = w32_internal_rc ( pStat );

  006f2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pStat$[rsp]
  006fa	e8 00 00 00 00	 call	 w32_internal_rc
  006ff	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv289[rsp], eax
  00706	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0070c	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv289[rsp]
  00713	89 08		 mov	 DWORD PTR [rax], ecx

; 1030 :                 }
; 1031 :                 while ( EINTR == errno );

  00715	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0071b	83 38 04	 cmp	 DWORD PTR [rax], 4
  0071e	74 a4		 je	 SHORT $LN39@w32_intern
$LN73@w32_intern:

; 1032 :             }
; 1033 :         }
; 1034 :         break;

  00720	eb 2a		 jmp	 SHORT $LN8@w32_intern
$LN74@w32_intern:

; 1035 : 
; 1036 :         case MTNOP:         // (no operation)
; 1037 :         {
; 1038 :             errno = 0;

  00722	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00728	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1039 :             rc = 0;

  0072e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 1040 :         }
; 1041 :         break;

  00736	eb 14		 jmp	 SHORT $LN8@w32_intern
$LN75@w32_intern:

; 1042 : 
; 1043 :         default:        // (invalid/unsupported tape operation)
; 1044 :         {
; 1045 :             errno = EINVAL;

  00738	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0073e	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 1046 :             rc = -1;

  00744	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN8@w32_intern:

; 1047 :         }
; 1048 :         break;
; 1049 :     }
; 1050 : 
; 1051 :     return (rc = (0 == errno || ENOSPC == errno) ? 0 : /* errno != 0 && errno != ENOSPC */ -1);

  0074c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00752	83 38 00	 cmp	 DWORD PTR [rax], 0
  00755	74 15		 je	 SHORT $LN79@w32_intern
  00757	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0075d	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00760	74 0a		 je	 SHORT $LN79@w32_intern
  00762	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR tv301[rsp], -1
  0076a	eb 08		 jmp	 SHORT $LN80@w32_intern
$LN79@w32_intern:
  0076c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv301[rsp], 0
$LN80@w32_intern:
  00774	8b 44 24 40	 mov	 eax, DWORD PTR tv301[rsp]
  00778	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
  0077c	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]

; 1052 : }

  00780	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00787	c3		 ret	 0
$LN81@w32_intern:
  00788	00 00 00 00	 DD	 $LN55@w32_intern
  0078c	00 00 00 00	 DD	 $LN56@w32_intern
  00790	00 00 00 00	 DD	 $LN60@w32_intern
  00794	00 00 00 00	 DD	 $LN61@w32_intern
  00798	00 00 00 00	 DD	 $LN67@w32_intern
  0079c	00 00 00 00	 DD	 $LN52@w32_intern
  007a0	00 00 00 00	 DD	 $LN48@w32_intern
  007a4	00 00 00 00	 DD	 $LN74@w32_intern
  007a8	00 00 00 00	 DD	 $LN75@w32_intern
  007ac	00 00 00 00	 DD	 $LN75@w32_intern
  007b0	00 00 00 00	 DD	 $LN75@w32_intern
  007b4	00 00 00 00	 DD	 $LN75@w32_intern
  007b8	00 00 00 00	 DD	 $LN71@w32_intern
  007bc	00 00 00 00	 DD	 $LN75@w32_intern
  007c0	00 00 00 00	 DD	 $LN75@w32_intern
  007c4	00 00 00 00	 DD	 $LN75@w32_intern
  007c8	00 00 00 00	 DD	 $LN66@w32_intern
  007cc	00 00 00 00	 DD	 $LN75@w32_intern
  007d0	00 00 00 00	 DD	 $LN75@w32_intern
  007d4	00 00 00 00	 DD	 $LN65@w32_intern
  007d8	00 00 00 00	 DD	 $LN75@w32_intern
  007dc	00 00 00 00	 DD	 $LN51@w32_intern
  007e0	00 00 00 00	 DD	 $LN75@w32_intern
  007e4	00 00 00 00	 DD	 $LN75@w32_intern
  007e8	00 00 00 00	 DD	 $LN75@w32_intern
  007ec	00 00 00 00	 DD	 $LN75@w32_intern
  007f0	00 00 00 00	 DD	 $LN75@w32_intern
  007f4	00 00 00 00	 DD	 $LN75@w32_intern
  007f8	00 00 00 00	 DD	 $LN75@w32_intern
  007fc	00 00 00 00	 DD	 $LN44@w32_intern
  00800	00 00 00 00	 DD	 $LN47@w32_intern
w32_internal_mtop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
tv135 = 32
pStat$ = 64
w32_internal_rc PROC

; 378  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@w32_intern:

; 379  :     ASSERT( pStat );    // (sanity check)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR pStat$[rsp], 0
  0000f	75 5c		 jne	 SHORT $LN10@w32_intern
$LN7@w32_intern:
  00011	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169406
  00018	41 b8 7b 01 00
	00		 mov	 r8d, 379		; 0000017bH
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169407
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169408
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00038	85 c0		 test	 eax, eax
  0003a	74 20		 je	 SHORT $LN11@w32_intern
  0003c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169410
  00043	41 b8 7b 01 00
	00		 mov	 r8d, 379		; 0000017bH
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169411
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169412
  00057	e8 00 00 00 00	 call	 DebuggerTrace
$LN11@w32_intern:
  0005c	33 c0		 xor	 eax, eax
  0005e	85 c0		 test	 eax, eax
  00060	75 af		 jne	 SHORT $LN7@w32_intern
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00068	85 c0		 test	 eax, eax
  0006a	74 01		 je	 SHORT $LN12@w32_intern
  0006c	cc		 int	 3
$LN12@w32_intern:
$LN10@w32_intern:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 96		 jne	 SHORT $LN4@w32_intern

; 380  : 
; 381  :     // PROGRAMMING NOTE: the 'door open' (no tape in drive) and the
; 382  :     // 'write protected' statuses are "sticky" in that they never change
; 383  :     // until a new/different tape is mounted. All the other statuses
; 384  :     // however, change dynamically as one does i/o to the tape...
; 385  : 
; 386  :     if (0
; 387  :         || ERROR_BUS_RESET            == errno // (See KB 111837: "ERROR_BUS_RESET May Be Benign")
; 388  :         || ERROR_MEDIA_CHANGED        == errno
; 389  :         || ERROR_DEVICE_NOT_CONNECTED == errno // (shouldn't occur but we'll check anyway)
; 390  :         || ERROR_DEV_NOT_EXIST        == errno // (shouldn't occur but we'll check anyway)
; 391  :         || ERROR_FILE_NOT_FOUND       == errno // (shouldn't occur but we'll check anyway)

  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 40		 jne	 SHORT $LN14@w32_intern
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0007f	81 38 57 04 00
	00		 cmp	 DWORD PTR [rax], 1111	; 00000457H
  00085	74 32		 je	 SHORT $LN14@w32_intern
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008d	81 38 56 04 00
	00		 cmp	 DWORD PTR [rax], 1110	; 00000456H
  00093	74 24		 je	 SHORT $LN14@w32_intern
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009b	81 38 8f 04 00
	00		 cmp	 DWORD PTR [rax], 1167	; 0000048fH
  000a1	74 16		 je	 SHORT $LN14@w32_intern
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a9	83 38 37	 cmp	 DWORD PTR [rax], 55	; 00000037H
  000ac	74 0b		 je	 SHORT $LN14@w32_intern
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b4	83 38 02	 cmp	 DWORD PTR [rax], 2
  000b7	75 24		 jne	 SHORT $LN13@w32_intern
$LN14@w32_intern:

; 392  :     )
; 393  :     {
; 394  :         *pStat  &=  ~GMT_DR_OPEN (0xFFFFFFFF);

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  000be	8b 00		 mov	 eax, DWORD PTR [rax]
  000c0	0f ba f0 12	 btr	 eax, 18
  000c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  000c9	89 01		 mov	 DWORD PTR [rcx], eax

; 395  :         *pStat  &=  ~GMT_WR_PROT (0xFFFFFFFF);

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  000d0	8b 00		 mov	 eax, DWORD PTR [rax]
  000d2	0f ba f0 1a	 btr	 eax, 26
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  000db	89 01		 mov	 DWORD PTR [rcx], eax
$LN13@w32_intern:

; 396  :     }
; 397  : 
; 398  :     // (see PROGRAMMING NOTE above)
; 399  : 
; 400  :     *pStat  &=  ~GMT_BOT (0xFFFFFFFF);

  000dd	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  000e2	8b 00		 mov	 eax, DWORD PTR [rax]
  000e4	0f ba f0 1e	 btr	 eax, 30
  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  000ed	89 01		 mov	 DWORD PTR [rcx], eax

; 401  :     *pStat  &=  ~GMT_SM  (0xFFFFFFFF);

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  000f4	8b 00		 mov	 eax, DWORD PTR [rax]
  000f6	0f ba f0 1c	 btr	 eax, 28
  000fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  000ff	89 01		 mov	 DWORD PTR [rcx], eax

; 402  :     *pStat  &=  ~GMT_EOF (0xFFFFFFFF);

  00101	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  00106	8b 00		 mov	 eax, DWORD PTR [rax]
  00108	0f ba f0 1f	 btr	 eax, 31
  0010c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  00111	89 01		 mov	 DWORD PTR [rcx], eax

; 403  :     *pStat  &=  ~GMT_EOT (0xFFFFFFFF);

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  00118	8b 00		 mov	 eax, DWORD PTR [rax]
  0011a	0f ba f0 1d	 btr	 eax, 29
  0011e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  00123	89 01		 mov	 DWORD PTR [rcx], eax

; 404  :     *pStat  &=  ~GMT_EOD (0xFFFFFFFF);

  00125	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  0012a	8b 00		 mov	 eax, DWORD PTR [rax]
  0012c	0f ba f0 1b	 btr	 eax, 27
  00130	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  00135	89 01		 mov	 DWORD PTR [rcx], eax

; 405  : 
; 406  :     if (0
; 407  :         || ERROR_BUS_RESET            == errno // (spurious error; retry)
; 408  :         || ERROR_MEDIA_CHANGED        == errno // (spurious error; retry)

  00137	33 c0		 xor	 eax, eax
  00139	85 c0		 test	 eax, eax
  0013b	75 1c		 jne	 SHORT $LN16@w32_intern
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00143	81 38 57 04 00
	00		 cmp	 DWORD PTR [rax], 1111	; 00000457H
  00149	74 0e		 je	 SHORT $LN16@w32_intern
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00151	81 38 56 04 00
	00		 cmp	 DWORD PTR [rax], 1110	; 00000456H
  00157	75 0a		 jne	 SHORT $LN15@w32_intern
$LN16@w32_intern:

; 409  : //      || ERROR_DEVICE_NOT_CONNECTED == errno // (PERM ERROR! NO RETRY!)
; 410  : //      || ERROR_DEV_NOT_EXIST        == errno // (PERM ERROR! NO RETRY!)
; 411  : //      || ERROR_FILE_NOT_FOUND       == errno // (PERM ERROR! NO RETRY!)
; 412  :     )
; 413  :     {
; 414  :         return EINTR;   // (Interrupted system call; Retry)

  00159	b8 04 00 00 00	 mov	 eax, 4
  0015e	e9 ef 01 00 00	 jmp	 $LN1@w32_intern
$LN15@w32_intern:

; 415  :     }
; 416  : 
; 417  :     // (see PROGRAMMING NOTE further above)
; 418  : 
; 419  :     switch (errno)

  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00169	8b 00		 mov	 eax, DWORD PTR [rax]
  0016b	89 44 24 20	 mov	 DWORD PTR tv135[rsp], eax
  0016f	81 7c 24 20 4d
	04 00 00	 cmp	 DWORD PTR tv135[rsp], 1101 ; 0000044dH
  00177	7f 42		 jg	 SHORT $LN30@w32_intern
  00179	81 7c 24 20 4d
	04 00 00	 cmp	 DWORD PTR tv135[rsp], 1101 ; 0000044dH
  00181	0f 84 25 01 00
	00		 je	 $LN24@w32_intern
  00187	83 7c 24 20 00	 cmp	 DWORD PTR tv135[rsp], 0
  0018c	74 70		 je	 SHORT $LN18@w32_intern
  0018e	83 7c 24 20 13	 cmp	 DWORD PTR tv135[rsp], 19
  00193	0f 84 93 01 00
	00		 je	 $LN28@w32_intern
  00199	83 7c 24 20 15	 cmp	 DWORD PTR tv135[rsp], 21
  0019e	0f 84 48 01 00
	00		 je	 $LN26@w32_intern
  001a4	83 7c 24 20 17	 cmp	 DWORD PTR tv135[rsp], 23
  001a9	74 64		 je	 SHORT $LN19@w32_intern
  001ab	81 7c 24 20 4c
	04 00 00	 cmp	 DWORD PTR tv135[rsp], 1100 ; 0000044cH
  001b3	0f 84 8a 00 00
	00		 je	 $LN21@w32_intern
  001b9	eb 3e		 jmp	 SHORT $LN17@w32_intern
$LN30@w32_intern:
  001bb	81 7c 24 20 4e
	04 00 00	 cmp	 DWORD PTR tv135[rsp], 1102 ; 0000044eH
  001c3	74 5b		 je	 SHORT $LN20@w32_intern
  001c5	81 7c 24 20 4f
	04 00 00	 cmp	 DWORD PTR tv135[rsp], 1103 ; 0000044fH
  001cd	0f 84 f9 00 00
	00		 je	 $LN25@w32_intern
  001d3	81 7c 24 20 50
	04 00 00	 cmp	 DWORD PTR tv135[rsp], 1104 ; 00000450H
  001db	0f 84 a8 00 00
	00		 je	 $LN23@w32_intern
  001e1	81 7c 24 20 58
	04 00 00	 cmp	 DWORD PTR tv135[rsp], 1112 ; 00000458H
  001e9	0f 84 1d 01 00
	00		 je	 $LN27@w32_intern
  001ef	81 7c 24 20 69
	04 00 00	 cmp	 DWORD PTR tv135[rsp], 1129 ; 00000469H
  001f7	74 6d		 je	 SHORT $LN22@w32_intern
$LN17@w32_intern:

; 420  :     {
; 421  :         default:                          break;  // (leave errno set to whatever it already is)

  001f9	e9 4c 01 00 00	 jmp	 $LN8@w32_intern
$LN18@w32_intern:

; 422  :         case NO_ERROR:    errno = 0;      break;  // (normal expected i/o result)

  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00204	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0020a	e9 3b 01 00 00	 jmp	 $LN8@w32_intern
$LN19@w32_intern:

; 423  :         case ERROR_CRC:   errno = EIO;    break;  // (dirty drive or bad media)

  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00215	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
  0021b	e9 2a 01 00 00	 jmp	 $LN8@w32_intern
$LN20@w32_intern:

; 424  : 
; 425  :         case ERROR_BEGINNING_OF_MEDIA: *pStat |= GMT_BOT     (0xFFFFFFFF); errno = EIO;       break;

  00220	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  00225	8b 00		 mov	 eax, DWORD PTR [rax]
  00227	0f ba e8 1e	 bts	 eax, 30
  0022b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  00230	89 01		 mov	 DWORD PTR [rcx], eax
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00238	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
  0023e	e9 07 01 00 00	 jmp	 $LN8@w32_intern
$LN21@w32_intern:

; 426  :         case ERROR_END_OF_MEDIA:       *pStat |= GMT_EOT     (0xFFFFFFFF); errno = ENOSPC;    break;

  00243	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  00248	8b 00		 mov	 eax, DWORD PTR [rax]
  0024a	0f ba e8 1d	 bts	 eax, 29
  0024e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  00253	89 01		 mov	 DWORD PTR [rcx], eax
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0025b	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28
  00261	e9 e4 00 00 00	 jmp	 $LN8@w32_intern
$LN22@w32_intern:

; 427  : 
; 428  :         //  "ERROR_END_OF_MEDIA"
; 429  :         //
; 430  :         //      Msg:   "The physical end of the tape has been reached."
; 431  :         //
; 432  :         //      The EOT warning reflector has been reached or passed (i.e. you're
; 433  :         //      now/still in the "EOT Warning Zone" area). Writing additional data
; 434  :         //      and/or tapemarks may still be possible depending on the size of the
; 435  :         //      EOT Warning Zone (as set by a SetTapeParameters call with a non-zero
; 436  :         //      EOTWarningZoneSize value (if supported; see further below)) and
; 437  :         //      how much data you've already written to the EOT Warning Zone area
; 438  :         //      (i.e. once you're in the warning area, this "error" occurs after
; 439  :         //      EACH and EVERY I/O [in the warning zone area] until the ABSOLUTE
; 440  :         //      physical end-of-tape (ERROR_EOM_OVERFLOW) is reached; see below).
; 441  :         //
; 442  :         //
; 443  :         //                       ***********************
; 444  :         //                       **  IMPORTANT NOTE!  **
; 445  :         //                       ***********************
; 446  :         //
; 447  :         //                    This is NOT actually an "error"!!!
; 448  :         //
; 449  :         //
; 450  :         //      When this "error" occurs, your "ReadFile" and/or "WriteFile" call
; 451  :         //      returns 'FALSE' even though ALL of your requested data was actually
; 452  :         //      written successfully!! This can be verified by checking to ensure
; 453  :         //      the returned "number of bytes written" actually matches the amount
; 454  :         //      you asked to be written. If they're the same (and they ALWAYS will
; 455  :         //      be for this specific "error" code), then it means this "error" is
; 456  :         //      NOT actually an error at all, but rather just a WARNING instead!!
; 457  :         //      (Had it been an actual i/o error, the error code would have been
; 458  :         //      some other DIFFERENT error code value instead!!)
; 459  :         //
; 460  :         //
; 461  :         //                       ***********************
; 462  :         //                       **  ALSO IMPORTANT!  **
; 463  :         //                       ***********************
; 464  :         //      See also:
; 465  :         //
; 466  :         //    http://fixunix.com/storage/205622-bug-dlttape-sys-no-eot-warning.html
; 467  :         //
; 468  :         //      for ADDITIONAL IMPORTANT INFORMATION regarding always having to
; 469  :         //      specifically request that this "error" code be returned to you:
; 470  :         //
; 471  :         //      Even when a drive reports it does not support the setting of the
; 472  :         //      the 'EOTWarningZoneSize' value (i.e. the FeaturesLow field of the
; 473  :         //      GetTapeParameters call returns '0' for TAPE_DRIVE_SET_EOT_WZ_SIZE
; 474  :         //      field), it may still be possible for "ERROR_END_OF_MEDIA" warnings
; 475  :         //      to be generated anyway by simply calling SetTapeParameters with a
; 476  :         //      non-zero 'EOTWarningZoneSize' value anyway.
; 477  :         //
; 478  :         //      The reason for this is because some drives may not allow CHANGING
; 479  :         //      the value (thus the reason for it reporting that setting the value
; 480  :         //      is not supported), but may nevertheless still support the ENABLING
; 481  :         //      of their own hard-coded internal value. That is to say, while the
; 482  :         //      size of the warning zone may not be modifiable (as it may be hard-
; 483  :         //      coded and thus unchangeable), the drive may still have the ability
; 484  :         //      to REPORT reaching the EOT Warning zone IF SPECIFICALLY REQUESTED
; 485  :         //      TO DO SO! (which is presumably what requesting a non-zero Warning
; 486  :         //      Zone size would end up doing: i.e. even though such calls APPEAR
; 487  :         //      to fail, they actually DO succeed in accomplishing SOMETHING, just
; 488  :         //      not what you originally/specifically requested).
; 489  :         //
; 490  :         //      Thus calling SetTapeParameters with a non-zero 'EOTWarningZoneSize'
; 491  :         //      value might very well succeed anyway even though GetTapeParameters
; 492  :         //      reports that doing so is not supported, and by so doing, may cause
; 493  :         //      the drive to begin reporting of "ERROR_END_OF_MEDIA" (whereas not
; 494  :         //      attempting to do so would end up leaving the drive in its default
; 495  :         //      non-reporting mode. That is to say, you should ALWAYS try setting
; 496  :         //      a non-zero 'EOTWarningZoneSize' value, ignoring any "unsupported"
; 497  :         //      error code that may be returned from such a call.)
; 498  : 
; 499  :         case ERROR_EOM_OVERFLOW:       *pStat |= GMT_EOT     (0xFFFFFFFF); errno = EIO;       break;

  00266	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  0026b	8b 00		 mov	 eax, DWORD PTR [rax]
  0026d	0f ba e8 1d	 bts	 eax, 29
  00271	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  00276	89 01		 mov	 DWORD PTR [rcx], eax
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0027e	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
  00284	e9 c1 00 00 00	 jmp	 $LN8@w32_intern
$LN23@w32_intern:

; 500  : 
; 501  :         //  "ERROR_EOM_OVERFLOW"
; 502  :         //
; 503  :         //      Msg:   "Physical end of tape encountered."
; 504  :         //
; 505  :         //      This error code means that the actual physical end-of-media has been
; 506  :         //      reached, and no more data can be written to the tape. This includes
; 507  :         //      tapemarks as well.
; 508  :         //
; 509  :         //                       ***********************
; 510  :         //                       **  IMPORTANT NOTE!  **
; 511  :         //                       ***********************
; 512  :         //
; 513  :         //                 This is a HARD (UNRECOVERABLE) error!!
; 514  :         //
; 515  :         //      To be programmatically informed of when you are coming close to the
; 516  :         //      physical end-of-the-tape (such that you could be assured room still
; 517  :         //      remained to write logical end-of-volume labels for example), simply
; 518  :         //      call SetTapeParameters with a non-zero 'EOTWarningZoneSize' value
; 519  :         //      and treat any "ERROR_END_OF_MEDIA" "errors" received when writing
; 520  :         //      as warnings instead. (See prior discussion of "ERROR_END_OF_MEDIA"
; 521  :         //      return code further above)
; 522  : 
; 523  :         case ERROR_NO_DATA_DETECTED:   *pStat |= GMT_EOD     (0xFFFFFFFF); errno = EIO;       break;

  00289	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  0028e	8b 00		 mov	 eax, DWORD PTR [rax]
  00290	0f ba e8 1b	 bts	 eax, 27
  00294	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  00299	89 01		 mov	 DWORD PTR [rcx], eax
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a1	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
  002a7	e9 9e 00 00 00	 jmp	 $LN8@w32_intern
$LN24@w32_intern:

; 524  :         case ERROR_FILEMARK_DETECTED:  *pStat |= GMT_EOF     (0xFFFFFFFF); errno = EIO;       break;

  002ac	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  002b1	8b 00		 mov	 eax, DWORD PTR [rax]
  002b3	0f ba e8 1f	 bts	 eax, 31
  002b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  002bc	89 01		 mov	 DWORD PTR [rcx], eax
  002be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002c4	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
  002ca	eb 7e		 jmp	 SHORT $LN8@w32_intern
$LN25@w32_intern:

; 525  :         case ERROR_SETMARK_DETECTED:   *pStat |= GMT_SM      (0xFFFFFFFF); errno = EIO;       break;

  002cc	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  002d1	8b 00		 mov	 eax, DWORD PTR [rax]
  002d3	0f ba e8 1c	 bts	 eax, 28
  002d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  002dc	89 01		 mov	 DWORD PTR [rcx], eax
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002e4	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
  002ea	eb 5e		 jmp	 SHORT $LN8@w32_intern
$LN26@w32_intern:

; 526  :         case ERROR_NOT_READY:          *pStat |= GMT_DR_OPEN (0xFFFFFFFF); errno = ENOMEDIUM; break;

  002ec	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  002f1	8b 00		 mov	 eax, DWORD PTR [rax]
  002f3	0f ba e8 12	 bts	 eax, 18
  002f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  002fc	89 01		 mov	 DWORD PTR [rcx], eax
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00304	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
  0030a	eb 3e		 jmp	 SHORT $LN8@w32_intern
$LN27@w32_intern:

; 527  :         case ERROR_NO_MEDIA_IN_DRIVE:  *pStat |= GMT_DR_OPEN (0xFFFFFFFF); errno = ENOMEDIUM; break;

  0030c	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  00311	8b 00		 mov	 eax, DWORD PTR [rax]
  00313	0f ba e8 12	 bts	 eax, 18
  00317	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  0031c	89 01		 mov	 DWORD PTR [rcx], eax
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00324	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
  0032a	eb 1e		 jmp	 SHORT $LN8@w32_intern
$LN28@w32_intern:

; 528  :         case ERROR_WRITE_PROTECT:      *pStat |= GMT_WR_PROT (0xFFFFFFFF); errno = EROFS;     break;

  0032c	48 8b 44 24 40	 mov	 rax, QWORD PTR pStat$[rsp]
  00331	8b 00		 mov	 eax, DWORD PTR [rax]
  00333	0f ba e8 1a	 bts	 eax, 26
  00337	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pStat$[rsp]
  0033c	89 01		 mov	 DWORD PTR [rcx], eax
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00344	c7 00 1e 00 00
	00		 mov	 DWORD PTR [rax], 30
$LN8@w32_intern:

; 529  :     }
; 530  :     return errno;

  0034a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00350	8b 00		 mov	 eax, DWORD PTR [rax]
$LN1@w32_intern:

; 531  : }

  00352	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00356	c3		 ret	 0
w32_internal_rc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
dwTapeStatus$ = 32
hFile$ = 64
w32_get_tape_status PROC

; 147  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@w32_get_ta:

; 148  :     // ***************************************************************
; 149  :     //  PROGRAMMING NOTE: it is THIS LOOP (retrieving the status
; 150  :     //  of the tape drive) that takes UP TO *10* SECONDS TO COMPLETE
; 151  :     //  if there is no tape mounted on the drive whereas it completes
; 152  :     //  immediately when there IS a tape mounted!  I have no idea why
; 153  :     //  Windows behave so unusually/inefficiently in this way! - Fish
; 154  :     // ***************************************************************
; 155  : 
; 156  :     DWORD dwTapeStatus;
; 157  : 
; 158  :     // (NOTE: see also: KB 111837: "ERROR_BUS_RESET May Be Benign")
; 159  : 
; 160  :     do dwTapeStatus = GetTapeStatus( hFile );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hFile$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTapeStatus
  00014	89 44 24 20	 mov	 DWORD PTR dwTapeStatus$[rsp], eax

; 161  :     while (ERROR_BUS_RESET == dwTapeStatus);

  00018	81 7c 24 20 57
	04 00 00	 cmp	 DWORD PTR dwTapeStatus$[rsp], 1111 ; 00000457H
  00020	74 e7		 je	 SHORT $LN4@w32_get_ta

; 162  : 
; 163  :     return dwTapeStatus;

  00022	8b 44 24 20	 mov	 eax, DWORD PTR dwTapeStatus$[rsp]

; 164  : }

  00026	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002a	c3		 ret	 0
w32_get_tape_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
rc$ = 32
ifd$ = 64
w32_free_ifd PROC

; 129  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 130  :     int rc = 0;

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 131  :     errno = 0;

  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00016	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 132  : 
; 133  :     lock();

  0001c	e8 00 00 00 00	 call	 obtain_w32stape_lock

; 134  :     {
; 135  :         rc = w32_free_ifd_nolock( ifd );

  00021	8b 4c 24 40	 mov	 ecx, DWORD PTR ifd$[rsp]
  00025	e8 00 00 00 00	 call	 w32_free_ifd_nolock
  0002a	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 136  :     }
; 137  :     unlock();

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169239
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 138  : 
; 139  :     return rc;

  00042	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 140  : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
w32_free_ifd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
rc$ = 32
$T1 = 40
ifd$ = 64
w32_free_ifd_nolock PROC

; 109  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 110  :     int rc = 0;

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 111  :     errno = 0;

  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00016	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 112  : 
; 113  :     if ( ifd >= 0  &&  ifd < W32STAPE_MAX_FDNUMS )

  0001c	83 7c 24 40 00	 cmp	 DWORD PTR ifd$[rsp], 0
  00021	7c 32		 jl	 SHORT $LN2@w32_free_i
  00023	83 7c 24 40 20	 cmp	 DWORD PTR ifd$[rsp], 32	; 00000020H
  00028	7d 2b		 jge	 SHORT $LN2@w32_free_i

; 114  :         g_ifds [ ifd ] = 0;

  0002a	48 63 44 24 40	 movsxd	 rax, DWORD PTR ifd$[rsp]
  0002f	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00034	48 83 7c 24 28
	20		 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  0003a	73 02		 jae	 SHORT $LN5@w32_free_i
  0003c	eb 05		 jmp	 SHORT $LN6@w32_free_i
$LN5@w32_free_i:
  0003e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN6@w32_free_i:
  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:g_ifds
  0004a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0004f	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  00053	eb 14		 jmp	 SHORT $LN3@w32_free_i
$LN2@w32_free_i:

; 115  :     else
; 116  :     {
; 117  :         rc = -1;

  00055	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 118  :         errno = EBADF;

  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00063	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
$LN3@w32_free_i:

; 119  :     }
; 120  : 
; 121  :     return rc;

  00069	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN4@w32_free_i:

; 122  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
w32_free_ifd_nolock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
n$1 = 32
ifd$ = 36
pifd_slot$2 = 40
w32_alloc_ifd PROC

; 79   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 80   :     ifd_t ifd = -1;

  00004	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR ifd$[rsp], -1

; 81   :     errno = EMFILE;

  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00012	c7 00 18 00 00
	00		 mov	 DWORD PTR [rax], 24

; 82   : 
; 83   :     lock();

  00018	e8 00 00 00 00	 call	 obtain_w32stape_lock

; 84   :     {
; 85   :         BYTE* pifd_slot = memchr( g_ifds, 0, W32STAPE_MAX_FDNUMS );

  0001d	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00023	33 d2		 xor	 edx, edx
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_ifds
  0002c	e8 00 00 00 00	 call	 memchr
  00031	48 89 44 24 28	 mov	 QWORD PTR pifd_slot$2[rsp], rax

; 86   : 
; 87   :         if (pifd_slot)

  00036	48 83 7c 24 28
	00		 cmp	 QWORD PTR pifd_slot$2[rsp], 0
  0003c	74 40		 je	 SHORT $LN2@w32_alloc_

; 88   :         {
; 89   :             int n = (int) (pifd_slot - g_ifds);

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:g_ifds
  00045	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pifd_slot$2[rsp]
  0004a	48 2b c8	 sub	 rcx, rax
  0004d	48 8b c1	 mov	 rax, rcx
  00050	89 44 24 20	 mov	 DWORD PTR n$1[rsp], eax

; 90   : 
; 91   :             if ( n >= 0  &&  n < W32STAPE_MAX_FDNUMS )

  00054	83 7c 24 20 00	 cmp	 DWORD PTR n$1[rsp], 0
  00059	7c 23		 jl	 SHORT $LN3@w32_alloc_
  0005b	83 7c 24 20 20	 cmp	 DWORD PTR n$1[rsp], 32	; 00000020H
  00060	7d 1c		 jge	 SHORT $LN3@w32_alloc_

; 92   :             {
; 93   :                 *pifd_slot = 1;

  00062	48 8b 44 24 28	 mov	 rax, QWORD PTR pifd_slot$2[rsp]
  00067	c6 00 01	 mov	 BYTE PTR [rax], 1

; 94   :                 errno = 0;

  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00070	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 95   :                 ifd = n;

  00076	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  0007a	89 44 24 24	 mov	 DWORD PTR ifd$[rsp], eax
$LN3@w32_alloc_:
$LN2@w32_alloc_:

; 96   :             }
; 97   :         }
; 98   :     }
; 99   :     unlock();

  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169225
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 100  : 
; 101  :     return ifd;

  00092	8b 44 24 24	 mov	 eax, DWORD PTR ifd$[rsp]

; 102  : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
w32_alloc_ifd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
obtain_w32stape_lock PROC

; 55   : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 56   :     static int bDidInit  = 0;
; 57   :     static int bInitBusy = 1;
; 58   :     if (!bDidInit)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDidInit@?1??obtain_w32stape_lock@@9@9, 0
  0000d	0f 85 a4 00 00
	00		 jne	 $LN4@obtain_w32

; 59   :     {
; 60   :         bDidInit = 1;

  00013	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDidInit@?1??obtain_w32stape_lock@@9@9, 1

; 61   :         initialize_lock ( &g_lock );

  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169214
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169215
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 62   :         memset( g_ifds,    0,    sizeof ( g_ifds    ) );

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:g_ifds
  0003f	48 8b f8	 mov	 rdi, rax
  00042	33 c0		 xor	 eax, eax
  00044	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00049	f3 aa		 rep stosb

; 63   :         memset( g_handles, 0,    sizeof ( g_handles ) );

  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:g_handles
  00052	48 8b f8	 mov	 rdi, rax
  00055	33 c0		 xor	 eax, eax
  00057	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0005c	f3 aa		 rep stosb

; 64   :         memset( g_fnames,  0,    sizeof ( g_fnames  ) );

  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:g_fnames
  00065	48 8b f8	 mov	 rdi, rax
  00068	33 c0		 xor	 eax, eax
  0006a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0006f	f3 aa		 rep stosb

; 65   :         memset( g_fstats,  0,    sizeof ( g_fstats  ) );

  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:g_fstats
  00078	48 8b f8	 mov	 rdi, rax
  0007b	33 c0		 xor	 eax, eax
  0007d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00082	f3 aa		 rep stosb

; 66   :         memset( g_BOTmsk,  0xFF, sizeof ( g_BOTmsk  ) );

  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:g_BOTmsk
  0008b	48 8b f8	 mov	 rdi, rax
  0008e	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00093	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00098	f3 aa		 rep stosb

; 67   :         memset( g_BOTbot,  0,    sizeof ( g_BOTbot  ) );

  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:g_BOTbot
  000a1	48 8b f8	 mov	 rdi, rax
  000a4	33 c0		 xor	 eax, eax
  000a6	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000ab	f3 aa		 rep stosb

; 68   :         bInitBusy = 0;

  000ad	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bInitBusy@?1??obtain_w32stape_lock@@9@9, 0
$LN4@obtain_w32:
$LN2@obtain_w32:

; 69   :     }
; 70   :     while (bInitBusy) Sleep(10);

  000b7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bInitBusy@?1??obtain_w32stape_lock@@9@9, 0
  000be	74 0d		 je	 SHORT $LN3@obtain_w32
  000c0	b9 0a 00 00 00	 mov	 ecx, 10
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
  000cb	eb ea		 jmp	 SHORT $LN2@obtain_w32
$LN3@obtain_w32:

; 71   :     obtain_lock ( &g_lock );

  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169216
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 72   : }

  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
obtain_w32stape_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
ifd$ = 48
bSuccess$ = 52
dwBytesWritten$ = 56
dwLastError$ = 60
tv95 = 64
pStat$ = 72
hFile$ = 80
ufd$ = 112
buf$ = 120
nbyte$ = 128
w32_write_tape PROC

; 664  : {

$LN40:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 665  :     BOOL     bSuccess;
; 666  :     DWORD    dwBytesWritten;
; 667  :     DWORD    dwLastError;
; 668  : 
; 669  :     ifd_t    ifd    = W32STAPE_UFD2IFD( ufd );

  00012	8b 44 24 70	 mov	 eax, DWORD PTR ufd$[rsp]
  00016	25 ff ff ff 80	 and	 eax, -2130706433	; ffffffff80ffffffH
  0001b	89 44 24 30	 mov	 DWORD PTR ifd$[rsp], eax

; 670  :     U32*     pStat  = NULL;

  0001f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pStat$[rsp], 0

; 671  :     HANDLE   hFile;
; 672  : 
; 673  :     if (!buf)

  00028	48 83 7c 24 78
	00		 cmp	 QWORD PTR buf$[rsp], 0
  0002e	75 18		 jne	 SHORT $LN23@w32_write_

; 674  :     {
; 675  :         errno = EINVAL;

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00036	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 676  :         return -1;

  0003c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00043	e9 92 02 00 00	 jmp	 $LN1@w32_write_
$LN23@w32_write_:

; 677  :     }
; 678  : 
; 679  :     lock();

  00048	e8 00 00 00 00	 call	 obtain_w32stape_lock

; 680  : 
; 681  :     if (0
; 682  :         ||         ifd    <   0
; 683  :         ||         ifd    >=  W32STAPE_MAX_FDNUMS
; 684  :         || g_ifds[ ifd ]  ==  0

  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 22		 jne	 SHORT $LN25@w32_write_
  00053	83 7c 24 30 00	 cmp	 DWORD PTR ifd$[rsp], 0
  00058	7c 1b		 jl	 SHORT $LN25@w32_write_
  0005a	83 7c 24 30 20	 cmp	 DWORD PTR ifd$[rsp], 32	; 00000020H
  0005f	7d 14		 jge	 SHORT $LN25@w32_write_
  00061	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_ifds
  0006d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00071	85 c0		 test	 eax, eax
  00073	75 2c		 jne	 SHORT $LN24@w32_write_
$LN25@w32_write_:

; 685  :     )
; 686  :     {
; 687  :         unlock();

  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169621
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 688  :         errno = EBADF;

  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008f	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 689  :         return -1;

  00095	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0009c	e9 39 02 00 00	 jmp	 $LN1@w32_write_
$LN24@w32_write_:

; 690  :     }
; 691  : 
; 692  :     unlock();

  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169622
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 693  : 
; 694  :     hFile = g_handles[ ifd ];

  000b5	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_handles
  000c1	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000c5	48 89 44 24 50	 mov	 QWORD PTR hFile$[rsp], rax

; 695  :     pStat = &g_fstats[ ifd ];

  000ca	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_fstats
  000d6	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000da	48 89 44 24 48	 mov	 QWORD PTR pStat$[rsp], rax
$LN4@w32_write_:

; 696  : 
; 697  :     // Do the i/o, save results, update device status
; 698  :     // (based on the results), then check results...
; 699  : 
; 700  :     do
; 701  :     {
; 702  :         dwBytesWritten = 0;

  000df	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR dwBytesWritten$[rsp], 0

; 703  :         bSuccess       = WriteFile( hFile, buf, (DWORD)nbyte, &dwBytesWritten, NULL );

  000e7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f0	4c 8d 4c 24 38	 lea	 r9, QWORD PTR dwBytesWritten$[rsp]
  000f5	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR nbyte$[rsp]
  000fd	48 8b 54 24 78	 mov	 rdx, QWORD PTR buf$[rsp]
  00102	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hFile$[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile
  0010d	89 44 24 34	 mov	 DWORD PTR bSuccess$[rsp], eax

; 704  :         errno          = (dwLastError = GetLastError());

  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00117	89 44 24 3c	 mov	 DWORD PTR dwLastError$[rsp], eax
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00121	8b 4c 24 3c	 mov	 ecx, DWORD PTR dwLastError$[rsp]
  00125	89 08		 mov	 DWORD PTR [rax], ecx

; 705  :         errno          = w32_internal_rc ( pStat );

  00127	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pStat$[rsp]
  0012c	e8 00 00 00 00	 call	 w32_internal_rc
  00131	89 44 24 40	 mov	 DWORD PTR tv95[rsp], eax
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013b	8b 4c 24 40	 mov	 ecx, DWORD PTR tv95[rsp]
  0013f	89 08		 mov	 DWORD PTR [rax], ecx

; 706  :     }
; 707  :     while ( !bSuccess && EINTR == errno );

  00141	83 7c 24 34 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  00146	75 0b		 jne	 SHORT $LN26@w32_write_
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0014e	83 38 04	 cmp	 DWORD PTR [rax], 4
  00151	74 8c		 je	 SHORT $LN4@w32_write_
$LN26@w32_write_:

; 708  : 
; 709  :     // Success?  (see: "ERROR_END_OF_MEDIA" in function 'w32_internal_rc')
; 710  : 
; 711  :     if (bSuccess || ERROR_END_OF_MEDIA == dwLastError)

  00153	83 7c 24 34 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  00158	75 0e		 jne	 SHORT $LN28@w32_write_
  0015a	81 7c 24 3c 4c
	04 00 00	 cmp	 DWORD PTR dwLastError$[rsp], 1100 ; 0000044cH
  00162	0f 85 ed 00 00
	00		 jne	 $LN27@w32_write_
$LN28@w32_write_:
$LN7@w32_write_:

; 712  :     {
; 713  :         ASSERT( bSuccess || ENOSPC == errno );

  00168	83 7c 24 34 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  0016d	75 67		 jne	 SHORT $LN29@w32_write_
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00175	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00178	74 5c		 je	 SHORT $LN29@w32_write_
$LN10@w32_write_:
  0017a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169627
  00181	41 b8 c9 02 00
	00		 mov	 r8d, 713		; 000002c9H
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169628
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169629
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001a1	85 c0		 test	 eax, eax
  001a3	74 20		 je	 SHORT $LN30@w32_write_
  001a5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169631
  001ac	41 b8 c9 02 00
	00		 mov	 r8d, 713		; 000002c9H
  001b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169632
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169633
  001c0	e8 00 00 00 00	 call	 DebuggerTrace
$LN30@w32_write_:
  001c5	33 c0		 xor	 eax, eax
  001c7	85 c0		 test	 eax, eax
  001c9	75 af		 jne	 SHORT $LN10@w32_write_
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001d1	85 c0		 test	 eax, eax
  001d3	74 01		 je	 SHORT $LN31@w32_write_
  001d5	cc		 int	 3
$LN31@w32_write_:
$LN29@w32_write_:
  001d6	33 c0		 xor	 eax, eax
  001d8	85 c0		 test	 eax, eax
  001da	75 8c		 jne	 SHORT $LN7@w32_write_
$LN13@w32_write_:

; 714  :         ASSERT( ((size_t)dwBytesWritten) == nbyte );  // (MUST be true!!)

  001dc	8b 44 24 38	 mov	 eax, DWORD PTR dwBytesWritten$[rsp]
  001e0	48 3b 84 24 80
	00 00 00	 cmp	 rax, QWORD PTR nbyte$[rsp]
  001e8	74 5c		 je	 SHORT $LN32@w32_write_
$LN16@w32_write_:
  001ea	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169636
  001f1	41 b8 ca 02 00
	00		 mov	 r8d, 714		; 000002caH
  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169637
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169638
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0020b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00211	85 c0		 test	 eax, eax
  00213	74 20		 je	 SHORT $LN33@w32_write_
  00215	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169640
  0021c	41 b8 ca 02 00
	00		 mov	 r8d, 714		; 000002caH
  00222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169641
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169642
  00230	e8 00 00 00 00	 call	 DebuggerTrace
$LN33@w32_write_:
  00235	33 c0		 xor	 eax, eax
  00237	85 c0		 test	 eax, eax
  00239	75 af		 jne	 SHORT $LN16@w32_write_
  0023b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00241	85 c0		 test	 eax, eax
  00243	74 01		 je	 SHORT $LN34@w32_write_
  00245	cc		 int	 3
$LN34@w32_write_:
$LN32@w32_write_:
  00246	33 c0		 xor	 eax, eax
  00248	85 c0		 test	 eax, eax
  0024a	75 90		 jne	 SHORT $LN13@w32_write_

; 715  :         return ( (ssize_t) dwBytesWritten );

  0024c	8b 44 24 38	 mov	 eax, DWORD PTR dwBytesWritten$[rsp]
  00250	e9 85 00 00 00	 jmp	 $LN1@w32_write_
$LN27@w32_write_:
$LN19@w32_write_:

; 716  :     }
; 717  : 
; 718  :     // I/O error...
; 719  : 
; 720  :     ASSERT( !bSuccess && ERROR_END_OF_MEDIA != dwLastError && ENOSPC != errno );

  00255	83 7c 24 34 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  0025a	75 15		 jne	 SHORT $LN36@w32_write_
  0025c	81 7c 24 3c 4c
	04 00 00	 cmp	 DWORD PTR dwLastError$[rsp], 1100 ; 0000044cH
  00264	74 0b		 je	 SHORT $LN36@w32_write_
  00266	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0026c	83 38 1c	 cmp	 DWORD PTR [rax], 28
  0026f	75 5c		 jne	 SHORT $LN35@w32_write_
$LN36@w32_write_:
$LN22@w32_write_:
  00271	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169646
  00278	41 b8 d0 02 00
	00		 mov	 r8d, 720		; 000002d0H
  0027e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169647
  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169648
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00298	85 c0		 test	 eax, eax
  0029a	74 20		 je	 SHORT $LN37@w32_write_
  0029c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169650
  002a3	41 b8 d0 02 00
	00		 mov	 r8d, 720		; 000002d0H
  002a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169651
  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169652
  002b7	e8 00 00 00 00	 call	 DebuggerTrace
$LN37@w32_write_:
  002bc	33 c0		 xor	 eax, eax
  002be	85 c0		 test	 eax, eax
  002c0	75 af		 jne	 SHORT $LN22@w32_write_
  002c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002c8	85 c0		 test	 eax, eax
  002ca	74 01		 je	 SHORT $LN38@w32_write_
  002cc	cc		 int	 3
$LN38@w32_write_:
$LN35@w32_write_:
  002cd	33 c0		 xor	 eax, eax
  002cf	85 c0		 test	 eax, eax
  002d1	75 82		 jne	 SHORT $LN19@w32_write_

; 721  :     return -1;

  002d3	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN1@w32_write_:

; 722  : }

  002da	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002de	c3		 ret	 0
w32_write_tape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
ifd$ = 48
dwLastError$ = 52
bSuccess$ = 56
dwBytesRead$ = 60
tv95 = 64
pStat$ = 72
hFile$ = 80
ufd$ = 112
buf$ = 120
nbyte$ = 128
w32_read_tape PROC

; 590  : {

$LN50:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 591  :     BOOL    bSuccess;
; 592  :     DWORD   dwBytesRead;
; 593  :     DWORD   dwLastError;
; 594  : 
; 595  :     ifd_t   ifd    = W32STAPE_UFD2IFD( ufd );

  00012	8b 44 24 70	 mov	 eax, DWORD PTR ufd$[rsp]
  00016	25 ff ff ff 80	 and	 eax, -2130706433	; ffffffff80ffffffH
  0001b	89 44 24 30	 mov	 DWORD PTR ifd$[rsp], eax

; 596  :     U32*    pStat  = NULL;

  0001f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pStat$[rsp], 0

; 597  :     HANDLE  hFile;
; 598  : 
; 599  :     if (!buf)

  00028	48 83 7c 24 78
	00		 cmp	 QWORD PTR buf$[rsp], 0
  0002e	75 18		 jne	 SHORT $LN29@w32_read_t

; 600  :     {
; 601  :         errno = EINVAL;

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00036	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 602  :         return -1;

  0003c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00043	e9 19 03 00 00	 jmp	 $LN1@w32_read_t
$LN29@w32_read_t:

; 603  :     }
; 604  : 
; 605  :     lock();

  00048	e8 00 00 00 00	 call	 obtain_w32stape_lock

; 606  : 
; 607  :     if (0
; 608  :         ||         ifd    <   0
; 609  :         ||         ifd    >=  W32STAPE_MAX_FDNUMS
; 610  :         || g_ifds[ ifd ]  ==  0

  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 22		 jne	 SHORT $LN31@w32_read_t
  00053	83 7c 24 30 00	 cmp	 DWORD PTR ifd$[rsp], 0
  00058	7c 1b		 jl	 SHORT $LN31@w32_read_t
  0005a	83 7c 24 30 20	 cmp	 DWORD PTR ifd$[rsp], 32	; 00000020H
  0005f	7d 14		 jge	 SHORT $LN31@w32_read_t
  00061	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_ifds
  0006d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00071	85 c0		 test	 eax, eax
  00073	75 2c		 jne	 SHORT $LN30@w32_read_t
$LN31@w32_read_t:

; 611  :     )
; 612  :     {
; 613  :         unlock();

  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169535
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 614  :         errno = EBADF;

  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008f	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 615  :         return -1;

  00095	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0009c	e9 c0 02 00 00	 jmp	 $LN1@w32_read_t
$LN30@w32_read_t:

; 616  :     }
; 617  : 
; 618  :     unlock();

  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169536
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 619  : 
; 620  :     hFile = g_handles[ ifd ];

  000b5	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_handles
  000c1	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000c5	48 89 44 24 50	 mov	 QWORD PTR hFile$[rsp], rax

; 621  :     pStat = &g_fstats[ ifd ];

  000ca	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_fstats
  000d6	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000da	48 89 44 24 48	 mov	 QWORD PTR pStat$[rsp], rax
$LN4@w32_read_t:

; 622  : 
; 623  :     // Do the i/o, save results, update device status
; 624  :     // (based on the results), then check results...
; 625  : 
; 626  :     do
; 627  :     {
; 628  :         dwBytesRead = 0;

  000df	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR dwBytesRead$[rsp], 0

; 629  :         bSuccess    = ReadFile( hFile, buf, (DWORD)nbyte, &dwBytesRead, NULL );

  000e7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f0	4c 8d 4c 24 3c	 lea	 r9, QWORD PTR dwBytesRead$[rsp]
  000f5	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR nbyte$[rsp]
  000fd	48 8b 54 24 78	 mov	 rdx, QWORD PTR buf$[rsp]
  00102	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hFile$[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  0010d	89 44 24 38	 mov	 DWORD PTR bSuccess$[rsp], eax

; 630  :         errno       = (dwLastError = GetLastError());

  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00117	89 44 24 34	 mov	 DWORD PTR dwLastError$[rsp], eax
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00121	8b 4c 24 34	 mov	 ecx, DWORD PTR dwLastError$[rsp]
  00125	89 08		 mov	 DWORD PTR [rax], ecx

; 631  :         errno       = w32_internal_rc ( pStat );

  00127	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pStat$[rsp]
  0012c	e8 00 00 00 00	 call	 w32_internal_rc
  00131	89 44 24 40	 mov	 DWORD PTR tv95[rsp], eax
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013b	8b 4c 24 40	 mov	 ecx, DWORD PTR tv95[rsp]
  0013f	89 08		 mov	 DWORD PTR [rax], ecx

; 632  :     }
; 633  :     while ( !bSuccess && EINTR == errno );

  00141	83 7c 24 38 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  00146	75 0b		 jne	 SHORT $LN32@w32_read_t
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0014e	83 38 04	 cmp	 DWORD PTR [rax], 4
  00151	74 8c		 je	 SHORT $LN4@w32_read_t
$LN32@w32_read_t:

; 634  : 
; 635  :     // Success?  (see: "ERROR_END_OF_MEDIA" in function 'w32_internal_rc')
; 636  : 
; 637  :     if (bSuccess || ERROR_END_OF_MEDIA == dwLastError)

  00153	83 7c 24 38 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  00158	75 0a		 jne	 SHORT $LN34@w32_read_t
  0015a	81 7c 24 34 4c
	04 00 00	 cmp	 DWORD PTR dwLastError$[rsp], 1100 ; 0000044cH
  00162	75 7d		 jne	 SHORT $LN33@w32_read_t
$LN34@w32_read_t:
$LN7@w32_read_t:

; 638  :     {
; 639  :         ASSERT( bSuccess || ENOSPC == errno );

  00164	83 7c 24 38 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  00169	75 67		 jne	 SHORT $LN35@w32_read_t
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00171	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00174	74 5c		 je	 SHORT $LN35@w32_read_t
$LN10@w32_read_t:
  00176	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169541
  0017d	41 b8 7f 02 00
	00		 mov	 r8d, 639		; 0000027fH
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169542
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169543
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0019d	85 c0		 test	 eax, eax
  0019f	74 20		 je	 SHORT $LN36@w32_read_t
  001a1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169545
  001a8	41 b8 7f 02 00
	00		 mov	 r8d, 639		; 0000027fH
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169546
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169547
  001bc	e8 00 00 00 00	 call	 DebuggerTrace
$LN36@w32_read_t:
  001c1	33 c0		 xor	 eax, eax
  001c3	85 c0		 test	 eax, eax
  001c5	75 af		 jne	 SHORT $LN10@w32_read_t
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001cd	85 c0		 test	 eax, eax
  001cf	74 01		 je	 SHORT $LN37@w32_read_t
  001d1	cc		 int	 3
$LN37@w32_read_t:
$LN35@w32_read_t:
  001d2	33 c0		 xor	 eax, eax
  001d4	85 c0		 test	 eax, eax
  001d6	75 8c		 jne	 SHORT $LN7@w32_read_t

; 640  :         return ( (ssize_t) dwBytesRead );

  001d8	8b 44 24 3c	 mov	 eax, DWORD PTR dwBytesRead$[rsp]
  001dc	e9 80 01 00 00	 jmp	 $LN1@w32_read_t
$LN33@w32_read_t:
$LN13@w32_read_t:

; 641  :     }
; 642  : 
; 643  :     ASSERT( !bSuccess && ERROR_END_OF_MEDIA != dwLastError && ENOSPC != errno );

  001e1	83 7c 24 38 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  001e6	75 15		 jne	 SHORT $LN39@w32_read_t
  001e8	81 7c 24 34 4c
	04 00 00	 cmp	 DWORD PTR dwLastError$[rsp], 1100 ; 0000044cH
  001f0	74 0b		 je	 SHORT $LN39@w32_read_t
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001f8	83 38 1c	 cmp	 DWORD PTR [rax], 28
  001fb	75 5c		 jne	 SHORT $LN38@w32_read_t
$LN39@w32_read_t:
$LN16@w32_read_t:
  001fd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169551
  00204	41 b8 83 02 00
	00		 mov	 r8d, 643		; 00000283H
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169552
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169553
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00224	85 c0		 test	 eax, eax
  00226	74 20		 je	 SHORT $LN40@w32_read_t
  00228	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169555
  0022f	41 b8 83 02 00
	00		 mov	 r8d, 643		; 00000283H
  00235	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169556
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169557
  00243	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@w32_read_t:
  00248	33 c0		 xor	 eax, eax
  0024a	85 c0		 test	 eax, eax
  0024c	75 af		 jne	 SHORT $LN16@w32_read_t
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00254	85 c0		 test	 eax, eax
  00256	74 01		 je	 SHORT $LN41@w32_read_t
  00258	cc		 int	 3
$LN41@w32_read_t:
$LN38@w32_read_t:
  00259	33 c0		 xor	 eax, eax
  0025b	85 c0		 test	 eax, eax
  0025d	75 82		 jne	 SHORT $LN13@w32_read_t

; 644  : 
; 645  :     // The i/o "failed".  Check to see if it was just a tapemark...
; 646  : 
; 647  :     if ( EIO == errno && GMT_EOF( *pStat ) )

  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00265	83 38 05	 cmp	 DWORD PTR [rax], 5
  00268	0f 85 80 00 00
	00		 jne	 $LN42@w32_read_t
  0026e	48 8b 44 24 48	 mov	 rax, QWORD PTR pStat$[rsp]
  00273	8b 00		 mov	 eax, DWORD PTR [rax]
  00275	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0027a	85 c0		 test	 eax, eax
  0027c	74 70		 je	 SHORT $LN42@w32_read_t
$LN19@w32_read_t:

; 648  :     {
; 649  :         ASSERT( ERROR_FILEMARK_DETECTED == dwLastError );

  0027e	81 7c 24 34 4d
	04 00 00	 cmp	 DWORD PTR dwLastError$[rsp], 1101 ; 0000044dH
  00286	74 5c		 je	 SHORT $LN43@w32_read_t
$LN22@w32_read_t:
  00288	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169561
  0028f	41 b8 89 02 00
	00		 mov	 r8d, 649		; 00000289H
  00295	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169562
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169563
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002af	85 c0		 test	 eax, eax
  002b1	74 20		 je	 SHORT $LN44@w32_read_t
  002b3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169565
  002ba	41 b8 89 02 00
	00		 mov	 r8d, 649		; 00000289H
  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169566
  002c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169567
  002ce	e8 00 00 00 00	 call	 DebuggerTrace
$LN44@w32_read_t:
  002d3	33 c0		 xor	 eax, eax
  002d5	85 c0		 test	 eax, eax
  002d7	75 af		 jne	 SHORT $LN22@w32_read_t
  002d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002df	85 c0		 test	 eax, eax
  002e1	74 01		 je	 SHORT $LN45@w32_read_t
  002e3	cc		 int	 3
$LN45@w32_read_t:
$LN43@w32_read_t:
  002e4	33 c0		 xor	 eax, eax
  002e6	85 c0		 test	 eax, eax
  002e8	75 94		 jne	 SHORT $LN19@w32_read_t

; 650  :         return 0;   // (tapemark)

  002ea	33 c0		 xor	 eax, eax
  002ec	eb 73		 jmp	 SHORT $LN1@w32_read_t
$LN42@w32_read_t:
$LN25@w32_read_t:

; 651  :     }
; 652  : 
; 653  :     // EIO != errno || !GMT_EOF( *pStat )  -->  bonafide i/o error...
; 654  : 
; 655  :     ASSERT( ERROR_FILEMARK_DETECTED != dwLastError );

  002ee	81 7c 24 34 4d
	04 00 00	 cmp	 DWORD PTR dwLastError$[rsp], 1101 ; 0000044dH
  002f6	75 5c		 jne	 SHORT $LN46@w32_read_t
$LN28@w32_read_t:
  002f8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169570
  002ff	41 b8 8f 02 00
	00		 mov	 r8d, 655		; 0000028fH
  00305	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169571
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169572
  00313	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00319	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0031f	85 c0		 test	 eax, eax
  00321	74 20		 je	 SHORT $LN47@w32_read_t
  00323	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169574
  0032a	41 b8 8f 02 00
	00		 mov	 r8d, 655		; 0000028fH
  00330	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169575
  00337	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169576
  0033e	e8 00 00 00 00	 call	 DebuggerTrace
$LN47@w32_read_t:
  00343	33 c0		 xor	 eax, eax
  00345	85 c0		 test	 eax, eax
  00347	75 af		 jne	 SHORT $LN28@w32_read_t
  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0034f	85 c0		 test	 eax, eax
  00351	74 01		 je	 SHORT $LN48@w32_read_t
  00353	cc		 int	 3
$LN48@w32_read_t:
$LN46@w32_read_t:
  00354	33 c0		 xor	 eax, eax
  00356	85 c0		 test	 eax, eax
  00358	75 94		 jne	 SHORT $LN25@w32_read_t

; 656  :     return -1;

  0035a	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN1@w32_read_t:

; 657  : }

  00361	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00365	c3		 ret	 0
w32_read_tape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
ifd$ = 32
tv152 = 36
tv155 = 40
rc$ = 44
pName$1 = 48
hFile$2 = 56
ufd$ = 80
w32_close_tape PROC

; 546  : {

$LN17:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 547  :     ifd_t  ifd  = W32STAPE_UFD2IFD( ufd );

  00008	8b 44 24 50	 mov	 eax, DWORD PTR ufd$[rsp]
  0000c	25 ff ff ff 80	 and	 eax, -2130706433	; ffffffff80ffffffH
  00011	89 44 24 20	 mov	 DWORD PTR ifd$[rsp], eax

; 548  :     int    rc   = -1;

  00015	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 549  :     errno       = EBADF;

  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00023	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 550  : 
; 551  :     lock();

  00029	e8 00 00 00 00	 call	 obtain_w32stape_lock

; 552  : 
; 553  :     if (1
; 554  :         &&         ifd    >=  0
; 555  :         &&         ifd    <   W32STAPE_MAX_FDNUMS
; 556  :         && g_ifds[ ifd ]  !=  0

  0002e	33 c0		 xor	 eax, eax
  00030	83 f8 01	 cmp	 eax, 1
  00033	0f 84 8f 01 00
	00		 je	 $LN8@w32_close_
  00039	83 7c 24 20 00	 cmp	 DWORD PTR ifd$[rsp], 0
  0003e	0f 8c 84 01 00
	00		 jl	 $LN8@w32_close_
  00044	83 7c 24 20 20	 cmp	 DWORD PTR ifd$[rsp], 32	; 00000020H
  00049	0f 8d 79 01 00
	00		 jge	 $LN8@w32_close_
  0004f	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_ifds
  0005b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005f	85 c0		 test	 eax, eax
  00061	0f 84 61 01 00
	00		 je	 $LN8@w32_close_

; 557  :     )
; 558  :     {
; 559  :         // Deallocate resources
; 560  : 
; 561  :         HANDLE  hFile  = g_handles[ ifd ];

  00067	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_handles
  00073	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00077	48 89 44 24 38	 mov	 QWORD PTR hFile$2[rsp], rax

; 562  :         char*   pName  = g_fnames [ ifd ];

  0007c	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_fnames
  00088	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0008c	48 89 44 24 30	 mov	 QWORD PTR pName$1[rsp], rax

; 563  : 
; 564  :         g_handles[ ifd ] = NULL;

  00091	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_handles
  0009d	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 565  :         g_fnames [ ifd ] = NULL;

  000a5	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_fnames
  000b1	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 566  :         g_fstats [ ifd ] = GMT_DR_OPEN (0xFFFFFFFF);

  000b9	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_fstats
  000c5	c7 04 81 00 00
	04 00		 mov	 DWORD PTR [rcx+rax*4], 262144 ; 00040000H

; 567  :         g_BOTmsk [ ifd ] = 0xFFFFFFFF;

  000cc	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_BOTmsk
  000d8	c7 04 81 ff ff
	ff ff		 mov	 DWORD PTR [rcx+rax*4], -1 ; ffffffffH

; 568  :         g_BOTbot [ ifd ] = 0x00000000;

  000df	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_BOTbot
  000eb	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
$LN4@w32_close_:

; 569  : 
; 570  :         VERIFY( w32_free_ifd_nolock( ifd ) == 0 );

  000f2	8b 4c 24 20	 mov	 ecx, DWORD PTR ifd$[rsp]
  000f6	e8 00 00 00 00	 call	 w32_free_ifd_nolock
  000fb	85 c0		 test	 eax, eax
  000fd	74 5c		 je	 SHORT $LN9@w32_close_
$LN7@w32_close_:
  000ff	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169478
  00106	41 b8 3a 02 00
	00		 mov	 r8d, 570		; 0000023aH
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169479
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169480
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00126	85 c0		 test	 eax, eax
  00128	74 20		 je	 SHORT $LN10@w32_close_
  0012a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169482
  00131	41 b8 3a 02 00
	00		 mov	 r8d, 570		; 0000023aH
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169483
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169484
  00145	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@w32_close_:
  0014a	33 c0		 xor	 eax, eax
  0014c	85 c0		 test	 eax, eax
  0014e	75 af		 jne	 SHORT $LN7@w32_close_
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00156	85 c0		 test	 eax, eax
  00158	74 01		 je	 SHORT $LN11@w32_close_
  0015a	cc		 int	 3
$LN11@w32_close_:
$LN9@w32_close_:
  0015b	33 c0		 xor	 eax, eax
  0015d	85 c0		 test	 eax, eax
  0015f	75 91		 jne	 SHORT $LN4@w32_close_

; 571  : 
; 572  :         // Close the file...
; 573  : 
; 574  :         free( pName );

  00161	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pName$1[rsp]
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 575  : 
; 576  :         errno  =  CloseHandle( hFile ) ? 0 : w32_trans_w32error( GetLastError() );

  0016c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hFile$2[rsp]
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00177	85 c0		 test	 eax, eax
  00179	74 0a		 je	 SHORT $LN13@w32_close_
  0017b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
  00183	eb 12		 jmp	 SHORT $LN14@w32_close_
$LN13@w32_close_:
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0018b	8b c8		 mov	 ecx, eax
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_trans_w32error
  00193	89 44 24 24	 mov	 DWORD PTR tv152[rsp], eax
$LN14@w32_close_:
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0019d	8b 4c 24 24	 mov	 ecx, DWORD PTR tv152[rsp]
  001a1	89 08		 mov	 DWORD PTR [rax], ecx

; 577  :         rc     =  errno ? -1 : 0;

  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001a9	83 38 00	 cmp	 DWORD PTR [rax], 0
  001ac	74 0a		 je	 SHORT $LN15@w32_close_
  001ae	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR tv155[rsp], -1
  001b6	eb 08		 jmp	 SHORT $LN16@w32_close_
$LN15@w32_close_:
  001b8	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN16@w32_close_:
  001c0	8b 44 24 28	 mov	 eax, DWORD PTR tv155[rsp]
  001c4	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax
$LN8@w32_close_:

; 578  :     }
; 579  : 
; 580  :     unlock();

  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169486
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 581  : 
; 582  :     return rc;

  001dc	8b 44 24 2c	 mov	 eax, DWORD PTR rc$[rsp]

; 583  : }

  001e0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001e4	c3		 ret	 0
w32_close_tape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
ifd$ = 48
rc$ = 52
tv91 = 56
ptr$ = 64
pStat$ = 72
vl$ = 80
hFile$ = 88
mtget$1 = 96
mtpos$2 = 104
mtop$3 = 112
ufd$ = 144
request$ = 152
w32_ioctl_tape PROC

; 729  : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000d	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00012	57		 push	 rdi
  00013	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 730  :     va_list  vl;
; 731  :     void*    ptr    = NULL;

  0001a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR ptr$[rsp], 0

; 732  :     int      rc     = 0;

  00023	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 733  :     ifd_t    ifd    = W32STAPE_UFD2IFD( ufd );

  0002b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ufd$[rsp]
  00032	25 ff ff ff 80	 and	 eax, -2130706433	; ffffffff80ffffffH
  00037	89 44 24 30	 mov	 DWORD PTR ifd$[rsp], eax

; 734  :     U32*     pStat  = NULL;

  0003b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pStat$[rsp], 0

; 735  :     HANDLE   hFile;
; 736  : 
; 737  :     lock();

  00044	e8 00 00 00 00	 call	 obtain_w32stape_lock

; 738  : 
; 739  :     if (0
; 740  :         ||         ifd    <   0
; 741  :         ||         ifd    >=  W32STAPE_MAX_FDNUMS
; 742  :         || g_ifds[ ifd ]  ==  0

  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 22		 jne	 SHORT $LN5@w32_ioctl_
  0004f	83 7c 24 30 00	 cmp	 DWORD PTR ifd$[rsp], 0
  00054	7c 1b		 jl	 SHORT $LN5@w32_ioctl_
  00056	83 7c 24 30 20	 cmp	 DWORD PTR ifd$[rsp], 32	; 00000020H
  0005b	7d 14		 jge	 SHORT $LN5@w32_ioctl_
  0005d	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_ifds
  00069	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0006d	85 c0		 test	 eax, eax
  0006f	75 2a		 jne	 SHORT $LN4@w32_ioctl_
$LN5@w32_ioctl_:

; 743  :     )
; 744  :     {
; 745  :         unlock();

  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169693
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 746  :         errno = EBADF;

  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008b	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 747  :         return -1;

  00091	b8 ff ff ff ff	 mov	 eax, -1
  00096	e9 6e 01 00 00	 jmp	 $LN1@w32_ioctl_
$LN4@w32_ioctl_:

; 748  :     }
; 749  : 
; 750  :     unlock();

  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169694
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 751  : 
; 752  :     hFile = g_handles[ ifd ];

  000af	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_handles
  000bb	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000bf	48 89 44 24 58	 mov	 QWORD PTR hFile$[rsp], rax

; 753  :     pStat = &g_fstats[ ifd ];

  000c4	48 63 44 24 30	 movsxd	 rax, DWORD PTR ifd$[rsp]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_fstats
  000d0	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000d4	48 89 44 24 48	 mov	 QWORD PTR pStat$[rsp], rax

; 754  : 
; 755  :     va_start ( vl, request );

  000d9	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR request$[rsp+8]
  000e1	48 89 44 24 50	 mov	 QWORD PTR vl$[rsp], rax

; 756  :     ptr = va_arg( vl, void* );

  000e6	48 8b 44 24 50	 mov	 rax, QWORD PTR vl$[rsp]
  000eb	48 83 c0 08	 add	 rax, 8
  000ef	48 89 44 24 50	 mov	 QWORD PTR vl$[rsp], rax
  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR vl$[rsp]
  000f9	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  000fd	48 89 44 24 40	 mov	 QWORD PTR ptr$[rsp], rax

; 757  : 
; 758  :     if ( !ptr )

  00102	48 83 7c 24 40
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00108	75 16		 jne	 SHORT $LN6@w32_ioctl_

; 759  :     {
; 760  :         errno = EINVAL;

  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00110	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 761  :         return -1;

  00116	b8 ff ff ff ff	 mov	 eax, -1
  0011b	e9 e9 00 00 00	 jmp	 $LN1@w32_ioctl_
$LN6@w32_ioctl_:

; 762  :     }
; 763  : 
; 764  :     switch (request)

  00120	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR request$[rsp]
  00127	89 44 24 38	 mov	 DWORD PTR tv91[rsp], eax
  0012b	81 7c 24 38 01
	6d 08 80	 cmp	 DWORD PTR tv91[rsp], -2146931455 ; ffffffff80086d01H
  00133	74 19		 je	 SHORT $LN7@w32_ioctl_
  00135	81 7c 24 38 03
	6d 04 40	 cmp	 DWORD PTR tv91[rsp], 1074031875 ; 40046d03H
  0013d	74 72		 je	 SHORT $LN9@w32_ioctl_
  0013f	81 7c 24 38 02
	6d 1c 40	 cmp	 DWORD PTR tv91[rsp], 1075604738 ; 401c6d02H
  00147	74 31		 je	 SHORT $LN8@w32_ioctl_
  00149	e9 a3 00 00 00	 jmp	 $LN10@w32_ioctl_
$LN7@w32_ioctl_:

; 765  :     {
; 766  :         case MTIOCTOP:  // (perform tape operation)
; 767  :         {
; 768  :             struct mtop* mtop = ptr;

  0014e	48 8b 44 24 40	 mov	 rax, QWORD PTR ptr$[rsp]
  00153	48 89 44 24 70	 mov	 QWORD PTR mtop$3[rsp], rax

; 769  :             rc = w32_internal_mtop ( hFile, pStat, mtop, ifd );

  00158	44 8b 4c 24 30	 mov	 r9d, DWORD PTR ifd$[rsp]
  0015d	4c 8b 44 24 70	 mov	 r8, QWORD PTR mtop$3[rsp]
  00162	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStat$[rsp]
  00167	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  0016c	e8 00 00 00 00	 call	 w32_internal_mtop
  00171	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 770  :         }
; 771  :         break;

  00175	e9 8b 00 00 00	 jmp	 $LN2@w32_ioctl_
$LN8@w32_ioctl_:

; 772  : 
; 773  :         case MTIOCGET:  // (retrieve tape status)
; 774  :         {
; 775  :             struct mtget* mtget = ptr;

  0017a	48 8b 44 24 40	 mov	 rax, QWORD PTR ptr$[rsp]
  0017f	48 89 44 24 60	 mov	 QWORD PTR mtget$1[rsp], rax

; 776  :             memset( mtget, 0, sizeof(*mtget) );

  00184	48 8b 7c 24 60	 mov	 rdi, QWORD PTR mtget$1[rsp]
  00189	33 c0		 xor	 eax, eax
  0018b	b9 1c 00 00 00	 mov	 ecx, 28
  00190	f3 aa		 rep stosb

; 777  :             rc = w32_internal_mtget ( hFile, pStat, mtget, ifd );

  00192	44 8b 4c 24 30	 mov	 r9d, DWORD PTR ifd$[rsp]
  00197	4c 8b 44 24 60	 mov	 r8, QWORD PTR mtget$1[rsp]
  0019c	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStat$[rsp]
  001a1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  001a6	e8 00 00 00 00	 call	 w32_internal_mtget
  001ab	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 778  :         }
; 779  :         break;

  001af	eb 54		 jmp	 SHORT $LN2@w32_ioctl_
$LN9@w32_ioctl_:

; 780  : 
; 781  :         case MTIOCPOS:  // (retrieve tape position)
; 782  :         {
; 783  :             struct mtpos* mtpos = ptr;

  001b1	48 8b 44 24 40	 mov	 rax, QWORD PTR ptr$[rsp]
  001b6	48 89 44 24 68	 mov	 QWORD PTR mtpos$2[rsp], rax

; 784  :             memset( mtpos, 0, sizeof(*mtpos) );

  001bb	48 8b 7c 24 68	 mov	 rdi, QWORD PTR mtpos$2[rsp]
  001c0	33 c0		 xor	 eax, eax
  001c2	b9 04 00 00 00	 mov	 ecx, 4
  001c7	f3 aa		 rep stosb

; 785  :             rc = w32_internal_mtpos( hFile, pStat, &mtpos->mt_blkno, NULL, ifd );

  001c9	48 8b 44 24 68	 mov	 rax, QWORD PTR mtpos$2[rsp]
  001ce	8b 4c 24 30	 mov	 ecx, DWORD PTR ifd$[rsp]
  001d2	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001d6	45 33 c9	 xor	 r9d, r9d
  001d9	4c 8b c0	 mov	 r8, rax
  001dc	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStat$[rsp]
  001e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  001e6	e8 00 00 00 00	 call	 w32_internal_mtpos
  001eb	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 786  :         }
; 787  :         break;

  001ef	eb 14		 jmp	 SHORT $LN2@w32_ioctl_
$LN10@w32_ioctl_:

; 788  : 
; 789  :         default:    // (invalid/unsupported ioctl code)
; 790  :         {
; 791  :             errno = EINVAL;

  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001f7	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 792  :             rc = -1;

  001fd	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN2@w32_ioctl_:

; 793  :         }
; 794  :         break;
; 795  :     }
; 796  : 
; 797  :     return rc;

  00205	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@w32_ioctl_:

; 798  : }

  00209	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00210	5f		 pop	 rdi
  00211	c3		 ret	 0
w32_ioctl_tape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
ifd$ = 32
ufd$ = 64
msk$ = 72
bot$ = 80
w32_define_BOT PROC

; 324  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 325  :     ifd_t  ifd  = W32STAPE_UFD2IFD( ufd );

  00011	8b 44 24 40	 mov	 eax, DWORD PTR ufd$[rsp]
  00015	25 ff ff ff 80	 and	 eax, -2130706433	; ffffffff80ffffffH
  0001a	89 44 24 20	 mov	 DWORD PTR ifd$[rsp], eax

; 326  : 
; 327  :     lock();

  0001e	e8 00 00 00 00	 call	 obtain_w32stape_lock

; 328  : 
; 329  :     if (0
; 330  :         ||         ifd    <   0
; 331  :         ||         ifd    >=  W32STAPE_MAX_FDNUMS
; 332  :         || g_ifds[ ifd ]  ==  0

  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	75 22		 jne	 SHORT $LN3@w32_define
  00029	83 7c 24 20 00	 cmp	 DWORD PTR ifd$[rsp], 0
  0002e	7c 1b		 jl	 SHORT $LN3@w32_define
  00030	83 7c 24 20 20	 cmp	 DWORD PTR ifd$[rsp], 32	; 00000020H
  00035	7d 14		 jge	 SHORT $LN3@w32_define
  00037	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_ifds
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	85 c0		 test	 eax, eax
  00049	75 27		 jne	 SHORT $LN2@w32_define
$LN3@w32_define:

; 333  :     )
; 334  :     {
; 335  :         unlock();

  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169391
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 336  :         errno = EBADF;

  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00065	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 337  :         return -1;

  0006b	b8 ff ff ff ff	 mov	 eax, -1
  00070	eb 3c		 jmp	 SHORT $LN1@w32_define
$LN2@w32_define:

; 338  :     }
; 339  : 
; 340  :     g_BOTmsk [ ifd ]  = msk;   // (BOT block-id mask)

  00072	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_BOTmsk
  0007e	8b 54 24 48	 mov	 edx, DWORD PTR msk$[rsp]
  00082	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 341  :     g_BOTbot [ ifd ]  = bot;   // (BOT block-id value)

  00085	48 63 44 24 20	 movsxd	 rax, DWORD PTR ifd$[rsp]
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_BOTbot
  00091	8b 54 24 50	 mov	 edx, DWORD PTR bot$[rsp]
  00095	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 342  : 
; 343  :     unlock();

  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169392
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_lock
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 344  : 
; 345  :     return 0;

  000ac	33 c0		 xor	 eax, eax
$LN1@w32_define:

; 346  : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
w32_define_BOT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32stape.c
_TEXT	SEGMENT
ifd$ = 64
dwRetCode$ = 68
dwDesiredAccess$ = 72
pszTapeDevNum$ = 80
dwSizeofDriveParms$ = 88
hFile$ = 96
save_errno$1 = 104
save_errno$2 = 108
$T3 = 112
szTapeDeviceName$ = 120
__$ArrayPad$ = 136
path$ = 160
oflag$ = 168
w32_open_tape PROC

; 171  : {

$LN75:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000e	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00013	57		 push	 rdi
  00014	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 172  :     ifd_t       ifd;
; 173  :     HANDLE      hFile;
; 174  :     char        szTapeDeviceName[10];
; 175  :     const char* pszTapeDevNum;
; 176  :     DWORD       dwDesiredAccess, dwSizeofDriveParms, dwRetCode;
; 177  : 
; 178  :     // Reserve an fd number right away and bail if none available...
; 179  :     if ( (ifd = w32_alloc_ifd()) < 0 )

  0002d	e8 00 00 00 00	 call	 w32_alloc_ifd
  00032	89 44 24 40	 mov	 DWORD PTR ifd$[rsp], eax
  00036	83 7c 24 40 00	 cmp	 DWORD PTR ifd$[rsp], 0
  0003b	7d 0a		 jge	 SHORT $LN41@w32_open_t

; 180  :         return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	e9 13 06 00 00	 jmp	 $LN1@w32_open_t
$LN41@w32_open_t:

; 181  : 
; 182  :     // If they specified a Windows device name,
; 183  :     // use it as-is.
; 184  : 
; 185  :     if (1
; 186  :         && strnfilenamecmp( path, "\\\\.\\", 4 ) == 0
; 187  :         &&                  path            [4]  != 0

  00047	33 c0		 xor	 eax, eax
  00049	83 f8 01	 cmp	 eax, 1
  0004c	74 56		 je	 SHORT $LN42@w32_open_t
  0004e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169313
  0005b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00069	85 c0		 test	 eax, eax
  0006b	75 37		 jne	 SHORT $LN42@w32_open_t
  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	48 6b c0 04	 imul	 rax, rax, 4
  00076	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0007e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00082	85 c0		 test	 eax, eax
  00084	74 1e		 je	 SHORT $LN42@w32_open_t

; 188  :     )
; 189  :     {
; 190  :         STRLCPY( szTapeDeviceName, path );

  00086	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0008c	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  00094	48 8d 4c 24 78	 lea	 rcx, QWORD PTR szTapeDeviceName$[rsp]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 191  :     }

  0009f	e9 98 01 00 00	 jmp	 $LN43@w32_open_t
$LN42@w32_open_t:

; 192  :     else // (not a Windows device name)
; 193  :     {
; 194  :         // The device name is a Cygwin/*nix device name.
; 195  :         // Name must be either "/dev/nst0" or "/dev/st0"
; 196  : 
; 197  :         if (1
; 198  :             &&  strnfilenamecmp( path, "/dev/", 5 ) == 0
; 199  :             &&  (
; 200  :                     strnfilenamecmp( (pszTapeDevNum=path+8)-3, "nst", 3 ) == 0
; 201  :                     ||
; 202  :                     strnfilenamecmp( (pszTapeDevNum=path+7)-2, "st",  2 ) == 0
; 203  :                 )
; 204  :             &&  strlen(pszTapeDevNum) == 1
; 205  :             &&  isdigit(*pszTapeDevNum)

  000a4	33 c0		 xor	 eax, eax
  000a6	83 f8 01	 cmp	 eax, 1
  000a9	0f 84 08 01 00
	00		 je	 $LN44@w32_open_t
  000af	41 b8 05 00 00
	00		 mov	 r8d, 5
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169316
  000bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000ca	85 c0		 test	 eax, eax
  000cc	0f 85 e5 00 00
	00		 jne	 $LN44@w32_open_t
  000d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  000da	48 83 c0 08	 add	 rax, 8
  000de	48 89 44 24 50	 mov	 QWORD PTR pszTapeDevNum$[rsp], rax
  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR pszTapeDevNum$[rsp]
  000e8	48 83 e8 03	 sub	 rax, 3
  000ec	41 b8 03 00 00
	00		 mov	 r8d, 3
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169318
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00102	85 c0		 test	 eax, eax
  00104	74 34		 je	 SHORT $LN46@w32_open_t
  00106	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  0010e	48 83 c0 07	 add	 rax, 7
  00112	48 89 44 24 50	 mov	 QWORD PTR pszTapeDevNum$[rsp], rax
  00117	48 8b 44 24 50	 mov	 rax, QWORD PTR pszTapeDevNum$[rsp]
  0011c	48 83 e8 02	 sub	 rax, 2
  00120	41 b8 02 00 00
	00		 mov	 r8d, 2
  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169319
  0012d	48 8b c8	 mov	 rcx, rax
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00136	85 c0		 test	 eax, eax
  00138	75 7d		 jne	 SHORT $LN44@w32_open_t
$LN46@w32_open_t:
  0013a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pszTapeDevNum$[rsp]
  0013f	e8 00 00 00 00	 call	 strlen
  00144	48 83 f8 01	 cmp	 rax, 1
  00148	75 6d		 jne	 SHORT $LN44@w32_open_t
  0014a	48 8b 44 24 50	 mov	 rax, QWORD PTR pszTapeDevNum$[rsp]
  0014f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00152	8b c8		 mov	 ecx, eax
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  0015a	85 c0		 test	 eax, eax
  0015c	74 59		 je	 SHORT $LN44@w32_open_t

; 206  :         )
; 207  :         {
; 208  :             // Change it to a Windows device name (e.g. \\.\Tape0)
; 209  : 
; 210  :             STRLCPY( szTapeDeviceName, WIN32_TAPE_DEVICE_NAME );

  0015e	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00164	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169320
  0016b	48 8d 4c 24 78	 lea	 rcx, QWORD PTR szTapeDeviceName$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 211  :             szTapeDeviceName[8] = *pszTapeDevNum;

  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	48 6b c0 08	 imul	 rax, rax, 8
  0017f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pszTapeDevNum$[rsp]
  00184	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00187	88 4c 04 78	 mov	 BYTE PTR szTapeDeviceName$[rsp+rax], cl

; 212  :             szTapeDeviceName[9] = 0;

  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	48 6b c0 09	 imul	 rax, rax, 9
  00194	48 89 44 24 70	 mov	 QWORD PTR $T3[rsp], rax
  00199	48 83 7c 24 70
	0a		 cmp	 QWORD PTR $T3[rsp], 10
  0019f	73 02		 jae	 SHORT $LN71@w32_open_t
  001a1	eb 05		 jmp	 SHORT $LN72@w32_open_t
$LN71@w32_open_t:
  001a3	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN72@w32_open_t:
  001a8	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
  001ad	c6 44 04 78 00	 mov	 BYTE PTR szTapeDeviceName$[rsp+rax], 0

; 213  : 
; 214  :             // PROGRAMMING NOTE: the "rewind at close" option (implied by
; 215  :             // virtue of the filename being "/dev/st0" and not "/dev/nst0")
; 216  :             // was handled (detected/remembered) by the higher-level caller.
; 217  :         }

  001b2	e9 85 00 00 00	 jmp	 $LN45@w32_open_t
$LN44@w32_open_t:
$LN4@w32_open_t:

; 218  :         else
; 219  :         {
; 220  :             VERIFY( w32_free_ifd( ifd ) == 0 );

  001b7	8b 4c 24 40	 mov	 ecx, DWORD PTR ifd$[rsp]
  001bb	e8 00 00 00 00	 call	 w32_free_ifd
  001c0	85 c0		 test	 eax, eax
  001c2	74 5c		 je	 SHORT $LN47@w32_open_t
$LN7@w32_open_t:
  001c4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169322
  001cb	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  001d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169323
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169324
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001eb	85 c0		 test	 eax, eax
  001ed	74 20		 je	 SHORT $LN48@w32_open_t
  001ef	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169326
  001f6	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169327
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169328
  0020a	e8 00 00 00 00	 call	 DebuggerTrace
$LN48@w32_open_t:
  0020f	33 c0		 xor	 eax, eax
  00211	85 c0		 test	 eax, eax
  00213	75 af		 jne	 SHORT $LN7@w32_open_t
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0021b	85 c0		 test	 eax, eax
  0021d	74 01		 je	 SHORT $LN49@w32_open_t
  0021f	cc		 int	 3
$LN49@w32_open_t:
$LN47@w32_open_t:
  00220	33 c0		 xor	 eax, eax
  00222	85 c0		 test	 eax, eax
  00224	75 91		 jne	 SHORT $LN4@w32_open_t

; 221  :             errno = EINVAL;     // (bad device name)

  00226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0022c	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 222  :             return -1;          // (open failure)

  00232	b8 ff ff ff ff	 mov	 eax, -1
  00237	e9 1e 04 00 00	 jmp	 $LN1@w32_open_t
$LN45@w32_open_t:
$LN43@w32_open_t:

; 223  :         }
; 224  :     }
; 225  : 
; 226  :     // We only support O_BINARY with either O_RDWR or O_RDONLY
; 227  : 
; 228  :     if (1
; 229  :         && (( O_BINARY | O_RDWR  ) != oflag)
; 230  :         && (( O_BINARY | O_RDONLY) != oflag)

  0023c	33 c0		 xor	 eax, eax
  0023e	83 f8 01	 cmp	 eax, 1
  00241	0f 84 a7 00 00
	00		 je	 $LN50@w32_open_t
  00247	81 bc 24 a8 00
	00 00 02 80 00
	00		 cmp	 DWORD PTR oflag$[rsp], 32770 ; 00008002H
  00252	0f 84 96 00 00
	00		 je	 $LN50@w32_open_t
  00258	81 bc 24 a8 00
	00 00 00 80 00
	00		 cmp	 DWORD PTR oflag$[rsp], 32768 ; 00008000H
  00263	0f 84 85 00 00
	00		 je	 $LN50@w32_open_t
$LN10@w32_open_t:

; 231  :     )
; 232  :     {
; 233  :         VERIFY( w32_free_ifd( ifd ) == 0 );

  00269	8b 4c 24 40	 mov	 ecx, DWORD PTR ifd$[rsp]
  0026d	e8 00 00 00 00	 call	 w32_free_ifd
  00272	85 c0		 test	 eax, eax
  00274	74 5c		 je	 SHORT $LN51@w32_open_t
$LN13@w32_open_t:
  00276	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169332
  0027d	41 b8 e9 00 00
	00		 mov	 r8d, 233		; 000000e9H
  00283	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169333
  0028a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169334
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00297	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0029d	85 c0		 test	 eax, eax
  0029f	74 20		 je	 SHORT $LN52@w32_open_t
  002a1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169336
  002a8	41 b8 e9 00 00
	00		 mov	 r8d, 233		; 000000e9H
  002ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169337
  002b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169338
  002bc	e8 00 00 00 00	 call	 DebuggerTrace
$LN52@w32_open_t:
  002c1	33 c0		 xor	 eax, eax
  002c3	85 c0		 test	 eax, eax
  002c5	75 af		 jne	 SHORT $LN13@w32_open_t
  002c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002cd	85 c0		 test	 eax, eax
  002cf	74 01		 je	 SHORT $LN53@w32_open_t
  002d1	cc		 int	 3
$LN53@w32_open_t:
$LN51@w32_open_t:
  002d2	33 c0		 xor	 eax, eax
  002d4	85 c0		 test	 eax, eax
  002d6	75 91		 jne	 SHORT $LN10@w32_open_t

; 234  :         errno = EINVAL;     // (invalid open flags)

  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002de	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 235  :         return -1;          // (open failure)

  002e4	b8 ff ff ff ff	 mov	 eax, -1
  002e9	e9 6c 03 00 00	 jmp	 $LN1@w32_open_t
$LN50@w32_open_t:

; 236  :     }
; 237  : 
; 238  :     // Set desired access
; 239  : 
; 240  :     dwDesiredAccess = GENERIC_READ;

  002ee	c7 44 24 48 00
	00 00 80	 mov	 DWORD PTR dwDesiredAccess$[rsp], -2147483648 ; 80000000H

; 241  : 
; 242  :     if ( oflag & O_RDWR )

  002f6	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR oflag$[rsp]
  002fd	83 e0 02	 and	 eax, 2
  00300	85 c0		 test	 eax, eax
  00302	74 0c		 je	 SHORT $LN54@w32_open_t

; 243  :         dwDesiredAccess |= GENERIC_WRITE;

  00304	8b 44 24 48	 mov	 eax, DWORD PTR dwDesiredAccess$[rsp]
  00308	0f ba e8 1e	 bts	 eax, 30
  0030c	89 44 24 48	 mov	 DWORD PTR dwDesiredAccess$[rsp], eax
$LN54@w32_open_t:

; 244  : 
; 245  :     // Open the tape drive...
; 246  : 
; 247  :     hFile = CreateFile

  00310	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00319	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00321	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00329	45 33 c9	 xor	 r9d, r9d
  0032c	45 33 c0	 xor	 r8d, r8d
  0032f	8b 54 24 48	 mov	 edx, DWORD PTR dwDesiredAccess$[rsp]
  00333	48 8d 4c 24 78	 lea	 rcx, QWORD PTR szTapeDeviceName$[rsp]
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  0033e	48 89 44 24 60	 mov	 QWORD PTR hFile$[rsp], rax

; 248  :     (
; 249  :         szTapeDeviceName,   // filename
; 250  :         dwDesiredAccess,    // desired access
; 251  :         0,                  // share mode (0 == exclusive)
; 252  :         NULL,               // security == default
; 253  :         OPEN_EXISTING,      // "file" (device actually) must already exist
; 254  :         0,                  // no special access flags needed
; 255  :         NULL                // not using template
; 256  :     );
; 257  : 
; 258  :     if ( INVALID_HANDLE_VALUE == hFile )

  00343	48 83 7c 24 60
	ff		 cmp	 QWORD PTR hFile$[rsp], -1
  00349	0f 85 97 00 00
	00		 jne	 $LN55@w32_open_t

; 259  :     {
; 260  :         int save_errno = w32_trans_w32error( GetLastError() );

  0034f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00355	8b c8		 mov	 ecx, eax
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_trans_w32error
  0035d	89 44 24 68	 mov	 DWORD PTR save_errno$1[rsp], eax
$LN16@w32_open_t:

; 261  :         VERIFY( w32_free_ifd( ifd ) == 0 );

  00361	8b 4c 24 40	 mov	 ecx, DWORD PTR ifd$[rsp]
  00365	e8 00 00 00 00	 call	 w32_free_ifd
  0036a	85 c0		 test	 eax, eax
  0036c	74 5c		 je	 SHORT $LN56@w32_open_t
$LN19@w32_open_t:
  0036e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169343
  00375	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0037b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169344
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169345
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00395	85 c0		 test	 eax, eax
  00397	74 20		 je	 SHORT $LN57@w32_open_t
  00399	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169347
  003a0	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  003a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169348
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169349
  003b4	e8 00 00 00 00	 call	 DebuggerTrace
$LN57@w32_open_t:
  003b9	33 c0		 xor	 eax, eax
  003bb	85 c0		 test	 eax, eax
  003bd	75 af		 jne	 SHORT $LN19@w32_open_t
  003bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003c5	85 c0		 test	 eax, eax
  003c7	74 01		 je	 SHORT $LN58@w32_open_t
  003c9	cc		 int	 3
$LN58@w32_open_t:
$LN56@w32_open_t:
  003ca	33 c0		 xor	 eax, eax
  003cc	85 c0		 test	 eax, eax
  003ce	75 91		 jne	 SHORT $LN16@w32_open_t

; 262  :         errno = save_errno;

  003d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003d6	8b 4c 24 68	 mov	 ecx, DWORD PTR save_errno$1[rsp]
  003da	89 08		 mov	 DWORD PTR [rax], ecx

; 263  :         return -1;

  003dc	b8 ff ff ff ff	 mov	 eax, -1
  003e1	e9 74 02 00 00	 jmp	 $LN1@w32_open_t
$LN55@w32_open_t:

; 264  :     }
; 265  : 
; 266  :     // Save drive parameters for later...
; 267  : 
; 268  :     memset( &g_drive_parms[ifd], 0, sizeof(TAPE_GET_DRIVE_PARAMETERS) );

  003e6	48 63 44 24 40	 movsxd	 rax, DWORD PTR ifd$[rsp]
  003eb	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_drive_parms
  003f6	48 03 c8	 add	 rcx, rax
  003f9	48 8b c1	 mov	 rax, rcx
  003fc	48 8b f8	 mov	 rdi, rax
  003ff	33 c0		 xor	 eax, eax
  00401	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00406	f3 aa		 rep stosb

; 269  :     dwSizeofDriveParms = sizeof(TAPE_GET_DRIVE_PARAMETERS);

  00408	c7 44 24 58 20
	00 00 00	 mov	 DWORD PTR dwSizeofDriveParms$[rsp], 32 ; 00000020H
$LN74@w32_open_t:
$LN73@w32_open_t:
$LN22@w32_open_t:

; 270  : 
; 271  :     do
; 272  :     {
; 273  :         dwRetCode = GetTapeParameters

  00410	48 63 44 24 40	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00415	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00419	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_drive_parms
  00420	48 03 c8	 add	 rcx, rax
  00423	48 8b c1	 mov	 rax, rcx
  00426	4c 8b c8	 mov	 r9, rax
  00429	4c 8d 44 24 58	 lea	 r8, QWORD PTR dwSizeofDriveParms$[rsp]
  0042e	ba 01 00 00 00	 mov	 edx, 1
  00433	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hFile$[rsp]
  00438	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTapeParameters
  0043e	89 44 24 44	 mov	 DWORD PTR dwRetCode$[rsp], eax

; 274  :         (
; 275  :             hFile,
; 276  :             GET_TAPE_DRIVE_INFORMATION,
; 277  :             &dwSizeofDriveParms,
; 278  :             &g_drive_parms[ifd]
; 279  :         );
; 280  :     }
; 281  :     while ((NO_ERROR != dwRetCode)              // (if not normal completion,
; 282  :     &&                                          // check for retry conditions)

  00442	83 7c 24 44 00	 cmp	 DWORD PTR dwRetCode$[rsp], 0
  00447	74 1a		 je	 SHORT $LN59@w32_open_t
  00449	33 c0		 xor	 eax, eax
  0044b	85 c0		 test	 eax, eax
  0044d	75 c1		 jne	 SHORT $LN22@w32_open_t
  0044f	81 7c 24 44 56
	04 00 00	 cmp	 DWORD PTR dwRetCode$[rsp], 1110 ; 00000456H
  00457	74 b7		 je	 SHORT $LN73@w32_open_t
  00459	81 7c 24 44 57
	04 00 00	 cmp	 DWORD PTR dwRetCode$[rsp], 1111 ; 00000457H
  00461	74 ad		 je	 SHORT $LN74@w32_open_t
$LN59@w32_open_t:

; 283  :     (0
; 284  :         || ERROR_MEDIA_CHANGED == dwRetCode     // (likely but unimportant; retry)
; 285  :         || ERROR_BUS_RESET     == dwRetCode     // (unlikely but possible;  retry)
; 286  :     ));
; 287  : 
; 288  :     // Did that work?
; 289  : 
; 290  :     if (NO_ERROR != dwRetCode)

  00463	83 7c 24 44 00	 cmp	 DWORD PTR dwRetCode$[rsp], 0
  00468	0f 84 a2 00 00
	00		 je	 $LN60@w32_open_t

; 291  :     {
; 292  :         int save_errno = w32_trans_w32error( GetLastError() );

  0046e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00474	8b c8		 mov	 ecx, eax
  00476	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_trans_w32error
  0047c	89 44 24 6c	 mov	 DWORD PTR save_errno$2[rsp], eax

; 293  :         CloseHandle( hFile );

  00480	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hFile$[rsp]
  00485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN25@w32_open_t:

; 294  :         VERIFY( w32_free_ifd( ifd ) == 0 );

  0048b	8b 4c 24 40	 mov	 ecx, DWORD PTR ifd$[rsp]
  0048f	e8 00 00 00 00	 call	 w32_free_ifd
  00494	85 c0		 test	 eax, eax
  00496	74 5c		 je	 SHORT $LN61@w32_open_t
$LN28@w32_open_t:
  00498	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169354
  0049f	41 b8 26 01 00
	00		 mov	 r8d, 294		; 00000126H
  004a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169355
  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169356
  004b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  004b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004bf	85 c0		 test	 eax, eax
  004c1	74 20		 je	 SHORT $LN62@w32_open_t
  004c3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169358
  004ca	41 b8 26 01 00
	00		 mov	 r8d, 294		; 00000126H
  004d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169359
  004d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169360
  004de	e8 00 00 00 00	 call	 DebuggerTrace
$LN62@w32_open_t:
  004e3	33 c0		 xor	 eax, eax
  004e5	85 c0		 test	 eax, eax
  004e7	75 af		 jne	 SHORT $LN28@w32_open_t
  004e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004ef	85 c0		 test	 eax, eax
  004f1	74 01		 je	 SHORT $LN63@w32_open_t
  004f3	cc		 int	 3
$LN63@w32_open_t:
$LN61@w32_open_t:
  004f4	33 c0		 xor	 eax, eax
  004f6	85 c0		 test	 eax, eax
  004f8	75 91		 jne	 SHORT $LN25@w32_open_t

; 295  :         errno = save_errno;

  004fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00500	8b 4c 24 6c	 mov	 ecx, DWORD PTR save_errno$2[rsp]
  00504	89 08		 mov	 DWORD PTR [rax], ecx

; 296  :         return -1;

  00506	b8 ff ff ff ff	 mov	 eax, -1
  0050b	e9 4a 01 00 00	 jmp	 $LN1@w32_open_t
$LN60@w32_open_t:
$LN31@w32_open_t:

; 297  :     }
; 298  : 
; 299  :     ASSERT( NO_ERROR == dwRetCode );

  00510	83 7c 24 44 00	 cmp	 DWORD PTR dwRetCode$[rsp], 0
  00515	74 5c		 je	 SHORT $LN64@w32_open_t
$LN34@w32_open_t:
  00517	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169363
  0051e	41 b8 2b 01 00
	00		 mov	 r8d, 299		; 0000012bH
  00524	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169364
  0052b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169365
  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00538	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0053e	85 c0		 test	 eax, eax
  00540	74 20		 je	 SHORT $LN65@w32_open_t
  00542	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169367
  00549	41 b8 2b 01 00
	00		 mov	 r8d, 299		; 0000012bH
  0054f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169368
  00556	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169369
  0055d	e8 00 00 00 00	 call	 DebuggerTrace
$LN65@w32_open_t:
  00562	33 c0		 xor	 eax, eax
  00564	85 c0		 test	 eax, eax
  00566	75 af		 jne	 SHORT $LN34@w32_open_t
  00568	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0056e	85 c0		 test	 eax, eax
  00570	74 01		 je	 SHORT $LN66@w32_open_t
  00572	cc		 int	 3
$LN66@w32_open_t:
$LN64@w32_open_t:
  00573	33 c0		 xor	 eax, eax
  00575	85 c0		 test	 eax, eax
  00577	75 97		 jne	 SHORT $LN31@w32_open_t
$LN37@w32_open_t:

; 300  :     ASSERT( sizeof(TAPE_GET_DRIVE_PARAMETERS) == dwSizeofDriveParms );

  00579	8b 44 24 58	 mov	 eax, DWORD PTR dwSizeofDriveParms$[rsp]
  0057d	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  00581	74 5c		 je	 SHORT $LN67@w32_open_t
$LN40@w32_open_t:
  00583	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169372
  0058a	41 b8 2c 01 00
	00		 mov	 r8d, 300		; 0000012cH
  00590	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169373
  00597	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169374
  0059e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  005a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  005aa	85 c0		 test	 eax, eax
  005ac	74 20		 je	 SHORT $LN68@w32_open_t
  005ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169376
  005b5	41 b8 2c 01 00
	00		 mov	 r8d, 300		; 0000012cH
  005bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169377
  005c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169378
  005c9	e8 00 00 00 00	 call	 DebuggerTrace
$LN68@w32_open_t:
  005ce	33 c0		 xor	 eax, eax
  005d0	85 c0		 test	 eax, eax
  005d2	75 af		 jne	 SHORT $LN40@w32_open_t
  005d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  005da	85 c0		 test	 eax, eax
  005dc	74 01		 je	 SHORT $LN69@w32_open_t
  005de	cc		 int	 3
$LN69@w32_open_t:
$LN67@w32_open_t:
  005df	33 c0		 xor	 eax, eax
  005e1	85 c0		 test	 eax, eax
  005e3	75 94		 jne	 SHORT $LN37@w32_open_t

; 301  : 
; 302  :     // Save control info & return their file descriptor...
; 303  : 
; 304  :     g_handles [ ifd ]  = hFile;                     // (WIN32 handle)

  005e5	48 63 44 24 40	 movsxd	 rax, DWORD PTR ifd$[rsp]
  005ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_handles
  005f1	48 8b 54 24 60	 mov	 rdx, QWORD PTR hFile$[rsp]
  005f6	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 305  :     g_fnames  [ ifd ]  = strdup( path );            // (for posterity)

  005fa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00608	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ifd$[rsp]
  0060d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_fnames
  00614	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 306  :     g_fstats  [ ifd ]  = GMT_ONLINE (0xFFFFFFFF);   // (initial status)

  00618	48 63 44 24 40	 movsxd	 rax, DWORD PTR ifd$[rsp]
  0061d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_fstats
  00624	c7 04 81 00 00
	00 01		 mov	 DWORD PTR [rcx+rax*4], 16777216 ; 01000000H

; 307  :     g_BOTmsk  [ ifd ]  = 0xFFFFFFFF;                // (BOT block-id mask)

  0062b	48 63 44 24 40	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00630	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_BOTmsk
  00637	c7 04 81 ff ff
	ff ff		 mov	 DWORD PTR [rcx+rax*4], -1 ; ffffffffH

; 308  :     g_BOTbot  [ ifd ]  = 0x00000000;                // (BOT block-id value)

  0063e	48 63 44 24 40	 movsxd	 rax, DWORD PTR ifd$[rsp]
  00643	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_BOTbot
  0064a	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0

; 309  : 
; 310  :     return W32STAPE_IFD2UFD( ifd );                 // (user fd result)

  00651	8b 44 24 40	 mov	 eax, DWORD PTR ifd$[rsp]
  00655	0d 00 00 00 7f	 or	 eax, 2130706432		; 7f000000H
$LN1@w32_open_t:
$LN70@w32_open_t:

; 311  : }

  0065a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00662	48 33 cc	 xor	 rcx, rsp
  00665	e8 00 00 00 00	 call	 __security_check_cookie
  0066a	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00671	5f		 pop	 rdi
  00672	c3		 ret	 0
w32_open_tape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
