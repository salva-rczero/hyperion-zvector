; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG159052 DB	'2305', 00H
	ORG $+3
$SG159053 DB	'2835', 00H
	ORG $+3
$SG159054 DB	'2305-1', 00H
	ORG $+1
$SG159055 DB	'2835', 00H
	ORG $+3
$SG159056 DB	'2305-2', 00H
	ORG $+1
$SG159057 DB	'2835', 00H
	ORG $+3
$SG159058 DB	'2305-x', 00H
	ORG $+1
$SG159059 DB	'2835', 00H
	ORG $+3
$SG159060 DB	'2311', 00H
	ORG $+3
$SG159061 DB	'2841', 00H
	ORG $+3
$SG159062 DB	'2311-1', 00H
	ORG $+1
$SG159063 DB	'2841', 00H
	ORG $+3
$SG159064 DB	'2311-x', 00H
	ORG $+1
$SG159065 DB	'2841', 00H
	ORG $+3
$SG159066 DB	'2314', 00H
	ORG $+3
$SG159067 DB	'2314', 00H
	ORG $+3
$SG159068 DB	'2314-1', 00H
	ORG $+1
$SG159069 DB	'2314', 00H
	ORG $+3
$SG159070 DB	'2314-x', 00H
	ORG $+1
$SG159071 DB	'2314', 00H
	ORG $+3
$SG159072 DB	'3330', 00H
	ORG $+3
$SG159073 DB	'3830', 00H
	ORG $+3
$SG159074 DB	'3330-1', 00H
	ORG $+1
$SG159075 DB	'3830', 00H
	ORG $+3
$SG159076 DB	'3330-2', 00H
	ORG $+1
$SG159077 DB	'3830', 00H
	ORG $+3
$SG159078 DB	'3330-11', 00H
$SG159079 DB	'3830', 00H
	ORG $+3
$SG159080 DB	'3330-x', 00H
	ORG $+1
$SG159081 DB	'3830', 00H
	ORG $+3
$SG159082 DB	'3340', 00H
	ORG $+3
$SG159083 DB	'3830', 00H
	ORG $+3
$SG159084 DB	'3340-1', 00H
	ORG $+1
$SG159085 DB	'3830', 00H
	ORG $+3
$SG159086 DB	'3340-35', 00H
$SG159087 DB	'3830', 00H
	ORG $+3
$SG159088 DB	'3340-2', 00H
	ORG $+1
$SG159089 DB	'3830', 00H
	ORG $+3
$SG159090 DB	'3340-70', 00H
$SG159091 DB	'3830', 00H
	ORG $+3
$SG159092 DB	'3340-x', 00H
	ORG $+1
$SG159093 DB	'3830', 00H
	ORG $+3
$SG159094 DB	'3350', 00H
	ORG $+3
$SG159095 DB	'3830', 00H
	ORG $+3
$SG159096 DB	'3350-1', 00H
	ORG $+1
$SG159097 DB	'3830', 00H
	ORG $+3
$SG159098 DB	'3350-x', 00H
	ORG $+1
$SG159099 DB	'3830', 00H
	ORG $+3
$SG159100 DB	'3375', 00H
	ORG $+3
$SG159101 DB	'3880', 00H
	ORG $+3
$SG159102 DB	'3375-1', 00H
	ORG $+1
$SG159103 DB	'3880', 00H
	ORG $+3
$SG159104 DB	'3375-x', 00H
	ORG $+1
$SG159105 DB	'3880', 00H
	ORG $+3
$SG159106 DB	'3380', 00H
	ORG $+3
$SG159107 DB	'3880', 00H
	ORG $+3
$SG159108 DB	'3380-1', 00H
	ORG $+1
$SG159109 DB	'3880', 00H
	ORG $+3
$SG159110 DB	'3380-A', 00H
	ORG $+1
$SG159111 DB	'3880', 00H
	ORG $+3
$SG159112 DB	'3380-B', 00H
	ORG $+1
$SG159113 DB	'3880', 00H
	ORG $+3
$SG159114 DB	'3380-D', 00H
	ORG $+1
$SG159115 DB	'3880', 00H
	ORG $+3
$SG159116 DB	'3380-J', 00H
	ORG $+1
$SG159117 DB	'3880', 00H
	ORG $+3
$SG159118 DB	'3380-2', 00H
	ORG $+1
$SG159119 DB	'3880', 00H
	ORG $+3
$SG159120 DB	'3380-E', 00H
	ORG $+1
$SG159121 DB	'3880', 00H
	ORG $+3
$SG159122 DB	'3380-3', 00H
	ORG $+1
$SG159123 DB	'3880', 00H
	ORG $+3
$SG159124 DB	'3380-K', 00H
	ORG $+1
$SG159125 DB	'3880', 00H
	ORG $+3
$SG159126 DB	'EMC3380K+', 00H
	ORG $+2
$SG159127 DB	'3880', 00H
	ORG $+7
$SG159128 DB	'EMC3380K++', 00H
	ORG $+1
$SG159129 DB	'3880', 00H
	ORG $+3
$SG159130 DB	'3380-x', 00H
	ORG $+1
$SG159131 DB	'3880', 00H
	ORG $+3
$SG159132 DB	'3390', 00H
	ORG $+3
$SG159133 DB	'3990', 00H
	ORG $+3
$SG159134 DB	'3390-1', 00H
	ORG $+1
$SG159135 DB	'3990', 00H
	ORG $+3
$SG159136 DB	'3390-2', 00H
	ORG $+1
$SG159137 DB	'3990', 00H
	ORG $+3
$SG159138 DB	'3390-3', 00H
	ORG $+1
$SG159139 DB	'3990', 00H
	ORG $+3
$SG159140 DB	'3390-9', 00H
	ORG $+1
$SG159141 DB	'3990', 00H
	ORG $+7
$SG159142 DB	'3390-27', 00H
$SG159143 DB	'3990', 00H
	ORG $+3
$SG159144 DB	'3390-J', 00H
	ORG $+1
$SG159145 DB	'3990', 00H
	ORG $+3
$SG159146 DB	'3390-54', 00H
$SG159147 DB	'3990', 00H
	ORG $+3
$SG159148 DB	'3390-JJ', 00H
$SG159149 DB	'3990', 00H
	ORG $+3
$SG159150 DB	'3390-x', 00H
	ORG $+1
$SG159151 DB	'3990', 00H
	ORG $+3
$SG159152 DB	'9345', 00H
	ORG $+3
$SG159153 DB	'9343', 00H
	ORG $+3
$SG159154 DB	'9345-1', 00H
	ORG $+1
$SG159155 DB	'9343', 00H
	ORG $+3
$SG159156 DB	'9345-2', 00H
	ORG $+1
$SG159157 DB	'9343', 00H
	ORG $+3
$SG159158 DB	'9345-x', 00H
	ORG $+1
$SG159159 DB	'9343', 00H
	ORG $+3
$SG159161 DB	'2314', 00H
	ORG $+3
$SG159162 DB	'2835', 00H
	ORG $+3
$SG159163 DB	'2841', 00H
	ORG $+3
$SG159164 DB	'3830', 00H
	ORG $+3
$SG159165 DB	'3880', 00H
	ORG $+3
$SG159166 DB	'3990', 00H
	ORG $+3
$SG159167 DB	'3990-3', 00H
	ORG $+1
$SG159168 DB	'3990-6', 00H
	ORG $+1
$SG159169 DB	'9343', 00H
	ORG $+3
$SG159171 DB	'3310', 00H
	ORG $+3
$SG159172 DB	'3310-1', 00H
	ORG $+1
$SG159173 DB	'3310-x', 00H
	ORG $+1
$SG159174 DB	'3370', 00H
	ORG $+3
$SG159175 DB	'3370-1', 00H
	ORG $+1
$SG159176 DB	'3370-A1', 00H
$SG159177 DB	'3370-B1', 00H
$SG159178 DB	'3370-2', 00H
	ORG $+1
$SG159179 DB	'3370-A2', 00H
$SG159180 DB	'3370-B2', 00H
$SG159181 DB	'3370-x', 00H
	ORG $+1
$SG159182 DB	'9332', 00H
	ORG $+3
$SG159183 DB	'9332-400', 00H
	ORG $+7
$SG159184 DB	'9332-600', 00H
	ORG $+3
$SG159185 DB	'9332-x', 00H
	ORG $+1
$SG159186 DB	'9335', 00H
	ORG $+3
$SG159187 DB	'9335-x', 00H
	ORG $+1
$SG159188 DB	'9313', 00H
	ORG $+3
$SG159189 DB	'9313-x', 00H
	ORG $+1
$SG159190 DB	'9336', 00H
	ORG $+7
$SG159191 DB	'9336-10', 00H
$SG159192 DB	'9336-20', 00H
$SG159193 DB	'9336-25', 00H
$SG159194 DB	'9336-x', 00H
	ORG $+1
$SG159195 DB	'0671-08', 00H
$SG159196 DB	'0671', 00H
	ORG $+3
$SG159197 DB	'0671-04', 00H
$SG159198 DB	'0671-x', 00H
	ORG $+1
$SG159200 DB	'0671', 00H
	ORG $+3
$SG159201 DB	'3310', 00H
	ORG $+3
$SG159202 DB	'3370', 00H
	ORG $+3
$SG159203 DB	'9332', 00H
	ORG $+3
$SG159204 DB	'9335', 00H
	ORG $+3
$SG159205 DB	'9336', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	dasd_lookup
PUBLIC	dasd_build_ckd_devid
PUBLIC	dasd_build_ckd_devchar
PUBLIC	dasd_build_ckd_config_data
PUBLIC	dasd_build_ckd_subsys_status
PUBLIC	dasd_build_fba_devid
PUBLIC	dasd_build_fba_devchar
PUBLIC	store_hw_noswap
PUBLIC	store_fw_noswap
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	strcmp:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$dasd_lookup DD imagerel $LN37
	DD	imagerel $LN37+798
	DD	imagerel $unwind$dasd_lookup
$pdata$dasd_build_ckd_devid DD imagerel $LN21
	DD	imagerel $LN21+630
	DD	imagerel $unwind$dasd_build_ckd_devid
$pdata$dasd_build_ckd_devchar DD imagerel $LN16
	DD	imagerel $LN16+1422
	DD	imagerel $unwind$dasd_build_ckd_devchar
$pdata$dasd_build_ckd_config_data DD imagerel $LN26
	DD	imagerel $LN26+1516
	DD	imagerel $unwind$dasd_build_ckd_config_data
$pdata$dasd_build_ckd_subsys_status DD imagerel $LN6
	DD	imagerel $LN6+313
	DD	imagerel $unwind$dasd_build_ckd_subsys_status
$pdata$dasd_build_fba_devid DD imagerel $LN3
	DD	imagerel $LN3+186
	DD	imagerel $unwind$dasd_build_fba_devid
$pdata$dasd_build_fba_devchar DD imagerel $LN3
	DD	imagerel $LN3+500
	DD	imagerel $unwind$dasd_build_fba_devchar
pdata	ENDS
_DATA	SEGMENT
	ORG $+11
ckdtab	DQ	FLAT:$SG159052
	DW	02305H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	030H
	DW	00H
	DW	08H
	DW	038e8H
	DW	03738H
	DW	01b0H
	DW	038e8H
	DW	05aH
	DW	00H
	DW	0ffffH
	DW	0caH
	DW	01b0H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159053
	DQ	FLAT:$SG159054
	DW	02305H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	030H
	DW	00H
	DW	08H
	DW	038e8H
	DW	03738H
	DW	01b0H
	DW	038e8H
	DW	05aH
	DW	00H
	DW	0ffffH
	DW	0caH
	DW	01b0H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159055
	DQ	FLAT:$SG159056
	DW	02305H
	DB	02H
	DB	020H
	DB	00H
	ORG $+1
	DW	060H
	DW	00H
	DW	08H
	DW	03a0aH
	DW	03944H
	DW	0c6H
	DW	03a0aH
	DW	05aH
	DW	00H
	DW	0ffffH
	DW	05bH
	DW	0c6H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159057
	DQ	FLAT:$SG159058
	DW	02305H
	DB	02H
	DB	020H
	DB	00H
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	08H
	DW	03a0aH
	DW	03944H
	DW	0c6H
	DW	03a0aH
	DW	05aH
	DW	00H
	DW	0ffffH
	DW	05bH
	DW	0c6H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159059
	DQ	FLAT:$SG159060
	DW	02311H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	0c8H
	DW	03H
	DW	0aH
	DW	00H
	DW	0e29H
	DW	00H
	DW	0e29H
	DW	00H
	DW	00H
	DW	0fffeH
	DW	014H
	DW	03dH
	DW	0219H
	DW	0200H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159061
	DQ	FLAT:$SG159062
	DW	02311H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	0c8H
	DW	03H
	DW	0aH
	DW	00H
	DW	0e29H
	DW	00H
	DW	0e29H
	DW	00H
	DW	00H
	DW	0fffeH
	DW	014H
	DW	03dH
	DW	0219H
	DW	0200H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159063
	DQ	FLAT:$SG159064
	DW	02311H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	0aH
	DW	00H
	DW	0e29H
	DW	00H
	DW	0e29H
	DW	00H
	DW	00H
	DW	0fffeH
	DW	014H
	DW	03dH
	DW	0219H
	DW	0200H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159065
	DQ	FLAT:$SG159066
	DW	02314H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	0c8H
	DW	03H
	DW	014H
	DW	00H
	DW	01c7eH
	DW	00H
	DW	01c7eH
	DW	00H
	DW	00H
	DW	0fffeH
	DW	02dH
	DW	065H
	DW	0859H
	DW	0800H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159067
	DQ	FLAT:$SG159068
	DW	02314H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	0c8H
	DW	03H
	DW	014H
	DW	00H
	DW	01c7eH
	DW	00H
	DW	01c7eH
	DW	00H
	DW	00H
	DW	0fffeH
	DW	02dH
	DW	065H
	DW	0859H
	DW	0800H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159069
	DQ	FLAT:$SG159070
	DW	02314H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	014H
	DW	00H
	DW	01c7eH
	DW	00H
	DW	01c7eH
	DW	00H
	DW	00H
	DW	0fffeH
	DW	02dH
	DW	065H
	DW	0859H
	DW	0800H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159071
	DQ	FLAT:$SG159072
	DW	03330H
	DB	01H
	DB	020H
	DB	00H
	ORG $+1
	DW	0194H
	DW	07H
	DW	013H
	DW	0336dH
	DW	032e6H
	DW	087H
	DW	0336dH
	DW	080H
	DW	00H
	DW	0ffffH
	DW	038H
	DW	087H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159073
	DQ	FLAT:$SG159074
	DW	03330H
	DB	01H
	DB	020H
	DB	00H
	ORG $+1
	DW	0194H
	DW	07H
	DW	013H
	DW	0336dH
	DW	032e6H
	DW	087H
	DW	0336dH
	DW	080H
	DW	00H
	DW	0ffffH
	DW	038H
	DW	087H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159075
	DQ	FLAT:$SG159076
	DW	03330H
	DB	011H
	DB	020H
	DB	00H
	ORG $+1
	DW	0328H
	DW	07H
	DW	013H
	DW	0336dH
	DW	032e6H
	DW	087H
	DW	0336dH
	DW	080H
	DW	00H
	DW	0ffffH
	DW	038H
	DW	087H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159077
	DQ	FLAT:$SG159078
	DW	03330H
	DB	011H
	DB	020H
	DB	00H
	ORG $+1
	DW	0328H
	DW	07H
	DW	013H
	DW	0336dH
	DW	032e6H
	DW	087H
	DW	0336dH
	DW	080H
	DW	00H
	DW	0ffffH
	DW	038H
	DW	087H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159079
	DQ	FLAT:$SG159080
	DW	03330H
	DB	011H
	DB	020H
	DB	00H
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	013H
	DW	0336dH
	DW	032e6H
	DW	087H
	DW	0336dH
	DW	080H
	DW	00H
	DW	0ffffH
	DW	038H
	DW	087H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159081
	DQ	FLAT:$SG159082
	DW	03340H
	DB	01H
	DB	020H
	DB	00H
	ORG $+1
	DW	015cH
	DW	01H
	DW	0cH
	DW	02157H
	DW	020b0H
	DW	0a7H
	DW	02157H
	DW	040H
	DW	00H
	DW	0ffffH
	DW	04bH
	DW	0a7H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159083
	DQ	FLAT:$SG159084
	DW	03340H
	DB	01H
	DB	020H
	DB	00H
	ORG $+1
	DW	015cH
	DW	01H
	DW	0cH
	DW	02157H
	DW	020b0H
	DW	0a7H
	DW	02157H
	DW	040H
	DW	00H
	DW	0ffffH
	DW	04bH
	DW	0a7H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159085
	DQ	FLAT:$SG159086
	DW	03340H
	DB	01H
	DB	020H
	DB	00H
	ORG $+1
	DW	015cH
	DW	01H
	DW	0cH
	DW	02157H
	DW	020b0H
	DW	0a7H
	DW	02157H
	DW	040H
	DW	00H
	DW	0ffffH
	DW	04bH
	DW	0a7H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159087
	DQ	FLAT:$SG159088
	DW	03340H
	DB	02H
	DB	020H
	DB	00H
	ORG $+1
	DW	02b8H
	DW	02H
	DW	0cH
	DW	02157H
	DW	020b0H
	DW	0a7H
	DW	02157H
	DW	040H
	DW	00H
	DW	0ffffH
	DW	04bH
	DW	0a7H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159089
	DQ	FLAT:$SG159090
	DW	03340H
	DB	02H
	DB	020H
	DB	00H
	ORG $+1
	DW	02b8H
	DW	02H
	DW	0cH
	DW	02157H
	DW	020b0H
	DW	0a7H
	DW	02157H
	DW	040H
	DW	00H
	DW	0ffffH
	DW	04bH
	DW	0a7H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159091
	DQ	FLAT:$SG159092
	DW	03340H
	DB	02H
	DB	020H
	DB	00H
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	0cH
	DW	02157H
	DW	020b0H
	DW	0a7H
	DW	02157H
	DW	040H
	DW	00H
	DW	0ffffH
	DW	04bH
	DW	0a7H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159093
	DQ	FLAT:$SG159094
	DW	03350H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	022bH
	DW	05H
	DW	01eH
	DW	04b36H
	DW	04a7dH
	DW	0b9H
	DW	04b36H
	DW	080H
	DW	00H
	DW	0ffffH
	DW	052H
	DW	0b9H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159095
	DQ	FLAT:$SG159096
	DW	03350H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	022bH
	DW	05H
	DW	01eH
	DW	04b36H
	DW	04a7dH
	DW	0b9H
	DW	04b36H
	DW	080H
	DW	00H
	DW	0ffffH
	DW	052H
	DW	0b9H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159097
	DQ	FLAT:$SG159098
	DW	03350H
	DB	00H
	DB	020H
	DB	00H
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	01eH
	DW	04b36H
	DW	04a7dH
	DW	0b9H
	DW	04b36H
	DW	080H
	DW	00H
	DW	0ffffH
	DW	052H
	DW	0b9H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159099
	DQ	FLAT:$SG159100
	DW	03375H
	DB	02H
	DB	020H
	DB	0eH
	ORG $+1
	DW	03bfH
	DW	03H
	DW	0cH
	DW	08ca0H
	DW	08b20H
	DW	0340H
	DW	08ca0H
	DW	0c4H
	DW	05007H
	DW	01H
	DW	020H
	DW	0180H
	DW	0a0H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159101
	DQ	FLAT:$SG159102
	DW	03375H
	DB	02H
	DB	020H
	DB	0eH
	ORG $+1
	DW	03bfH
	DW	03H
	DW	0cH
	DW	08ca0H
	DW	08b20H
	DW	0340H
	DW	08ca0H
	DW	0c4H
	DW	05007H
	DW	01H
	DW	020H
	DW	0180H
	DW	0a0H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159103
	DQ	FLAT:$SG159104
	DW	03375H
	DB	02H
	DB	020H
	DB	0eH
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	0cH
	DW	08ca0H
	DW	08b20H
	DW	0340H
	DW	08ca0H
	DW	0c4H
	DW	05007H
	DW	01H
	DW	020H
	DW	0180H
	DW	0a0H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159105
	DQ	FLAT:$SG159106
	DW	03380H
	DB	02H
	DB	020H
	DB	0eH
	ORG $+1
	DW	0375H
	DW	01H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159107
	DQ	FLAT:$SG159108
	DW	03380H
	DB	02H
	DB	020H
	DB	0eH
	ORG $+1
	DW	0375H
	DW	01H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159109
	DQ	FLAT:$SG159110
	DW	03380H
	DB	02H
	DB	020H
	DB	0eH
	ORG $+1
	DW	0375H
	DW	01H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159111
	DQ	FLAT:$SG159112
	DW	03380H
	DB	02H
	DB	020H
	DB	0eH
	ORG $+1
	DW	0375H
	DW	01H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159113
	DQ	FLAT:$SG159114
	DW	03380H
	DB	06H
	DB	020H
	DB	0eH
	ORG $+1
	DW	0375H
	DW	01H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159115
	DQ	FLAT:$SG159116
	DW	03380H
	DB	016H
	DB	020H
	DB	0eH
	ORG $+1
	DW	0375H
	DW	01H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159117
	DQ	FLAT:$SG159118
	DW	03380H
	DB	0aH
	DB	020H
	DB	0eH
	ORG $+1
	DW	06eaH
	DW	02H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159119
	DQ	FLAT:$SG159120
	DW	03380H
	DB	0aH
	DB	020H
	DB	0eH
	ORG $+1
	DW	06eaH
	DW	02H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159121
	DQ	FLAT:$SG159122
	DW	03380H
	DB	01eH
	DB	020H
	DB	0eH
	ORG $+1
	DW	0a5fH
	DW	03H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159123
	DQ	FLAT:$SG159124
	DW	03380H
	DB	01eH
	DB	020H
	DB	0eH
	ORG $+1
	DW	0a5fH
	DW	03H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159125
	DQ	FLAT:$SG159126
	DW	03380H
	DB	01eH
	DB	020H
	DB	0eH
	ORG $+1
	DW	0d0bH
	DW	03H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159127
	DQ	FLAT:$SG159128
	DW	03380H
	DB	01eH
	DB	020H
	DB	0eH
	ORG $+1
	DW	0f99H
	DW	03H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159129
	DQ	FLAT:$SG159130
	DW	03380H
	DB	01eH
	DB	020H
	DB	0eH
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	0fH
	DW	0bb74H
	DW	0b974H
	DW	0440H
	DW	0bb60H
	DW	0deH
	DW	05007H
	DW	01H
	DW	020H
	DW	01ecH
	DW	0ecH
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
	DQ	FLAT:$SG159131
	DQ	FLAT:$SG159132
	DW	03390H
	DB	02H
	DB	020H
	DB	026H
	ORG $+1
	DW	0459H
	DW	01H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159133
	DQ	FLAT:$SG159134
	DW	03390H
	DB	02H
	DB	020H
	DB	026H
	ORG $+1
	DW	0459H
	DW	01H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159135
	DQ	FLAT:$SG159136
	DW	03390H
	DB	06H
	DB	020H
	DB	027H
	ORG $+1
	DW	08b2H
	DW	01H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159137
	DQ	FLAT:$SG159138
	DW	03390H
	DB	0aH
	DB	020H
	DB	024H
	ORG $+1
	DW	0d0bH
	DW	01H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159139
	DQ	FLAT:$SG159140
	DW	03390H
	DB	0cH
	DB	020H
	DB	032H
	ORG $+1
	DW	02721H
	DW	03H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159141
	DQ	FLAT:$SG159142
	DW	03390H
	DB	0cH
	DB	020H
	DB	032H
	ORG $+1
	DW	07ff8H
	DW	03H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159143
	DQ	FLAT:$SG159144
	DW	03390H
	DB	0cH
	DB	020H
	DB	032H
	ORG $+1
	DW	07ff8H
	DW	03H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159145
	DQ	FLAT:$SG159146
	DW	03390H
	DB	0cH
	DB	020H
	DB	032H
	ORG $+1
	DW	0fff0H
	DW	03H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159147
	DQ	FLAT:$SG159148
	DW	03390H
	DB	0cH
	DB	020H
	DB	032H
	ORG $+1
	DW	0fff0H
	DW	03H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159149
	DQ	FLAT:$SG159150
	DW	03390H
	DB	0cH
	DB	020H
	DB	032H
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	0fH
	DW	0dfeeH
	DW	0dd58H
	DW	0594H
	DW	0e5a2H
	DW	0e0H
	DW	07708H
	DW	02H
	DW	022H
	DW	013H
	DW	09H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159151
	DQ	FLAT:$SG159152
	DW	09345H
	DB	04H
	DB	020H
	DB	04H
	ORG $+1
	DW	05a0H
	DW	00H
	DW	0fH
	DW	0bc2eH
	DW	0b578H
	DW	04a0H
	DW	0bc98H
	DW	0d5H
	DW	08b07H
	DW	02H
	DW	022H
	DW	012H
	DW	07H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159153
	DQ	FLAT:$SG159154
	DW	09345H
	DB	04H
	DB	020H
	DB	04H
	ORG $+1
	DW	05a0H
	DW	00H
	DW	0fH
	DW	0bc2eH
	DW	0b578H
	DW	04a0H
	DW	0bc98H
	DW	0d5H
	DW	08b07H
	DW	02H
	DW	022H
	DW	012H
	DW	07H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159155
	DQ	FLAT:$SG159156
	DW	09345H
	DB	04H
	DB	020H
	DB	04H
	ORG $+1
	DW	086cH
	DW	00H
	DW	0fH
	DW	0bc2eH
	DW	0b578H
	DW	04a0H
	DW	0bc98H
	DW	0d5H
	DW	08b07H
	DW	02H
	DW	022H
	DW	012H
	DW	07H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159157
	DQ	FLAT:$SG159158
	DW	09345H
	DB	04H
	DB	020H
	DB	04H
	ORG $+1
	DW	0ffffH
	DW	00H
	DW	0fH
	DW	0bc2eH
	DW	0b578H
	DW	04a0H
	DW	0bc98H
	DW	0d5H
	DW	08b07H
	DW	02H
	DW	022H
	DW	012H
	DW	07H
	DW	06H
	DW	074H
	DW	06H
	ORG $+2
	DQ	FLAT:$SG159159
ckdcutab DQ	FLAT:$SG159161
	DW	02314H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	06H
	ORG $+3
	DQ	FLAT:$SG159162
	DW	02835H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	06H
	ORG $+3
	DQ	FLAT:$SG159163
	DW	02841H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	06H
	ORG $+3
	DQ	FLAT:$SG159164
	DW	03830H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	ORG $+2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	018H
	ORG $+3
	DQ	FLAT:$SG159165
	DW	03880H
	DB	05H
	DB	09H
	DB	00H
	DB	00H
	ORG $+2
	DD	080000000H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	018H
	ORG $+3
	DQ	FLAT:$SG159166
	DW	03990H
	DB	0c2H
	DB	010H
	DB	00H
	DB	00H
	ORG $+2
	DD	0d0000000H
	DD	040fa0100H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	020H
	ORG $+3
	DQ	FLAT:$SG159167
	DW	03990H
	DB	0ecH
	DB	06H
	DB	00H
	DB	00H
	ORG $+2
	DD	0d0001010H
	DD	040fa0100H
	DD	041270004H
	DD	0423e0040H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	020H
	ORG $+3
	DQ	FLAT:$SG159168
	DW	03990H
	DB	0e9H
	DB	015H
	DB	048H
	DB	015H
	ORG $+2
	DD	050001010H
	DD	040fa0100H
	DD	041270004H
	DD	0423e0060H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	020H
	ORG $+3
	DQ	FLAT:$SG159169
	DW	09343H
	DB	0e0H
	DB	011H
	DB	00H
	DB	00H
	ORG $+2
	DD	080000000H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	020H
	ORG $+3
	ORG $+8
fbatab	DQ	FLAT:$SG159171
	DW	03310H
	DB	021H
	DB	01H
	DB	01H
	ORG $+3
	DD	020H
	DD	0160H
	DD	0200H
	DD	01eae0H
	DW	04331H
	ORG $+6
	DQ	FLAT:$SG159172
	DW	03310H
	DB	021H
	DB	01H
	DB	01H
	ORG $+3
	DD	020H
	DD	0160H
	DD	0200H
	DD	01eae0H
	DW	04331H
	ORG $+6
	DQ	FLAT:$SG159173
	DW	03310H
	DB	021H
	DB	01H
	DB	01H
	ORG $+3
	DD	020H
	DD	0160H
	DD	0200H
	DD	00H
	DW	04331H
	ORG $+6
	DQ	FLAT:$SG159174
	DW	03370H
	DB	021H
	DB	02H
	DB	00H
	ORG $+3
	DD	03eH
	DD	02e8H
	DD	0200H
	DD	0883b0H
	DW	03880H
	ORG $+6
	DQ	FLAT:$SG159175
	DW	03370H
	DB	021H
	DB	02H
	DB	00H
	ORG $+3
	DD	03eH
	DD	02e8H
	DD	0200H
	DD	0883b0H
	DW	03880H
	ORG $+6
	DQ	FLAT:$SG159176
	DW	03370H
	DB	021H
	DB	02H
	DB	00H
	ORG $+3
	DD	03eH
	DD	02e8H
	DD	0200H
	DD	0883b0H
	DW	03880H
	ORG $+6
	DQ	FLAT:$SG159177
	DW	03370H
	DB	021H
	DB	02H
	DB	00H
	ORG $+3
	DD	03eH
	DD	02e8H
	DD	0200H
	DD	0883b0H
	DW	03880H
	ORG $+6
	DQ	FLAT:$SG159178
	DW	03370H
	DB	021H
	DB	05H
	DB	04H
	ORG $+3
	DD	03eH
	DD	02e8H
	DD	0200H
	DD	0ae030H
	DW	03880H
	ORG $+6
	DQ	FLAT:$SG159179
	DW	03370H
	DB	021H
	DB	05H
	DB	04H
	ORG $+3
	DD	03eH
	DD	02e8H
	DD	0200H
	DD	0ae030H
	DW	03880H
	ORG $+6
	DQ	FLAT:$SG159180
	DW	03370H
	DB	021H
	DB	05H
	DB	04H
	ORG $+3
	DD	03eH
	DD	02e8H
	DD	0200H
	DD	0ae030H
	DW	03880H
	ORG $+6
	DQ	FLAT:$SG159181
	DW	03370H
	DB	021H
	DB	05H
	DB	04H
	ORG $+3
	DD	03eH
	DD	02e8H
	DD	0200H
	DD	00H
	DW	03880H
	ORG $+6
	DQ	FLAT:$SG159182
	DW	09332H
	DB	021H
	DB	07H
	DB	00H
	ORG $+3
	DD	049H
	DD	0124H
	DD	0200H
	DD	057e64H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159183
	DW	09332H
	DB	021H
	DB	07H
	DB	00H
	ORG $+3
	DD	049H
	DD	0124H
	DD	0200H
	DD	057e64H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159184
	DW	09332H
	DB	021H
	DB	07H
	DB	01H
	ORG $+3
	DD	049H
	DD	0124H
	DD	0200H
	DD	087730H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159185
	DW	09332H
	DB	021H
	DB	07H
	DB	01H
	ORG $+3
	DD	049H
	DD	0124H
	DD	0200H
	DD	00H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159186
	DW	09335H
	DB	021H
	DB	06H
	DB	01H
	ORG $+3
	DD	047H
	DD	01aaH
	DD	0200H
	DD	0c476aH
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159187
	DW	09335H
	DB	021H
	DB	06H
	DB	01H
	ORG $+3
	DD	047H
	DD	01aaH
	DD	0200H
	DD	00H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159188
	DW	09313H
	DB	021H
	DB	08H
	DB	00H
	ORG $+3
	DD	060H
	DD	01e0H
	DD	0200H
	DD	03c1e0H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159189
	DW	09313H
	DB	021H
	DB	08H
	DB	00H
	ORG $+3
	DD	060H
	DD	01e0H
	DD	0200H
	DD	00H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159190
	DW	09336H
	DB	021H
	DB	011H
	DB	00H
	ORG $+3
	DD	03fH
	DD	013bH
	DD	0200H
	DD	0e0a33H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159191
	DW	09336H
	DB	021H
	DB	011H
	DB	00H
	ORG $+3
	DD	03fH
	DD	013bH
	DD	0200H
	DD	0e0a33H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159192
	DW	09336H
	DB	021H
	DB	011H
	DB	010H
	ORG $+3
	DD	06fH
	DD	0309H
	DD	0200H
	DD	01986b1H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159193
	DW	09336H
	DB	021H
	DB	011H
	DB	010H
	ORG $+3
	DD	06fH
	DD	0309H
	DD	0200H
	DD	01986b1H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159194
	DW	09336H
	DB	021H
	DB	011H
	DB	010H
	ORG $+3
	DD	06fH
	DD	0309H
	DD	0200H
	DD	00H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159195
	DW	0671H
	DB	021H
	DB	012H
	DB	08H
	ORG $+3
	DD	03fH
	DD	01f8H
	DD	0200H
	DD	07d430H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159196
	DW	0671H
	DB	021H
	DB	012H
	DB	00H
	ORG $+3
	DD	03fH
	DD	01f8H
	DD	0200H
	DD	08c460H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159197
	DW	0671H
	DB	021H
	DB	012H
	DB	04H
	ORG $+3
	DD	03fH
	DD	01f8H
	DD	0200H
	DD	098748H
	DW	06310H
	ORG $+6
	DQ	FLAT:$SG159198
	DW	0671H
	DB	021H
	DB	012H
	DB	04H
	ORG $+3
	DD	03fH
	DD	01f8H
	DD	0200H
	DD	00H
	DW	06310H
	ORG $+6
blktab	DQ	FLAT:$SG159200
	DW	0671H
	ORG $+2
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	08H
	DQ	FLAT:$SG159201
	DW	03310H
	ORG $+2
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	08H
	DQ	FLAT:$SG159202
	DW	03370H
	ORG $+2
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	08H
	DQ	FLAT:$SG159203
	DW	09332H
	ORG $+2
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	08H
	DQ	FLAT:$SG159204
	DW	09335H
	ORG $+2
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	08H
	DQ	FLAT:$SG159205
	DW	09336H
	ORG $+2
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	08H
$SG159364 DB	'  %4.4X0%2.2XHRCZZ', 00H
	ORG $+5
$SG159365 DB	'  %4.4X0%2.2XHRCZZ000000000003', 00H
	ORG $+1
$SG159366 DB	'  %4.4X0%2.2XHRCZZ000000000002', 00H
	ORG $+1
$SG159367 DB	'  %4.4X   HRCZZ000000000001', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dasd_build_ckd_subsys_status
	DD	01fH
	DD	0125H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dasd_build_ckd_config_data
	DD	022H
	DD	05d2H
voltbl	ENDS
xdata	SEGMENT
$unwind$dasd_lookup DD 011701H
	DD	06217H
$unwind$dasd_build_ckd_devid DD 021401H
	DD	070105214H
$unwind$dasd_build_ckd_devchar DD 021901H
	DD	070155219H
$unwind$dasd_build_ckd_config_data DD 042a19H
	DD	02f0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$dasd_build_ckd_subsys_status DD 032419H
	DD	07011c215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$dasd_build_fba_devid DD 020f01H
	DD	0700b320fH
$unwind$dasd_build_fba_devchar DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdtab.c
_TEXT	SEGMENT
fba$ = 48
devchar$ = 56
blks$ = 64
dasd_build_fba_devchar PROC

; 645  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 646  :     memset( devchar, 0, 64 );

  00014	48 8b 7c 24 38	 mov	 rdi, QWORD PTR devchar$[rsp]
  00019	33 c0		 xor	 eax, eax
  0001b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00020	f3 aa		 rep stosb

; 647  : 
; 648  :     devchar[0]  = 0x30;                         // operation modes

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 00	 imul	 rax, rax, 0
  0002b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR devchar$[rsp]
  00030	c6 04 01 30	 mov	 BYTE PTR [rcx+rax], 48	; 00000030H

; 649  :     devchar[1]  = 0x08;                         // features

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	48 6b c0 01	 imul	 rax, rax, 1
  0003d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR devchar$[rsp]
  00042	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8

; 650  :     devchar[2]  = fba->devclass;                // device class

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	48 6b c0 02	 imul	 rax, rax, 2
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR devchar$[rsp]
  00054	48 8b 54 24 30	 mov	 rdx, QWORD PTR fba$[rsp]
  00059	0f b6 52 0a	 movzx	 edx, BYTE PTR [rdx+10]
  0005d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 651  :     devchar[3]  = fba->type;                    // unit type

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	48 6b c0 03	 imul	 rax, rax, 3
  00069	48 8b 4c 24 38	 mov	 rcx, QWORD PTR devchar$[rsp]
  0006e	48 8b 54 24 30	 mov	 rdx, QWORD PTR fba$[rsp]
  00073	0f b6 52 0b	 movzx	 edx, BYTE PTR [rdx+11]
  00077	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 652  : 
; 653  :     store_hw( &devchar[ 4], (U16) fba->size );  // block size

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR fba$[rsp]
  0007f	0f b7 48 18	 movzx	 ecx, WORD PTR [rax+24]
  00083	e8 00 00 00 00	 call	 _byteswap_ushort
  00088	b9 01 00 00 00	 mov	 ecx, 1
  0008d	48 6b c9 04	 imul	 rcx, rcx, 4
  00091	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  00096	48 03 d1	 add	 rdx, rcx
  00099	48 8b ca	 mov	 rcx, rdx
  0009c	0f b7 d0	 movzx	 edx, ax
  0009f	e8 00 00 00 00	 call	 store_hw_noswap

; 654  : 
; 655  :     store_fw( &devchar[ 6],       fba->bpg );   // blks per cyclical group

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR fba$[rsp]
  000a9	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000ac	e8 00 00 00 00	 call	 _byteswap_ulong
  000b1	b9 01 00 00 00	 mov	 ecx, 1
  000b6	48 6b c9 06	 imul	 rcx, rcx, 6
  000ba	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  000bf	48 03 d1	 add	 rdx, rcx
  000c2	48 8b ca	 mov	 rcx, rdx
  000c5	8b d0		 mov	 edx, eax
  000c7	e8 00 00 00 00	 call	 store_fw_noswap

; 656  :     store_fw( &devchar[10],       fba->bpp );   // blks per access position

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR fba$[rsp]
  000d1	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  000d4	e8 00 00 00 00	 call	 _byteswap_ulong
  000d9	b9 01 00 00 00	 mov	 ecx, 1
  000de	48 6b c9 0a	 imul	 rcx, rcx, 10
  000e2	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  000e7	48 03 d1	 add	 rdx, rcx
  000ea	48 8b ca	 mov	 rcx, rdx
  000ed	8b d0		 mov	 edx, eax
  000ef	e8 00 00 00 00	 call	 store_fw_noswap

; 657  :     store_fw( &devchar[14],         blks );     // blks under movable heads

  000f4	8b 4c 24 40	 mov	 ecx, DWORD PTR blks$[rsp]
  000f8	e8 00 00 00 00	 call	 _byteswap_ulong
  000fd	b9 01 00 00 00	 mov	 ecx, 1
  00102	48 6b c9 0e	 imul	 rcx, rcx, 14
  00106	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  0010b	48 03 d1	 add	 rdx, rcx
  0010e	48 8b ca	 mov	 rcx, rdx
  00111	8b d0		 mov	 edx, eax
  00113	e8 00 00 00 00	 call	 store_fw_noswap

; 658  : 
; 659  :     store_fw( &devchar[18],          0 );       // blks under fixed heads

  00118	33 c9		 xor	 ecx, ecx
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong
  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	48 6b c9 12	 imul	 rcx, rcx, 18
  00128	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  0012d	48 03 d1	 add	 rdx, rcx
  00130	48 8b ca	 mov	 rcx, rdx
  00133	8b d0		 mov	 edx, eax
  00135	e8 00 00 00 00	 call	 store_fw_noswap

; 660  :     store_hw( &devchar[22],          0 );       // blks in alternate area

  0013a	33 c9		 xor	 ecx, ecx
  0013c	e8 00 00 00 00	 call	 _byteswap_ushort
  00141	b9 01 00 00 00	 mov	 ecx, 1
  00146	48 6b c9 16	 imul	 rcx, rcx, 22
  0014a	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  0014f	48 03 d1	 add	 rdx, rcx
  00152	48 8b ca	 mov	 rcx, rdx
  00155	0f b7 d0	 movzx	 edx, ax
  00158	e8 00 00 00 00	 call	 store_hw_noswap

; 661  :     store_hw( &devchar[24],          0 );       // blks in CE+SA areas

  0015d	33 c9		 xor	 ecx, ecx
  0015f	e8 00 00 00 00	 call	 _byteswap_ushort
  00164	b9 01 00 00 00	 mov	 ecx, 1
  00169	48 6b c9 18	 imul	 rcx, rcx, 24
  0016d	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  00172	48 03 d1	 add	 rdx, rcx
  00175	48 8b ca	 mov	 rcx, rdx
  00178	0f b7 d0	 movzx	 edx, ax
  0017b	e8 00 00 00 00	 call	 store_hw_noswap

; 662  :     store_hw( &devchar[26],          0 );       // cyclic period in ms

  00180	33 c9		 xor	 ecx, ecx
  00182	e8 00 00 00 00	 call	 _byteswap_ushort
  00187	b9 01 00 00 00	 mov	 ecx, 1
  0018c	48 6b c9 1a	 imul	 rcx, rcx, 26
  00190	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  00195	48 03 d1	 add	 rdx, rcx
  00198	48 8b ca	 mov	 rcx, rdx
  0019b	0f b7 d0	 movzx	 edx, ax
  0019e	e8 00 00 00 00	 call	 store_hw_noswap

; 663  :     store_hw( &devchar[28],          0 );       // min time to change access position in ms

  001a3	33 c9		 xor	 ecx, ecx
  001a5	e8 00 00 00 00	 call	 _byteswap_ushort
  001aa	b9 01 00 00 00	 mov	 ecx, 1
  001af	48 6b c9 1c	 imul	 rcx, rcx, 28
  001b3	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  001b8	48 03 d1	 add	 rdx, rcx
  001bb	48 8b ca	 mov	 rcx, rdx
  001be	0f b7 d0	 movzx	 edx, ax
  001c1	e8 00 00 00 00	 call	 store_hw_noswap

; 664  :     store_hw( &devchar[30],          0 );       // max time to change access position in ms

  001c6	33 c9		 xor	 ecx, ecx
  001c8	e8 00 00 00 00	 call	 _byteswap_ushort
  001cd	b9 01 00 00 00	 mov	 ecx, 1
  001d2	48 6b c9 1e	 imul	 rcx, rcx, 30
  001d6	48 8b 54 24 38	 mov	 rdx, QWORD PTR devchar$[rsp]
  001db	48 03 d1	 add	 rdx, rcx
  001de	48 8b ca	 mov	 rcx, rdx
  001e1	0f b7 d0	 movzx	 edx, ax
  001e4	e8 00 00 00 00	 call	 store_hw_noswap

; 665  : 
; 666  :     return 32;

  001e9	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 667  : }

  001ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f2	5f		 pop	 rdi
  001f3	c3		 ret	 0
dasd_build_fba_devchar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdtab.c
_TEXT	SEGMENT
fba$ = 48
devid$ = 56
dasd_build_fba_devid PROC

; 629  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 630  :     memset( devid, 0, 256 );

  0000f	48 8b 7c 24 38	 mov	 rdi, QWORD PTR devid$[rsp]
  00014	33 c0		 xor	 eax, eax
  00016	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0001b	f3 aa		 rep stosb

; 631  : 
; 632  :     devid[0] = 0xff;

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 00	 imul	 rax, rax, 0
  00026	48 8b 4c 24 38	 mov	 rcx, QWORD PTR devid$[rsp]
  0002b	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 633  :     store_hw( &devid[1], fba->cu );

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR fba$[rsp]
  00034	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  00038	e8 00 00 00 00	 call	 _byteswap_ushort
  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	48 6b c9 01	 imul	 rcx, rcx, 1
  00046	48 8b 54 24 38	 mov	 rdx, QWORD PTR devid$[rsp]
  0004b	48 03 d1	 add	 rdx, rcx
  0004e	48 8b ca	 mov	 rcx, rdx
  00051	0f b7 d0	 movzx	 edx, ax
  00054	e8 00 00 00 00	 call	 store_hw_noswap

; 634  :     devid[3] = 0x01;                  /* assume model is 1 */

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	48 6b c0 03	 imul	 rax, rax, 3
  00062	48 8b 4c 24 38	 mov	 rcx, QWORD PTR devid$[rsp]
  00067	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 635  :     store_hw( &devid[4], fba->devt );

  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR fba$[rsp]
  00070	0f b7 48 08	 movzx	 ecx, WORD PTR [rax+8]
  00074	e8 00 00 00 00	 call	 _byteswap_ushort
  00079	b9 01 00 00 00	 mov	 ecx, 1
  0007e	48 6b c9 04	 imul	 rcx, rcx, 4
  00082	48 8b 54 24 38	 mov	 rdx, QWORD PTR devid$[rsp]
  00087	48 03 d1	 add	 rdx, rcx
  0008a	48 8b ca	 mov	 rcx, rdx
  0008d	0f b7 d0	 movzx	 edx, ax
  00090	e8 00 00 00 00	 call	 store_hw_noswap

; 636  :     devid[6] = fba->model;

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	48 6b c0 06	 imul	 rax, rax, 6
  0009e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR devid$[rsp]
  000a3	48 8b 54 24 30	 mov	 rdx, QWORD PTR fba$[rsp]
  000a8	0f b6 52 0c	 movzx	 edx, BYTE PTR [rdx+12]
  000ac	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 637  : 
; 638  :     return 7;

  000af	b8 07 00 00 00	 mov	 eax, 7

; 639  : }

  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
dasd_build_fba_devid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdtab.c
_TEXT	SEGMENT
num$ = 32
tv128 = 36
buf$ = 40
__$ArrayPad$ = 88
dev$ = 128
iobuf$ = 136
count$ = 144
dasd_build_ckd_subsys_status PROC

; 599  : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 600  : int  num;
; 601  : BYTE buf[44];
; 602  : 
; 603  :     /* Build the basic subsystem status data in the I/O area */
; 604  :     memset( buf, 0, 44 );

  00024	48 8d 44 24 28	 lea	 rax, QWORD PTR buf$[rsp]
  00029	48 8b f8	 mov	 rdi, rax
  0002c	33 c0		 xor	 eax, eax
  0002e	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00033	f3 aa		 rep stosb

; 605  :     buf[1] = dev->devnum & 0xFF;

  00035	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00041	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	48 6b c9 01	 imul	 rcx, rcx, 1
  0004f	88 44 0c 28	 mov	 BYTE PTR buf$[rsp+rcx], al

; 606  :     buf[2] = DEVICES_PER_SUBSYS - 1;

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	48 6b c0 02	 imul	 rax, rax, 2
  0005c	c6 44 04 28 1f	 mov	 BYTE PTR buf$[rsp+rax], 31

; 607  :     store_hw (buf + 38, SSID(dev));

  00061	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00069	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0006d	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  00070	0f b7 c8	 movzx	 ecx, ax
  00073	e8 00 00 00 00	 call	 _byteswap_ushort
  00078	48 8d 4c 24 4e	 lea	 rcx, QWORD PTR buf$[rsp+38]
  0007d	0f b7 d0	 movzx	 edx, ax
  00080	e8 00 00 00 00	 call	 store_hw_noswap

; 608  :     num = 40;

  00085	c7 44 24 20 28
	00 00 00	 mov	 DWORD PTR num$[rsp], 40	; 00000028H

; 609  : 
; 610  :     /* Build an additional 4 bytes of data for the 3990-6 */
; 611  :     if (MODEL6(dev->ckdcu))

  0008d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00095	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  0009c	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  000a0	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  000a5	75 30		 jne	 SHORT $LN2@dasd_build
  000a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000af	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  000b6	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  000ba	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  000bf	75 16		 jne	 SHORT $LN2@dasd_build

; 612  :     {
; 613  :         buf[0] = 0x01;            /* Set 3990-6 enhanced flag */

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	48 6b c0 00	 imul	 rax, rax, 0
  000ca	c6 44 04 28 01	 mov	 BYTE PTR buf$[rsp+rax], 1

; 614  :         num = 44;

  000cf	c7 44 24 20 2c
	00 00 00	 mov	 DWORD PTR num$[rsp], 44	; 0000002cH
$LN2@dasd_build:

; 615  :     } /* end if(3990-6) */
; 616  : 
; 617  :     /* Copy subsystem status to the I/O buf */
; 618  :     count = count > num ? num : count;

  000d7	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  000db	39 84 24 90 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  000e2	7e 0a		 jle	 SHORT $LN4@dasd_build
  000e4	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  000e8	89 44 24 24	 mov	 DWORD PTR tv128[rsp], eax
  000ec	eb 0b		 jmp	 SHORT $LN5@dasd_build
$LN4@dasd_build:
  000ee	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  000f5	89 44 24 24	 mov	 DWORD PTR tv128[rsp], eax
$LN5@dasd_build:
  000f9	8b 44 24 24	 mov	 eax, DWORD PTR tv128[rsp]
  000fd	89 84 24 90 00
	00 00		 mov	 DWORD PTR count$[rsp], eax

; 619  :     memcpy (iobuf, buf, count);

  00104	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR count$[rsp]
  0010c	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00111	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00119	48 8b f1	 mov	 rsi, rcx
  0011c	48 8b c8	 mov	 rcx, rax
  0011f	f3 a4		 rep movsb

; 620  : 
; 621  :     return num;

  00121	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]

; 622  : }

  00125	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012a	48 33 cc	 xor	 rcx, rsp
  0012d	e8 00 00 00 00	 call	 __security_check_cookie
  00132	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	c3		 ret	 0
dasd_build_ckd_subsys_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdtab.c
_TEXT	SEGMENT
i$ = 32
tv147 = 36
tv328 = 40
$T1 = 48
$T2 = 56
$T3 = 64
tv87 = 72
tv172 = 80
tv204 = 88
buf$ = 96
__$ArrayPad$ = 352
dev$ = 400
iobuf$ = 408
count$ = 416
dasd_build_ckd_config_data PROC

; 517  : {

$LN26:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 518  : int  i;
; 519  : BYTE buf[256];
; 520  : 
; 521  :     /* Clear the configuration data area */
; 522  :     memset( buf, 0, 256 );

  0002a	48 8d 44 24 60	 lea	 rax, QWORD PTR buf$[rsp]
  0002f	48 8b f8	 mov	 rdi, rax
  00032	33 c0		 xor	 eax, eax
  00034	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00039	f3 aa		 rep stosb

; 523  : 
; 524  :     /* NOTE: ckdtab and/or ckdcu could be NULL if this is a shared
; 525  :        device that hasn't connected to the server yet (which would
; 526  :        cause a crash), so we have to check.
; 527  :     */
; 528  :     if (dev->ckdtab && dev->ckdcu)

  0003b	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	48 83 b8 a0 12
	00 00 00	 cmp	 QWORD PTR [rax+4768], 0
  0004b	0f 84 32 05 00
	00		 je	 $LN14@dasd_build
  00051	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00059	48 83 b8 a8 12
	00 00 00	 cmp	 QWORD PTR [rax+4776], 0
  00061	0f 84 1c 05 00
	00		 je	 $LN14@dasd_build

; 529  :     {
; 530  :         /* Bytes 0-31: NED 1  Node element descriptor for the device */
; 531  :         store_fw (buf, 0xdc010100);

  00067	b9 00 01 01 dc	 mov	 ecx, -603913984		; dc010100H
  0006c	e8 00 00 00 00	 call	 _byteswap_ulong
  00071	8b d0		 mov	 edx, eax
  00073	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$[rsp]
  00078	e8 00 00 00 00	 call	 store_fw_noswap

; 532  :         sprintf ((char *)&buf[4], "  %4.4X0%2.2XHRCZZ",

  0007d	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00085	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0008c	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  00090	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00098	48 8b 89 a0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4768]
  0009f	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  000a3	ba 01 00 00 00	 mov	 edx, 1
  000a8	48 6b d2 04	 imul	 rdx, rdx, 4
  000ac	48 8d 54 14 60	 lea	 rdx, QWORD PTR buf$[rsp+rdx]
  000b1	48 89 54 24 48	 mov	 QWORD PTR tv87[rsp], rdx
  000b6	44 8b c8	 mov	 r9d, eax
  000b9	44 8b c1	 mov	 r8d, ecx
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159364
  000c3	48 8b 44 24 48	 mov	 rax, QWORD PTR tv87[rsp]
  000c8	48 8b c8	 mov	 rcx, rax
  000cb	e8 00 00 00 00	 call	 sprintf

; 533  :                             dev->ckdtab->devt, dev->ckdtab->model);
; 534  :         memcpy( &buf[18], dev->serial, 12 );

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	48 6b c0 12	 imul	 rax, rax, 18
  000d9	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e1	48 8d 7c 04 60	 lea	 rdi, QWORD PTR buf$[rsp+rax]
  000e6	48 8d b1 98 00
	00 00		 lea	 rsi, QWORD PTR [rcx+152]
  000ed	b9 0c 00 00 00	 mov	 ecx, 12
  000f2	f3 a4		 rep movsb

; 535  :         for (i = 4; i < 30; i++)

  000f4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR i$[rsp], 4
  000fc	eb 0a		 jmp	 SHORT $LN4@dasd_build
$LN2@dasd_build:
  000fe	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00102	ff c0		 inc	 eax
  00104	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@dasd_build:
  00108	83 7c 24 20 1e	 cmp	 DWORD PTR i$[rsp], 30
  0010d	7d 44		 jge	 SHORT $LN3@dasd_build

; 536  :             buf[i] = host_to_guest( isalnum( buf[i] ) ? buf[i] : '0' );

  0010f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00114	0f b6 44 04 60	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00119	8b c8		 mov	 ecx, eax
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  00121	85 c0		 test	 eax, eax
  00123	74 10		 je	 SHORT $LN16@dasd_build
  00125	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0012a	0f b6 44 04 60	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  0012f	89 44 24 24	 mov	 DWORD PTR tv147[rsp], eax
  00133	eb 08		 jmp	 SHORT $LN17@dasd_build
$LN16@dasd_build:
  00135	c7 44 24 24 30
	00 00 00	 mov	 DWORD PTR tv147[rsp], 48 ; 00000030H
$LN17@dasd_build:
  0013d	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR tv147[rsp]
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  00148	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0014d	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al
  00151	eb ab		 jmp	 SHORT $LN2@dasd_build
$LN3@dasd_build:

; 537  :         store_hw(buf + 30, dev->devnum);        /* Uniquely tag within system */

  00153	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015b	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  0015f	e8 00 00 00 00	 call	 _byteswap_ushort
  00164	48 8d 4c 24 7e	 lea	 rcx, QWORD PTR buf$[rsp+30]
  00169	0f b7 d0	 movzx	 edx, ax
  0016c	e8 00 00 00 00	 call	 store_hw_noswap

; 538  : 
; 539  :         /* Bytes 32-63: NED 2  Node element descriptor for the string */
; 540  :         store_fw (buf + 32, 0xd4020000);

  00171	b9 00 00 02 d4	 mov	 ecx, -738066432		; d4020000H
  00176	e8 00 00 00 00	 call	 _byteswap_ulong
  0017b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+32]
  00183	8b d0		 mov	 edx, eax
  00185	e8 00 00 00 00	 call	 store_fw_noswap

; 541  :         sprintf ((char *)&buf[36], "  %4.4X0%2.2XHRCZZ000000000003",

  0018a	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00192	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  00199	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  0019d	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a5	48 8b 89 a0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4768]
  001ac	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  001b0	ba 01 00 00 00	 mov	 edx, 1
  001b5	48 6b d2 24	 imul	 rdx, rdx, 36		; 00000024H
  001b9	48 8d 54 14 60	 lea	 rdx, QWORD PTR buf$[rsp+rdx]
  001be	48 89 54 24 50	 mov	 QWORD PTR tv172[rsp], rdx
  001c3	44 8b c8	 mov	 r9d, eax
  001c6	44 8b c1	 mov	 r8d, ecx
  001c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159365
  001d0	48 8b 44 24 50	 mov	 rax, QWORD PTR tv172[rsp]
  001d5	48 8b c8	 mov	 rcx, rax
  001d8	e8 00 00 00 00	 call	 sprintf

; 542  :                             dev->ckdtab->devt, dev->ckdtab->model);
; 543  :         for (i = 36; i < 62; i++)

  001dd	c7 44 24 20 24
	00 00 00	 mov	 DWORD PTR i$[rsp], 36	; 00000024H
  001e5	eb 0a		 jmp	 SHORT $LN7@dasd_build
$LN5@dasd_build:
  001e7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001eb	ff c0		 inc	 eax
  001ed	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@dasd_build:
  001f1	83 7c 24 20 3e	 cmp	 DWORD PTR i$[rsp], 62	; 0000003eH
  001f6	7d 1b		 jge	 SHORT $LN6@dasd_build

; 544  :             buf[i] = host_to_guest(buf[i]);

  001f8	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001fd	0f b6 4c 04 60	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  00208	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0020d	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al
  00211	eb d4		 jmp	 SHORT $LN5@dasd_build
$LN6@dasd_build:

; 545  :         store_hw (buf + 62, 0x0000);

  00213	33 c9		 xor	 ecx, ecx
  00215	e8 00 00 00 00	 call	 _byteswap_ushort
  0021a	48 8d 8c 24 9e
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+62]
  00222	0f b7 d0	 movzx	 edx, ax
  00225	e8 00 00 00 00	 call	 store_hw_noswap

; 546  : 
; 547  :         /* Bytes 64-95: NED 3  Node element descriptor for the storage director */
; 548  :         store_fw (buf + 64, 0xd0000000);

  0022a	b9 00 00 00 d0	 mov	 ecx, -805306368		; d0000000H
  0022f	e8 00 00 00 00	 call	 _byteswap_ulong
  00234	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+64]
  0023c	8b d0		 mov	 edx, eax
  0023e	e8 00 00 00 00	 call	 store_fw_noswap

; 549  :         sprintf ((char *)&buf[68], "  %4.4X0%2.2XHRCZZ000000000002",

  00243	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0024b	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  00252	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  00256	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0025e	48 8b 89 a8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4776]
  00265	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  00269	ba 01 00 00 00	 mov	 edx, 1
  0026e	48 6b d2 44	 imul	 rdx, rdx, 68		; 00000044H
  00272	48 8d 54 14 60	 lea	 rdx, QWORD PTR buf$[rsp+rdx]
  00277	48 89 54 24 58	 mov	 QWORD PTR tv204[rsp], rdx
  0027c	44 8b c8	 mov	 r9d, eax
  0027f	44 8b c1	 mov	 r8d, ecx
  00282	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159366
  00289	48 8b 44 24 58	 mov	 rax, QWORD PTR tv204[rsp]
  0028e	48 8b c8	 mov	 rcx, rax
  00291	e8 00 00 00 00	 call	 sprintf

; 550  :                             dev->ckdcu->devt, dev->ckdcu->model);
; 551  :         for (i = 68; i < 94; i++)

  00296	c7 44 24 20 44
	00 00 00	 mov	 DWORD PTR i$[rsp], 68	; 00000044H
  0029e	eb 0a		 jmp	 SHORT $LN10@dasd_build
$LN8@dasd_build:
  002a0	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002a4	ff c0		 inc	 eax
  002a6	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@dasd_build:
  002aa	83 7c 24 20 5e	 cmp	 DWORD PTR i$[rsp], 94	; 0000005eH
  002af	7d 1b		 jge	 SHORT $LN9@dasd_build

; 552  :             buf[i] = host_to_guest(buf[i]);

  002b1	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002b6	0f b6 4c 04 60	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  002c1	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  002c6	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al
  002ca	eb d4		 jmp	 SHORT $LN8@dasd_build
$LN9@dasd_build:

; 553  :         buf[94] = 0x00;

  002cc	b8 01 00 00 00	 mov	 eax, 1
  002d1	48 6b c0 5e	 imul	 rax, rax, 94		; 0000005eH
  002d5	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  002da	48 81 7c 24 30
	00 01 00 00	 cmp	 QWORD PTR $T1[rsp], 256	; 00000100H
  002e3	73 02		 jae	 SHORT $LN18@dasd_build
  002e5	eb 05		 jmp	 SHORT $LN19@dasd_build
$LN18@dasd_build:
  002e7	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN19@dasd_build:
  002ec	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  002f1	c6 44 04 60 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 554  :         buf[95] = (dev->devnum >> 8) & 0xFF;

  002f6	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002fe	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00302	c1 f8 08	 sar	 eax, 8
  00305	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0030a	b9 01 00 00 00	 mov	 ecx, 1
  0030f	48 6b c9 5f	 imul	 rcx, rcx, 95		; 0000005fH
  00313	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al

; 555  : 
; 556  :         /* Bytes 96-127: NED 4  Node element descriptor for the subsystem */
; 557  :         store_fw (buf + 96, 0xF0000001);

  00317	b9 01 00 00 f0	 mov	 ecx, -268435455		; f0000001H
  0031c	e8 00 00 00 00	 call	 _byteswap_ulong
  00321	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+96]
  00329	8b d0		 mov	 edx, eax
  0032b	e8 00 00 00 00	 call	 store_fw_noswap

; 558  :         sprintf ((char *)&buf[100], "  %4.4X   HRCZZ000000000001",

  00330	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00338	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  0033f	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  00343	b9 01 00 00 00	 mov	 ecx, 1
  00348	48 6b c9 64	 imul	 rcx, rcx, 100		; 00000064H
  0034c	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  00351	44 8b c0	 mov	 r8d, eax
  00354	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159367
  0035b	e8 00 00 00 00	 call	 sprintf

; 559  :                             dev->ckdcu->devt);
; 560  :         for (i = 100; i < 126; i++)

  00360	c7 44 24 20 64
	00 00 00	 mov	 DWORD PTR i$[rsp], 100	; 00000064H
  00368	eb 0a		 jmp	 SHORT $LN13@dasd_build
$LN11@dasd_build:
  0036a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0036e	ff c0		 inc	 eax
  00370	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@dasd_build:
  00374	83 7c 24 20 7e	 cmp	 DWORD PTR i$[rsp], 126	; 0000007eH
  00379	7d 1b		 jge	 SHORT $LN12@dasd_build

; 561  :             buf[i] = host_to_guest(buf[i]);

  0037b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00380	0f b6 4c 04 60	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0038b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00390	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al
  00394	eb d4		 jmp	 SHORT $LN11@dasd_build
$LN12@dasd_build:

; 562  :         store_hw (buf + 126, 0x0000);

  00396	33 c9		 xor	 ecx, ecx
  00398	e8 00 00 00 00	 call	 _byteswap_ushort
  0039d	48 8d 8c 24 de
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+126]
  003a5	0f b7 d0	 movzx	 edx, ax
  003a8	e8 00 00 00 00	 call	 store_hw_noswap

; 563  : 
; 564  :         /* Bytes 128-223: zeroes */
; 565  : 
; 566  :         /* Bytes 224-255: NEQ  Node Element Qualifier */
; 567  :         buf[224] = 0x80;                  // flags (general NEQ)

  003ad	b8 01 00 00 00	 mov	 eax, 1
  003b2	48 69 c0 e0 00
	00 00		 imul	 rax, rax, 224		; 000000e0H
  003b9	c6 44 04 60 80	 mov	 BYTE PTR buf$[rsp+rax], 128 ; 00000080H

; 568  :         buf[225] = 0;                     // record selector

  003be	b8 01 00 00 00	 mov	 eax, 1
  003c3	48 69 c0 e1 00
	00 00		 imul	 rax, rax, 225		; 000000e1H
  003ca	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  003cf	48 81 7c 24 38
	00 01 00 00	 cmp	 QWORD PTR $T2[rsp], 256	; 00000100H
  003d8	73 02		 jae	 SHORT $LN20@dasd_build
  003da	eb 05		 jmp	 SHORT $LN21@dasd_build
$LN20@dasd_build:
  003dc	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN21@dasd_build:
  003e1	48 8b 44 24 38	 mov	 rax, QWORD PTR $T2[rsp]
  003e6	c6 44 04 60 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 569  :         store_hw (buf + 226, IFID(dev));  // interface id

  003eb	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003f7	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  003fa	c1 f8 05	 sar	 eax, 5
  003fd	83 e0 07	 and	 eax, 7
  00400	0f b7 c8	 movzx	 ecx, ax
  00403	e8 00 00 00 00	 call	 _byteswap_ushort
  00408	48 8d 8c 24 42
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+226]
  00410	0f b7 d0	 movzx	 edx, ax
  00413	e8 00 00 00 00	 call	 store_hw_noswap

; 570  :         store_hw (buf + 228, 0);          // must be zero

  00418	33 c9		 xor	 ecx, ecx
  0041a	e8 00 00 00 00	 call	 _byteswap_ushort
  0041f	48 8d 8c 24 44
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+228]
  00427	0f b7 d0	 movzx	 edx, ax
  0042a	e8 00 00 00 00	 call	 store_hw_noswap

; 571  :         buf[230] = 0x1E;                  // primary missing interrupt timer interval

  0042f	b8 01 00 00 00	 mov	 eax, 1
  00434	48 69 c0 e6 00
	00 00		 imul	 rax, rax, 230		; 000000e6H
  0043b	c6 44 04 60 1e	 mov	 BYTE PTR buf$[rsp+rax], 30

; 572  :         buf[231] = 0x00;                  // secondary missing interrupt timer interval

  00440	b8 01 00 00 00	 mov	 eax, 1
  00445	48 69 c0 e7 00
	00 00		 imul	 rax, rax, 231		; 000000e7H
  0044c	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  00451	48 81 7c 24 40
	00 01 00 00	 cmp	 QWORD PTR $T3[rsp], 256	; 00000100H
  0045a	73 02		 jae	 SHORT $LN22@dasd_build
  0045c	eb 05		 jmp	 SHORT $LN23@dasd_build
$LN22@dasd_build:
  0045e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN23@dasd_build:
  00463	48 8b 44 24 40	 mov	 rax, QWORD PTR $T3[rsp]
  00468	c6 44 04 60 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 573  :         store_hw (buf + 232, SSID(dev));  // subsystem id

  0046d	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00475	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00479	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  0047c	0f b7 c8	 movzx	 ecx, ax
  0047f	e8 00 00 00 00	 call	 _byteswap_ushort
  00484	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+232]
  0048c	0f b7 d0	 movzx	 edx, ax
  0048f	e8 00 00 00 00	 call	 store_hw_noswap

; 574  :         buf[234] = 0x80;                  // path/cluster id

  00494	b8 01 00 00 00	 mov	 eax, 1
  00499	48 69 c0 ea 00
	00 00		 imul	 rax, rax, 234		; 000000eaH
  004a0	c6 44 04 60 80	 mov	 BYTE PTR buf$[rsp+rax], 128 ; 00000080H

; 575  :         buf[235] = (dev->devnum & 0xFF);  // unit address

  004a5	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ad	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004b1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004b6	b9 01 00 00 00	 mov	 ecx, 1
  004bb	48 69 c9 eb 00
	00 00		 imul	 rcx, rcx, 235		; 000000ebH
  004c2	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al

; 576  :         buf[236] = (dev->devnum & 0xFF);  // physical device id

  004c6	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ce	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004d2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004d7	b9 01 00 00 00	 mov	 ecx, 1
  004dc	48 69 c9 ec 00
	00 00		 imul	 rcx, rcx, 236		; 000000ecH
  004e3	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al

; 577  :         buf[237] = (dev->devnum & 0xFF);  // physical device address

  004e7	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ef	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004f3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004f8	b9 01 00 00 00	 mov	 ecx, 1
  004fd	48 69 c9 ed 00
	00 00		 imul	 rcx, rcx, 237		; 000000edH
  00504	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al

; 578  :         buf[238] = buf[227];              // SA ID (same as interface ID, byte 227)

  00508	b8 01 00 00 00	 mov	 eax, 1
  0050d	48 69 c0 e3 00
	00 00		 imul	 rax, rax, 227		; 000000e3H
  00514	b9 01 00 00 00	 mov	 ecx, 1
  00519	48 69 c9 ee 00
	00 00		 imul	 rcx, rcx, 238		; 000000eeH
  00520	0f b6 44 04 60	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00525	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al

; 579  :         store_hw (buf + 239, 0);          // escon link address

  00529	33 c9		 xor	 ecx, ecx
  0052b	e8 00 00 00 00	 call	 _byteswap_ushort
  00530	48 8d 8c 24 4f
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+239]
  00538	0f b7 d0	 movzx	 edx, ax
  0053b	e8 00 00 00 00	 call	 store_hw_noswap

; 580  :         buf[241] = 0x80;                  // interface protocol type (parallel)

  00540	b8 01 00 00 00	 mov	 eax, 1
  00545	48 69 c0 f1 00
	00 00		 imul	 rax, rax, 241		; 000000f1H
  0054c	c6 44 04 60 80	 mov	 BYTE PTR buf$[rsp+rax], 128 ; 00000080H

; 581  : //      buf[241] = 0x40;                  // interface protocol type (escon)
; 582  :         buf[242] = 0x80;                  // NEQ format flags

  00551	b8 01 00 00 00	 mov	 eax, 1
  00556	48 69 c0 f2 00
	00 00		 imul	 rax, rax, 242		; 000000f2H
  0055d	c6 44 04 60 80	 mov	 BYTE PTR buf$[rsp+rax], 128 ; 00000080H

; 583  :         buf[243] = (dev->devnum & 0xFF);  // logical device address (LDA)

  00562	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0056a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0056e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00573	b9 01 00 00 00	 mov	 ecx, 1
  00578	48 69 c9 f3 00
	00 00		 imul	 rcx, rcx, 243		; 000000f3H
  0057f	88 44 0c 60	 mov	 BYTE PTR buf$[rsp+rcx], al
$LN14@dasd_build:

; 584  :                                           // bytes 244-255 must be zero
; 585  :     }
; 586  : 
; 587  :     /* Copy data characteristics to the I/O buf */
; 588  :     count = count > 256 ? 256 : count;

  00583	81 bc 24 a0 01
	00 00 00 01 00
	00		 cmp	 DWORD PTR count$[rsp], 256 ; 00000100H
  0058e	7e 0a		 jle	 SHORT $LN24@dasd_build
  00590	c7 44 24 28 00
	01 00 00	 mov	 DWORD PTR tv328[rsp], 256 ; 00000100H
  00598	eb 0b		 jmp	 SHORT $LN25@dasd_build
$LN24@dasd_build:
  0059a	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  005a1	89 44 24 28	 mov	 DWORD PTR tv328[rsp], eax
$LN25@dasd_build:
  005a5	8b 44 24 28	 mov	 eax, DWORD PTR tv328[rsp]
  005a9	89 84 24 a0 01
	00 00		 mov	 DWORD PTR count$[rsp], eax

; 589  :     memcpy (iobuf, buf, count);

  005b0	48 63 84 24 a0
	01 00 00	 movsxd	 rax, DWORD PTR count$[rsp]
  005b8	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$[rsp]
  005bd	48 8b bc 24 98
	01 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  005c5	48 8b f1	 mov	 rsi, rcx
  005c8	48 8b c8	 mov	 rcx, rax
  005cb	f3 a4		 rep movsb

; 590  : 
; 591  :     return 256;

  005cd	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
$LN15@dasd_build:

; 592  : }

  005d2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005da	48 33 cc	 xor	 rcx, rsp
  005dd	e8 00 00 00 00	 call	 __security_check_cookie
  005e2	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  005e9	5f		 pop	 rdi
  005ea	5e		 pop	 rsi
  005eb	c3		 ret	 0
dasd_build_ckd_config_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdtab.c
_TEXT	SEGMENT
altcyls$ = 32
tv131 = 36
tv133 = 40
ckd$ = 64
cu$ = 72
devchar$ = 80
cyls$ = 88
dasd_build_ckd_devchar PROC

; 397  : {

$LN16:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 398  : int altcyls;                            /* Number alternate cyls     */
; 399  : 
; 400  :     if (cyls > ckd->cyls) altcyls = cyls - ckd->cyls;

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  0001e	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  00022	39 44 24 58	 cmp	 DWORD PTR cyls$[rsp], eax
  00026	7e 17		 jle	 SHORT $LN2@dasd_build
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  0002d	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  00031	8b 4c 24 58	 mov	 ecx, DWORD PTR cyls$[rsp]
  00035	2b c8		 sub	 ecx, eax
  00037	8b c1		 mov	 eax, ecx
  00039	89 44 24 20	 mov	 DWORD PTR altcyls$[rsp], eax
  0003d	eb 08		 jmp	 SHORT $LN3@dasd_build
$LN2@dasd_build:

; 401  :     else altcyls = 0;

  0003f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR altcyls$[rsp], 0
$LN3@dasd_build:

; 402  : 
; 403  :     memset( devchar, 0, 64 );

  00047	48 8b 7c 24 50	 mov	 rdi, QWORD PTR devchar$[rsp]
  0004c	33 c0		 xor	 eax, eax
  0004e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00053	f3 aa		 rep stosb

; 404  :     store_hw(devchar+0, cu->devt);              // Storage control type

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  0005a	0f b7 48 08	 movzx	 ecx, WORD PTR [rax+8]
  0005e	e8 00 00 00 00	 call	 _byteswap_ushort
  00063	0f b7 d0	 movzx	 edx, ax
  00066	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0006b	e8 00 00 00 00	 call	 store_hw_noswap

; 405  :     devchar[2]  = cu->model;                    // CU model

  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	48 6b c0 02	 imul	 rax, rax, 2
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0007e	48 8b 54 24 48	 mov	 rdx, QWORD PTR cu$[rsp]
  00083	0f b6 52 0a	 movzx	 edx, BYTE PTR [rdx+10]
  00087	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 406  :     store_hw(devchar+3, ckd->devt);             // Device type

  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  0008f	0f b7 48 08	 movzx	 ecx, WORD PTR [rax+8]
  00093	e8 00 00 00 00	 call	 _byteswap_ushort
  00098	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0009d	48 83 c1 03	 add	 rcx, 3
  000a1	0f b7 d0	 movzx	 edx, ax
  000a4	e8 00 00 00 00	 call	 store_hw_noswap

; 407  :     devchar[5]  = ckd->model;                   // Device model

  000a9	b8 01 00 00 00	 mov	 eax, 1
  000ae	48 6b c0 05	 imul	 rax, rax, 5
  000b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  000b7	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  000bc	0f b6 52 0a	 movzx	 edx, BYTE PTR [rdx+10]
  000c0	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 408  :     store_fw(devchar+6, cu->sctlfeat |          // Device and SD facilities

  000c3	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  000c8	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  000cc	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  000d1	75 1a		 jne	 SHORT $LN14@dasd_build
  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  000d8	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  000dc	3d 80 33 00 00	 cmp	 eax, 13184		; 00003380H
  000e1	75 0a		 jne	 SHORT $LN14@dasd_build
  000e3	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000eb	eb 08		 jmp	 SHORT $LN15@dasd_build
$LN14@dasd_build:
  000ed	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@dasd_build:
  000f5	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  000fa	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000fd	89 44 24 28	 mov	 DWORD PTR tv133[rsp], eax
  00101	8b 44 24 24	 mov	 eax, DWORD PTR tv131[rsp]
  00105	8b 4c 24 28	 mov	 ecx, DWORD PTR tv133[rsp]
  00109	0b c8		 or	 ecx, eax
  0010b	8b c1		 mov	 eax, ecx
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 _byteswap_ulong
  00114	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00119	48 83 c1 06	 add	 rcx, 6
  0011d	8b d0		 mov	 edx, eax
  0011f	e8 00 00 00 00	 call	 store_fw_noswap

; 409  :       (cu->devt == 0x3990 &&                    // ... or in 24-byte sense
; 410  :        ckd->devt == 0x3380));                   // ... compatibility for 3380
; 411  :                                                 // ... hosted on 3990 controller
; 412  :     devchar[10] = ckd->devclass;                // Device class code:

  00124	b8 01 00 00 00	 mov	 eax, 1
  00129	48 6b c0 0a	 imul	 rax, rax, 10
  0012d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00132	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  00137	0f b6 52 0b	 movzx	 edx, BYTE PTR [rdx+11]
  0013b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 413  :                                                 // (always X'20'=DASD)
; 414  :     devchar[11] = ckd->code;                    // Device type code

  0013e	b8 01 00 00 00	 mov	 eax, 1
  00143	48 6b c0 0b	 imul	 rax, rax, 11
  00147	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0014c	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  00151	0f b6 52 0c	 movzx	 edx, BYTE PTR [rdx+12]
  00155	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 415  :     store_hw(devchar+12, cyls - altcyls);       // Primary cylinders

  00158	8b 44 24 20	 mov	 eax, DWORD PTR altcyls$[rsp]
  0015c	8b 4c 24 58	 mov	 ecx, DWORD PTR cyls$[rsp]
  00160	2b c8		 sub	 ecx, eax
  00162	8b c1		 mov	 eax, ecx
  00164	0f b7 c8	 movzx	 ecx, ax
  00167	e8 00 00 00 00	 call	 _byteswap_ushort
  0016c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00171	48 83 c1 0c	 add	 rcx, 12
  00175	0f b7 d0	 movzx	 edx, ax
  00178	e8 00 00 00 00	 call	 store_hw_noswap

; 416  :     store_hw(devchar+14, ckd->heads);           // Tracks per cylinder

  0017d	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  00182	0f b7 48 12	 movzx	 ecx, WORD PTR [rax+18]
  00186	e8 00 00 00 00	 call	 _byteswap_ushort
  0018b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00190	48 83 c1 0e	 add	 rcx, 14
  00194	0f b7 d0	 movzx	 edx, ax
  00197	e8 00 00 00 00	 call	 store_hw_noswap

; 417  :     devchar[16] = (BYTE)(ckd->sectors);         // Number of sectors

  0019c	b8 01 00 00 00	 mov	 eax, 1
  001a1	48 6b c0 10	 imul	 rax, rax, 16
  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  001aa	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  001af	0f b6 52 1c	 movzx	 edx, BYTE PTR [rdx+28]
  001b3	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 418  :     store_hw(devchar+18, ckd->len);             // Track length

  001b6	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  001bb	0f b7 48 1a	 movzx	 ecx, WORD PTR [rax+26]
  001bf	e8 00 00 00 00	 call	 _byteswap_ushort
  001c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  001c9	48 83 c1 12	 add	 rcx, 18
  001cd	0f b7 d0	 movzx	 edx, ax
  001d0	e8 00 00 00 00	 call	 store_hw_noswap

; 419  :     store_hw(devchar+20, ckd->har0);            // Length of HA and R0

  001d5	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  001da	0f b7 48 18	 movzx	 ecx, WORD PTR [rax+24]
  001de	e8 00 00 00 00	 call	 _byteswap_ushort
  001e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  001e8	48 83 c1 14	 add	 rcx, 20
  001ec	0f b7 d0	 movzx	 edx, ax
  001ef	e8 00 00 00 00	 call	 store_hw_noswap

; 420  :     if (ckd->formula == 1)

  001f4	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  001f9	0f bf 40 20	 movsx	 eax, WORD PTR [rax+32]
  001fd	83 f8 01	 cmp	 eax, 1
  00200	75 77		 jne	 SHORT $LN4@dasd_build

; 421  :     {
; 422  :         devchar[22] = (BYTE)(ckd->formula);     // Track capacity formula

  00202	b8 01 00 00 00	 mov	 eax, 1
  00207	48 6b c0 16	 imul	 rax, rax, 22
  0020b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00210	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  00215	0f b6 52 20	 movzx	 edx, BYTE PTR [rdx+32]
  00219	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 423  :         devchar[23] = (BYTE)(ckd->f1);          // Factor F1

  0021c	b8 01 00 00 00	 mov	 eax, 1
  00221	48 6b c0 17	 imul	 rax, rax, 23
  00225	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0022a	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  0022f	0f b6 52 22	 movzx	 edx, BYTE PTR [rdx+34]
  00233	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 424  :         store_hw(devchar+24, ckd->f2);          // Factor F2

  00236	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  0023b	0f b7 48 24	 movzx	 ecx, WORD PTR [rax+36]
  0023f	e8 00 00 00 00	 call	 _byteswap_ushort
  00244	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00249	48 83 c1 18	 add	 rcx, 24
  0024d	0f b7 d0	 movzx	 edx, ax
  00250	e8 00 00 00 00	 call	 store_hw_noswap

; 425  :         store_hw(devchar+26, ckd->f3);          // Factor F3

  00255	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  0025a	0f b7 48 26	 movzx	 ecx, WORD PTR [rax+38]
  0025e	e8 00 00 00 00	 call	 _byteswap_ushort
  00263	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00268	48 83 c1 1a	 add	 rcx, 26
  0026c	0f b7 d0	 movzx	 edx, ax
  0026f	e8 00 00 00 00	 call	 store_hw_noswap

; 426  :     }

  00274	e9 ae 00 00 00	 jmp	 $LN5@dasd_build
$LN4@dasd_build:

; 427  :     else if (ckd->formula == 2)

  00279	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  0027e	0f bf 40 20	 movsx	 eax, WORD PTR [rax+32]
  00282	83 f8 02	 cmp	 eax, 2
  00285	0f 85 9c 00 00
	00		 jne	 $LN6@dasd_build

; 428  :     {
; 429  :         devchar[22] = (BYTE)(ckd->formula);     // Track capacity formula

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	48 6b c0 16	 imul	 rax, rax, 22
  00294	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00299	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  0029e	0f b6 52 20	 movzx	 edx, BYTE PTR [rdx+32]
  002a2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 430  :         devchar[23] = (BYTE)(ckd->f1);          // Factor F1

  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	48 6b c0 17	 imul	 rax, rax, 23
  002ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  002b3	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  002b8	0f b6 52 22	 movzx	 edx, BYTE PTR [rdx+34]
  002bc	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 431  :         devchar[24] = (BYTE)(ckd->f2);          // Factor F2

  002bf	b8 01 00 00 00	 mov	 eax, 1
  002c4	48 6b c0 18	 imul	 rax, rax, 24
  002c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  002cd	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  002d2	0f b6 52 24	 movzx	 edx, BYTE PTR [rdx+36]
  002d6	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 432  :         devchar[25] = (BYTE)(ckd->f3);          // Factor F3

  002d9	b8 01 00 00 00	 mov	 eax, 1
  002de	48 6b c0 19	 imul	 rax, rax, 25
  002e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  002e7	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  002ec	0f b6 52 26	 movzx	 edx, BYTE PTR [rdx+38]
  002f0	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 433  :         devchar[26] = (BYTE)(ckd->f4);          // Factor F4

  002f3	b8 01 00 00 00	 mov	 eax, 1
  002f8	48 6b c0 1a	 imul	 rax, rax, 26
  002fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00301	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  00306	0f b6 52 28	 movzx	 edx, BYTE PTR [rdx+40]
  0030a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 434  :         devchar[27] = (BYTE)(ckd->f5);          // Factor F5

  0030d	b8 01 00 00 00	 mov	 eax, 1
  00312	48 6b c0 1b	 imul	 rax, rax, 27
  00316	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0031b	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  00320	0f b6 52 2a	 movzx	 edx, BYTE PTR [rdx+42]
  00324	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
$LN6@dasd_build:
$LN5@dasd_build:

; 435  :     }
; 436  :     if (altcyls > 0)

  00327	83 7c 24 20 00	 cmp	 DWORD PTR altcyls$[rsp], 0
  0032c	7e 50		 jle	 SHORT $LN7@dasd_build

; 437  :     {
; 438  :         store_hw(devchar+28, cyls - altcyls);   // Alternate cylinder & tracks

  0032e	8b 44 24 20	 mov	 eax, DWORD PTR altcyls$[rsp]
  00332	8b 4c 24 58	 mov	 ecx, DWORD PTR cyls$[rsp]
  00336	2b c8		 sub	 ecx, eax
  00338	8b c1		 mov	 eax, ecx
  0033a	0f b7 c8	 movzx	 ecx, ax
  0033d	e8 00 00 00 00	 call	 _byteswap_ushort
  00342	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00347	48 83 c1 1c	 add	 rcx, 28
  0034b	0f b7 d0	 movzx	 edx, ax
  0034e	e8 00 00 00 00	 call	 store_hw_noswap

; 439  :         store_hw(devchar+30, altcyls * ckd->heads);

  00353	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  00358	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  0035c	8b 4c 24 20	 mov	 ecx, DWORD PTR altcyls$[rsp]
  00360	0f af c8	 imul	 ecx, eax
  00363	8b c1		 mov	 eax, ecx
  00365	0f b7 c8	 movzx	 ecx, ax
  00368	e8 00 00 00 00	 call	 _byteswap_ushort
  0036d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00372	48 83 c1 1e	 add	 rcx, 30
  00376	0f b7 d0	 movzx	 edx, ax
  00379	e8 00 00 00 00	 call	 store_hw_noswap
$LN7@dasd_build:

; 440  :     }
; 441  :     devchar[40] = ckd->code;                    // MDR record ID

  0037e	b8 01 00 00 00	 mov	 eax, 1
  00383	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00387	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0038c	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  00391	0f b6 52 0c	 movzx	 edx, BYTE PTR [rdx+12]
  00395	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 442  :     devchar[41] = ckd->code;                    // OBR record ID

  00398	b8 01 00 00 00	 mov	 eax, 1
  0039d	48 6b c0 29	 imul	 rax, rax, 41		; 00000029H
  003a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  003a6	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  003ab	0f b6 52 0c	 movzx	 edx, BYTE PTR [rdx+12]
  003af	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 443  :     devchar[42] = cu->code;                     // CU Type Code

  003b2	b8 01 00 00 00	 mov	 eax, 1
  003b7	48 6b c0 2a	 imul	 rax, rax, 42		; 0000002aH
  003bb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  003c0	48 8b 54 24 48	 mov	 rdx, QWORD PTR cu$[rsp]
  003c5	0f b6 52 0b	 movzx	 edx, BYTE PTR [rdx+11]
  003c9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 444  :     devchar[43] = 0x02;                         // Parameter length

  003cc	b8 01 00 00 00	 mov	 eax, 1
  003d1	48 6b c0 2b	 imul	 rax, rax, 43		; 0000002bH
  003d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  003da	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2

; 445  :     store_hw(devchar+44, ckd->r0);              // Record 0 length

  003de	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  003e3	0f b7 48 14	 movzx	 ecx, WORD PTR [rax+20]
  003e7	e8 00 00 00 00	 call	 _byteswap_ushort
  003ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  003f1	48 83 c1 2c	 add	 rcx, 44			; 0000002cH
  003f5	0f b7 d0	 movzx	 edx, ax
  003f8	e8 00 00 00 00	 call	 store_hw_noswap

; 446  :     devchar[47] = 0x01;                         // Track set

  003fd	b8 01 00 00 00	 mov	 eax, 1
  00402	48 6b c0 2f	 imul	 rax, rax, 47		; 0000002fH
  00406	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0040b	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 447  :     devchar[48] = (BYTE)(ckd->f6);              // F6

  0040f	b8 01 00 00 00	 mov	 eax, 1
  00414	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00418	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0041d	48 8b 54 24 40	 mov	 rdx, QWORD PTR ckd$[rsp]
  00422	0f b6 52 2c	 movzx	 edx, BYTE PTR [rdx+44]
  00426	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 448  :     store_hw(devchar+49, ckd->rpscalc);         // RPS factor

  00429	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  0042e	0f b7 48 1e	 movzx	 ecx, WORD PTR [rax+30]
  00432	e8 00 00 00 00	 call	 _byteswap_ushort
  00437	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0043c	48 83 c1 31	 add	 rcx, 49			; 00000031H
  00440	0f b7 d0	 movzx	 edx, ax
  00443	e8 00 00 00 00	 call	 store_hw_noswap

; 449  :     devchar[51] =  0x00;                        // reserved byte 51

  00448	b8 01 00 00 00	 mov	 eax, 1
  0044d	48 6b c0 33	 imul	 rax, rax, 51		; 00000033H
  00451	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00456	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 450  :     /*---------------------------------------------------------------*/
; 451  :     /* 2013/01/09 Fish                                               */
; 452  :     /* RDC bytes 51-53 are reserved for model-3, model-6 and higher  */
; 453  :     /* control units and define a feature buffer lower/upper limit.  */
; 454  :     /* The lower limit might not need to be precisely 0x0f, but it   */
; 455  :     /* cannot be zero or else VSAM Extended Format Datasets cannot   */
; 456  :     /* be created by SMS. The precise value is unknown but was 0x0f  */
; 457  :     /* in previous versions of Hercules so we use that value. Bytes  */
; 458  :     /* 52-53 were previously always zero but defining them to be a   */
; 459  :     /* value larger than byte 51 seems to make logical sense since   */
; 460  :     /* we know it's an upper limit. I was told 0x7f was reasonable.  */
; 461  :     /*---------------------------------------------------------------*/
; 462  :     if (MODEL3(cu) || MODEL6(cu))               // Model-3/-6/greater?

  0045a	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  0045f	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  00463	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  00468	75 10		 jne	 SHORT $LN10@dasd_build
  0046a	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  0046f	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  00473	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  00478	74 24		 je	 SHORT $LN9@dasd_build
$LN10@dasd_build:
  0047a	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  0047f	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  00483	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  00488	0f 85 8c 00 00
	00		 jne	 $LN8@dasd_build
  0048e	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  00493	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  00497	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  0049c	75 7c		 jne	 SHORT $LN8@dasd_build
$LN9@dasd_build:

; 463  :     {
; 464  :         devchar[51] =  0x0f;                    // reserved (feature buffer lower limit)

  0049e	b8 01 00 00 00	 mov	 eax, 1
  004a3	48 6b c0 33	 imul	 rax, rax, 51		; 00000033H
  004a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  004ac	c6 04 01 0f	 mov	 BYTE PTR [rcx+rax], 15

; 465  : 
; 466  :         if (MODEL3(cu))                         // 3990-3

  004b0	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  004b5	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  004b9	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  004be	75 36		 jne	 SHORT $LN11@dasd_build
  004c0	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  004c5	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  004c9	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  004ce	75 26		 jne	 SHORT $LN11@dasd_build

; 467  :         {
; 468  :             devchar[52] =  0x00;                // reserved (always zero)

  004d0	b8 01 00 00 00	 mov	 eax, 1
  004d5	48 6b c0 34	 imul	 rax, rax, 52		; 00000034H
  004d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  004de	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 469  :             devchar[53] =  0x3f;                // reserved (feature buffer upper limit)

  004e2	b8 01 00 00 00	 mov	 eax, 1
  004e7	48 6b c0 35	 imul	 rax, rax, 53		; 00000035H
  004eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  004f0	c6 04 01 3f	 mov	 BYTE PTR [rcx+rax], 63	; 0000003fH

; 470  :         }

  004f4	eb 24		 jmp	 SHORT $LN12@dasd_build
$LN11@dasd_build:

; 471  :         else                                    // 3990-6 or greater
; 472  :         {
; 473  :             devchar[52] =  0x00;                // reserved (high byte feature buffer upper limit)

  004f6	b8 01 00 00 00	 mov	 eax, 1
  004fb	48 6b c0 34	 imul	 rax, rax, 52		; 00000034H
  004ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00504	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 474  :             devchar[53] =  0x7f;                // reserved (low byte  feature buffer upper limit)

  00508	b8 01 00 00 00	 mov	 eax, 1
  0050d	48 6b c0 35	 imul	 rax, rax, 53		; 00000035H
  00511	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00516	c6 04 01 7f	 mov	 BYTE PTR [rcx+rax], 127	; 0000007fH
$LN12@dasd_build:
$LN8@dasd_build:

; 475  :         }
; 476  :     }
; 477  :     devchar[54] = cu->funcfeat;                 // device/CU functions/features

  0051a	b8 01 00 00 00	 mov	 eax, 1
  0051f	48 6b c0 36	 imul	 rax, rax, 54		; 00000036H
  00523	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00528	48 8b 54 24 48	 mov	 rdx, QWORD PTR cu$[rsp]
  0052d	0f b6 52 0c	 movzx	 edx, BYTE PTR [rdx+12]
  00531	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 478  :     devchar[56] = cu->typecode;                 // Real CU type code

  00534	b8 01 00 00 00	 mov	 eax, 1
  00539	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0053d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00542	48 8b 54 24 48	 mov	 rdx, QWORD PTR cu$[rsp]
  00547	0f b6 52 0d	 movzx	 edx, BYTE PTR [rdx+13]
  0054b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 479  :     /*---------------------------------------------------------------*/
; 480  :     /* 2007/05/04 @kl                                                */
; 481  :     /* The following line to set devchar[57] to 0xff was restored    */
; 482  :     /* to circumvent a command reject when ICKDSF issues a Read      */
; 483  :     /* Special Home Address (0x0a) to an alternate track.            */
; 484  :     /* According to the IBM 3880 Storage Control Reference,          */
; 485  :     /* GA16-1661-09, and the 3990/9330 Reference, GA32-0274-05,      */
; 486  :     /* it should be 0x00 for real 3380 and 3390 devices.  Setting    */
; 487  :     /* it to 0xff makes the underlying real DASD look like a         */
; 488  :     /* disk array (whose virtual 3380/3390 disks have no alternate   */
; 489  :     /* tracks).  This causes DSF to skip issuing the 0x0a channel    */
; 490  :     /* command, which Hercules does not currently support, for       */
; 491  :     /* alternate tracks.                                             */
; 492  :     /*---------------------------------------------------------------*/
; 493  :     devchar[57] = 0xff;                         // real device type code

  0054e	b8 01 00 00 00	 mov	 eax, 1
  00553	48 6b c0 39	 imul	 rax, rax, 57		; 00000039H
  00557	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  0055c	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 494  : 
; 495  :     /*---------------------------------------------------------------*/
; 496  :     /*  https://www.vm.ibm.com/pubs/cp720/RDCBK.HTML                 */
; 497  :     /*                                                               */
; 498  :     /*  NAME       : HCPRDCBK                                        */
; 499  :     /*  DESCRIPTION: Real Device Characteristics Block               */
; 500  :     /*  DSECT      : RDCBK                                           */
; 501  :     /*   ...                                                         */
; 502  :     /*  003A  58 Bitstring  2 RDC5859    DASD SPECIFIC RESERVED      */
; 503  :     /*  003C  60 Signed     4 RDCMCYL32  NUMBER OF PRIMARY CYLINDERS */
; 504  :     /*                                                               */
; 505  :     /*---------------------------------------------------------------*/
; 506  : 
; 507  :     store_fw( devchar+60, cyls - altcyls );     // Primary cylinders

  00560	8b 44 24 20	 mov	 eax, DWORD PTR altcyls$[rsp]
  00564	8b 4c 24 58	 mov	 ecx, DWORD PTR cyls$[rsp]
  00568	2b c8		 sub	 ecx, eax
  0056a	8b c1		 mov	 eax, ecx
  0056c	8b c8		 mov	 ecx, eax
  0056e	e8 00 00 00 00	 call	 _byteswap_ulong
  00573	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devchar$[rsp]
  00578	48 83 c1 3c	 add	 rcx, 60			; 0000003cH
  0057c	8b d0		 mov	 edx, eax
  0057e	e8 00 00 00 00	 call	 store_fw_noswap

; 508  : 
; 509  :     return 64;

  00583	b8 40 00 00 00	 mov	 eax, 64			; 00000040H

; 510  : }

  00588	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0058c	5f		 pop	 rdi
  0058d	c3		 ret	 0
dasd_build_ckd_devchar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdtab.c
_TEXT	SEGMENT
len$ = 32
ckd$ = 64
cu$ = 72
devid$ = 80
dasd_build_ckd_devid PROC

; 347  : {

$LN21:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 348  : int len;
; 349  : 
; 350  :     memset( devid, 0, 256 );

  00014	48 8b 7c 24 50	 mov	 rdi, QWORD PTR devid$[rsp]
  00019	33 c0		 xor	 eax, eax
  0001b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00020	f3 aa		 rep stosb

; 351  : 
; 352  :     store_fw (devid + 0, 0xFF000000 | (cu->devt << 8) | cu->model);

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  00027	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0002b	c1 e0 08	 shl	 eax, 8
  0002e	0d 00 00 00 ff	 or	 eax, -16777216		; ff000000H
  00033	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cu$[rsp]
  00038	0f b6 49 0a	 movzx	 ecx, BYTE PTR [rcx+10]
  0003c	0b c1		 or	 eax, ecx
  0003e	8b c8		 mov	 ecx, eax
  00040	e8 00 00 00 00	 call	 _byteswap_ulong
  00045	8b d0		 mov	 edx, eax
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  0004c	e8 00 00 00 00	 call	 store_fw_noswap

; 353  :     store_fw (devid + 4, (ckd->devt << 16) | (ckd->model << 8) | 0x00);

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  00056	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0005a	c1 e0 10	 shl	 eax, 16
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ckd$[rsp]
  00062	0f b6 49 0a	 movzx	 ecx, BYTE PTR [rcx+10]
  00066	c1 e1 08	 shl	 ecx, 8
  00069	0b c1		 or	 eax, ecx
  0006b	8b c8		 mov	 ecx, eax
  0006d	e8 00 00 00 00	 call	 _byteswap_ulong
  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  00077	48 83 c1 04	 add	 rcx, 4
  0007b	8b d0		 mov	 edx, eax
  0007d	e8 00 00 00 00	 call	 store_fw_noswap

; 354  :     store_fw (devid + 8, cu->ciw1);

  00082	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  00087	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  0008a	e8 00 00 00 00	 call	 _byteswap_ulong
  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  00094	48 83 c1 08	 add	 rcx, 8
  00098	8b d0		 mov	 edx, eax
  0009a	e8 00 00 00 00	 call	 store_fw_noswap

; 355  :     store_fw (devid +12, cu->ciw2);

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  000a4	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000a7	e8 00 00 00 00	 call	 _byteswap_ulong
  000ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  000b1	48 83 c1 0c	 add	 rcx, 12
  000b5	8b d0		 mov	 edx, eax
  000b7	e8 00 00 00 00	 call	 store_fw_noswap

; 356  :     store_fw (devid +16, cu->ciw3);

  000bc	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  000c1	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  000c4	e8 00 00 00 00	 call	 _byteswap_ulong
  000c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  000ce	48 83 c1 10	 add	 rcx, 16
  000d2	8b d0		 mov	 edx, eax
  000d4	e8 00 00 00 00	 call	 store_fw_noswap

; 357  :     store_fw (devid +20, cu->ciw4);

  000d9	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  000de	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  000e1	e8 00 00 00 00	 call	 _byteswap_ulong
  000e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  000eb	48 83 c1 14	 add	 rcx, 20
  000ef	8b d0		 mov	 edx, eax
  000f1	e8 00 00 00 00	 call	 store_fw_noswap

; 358  :     store_fw (devid +24, cu->ciw5);

  000f6	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  000fb	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  000fe	e8 00 00 00 00	 call	 _byteswap_ulong
  00103	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  00108	48 83 c1 18	 add	 rcx, 24
  0010c	8b d0		 mov	 edx, eax
  0010e	e8 00 00 00 00	 call	 store_fw_noswap

; 359  :     store_fw (devid +28, cu->ciw6);

  00113	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  00118	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0011b	e8 00 00 00 00	 call	 _byteswap_ulong
  00120	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  00125	48 83 c1 1c	 add	 rcx, 28
  00129	8b d0		 mov	 edx, eax
  0012b	e8 00 00 00 00	 call	 store_fw_noswap

; 360  :     store_fw (devid +32, cu->ciw7);

  00130	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  00135	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  00138	e8 00 00 00 00	 call	 _byteswap_ulong
  0013d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  00142	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00146	8b d0		 mov	 edx, eax
  00148	e8 00 00 00 00	 call	 store_fw_noswap

; 361  :     store_fw (devid +36, cu->ciw8);

  0014d	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  00152	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00155	e8 00 00 00 00	 call	 _byteswap_ulong
  0015a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR devid$[rsp]
  0015f	48 83 c1 24	 add	 rcx, 36			; 00000024H
  00163	8b d0		 mov	 edx, eax
  00165	e8 00 00 00 00	 call	 store_fw_noswap

; 362  : 
; 363  :     /* Set length */
; 364  :     if (cu->ciw8 != 0) len = 40;

  0016a	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  0016f	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00173	74 0d		 je	 SHORT $LN2@dasd_build
  00175	c7 44 24 20 28
	00 00 00	 mov	 DWORD PTR len$[rsp], 40	; 00000028H
  0017d	e9 9e 00 00 00	 jmp	 $LN3@dasd_build
$LN2@dasd_build:

; 365  :     else if (cu->ciw7 != 0) len = 36;

  00182	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  00187	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0018b	74 0d		 je	 SHORT $LN4@dasd_build
  0018d	c7 44 24 20 24
	00 00 00	 mov	 DWORD PTR len$[rsp], 36	; 00000024H
  00195	e9 86 00 00 00	 jmp	 $LN5@dasd_build
$LN4@dasd_build:

; 366  :     else if (cu->ciw6 != 0) len = 32;

  0019a	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  0019f	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  001a3	74 0a		 je	 SHORT $LN6@dasd_build
  001a5	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR len$[rsp], 32	; 00000020H
  001ad	eb 71		 jmp	 SHORT $LN7@dasd_build
$LN6@dasd_build:

; 367  :     else if (cu->ciw5 != 0) len = 28;

  001af	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  001b4	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  001b8	74 0a		 je	 SHORT $LN8@dasd_build
  001ba	c7 44 24 20 1c
	00 00 00	 mov	 DWORD PTR len$[rsp], 28
  001c2	eb 5c		 jmp	 SHORT $LN9@dasd_build
$LN8@dasd_build:

; 368  :     else if (cu->ciw4 != 0) len = 24;

  001c4	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  001c9	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  001cd	74 0a		 je	 SHORT $LN10@dasd_build
  001cf	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR len$[rsp], 24
  001d7	eb 47		 jmp	 SHORT $LN11@dasd_build
$LN10@dasd_build:

; 369  :     else if (cu->ciw3 != 0) len = 20;

  001d9	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  001de	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  001e2	74 0a		 je	 SHORT $LN12@dasd_build
  001e4	c7 44 24 20 14
	00 00 00	 mov	 DWORD PTR len$[rsp], 20
  001ec	eb 32		 jmp	 SHORT $LN13@dasd_build
$LN12@dasd_build:

; 370  :     else if (cu->ciw2 != 0) len = 16;

  001ee	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  001f3	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001f7	74 0a		 je	 SHORT $LN14@dasd_build
  001f9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR len$[rsp], 16
  00201	eb 1d		 jmp	 SHORT $LN15@dasd_build
$LN14@dasd_build:

; 371  :     else if (cu->ciw1 != 0) len = 12;

  00203	48 8b 44 24 48	 mov	 rax, QWORD PTR cu$[rsp]
  00208	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0020c	74 0a		 je	 SHORT $LN16@dasd_build
  0020e	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR len$[rsp], 12
  00216	eb 08		 jmp	 SHORT $LN17@dasd_build
$LN16@dasd_build:

; 372  :     else len = 7;

  00218	c7 44 24 20 07
	00 00 00	 mov	 DWORD PTR len$[rsp], 7
$LN17@dasd_build:
$LN15@dasd_build:
$LN13@dasd_build:
$LN11@dasd_build:
$LN9@dasd_build:
$LN7@dasd_build:
$LN5@dasd_build:
$LN3@dasd_build:

; 373  : 
; 374  :     /* If LEGACYSENSEID ENABLE is not set and device is a 2311
; 375  :        or 2314, set devid length to zero to force command reject
; 376  :        response to 0xE4 Sense ID command */
; 377  :     if (1
; 378  :         && !sysblk.legacysenseid
; 379  :         && (0

  00220	33 c0		 xor	 eax, eax
  00222	83 f8 01	 cmp	 eax, 1
  00225	74 45		 je	 SHORT $LN18@dasd_build
  00227	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0022e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00234	c1 e8 14	 shr	 eax, 20
  00237	83 e0 01	 and	 eax, 1
  0023a	85 c0		 test	 eax, eax
  0023c	75 2e		 jne	 SHORT $LN18@dasd_build
  0023e	33 c0		 xor	 eax, eax
  00240	85 c0		 test	 eax, eax
  00242	75 20		 jne	 SHORT $LN19@dasd_build
  00244	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  00249	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0024d	3d 11 23 00 00	 cmp	 eax, 8977		; 00002311H
  00252	74 10		 je	 SHORT $LN19@dasd_build
  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR ckd$[rsp]
  00259	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0025d	3d 14 23 00 00	 cmp	 eax, 8980		; 00002314H
  00262	75 08		 jne	 SHORT $LN18@dasd_build
$LN19@dasd_build:

; 380  :             || 0x2311 == ckd->devt
; 381  :             || 0x2314 == ckd->devt
; 382  :            )
; 383  :         )
; 384  :     {
; 385  :       len = 0;

  00264	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN18@dasd_build:

; 386  :     }
; 387  : 
; 388  :     return len;

  0026c	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]

; 389  : }

  00270	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00274	5f		 pop	 rdi
  00275	c3		 ret	 0
dasd_build_ckd_devid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdtab.c
_TEXT	SEGMENT
i$ = 32
tv64 = 36
dtype$ = 64
name$ = 72
devt$ = 80
size$ = 88
dasd_lookup PROC

; 292  : {

$LN37:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 293  : U32 i;                                  /* Loop Index                */
; 294  : 
; 295  :     switch (dtype) {

  00017	8b 44 24 40	 mov	 eax, DWORD PTR dtype$[rsp]
  0001b	89 44 24 24	 mov	 DWORD PTR tv64[rsp], eax
  0001f	83 7c 24 24 01	 cmp	 DWORD PTR tv64[rsp], 1
  00024	74 26		 je	 SHORT $LN16@dasd_looku
  00026	83 7c 24 24 02	 cmp	 DWORD PTR tv64[rsp], 2
  0002b	0f 84 f2 00 00
	00		 je	 $LN21@dasd_looku
  00031	83 7c 24 24 03	 cmp	 DWORD PTR tv64[rsp], 3
  00036	0f 84 68 01 00
	00		 je	 $LN25@dasd_looku
  0003c	83 7c 24 24 04	 cmp	 DWORD PTR tv64[rsp], 4
  00041	0f 84 33 02 00
	00		 je	 $LN31@dasd_looku
  00047	e9 cb 02 00 00	 jmp	 $LN35@dasd_looku
$LN16@dasd_looku:

; 296  : 
; 297  :     case DASD_CKDDEV:
; 298  :         for (i = 0; i < (int)CKDDEV_NUM; i++)

  0004c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00054	eb 0a		 jmp	 SHORT $LN6@dasd_looku
$LN4@dasd_looku:
  00056	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0005a	ff c0		 inc	 eax
  0005c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN6@dasd_looku:
  00060	83 7c 24 20 36	 cmp	 DWORD PTR i$[rsp], 54	; 00000036H
  00065	0f 83 b1 00 00
	00		 jae	 $LN5@dasd_looku

; 299  :         {
; 300  :             if ((name && !strcmp(name, ckdtab[i].name))
; 301  :              || (((U32)devt == (U32)ckdtab[i].devt || (U32)devt == (U32)(ckdtab[i].devt & 0xff))

  0006b	48 83 7c 24 48
	00		 cmp	 QWORD PTR name$[rsp], 0
  00071	74 21		 je	 SHORT $LN19@dasd_looku
  00073	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00077	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckdtab
  00082	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00086	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  0008b	e8 00 00 00 00	 call	 strcmp
  00090	85 c0		 test	 eax, eax
  00092	74 69		 je	 SHORT $LN18@dasd_looku
$LN19@dasd_looku:
  00094	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00098	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckdtab
  000a3	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  000a8	39 44 24 50	 cmp	 DWORD PTR devt$[rsp], eax
  000ac	74 1f		 je	 SHORT $LN20@dasd_looku
  000ae	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000b2	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckdtab
  000bd	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  000c2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c7	39 44 24 50	 cmp	 DWORD PTR devt$[rsp], eax
  000cb	75 4a		 jne	 SHORT $LN17@dasd_looku
$LN20@dasd_looku:
  000cd	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000d1	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckdtab
  000dc	0f b7 44 01 0e	 movzx	 eax, WORD PTR [rcx+rax+14]
  000e1	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000e5	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ckdtab
  000f0	0f b7 4c 0a 10	 movzx	 ecx, WORD PTR [rdx+rcx+16]
  000f5	03 c1		 add	 eax, ecx
  000f7	39 44 24 58	 cmp	 DWORD PTR size$[rsp], eax
  000fb	77 1a		 ja	 SHORT $LN17@dasd_looku
$LN18@dasd_looku:

; 302  :               && (U32)size <= (U32)(ckdtab[i].cyls + ckdtab[i].altcyls)))
; 303  :                 return &ckdtab[i];

  000fd	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00101	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckdtab
  0010c	48 03 c8	 add	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	e9 02 02 00 00	 jmp	 $LN1@dasd_looku
$LN17@dasd_looku:

; 304  :         }

  00117	e9 3a ff ff ff	 jmp	 $LN4@dasd_looku
$LN5@dasd_looku:

; 305  :         return NULL;

  0011c	33 c0		 xor	 eax, eax
  0011e	e9 f6 01 00 00	 jmp	 $LN1@dasd_looku
$LN21@dasd_looku:

; 306  : 
; 307  :     case DASD_CKDCU:
; 308  :         for (i = 0; i < (int)CKDCU_NUM; i++)

  00123	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012b	eb 0a		 jmp	 SHORT $LN9@dasd_looku
$LN7@dasd_looku:
  0012d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00131	ff c0		 inc	 eax
  00133	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN9@dasd_looku:
  00137	83 7c 24 20 09	 cmp	 DWORD PTR i$[rsp], 9
  0013c	73 5f		 jae	 SHORT $LN8@dasd_looku

; 309  :         {
; 310  :             if ((name != NULL && strcmp(name, ckdcutab[i].name) == 0)
; 311  :              || devt == ckdcutab[i].devt)

  0013e	48 83 7c 24 48
	00		 cmp	 QWORD PTR name$[rsp], 0
  00144	74 21		 je	 SHORT $LN24@dasd_looku
  00146	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0014a	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckdcutab
  00155	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00159	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  0015e	e8 00 00 00 00	 call	 strcmp
  00163	85 c0		 test	 eax, eax
  00165	74 1a		 je	 SHORT $LN23@dasd_looku
$LN24@dasd_looku:
  00167	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0016b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0016f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckdcutab
  00176	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  0017b	39 44 24 50	 cmp	 DWORD PTR devt$[rsp], eax
  0017f	75 1a		 jne	 SHORT $LN22@dasd_looku
$LN23@dasd_looku:

; 312  :                 return &ckdcutab[i];

  00181	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00185	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckdcutab
  00190	48 03 c8	 add	 rcx, rax
  00193	48 8b c1	 mov	 rax, rcx
  00196	e9 7e 01 00 00	 jmp	 $LN1@dasd_looku
$LN22@dasd_looku:

; 313  :         }

  0019b	eb 90		 jmp	 SHORT $LN7@dasd_looku
$LN8@dasd_looku:

; 314  :         return NULL;

  0019d	33 c0		 xor	 eax, eax
  0019f	e9 75 01 00 00	 jmp	 $LN1@dasd_looku
$LN25@dasd_looku:

; 315  : 
; 316  :     case DASD_FBADEV:
; 317  :         for (i = 0; i < (int)FBADEV_NUM; i++)

  001a4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ac	eb 0a		 jmp	 SHORT $LN12@dasd_looku
$LN10@dasd_looku:
  001ae	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001b2	ff c0		 inc	 eax
  001b4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN12@dasd_looku:
  001b8	83 7c 24 20 1c	 cmp	 DWORD PTR i$[rsp], 28
  001bd	0f 83 b0 00 00
	00		 jae	 $LN11@dasd_looku

; 318  :         {
; 319  :             if ((name && !strcmp(name, fbatab[i].name))
; 320  :              || (((U32)devt == (U32)fbatab[i].devt || (U32)devt == (U32)(fbatab[i].devt & 0xff))

  001c3	48 83 7c 24 48
	00		 cmp	 QWORD PTR name$[rsp], 0
  001c9	74 21		 je	 SHORT $LN28@dasd_looku
  001cb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001cf	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fbatab
  001da	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  001de	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  001e3	e8 00 00 00 00	 call	 strcmp
  001e8	85 c0		 test	 eax, eax
  001ea	74 68		 je	 SHORT $LN27@dasd_looku
$LN28@dasd_looku:
  001ec	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001f0	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fbatab
  001fb	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  00200	39 44 24 50	 cmp	 DWORD PTR devt$[rsp], eax
  00204	74 1f		 je	 SHORT $LN29@dasd_looku
  00206	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0020a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fbatab
  00215	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  0021a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021f	39 44 24 50	 cmp	 DWORD PTR devt$[rsp], eax
  00223	75 49		 jne	 SHORT $LN26@dasd_looku
$LN29@dasd_looku:
  00225	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00229	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fbatab
  00234	8b 44 01 1c	 mov	 eax, DWORD PTR [rcx+rax+28]
  00238	39 44 24 58	 cmp	 DWORD PTR size$[rsp], eax
  0023c	76 16		 jbe	 SHORT $LN30@dasd_looku
  0023e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00242	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fbatab
  0024d	83 7c 01 1c 00	 cmp	 DWORD PTR [rcx+rax+28], 0
  00252	75 1a		 jne	 SHORT $LN26@dasd_looku
$LN30@dasd_looku:
$LN27@dasd_looku:

; 321  :               && ((size <= fbatab[i].blks) || (fbatab[i].blks == 0))))
; 322  :                 return &fbatab[i];

  00254	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00258	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fbatab
  00263	48 03 c8	 add	 rcx, rax
  00266	48 8b c1	 mov	 rax, rcx
  00269	e9 ab 00 00 00	 jmp	 $LN1@dasd_looku
$LN26@dasd_looku:

; 323  :         }

  0026e	e9 3b ff ff ff	 jmp	 $LN10@dasd_looku
$LN11@dasd_looku:

; 324  :         return NULL;

  00273	33 c0		 xor	 eax, eax
  00275	e9 9f 00 00 00	 jmp	 $LN1@dasd_looku
$LN31@dasd_looku:

; 325  : #if defined(FEATURE_VM_BLOCKIO)
; 326  :     case DASD_STDBLK:
; 327  :         for (i = 0; i < (int)BLKTAB_NUM; i++)

  0027a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00282	eb 0a		 jmp	 SHORT $LN15@dasd_looku
$LN13@dasd_looku:
  00284	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00288	ff c0		 inc	 eax
  0028a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN15@dasd_looku:
  0028e	83 7c 24 20 06	 cmp	 DWORD PTR i$[rsp], 6
  00293	73 7e		 jae	 SHORT $LN14@dasd_looku

; 328  :         {
; 329  :             if ((name && !strcmp(name, blktab[i].name)) ||
; 330  :                 (U32)devt == (U32)blktab[i].devt ||

  00295	48 83 7c 24 48
	00		 cmp	 QWORD PTR name$[rsp], 0
  0029b	74 21		 je	 SHORT $LN34@dasd_looku
  0029d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002a1	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:blktab
  002ac	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  002b5	e8 00 00 00 00	 call	 strcmp
  002ba	85 c0		 test	 eax, eax
  002bc	74 39		 je	 SHORT $LN33@dasd_looku
$LN34@dasd_looku:
  002be	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002c2	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:blktab
  002cd	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  002d2	39 44 24 50	 cmp	 DWORD PTR devt$[rsp], eax
  002d6	74 1f		 je	 SHORT $LN33@dasd_looku
  002d8	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002dc	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:blktab
  002e7	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  002ec	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002f1	39 44 24 50	 cmp	 DWORD PTR devt$[rsp], eax
  002f5	75 17		 jne	 SHORT $LN32@dasd_looku
$LN33@dasd_looku:

; 331  :                 (U32)devt == (U32)(blktab[i].devt & 0xff))
; 332  :                 return &blktab[i];

  002f7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002fb	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:blktab
  00306	48 03 c8	 add	 rcx, rax
  00309	48 8b c1	 mov	 rax, rcx
  0030c	eb 0b		 jmp	 SHORT $LN1@dasd_looku
$LN32@dasd_looku:

; 333  :         }

  0030e	e9 71 ff ff ff	 jmp	 $LN13@dasd_looku
$LN14@dasd_looku:

; 334  :         return NULL;

  00313	33 c0		 xor	 eax, eax
  00315	eb 02		 jmp	 SHORT $LN1@dasd_looku
$LN35@dasd_looku:

; 335  : #endif /* defined(FEATURE_VM_BLOCKIO) */
; 336  :     default:
; 337  :         return NULL;

  00317	33 c0		 xor	 eax, eax
$LN1@dasd_looku:

; 338  :     }
; 339  : 
; 340  :     UNREACHABLE_CODE( return NULL );
; 341  : }

  00319	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0031d	c3		 ret	 0
dasd_lookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
