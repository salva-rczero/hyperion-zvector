; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG159052 DB	'No error', 00H
	ORG $+7
$SG159053 DB	'File error', 00H
	ORG $+5
$SG159054 DB	'Tapemark read', 00H
	ORG $+2
$SG159055 DB	'Beginning of tape', 00H
	ORG $+6
$SG159056 DB	'End of tape', 00H
	ORG $+4
$SG159057 DB	'BOR not found', 00H
	ORG $+2
$SG159058 DB	'EOR not found', 00H
	ORG $+2
$SG159059 DB	'Unexpected tapemark', 00H
	ORG $+4
$SG159060 DB	'Buffer not big enough', 00H
	ORG $+2
$SG159061 DB	'Premature EOF', 00H
	ORG $+2
$SG159062 DB	'Decompression error', 00H
	ORG $+4
$SG159063 DB	'Unknown compression method', 00H
	ORG $+5
$SG159064 DB	'Compression error', 00H
	ORG $+6
$SG159065 DB	'Specified length to big', 00H
$SG159066 DB	'Write protected', 00H
$SG159067 DB	'Bad function code passed', 00H
	ORG $+7
$SG159068 DB	'Bad compression method', 00H
	ORG $+1
$SG159069 DB	'Bad compression level', 00H
	ORG $+2
$SG159070 DB	'Bad write chunk size', 00H
	ORG $+3
$SG159071 DB	'Invalid direction specified', 00H
	ORG $+4
$SG159072 DB	'Insufficient memory', 00H
	ORG $+4
$SG159073 DB	'Couldn''t read block header', 00H
	ORG $+5
$SG159074 DB	'Inconsistent compression flags', 00H
	ORG $+1
$SG159075 DB	'Block is short', 00H
	ORG $+1
$SG159076 DB	'Location error', 00H
	ORG $+1
$SG159077 DB	'Invalid error code', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	het_open
PUBLIC	het_close
PUBLIC	het_read_header
PUBLIC	het_read
PUBLIC	het_write_header
PUBLIC	het_write
PUBLIC	het_tapemark
PUBLIC	het_sync
PUBLIC	het_cntl
PUBLIC	het_locate
PUBLIC	het_bsb
PUBLIC	het_fsb
PUBLIC	het_bsf
PUBLIC	het_fsf
PUBLIC	het_rewind
PUBLIC	het_error
PUBLIC	het_tell
EXTRN	__imp__errno:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp__aligned_free:PROC
EXTRN	__imp__aligned_malloc:PROC
EXTRN	__imp__chsize_s:PROC
EXTRN	__imp__commit:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp__ftelli64:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_fdopen:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$het_open DD imagerel $LN19
	DD	imagerel $LN19+862
	DD	imagerel $unwind$het_open
$pdata$het_close DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$het_close
$pdata$het_read_header DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$het_read_header
$pdata$het_read DD imagerel $LN30
	DD	imagerel $LN30+854
	DD	imagerel $unwind$het_read
$pdata$het_write_header DD imagerel $LN12
	DD	imagerel $LN12+514
	DD	imagerel $unwind$het_write_header
$pdata$het_write DD imagerel $LN23
	DD	imagerel $LN23+503
	DD	imagerel $unwind$het_write
$pdata$het_tapemark DD imagerel $LN8
	DD	imagerel $LN8+110
	DD	imagerel $unwind$het_tapemark
$pdata$het_sync DD imagerel $LN8
	DD	imagerel $LN8+77
	DD	imagerel $unwind$het_sync
$pdata$het_cntl DD imagerel $LN26
	DD	imagerel $LN26+509
	DD	imagerel $unwind$het_cntl
$pdata$het_locate DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$het_locate
$pdata$het_bsb DD imagerel $LN14
	DD	imagerel $LN14+536
	DD	imagerel $unwind$het_bsb
$pdata$het_fsb DD imagerel $LN8
	DD	imagerel $LN8+177
	DD	imagerel $unwind$het_fsb
$pdata$het_bsf DD imagerel $LN6
	DD	imagerel $LN6+39
	DD	imagerel $unwind$het_bsf
$pdata$het_fsf DD imagerel $LN7
	DD	imagerel $LN7+56
	DD	imagerel $unwind$het_fsf
$pdata$het_rewind DD imagerel $LN4
	DD	imagerel $LN4+113
	DD	imagerel $unwind$het_rewind
$pdata$het_tell DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$het_tell
pdata	ENDS
_DATA	SEGMENT
	ORG $+13
het_errstr DQ	FLAT:$SG159052
	DQ	FLAT:$SG159053
	DQ	FLAT:$SG159054
	DQ	FLAT:$SG159055
	DQ	FLAT:$SG159056
	DQ	FLAT:$SG159057
	DQ	FLAT:$SG159058
	DQ	FLAT:$SG159059
	DQ	FLAT:$SG159060
	DQ	FLAT:$SG159061
	DQ	FLAT:$SG159062
	DQ	FLAT:$SG159063
	DQ	FLAT:$SG159064
	DQ	FLAT:$SG159065
	DQ	FLAT:$SG159066
	DQ	FLAT:$SG159067
	DQ	FLAT:$SG159068
	DQ	FLAT:$SG159069
	DQ	FLAT:$SG159070
	DQ	FLAT:$SG159071
	DQ	FLAT:$SG159072
	DQ	FLAT:$SG159073
	DQ	FLAT:$SG159074
	DQ	FLAT:$SG159075
	DQ	FLAT:$SG159076
	DQ	FLAT:$SG159077
$SG159102 DB	'r+b', 00H
$SG159107 DB	'rb', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:het_open
	DD	020H
	DD	0346H
voltbl	ENDS
xdata	SEGMENT
$unwind$het_open DD 022819H
	DD	02d0116H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$het_close DD 010901H
	DD	04209H
$unwind$het_read_header DD 010901H
	DD	06209H
$unwind$het_read DD 010e01H
	DD	0a20eH
$unwind$het_write_header DD 011701H
	DD	06217H
$unwind$het_write DD 011301H
	DD	08213H
$unwind$het_tapemark DD 010901H
	DD	06209H
$unwind$het_sync DD 010901H
	DD	06209H
$unwind$het_cntl DD 011201H
	DD	02212H
$unwind$het_locate DD 010d01H
	DD	0620dH
$unwind$het_bsb DD 010901H
	DD	06209H
$unwind$het_fsb DD 010901H
	DD	06209H
$unwind$het_bsf DD 010901H
	DD	06209H
$unwind$het_fsf DD 010901H
	DD	06209H
$unwind$het_rewind DD 020a01H
	DD	07006520aH
$unwind$het_tell DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rwptr$ = 32
hetb$ = 64
het_tell PROC

; 2427 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2428 :     off_t rwptr = ftell( hetb->fh );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0000e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  00017	48 89 44 24 20	 mov	 QWORD PTR rwptr$[rsp], rax

; 2429 :     if ( rwptr < 0 )

  0001c	48 83 7c 24 20
	00		 cmp	 QWORD PTR rwptr$[rsp], 0
  00022	7d 09		 jge	 SHORT $LN2@het_tell

; 2430 :     {
; 2431 :         return HETE_ERROR;

  00024	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0002b	eb 05		 jmp	 SHORT $LN1@het_tell
$LN2@het_tell:

; 2432 :     }
; 2433 :     return rwptr;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR rwptr$[rsp]
$LN1@het_tell:

; 2434 : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
het_tell ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 8
het_error PROC

; 2340 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 2341 :     /*
; 2342 :     || If not an error just return the "OK" string
; 2343 :     */
; 2344 :     if( rc >= 0 )

  00004	83 7c 24 08 00	 cmp	 DWORD PTR rc$[rsp], 0
  00009	7c 08		 jl	 SHORT $LN2@het_error

; 2345 :     {
; 2346 :         rc = 0;

  0000b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN2@het_error:

; 2347 :     }
; 2348 : 
; 2349 :     /*
; 2350 :     || Turn it into an index
; 2351 :     */
; 2352 :     rc = -rc;

  00013	8b 44 24 08	 mov	 eax, DWORD PTR rc$[rsp]
  00017	f7 d8		 neg	 eax
  00019	89 44 24 08	 mov	 DWORD PTR rc$[rsp], eax

; 2353 : 
; 2354 :     /*
; 2355 :     || Within range?
; 2356 :     */
; 2357 :     if( rc >= (int)HET_ERRSTR_MAX )

  0001d	83 7c 24 08 1a	 cmp	 DWORD PTR rc$[rsp], 26
  00022	7c 08		 jl	 SHORT $LN3@het_error

; 2358 :     {
; 2359 :         rc = HET_ERRSTR_MAX - 1;

  00024	c7 44 24 08 19
	00 00 00	 mov	 DWORD PTR rc$[rsp], 25
$LN3@het_error:

; 2360 :     }
; 2361 : 
; 2362 :     /*
; 2363 :     || Return string
; 2364 :     */
; 2365 :     return( het_errstr[ rc ] );

  0002c	48 63 44 24 08	 movsxd	 rax, DWORD PTR rc$[rsp]
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:het_errstr
  00038	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 2366 : }

  0003c	c3		 ret	 0
het_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
hetb$ = 64
het_rewind PROC

; 2266 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2267 :     int rc;
; 2268 : 
; 2269 :     /*
; 2270 :     || Just seek to the beginning of the file
; 2271 :     */
; 2272 :     rc = fseek( hetb->fh,

  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	33 d2		 xor	 edx, edx
  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00014	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0001d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2273 :                 0,
; 2274 :                 SEEK_SET );
; 2275 :     if( rc == -1 )

  00021	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  00026	75 07		 jne	 SHORT $LN2@het_rewind

; 2276 :     {
; 2277 :         return( HETE_ERROR );

  00028	b8 ff ff ff ff	 mov	 eax, -1
  0002d	eb 3c		 jmp	 SHORT $LN1@het_rewind
$LN2@het_rewind:

; 2278 :     }
; 2279 : 
; 2280 :     /*
; 2281 :     || Reset current block
; 2282 :     */
; 2283 :     hetb->cblk = 0;

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00034	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 2284 : 
; 2285 :     /*
; 2286 :     || Clear header for the heck of it
; 2287 :     */
; 2288 :     memset( &hetb->chdr, 0, sizeof( hetb->chdr ) );

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00040	48 83 c0 1c	 add	 rax, 28
  00044	48 8b f8	 mov	 rdi, rax
  00047	33 c0		 xor	 eax, eax
  00049	b9 06 00 00 00	 mov	 ecx, 6
  0004e	f3 aa		 rep stosb

; 2289 : 
; 2290 :     /*
; 2291 :     || Reset flag to force truncation if a write occurs
; 2292 :     */
; 2293 :     hetb->truncated = FALSE;

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00055	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00058	83 e0 fb	 and	 eax, -5			; fffffffbH
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00060	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2294 : 
; 2295 :     /*
; 2296 :     || Return block number
; 2297 :     */
; 2298 :     return( hetb->cblk );

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00068	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
$LN1@het_rewind:

; 2299 : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
het_rewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
hetb$ = 64
het_fsf	PROC

; 2178 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@het_fsf:

; 2179 :     int rc;
; 2180 : 
; 2181 :     /*
; 2182 :     || Forward space until we hit a tapemark
; 2183 :     */
; 2184 :     do
; 2185 :     {
; 2186 :         rc = het_fsb( hetb );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  0000e	e8 00 00 00 00	 call	 het_fsb
  00013	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2187 :     }
; 2188 :     while( rc >= 0 );

  00017	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0001c	7d eb		 jge	 SHORT $LN4@het_fsf

; 2189 : 
; 2190 :     /*
; 2191 :     || Success
; 2192 :     */
; 2193 :     if( rc == HETE_TAPEMARK )

  0001e	83 7c 24 20 fe	 cmp	 DWORD PTR rc$[rsp], -2
  00023	75 0a		 jne	 SHORT $LN5@het_fsf

; 2194 :     {
; 2195 :         return( hetb->cblk );

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0002a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002d	eb 04		 jmp	 SHORT $LN1@het_fsf
$LN5@het_fsf:

; 2196 :     }
; 2197 : 
; 2198 :     /*
; 2199 :     || Failure
; 2200 :     */
; 2201 :     return( rc );

  0002f	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@het_fsf:

; 2202 : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	c3		 ret	 0
het_fsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
hetb$ = 64
het_bsf	PROC

; 2098 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@het_bsf:

; 2099 :     int rc;
; 2100 : 
; 2101 :     /*
; 2102 :     || Backspace block until we either BSB over a tapemark or reach BOT
; 2103 :     */
; 2104 :     do
; 2105 :     {
; 2106 :         rc = het_bsb( hetb );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  0000e	e8 00 00 00 00	 call	 het_bsb
  00013	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2107 :     }
; 2108 :     while( rc >= 0 );

  00017	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0001c	7d eb		 jge	 SHORT $LN4@het_bsf

; 2109 : 
; 2110 :     /*
; 2111 :     || Success or Failure.  Note: HETE_TAPEMARK is a negative value but
; 2112 :     || should be treated by the caller as success.
; 2113 :     */
; 2114 :     return( rc );

  0001e	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 2115 : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
het_bsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
hetb$ = 64
het_fsb	PROC

; 1993 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@het_fsb:

; 1994 :     int rc;
; 1995 : 
; 1996 :     /*
; 1997 :     || Loop until we've processed an entire block
; 1998 :     */
; 1999 :     do
; 2000 :     {
; 2001 :         /*
; 2002 :         || Read header to get length of next chunk
; 2003 :         */
; 2004 :         rc = het_read_header( hetb );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  0000e	e8 00 00 00 00	 call	 het_read_header
  00013	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2005 :         if( rc < 0 )

  00017	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0001c	7d 09		 jge	 SHORT $LN5@het_fsb

; 2006 :         {
; 2007 :             return( rc );

  0001e	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00022	e9 85 00 00 00	 jmp	 $LN1@het_fsb
$LN5@het_fsb:

; 2008 :         }
; 2009 : 
; 2010 :         /*
; 2011 :         || Seek to next chunk
; 2012 :         */
; 2013 :         rc = fseek( hetb->fh,

  00027	b8 01 00 00 00	 mov	 eax, 1
  0002c	48 6b c0 01	 imul	 rax, rax, 1
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00035	0f b6 44 01 1c	 movzx	 eax, BYTE PTR [rcx+rax+28]
  0003a	c1 e0 08	 shl	 eax, 8
  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	48 6b c9 00	 imul	 rcx, rcx, 0
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR hetb$[rsp]
  0004b	0f b6 4c 0a 1c	 movzx	 ecx, BYTE PTR [rdx+rcx+28]
  00050	03 c1		 add	 eax, ecx
  00052	48 98		 cdqe
  00054	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005a	48 8b d0	 mov	 rdx, rax
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00062	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0006b	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2014 :                     HETHDR_CLEN( hetb ),
; 2015 :                     SEEK_CUR );
; 2016 :         if( rc == -1 )

  0006f	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  00074	75 07		 jne	 SHORT $LN6@het_fsb

; 2017 :         {
; 2018 :             return( HETE_ERROR );

  00076	b8 ff ff ff ff	 mov	 eax, -1
  0007b	eb 2f		 jmp	 SHORT $LN1@het_fsb
$LN6@het_fsb:

; 2019 :         }
; 2020 :     }
; 2021 :     while( !( hetb->chdr.flags1 & HETHDR_FLAGS1_EOR ) );

  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00082	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00086	83 e0 20	 and	 eax, 32			; 00000020H
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 78 ff ff
	ff		 je	 $LN4@het_fsb

; 2022 : 
; 2023 :     /*
; 2024 :     || Reset flag to force truncation if a write occurs
; 2025 :     */
; 2026 :     hetb->truncated = FALSE;

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00096	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00099	83 e0 fb	 and	 eax, -5			; fffffffbH
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  000a1	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2027 : 
; 2028 :     /*
; 2029 :     || Return block number
; 2030 :     */
; 2031 :     return( hetb->cblk );

  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  000a9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
$LN1@het_fsb:

; 2032 : }

  000ac	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b0	c3		 ret	 0
het_fsb	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
offset$ = 36
newblk$ = 40
tapemark$ = 44
hetb$ = 64
het_bsb	PROC

; 1800 : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1801 :     int rc;
; 1802 :     int newblk;
; 1803 :     int offset;     // (note: safe to use 'int' as offset here
; 1804 :                     //  since we only ever seek from SEEK_CUR)
; 1805 :     int tapemark = FALSE;

  00009	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tapemark$[rsp], 0

; 1806 : 
; 1807 :     /*
; 1808 :     || Error if at BOT
; 1809 :     */
; 1810 :     if( hetb->cblk == 0 )

  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00016	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0001a	75 0a		 jne	 SHORT $LN5@het_bsb

; 1811 :     {
; 1812 :         return( HETE_BOT );

  0001c	b8 fd ff ff ff	 mov	 eax, -3
  00021	e9 ed 01 00 00	 jmp	 $LN1@het_bsb
$LN5@het_bsb:

; 1813 :     }
; 1814 : 
; 1815 :     /*
; 1816 :     || Get new block number
; 1817 :     */
; 1818 :     newblk = hetb->cblk - 1;

  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0002b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002e	ff c8		 dec	 eax
  00030	89 44 24 28	 mov	 DWORD PTR newblk$[rsp], eax

; 1819 : 
; 1820 :     /*
; 1821 :     || If new block is first on, then just rewind
; 1822 :     */
; 1823 :     if( newblk == 0 )

  00034	83 7c 24 28 00	 cmp	 DWORD PTR newblk$[rsp], 0
  00039	75 0f		 jne	 SHORT $LN6@het_bsb

; 1824 :     {
; 1825 :         return( het_rewind( hetb ) );

  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00040	e8 00 00 00 00	 call	 het_rewind
  00045	e9 c9 01 00 00	 jmp	 $LN1@het_bsb
$LN6@het_bsb:

; 1826 :     }
; 1827 : 
; 1828 :     /*
; 1829 :     || Calculate offset to get back to beginning of current block
; 1830 :     */
; 1831 :     offset = -((int)( HETHDR_CLEN( hetb ) + sizeof( HETHDR ) ));

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	48 6b c0 01	 imul	 rax, rax, 1
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00058	0f b6 44 01 1c	 movzx	 eax, BYTE PTR [rcx+rax+28]
  0005d	c1 e0 08	 shl	 eax, 8
  00060	b9 01 00 00 00	 mov	 ecx, 1
  00065	48 6b c9 00	 imul	 rcx, rcx, 0
  00069	48 8b 54 24 40	 mov	 rdx, QWORD PTR hetb$[rsp]
  0006e	0f b6 4c 0a 1c	 movzx	 ecx, BYTE PTR [rdx+rcx+28]
  00073	03 c1		 add	 eax, ecx
  00075	48 98		 cdqe
  00077	48 83 c0 06	 add	 rax, 6
  0007b	f7 d8		 neg	 eax
  0007d	89 44 24 24	 mov	 DWORD PTR offset$[rsp], eax
$LN4@het_bsb:

; 1832 : 
; 1833 :     /*
; 1834 :     || Search backwards an entire block.  If the block is a tapemark, we can't
; 1835 :     || just return to caller since we must load the chunk header preceding it
; 1836 :     || to maintain the chdr in the HET.
; 1837 :     */
; 1838 :     do
; 1839 :     {
; 1840 :         /*
; 1841 :         || Reposition to start of chunk
; 1842 :         */
; 1843 :         rc = fseek( hetb->fh,

  00081	48 63 44 24 24	 movsxd	 rax, DWORD PTR offset$[rsp]
  00086	41 b8 01 00 00
	00		 mov	 r8d, 1
  0008c	48 8b d0	 mov	 rdx, rax
  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00094	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0009d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1844 :                     offset,
; 1845 :                     SEEK_CUR );
; 1846 :         if( rc == -1 )

  000a1	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  000a6	75 0a		 jne	 SHORT $LN7@het_bsb

; 1847 :         {
; 1848 :             return( HETE_ERROR );

  000a8	b8 ff ff ff ff	 mov	 eax, -1
  000ad	e9 61 01 00 00	 jmp	 $LN1@het_bsb
$LN7@het_bsb:

; 1849 :         }
; 1850 : 
; 1851 :         /*
; 1852 :         || Read header, ignoring tapemarks
; 1853 :         */
; 1854 :         rc = het_read_header( hetb );

  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  000b7	e8 00 00 00 00	 call	 het_read_header
  000bc	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1855 :         if( rc < 0 && rc != HETE_TAPEMARK )

  000c0	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000c5	7d 10		 jge	 SHORT $LN8@het_bsb
  000c7	83 7c 24 20 fe	 cmp	 DWORD PTR rc$[rsp], -2
  000cc	74 09		 je	 SHORT $LN8@het_bsb

; 1856 :         {
; 1857 :             return( rc );

  000ce	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  000d2	e9 3c 01 00 00	 jmp	 $LN1@het_bsb
$LN8@het_bsb:

; 1858 :         }
; 1859 : 
; 1860 :         /*
; 1861 :         || Recalculate offset
; 1862 :         */
; 1863 :         offset = -((int)( HETHDR_PLEN( hetb ) + ( sizeof( HETHDR ) * 2 ) ));

  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 6b c0 01	 imul	 rax, rax, 1
  000e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  000e5	0f b6 44 01 1e	 movzx	 eax, BYTE PTR [rcx+rax+30]
  000ea	c1 e0 08	 shl	 eax, 8
  000ed	b9 01 00 00 00	 mov	 ecx, 1
  000f2	48 6b c9 00	 imul	 rcx, rcx, 0
  000f6	48 8b 54 24 40	 mov	 rdx, QWORD PTR hetb$[rsp]
  000fb	0f b6 4c 0a 1e	 movzx	 ecx, BYTE PTR [rdx+rcx+30]
  00100	03 c1		 add	 eax, ecx
  00102	48 98		 cdqe
  00104	48 83 c0 0c	 add	 rax, 12
  00108	f7 d8		 neg	 eax
  0010a	89 44 24 24	 mov	 DWORD PTR offset$[rsp], eax

; 1864 :     }
; 1865 :     while( hetb->chdr.flags1 & !( HETHDR_FLAGS1_BOR | HETHDR_FLAGS1_TAPEMARK ) );

  0010e	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00113	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00117	83 e0 00	 and	 eax, 0
  0011a	85 c0		 test	 eax, eax
  0011c	0f 85 5f ff ff
	ff		 jne	 $LN4@het_bsb

; 1866 : 
; 1867 :     /*
; 1868 :     || Remember whether it's a tapemark or not
; 1869 :     */
; 1870 :     tapemark = ( hetb->chdr.flags1 & HETHDR_FLAGS1_TAPEMARK );

  00122	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00127	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0012b	83 e0 40	 and	 eax, 64			; 00000040H
  0012e	89 44 24 2c	 mov	 DWORD PTR tapemark$[rsp], eax

; 1871 : 
; 1872 :     /*
; 1873 :     || Reposition to chunk header preceding this one so we can load keep the
; 1874 :     || chdr in the HET current.
; 1875 :     */
; 1876 :     rc = fseek( hetb->fh,

  00132	48 63 44 24 24	 movsxd	 rax, DWORD PTR offset$[rsp]
  00137	41 b8 01 00 00
	00		 mov	 r8d, 1
  0013d	48 8b d0	 mov	 rdx, rax
  00140	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00145	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0014e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1877 :                 offset,
; 1878 :                 SEEK_CUR );
; 1879 :     if( rc == -1 )

  00152	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  00157	75 0a		 jne	 SHORT $LN9@het_bsb

; 1880 :     {
; 1881 :         return( HETE_ERROR );

  00159	b8 ff ff ff ff	 mov	 eax, -1
  0015e	e9 b0 00 00 00	 jmp	 $LN1@het_bsb
$LN9@het_bsb:

; 1882 :     }
; 1883 : 
; 1884 :     /*
; 1885 :     || Read header (ignore tapemarks)
; 1886 :     */
; 1887 :     rc = het_read_header( hetb );

  00163	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00168	e8 00 00 00 00	 call	 het_read_header
  0016d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1888 :     if( rc < 0 && ( rc != HETE_TAPEMARK ) )

  00171	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00176	7d 10		 jge	 SHORT $LN10@het_bsb
  00178	83 7c 24 20 fe	 cmp	 DWORD PTR rc$[rsp], -2
  0017d	74 09		 je	 SHORT $LN10@het_bsb

; 1889 :     {
; 1890 :         return( rc );

  0017f	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00183	e9 8b 00 00 00	 jmp	 $LN1@het_bsb
$LN10@het_bsb:

; 1891 :     }
; 1892 : 
; 1893 :     /*
; 1894 :     || Finally reposition back to the where we should be
; 1895 :     */
; 1896 :     rc = fseek( hetb->fh,

  00188	b8 01 00 00 00	 mov	 eax, 1
  0018d	48 6b c0 01	 imul	 rax, rax, 1
  00191	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00196	0f b6 44 01 1c	 movzx	 eax, BYTE PTR [rcx+rax+28]
  0019b	c1 e0 08	 shl	 eax, 8
  0019e	b9 01 00 00 00	 mov	 ecx, 1
  001a3	48 6b c9 00	 imul	 rcx, rcx, 0
  001a7	48 8b 54 24 40	 mov	 rdx, QWORD PTR hetb$[rsp]
  001ac	0f b6 4c 0a 1c	 movzx	 ecx, BYTE PTR [rdx+rcx+28]
  001b1	03 c1		 add	 eax, ecx
  001b3	48 98		 cdqe
  001b5	41 b8 01 00 00
	00		 mov	 r8d, 1
  001bb	48 8b d0	 mov	 rdx, rax
  001be	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  001c3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  001cc	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1897 :                 HETHDR_CLEN( hetb ),
; 1898 :                 SEEK_CUR );
; 1899 :     if( rc == -1 )

  001d0	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  001d5	75 07		 jne	 SHORT $LN11@het_bsb

; 1900 :     {
; 1901 :         return( HETE_ERROR );

  001d7	b8 ff ff ff ff	 mov	 eax, -1
  001dc	eb 35		 jmp	 SHORT $LN1@het_bsb
$LN11@het_bsb:

; 1902 :     }
; 1903 : 
; 1904 :     /*
; 1905 :     || Store new block number
; 1906 :     */
; 1907 :     hetb->cblk = newblk;

  001de	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  001e3	8b 4c 24 28	 mov	 ecx, DWORD PTR newblk$[rsp]
  001e7	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 1908 : 
; 1909 :     /*
; 1910 :     || Was it a tapemark?
; 1911 :     */
; 1912 :     if( tapemark )

  001ea	83 7c 24 2c 00	 cmp	 DWORD PTR tapemark$[rsp], 0
  001ef	74 07		 je	 SHORT $LN12@het_bsb

; 1913 :     {
; 1914 :         return( HETE_TAPEMARK );

  001f1	b8 fe ff ff ff	 mov	 eax, -2
  001f6	eb 1b		 jmp	 SHORT $LN1@het_bsb
$LN12@het_bsb:

; 1915 :     }
; 1916 : 
; 1917 :     /*
; 1918 :     || Reset flag to force truncation if a write occurs
; 1919 :     */
; 1920 :     hetb->truncated = FALSE;

  001f8	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  001fd	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00200	83 e0 fb	 and	 eax, -5			; fffffffbH
  00203	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00208	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 1921 : 
; 1922 :     /*
; 1923 :     || Return block number
; 1924 :     */
; 1925 :     return( hetb->cblk );

  0020b	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00210	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
$LN1@het_bsb:

; 1926 : }

  00213	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00217	c3		 ret	 0
het_bsb	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
hetb$ = 64
block$ = 72
het_locate PROC

; 1699 : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1700 :     int rc;
; 1701 : 
; 1702 :     /*
; 1703 :     || Start the search from the beginning
; 1704 :     */
; 1705 :     rc = het_rewind( hetb );

  0000d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00012	e8 00 00 00 00	 call	 het_rewind
  00017	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1706 :     if( rc < 0 )

  0001b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00020	7d 06		 jge	 SHORT $LN4@het_locate

; 1707 :     {
; 1708 :         return( rc );

  00022	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00026	eb 3a		 jmp	 SHORT $LN1@het_locate
$LN4@het_locate:
$LN2@het_locate:

; 1709 :     }
; 1710 : 
; 1711 :     /*
; 1712 :     || Forward space until we reach the desired block
; 1713 :     */
; 1714 :     while( (int)hetb->cblk < block )

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0002d	8b 4c 24 48	 mov	 ecx, DWORD PTR block$[rsp]
  00031	39 48 18	 cmp	 DWORD PTR [rax+24], ecx
  00034	7d 24		 jge	 SHORT $LN3@het_locate

; 1715 :     {
; 1716 :         rc = het_fsb( hetb );

  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  0003b	e8 00 00 00 00	 call	 het_fsb
  00040	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1717 :         if( rc < 0 && HETE_TAPEMARK != rc )

  00044	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00049	7d 0d		 jge	 SHORT $LN5@het_locate
  0004b	83 7c 24 20 fe	 cmp	 DWORD PTR rc$[rsp], -2
  00050	74 06		 je	 SHORT $LN5@het_locate

; 1718 :         {
; 1719 :             return( rc );

  00052	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00056	eb 0a		 jmp	 SHORT $LN1@het_locate
$LN5@het_locate:

; 1720 :         }
; 1721 :     }

  00058	eb ce		 jmp	 SHORT $LN2@het_locate
$LN3@het_locate:

; 1722 : 
; 1723 :     return( hetb->cblk );

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0005f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
$LN1@het_locate:

; 1724 : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
het_locate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
tv66 = 0
mode$ = 4
tv73 = 8
tv85 = 12
hetb$ = 32
func$ = 40
val$ = 48
het_cntl PROC

; 474  : {

$LN26:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 475  :     int mode;
; 476  : 
; 477  :     /*
; 478  :     || Isolate the mode
; 479  :     */
; 480  :     mode = func & HETCNTL_SET;

  00012	8b 44 24 28	 mov	 eax, DWORD PTR func$[rsp]
  00016	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0001b	89 44 24 04	 mov	 DWORD PTR mode$[rsp], eax

; 481  : 
; 482  :     /*
; 483  :     || Process the requested function
; 484  :     */
; 485  :     switch( func & ( ~( HETCNTL_GET | HETCNTL_SET ) ) )

  0001f	8b 44 24 28	 mov	 eax, DWORD PTR func$[rsp]
  00023	0f ba f0 08	 btr	 eax, 8
  00027	89 04 24	 mov	 DWORD PTR tv66[rsp], eax
  0002a	83 3c 24 01	 cmp	 DWORD PTR tv66[rsp], 1
  0002e	74 29		 je	 SHORT $LN4@het_cntl
  00030	83 3c 24 02	 cmp	 DWORD PTR tv66[rsp], 2
  00034	74 7c		 je	 SHORT $LN6@het_cntl
  00036	83 3c 24 03	 cmp	 DWORD PTR tv66[rsp], 3
  0003a	0f 84 cb 00 00
	00		 je	 $LN8@het_cntl
  00040	83 3c 24 04	 cmp	 DWORD PTR tv66[rsp], 4
  00044	0f 84 19 01 00
	00		 je	 $LN12@het_cntl
  0004a	83 3c 24 05	 cmp	 DWORD PTR tv66[rsp], 5
  0004e	0f 84 61 01 00
	00		 je	 $LN16@het_cntl
  00054	e9 96 01 00 00	 jmp	 $LN20@het_cntl
$LN4@het_cntl:

; 486  :     {
; 487  :         case HETCNTL_COMPRESS:
; 488  :             if( mode == HETCNTL_GET )

  00059	83 7c 24 04 00	 cmp	 DWORD PTR mode$[rsp], 0
  0005e	75 13		 jne	 SHORT $LN5@het_cntl

; 489  :             {
; 490  :                 return( hetb->compress );

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR hetb$[rsp]
  00065	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00068	c1 e8 03	 shr	 eax, 3
  0006b	83 e0 01	 and	 eax, 1
  0006e	e9 85 01 00 00	 jmp	 $LN1@het_cntl
$LN5@het_cntl:

; 491  :             }
; 492  : 
; 493  :             hetb->compress = ( val ? TRUE : FALSE );

  00073	83 7c 24 30 00	 cmp	 DWORD PTR val$[rsp], 0
  00078	74 0a		 je	 SHORT $LN22@het_cntl
  0007a	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00082	eb 08		 jmp	 SHORT $LN23@het_cntl
$LN22@het_cntl:
  00084	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN23@het_cntl:
  0008c	8b 44 24 08	 mov	 eax, DWORD PTR tv73[rsp]
  00090	83 e0 01	 and	 eax, 1
  00093	c1 e0 03	 shl	 eax, 3
  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hetb$[rsp]
  0009b	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  0009e	83 e1 f7	 and	 ecx, -9			; fffffff7H
  000a1	0b c8		 or	 ecx, eax
  000a3	8b c1		 mov	 eax, ecx
  000a5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hetb$[rsp]
  000aa	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 494  :         break;

  000ad	e9 44 01 00 00	 jmp	 $LN2@het_cntl
$LN6@het_cntl:

; 495  : 
; 496  :         case HETCNTL_DECOMPRESS:
; 497  :             if( mode == HETCNTL_GET )

  000b2	83 7c 24 04 00	 cmp	 DWORD PTR mode$[rsp], 0
  000b7	75 13		 jne	 SHORT $LN7@het_cntl

; 498  :             {
; 499  :                 return( hetb->decompress );

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR hetb$[rsp]
  000be	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000c1	c1 e8 04	 shr	 eax, 4
  000c4	83 e0 01	 and	 eax, 1
  000c7	e9 2c 01 00 00	 jmp	 $LN1@het_cntl
$LN7@het_cntl:

; 500  :             }
; 501  : 
; 502  :             hetb->decompress = ( val ? TRUE : FALSE );

  000cc	83 7c 24 30 00	 cmp	 DWORD PTR val$[rsp], 0
  000d1	74 0a		 je	 SHORT $LN24@het_cntl
  000d3	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  000db	eb 08		 jmp	 SHORT $LN25@het_cntl
$LN24@het_cntl:
  000dd	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN25@het_cntl:
  000e5	8b 44 24 0c	 mov	 eax, DWORD PTR tv85[rsp]
  000e9	83 e0 01	 and	 eax, 1
  000ec	c1 e0 04	 shl	 eax, 4
  000ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hetb$[rsp]
  000f4	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  000f7	83 e1 ef	 and	 ecx, -17		; ffffffefH
  000fa	0b c8		 or	 ecx, eax
  000fc	8b c1		 mov	 eax, ecx
  000fe	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hetb$[rsp]
  00103	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 503  :         break;

  00106	e9 eb 00 00 00	 jmp	 $LN2@het_cntl
$LN8@het_cntl:

; 504  : 
; 505  :         case HETCNTL_METHOD:
; 506  :             if( mode == HETCNTL_GET )

  0010b	83 7c 24 04 00	 cmp	 DWORD PTR mode$[rsp], 0
  00110	75 13		 jne	 SHORT $LN9@het_cntl

; 507  :             {
; 508  :                 return( hetb->method );

  00112	48 8b 44 24 20	 mov	 rax, QWORD PTR hetb$[rsp]
  00117	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0011a	c1 e8 05	 shr	 eax, 5
  0011d	83 e0 03	 and	 eax, 3
  00120	e9 d3 00 00 00	 jmp	 $LN1@het_cntl
$LN9@het_cntl:

; 509  :             }
; 510  : 
; 511  :             if( val < HETMIN_METHOD || val > HETMAX_METHOD )

  00125	83 7c 24 30 01	 cmp	 DWORD PTR val$[rsp], 1
  0012a	72 07		 jb	 SHORT $LN11@het_cntl
  0012c	83 7c 24 30 01	 cmp	 DWORD PTR val$[rsp], 1
  00131	76 0a		 jbe	 SHORT $LN10@het_cntl
$LN11@het_cntl:

; 512  :             {
; 513  :                 return( HETE_BADMETHOD );

  00133	b8 f0 ff ff ff	 mov	 eax, -16
  00138	e9 bb 00 00 00	 jmp	 $LN1@het_cntl
$LN10@het_cntl:

; 514  :             }
; 515  : 
; 516  :             hetb->method = val;

  0013d	8b 44 24 30	 mov	 eax, DWORD PTR val$[rsp]
  00141	83 e0 03	 and	 eax, 3
  00144	c1 e0 05	 shl	 eax, 5
  00147	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hetb$[rsp]
  0014c	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  0014f	83 e1 9f	 and	 ecx, -97		; ffffff9fH
  00152	0b c8		 or	 ecx, eax
  00154	8b c1		 mov	 eax, ecx
  00156	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hetb$[rsp]
  0015b	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 517  :         break;

  0015e	e9 93 00 00 00	 jmp	 $LN2@het_cntl
$LN12@het_cntl:

; 518  : 
; 519  :         case HETCNTL_LEVEL:
; 520  :             if( mode == HETCNTL_GET )

  00163	83 7c 24 04 00	 cmp	 DWORD PTR mode$[rsp], 0
  00168	75 10		 jne	 SHORT $LN13@het_cntl

; 521  :             {
; 522  :                 return( hetb->level );

  0016a	48 8b 44 24 20	 mov	 rax, QWORD PTR hetb$[rsp]
  0016f	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00172	c1 e8 07	 shr	 eax, 7
  00175	83 e0 0f	 and	 eax, 15
  00178	eb 7e		 jmp	 SHORT $LN1@het_cntl
$LN13@het_cntl:

; 523  :             }
; 524  : 
; 525  :             if( val < HETMIN_LEVEL || val > HETMAX_LEVEL )

  0017a	83 7c 24 30 01	 cmp	 DWORD PTR val$[rsp], 1
  0017f	72 07		 jb	 SHORT $LN15@het_cntl
  00181	83 7c 24 30 09	 cmp	 DWORD PTR val$[rsp], 9
  00186	76 07		 jbe	 SHORT $LN14@het_cntl
$LN15@het_cntl:

; 526  :             {
; 527  :                 return( HETE_BADLEVEL );

  00188	b8 ef ff ff ff	 mov	 eax, -17
  0018d	eb 69		 jmp	 SHORT $LN1@het_cntl
$LN14@het_cntl:

; 528  :             }
; 529  : 
; 530  :             hetb->level = val;

  0018f	8b 44 24 30	 mov	 eax, DWORD PTR val$[rsp]
  00193	83 e0 0f	 and	 eax, 15
  00196	c1 e0 07	 shl	 eax, 7
  00199	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hetb$[rsp]
  0019e	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  001a1	81 e1 7f f8 ff
	ff		 and	 ecx, -1921		; fffff87fH
  001a7	0b c8		 or	 ecx, eax
  001a9	8b c1		 mov	 eax, ecx
  001ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hetb$[rsp]
  001b0	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 531  :         break;

  001b3	eb 41		 jmp	 SHORT $LN2@het_cntl
$LN16@het_cntl:

; 532  : 
; 533  :         case HETCNTL_CHUNKSIZE:
; 534  :             if( mode == HETCNTL_GET )

  001b5	83 7c 24 04 00	 cmp	 DWORD PTR mode$[rsp], 0
  001ba	75 0a		 jne	 SHORT $LN17@het_cntl

; 535  :             {
; 536  :                 return( hetb->chksize );

  001bc	48 8b 44 24 20	 mov	 rax, QWORD PTR hetb$[rsp]
  001c1	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  001c4	eb 32		 jmp	 SHORT $LN1@het_cntl
$LN17@het_cntl:

; 537  :             }
; 538  : 
; 539  :             if( val < HETMIN_CHUNKSIZE || val > HETMAX_CHUNKSIZE )

  001c6	81 7c 24 30 00
	10 00 00	 cmp	 DWORD PTR val$[rsp], 4096 ; 00001000H
  001ce	72 0a		 jb	 SHORT $LN19@het_cntl
  001d0	81 7c 24 30 ff
	ff 00 00	 cmp	 DWORD PTR val$[rsp], 65535 ; 0000ffffH
  001d8	76 07		 jbe	 SHORT $LN18@het_cntl
$LN19@het_cntl:

; 540  :             {
; 541  :                 return( HETE_BADSIZE );

  001da	b8 ee ff ff ff	 mov	 eax, -18
  001df	eb 17		 jmp	 SHORT $LN1@het_cntl
$LN18@het_cntl:

; 542  :             }
; 543  : 
; 544  :             hetb->chksize = val;

  001e1	48 8b 44 24 20	 mov	 rax, QWORD PTR hetb$[rsp]
  001e6	8b 4c 24 30	 mov	 ecx, DWORD PTR val$[rsp]
  001ea	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 545  :         break;

  001ed	eb 07		 jmp	 SHORT $LN2@het_cntl
$LN20@het_cntl:

; 546  : 
; 547  :         default:
; 548  :             return( HETE_BADFUNC );

  001ef	b8 f1 ff ff ff	 mov	 eax, -15
  001f4	eb 02		 jmp	 SHORT $LN1@het_cntl
$LN2@het_cntl:

; 549  :     }
; 550  : 
; 551  :     /*
; 552  :     || Success
; 553  :     */
; 554  : 
; 555  :     return( 0 );

  001f6	33 c0		 xor	 eax, eax
$LN1@het_cntl:

; 556  : }

  001f8	48 83 c4 18	 add	 rsp, 24
  001fc	c3		 ret	 0
het_cntl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
hetb$ = 64
het_sync PROC

; 1607 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1608 :     int rc;
; 1609 : 
; 1610 :     /*
; 1611 :     || Can't sync to readonly media
; 1612 :     */
; 1613 :     if( hetb->writeprotect )

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0000e	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00011	83 e0 01	 and	 eax, 1
  00014	85 c0		 test	 eax, eax
  00016	74 07		 je	 SHORT $LN5@het_sync

; 1614 :     {
; 1615 :         return( HETE_PROTECTED );

  00018	b8 f2 ff ff ff	 mov	 eax, -14
  0001d	eb 29		 jmp	 SHORT $LN1@het_sync
$LN5@het_sync:
$LN4@het_sync:

; 1616 :     }
; 1617 : 
; 1618 :     /*
; 1619 :     || Perform the sync
; 1620 :     */
; 1621 :     do rc = fdatasync( hetb->fd );

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00024	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
  0002d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1622 :     while (EINTR == rc);

  00031	83 7c 24 20 04	 cmp	 DWORD PTR rc$[rsp], 4
  00036	74 e7		 je	 SHORT $LN4@het_sync

; 1623 :     if (rc != 0)

  00038	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0003d	74 07		 je	 SHORT $LN6@het_sync

; 1624 :     {
; 1625 :         return( HETE_ERROR );

  0003f	b8 ff ff ff ff	 mov	 eax, -1
  00044	eb 02		 jmp	 SHORT $LN1@het_sync
$LN6@het_sync:

; 1626 :     }
; 1627 : 
; 1628 :     /*
; 1629 :     || Success
; 1630 :     */
; 1631 :     return( 0 );

  00046	33 c0		 xor	 eax, eax
$LN1@het_sync:

; 1632 : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
het_sync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
hetb$ = 64
het_tapemark PROC

; 1504 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1505 :     int rc;
; 1506 : 
; 1507 :     /*
; 1508 :     || Just write a tapemark header
; 1509 :     */
; 1510 :     rc = het_write_header( hetb, 0, HETHDR_FLAGS1_TAPEMARK, 0 );

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00012	33 d2		 xor	 edx, edx
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00019	e8 00 00 00 00	 call	 het_write_header
  0001e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1511 :     if( rc < 0 )

  00022	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00027	7d 06		 jge	 SHORT $LN5@het_tapema

; 1512 :     {
; 1513 :         return( rc );

  00029	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  0002d	eb 3a		 jmp	 SHORT $LN1@het_tapema
$LN5@het_tapema:
$LN4@het_tapema:

; 1514 :     }
; 1515 : 
; 1516 :     /*
; 1517 :     || Set new physical EOF
; 1518 :     */
; 1519 :     do rc = ftruncate( hetb->fd, ftell( hetb->fh ) );

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00034	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  0003d	48 8b d0	 mov	 rdx, rax
  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00045	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  0004e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1520 :     while (EINTR == rc);

  00052	83 7c 24 20 04	 cmp	 DWORD PTR rc$[rsp], 4
  00057	74 d6		 je	 SHORT $LN4@het_tapema

; 1521 :     if (rc != 0)

  00059	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005e	74 07		 je	 SHORT $LN6@het_tapema

; 1522 :     {
; 1523 :         return( HETE_ERROR );

  00060	b8 ff ff ff ff	 mov	 eax, -1
  00065	eb 02		 jmp	 SHORT $LN1@het_tapema
$LN6@het_tapema:

; 1524 :     }
; 1525 : 
; 1526 :     /*
; 1527 :     || Success
; 1528 :     */
; 1529 :     return( 0 );

  00067	33 c0		 xor	 eax, eax
$LN1@het_tapema:

; 1530 : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
het_tapemark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
tlen$ = 36
flags$ = 40
tv75 = 44
tbuf$ = 48
csbuf$1 = 56
hetb$ = 80
sbuf$ = 88
slen$ = 96
het_write PROC

; 1266 : {

$LN23:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1267 :     int rc;
; 1268 :     int flags;
; 1269 : 
; 1270 :     unsigned long tlen;
; 1271 : 
; 1272 : //    unsigned int bz_tlen; @salva unreferenced local variable error
; 1273 : 
; 1274 :     char *tbuf = NULL;

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tbuf$[rsp], 0

; 1275 : #if defined( HAVE_ZLIB ) || defined( HET_BZIP2 )
; 1276 :     size_t tsiz = ((((HETMAX_BLOCKSIZE * 1001) + 999) / 1000) + 12);
; 1277 :     tbuf = malloc_aligned( tsiz, 4096 );
; 1278 :     if (!tbuf)
; 1279 :     {
; 1280 :         return( HETE_NOMEM );
; 1281 :     }
; 1282 : #endif
; 1283 : 
; 1284 :     /*
; 1285 :     || Validate
; 1286 :     */
; 1287 :     if( slen > HETMAX_BLOCKSIZE )

  0001c	81 7c 24 60 00
	00 20 00	 cmp	 DWORD PTR slen$[rsp], 2097152 ; 00200000H
  00024	7e 1d		 jle	 SHORT $LN10@het_write

; 1288 :     {
; 1289 :         if (tbuf) free_aligned( tbuf );

  00026	48 83 7c 24 30
	00		 cmp	 QWORD PTR tbuf$[rsp], 0
  0002c	74 0b		 je	 SHORT $LN11@het_write
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tbuf$[rsp]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN11@het_write:

; 1290 :         return( HETE_BADLEN );

  00039	b8 f3 ff ff ff	 mov	 eax, -13
  0003e	e9 af 01 00 00	 jmp	 $LN1@het_write
$LN10@het_write:

; 1291 :     }
; 1292 : 
; 1293 :     /*
; 1294 :     || Initialize
; 1295 :     */
; 1296 :     flags = HETHDR_FLAGS1_BOR;

  00043	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR flags$[rsp], 128 ; 00000080H

; 1297 : 
; 1298 :     /*
; 1299 :     || Save uncompressed length
; 1300 :     */
; 1301 :     hetb->ublksize = slen;

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  00050	8b 4c 24 60	 mov	 ecx, DWORD PTR slen$[rsp]
  00054	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1302 : 
; 1303 :     /*
; 1304 :     || Compress data if requested
; 1305 :     */
; 1306 :     if( hetb->compress )

  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  0005c	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0005f	c1 e8 03	 shr	 eax, 3
  00062	83 e0 01	 and	 eax, 1
  00065	85 c0		 test	 eax, eax
  00067	74 12		 je	 SHORT $LN12@het_write

; 1307 :     {
; 1308 :         switch( hetb->method )

  00069	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  0006e	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00071	c1 e8 05	 shr	 eax, 5
  00074	83 e0 03	 and	 eax, 3
  00077	89 44 24 2c	 mov	 DWORD PTR tv75[rsp], eax
$LN12@het_write:

; 1309 :         {
; 1310 : #if defined( HAVE_ZLIB )
; 1311 :             case HETHDR_FLAGS1_ZLIB:
; 1312 :                 tlen = tsiz;
; 1313 : 
; 1314 :                 rc = compress2( (unsigned char *)tbuf, &tlen, (void *)sbuf, slen, hetb->level );
; 1315 :                 if( rc != Z_OK )
; 1316 :                 {
; 1317 :                     rc = errno;
; 1318 :                     if (tbuf) free_aligned( tbuf );
; 1319 :                     errno = rc;
; 1320 :                     return( HETE_COMPERR );
; 1321 :                 }
; 1322 : 
; 1323 :                 if( (int)tlen < slen )
; 1324 :                 {
; 1325 :                     sbuf = tbuf;
; 1326 :                     slen = tlen;
; 1327 :                     flags |= HETHDR_FLAGS1_ZLIB;
; 1328 :                 }
; 1329 :             break;
; 1330 : #endif
; 1331 : 
; 1332 : #if defined( HET_BZIP2 )
; 1333 :             case HETHDR_FLAGS1_BZLIB:
; 1334 :                 tlen = tsiz;
; 1335 : 
; 1336 :                 bz_tlen = (unsigned int) tlen;
; 1337 : 
; 1338 :                 rc = BZ2_bzBuffToBuffCompress( tbuf,
; 1339 :                                                (void *) &bz_tlen,
; 1340 :                                                (void *)sbuf,
; 1341 :                                                slen,
; 1342 :                                                hetb->level,
; 1343 :                                                0,
; 1344 :                                                0 );
; 1345 :                 tlen = (unsigned long) bz_tlen;
; 1346 : 
; 1347 :                 if( rc != BZ_OK )
; 1348 :                 {
; 1349 :                     rc = errno;
; 1350 :                     if (tbuf) free_aligned( tbuf );
; 1351 :                     errno = rc;
; 1352 :                     return( HETE_COMPERR );
; 1353 :                 }
; 1354 : 
; 1355 :                 if( (int)tlen < slen )
; 1356 :                 {
; 1357 :                     sbuf = tbuf;
; 1358 :                     slen = tlen;
; 1359 :                     flags |= HETHDR_FLAGS1_BZLIB;
; 1360 :                 }
; 1361 :             break;
; 1362 : #endif /* defined( HET_BZIP2 ) */
; 1363 :         }
; 1364 :     }
; 1365 : 
; 1366 :     /*
; 1367 :     || Save compressed length
; 1368 :     */
; 1369 :     hetb->cblksize = slen;

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  00080	8b 4c 24 60	 mov	 ecx, DWORD PTR slen$[rsp]
  00084	89 48 14	 mov	 DWORD PTR [rax+20], ecx
$LN6@het_write:

; 1370 : 
; 1371 :     /*
; 1372 :     || Write block, breaking it into "chksize" chunks
; 1373 :     */
; 1374 :     do
; 1375 :     {
; 1376 :         /*
; 1377 :         || Last chunk for this block?
; 1378 :         */
; 1379 :         if( slen <= (int)hetb->chksize )

  00087	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  0008c	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0008f	39 44 24 60	 cmp	 DWORD PTR slen$[rsp], eax
  00093	7f 15		 jg	 SHORT $LN13@het_write

; 1380 :         {
; 1381 :             flags |= HETHDR_FLAGS1_EOR;

  00095	8b 44 24 28	 mov	 eax, DWORD PTR flags$[rsp]
  00099	83 c8 20	 or	 eax, 32			; 00000020H
  0009c	89 44 24 28	 mov	 DWORD PTR flags$[rsp], eax

; 1382 :             tlen = slen;

  000a0	8b 44 24 60	 mov	 eax, DWORD PTR slen$[rsp]
  000a4	89 44 24 24	 mov	 DWORD PTR tlen$[rsp], eax

; 1383 :         }

  000a8	eb 0c		 jmp	 SHORT $LN14@het_write
$LN13@het_write:

; 1384 :         else
; 1385 :         {
; 1386 :             tlen = hetb->chksize;

  000aa	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  000af	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000b2	89 44 24 24	 mov	 DWORD PTR tlen$[rsp], eax
$LN14@het_write:

; 1387 :         }
; 1388 : 
; 1389 :         /*
; 1390 :         || Write the header
; 1391 :         */
; 1392 :         rc = het_write_header( hetb, tlen, flags, 0 );

  000b6	45 33 c9	 xor	 r9d, r9d
  000b9	44 8b 44 24 28	 mov	 r8d, DWORD PTR flags$[rsp]
  000be	8b 54 24 24	 mov	 edx, DWORD PTR tlen$[rsp]
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hetb$[rsp]
  000c7	e8 00 00 00 00	 call	 het_write_header
  000cc	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1393 :         if( rc < 0 )

  000d0	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d5	7d 1c		 jge	 SHORT $LN15@het_write

; 1394 :         {
; 1395 :             if (tbuf) free_aligned( tbuf );

  000d7	48 83 7c 24 30
	00		 cmp	 QWORD PTR tbuf$[rsp], 0
  000dd	74 0b		 je	 SHORT $LN16@het_write
  000df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tbuf$[rsp]
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN16@het_write:

; 1396 :             return( rc );

  000ea	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  000ee	e9 ff 00 00 00	 jmp	 $LN1@het_write
$LN15@het_write:

; 1397 :         }
; 1398 : 
; 1399 :         /*
; 1400 :         || Write the block
; 1401 :         */
; 1402 :         rc = (int)fwrite( sbuf, 1, tlen, hetb->fh );

  000f3	8b 44 24 24	 mov	 eax, DWORD PTR tlen$[rsp]
  000f7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hetb$[rsp]
  000fc	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  000ff	44 8b c0	 mov	 r8d, eax
  00102	ba 01 00 00 00	 mov	 edx, 1
  00107	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sbuf$[rsp]
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00112	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1403 :         if( rc != (int)tlen )

  00116	8b 44 24 24	 mov	 eax, DWORD PTR tlen$[rsp]
  0011a	39 44 24 20	 cmp	 DWORD PTR rc$[rsp], eax
  0011e	74 1d		 je	 SHORT $LN17@het_write

; 1404 :         {
; 1405 :             if (tbuf) free_aligned( tbuf );

  00120	48 83 7c 24 30
	00		 cmp	 QWORD PTR tbuf$[rsp], 0
  00126	74 0b		 je	 SHORT $LN18@het_write
  00128	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tbuf$[rsp]
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN18@het_write:

; 1406 :             return( HETE_ERROR );

  00133	b8 ff ff ff ff	 mov	 eax, -1
  00138	e9 b5 00 00 00	 jmp	 $LN1@het_write
$LN17@het_write:

; 1407 :         }
; 1408 : 
; 1409 :         /*
; 1410 :         || Bump pointers and turn off BOR flag
; 1411 :         */
; 1412 :         {
; 1413 :             char    *csbuf;
; 1414 :             csbuf=(char *)sbuf;

  0013d	48 8b 44 24 58	 mov	 rax, QWORD PTR sbuf$[rsp]
  00142	48 89 44 24 38	 mov	 QWORD PTR csbuf$1[rsp], rax

; 1415 :             csbuf+=tlen;

  00147	8b 44 24 24	 mov	 eax, DWORD PTR tlen$[rsp]
  0014b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR csbuf$1[rsp]
  00150	48 03 c8	 add	 rcx, rax
  00153	48 8b c1	 mov	 rax, rcx
  00156	48 89 44 24 38	 mov	 QWORD PTR csbuf$1[rsp], rax

; 1416 :             sbuf=(void *)csbuf;

  0015b	48 8b 44 24 38	 mov	 rax, QWORD PTR csbuf$1[rsp]
  00160	48 89 44 24 58	 mov	 QWORD PTR sbuf$[rsp], rax

; 1417 :         }
; 1418 :         slen -= tlen;

  00165	8b 44 24 24	 mov	 eax, DWORD PTR tlen$[rsp]
  00169	8b 4c 24 60	 mov	 ecx, DWORD PTR slen$[rsp]
  0016d	2b c8		 sub	 ecx, eax
  0016f	8b c1		 mov	 eax, ecx
  00171	89 44 24 60	 mov	 DWORD PTR slen$[rsp], eax

; 1419 :         flags &= (~HETHDR_FLAGS1_BOR);

  00175	8b 44 24 28	 mov	 eax, DWORD PTR flags$[rsp]
  00179	0f ba f0 07	 btr	 eax, 7
  0017d	89 44 24 28	 mov	 DWORD PTR flags$[rsp], eax

; 1420 :     }
; 1421 :     while( slen > 0 );

  00181	83 7c 24 60 00	 cmp	 DWORD PTR slen$[rsp], 0
  00186	0f 8f fb fe ff
	ff		 jg	 $LN6@het_write
$LN9@het_write:

; 1422 : 
; 1423 :     /*
; 1424 :     || Set new physical EOF
; 1425 :     */
; 1426 :     do rc = ftruncate( hetb->fd, ftell( hetb->fh ) );

  0018c	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  00191	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  0019a	48 8b d0	 mov	 rdx, rax
  0019d	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  001a2	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  001ab	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1427 :     while (EINTR == rc);

  001af	83 7c 24 20 04	 cmp	 DWORD PTR rc$[rsp], 4
  001b4	74 d6		 je	 SHORT $LN9@het_write

; 1428 :     if (rc != 0)

  001b6	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  001bb	74 1a		 je	 SHORT $LN19@het_write

; 1429 :     {
; 1430 :         if (tbuf) free_aligned( tbuf );

  001bd	48 83 7c 24 30
	00		 cmp	 QWORD PTR tbuf$[rsp], 0
  001c3	74 0b		 je	 SHORT $LN20@het_write
  001c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tbuf$[rsp]
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN20@het_write:

; 1431 :         return( HETE_ERROR );

  001d0	b8 ff ff ff ff	 mov	 eax, -1
  001d5	eb 1b		 jmp	 SHORT $LN1@het_write
$LN19@het_write:

; 1432 :     }
; 1433 : 
; 1434 :     /*
; 1435 :     || Cleanup
; 1436 :     */
; 1437 :     if (tbuf) free_aligned( tbuf );

  001d7	48 83 7c 24 30
	00		 cmp	 QWORD PTR tbuf$[rsp], 0
  001dd	74 0b		 je	 SHORT $LN21@het_write
  001df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tbuf$[rsp]
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN21@het_write:

; 1438 : 
; 1439 :     /*
; 1440 :     || Success
; 1441 :     */
; 1442 :     return( hetb->cblksize );

  001ea	48 8b 44 24 50	 mov	 rax, QWORD PTR hetb$[rsp]
  001ef	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
$LN1@het_write:

; 1443 : }

  001f2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f6	c3		 ret	 0
het_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
rcoff$ = 40
hetb$ = 64
len$ = 72
flags1$ = 80
flags2$ = 88
het_write_header PROC

; 1093 : {

$LN12:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1094 :     int    rc;
; 1095 :     off_t  rcoff;
; 1096 : 
; 1097 : #if defined( HETDEBUGW )
; 1098 :     printf("write hdr: pl=%d, cl=%d, f1=%02x, f2=%02x\n",
; 1099 :         HETHDR_PLEN( hetb ), HETHDR_CLEN( hetb ),
; 1100 :         hetb->chdr.flags1, hetb->chdr.flags2);
; 1101 : #endif
; 1102 : 
; 1103 :     /*
; 1104 :     || Validate length
; 1105 :     */
; 1106 :     if( len > HETMAX_CHUNKSIZE )

  00017	81 7c 24 48 ff
	ff 00 00	 cmp	 DWORD PTR len$[rsp], 65535 ; 0000ffffH
  0001f	7e 0a		 jle	 SHORT $LN2@het_write_

; 1107 :     {
; 1108 :         return( HETE_BADLEN );

  00021	b8 f3 ff ff ff	 mov	 eax, -13
  00026	e9 d2 01 00 00	 jmp	 $LN1@het_write_
$LN2@het_write_:

; 1109 :     }
; 1110 : 
; 1111 :     /*
; 1112 :     || Can't write anything on readonly media
; 1113 :     */
; 1114 :     if( hetb->writeprotect )

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00030	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00033	83 e0 01	 and	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	74 0a		 je	 SHORT $LN3@het_write_

; 1115 :     {
; 1116 :         return( HETE_PROTECTED );

  0003a	b8 f2 ff ff ff	 mov	 eax, -14
  0003f	e9 b9 01 00 00	 jmp	 $LN1@het_write_
$LN3@het_write_:

; 1117 :     }
; 1118 : 
; 1119 :     /*
; 1120 :     || For tapemarks, length must be zero.
; 1121 :     */
; 1122 :     if( flags1 & HETHDR_FLAGS1_TAPEMARK )

  00044	8b 44 24 50	 mov	 eax, DWORD PTR flags1$[rsp]
  00048	83 e0 40	 and	 eax, 64			; 00000040H
  0004b	85 c0		 test	 eax, eax
  0004d	74 08		 je	 SHORT $LN4@het_write_

; 1123 :     {
; 1124 :         len = 0;

  0004f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN4@het_write_:

; 1125 :     }
; 1126 : 
; 1127 :     /*
; 1128 :     || According to Linux fopen() man page, a positioning function is required
; 1129 :     || between reads and writes.  Is this REALLY necessary???
; 1130 :     */
; 1131 :     if( !hetb->readlast )

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0005c	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0005f	d1 e8		 shr	 eax, 1
  00061	83 e0 01	 and	 eax, 1
  00064	85 c0		 test	 eax, eax
  00066	75 29		 jne	 SHORT $LN5@het_write_

; 1132 :     {
; 1133 :         fseek( hetb->fh, 0, SEEK_CUR );

  00068	41 b8 01 00 00
	00		 mov	 r8d, 1
  0006e	33 d2		 xor	 edx, edx
  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00075	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64

; 1134 :         hetb->readlast = FALSE;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00083	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00086	83 e0 fd	 and	 eax, -3			; fffffffdH
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  0008e	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN5@het_write_:

; 1135 :     }
; 1136 : 
; 1137 :     /*
; 1138 :     || If this is the first write, truncate the file
; 1139 :     */
; 1140 :     if( !hetb->truncated )

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00096	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00099	c1 e8 02	 shr	 eax, 2
  0009c	83 e0 01	 and	 eax, 1
  0009f	85 c0		 test	 eax, eax
  000a1	75 60		 jne	 SHORT $LN6@het_write_

; 1141 :     {
; 1142 :         rcoff = ftell( hetb->fh );

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  000a8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  000b1	48 89 44 24 28	 mov	 QWORD PTR rcoff$[rsp], rax

; 1143 :         if( rcoff == -1 )

  000b6	48 83 7c 24 28
	ff		 cmp	 QWORD PTR rcoff$[rsp], -1
  000bc	75 0a		 jne	 SHORT $LN7@het_write_

; 1144 :         {
; 1145 :             return( HETE_ERROR );

  000be	b8 ff ff ff ff	 mov	 eax, -1
  000c3	e9 35 01 00 00	 jmp	 $LN1@het_write_
$LN7@het_write_:

; 1146 :         }
; 1147 : 
; 1148 :         rc = ftruncate( hetb->fd, rcoff );

  000c8	48 8b 54 24 28	 mov	 rdx, QWORD PTR rcoff$[rsp]
  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  000d2	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  000db	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1149 :         if( rc == -1 )

  000df	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  000e4	75 0a		 jne	 SHORT $LN8@het_write_

; 1150 :         {
; 1151 :             return( HETE_ERROR );

  000e6	b8 ff ff ff ff	 mov	 eax, -1
  000eb	e9 0d 01 00 00	 jmp	 $LN1@het_write_
$LN8@het_write_:

; 1152 :         }
; 1153 : 
; 1154 :         hetb->truncated = TRUE;

  000f0	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  000f5	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000f8	83 c8 04	 or	 eax, 4
  000fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00100	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN6@het_write_:

; 1155 :     }
; 1156 : 
; 1157 :     /*
; 1158 :     || Construct the header
; 1159 :     */
; 1160 :     hetb->chdr.plen[ 0 ] = hetb->chdr.clen[ 0 ];

  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	48 6b c0 00	 imul	 rax, rax, 0
  0010c	b9 01 00 00 00	 mov	 ecx, 1
  00111	48 6b c9 00	 imul	 rcx, rcx, 0
  00115	48 8b 54 24 40	 mov	 rdx, QWORD PTR hetb$[rsp]
  0011a	4c 8b 44 24 40	 mov	 r8, QWORD PTR hetb$[rsp]
  0011f	41 0f b6 44 00
	1c		 movzx	 eax, BYTE PTR [r8+rax+28]
  00125	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 1161 :     hetb->chdr.plen[ 1 ] = hetb->chdr.clen[ 1 ];

  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	48 6b c0 01	 imul	 rax, rax, 1
  00132	b9 01 00 00 00	 mov	 ecx, 1
  00137	48 6b c9 01	 imul	 rcx, rcx, 1
  0013b	48 8b 54 24 40	 mov	 rdx, QWORD PTR hetb$[rsp]
  00140	4c 8b 44 24 40	 mov	 r8, QWORD PTR hetb$[rsp]
  00145	41 0f b6 44 00
	1c		 movzx	 eax, BYTE PTR [r8+rax+28]
  0014b	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 1162 :     hetb->chdr.clen[ 0 ] = len & 0xFF;

  0014f	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  00153	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00158	b9 01 00 00 00	 mov	 ecx, 1
  0015d	48 6b c9 00	 imul	 rcx, rcx, 0
  00161	48 8b 54 24 40	 mov	 rdx, QWORD PTR hetb$[rsp]
  00166	88 44 0a 1c	 mov	 BYTE PTR [rdx+rcx+28], al

; 1163 :     hetb->chdr.clen[ 1 ] = ( len >> 8 ) & 0xFF;

  0016a	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  0016e	c1 f8 08	 sar	 eax, 8
  00171	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00176	b9 01 00 00 00	 mov	 ecx, 1
  0017b	48 6b c9 01	 imul	 rcx, rcx, 1
  0017f	48 8b 54 24 40	 mov	 rdx, QWORD PTR hetb$[rsp]
  00184	88 44 0a 1c	 mov	 BYTE PTR [rdx+rcx+28], al

; 1164 :     hetb->chdr.flags1    = flags1;

  00188	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0018d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR flags1$[rsp]
  00192	88 48 20	 mov	 BYTE PTR [rax+32], cl

; 1165 :     hetb->chdr.flags2    = flags2;

  00195	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0019a	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR flags2$[rsp]
  0019f	88 48 21	 mov	 BYTE PTR [rax+33], cl

; 1166 : 
; 1167 :     /*
; 1168 :     || Write it out
; 1169 :     */
; 1170 :     rc = (int)fwrite( &hetb->chdr, sizeof( HETHDR ), 1, hetb->fh );

  001a2	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  001a7	48 83 c0 1c	 add	 rax, 28
  001ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  001b0	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  001b3	41 b8 01 00 00
	00		 mov	 r8d, 1
  001b9	ba 06 00 00 00	 mov	 edx, 6
  001be	48 8b c8	 mov	 rcx, rax
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  001c7	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1171 :     if( rc != 1 )

  001cb	83 7c 24 20 01	 cmp	 DWORD PTR rc$[rsp], 1
  001d0	74 07		 je	 SHORT $LN9@het_write_

; 1172 :     {
; 1173 :         return( HETE_ERROR );

  001d2	b8 ff ff ff ff	 mov	 eax, -1
  001d7	eb 24		 jmp	 SHORT $LN1@het_write_
$LN9@het_write_:

; 1174 :     }
; 1175 : 
; 1176 :     /*
; 1177 :     || Bump block count if done with entire block
; 1178 :     */
; 1179 :     if( hetb->chdr.flags1 & ( HETHDR_FLAGS1_EOR | HETHDR_FLAGS1_TAPEMARK ) )

  001d9	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  001de	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  001e2	83 e0 60	 and	 eax, 96			; 00000060H
  001e5	85 c0		 test	 eax, eax
  001e7	74 12		 je	 SHORT $LN10@het_write_

; 1180 :     {
; 1181 :         hetb->cblk++;

  001e9	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  001ee	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001f1	ff c0		 inc	 eax
  001f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  001f8	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN10@het_write_:

; 1182 :     }
; 1183 : 
; 1184 :     /*
; 1185 :     || Success
; 1186 :     */
; 1187 :     return 0;

  001fb	33 c0		 xor	 eax, eax
$LN1@het_write_:

; 1188 : }

  001fd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00201	c3		 ret	 0
het_write_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
tbuf$ = 32
tlen$ = 40
rc$ = 44
slen$ = 48
flags1$ = 52
flags2$ = 56
tptr$ = 64
tv198 = 72
tv202 = 76
hetb$ = 96
sbuf$ = 104
het_read PROC

; 767  : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 768  :     char *tptr;
; 769  :     int rc;
; 770  : 
; 771  :     unsigned long slen;
; 772  :     unsigned long tlen;
; 773  : 
; 774  : //    unsigned int bz_slen; @salva unreferenced local variable error
; 775  : //    unsigned int bz_tlen; @salva unreferenced local variable error
; 776  : 
; 777  :     int flags1, flags2;
; 778  :     char *tbuf;
; 779  : 
; 780  :     /*
; 781  :     || Initialize
; 782  :     */
; 783  :     flags1 = flags2 = 0;

  0000e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR flags2$[rsp], 0
  00016	8b 44 24 38	 mov	 eax, DWORD PTR flags2$[rsp]
  0001a	89 44 24 34	 mov	 DWORD PTR flags1$[rsp], eax

; 784  :     tlen = 0;

  0001e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tlen$[rsp], 0

; 785  :     tptr = sbuf;

  00026	48 8b 44 24 68	 mov	 rax, QWORD PTR sbuf$[rsp]
  0002b	48 89 44 24 40	 mov	 QWORD PTR tptr$[rsp], rax

; 786  :     tbuf = malloc_aligned( HETMAX_BLOCKSIZE, 4096 );

  00030	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00035	b9 00 00 20 00	 mov	 ecx, 2097152		; 00200000H
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  00040	48 89 44 24 20	 mov	 QWORD PTR tbuf$[rsp], rax

; 787  :     if (!tbuf)

  00045	48 83 7c 24 20
	00		 cmp	 QWORD PTR tbuf$[rsp], 0
  0004b	75 0a		 jne	 SHORT $LN9@het_read

; 788  :     {
; 789  :         return( HETE_NOMEM );

  0004d	b8 ec ff ff ff	 mov	 eax, -20
  00052	e9 fa 02 00 00	 jmp	 $LN1@het_read
$LN9@het_read:
$LN4@het_read:

; 790  :     }
; 791  : 
; 792  :     /*
; 793  :     || Read chunks until entire block has been read
; 794  :     */
; 795  :     do
; 796  :     {
; 797  :         /*
; 798  :         || Get a header
; 799  :         */
; 800  :         rc = het_read_header( hetb );

  00057	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hetb$[rsp]
  0005c	e8 00 00 00 00	 call	 het_read_header
  00061	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax

; 801  :         if( rc < 0 )

  00065	83 7c 24 2c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0006a	7d 14		 jge	 SHORT $LN10@het_read

; 802  :         {
; 803  :             free_aligned( tbuf );

  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 804  :             return( rc );

  00077	8b 44 24 2c	 mov	 eax, DWORD PTR rc$[rsp]
  0007b	e9 d1 02 00 00	 jmp	 $LN1@het_read
$LN10@het_read:

; 805  :         }
; 806  : 
; 807  :         /*
; 808  :         || Have we seen a BOR chunk yet?
; 809  :         */
; 810  :         if( !( flags1 & HETHDR_FLAGS1_BOR ) )

  00080	8b 44 24 34	 mov	 eax, DWORD PTR flags1$[rsp]
  00084	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00089	85 c0		 test	 eax, eax
  0008b	0f 85 b8 00 00
	00		 jne	 $LN11@het_read

; 811  :         {
; 812  :             /*
; 813  :             || Nope, so this chunk MUST have the BOR set
; 814  :             */
; 815  :             if( !( hetb->chdr.flags1 & HETHDR_FLAGS1_BOR ) )

  00091	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  00096	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0009a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0009f	85 c0		 test	 eax, eax
  000a1	75 15		 jne	 SHORT $LN13@het_read

; 816  :             {
; 817  :                 free_aligned( tbuf );

  000a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 818  :                 return( HETE_BADBOR );

  000ae	b8 fb ff ff ff	 mov	 eax, -5
  000b3	e9 99 02 00 00	 jmp	 $LN1@het_read
$LN13@het_read:

; 819  :             }
; 820  : 
; 821  :             /*
; 822  :             || If block is compressed (and decompression is desired), set
; 823  :             || destination pointer.
; 824  :             */
; 825  :             if( hetb->decompress )

  000b8	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  000bd	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000c0	c1 e8 04	 shr	 eax, 4
  000c3	83 e0 01	 and	 eax, 1
  000c6	85 c0		 test	 eax, eax
  000c8	74 63		 je	 SHORT $LN14@het_read

; 826  :             {
; 827  :                 if( hetb->chdr.flags1 & HETHDR_FLAGS1_COMPRESS ||

  000ca	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  000cf	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  000d3	83 e0 03	 and	 eax, 3
  000d6	85 c0		 test	 eax, eax
  000d8	75 12		 jne	 SHORT $LN16@het_read
  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  000df	0f b6 40 21	 movzx	 eax, BYTE PTR [rax+33]
  000e3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000e8	85 c0		 test	 eax, eax
  000ea	74 41		 je	 SHORT $LN15@het_read
$LN16@het_read:

; 828  :                     hetb->chdr.flags2 & HETHDR_FLAGS2_COMPRESS )
; 829  :                 {
; 830  :                     if( ( hetb->chdr.flags1 & HETHDR_FLAGS1_COMPRESS ) &&

  000ec	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  000f1	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  000f5	83 e0 03	 and	 eax, 3
  000f8	85 c0		 test	 eax, eax
  000fa	74 27		 je	 SHORT $LN17@het_read
  000fc	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  00101	0f b6 40 21	 movzx	 eax, BYTE PTR [rax+33]
  00105	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0010a	85 c0		 test	 eax, eax
  0010c	74 15		 je	 SHORT $LN17@het_read

; 831  :                         ( hetb->chdr.flags2 & HETHDR_FLAGS2_COMPRESS ) )
; 832  :                     {
; 833  :                         free_aligned( tbuf );

  0010e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 834  :                         return( HETE_BADCOMPRESS );

  00119	b8 ea ff ff ff	 mov	 eax, -22
  0011e	e9 2e 02 00 00	 jmp	 $LN1@het_read
$LN17@het_read:

; 835  :                     }
; 836  :                     tptr = tbuf;

  00123	48 8b 44 24 20	 mov	 rax, QWORD PTR tbuf$[rsp]
  00128	48 89 44 24 40	 mov	 QWORD PTR tptr$[rsp], rax
$LN15@het_read:
$LN14@het_read:

; 837  :                 }
; 838  :             }
; 839  : 
; 840  :             /*
; 841  :             || Save flags for later validation
; 842  :             */
; 843  :             flags1 = hetb->chdr.flags1;

  0012d	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  00132	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00136	89 44 24 34	 mov	 DWORD PTR flags1$[rsp], eax

; 844  :             flags2 = hetb->chdr.flags2;

  0013a	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  0013f	0f b6 40 21	 movzx	 eax, BYTE PTR [rax+33]
  00143	89 44 24 38	 mov	 DWORD PTR flags2$[rsp], eax

; 845  :         }

  00147	eb 27		 jmp	 SHORT $LN12@het_read
$LN11@het_read:

; 846  :         else
; 847  :         {
; 848  :             /*
; 849  :             || Yep, so this chunk MUST NOT have the BOR flag set
; 850  :             */
; 851  :             if( hetb->chdr.flags1 & HETHDR_FLAGS1_BOR )

  00149	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  0014e	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00152	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00157	85 c0		 test	 eax, eax
  00159	74 15		 je	 SHORT $LN18@het_read

; 852  :             {
; 853  :                 free_aligned( tbuf );

  0015b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 854  :                 return( HETE_BADBOR );

  00166	b8 fb ff ff ff	 mov	 eax, -5
  0016b	e9 e1 01 00 00	 jmp	 $LN1@het_read
$LN18@het_read:
$LN12@het_read:

; 855  :             }
; 856  :         }
; 857  : 
; 858  :         /*
; 859  :         || Compression flags from related chunks must match
; 860  :         */
; 861  :         if( (            flags1 & HETHDR_FLAGS1_COMPRESS ) !=

  00170	8b 44 24 34	 mov	 eax, DWORD PTR flags1$[rsp]
  00174	83 e0 03	 and	 eax, 3
  00177	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hetb$[rsp]
  0017c	0f b6 49 20	 movzx	 ecx, BYTE PTR [rcx+32]
  00180	83 e1 03	 and	 ecx, 3
  00183	3b c1		 cmp	 eax, ecx
  00185	74 15		 je	 SHORT $LN19@het_read

; 862  :             ( hetb->chdr.flags1 & HETHDR_FLAGS1_COMPRESS ) )
; 863  :         {
; 864  :             free_aligned( tbuf );

  00187	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 865  :             return( HETE_BADCOMPRESS );

  00192	b8 ea ff ff ff	 mov	 eax, -22
  00197	e9 b5 01 00 00	 jmp	 $LN1@het_read
$LN19@het_read:

; 866  :         }
; 867  :         if( (            flags2 & HETHDR_FLAGS2_COMPRESS ) !=

  0019c	8b 44 24 38	 mov	 eax, DWORD PTR flags2$[rsp]
  001a0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hetb$[rsp]
  001aa	0f b6 49 21	 movzx	 ecx, BYTE PTR [rcx+33]
  001ae	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  001b4	3b c1		 cmp	 eax, ecx
  001b6	74 15		 je	 SHORT $LN20@het_read

; 868  :             ( hetb->chdr.flags2 & HETHDR_FLAGS2_COMPRESS ) )
; 869  :         {
; 870  :             free_aligned( tbuf );

  001b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 871  :             return( HETE_BADCOMPRESS );

  001c3	b8 ea ff ff ff	 mov	 eax, -22
  001c8	e9 84 01 00 00	 jmp	 $LN1@het_read
$LN20@het_read:

; 872  :         }
; 873  : 
; 874  :         /*
; 875  :         || Calculate running length
; 876  :         */
; 877  :         slen = HETHDR_CLEN( hetb );

  001cd	b8 01 00 00 00	 mov	 eax, 1
  001d2	48 6b c0 01	 imul	 rax, rax, 1
  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hetb$[rsp]
  001db	0f b6 44 01 1c	 movzx	 eax, BYTE PTR [rcx+rax+28]
  001e0	c1 e0 08	 shl	 eax, 8
  001e3	b9 01 00 00 00	 mov	 ecx, 1
  001e8	48 6b c9 00	 imul	 rcx, rcx, 0
  001ec	48 8b 54 24 60	 mov	 rdx, QWORD PTR hetb$[rsp]
  001f1	0f b6 4c 0a 1c	 movzx	 ecx, BYTE PTR [rdx+rcx+28]
  001f6	03 c1		 add	 eax, ecx
  001f8	89 44 24 30	 mov	 DWORD PTR slen$[rsp], eax

; 878  :         tlen += slen;

  001fc	8b 44 24 30	 mov	 eax, DWORD PTR slen$[rsp]
  00200	8b 4c 24 28	 mov	 ecx, DWORD PTR tlen$[rsp]
  00204	03 c8		 add	 ecx, eax
  00206	8b c1		 mov	 eax, ecx
  00208	89 44 24 28	 mov	 DWORD PTR tlen$[rsp], eax

; 879  : 
; 880  :         /*
; 881  :         || Can't be bigger than HETMAX_BLOCKSIZE
; 882  :         */
; 883  :         if( tlen > HETMAX_BLOCKSIZE )

  0020c	81 7c 24 28 00
	00 20 00	 cmp	 DWORD PTR tlen$[rsp], 2097152 ; 00200000H
  00214	76 15		 jbe	 SHORT $LN21@het_read

; 884  :         {
; 885  :             free_aligned( tbuf );

  00216	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 886  :             return( HETE_OVERFLOW );

  00221	b8 f8 ff ff ff	 mov	 eax, -8
  00226	e9 26 01 00 00	 jmp	 $LN1@het_read
$LN21@het_read:

; 887  :         }
; 888  : 
; 889  :         /*
; 890  :         || Finally read in the chunk data
; 891  :         */
; 892  :         rc = (int)fread( tptr, 1, slen, hetb->fh );

  0022b	8b 44 24 30	 mov	 eax, DWORD PTR slen$[rsp]
  0022f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hetb$[rsp]
  00234	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00237	44 8b c0	 mov	 r8d, eax
  0023a	ba 01 00 00 00	 mov	 edx, 1
  0023f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tptr$[rsp]
  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0024a	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax

; 893  :         if( rc != (int)slen )

  0024e	8b 44 24 30	 mov	 eax, DWORD PTR slen$[rsp]
  00252	39 44 24 2c	 cmp	 DWORD PTR rc$[rsp], eax
  00256	74 3c		 je	 SHORT $LN22@het_read

; 894  :         {
; 895  :             if( feof( hetb->fh ) )

  00258	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  0025d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  00266	85 c0		 test	 eax, eax
  00268	74 15		 je	 SHORT $LN23@het_read

; 896  :             {
; 897  :                 free_aligned( tbuf );

  0026a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 898  :                 return( HETE_PREMEOF );

  00275	b8 f7 ff ff ff	 mov	 eax, -9
  0027a	e9 d2 00 00 00	 jmp	 $LN1@het_read
$LN23@het_read:

; 899  :             }
; 900  : 
; 901  :             free_aligned( tbuf );

  0027f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  00284	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 902  :             return( HETE_ERROR );

  0028a	b8 ff ff ff ff	 mov	 eax, -1
  0028f	e9 bd 00 00 00	 jmp	 $LN1@het_read
$LN22@het_read:

; 903  :         }
; 904  : 
; 905  :         /*
; 906  :         || Bump destination pointer to next possible location
; 907  :         */
; 908  :         tptr += slen;

  00294	8b 44 24 30	 mov	 eax, DWORD PTR slen$[rsp]
  00298	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tptr$[rsp]
  0029d	48 03 c8	 add	 rcx, rax
  002a0	48 8b c1	 mov	 rax, rcx
  002a3	48 89 44 24 40	 mov	 QWORD PTR tptr$[rsp], rax

; 909  :     }
; 910  :     while( !( hetb->chdr.flags1 & HETHDR_FLAGS1_EOR ) );

  002a8	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  002ad	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  002b1	83 e0 20	 and	 eax, 32			; 00000020H
  002b4	85 c0		 test	 eax, eax
  002b6	0f 84 9b fd ff
	ff		 je	 $LN4@het_read

; 911  : 
; 912  :     /*
; 913  :     || Save compressed length (means cblksize size and ublksize will be the
; 914  :     || same for uncompressed data)
; 915  :     */
; 916  :     hetb->cblksize = tlen;

  002bc	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  002c1	8b 4c 24 28	 mov	 ecx, DWORD PTR tlen$[rsp]
  002c5	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 917  : 
; 918  :     /*
; 919  :     || Decompress data if requested
; 920  :     */
; 921  :     if( hetb->decompress )

  002c8	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  002cd	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  002d0	c1 e8 04	 shr	 eax, 4
  002d3	83 e0 01	 and	 eax, 1
  002d6	85 c0		 test	 eax, eax
  002d8	74 5c		 je	 SHORT $LN24@het_read

; 922  :     {
; 923  :         switch( hetb->chdr.flags1 & HETHDR_FLAGS1_COMPRESS )

  002da	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  002df	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  002e3	83 e0 03	 and	 eax, 3
  002e6	89 44 24 48	 mov	 DWORD PTR tv198[rsp], eax
  002ea	83 7c 24 48 00	 cmp	 DWORD PTR tv198[rsp], 0
  002ef	74 02		 je	 SHORT $LN25@het_read
  002f1	eb 31		 jmp	 SHORT $LN28@het_read
$LN25@het_read:

; 924  :         {
; 925  :             case 0:
; 926  :                 switch( hetb->chdr.flags2 & HETHDR_FLAGS2_COMPRESS )

  002f3	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  002f8	0f b6 40 21	 movzx	 eax, BYTE PTR [rax+33]
  002fc	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00301	89 44 24 4c	 mov	 DWORD PTR tv202[rsp], eax
  00305	83 7c 24 4c 00	 cmp	 DWORD PTR tv202[rsp], 0
  0030a	74 02		 je	 SHORT $LN26@het_read
  0030c	eb 02		 jmp	 SHORT $LN27@het_read
$LN26@het_read:

; 927  :                 {
; 928  :                     case 0:
; 929  :                     break;

  0030e	eb 12		 jmp	 SHORT $LN7@het_read
$LN27@het_read:

; 930  : #if defined( HAVE_ZLIB )
; 931  :                     case HETHDR_FLAGS2_ZLIB_BUSTECH:
; 932  :                         slen = HETMAX_BLOCKSIZE;
; 933  : 
; 934  :                         rc = uncompress( sbuf, &slen, (unsigned char *)tbuf, tlen );
; 935  :                         if( rc != Z_OK )
; 936  :                         {
; 937  :                             rc = errno;
; 938  :                             free_aligned( tbuf );
; 939  :                             errno = rc;
; 940  :                             return( HETE_DECERR );
; 941  :                         }
; 942  : 
; 943  :                         tlen = slen;
; 944  :                     break;
; 945  : #endif /* defined( HAVE_ZLIB ) */
; 946  :                     default:
; 947  :                         free_aligned( tbuf );

  00310	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  00315	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 948  :                         return( HETE_UNKMETH );

  0031b	b8 f5 ff ff ff	 mov	 eax, -11
  00320	eb 2f		 jmp	 SHORT $LN1@het_read
$LN7@het_read:

; 949  :                 }
; 950  :             break;

  00322	eb 12		 jmp	 SHORT $LN5@het_read
$LN28@het_read:

; 951  : 
; 952  : #if defined( HAVE_ZLIB )
; 953  :             case HETHDR_FLAGS1_ZLIB:
; 954  :                 slen = HETMAX_BLOCKSIZE;
; 955  : 
; 956  :                 rc = uncompress( sbuf, &slen, (unsigned char *)tbuf, tlen );
; 957  :                 if( rc != Z_OK )
; 958  :                 {
; 959  :                     rc = errno;
; 960  :                     free_aligned( tbuf );
; 961  :                     errno = rc;
; 962  :                     return( HETE_DECERR );
; 963  :                 }
; 964  : 
; 965  :                 tlen = slen;
; 966  :             break;
; 967  : #endif /* defined( HAVE_ZLIB ) */
; 968  : 
; 969  : #if defined( HET_BZIP2 )
; 970  :             case HETHDR_FLAGS1_BZLIB:
; 971  : 
; 972  :                 slen = HETMAX_BLOCKSIZE;
; 973  : 
; 974  :                 bz_slen = (unsigned int) slen;
; 975  :                 bz_tlen = (unsigned int) tlen;
; 976  : 
; 977  :                 rc = BZ2_bzBuffToBuffDecompress( sbuf,
; 978  :                                                  (void *) &bz_slen,
; 979  :                                                  tbuf,
; 980  :                                                  bz_tlen,
; 981  :                                                  0,
; 982  :                                                  0 );
; 983  :                 slen = (unsigned long) bz_slen;
; 984  :                 tlen = (unsigned long) bz_tlen;
; 985  : 
; 986  :                 if (rc != BZ_OK)
; 987  :                 {
; 988  :                     rc = errno;
; 989  :                     free_aligned( tbuf );
; 990  :                     errno = rc;
; 991  :                     return( HETE_DECERR );
; 992  :                 }
; 993  : 
; 994  :                 tlen = slen;
; 995  :             break;
; 996  : #endif /* defined( HET_BZIP2 ) */
; 997  : 
; 998  :             default:
; 999  :                 free_aligned( tbuf );

  00324	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  00329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 1000 :                 return( HETE_UNKMETH );

  0032f	b8 f5 ff ff ff	 mov	 eax, -11
  00334	eb 1b		 jmp	 SHORT $LN1@het_read
$LN5@het_read:
$LN24@het_read:

; 1001 :         }
; 1002 :     }
; 1003 : 
; 1004 :     /*
; 1005 :     || Save uncompressed length
; 1006 :     */
; 1007 :     hetb->ublksize = tlen;

  00336	48 8b 44 24 60	 mov	 rax, QWORD PTR hetb$[rsp]
  0033b	8b 4c 24 28	 mov	 ecx, DWORD PTR tlen$[rsp]
  0033f	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1008 : 
; 1009 :     /*
; 1010 :     || Cleanup
; 1011 :     */
; 1012 :     free_aligned( tbuf );

  00342	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbuf$[rsp]
  00347	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 1013 : 
; 1014 :     /*
; 1015 :     || Success
; 1016 :     */
; 1017 :     return( tlen );

  0034d	8b 44 24 28	 mov	 eax, DWORD PTR tlen$[rsp]
$LN1@het_read:

; 1018 : }

  00351	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00355	c3		 ret	 0
het_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
rc$ = 32
hetb$ = 64
het_read_header PROC

; 631  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 632  :     int rc;
; 633  : 
; 634  :     /*
; 635  :     || Read in a headers worth of data
; 636  :     */
; 637  :     rc = (int)fread( &hetb->chdr, sizeof( HETHDR ), 1, hetb->fh );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0000e	48 83 c0 1c	 add	 rax, 28
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00017	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  0001a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00020	ba 06 00 00 00	 mov	 edx, 6
  00025	48 8b c8	 mov	 rcx, rax
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0002e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 638  :     if( rc != 1 )

  00032	83 7c 24 20 01	 cmp	 DWORD PTR rc$[rsp], 1
  00037	74 20		 je	 SHORT $LN2@het_read_h

; 639  :     {
; 640  :         /*
; 641  :         || Return EOT if at end of physical file
; 642  :         */
; 643  :         if( feof( hetb->fh ) )

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0003e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  00047	85 c0		 test	 eax, eax
  00049	74 07		 je	 SHORT $LN3@het_read_h

; 644  :         {
; 645  :             return( HETE_EOT );

  0004b	b8 fc ff ff ff	 mov	 eax, -4
  00050	eb 42		 jmp	 SHORT $LN1@het_read_h
$LN3@het_read_h:

; 646  :         }
; 647  : 
; 648  :         /*
; 649  :         || Something else must've happened
; 650  :         */
; 651  :         return( HETE_ERROR );

  00052	b8 ff ff ff ff	 mov	 eax, -1
  00057	eb 3b		 jmp	 SHORT $LN1@het_read_h
$LN2@het_read_h:

; 652  :     }
; 653  : 
; 654  : #if defined( HETDEBUGR )
; 655  :     printf("read hdr: pl=%d, cl=%d, f1=%02x, f2=%02x\n",
; 656  :         HETHDR_PLEN( hetb ), HETHDR_CLEN( hetb ),
; 657  :         hetb->chdr.flags1, hetb->chdr.flags2);
; 658  : #endif
; 659  : 
; 660  :     /*
; 661  :     || Bump block number if done with entire block
; 662  :     */
; 663  :     if( hetb->chdr.flags1 & ( HETHDR_FLAGS1_EOR | HETHDR_FLAGS1_TAPEMARK ) )

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0005e	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00062	83 e0 60	 and	 eax, 96			; 00000060H
  00065	85 c0		 test	 eax, eax
  00067	74 12		 je	 SHORT $LN4@het_read_h

; 664  :     {
; 665  :         hetb->cblk++;

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  0006e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00071	ff c0		 inc	 eax
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hetb$[rsp]
  00078	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN4@het_read_h:

; 666  :     }
; 667  : 
; 668  :     /*
; 669  :     || Check for tape marks
; 670  :     */
; 671  :     if( hetb->chdr.flags1 & HETHDR_FLAGS1_TAPEMARK )

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR hetb$[rsp]
  00080	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00084	83 e0 40	 and	 eax, 64			; 00000040H
  00087	85 c0		 test	 eax, eax
  00089	74 07		 je	 SHORT $LN5@het_read_h

; 672  :     {
; 673  :         return( HETE_TAPEMARK );

  0008b	b8 fe ff ff ff	 mov	 eax, -2
  00090	eb 02		 jmp	 SHORT $LN1@het_read_h
$LN5@het_read_h:

; 674  :     }
; 675  : 
; 676  :     /*
; 677  :     || Success
; 678  :     */
; 679  :     return( 0 );

  00092	33 c0		 xor	 eax, eax
$LN1@het_read_h:

; 680  : }

  00094	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00098	c3		 ret	 0
het_read_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
hetb$ = 48
het_close PROC

; 331  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 332  : 
; 333  :     /*
; 334  :     || Only free the HETB if we have one
; 335  :     */
; 336  :     if( *(hetb) != NULL )

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR hetb$[rsp]
  0000e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00012	74 2d		 je	 SHORT $LN2@het_close

; 337  :     {
; 338  :         /*
; 339  :         || Only close the file if opened
; 340  :         */
; 341  :         if( (*hetb)->fh != NULL )

  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR hetb$[rsp]
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00020	74 11		 je	 SHORT $LN3@het_close

; 342  :         {
; 343  :             fclose( (*hetb)->fh );

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR hetb$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
$LN3@het_close:

; 344  :         }
; 345  :         free( *(hetb) );

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR hetb$[rsp]
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@het_close:

; 346  :     }
; 347  : 
; 348  :     /*
; 349  :     || Reinitialize pointer
; 350  :     */
; 351  :     *hetb = NULL;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR hetb$[rsp]
  00046	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 352  : 
; 353  :     return( 0 );

  0004d	33 c0		 xor	 eax, eax

; 354  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
het_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hetlib.c
_TEXT	SEGMENT
thetb$ = 32
rc$ = 40
tv95 = 44
oflags$ = 48
omode$ = 56
pathname$ = 64
__$ArrayPad$ = 336
hetb$ = 368
filename$ = 376
flags$ = 384
het_open PROC

; 141  : {

$LN19:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 142  :     HETB *thetb;
; 143  :     char *omode;
; 144  :     int   rc;
; 145  :     int   oflags;
; 146  :     char  pathname[MAX_PATH];
; 147  : 
; 148  :     /*
; 149  :     || Initialize
; 150  :     */
; 151  :     *hetb = NULL;

  00028	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hetb$[rsp]
  00030	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 152  :     hostpath(pathname, filename, sizeof(pathname));

  00037	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0003d	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  00045	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pathname$[rsp]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 153  : 
; 154  :     /*
; 155  :     || Allocate a new HETB
; 156  :     */
; 157  :     thetb = calloc( 1, sizeof( HETB ) );

  00050	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00060	48 89 44 24 20	 mov	 QWORD PTR thetb$[rsp], rax

; 158  :     if( thetb == NULL )

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR thetb$[rsp], 0
  0006b	75 0a		 jne	 SHORT $LN2@het_open

; 159  :     {
; 160  :         return( HETE_NOMEM );

  0006d	b8 ec ff ff ff	 mov	 eax, -20
  00072	e9 cf 02 00 00	 jmp	 $LN1@het_open
$LN2@het_open:

; 161  :     }
; 162  : 
; 163  :     /*
; 164  :     || Set defaults
; 165  :     */
; 166  :     thetb->fd         = -1;

  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  0007c	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 167  :     thetb->compress   = HETDFLT_COMPRESS;

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  00088	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0008b	83 c8 08	 or	 eax, 8
  0008e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  00093	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 168  :     thetb->decompress = HETDFLT_DECOMPRESS;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  0009b	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0009e	83 c8 10	 or	 eax, 16
  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  000a6	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 169  :     thetb->method     = HETDFLT_METHOD;

  000a9	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  000ae	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000b1	83 e0 9f	 and	 eax, -97		; ffffff9fH
  000b4	83 c8 20	 or	 eax, 32			; 00000020H
  000b7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  000bc	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 170  :     thetb->level      = HETDFLT_LEVEL;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  000c4	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000c7	25 7f f8 ff ff	 and	 eax, -1921		; fffff87fH
  000cc	0f ba e8 09	 bts	 eax, 9
  000d0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  000d5	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 171  :     thetb->chksize    = HETDFLT_CHKSIZE;

  000d8	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  000dd	c7 40 0c ff ff
	00 00		 mov	 DWORD PTR [rax+12], 65535 ; 0000ffffH

; 172  : 
; 173  :     /*
; 174  :     || clear HETOPEN_CREATE if HETOPEN_READONLY is specified
; 175  :     */
; 176  :     if(flags & HETOPEN_READONLY)

  000e4	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  000eb	83 e0 02	 and	 eax, 2
  000ee	85 c0		 test	 eax, eax
  000f0	74 11		 je	 SHORT $LN3@het_open

; 177  :     {
; 178  :         flags&=~HETOPEN_CREATE;

  000f2	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  000f9	83 e0 fe	 and	 eax, -2
  000fc	89 84 24 80 01
	00 00		 mov	 DWORD PTR flags$[rsp], eax
$LN3@het_open:

; 179  :     }
; 180  :     /*
; 181  :     || Translate HET create flag to filesystem flag
; 182  :     */
; 183  :     oflags = ( ( flags & HETOPEN_CREATE ) ? O_CREAT : 0 );

  00103	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 0a		 je	 SHORT $LN17@het_open
  00111	c7 44 24 2c 00
	01 00 00	 mov	 DWORD PTR tv95[rsp], 256 ; 00000100H
  00119	eb 08		 jmp	 SHORT $LN18@het_open
$LN17@het_open:
  0011b	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN18@het_open:
  00123	8b 44 24 2c	 mov	 eax, DWORD PTR tv95[rsp]
  00127	89 44 24 30	 mov	 DWORD PTR oflags$[rsp], eax

; 184  : 
; 185  :     /*
; 186  :     || Open the tape file
; 187  :     */
; 188  :     omode = "r+b";

  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159102
  00132	48 89 44 24 38	 mov	 QWORD PTR omode$[rsp], rax

; 189  :     if(!(flags & HETOPEN_READONLY))

  00137	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0013e	83 e0 02	 and	 eax, 2
  00141	85 c0		 test	 eax, eax
  00143	75 24		 jne	 SHORT $LN4@het_open

; 190  :     {
; 191  :         thetb->fd = HOPEN( pathname, O_RDWR | O_BINARY | oflags, S_IRUSR | S_IWUSR | S_IRGRP );

  00145	8b 44 24 30	 mov	 eax, DWORD PTR oflags$[rsp]
  00149	0d 02 80 00 00	 or	 eax, 32770		; 00008002H
  0014e	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00154	8b d0		 mov	 edx, eax
  00156	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pathname$[rsp]
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00161	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  00166	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN4@het_open:

; 192  :     }
; 193  :     if( (flags & HETOPEN_READONLY) || (thetb->fd == -1 && (errno == EROFS || errno == EACCES) ) )

  00169	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00170	83 e0 02	 and	 eax, 2
  00173	85 c0		 test	 eax, eax
  00175	75 21		 jne	 SHORT $LN6@het_open
  00177	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  0017c	83 78 08 ff	 cmp	 DWORD PTR [rax+8], -1
  00180	75 53		 jne	 SHORT $LN5@het_open
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00188	83 38 1e	 cmp	 DWORD PTR [rax], 30
  0018b	74 0b		 je	 SHORT $LN7@het_open
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00193	83 38 0d	 cmp	 DWORD PTR [rax], 13
  00196	75 3d		 jne	 SHORT $LN5@het_open
$LN7@het_open:
$LN6@het_open:

; 194  :     {
; 195  :         /*
; 196  :         || Retry open if file resides on readonly file system
; 197  :         */
; 198  :         omode = "rb";

  00198	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159107
  0019f	48 89 44 24 38	 mov	 QWORD PTR omode$[rsp], rax

; 199  :         thetb->writeprotect = TRUE;

  001a4	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  001a9	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  001ac	83 c8 01	 or	 eax, 1
  001af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  001b4	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 200  :         thetb->fd = HOPEN( pathname, O_RDONLY | O_BINARY, S_IRUSR | S_IRGRP );

  001b7	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001bd	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  001c2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pathname$[rsp]
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  001cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  001d2	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN5@het_open:

; 201  :     }
; 202  : 
; 203  :     /*
; 204  :     || Error out if both opens failed
; 205  :     */
; 206  :     if( thetb->fd == -1 )

  001d5	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  001da	83 78 08 ff	 cmp	 DWORD PTR [rax+8], -1
  001de	75 15		 jne	 SHORT $LN8@het_open

; 207  :     {
; 208  :         free( thetb );

  001e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 209  :         return( HETE_ERROR );

  001eb	b8 ff ff ff ff	 mov	 eax, -1
  001f0	e9 51 01 00 00	 jmp	 $LN1@het_open
$LN8@het_open:

; 210  :     }
; 211  : 
; 212  :     /*
; 213  :     || Associate stream with file descriptor
; 214  :     */
; 215  :     thetb->fh = fdopen( thetb->fd, omode );

  001f5	48 8b 54 24 38	 mov	 rdx, QWORD PTR omode$[rsp]
  001fa	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  001ff	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fdopen
  00208	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  0020d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 216  :     if( thetb->fh == NULL )

  00210	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  00215	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00219	75 3b		 jne	 SHORT $LN9@het_open

; 217  :     {
; 218  :         rc = errno;

  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00221	8b 00		 mov	 eax, DWORD PTR [rax]
  00223	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 219  :         close( thetb->fd );

  00227	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  0022c	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 220  :         errno = rc;

  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0023b	8b 4c 24 28	 mov	 ecx, DWORD PTR rc$[rsp]
  0023f	89 08		 mov	 DWORD PTR [rax], ecx

; 221  :         free( thetb );

  00241	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 222  :         return( HETE_ERROR );

  0024c	b8 ff ff ff ff	 mov	 eax, -1
  00251	e9 f0 00 00 00	 jmp	 $LN1@het_open
$LN9@het_open:

; 223  :     }
; 224  : 
; 225  :     /*
; 226  :     || If uninitialized tape, write 2 tapemarks to make it a valid NL tape
; 227  :     */
; 228  :     rc = het_read_header( thetb );

  00256	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  0025b	e8 00 00 00 00	 call	 het_read_header
  00260	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 229  :     if( rc < 0 && rc != HETE_TAPEMARK )

  00264	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00269	0f 8d 8b 00 00
	00		 jge	 $LN10@het_open
  0026f	83 7c 24 28 fe	 cmp	 DWORD PTR rc$[rsp], -2
  00274	0f 84 80 00 00
	00		 je	 $LN10@het_open

; 230  :     {
; 231  :         if( rc != HETE_EOT )

  0027a	83 7c 24 28 fc	 cmp	 DWORD PTR rc$[rsp], -4
  0027f	74 14		 je	 SHORT $LN12@het_open

; 232  :         {
; 233  :             free( thetb );

  00281	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 234  :             return( rc );

  0028c	8b 44 24 28	 mov	 eax, DWORD PTR rc$[rsp]
  00290	e9 b1 00 00 00	 jmp	 $LN1@het_open
$LN12@het_open:

; 235  :         }
; 236  : 
; 237  :         rc = het_tapemark( thetb );

  00295	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  0029a	e8 00 00 00 00	 call	 het_tapemark
  0029f	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 238  :         if( rc < 0 )

  002a3	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  002a8	7d 14		 jge	 SHORT $LN13@het_open

; 239  :         {
; 240  :             free( thetb );

  002aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 241  :             return( rc );

  002b5	8b 44 24 28	 mov	 eax, DWORD PTR rc$[rsp]
  002b9	e9 88 00 00 00	 jmp	 $LN1@het_open
$LN13@het_open:

; 242  :         }
; 243  : 
; 244  :         rc = het_tapemark( thetb );

  002be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  002c3	e8 00 00 00 00	 call	 het_tapemark
  002c8	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 245  :         if( rc < 0 )

  002cc	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  002d1	7d 11		 jge	 SHORT $LN14@het_open

; 246  :         {
; 247  :             free( thetb );

  002d3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 248  :             return( rc );

  002de	8b 44 24 28	 mov	 eax, DWORD PTR rc$[rsp]
  002e2	eb 62		 jmp	 SHORT $LN1@het_open
$LN14@het_open:

; 249  :         }
; 250  : 
; 251  :         thetb->created = TRUE;

  002e4	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  002e9	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  002ec	0f ba e8 0b	 bts	 eax, 11
  002f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  002f5	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 252  :     }

  002f8	eb 14		 jmp	 SHORT $LN11@het_open
$LN10@het_open:

; 253  :     else
; 254  :         thetb->created = FALSE;

  002fa	48 8b 44 24 20	 mov	 rax, QWORD PTR thetb$[rsp]
  002ff	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00302	0f ba f0 0b	 btr	 eax, 11
  00306	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  0030b	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN11@het_open:

; 255  : 
; 256  :     /*
; 257  :     || Reposition tape to load point
; 258  :     */
; 259  :     rc = het_rewind( thetb );

  0030e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  00313	e8 00 00 00 00	 call	 het_rewind
  00318	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 260  :     if( rc < 0 )

  0031c	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00321	7d 11		 jge	 SHORT $LN15@het_open

; 261  :     {
; 262  :         free( thetb );

  00323	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 263  :         return( rc );

  0032e	8b 44 24 28	 mov	 eax, DWORD PTR rc$[rsp]
  00332	eb 12		 jmp	 SHORT $LN1@het_open
$LN15@het_open:

; 264  :     }
; 265  : 
; 266  :     /*
; 267  :     || Give the caller the new HETB
; 268  :     */
; 269  :     *hetb = thetb;

  00334	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hetb$[rsp]
  0033c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thetb$[rsp]
  00341	48 89 08	 mov	 QWORD PTR [rax], rcx

; 270  : 
; 271  :     return( 0 );

  00344	33 c0		 xor	 eax, eax
$LN1@het_open:

; 272  : 
; 273  : }

  00346	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0034e	48 33 cc	 xor	 rcx, rsp
  00351	e8 00 00 00 00	 call	 __security_check_cookie
  00356	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  0035d	c3		 ret	 0
het_open ENDP
_TEXT	ENDS
END
