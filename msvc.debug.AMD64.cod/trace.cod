; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s390_trace_br
PUBLIC	store_hw_noswap
PUBLIC	store_fw_noswap
PUBLIC	store_dw_noswap
PUBLIC	s390_trace_bsg
PUBLIC	s390_trace_ssar
PUBLIC	s390_trace_pc
PUBLIC	s390_trace_pr
PUBLIC	s390_trace_pt
PUBLIC	s390_trace_tr
PUBLIC	s390_is_low_address_protected
PUBLIC	z900_trace_br
PUBLIC	z900_trace_bsg
PUBLIC	z900_trace_ssar
PUBLIC	z900_trace_pc
PUBLIC	z900_trace_pr
PUBLIC	z900_trace_pt
PUBLIC	z900_trace_tr
PUBLIC	z900_trace_tg
PUBLIC	z900_trace_ms
PUBLIC	z900_is_low_address_protected
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	etod_clock:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$ETOD_shift DD imagerel ETOD_shift
	DD	imagerel ETOD_shift+501
	DD	imagerel $unwind$ETOD_shift
$pdata$s390_trace_br DD imagerel $LN5
	DD	imagerel $LN5+219
	DD	imagerel $unwind$s390_trace_br
$pdata$s390_trace_bsg DD imagerel $LN4
	DD	imagerel $LN4+259
	DD	imagerel $unwind$s390_trace_bsg
$pdata$s390_trace_ssar DD imagerel $LN5
	DD	imagerel $LN5+184
	DD	imagerel $unwind$s390_trace_ssar
$pdata$s390_trace_pc DD imagerel $LN9
	DD	imagerel $LN9+346
	DD	imagerel $unwind$s390_trace_pc
$pdata$s390_trace_pr DD imagerel $LN13
	DD	imagerel $LN13+479
	DD	imagerel $unwind$s390_trace_pr
$pdata$s390_trace_pt DD imagerel $LN5
	DD	imagerel $LN5+225
	DD	imagerel $unwind$s390_trace_pt
$pdata$s390_trace_tr DD imagerel $LN11
	DD	imagerel $LN11+578
	DD	imagerel $unwind$s390_trace_tr
$pdata$s390_get_trace_entry DD imagerel s390_get_trace_entry
	DD	imagerel s390_get_trace_entry+551
	DD	imagerel $unwind$s390_get_trace_entry
$pdata$s390_set_trace_entry DD imagerel s390_set_trace_entry
	DD	imagerel s390_set_trace_entry+205
	DD	imagerel $unwind$s390_set_trace_entry
$pdata$z900_trace_br DD imagerel $LN7
	DD	imagerel $LN7+380
	DD	imagerel $unwind$z900_trace_br
$pdata$z900_trace_bsg DD imagerel $LN6
	DD	imagerel $LN6+474
	DD	imagerel $unwind$z900_trace_bsg
$pdata$z900_trace_ssar DD imagerel $LN5
	DD	imagerel $LN5+184
	DD	imagerel $unwind$z900_trace_ssar
$pdata$z900_trace_pc DD imagerel $LN33
	DD	imagerel $LN33+2158
	DD	imagerel $unwind$z900_trace_pc
$pdata$z900_trace_pr DD imagerel $LN45
	DD	imagerel $LN45+3427
	DD	imagerel $unwind$z900_trace_pr
$pdata$z900_trace_pt DD imagerel $LN9
	DD	imagerel $LN9+655
	DD	imagerel $unwind$z900_trace_pt
$pdata$z900_trace_tr DD imagerel $LN15
	DD	imagerel $LN15+713
	DD	imagerel $unwind$z900_trace_tr
$pdata$z900_trace_tg DD imagerel $LN11
	DD	imagerel $LN11+699
	DD	imagerel $unwind$z900_trace_tg
$pdata$z900_trace_ms DD imagerel $LN17
	DD	imagerel $LN17+1170
	DD	imagerel $unwind$z900_trace_ms
$pdata$z900_get_trace_entry DD imagerel z900_get_trace_entry
	DD	imagerel z900_get_trace_entry+463
	DD	imagerel $unwind$z900_get_trace_entry
$pdata$z900_set_trace_entry DD imagerel z900_set_trace_entry
	DD	imagerel z900_set_trace_entry+214
	DD	imagerel $unwind$z900_set_trace_entry
pdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_trace_tg
	DD	025H
	DD	02a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_trace_tr
	DD	025H
	DD	02afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_trace_tr
	DD	025H
	DD	0228H
voltbl	ENDS
xdata	SEGMENT
$unwind$ETOD_shift DD 011301H
	DD	08213H
$unwind$s390_trace_br DD 011101H
	DD	0a211H
$unwind$s390_trace_bsg DD 011101H
	DD	08211H
$unwind$s390_trace_ssar DD 011201H
	DD	0a212H
$unwind$s390_trace_pc DD 010d01H
	DD	0820dH
$unwind$s390_trace_pr DD 010e01H
	DD	0820eH
$unwind$s390_trace_pt DD 011701H
	DD	0a217H
$unwind$s390_trace_tr DD 042d19H
	DD	015011bH
	DD	060137014H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s390_get_trace_entry DD 011201H
	DD	0a212H
$unwind$s390_set_trace_entry DD 011801H
	DD	02218H
$unwind$z900_trace_br DD 011201H
	DD	0a212H
$unwind$z900_trace_bsg DD 011201H
	DD	0a212H
$unwind$z900_trace_ssar DD 011201H
	DD	0a212H
$unwind$z900_trace_pc DD 021001H
	DD	0150110H
$unwind$z900_trace_pr DD 021101H
	DD	0170111H
$unwind$z900_trace_pt DD 011701H
	DD	0c217H
$unwind$z900_trace_tr DD 042d19H
	DD	015011bH
	DD	060137014H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_trace_tg DD 042d19H
	DD	013011bH
	DD	060137014H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$z900_trace_ms DD 011201H
	DD	0e212H
$unwind$z900_get_trace_entry DD 011201H
	DD	08212H
$unwind$z900_set_trace_entry DD 011801H
	DD	02218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
tv75 = 0
abs_host$ = 8
abs_guest$ = 32
raddr$ = 40
size$ = 48
regs$ = 56
z900_set_trace_entry PROC

; 421  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 422  : #if defined(_FEATURE_SIE)
; 423  : RADR abs_host;
; 424  : 
; 425  :     abs_host = raddr;

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR raddr$[rsp]
  0001d	48 89 44 24 08	 mov	 QWORD PTR abs_host$[rsp], rax

; 426  : #endif /*defined(_FEATURE_SIE)*/
; 427  : 
; 428  :     raddr += size;

  00022	48 63 44 24 30	 movsxd	 rax, DWORD PTR size$[rsp]
  00027	48 8b 4c 24 28	 mov	 rcx, QWORD PTR raddr$[rsp]
  0002c	48 03 c8	 add	 rcx, rax
  0002f	48 8b c1	 mov	 rax, rcx
  00032	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 429  : 
; 430  : #if defined(_FEATURE_SIE)
; 431  :     /* Recalculate the Guest absolute address */
; 432  :     raddr = abs_guest + (raddr - abs_host);

  00037	48 8b 44 24 08	 mov	 rax, QWORD PTR abs_host$[rsp]
  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR raddr$[rsp]
  00041	48 2b c8	 sub	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs_guest$[rsp]
  0004c	48 03 c8	 add	 rcx, rax
  0004f	48 8b c1	 mov	 rax, rcx
  00052	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 433  : #endif /*defined(_FEATURE_SIE)*/
; 434  : 
; 435  :     /* Convert trace entry absolute address back to real address */
; 436  :     raddr = APPLY_PREFIXING (raddr, regs->PX);

  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR raddr$[rsp]
  0005c	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00062	48 85 c0	 test	 rax, rax
  00065	74 21		 je	 SHORT $LN3@z900_set_t
  00067	48 8b 44 24 28	 mov	 rax, QWORD PTR raddr$[rsp]
  0006c	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00072	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  0007b	74 0b		 je	 SHORT $LN3@z900_set_t
  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR raddr$[rsp]
  00082	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  00086	eb 18		 jmp	 SHORT $LN4@z900_set_t
$LN3@z900_set_t:
  00088	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00091	48 8b 4c 24 28	 mov	 rcx, QWORD PTR raddr$[rsp]
  00096	48 33 c8	 xor	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@z900_set_t:
  000a0	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]
  000a4	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 437  : 
; 438  :     /* Return updated value of control register 12 */
; 439  :     return (regs->CR(12) & ~CR12_TRACEEA) | raddr;

  000a9	b8 08 00 00 00	 mov	 eax, 8
  000ae	48 6b c0 0d	 imul	 rax, rax, 13
  000b2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	48 ba 03 00 00
	00 00 00 00 c0	 mov	 rdx, -4611686018427387901 ; c000000000000003H
  000c1	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000c9	48 23 c2	 and	 rax, rdx
  000cc	48 0b 44 24 28	 or	 rax, QWORD PTR raddr$[rsp]

; 440  : 
; 441  : } /* end function ARCH_DEP(set_trace_entry) */

  000d1	48 83 c4 18	 add	 rsp, 24
  000d5	c3		 ret	 0
z900_set_trace_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
n$ = 48
tv129 = 56
abs_guest$ = 80
size$ = 88
regs$ = 96
z900_get_trace_entry PROC

; 370  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 371  : RADR    n;                              /* Addr of trace table entry */
; 372  : 
; 373  :     /* Obtain the trace entry address from control register 12 */
; 374  :     n = regs->CR(12) & CR12_TRACEEA;

  00012	b8 08 00 00 00	 mov	 eax, 8
  00017	48 6b c0 0d	 imul	 rax, rax, 13
  0001b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00020	48 ba fc ff ff
	ff ff ff ff 3f	 mov	 rdx, 4611686018427387900 ; 3ffffffffffffffcH
  0002a	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00032	48 23 c2	 and	 rax, rdx
  00035	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 375  : 
; 376  :     /* Apply low-address protection to trace entry address */
; 377  :     if (ARCH_DEP(is_low_address_protected) (n, regs))

  0003a	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0003f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  00044	e8 00 00 00 00	 call	 z900_is_low_address_protected
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	74 32		 je	 SHORT $LN5@z900_get_t

; 378  :     {
; 379  : #ifdef FEATURE_SUPPRESSION_ON_PROTECTION
; 380  :         regs->TEA = (n & STORAGE_KEY_PAGEMASK);

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00055	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0005b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 381  :         regs->excarid = 0;

  00067	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 3e 08 00
	00 00		 mov	 BYTE PTR [rax+2110], 0

; 382  : #endif /*FEATURE_SUPPRESSION_ON_PROTECTION*/
; 383  :         ARCH_DEP(program_interrupt) (regs, PGM_PROTECTION_EXCEPTION);

  00073	ba 04 00 00 00	 mov	 edx, 4
  00078	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN5@z900_get_t:

; 384  :     }
; 385  : 
; 386  :     /* Program check if trace entry is outside main storage */
; 387  :     if ( n > regs->mainlim )

  00082	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00087	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0008e	48 39 44 24 30	 cmp	 QWORD PTR n$[rsp], rax
  00093	76 0f		 jbe	 SHORT $LN6@z900_get_t

; 388  :         ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00095	ba 05 00 00 00	 mov	 edx, 5
  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_get_t:

; 389  : 
; 390  :     /* Program check if storing would overflow a 4K page boundary */
; 391  :     if ( ((n + size) & PAGEFRAME_PAGEMASK) != (n & PAGEFRAME_PAGEMASK) )

  000a4	48 63 44 24 58	 movsxd	 rax, DWORD PTR size$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000ae	48 03 c8	 add	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000bf	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  000c6	48 3b c1	 cmp	 rax, rcx
  000c9	74 0f		 je	 SHORT $LN7@z900_get_t

; 392  :         ARCH_DEP(program_interrupt) (regs, PGM_TRACE_TABLE_EXCEPTION);

  000cb	ba 16 00 00 00	 mov	 edx, 22
  000d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	e8 00 00 00 00	 call	 z900_program_interrupt
$LN7@z900_get_t:

; 393  : 
; 394  :     /* Convert trace entry real address to absolute address */
; 395  :     n = APPLY_PREFIXING (n, regs->PX);

  000da	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  000df	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000e5	48 85 c0	 test	 rax, rax
  000e8	74 22		 je	 SHORT $LN10@z900_get_t
  000ea	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  000ef	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  000fe	74 0c		 je	 SHORT $LN10@z900_get_t
  00100	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00105	48 89 44 24 38	 mov	 QWORD PTR tv129[rsp], rax
  0010a	eb 19		 jmp	 SHORT $LN11@z900_get_t
$LN10@z900_get_t:
  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00111	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00115	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  0011a	48 33 c8	 xor	 rcx, rax
  0011d	48 8b c1	 mov	 rax, rcx
  00120	48 89 44 24 38	 mov	 QWORD PTR tv129[rsp], rax
$LN11@z900_get_t:
  00125	48 8b 44 24 38	 mov	 rax, QWORD PTR tv129[rsp]
  0012a	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 396  : 
; 397  : #if defined(_FEATURE_SIE)
; 398  :     *abs_guest = n;

  0012f	48 8b 44 24 50	 mov	 rax, QWORD PTR abs_guest$[rsp]
  00134	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  00139	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN4@z900_get_t:

; 399  : 
; 400  :     SIE_TRANSLATE(&n, ACCTYPE_WRITE, regs);

  0013c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00141	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00147	d1 e8		 shr	 eax, 1
  00149	83 e0 01	 and	 eax, 1
  0014c	85 c0		 test	 eax, eax
  0014e	74 6b		 je	 SHORT $LN8@z900_get_t
  00150	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00155	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015b	c1 e8 02	 shr	 eax, 2
  0015e	83 e0 01	 and	 eax, 1
  00161	85 c0		 test	 eax, eax
  00163	75 56		 jne	 SHORT $LN8@z900_get_t
  00165	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00171	48 03 44 24 30	 add	 rax, QWORD PTR n$[rsp]
  00176	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0017f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00184	41 b9 02 00 00
	00		 mov	 r9d, 2
  0018a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00196	ba fd ff ff ff	 mov	 edx, -3
  0019b	48 8b c8	 mov	 rcx, rax
  0019e	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001a3	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001af	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  001b6	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax
$LN8@z900_get_t:
  001bb	33 c0		 xor	 eax, eax
  001bd	85 c0		 test	 eax, eax
  001bf	0f 85 77 ff ff
	ff		 jne	 $LN4@z900_get_t

; 401  : 
; 402  : #endif /*defined(_FEATURE_SIE)*/
; 403  : 
; 404  :     return n;

  001c5	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]

; 405  : 
; 406  : } /* end function ARCH_DEP(get_trace_entry) */

  001ca	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ce	c3		 ret	 0
z900_get_trace_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_low_address_protected
_TEXT	SEGMENT
addr$ = 8
regs$ = 16
z900_is_low_address_protected PROC			; COMDAT

; 419  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 420  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 421  :     /* For z/Arch, low-address protection applies to locations
; 422  :        0-511 (0000-01FF) and also 4096-4607 (1000-11FF) */
; 423  :     if (addr & 0xFFFFFFFFFFFFEE00ULL)

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR addr$[rsp]
  0000f	48 25 00 ee ff
	ff		 and	 rax, -4608		; ffffffffffffee00H
  00015	48 85 c0	 test	 rax, rax
  00018	74 04		 je	 SHORT $LN2@z900_is_lo

; 424  : #else
; 425  :     /* For S/370 and ESA/390, low-address protection applies
; 426  :        only to locations 0-511 */
; 427  :     if (addr > 511)
; 428  : #endif
; 429  :         return false;

  0001a	32 c0		 xor	 al, al
  0001c	eb 53		 jmp	 SHORT $LN1@z900_is_lo
$LN2@z900_is_lo:

; 430  : 
; 431  :     /* Low-address protection applies only if the low-address
; 432  :        protection control bit in control register 0 is set */
; 433  :     if (!(regs->CR(0) & CR0_LOW_PROT))

  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 01	 imul	 rax, rax, 1
  00027	48 8b 4c 24 10	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00034	48 25 00 00 00
	10		 and	 rax, 268435456		; 10000000H
  0003a	48 85 c0	 test	 rax, rax
  0003d	75 04		 jne	 SHORT $LN3@z900_is_lo

; 434  :         return false;

  0003f	32 c0		 xor	 al, al
  00041	eb 2e		 jmp	 SHORT $LN1@z900_is_lo
$LN3@z900_is_lo:

; 435  : 
; 436  : #if defined( _FEATURE_SIE )
; 437  :     /* Host low-address protection is not applied to guest
; 438  :        references to guest storage */
; 439  :     if (regs->sie_active)

  00043	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0004e	83 e0 01	 and	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	74 04		 je	 SHORT $LN4@z900_is_lo

; 440  :         return false;

  00055	32 c0		 xor	 al, al
  00057	eb 18		 jmp	 SHORT $LN1@z900_is_lo
$LN4@z900_is_lo:

; 441  : #endif
; 442  : 
; 443  :     /* Low-addr protection doesn't apply to private address spaces */
; 444  :     if (regs->dat.pvtaddr)

  00059	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00064	83 e0 01	 and	 eax, 1
  00067	85 c0		 test	 eax, eax
  00069	74 04		 je	 SHORT $LN5@z900_is_lo

; 445  :         return false;

  0006b	32 c0		 xor	 al, al
  0006d	eb 02		 jmp	 SHORT $LN1@z900_is_lo
$LN5@z900_is_lo:

; 446  : 
; 447  :     return true;      // (location *IS* low-address protected)

  0006f	b0 01		 mov	 al, 1
$LN1@z900_is_lo:

; 448  : 
; 449  : } /* end function is_low_address_protected */

  00071	c3		 ret	 0
z900_is_low_address_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
size$ = 32
raddr$ = 40
ag$ = 48
tte$1 = 56
tte$2 = 64
tte$3 = 72
tte$4 = 80
tte$5 = 88
tte$6 = 96
br$ = 128
baddr$ = 136
regs$ = 144
z900_trace_ms PROC

; 961  : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN4@z900_trace:

; 962  : RADR raddr;
; 963  : RADR ag;
; 964  : int  size;
; 965  : 
; 966  :     MAYBE_SET_PSW_IA_FROM_IP(regs);

  00012	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0001a	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00022	74 51		 je	 SHORT $LN5@z900_trace
  00024	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00034	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0003b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0003f	48 2b c1	 sub	 rax, rcx
  00042	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00051	48 03 c8	 add	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00066	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN5@z900_trace:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 97		 jne	 SHORT $LN4@z900_trace

; 967  : 
; 968  :     if(!br)

  0007b	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR br$[rsp], 0
  00083	0f 85 15 02 00
	00		 jne	 $LN6@z900_trace

; 969  :     {
; 970  :         if(!regs->psw.amode64)

  00089	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00091	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	0f 85 ae 00 00
	00		 jne	 $LN8@z900_trace

; 971  :         {
; 972  :             TRACE_F1_MS *tte;
; 973  :             size = sizeof(TRACE_F1_MS);

  000a2	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 974  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  000aa	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000b2	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  000b6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  000bb	e8 00 00 00 00	 call	 z900_get_trace_entry
  000c0	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 975  :             tte = (void*)(regs->mainstor + raddr);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000d4	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  000d9	48 89 44 24 38	 mov	 QWORD PTR tte$1[rsp], rax

; 976  :             tte->format = TRACE_F1_MS_FMT;

  000de	48 8b 44 24 38	 mov	 rax, QWORD PTR tte$1[rsp]
  000e3	c6 00 51	 mov	 BYTE PTR [rax], 81	; 00000051H

; 977  :             tte->fmt2 = TRACE_F1_MS_FM2;

  000e6	48 8b 44 24 38	 mov	 rax, QWORD PTR tte$1[rsp]
  000eb	c6 40 01 30	 mov	 BYTE PTR [rax+1], 48	; 00000030H

; 978  :             STORE_HW(tte->resv, 0);

  000ef	33 c9		 xor	 ecx, ecx
  000f1	e8 00 00 00 00	 call	 _byteswap_ushort
  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tte$1[rsp]
  000fb	48 83 c1 02	 add	 rcx, 2
  000ff	0f b7 d0	 movzx	 edx, ax
  00102	e8 00 00 00 00	 call	 store_hw_noswap

; 979  :             STORE_FW(tte->newia, regs->psw.IA | (regs->psw.amode << 31));

  00107	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00115	d1 e8		 shr	 eax, 1
  00117	83 e0 01	 and	 eax, 1
  0011a	c1 e0 1f	 shl	 eax, 31
  0011d	8b c0		 mov	 eax, eax
  0011f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  0012e	48 0b c8	 or	 rcx, rax
  00131	48 8b c1	 mov	 rax, rcx
  00134	8b c8		 mov	 ecx, eax
  00136	e8 00 00 00 00	 call	 _byteswap_ulong
  0013b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tte$1[rsp]
  00140	48 83 c1 04	 add	 rcx, 4
  00144	8b d0		 mov	 edx, eax
  00146	e8 00 00 00 00	 call	 store_fw_noswap

; 980  :         }

  0014b	e9 49 01 00 00	 jmp	 $LN9@z900_trace
$LN8@z900_trace:

; 981  :         else
; 982  :         if(regs->psw.amode64 && regs->psw.IA <= 0x7FFFFFFF)

  00150	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0015e	83 e0 01	 and	 eax, 1
  00161	85 c0		 test	 eax, eax
  00163	0f 84 a6 00 00
	00		 je	 $LN10@z900_trace
  00169	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00171	48 81 b8 88 00
	00 00 ff ff ff
	7f		 cmp	 QWORD PTR [rax+136], 2147483647 ; 7fffffffH
  0017c	0f 87 8d 00 00
	00		 ja	 $LN10@z900_trace

; 983  :         {
; 984  :             TRACE_F2_MS *tte;
; 985  :             size = sizeof(TRACE_F2_MS);

  00182	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 986  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0018a	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00192	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00196	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  0019b	e8 00 00 00 00	 call	 z900_get_trace_entry
  001a0	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 987  :             tte = (void*)(regs->mainstor + raddr);

  001a5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ad	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001b4	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  001b9	48 89 44 24 40	 mov	 QWORD PTR tte$2[rsp], rax

; 988  :             tte->format = TRACE_F2_MS_FMT;

  001be	48 8b 44 24 40	 mov	 rax, QWORD PTR tte$2[rsp]
  001c3	c6 00 51	 mov	 BYTE PTR [rax], 81	; 00000051H

; 989  :             tte->fmt2 = TRACE_F2_MS_FM2;

  001c6	48 8b 44 24 40	 mov	 rax, QWORD PTR tte$2[rsp]
  001cb	c6 40 01 20	 mov	 BYTE PTR [rax+1], 32	; 00000020H

; 990  :             STORE_HW(tte->resv, 0);

  001cf	33 c9		 xor	 ecx, ecx
  001d1	e8 00 00 00 00	 call	 _byteswap_ushort
  001d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$2[rsp]
  001db	48 83 c1 02	 add	 rcx, 2
  001df	0f b7 d0	 movzx	 edx, ax
  001e2	e8 00 00 00 00	 call	 store_hw_noswap

; 991  :             STORE_FW(tte->newia, regs->psw.IA);

  001e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  001f5	e8 00 00 00 00	 call	 _byteswap_ulong
  001fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$2[rsp]
  001ff	48 83 c1 04	 add	 rcx, 4
  00203	8b d0		 mov	 edx, eax
  00205	e8 00 00 00 00	 call	 store_fw_noswap

; 992  :         }

  0020a	e9 8a 00 00 00	 jmp	 $LN11@z900_trace
$LN10@z900_trace:

; 993  :         else
; 994  :         {
; 995  :             TRACE_F3_MS *tte;
; 996  :             size = sizeof(TRACE_F3_MS);

  0020f	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 997  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00217	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0021f	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00223	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  00228	e8 00 00 00 00	 call	 z900_get_trace_entry
  0022d	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 998  :             tte = (void*)(regs->mainstor + raddr);

  00232	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023a	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00241	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00246	48 89 44 24 48	 mov	 QWORD PTR tte$3[rsp], rax

; 999  :             tte->format = TRACE_F3_MS_FMT;

  0024b	48 8b 44 24 48	 mov	 rax, QWORD PTR tte$3[rsp]
  00250	c6 00 52	 mov	 BYTE PTR [rax], 82	; 00000052H

; 1000 :             tte->fmt2 = TRACE_F3_MS_FM2;

  00253	48 8b 44 24 48	 mov	 rax, QWORD PTR tte$3[rsp]
  00258	c6 40 01 60	 mov	 BYTE PTR [rax+1], 96	; 00000060H

; 1001 :             STORE_HW(tte->resv, 0);

  0025c	33 c9		 xor	 ecx, ecx
  0025e	e8 00 00 00 00	 call	 _byteswap_ushort
  00263	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$3[rsp]
  00268	48 83 c1 02	 add	 rcx, 2
  0026c	0f b7 d0	 movzx	 edx, ax
  0026f	e8 00 00 00 00	 call	 store_hw_noswap

; 1002 :             STORE_DW(tte->newia, regs->psw.IA);

  00274	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027c	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  00283	e8 00 00 00 00	 call	 _byteswap_uint64
  00288	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$3[rsp]
  0028d	48 83 c1 04	 add	 rcx, 4
  00291	48 8b d0	 mov	 rdx, rax
  00294	e8 00 00 00 00	 call	 store_dw_noswap
$LN11@z900_trace:
$LN9@z900_trace:

; 1003 :         }
; 1004 :     }

  00299	e9 d3 01 00 00	 jmp	 $LN7@z900_trace
$LN6@z900_trace:

; 1005 :     else
; 1006 :     {
; 1007 :         /* if currently in 64-bit, we are switching out */
; 1008 :         if(regs->psw.amode64)

  0029e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002ac	83 e0 01	 and	 eax, 1
  002af	85 c0		 test	 eax, eax
  002b1	0f 84 86 00 00
	00		 je	 $LN12@z900_trace

; 1009 :         {
; 1010 :             TRACE_F1_MSB *tte;
; 1011 :             size = sizeof(TRACE_F1_MSB);

  002b7	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 1012 :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  002bf	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002c7	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  002cb	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  002d0	e8 00 00 00 00	 call	 z900_get_trace_entry
  002d5	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 1013 :             tte = (void*)(regs->mainstor + raddr);

  002da	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e2	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002e9	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  002ee	48 89 44 24 50	 mov	 QWORD PTR tte$4[rsp], rax

; 1014 :             tte->format = TRACE_F1_MSB_FMT;

  002f3	48 8b 44 24 50	 mov	 rax, QWORD PTR tte$4[rsp]
  002f8	c6 00 51	 mov	 BYTE PTR [rax], 81	; 00000051H

; 1015 :             tte->fmt2 = TRACE_F1_MSB_FM2;

  002fb	48 8b 44 24 50	 mov	 rax, QWORD PTR tte$4[rsp]
  00300	c6 40 01 a0	 mov	 BYTE PTR [rax+1], 160	; 000000a0H

; 1016 :             STORE_HW(tte->resv, 0);

  00304	33 c9		 xor	 ecx, ecx
  00306	e8 00 00 00 00	 call	 _byteswap_ushort
  0030b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$4[rsp]
  00310	48 83 c1 02	 add	 rcx, 2
  00314	0f b7 d0	 movzx	 edx, ax
  00317	e8 00 00 00 00	 call	 store_hw_noswap

; 1017 :             STORE_FW(tte->newia, baddr);

  0031c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR baddr$[rsp]
  00323	e8 00 00 00 00	 call	 _byteswap_ulong
  00328	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$4[rsp]
  0032d	48 83 c1 04	 add	 rcx, 4
  00331	8b d0		 mov	 edx, eax
  00333	e8 00 00 00 00	 call	 store_fw_noswap

; 1018 :         }

  00338	e9 34 01 00 00	 jmp	 $LN13@z900_trace
$LN12@z900_trace:

; 1019 :         else
; 1020 :         if(!regs->psw.amode64 && baddr <= 0x7FFFFFFF)

  0033d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00345	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0034b	83 e0 01	 and	 eax, 1
  0034e	85 c0		 test	 eax, eax
  00350	0f 85 98 00 00
	00		 jne	 $LN14@z900_trace
  00356	48 81 bc 24 88
	00 00 00 ff ff
	ff 7f		 cmp	 QWORD PTR baddr$[rsp], 2147483647 ; 7fffffffH
  00362	0f 87 86 00 00
	00		 ja	 $LN14@z900_trace

; 1021 :         {
; 1022 :             TRACE_F2_MSB *tte;
; 1023 :             size = sizeof(TRACE_F2_MSB);

  00368	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 1024 :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00370	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00378	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0037c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  00381	e8 00 00 00 00	 call	 z900_get_trace_entry
  00386	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 1025 :             tte = (void*)(regs->mainstor + raddr);

  0038b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00393	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0039a	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0039f	48 89 44 24 58	 mov	 QWORD PTR tte$5[rsp], rax

; 1026 :             tte->format = TRACE_F2_MSB_FMT;

  003a4	48 8b 44 24 58	 mov	 rax, QWORD PTR tte$5[rsp]
  003a9	c6 00 51	 mov	 BYTE PTR [rax], 81	; 00000051H

; 1027 :             tte->fmt2 = TRACE_F2_MSB_FM2;

  003ac	48 8b 44 24 58	 mov	 rax, QWORD PTR tte$5[rsp]
  003b1	c6 40 01 b0	 mov	 BYTE PTR [rax+1], 176	; 000000b0H

; 1028 :             STORE_HW(tte->resv, 0);

  003b5	33 c9		 xor	 ecx, ecx
  003b7	e8 00 00 00 00	 call	 _byteswap_ushort
  003bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$5[rsp]
  003c1	48 83 c1 02	 add	 rcx, 2
  003c5	0f b7 d0	 movzx	 edx, ax
  003c8	e8 00 00 00 00	 call	 store_hw_noswap

; 1029 :             STORE_FW(tte->newia, baddr);

  003cd	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR baddr$[rsp]
  003d4	e8 00 00 00 00	 call	 _byteswap_ulong
  003d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$5[rsp]
  003de	48 83 c1 04	 add	 rcx, 4
  003e2	8b d0		 mov	 edx, eax
  003e4	e8 00 00 00 00	 call	 store_fw_noswap

; 1030 :         }

  003e9	e9 83 00 00 00	 jmp	 $LN15@z900_trace
$LN14@z900_trace:

; 1031 :         else
; 1032 :         {
; 1033 :             TRACE_F3_MSB *tte;
; 1034 :             size = sizeof(TRACE_F3_MSB);

  003ee	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 1035 :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  003f6	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003fe	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00402	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  00407	e8 00 00 00 00	 call	 z900_get_trace_entry
  0040c	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 1036 :             tte = (void*)(regs->mainstor + raddr);

  00411	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00419	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00420	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00425	48 89 44 24 60	 mov	 QWORD PTR tte$6[rsp], rax

; 1037 :             tte->format = TRACE_F3_MSB_FMT;

  0042a	48 8b 44 24 60	 mov	 rax, QWORD PTR tte$6[rsp]
  0042f	c6 00 52	 mov	 BYTE PTR [rax], 82	; 00000052H

; 1038 :             tte->fmt2 = TRACE_F3_MSB_FM2;

  00432	48 8b 44 24 60	 mov	 rax, QWORD PTR tte$6[rsp]
  00437	c6 40 01 f0	 mov	 BYTE PTR [rax+1], 240	; 000000f0H

; 1039 :             STORE_HW(tte->resv, 0);

  0043b	33 c9		 xor	 ecx, ecx
  0043d	e8 00 00 00 00	 call	 _byteswap_ushort
  00442	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$6[rsp]
  00447	48 83 c1 02	 add	 rcx, 2
  0044b	0f b7 d0	 movzx	 edx, ax
  0044e	e8 00 00 00 00	 call	 store_hw_noswap

; 1040 :             STORE_DW(tte->newia, baddr);

  00453	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR baddr$[rsp]
  0045b	e8 00 00 00 00	 call	 _byteswap_uint64
  00460	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$6[rsp]
  00465	48 83 c1 04	 add	 rcx, 4
  00469	48 8b d0	 mov	 rdx, rax
  0046c	e8 00 00 00 00	 call	 store_dw_noswap
$LN15@z900_trace:
$LN13@z900_trace:
$LN7@z900_trace:

; 1041 :         }
; 1042 :     }
; 1043 : 
; 1044 :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  00471	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00479	44 8b 44 24 20	 mov	 r8d, DWORD PTR size$[rsp]
  0047e	48 8b 54 24 28	 mov	 rdx, QWORD PTR raddr$[rsp]
  00483	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ag$[rsp]
  00488	e8 00 00 00 00	 call	 z900_set_trace_entry

; 1045 : 
; 1046 : } /* end function ARCH_DEP(trace_ms) */

  0048d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00491	c3		 ret	 0
z900_trace_ms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
i$ = 32
j$ = 36
tv74 = 40
n$ = 44
size$ = 48
dreg$ = 56
tte$1 = 64
raddr$ = 72
tv161 = 80
ag$ = 88
$T2 = 96
ETOD$ = 112
__$ArrayPad$ = 128
r1$ = 176
r3$ = 184
op$ = 192
regs$ = 200
z900_trace_tg PROC

; 1150 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1151 : RADR raddr;
; 1152 : RADR ag;
; 1153 : int  size;
; 1154 : int  i, j, n;
; 1155 : ETOD ETOD;
; 1156 : U64  dreg;
; 1157 : 
; 1158 :     {
; 1159 :         TRACE_F2_TR *tte;
; 1160 :         size = sizeof(TRACE_F2_TR);

  0002d	c7 44 24 30 90
	00 00 00	 mov	 DWORD PTR size$[rsp], 144 ; 00000090H

; 1161 :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00035	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0003d	8b 54 24 30	 mov	 edx, DWORD PTR size$[rsp]
  00041	48 8d 4c 24 58	 lea	 rcx, QWORD PTR ag$[rsp]
  00046	e8 00 00 00 00	 call	 z900_get_trace_entry
  0004b	48 89 44 24 48	 mov	 QWORD PTR raddr$[rsp], rax

; 1162 :         tte = (void*)(regs->mainstor + raddr);

  00050	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00058	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0005f	48 03 44 24 48	 add	 rax, QWORD PTR raddr$[rsp]
  00064	48 89 44 24 40	 mov	 QWORD PTR tte$1[rsp], rax

; 1163 : 
; 1164 :         /* Calculate the number of registers to be traced, minus 1 */
; 1165 :         n = ( r3 < r1 ) ? r3 + 16 - r1 : r3 - r1;

  00069	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00070	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR r3$[rsp], eax
  00077	7d 17		 jge	 SHORT $LN9@z900_trace
  00079	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00080	83 c0 10	 add	 eax, 16
  00083	2b 84 24 b0 00
	00 00		 sub	 eax, DWORD PTR r1$[rsp]
  0008a	89 44 24 28	 mov	 DWORD PTR tv74[rsp], eax
  0008e	eb 16		 jmp	 SHORT $LN10@z900_trace
$LN9@z900_trace:
  00090	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00097	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR r3$[rsp]
  0009e	2b c8		 sub	 ecx, eax
  000a0	8b c1		 mov	 eax, ecx
  000a2	89 44 24 28	 mov	 DWORD PTR tv74[rsp], eax
$LN10@z900_trace:
  000a6	8b 44 24 28	 mov	 eax, DWORD PTR tv74[rsp]
  000aa	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1166 : 
; 1167 :         /* Retrieve the extended TOD clock value including the epoch */
; 1168 :         etod_clock(regs, &ETOD, ETOD_extended);

  000ae	41 b8 03 00 00
	00		 mov	 r8d, 3
  000b4	48 8d 54 24 70	 lea	 rdx, QWORD PTR ETOD$[rsp]
  000b9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	e8 00 00 00 00	 call	 etod_clock

; 1169 : 
; 1170 :         /* Convert clock value to 80-bit trace format; clean and leave
; 1171 :          * TODEX bit 7 along with TOD clock bits 0-79
; 1172 :          */
; 1173 :         ETOD_shift(&ETOD, ETOD, 8);

  000c6	48 8d 44 24 60	 lea	 rax, QWORD PTR $T2[rsp]
  000cb	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ETOD$[rsp]
  000d0	48 8b f8	 mov	 rdi, rax
  000d3	48 8b f1	 mov	 rsi, rcx
  000d6	b9 10 00 00 00	 mov	 ecx, 16
  000db	f3 a4		 rep movsb
  000dd	41 b8 08 00 00
	00		 mov	 r8d, 8
  000e3	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T2[rsp]
  000e8	48 8d 4c 24 70	 lea	 rcx, QWORD PTR ETOD$[rsp]
  000ed	e8 00 00 00 00	 call	 ETOD_shift

; 1174 :         dreg = ETOD.high & 0x0001FFFFFFFFFFFFULL;       /* Clean up */

  000f2	48 b8 ff ff ff
	ff ff ff 01 00	 mov	 rax, 562949953421311	; 0001ffffffffffffH
  000fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ETOD$[rsp+8]
  00101	48 23 c8	 and	 rcx, rax
  00104	48 8b c1	 mov	 rax, rcx
  00107	48 89 44 24 38	 mov	 QWORD PTR dreg$[rsp], rax

; 1175 : 
; 1176 :         /* Set format information */
; 1177 :         dreg |= /* tte->format = */ ((U64)(TRACE_F2_TR_FMT | n)) << 56;

  0010c	8b 44 24 2c	 mov	 eax, DWORD PTR n$[rsp]
  00110	83 c8 70	 or	 eax, 112		; 00000070H
  00113	48 98		 cdqe
  00115	48 c1 e0 38	 shl	 rax, 56			; 00000038H
  00119	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dreg$[rsp]
  0011e	48 0b c8	 or	 rcx, rax
  00121	48 8b c1	 mov	 rax, rcx
  00124	48 89 44 24 38	 mov	 QWORD PTR dreg$[rsp], rax

; 1178 :         dreg |= /* tte->fmt2 =   */  (U64)TRACE_F2_TR_FM2        << 48;

  00129	48 b8 00 00 00
	00 00 00 80 00	 mov	 rax, 36028797018963968	; 0080000000000000H
  00133	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dreg$[rsp]
  00138	48 0b c8	 or	 rcx, rax
  0013b	48 8b c1	 mov	 rax, rcx
  0013e	48 89 44 24 38	 mov	 QWORD PTR dreg$[rsp], rax

; 1179 : 
; 1180 :         /* Store format information and bits 0-79 of the TOD clock
; 1181 :          * value
; 1182 :          */
; 1183 :         STORE_DW(tte, dreg);

  00143	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dreg$[rsp]
  00148	e8 00 00 00 00	 call	 _byteswap_uint64
  0014d	48 8b d0	 mov	 rdx, rax
  00150	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$1[rsp]
  00155	e8 00 00 00 00	 call	 store_dw_noswap

; 1184 :         STORE_FW(tte->clk48, ETOD.low >> 32);

  0015a	48 8b 44 24 70	 mov	 rax, QWORD PTR ETOD$[rsp]
  0015f	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00163	8b c8		 mov	 ecx, eax
  00165	e8 00 00 00 00	 call	 _byteswap_ulong
  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$1[rsp]
  0016f	48 83 c1 08	 add	 rcx, 8
  00173	8b d0		 mov	 edx, eax
  00175	e8 00 00 00 00	 call	 store_fw_noswap

; 1185 : 
; 1186 :         /* Store trace operand */
; 1187 : #if defined(FEATURE_025_STORE_CLOCK_FAST_FACILITY)
; 1188 :         if (FACILITY_ENABLED( 025_STORE_CLOCK_FAST, regs ))

  0017a	b8 01 00 00 00	 mov	 eax, 1
  0017f	48 6b c0 03	 imul	 rax, rax, 3
  00183	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00193	83 e0 40	 and	 eax, 64			; 00000040H
  00196	85 c0		 test	 eax, eax
  00198	74 39		 je	 SHORT $LN5@z900_trace

; 1189 :         {
; 1190 :             if ((regs->CR(0) & CR0_TRACE_TOD))

  0019a	b8 08 00 00 00	 mov	 eax, 8
  0019f	48 6b c0 01	 imul	 rax, rax, 1
  001a3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  001b0	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001b8	48 23 c2	 and	 rax, rdx
  001bb	48 85 c0	 test	 rax, rax
  001be	74 13		 je	 SHORT $LN6@z900_trace

; 1191 :             {
; 1192 :                 op &= 0xFF00FFFF;

  001c0	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  001c7	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  001cc	89 84 24 c0 00
	00 00		 mov	 DWORD PTR op$[rsp], eax
$LN6@z900_trace:
$LN5@z900_trace:

; 1193 :                 /* FIXME: OR-in model dependent code
; 1194 :                 op |= model_code << 16;
; 1195 :                  */
; 1196 :             }
; 1197 :         }
; 1198 : #endif
; 1199 :         STORE_FW(tte->operand, op);

  001d3	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR op$[rsp]
  001da	e8 00 00 00 00	 call	 _byteswap_ulong
  001df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$1[rsp]
  001e4	48 83 c1 0c	 add	 rcx, 12
  001e8	8b d0		 mov	 edx, eax
  001ea	e8 00 00 00 00	 call	 store_fw_noswap

; 1200 : 
; 1201 :         for (i = r1, j = 0; ; )

  001ef	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  001f6	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001fa	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
$LN2@z900_trace:

; 1202 :         {
; 1203 :             STORE_DW(tte->reg[j++], regs->GR_G(i));

  00202	48 8b 44 24 40	 mov	 rax, QWORD PTR tte$1[rsp]
  00207	48 83 c0 10	 add	 rax, 16
  0020b	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00210	48 c1 e1 03	 shl	 rcx, 3
  00214	48 03 c1	 add	 rax, rcx
  00217	48 89 44 24 50	 mov	 QWORD PTR tv161[rsp], rax
  0021c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00221	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00231	e8 00 00 00 00	 call	 _byteswap_uint64
  00236	48 8b d0	 mov	 rdx, rax
  00239	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv161[rsp]
  0023e	e8 00 00 00 00	 call	 store_dw_noswap
  00243	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00247	ff c0		 inc	 eax
  00249	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax

; 1204 : 
; 1205 :             /* Regdump is complete when r3 is done */
; 1206 :             if(r3 == i) break;

  0024d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00251	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR r3$[rsp], eax
  00258	75 02		 jne	 SHORT $LN7@z900_trace
  0025a	eb 17		 jmp	 SHORT $LN3@z900_trace
$LN7@z900_trace:

; 1207 : 
; 1208 :             /* Update register number and wrap */
; 1209 :             i++; i &= 15;

  0025c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00260	ff c0		 inc	 eax
  00262	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00266	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0026a	83 e0 0f	 and	 eax, 15
  0026d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1210 :         }

  00271	eb 8f		 jmp	 SHORT $LN2@z900_trace
$LN3@z900_trace:

; 1211 : 
; 1212 :     }
; 1213 : 
; 1214 :     return ARCH_DEP(set_trace_entry) (ag, raddr, size - (8 * (15 - n)), regs);

  00273	b8 0f 00 00 00	 mov	 eax, 15
  00278	2b 44 24 2c	 sub	 eax, DWORD PTR n$[rsp]
  0027c	c1 e0 03	 shl	 eax, 3
  0027f	8b 4c 24 30	 mov	 ecx, DWORD PTR size$[rsp]
  00283	2b c8		 sub	 ecx, eax
  00285	8b c1		 mov	 eax, ecx
  00287	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0028f	44 8b c0	 mov	 r8d, eax
  00292	48 8b 54 24 48	 mov	 rdx, QWORD PTR raddr$[rsp]
  00297	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ag$[rsp]
  0029c	e8 00 00 00 00	 call	 z900_set_trace_entry

; 1215 : 
; 1216 : } /* end function ARCH_DEP(trace_tg) */

  002a1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a9	48 33 cc	 xor	 rcx, rsp
  002ac	e8 00 00 00 00	 call	 __security_check_cookie
  002b1	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002b8	5f		 pop	 rdi
  002b9	5e		 pop	 rsi
  002ba	c3		 ret	 0
z900_trace_tg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
fast$1 = 32
i$ = 36
j$ = 40
tv87 = 44
tv91 = 48
n$ = 52
size$ = 56
dreg$ = 64
tte$2 = 72
raddr$ = 80
tv164 = 88
ag$ = 96
$T3 = 112
ETOD$ = 128
__$ArrayPad$ = 144
r1$ = 192
r3$ = 200
op$ = 208
regs$ = 216
z900_trace_tr PROC

; 1063 : {

$LN15:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1064 : RADR raddr;
; 1065 : RADR ag;
; 1066 : int  size;
; 1067 : int  i, j, n;
; 1068 : U64  dreg;
; 1069 : ETOD ETOD;
; 1070 : 
; 1071 :     {
; 1072 :         TRACE_F1_TR *tte;
; 1073 :         BYTE fast;
; 1074 : 
; 1075 :         size = sizeof(TRACE_F1_TR);

  0002d	c7 44 24 38 4c
	00 00 00	 mov	 DWORD PTR size$[rsp], 76 ; 0000004cH

; 1076 :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00035	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0003d	8b 54 24 38	 mov	 edx, DWORD PTR size$[rsp]
  00041	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ag$[rsp]
  00046	e8 00 00 00 00	 call	 z900_get_trace_entry
  0004b	48 89 44 24 50	 mov	 QWORD PTR raddr$[rsp], rax

; 1077 :         tte = (void*)(regs->mainstor + raddr);

  00050	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00058	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0005f	48 03 44 24 50	 add	 rax, QWORD PTR raddr$[rsp]
  00064	48 89 44 24 48	 mov	 QWORD PTR tte$2[rsp], rax

; 1078 : 
; 1079 :         /* Determine if fast clock format */
; 1080 : #if defined(FEATURE_025_STORE_CLOCK_FAST_FACILITY)
; 1081 :         if (FACILITY_ENABLED( 025_STORE_CLOCK_FAST, regs ))

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	48 6b c0 03	 imul	 rax, rax, 3
  00072	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00082	83 e0 40	 and	 eax, 64			; 00000040H
  00085	85 c0		 test	 eax, eax
  00087	74 2b		 je	 SHORT $LN5@z900_trace

; 1082 :             fast = (regs->CR(0) & CR0_TRACE_TOD) >> 31;

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0009f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000a7	48 23 c2	 and	 rax, rdx
  000aa	48 c1 e8 1f	 shr	 rax, 31
  000ae	88 44 24 20	 mov	 BYTE PTR fast$1[rsp], al
  000b2	eb 05		 jmp	 SHORT $LN6@z900_trace
$LN5@z900_trace:

; 1083 :         else
; 1084 : #endif
; 1085 :             fast = 0;

  000b4	c6 44 24 20 00	 mov	 BYTE PTR fast$1[rsp], 0
$LN6@z900_trace:

; 1086 : 
; 1087 :         /* Calculate the number of registers to be traced, minus 1 */
; 1088 :         n = ( r3 < r1 ) ? r3 + 16 - r1 : r3 - r1;

  000b9	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  000c0	39 84 24 c8 00
	00 00		 cmp	 DWORD PTR r3$[rsp], eax
  000c7	7d 17		 jge	 SHORT $LN11@z900_trace
  000c9	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  000d0	83 c0 10	 add	 eax, 16
  000d3	2b 84 24 c0 00
	00 00		 sub	 eax, DWORD PTR r1$[rsp]
  000da	89 44 24 2c	 mov	 DWORD PTR tv87[rsp], eax
  000de	eb 16		 jmp	 SHORT $LN12@z900_trace
$LN11@z900_trace:
  000e0	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  000e7	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR r3$[rsp]
  000ee	2b c8		 sub	 ecx, eax
  000f0	8b c1		 mov	 eax, ecx
  000f2	89 44 24 2c	 mov	 DWORD PTR tv87[rsp], eax
$LN12@z900_trace:
  000f6	8b 44 24 2c	 mov	 eax, DWORD PTR tv87[rsp]
  000fa	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 1089 : 
; 1090 :         /* Retrieve the TOD clock value bits 16-63 */
; 1091 :         etod_clock(regs, &ETOD, fast ? ETOD_fast : ETOD_standard);

  000fe	0f b6 44 24 20	 movzx	 eax, BYTE PTR fast$1[rsp]
  00103	85 c0		 test	 eax, eax
  00105	74 0a		 je	 SHORT $LN13@z900_trace
  00107	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  0010f	eb 08		 jmp	 SHORT $LN14@z900_trace
$LN13@z900_trace:
  00111	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv91[rsp], 2
$LN14@z900_trace:
  00119	44 8b 44 24 30	 mov	 r8d, DWORD PTR tv91[rsp]
  0011e	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR ETOD$[rsp]
  00126	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	e8 00 00 00 00	 call	 etod_clock

; 1092 :         dreg = ETOD2TOD(ETOD) & 0x0000FFFFFFFFFFFFULL;

  00133	48 8d 44 24 70	 lea	 rax, QWORD PTR $T3[rsp]
  00138	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ETOD$[rsp]
  00140	48 8b f8	 mov	 rdi, rax
  00143	48 8b f1	 mov	 rsi, rcx
  00146	b9 10 00 00 00	 mov	 ecx, 16
  0014b	f3 a4		 rep movsb
  0014d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T3[rsp]
  00152	e8 00 00 00 00	 call	 ETOD2TOD
  00157	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  00161	48 23 c1	 and	 rax, rcx
  00164	48 89 44 24 40	 mov	 QWORD PTR dreg$[rsp], rax

; 1093 : 
; 1094 :         /* Set format information */
; 1095 :         dreg |= /* tte->format = */ ((U64)(TRACE_F1_TR_FMT | n)) << 56;

  00169	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  0016d	83 c8 70	 or	 eax, 112		; 00000070H
  00170	48 98		 cdqe
  00172	48 c1 e0 38	 shl	 rax, 56			; 00000038H
  00176	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dreg$[rsp]
  0017b	48 0b c8	 or	 rcx, rax
  0017e	48 8b c1	 mov	 rax, rcx
  00181	48 89 44 24 40	 mov	 QWORD PTR dreg$[rsp], rax

; 1096 :         dreg |= /* tte->fmt2 =   */  (U64)TRACE_F1_TR_FM2        << 48;

  00186	48 8b 44 24 40	 mov	 rax, QWORD PTR dreg$[rsp]
  0018b	48 89 44 24 40	 mov	 QWORD PTR dreg$[rsp], rax

; 1097 : 
; 1098 :         /* Store format information and bits 16-63 of the TOD clock
; 1099 :          * value
; 1100 :          */
; 1101 :         STORE_DW(tte, dreg);

  00190	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dreg$[rsp]
  00195	e8 00 00 00 00	 call	 _byteswap_uint64
  0019a	48 8b d0	 mov	 rdx, rax
  0019d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$2[rsp]
  001a2	e8 00 00 00 00	 call	 store_dw_noswap

; 1102 : 
; 1103 :         /* Store trace operand */
; 1104 : #if defined(FEATURE_025_STORE_CLOCK_FAST_FACILITY)
; 1105 :         if (FACILITY_ENABLED( 025_STORE_CLOCK_FAST, regs ))

  001a7	b8 01 00 00 00	 mov	 eax, 1
  001ac	48 6b c0 03	 imul	 rax, rax, 3
  001b0	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001c0	83 e0 40	 and	 eax, 64			; 00000040H
  001c3	85 c0		 test	 eax, eax
  001c5	74 1c		 je	 SHORT $LN7@z900_trace

; 1106 :         {
; 1107 :             if (fast)

  001c7	0f b6 44 24 20	 movzx	 eax, BYTE PTR fast$1[rsp]
  001cc	85 c0		 test	 eax, eax
  001ce	74 13		 je	 SHORT $LN8@z900_trace

; 1108 :             {
; 1109 :                 op &= 0xFF00FFFF;

  001d0	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  001d7	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  001dc	89 84 24 d0 00
	00 00		 mov	 DWORD PTR op$[rsp], eax
$LN8@z900_trace:
$LN7@z900_trace:

; 1110 :                 /* FIXME: OR-in model dependent code
; 1111 :                 op |= model_code << 16;
; 1112 :                  */
; 1113 :             }
; 1114 :         }
; 1115 : #endif
; 1116 :         STORE_FW(tte->operand, op);

  001e3	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR op$[rsp]
  001ea	e8 00 00 00 00	 call	 _byteswap_ulong
  001ef	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$2[rsp]
  001f4	48 83 c1 08	 add	 rcx, 8
  001f8	8b d0		 mov	 edx, eax
  001fa	e8 00 00 00 00	 call	 store_fw_noswap

; 1117 : 
; 1118 :         for(i = r1, j = 0; ; )

  001ff	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00206	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  0020a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
$LN2@z900_trace:

; 1119 :         {
; 1120 :             STORE_FW(tte->reg[j++], regs->GR_L(i));

  00212	48 8b 44 24 48	 mov	 rax, QWORD PTR tte$2[rsp]
  00217	48 83 c0 0c	 add	 rax, 12
  0021b	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR j$[rsp]
  00220	48 c1 e1 02	 shl	 rcx, 2
  00224	48 03 c1	 add	 rax, rcx
  00227	48 89 44 24 58	 mov	 QWORD PTR tv164[rsp], rax
  0022c	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00231	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00240	e8 00 00 00 00	 call	 _byteswap_ulong
  00245	8b d0		 mov	 edx, eax
  00247	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv164[rsp]
  0024c	e8 00 00 00 00	 call	 store_fw_noswap
  00251	8b 44 24 28	 mov	 eax, DWORD PTR j$[rsp]
  00255	ff c0		 inc	 eax
  00257	89 44 24 28	 mov	 DWORD PTR j$[rsp], eax

; 1121 : 
; 1122 :             /* Regdump is complete when r3 is done */
; 1123 :             if(r3 == i) break;

  0025b	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0025f	39 84 24 c8 00
	00 00		 cmp	 DWORD PTR r3$[rsp], eax
  00266	75 02		 jne	 SHORT $LN9@z900_trace
  00268	eb 17		 jmp	 SHORT $LN3@z900_trace
$LN9@z900_trace:

; 1124 : 
; 1125 :             /* Update register number and wrap */
; 1126 :             i++; i &= 15;

  0026a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0026e	ff c0		 inc	 eax
  00270	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  00274	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00278	83 e0 0f	 and	 eax, 15
  0027b	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax

; 1127 :         }

  0027f	eb 91		 jmp	 SHORT $LN2@z900_trace
$LN3@z900_trace:

; 1128 : 
; 1129 :     }
; 1130 : 
; 1131 :     return ARCH_DEP(set_trace_entry) (ag, raddr, size - (4 * (15 - n)), regs);

  00281	b8 0f 00 00 00	 mov	 eax, 15
  00286	2b 44 24 34	 sub	 eax, DWORD PTR n$[rsp]
  0028a	c1 e0 02	 shl	 eax, 2
  0028d	8b 4c 24 38	 mov	 ecx, DWORD PTR size$[rsp]
  00291	2b c8		 sub	 ecx, eax
  00293	8b c1		 mov	 eax, ecx
  00295	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0029d	44 8b c0	 mov	 r8d, eax
  002a0	48 8b 54 24 50	 mov	 rdx, QWORD PTR raddr$[rsp]
  002a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ag$[rsp]
  002aa	e8 00 00 00 00	 call	 z900_set_trace_entry

; 1132 : 
; 1133 : } /* end function ARCH_DEP(trace_tr) */

  002af	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b7	48 33 cc	 xor	 rcx, rsp
  002ba	e8 00 00 00 00	 call	 __security_check_cookie
  002bf	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002c6	5f		 pop	 rdi
  002c7	5e		 pop	 rsi
  002c8	c3		 ret	 0
z900_trace_tr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
nbit$ = 32
size$ = 36
tv65 = 40
raddr$ = 48
tte$1 = 56
tte$2 = 64
tte$3 = 72
ag$ = 80
pti$ = 112
pasn$ = 120
gpr2$ = 128
regs$ = 136
z900_trace_pt PROC

; 899  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 900  : RADR raddr;
; 901  : RADR ag;
; 902  : int  size;
; 903  : BYTE nbit = (pti ? 1 : 0);

  00017	83 7c 24 70 00	 cmp	 DWORD PTR pti$[rsp], 0
  0001c	74 0a		 je	 SHORT $LN7@z900_trace
  0001e	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  00026	eb 08		 jmp	 SHORT $LN8@z900_trace
$LN7@z900_trace:
  00028	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN8@z900_trace:
  00030	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv65[rsp]
  00035	88 44 24 20	 mov	 BYTE PTR nbit$[rsp], al

; 904  : 
; 905  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 906  :     if(regs->psw.amode64 && gpr2 > 0xFFFFFFFFULL)

  00039	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00041	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00047	83 e0 01	 and	 eax, 1
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 b3 00 00
	00		 je	 $LN2@z900_trace
  00052	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00057	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR gpr2$[rsp], rax
  0005f	0f 86 a0 00 00
	00		 jbe	 $LN2@z900_trace

; 907  :     {
; 908  :         TRACE_F3_PT *tte;
; 909  :         size = sizeof(TRACE_F3_PT);

  00065	c7 44 24 24 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 910  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0006d	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00075	8b 54 24 24	 mov	 edx, DWORD PTR size$[rsp]
  00079	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ag$[rsp]
  0007e	e8 00 00 00 00	 call	 z900_get_trace_entry
  00083	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 911  :         tte = (void*)(regs->mainstor + raddr);

  00088	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00097	48 03 44 24 30	 add	 rax, QWORD PTR raddr$[rsp]
  0009c	48 89 44 24 38	 mov	 QWORD PTR tte$1[rsp], rax

; 912  :         tte->format = TRACE_F3_PT_FMT;

  000a1	48 8b 44 24 38	 mov	 rax, QWORD PTR tte$1[rsp]
  000a6	c6 00 32	 mov	 BYTE PTR [rax], 50	; 00000032H

; 913  :         tte->pswkey = regs->psw.pkey | TRACE_F3_PT_FM2 | nbit;

  000a9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000b5	83 c8 0c	 or	 eax, 12
  000b8	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR nbit$[rsp]
  000bd	0b c1		 or	 eax, ecx
  000bf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tte$1[rsp]
  000c4	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 914  :         STORE_HW(tte->newpasn, pasn);

  000c7	0f b7 4c 24 78	 movzx	 ecx, WORD PTR pasn$[rsp]
  000cc	e8 00 00 00 00	 call	 _byteswap_ushort
  000d1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tte$1[rsp]
  000d6	48 83 c1 02	 add	 rcx, 2
  000da	0f b7 d0	 movzx	 edx, ax
  000dd	e8 00 00 00 00	 call	 store_hw_noswap

; 915  :         STORE_DW(tte->r2, gpr2);

  000e2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR gpr2$[rsp]
  000ea	e8 00 00 00 00	 call	 _byteswap_uint64
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tte$1[rsp]
  000f4	48 83 c1 04	 add	 rcx, 4
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	e8 00 00 00 00	 call	 store_dw_noswap

; 916  :     }

  00100	e9 69 01 00 00	 jmp	 $LN3@z900_trace
$LN2@z900_trace:

; 917  :     else
; 918  :     if(regs->psw.amode64)

  00105	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	0f 84 ac 00 00
	00		 je	 $LN4@z900_trace

; 919  :     {
; 920  :         TRACE_F2_PT *tte;
; 921  :         size = sizeof(TRACE_F2_PT);

  0011e	c7 44 24 24 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 922  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00126	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0012e	8b 54 24 24	 mov	 edx, DWORD PTR size$[rsp]
  00132	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ag$[rsp]
  00137	e8 00 00 00 00	 call	 z900_get_trace_entry
  0013c	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 923  :         tte = (void*)(regs->mainstor + raddr);

  00141	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00150	48 03 44 24 30	 add	 rax, QWORD PTR raddr$[rsp]
  00155	48 89 44 24 40	 mov	 QWORD PTR tte$2[rsp], rax

; 924  :         tte->format = TRACE_F2_PT_FMT;

  0015a	48 8b 44 24 40	 mov	 rax, QWORD PTR tte$2[rsp]
  0015f	c6 00 31	 mov	 BYTE PTR [rax], 49	; 00000031H

; 925  :         tte->pswkey = regs->psw.pkey | TRACE_F2_PT_FM2 | nbit;

  00162	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0016e	83 c8 08	 or	 eax, 8
  00171	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR nbit$[rsp]
  00176	0b c1		 or	 eax, ecx
  00178	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$2[rsp]
  0017d	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 926  :         STORE_HW(tte->newpasn, pasn);

  00180	0f b7 4c 24 78	 movzx	 ecx, WORD PTR pasn$[rsp]
  00185	e8 00 00 00 00	 call	 _byteswap_ushort
  0018a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$2[rsp]
  0018f	48 83 c1 02	 add	 rcx, 2
  00193	0f b7 d0	 movzx	 edx, ax
  00196	e8 00 00 00 00	 call	 store_hw_noswap

; 927  :         STORE_FW(tte->r2, gpr2 & 0xFFFFFFFF);

  0019b	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  001a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR gpr2$[rsp]
  001a8	48 23 c8	 and	 rcx, rax
  001ab	48 8b c1	 mov	 rax, rcx
  001ae	8b c8		 mov	 ecx, eax
  001b0	e8 00 00 00 00	 call	 _byteswap_ulong
  001b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$2[rsp]
  001ba	48 83 c1 04	 add	 rcx, 4
  001be	8b d0		 mov	 edx, eax
  001c0	e8 00 00 00 00	 call	 store_fw_noswap

; 928  :     }

  001c5	e9 a4 00 00 00	 jmp	 $LN5@z900_trace
$LN4@z900_trace:

; 929  :     else
; 930  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 931  :     {
; 932  :         TRACE_F1_PT *tte;
; 933  :         size = sizeof(TRACE_F1_PT);

  001ca	c7 44 24 24 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 934  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  001d2	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001da	8b 54 24 24	 mov	 edx, DWORD PTR size$[rsp]
  001de	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ag$[rsp]
  001e3	e8 00 00 00 00	 call	 z900_get_trace_entry
  001e8	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 935  :         tte = (void*)(regs->mainstor + raddr);

  001ed	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f5	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001fc	48 03 44 24 30	 add	 rax, QWORD PTR raddr$[rsp]
  00201	48 89 44 24 48	 mov	 QWORD PTR tte$3[rsp], rax

; 936  :         tte->format = TRACE_F1_PT_FMT;

  00206	48 8b 44 24 48	 mov	 rax, QWORD PTR tte$3[rsp]
  0020b	c6 00 31	 mov	 BYTE PTR [rax], 49	; 00000031H

; 937  :         tte->pswkey = regs->psw.pkey | TRACE_F1_PT_FM2 | nbit;

  0020e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00216	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0021a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR nbit$[rsp]
  0021f	0b c1		 or	 eax, ecx
  00221	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$3[rsp]
  00226	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 938  :         STORE_HW(tte->newpasn, pasn);

  00229	0f b7 4c 24 78	 movzx	 ecx, WORD PTR pasn$[rsp]
  0022e	e8 00 00 00 00	 call	 _byteswap_ushort
  00233	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$3[rsp]
  00238	48 83 c1 02	 add	 rcx, 2
  0023c	0f b7 d0	 movzx	 edx, ax
  0023f	e8 00 00 00 00	 call	 store_hw_noswap

; 939  :         STORE_FW(tte->r2, gpr2 & 0xFFFFFFFF);

  00244	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00249	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR gpr2$[rsp]
  00251	48 23 c8	 and	 rcx, rax
  00254	48 8b c1	 mov	 rax, rcx
  00257	8b c8		 mov	 ecx, eax
  00259	e8 00 00 00 00	 call	 _byteswap_ulong
  0025e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$3[rsp]
  00263	48 83 c1 04	 add	 rcx, 4
  00267	8b d0		 mov	 edx, eax
  00269	e8 00 00 00 00	 call	 store_fw_noswap
$LN5@z900_trace:
$LN3@z900_trace:

; 940  :     }
; 941  : 
; 942  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  0026e	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00276	44 8b 44 24 24	 mov	 r8d, DWORD PTR size$[rsp]
  0027b	48 8b 54 24 30	 mov	 rdx, QWORD PTR raddr$[rsp]
  00280	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ag$[rsp]
  00285	e8 00 00 00 00	 call	 z900_set_trace_entry

; 943  : 
; 944  : } /* end function ARCH_DEP(trace_pt) */

  0028a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0028e	c3		 ret	 0
z900_trace_pt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
size$ = 32
raddr$ = 40
ag$ = 48
tv153 = 56
tv210 = 60
tv262 = 64
tv309 = 68
tv363 = 72
tv412 = 76
tte$1 = 80
tte$2 = 88
tte$3 = 96
tte$4 = 104
tte$5 = 112
tte$6 = 120
tte$7 = 128
tte$8 = 136
tte$9 = 144
tv459 = 152
tv513 = 160
tv552 = 168
newregs$ = 192
regs$ = 200
z900_trace_pr PROC

; 740  : {

$LN45:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
$LN4@z900_trace:

; 741  : RADR raddr;
; 742  : RADR ag;
; 743  : int  size;
; 744  : 
; 745  :     MAYBE_SET_PSW_IA_FROM_IP(regs);

  00011	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00019	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00021	74 51		 je	 SHORT $LN8@z900_trace
  00023	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00033	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0003a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0003e	48 2b c1	 sub	 rax, rcx
  00041	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00050	48 03 c8	 add	 rcx, rax
  00053	48 8b c1	 mov	 rax, rcx
  00056	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00065	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN8@z900_trace:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 97		 jne	 SHORT $LN4@z900_trace
$LN7@z900_trace:

; 746  :     MAYBE_SET_PSW_IA_FROM_IP(newregs);

  0007a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00082	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0008a	74 51		 je	 SHORT $LN9@z900_trace
  0008c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00094	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  0009c	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  000a3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a7	48 2b c1	 sub	 rax, rcx
  000aa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  000b2	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000b9	48 03 c8	 add	 rcx, rax
  000bc	48 8b c1	 mov	 rax, rcx
  000bf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  000c7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ce	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  000d6	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN9@z900_trace:
  000dd	33 c0		 xor	 eax, eax
  000df	85 c0		 test	 eax, eax
  000e1	75 97		 jne	 SHORT $LN7@z900_trace

; 747  : 
; 748  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 749  :     if(!regs->psw.amode64 && !newregs->psw.amode64)

  000e3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000f1	83 e0 01	 and	 eax, 1
  000f4	85 c0		 test	 eax, eax
  000f6	0f 85 44 01 00
	00		 jne	 $LN10@z900_trace
  000fc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00104	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 2b 01 00
	00		 jne	 $LN10@z900_trace

; 750  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 751  :     {
; 752  :         TRACE_F1_PR *tte;
; 753  :         size = sizeof(TRACE_F1_PR);

  00115	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 754  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0011d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00125	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00129	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  0012e	e8 00 00 00 00	 call	 z900_get_trace_entry
  00133	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 755  :         tte = (void*)(regs->mainstor + raddr);

  00138	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00147	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0014c	48 89 44 24 50	 mov	 QWORD PTR tte$1[rsp], rax

; 756  :         tte->format = TRACE_F1_PR_FMT;

  00151	48 8b 44 24 50	 mov	 rax, QWORD PTR tte$1[rsp]
  00156	c6 00 32	 mov	 BYTE PTR [rax], 50	; 00000032H

; 757  :         tte->pswkey = regs->psw.pkey | TRACE_F1_PR_FM2;

  00159	48 8b 44 24 50	 mov	 rax, QWORD PTR tte$1[rsp]
  0015e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0016a	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 758  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  0016d	b8 08 00 00 00	 mov	 eax, 8
  00172	48 6b c0 05	 imul	 rax, rax, 5
  00176	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  0017e	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  00186	e8 00 00 00 00	 call	 _byteswap_ushort
  0018b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$1[rsp]
  00190	48 83 c1 02	 add	 rcx, 2
  00194	0f b7 d0	 movzx	 edx, ax
  00197	e8 00 00 00 00	 call	 store_hw_noswap

; 759  :         STORE_FW(tte->retna, (newregs->psw.amode << 31)

  0019c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  001a4	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  001a8	83 e0 01	 and	 eax, 1
  001ab	85 c0		 test	 eax, eax
  001ad	74 0a		 je	 SHORT $LN27@z900_trace
  001af	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  001b7	eb 08		 jmp	 SHORT $LN28@z900_trace
$LN27@z900_trace:
  001b9	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN28@z900_trace:
  001c1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  001c9	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001cf	d1 e8		 shr	 eax, 1
  001d1	83 e0 01	 and	 eax, 1
  001d4	c1 e0 1f	 shl	 eax, 31
  001d7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  001df	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  001e5	0b 44 24 38	 or	 eax, DWORD PTR tv153[rsp]
  001e9	8b c8		 mov	 ecx, eax
  001eb	e8 00 00 00 00	 call	 _byteswap_ulong
  001f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$1[rsp]
  001f5	48 83 c1 04	 add	 rcx, 4
  001f9	8b d0		 mov	 edx, eax
  001fb	e8 00 00 00 00	 call	 store_fw_noswap

; 760  :                                 | newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 761  :         STORE_FW(tte->newia, (regs->psw.amode << 31)

  00200	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00208	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0020e	d1 e8		 shr	 eax, 1
  00210	83 e0 01	 and	 eax, 1
  00213	c1 e0 1f	 shl	 eax, 31
  00216	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021e	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  00224	8b c8		 mov	 ecx, eax
  00226	e8 00 00 00 00	 call	 _byteswap_ulong
  0022b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$1[rsp]
  00230	48 83 c1 08	 add	 rcx, 8
  00234	8b d0		 mov	 edx, eax
  00236	e8 00 00 00 00	 call	 store_fw_noswap

; 762  :                                  | regs->psw.IA_L);
; 763  :     }

  0023b	e9 ff 0a 00 00	 jmp	 $LN11@z900_trace
$LN10@z900_trace:

; 764  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 765  :     else
; 766  :     if(regs->psw.amode64 && regs->psw.IA_H == 0 && !newregs->psw.amode64)

  00240	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00248	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0024e	83 e0 01	 and	 eax, 1
  00251	85 c0		 test	 eax, eax
  00253	0f 84 44 01 00
	00		 je	 $LN12@z900_trace
  00259	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00261	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00268	0f 85 2f 01 00
	00		 jne	 $LN12@z900_trace
  0026e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00276	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0027c	83 e0 01	 and	 eax, 1
  0027f	85 c0		 test	 eax, eax
  00281	0f 85 16 01 00
	00		 jne	 $LN12@z900_trace

; 767  :     {
; 768  :         TRACE_F2_PR *tte;
; 769  :         size = sizeof(TRACE_F2_PR);

  00287	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 770  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0028f	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00297	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0029b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  002a0	e8 00 00 00 00	 call	 z900_get_trace_entry
  002a5	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 771  :         tte = (void*)(regs->mainstor + raddr);

  002aa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b2	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002b9	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  002be	48 89 44 24 58	 mov	 QWORD PTR tte$2[rsp], rax

; 772  :         tte->format = TRACE_F2_PR_FMT;

  002c3	48 8b 44 24 58	 mov	 rax, QWORD PTR tte$2[rsp]
  002c8	c6 00 32	 mov	 BYTE PTR [rax], 50	; 00000032H

; 773  :         tte->pswkey = regs->psw.pkey | TRACE_F2_PR_FM2;

  002cb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d3	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  002d7	83 c8 02	 or	 eax, 2
  002da	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$2[rsp]
  002df	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 774  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  002e2	b8 08 00 00 00	 mov	 eax, 8
  002e7	48 6b c0 05	 imul	 rax, rax, 5
  002eb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  002f3	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  002fb	e8 00 00 00 00	 call	 _byteswap_ushort
  00300	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$2[rsp]
  00305	48 83 c1 02	 add	 rcx, 2
  00309	0f b7 d0	 movzx	 edx, ax
  0030c	e8 00 00 00 00	 call	 store_hw_noswap

; 775  :         STORE_FW(tte->retna, (newregs->psw.amode << 31)

  00311	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00319	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0031d	83 e0 01	 and	 eax, 1
  00320	85 c0		 test	 eax, eax
  00322	74 0a		 je	 SHORT $LN29@z900_trace
  00324	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  0032c	eb 08		 jmp	 SHORT $LN30@z900_trace
$LN29@z900_trace:
  0032e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN30@z900_trace:
  00336	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  0033e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00344	d1 e8		 shr	 eax, 1
  00346	83 e0 01	 and	 eax, 1
  00349	c1 e0 1f	 shl	 eax, 31
  0034c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  00354	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  0035a	0b 44 24 3c	 or	 eax, DWORD PTR tv210[rsp]
  0035e	8b c8		 mov	 ecx, eax
  00360	e8 00 00 00 00	 call	 _byteswap_ulong
  00365	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$2[rsp]
  0036a	48 83 c1 04	 add	 rcx, 4
  0036e	8b d0		 mov	 edx, eax
  00370	e8 00 00 00 00	 call	 store_fw_noswap

; 776  :                                 | newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 777  :         STORE_FW(tte->newia, regs->psw.IA_L);

  00375	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037d	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  00383	e8 00 00 00 00	 call	 _byteswap_ulong
  00388	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$2[rsp]
  0038d	48 83 c1 08	 add	 rcx, 8
  00391	8b d0		 mov	 edx, eax
  00393	e8 00 00 00 00	 call	 store_fw_noswap

; 778  :     }

  00398	e9 a2 09 00 00	 jmp	 $LN13@z900_trace
$LN12@z900_trace:

; 779  :     else
; 780  :     if(regs->psw.amode64 && regs->psw.IA_H != 0 && !newregs->psw.amode64)

  0039d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003ab	83 e0 01	 and	 eax, 1
  003ae	85 c0		 test	 eax, eax
  003b0	0f 84 46 01 00
	00		 je	 $LN14@z900_trace
  003b6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003be	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  003c5	0f 84 31 01 00
	00		 je	 $LN14@z900_trace
  003cb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  003d3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003d9	83 e0 01	 and	 eax, 1
  003dc	85 c0		 test	 eax, eax
  003de	0f 85 18 01 00
	00		 jne	 $LN14@z900_trace

; 781  :     {
; 782  :         TRACE_F3_PR *tte;
; 783  :         size = sizeof(TRACE_F3_PR);

  003e4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR size$[rsp], 16

; 784  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  003ec	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f4	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  003f8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  003fd	e8 00 00 00 00	 call	 z900_get_trace_entry
  00402	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 785  :         tte = (void*)(regs->mainstor + raddr);

  00407	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00416	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0041b	48 89 44 24 60	 mov	 QWORD PTR tte$3[rsp], rax

; 786  :         tte->format = TRACE_F3_PR_FMT;

  00420	48 8b 44 24 60	 mov	 rax, QWORD PTR tte$3[rsp]
  00425	c6 00 33	 mov	 BYTE PTR [rax], 51	; 00000033H

; 787  :         tte->pswkey = regs->psw.pkey | TRACE_F3_PR_FM2;

  00428	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00430	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00434	83 c8 03	 or	 eax, 3
  00437	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$3[rsp]
  0043c	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 788  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  0043f	b8 08 00 00 00	 mov	 eax, 8
  00444	48 6b c0 05	 imul	 rax, rax, 5
  00448	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  00450	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  00458	e8 00 00 00 00	 call	 _byteswap_ushort
  0045d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$3[rsp]
  00462	48 83 c1 02	 add	 rcx, 2
  00466	0f b7 d0	 movzx	 edx, ax
  00469	e8 00 00 00 00	 call	 store_hw_noswap

; 789  :         STORE_FW(tte->retna, (newregs->psw.amode << 31)

  0046e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00476	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0047a	83 e0 01	 and	 eax, 1
  0047d	85 c0		 test	 eax, eax
  0047f	74 0a		 je	 SHORT $LN31@z900_trace
  00481	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv262[rsp], 1
  00489	eb 08		 jmp	 SHORT $LN32@z900_trace
$LN31@z900_trace:
  0048b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv262[rsp], 0
$LN32@z900_trace:
  00493	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  0049b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004a1	d1 e8		 shr	 eax, 1
  004a3	83 e0 01	 and	 eax, 1
  004a6	c1 e0 1f	 shl	 eax, 31
  004a9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  004b1	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  004b7	0b 44 24 40	 or	 eax, DWORD PTR tv262[rsp]
  004bb	8b c8		 mov	 ecx, eax
  004bd	e8 00 00 00 00	 call	 _byteswap_ulong
  004c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$3[rsp]
  004c7	48 83 c1 04	 add	 rcx, 4
  004cb	8b d0		 mov	 edx, eax
  004cd	e8 00 00 00 00	 call	 store_fw_noswap

; 790  :                                 | newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 791  :         STORE_DW(tte->newia, regs->psw.IA_G);

  004d2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004da	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  004e1	e8 00 00 00 00	 call	 _byteswap_uint64
  004e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$3[rsp]
  004eb	48 83 c1 08	 add	 rcx, 8
  004ef	48 8b d0	 mov	 rdx, rax
  004f2	e8 00 00 00 00	 call	 store_dw_noswap

; 792  :     }

  004f7	e9 43 08 00 00	 jmp	 $LN15@z900_trace
$LN14@z900_trace:

; 793  :     else
; 794  :     if(!regs->psw.amode64  && newregs->psw.amode64 && newregs->psw.IA_H == 0)

  004fc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00504	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0050a	83 e0 01	 and	 eax, 1
  0050d	85 c0		 test	 eax, eax
  0050f	0f 85 48 01 00
	00		 jne	 $LN16@z900_trace
  00515	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  0051d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00523	83 e0 01	 and	 eax, 1
  00526	85 c0		 test	 eax, eax
  00528	0f 84 2f 01 00
	00		 je	 $LN16@z900_trace
  0052e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00536	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  0053d	0f 85 1a 01 00
	00		 jne	 $LN16@z900_trace

; 795  :     {
; 796  :         TRACE_F4_PR *tte;
; 797  :         size = sizeof(TRACE_F4_PR);

  00543	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 798  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0054b	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00553	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00557	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  0055c	e8 00 00 00 00	 call	 z900_get_trace_entry
  00561	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 799  :         tte = (void*)(regs->mainstor + raddr);

  00566	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00575	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0057a	48 89 44 24 68	 mov	 QWORD PTR tte$4[rsp], rax

; 800  :         tte->format = TRACE_F4_PR_FMT;

  0057f	48 8b 44 24 68	 mov	 rax, QWORD PTR tte$4[rsp]
  00584	c6 00 32	 mov	 BYTE PTR [rax], 50	; 00000032H

; 801  :         tte->pswkey = regs->psw.pkey | TRACE_F4_PR_FM2;

  00587	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00593	83 c8 08	 or	 eax, 8
  00596	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tte$4[rsp]
  0059b	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 802  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  0059e	b8 08 00 00 00	 mov	 eax, 8
  005a3	48 6b c0 05	 imul	 rax, rax, 5
  005a7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  005af	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  005b7	e8 00 00 00 00	 call	 _byteswap_ushort
  005bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tte$4[rsp]
  005c1	48 83 c1 02	 add	 rcx, 2
  005c5	0f b7 d0	 movzx	 edx, ax
  005c8	e8 00 00 00 00	 call	 store_hw_noswap

; 803  :         STORE_FW(tte->retna,  newregs->psw.IA_L | PROBSTATE(&newregs->psw));

  005cd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  005d5	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  005d9	83 e0 01	 and	 eax, 1
  005dc	85 c0		 test	 eax, eax
  005de	74 0a		 je	 SHORT $LN33@z900_trace
  005e0	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv309[rsp], 1
  005e8	eb 08		 jmp	 SHORT $LN34@z900_trace
$LN33@z900_trace:
  005ea	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv309[rsp], 0
$LN34@z900_trace:
  005f2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  005fa	8b 4c 24 44	 mov	 ecx, DWORD PTR tv309[rsp]
  005fe	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00604	0b c1		 or	 eax, ecx
  00606	8b c8		 mov	 ecx, eax
  00608	e8 00 00 00 00	 call	 _byteswap_ulong
  0060d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tte$4[rsp]
  00612	48 83 c1 04	 add	 rcx, 4
  00616	8b d0		 mov	 edx, eax
  00618	e8 00 00 00 00	 call	 store_fw_noswap

; 804  :         STORE_FW(tte->newia, (regs->psw.amode << 31)

  0061d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00625	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0062b	d1 e8		 shr	 eax, 1
  0062d	83 e0 01	 and	 eax, 1
  00630	c1 e0 1f	 shl	 eax, 31
  00633	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0063b	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  00641	8b c8		 mov	 ecx, eax
  00643	e8 00 00 00 00	 call	 _byteswap_ulong
  00648	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tte$4[rsp]
  0064d	48 83 c1 08	 add	 rcx, 8
  00651	8b d0		 mov	 edx, eax
  00653	e8 00 00 00 00	 call	 store_fw_noswap

; 805  :                                  | regs->psw.IA_L);
; 806  :     }

  00658	e9 e2 06 00 00	 jmp	 $LN17@z900_trace
$LN16@z900_trace:

; 807  :     else
; 808  :     if(regs->psw.amode64 && regs->psw.IA_H == 0 && newregs->psw.amode64 && newregs->psw.IA_H == 0)

  0065d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00665	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0066b	83 e0 01	 and	 eax, 1
  0066e	85 c0		 test	 eax, eax
  00670	0f 84 45 01 00
	00		 je	 $LN18@z900_trace
  00676	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067e	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00685	0f 85 30 01 00
	00		 jne	 $LN18@z900_trace
  0068b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00693	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00699	83 e0 01	 and	 eax, 1
  0069c	85 c0		 test	 eax, eax
  0069e	0f 84 17 01 00
	00		 je	 $LN18@z900_trace
  006a4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  006ac	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  006b3	0f 85 02 01 00
	00		 jne	 $LN18@z900_trace

; 809  :     {
; 810  :         TRACE_F5_PR *tte;
; 811  :         size = sizeof(TRACE_F5_PR);

  006b9	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 812  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  006c1	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  006c9	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  006cd	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  006d2	e8 00 00 00 00	 call	 z900_get_trace_entry
  006d7	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 813  :         tte = (void*)(regs->mainstor + raddr);

  006dc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e4	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  006eb	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  006f0	48 89 44 24 70	 mov	 QWORD PTR tte$5[rsp], rax

; 814  :         tte->format = TRACE_F5_PR_FMT;

  006f5	48 8b 44 24 70	 mov	 rax, QWORD PTR tte$5[rsp]
  006fa	c6 00 32	 mov	 BYTE PTR [rax], 50	; 00000032H

; 815  :         tte->pswkey = regs->psw.pkey | TRACE_F5_PR_FM2;

  006fd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00705	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00709	83 c8 0a	 or	 eax, 10
  0070c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tte$5[rsp]
  00711	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 816  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  00714	b8 08 00 00 00	 mov	 eax, 8
  00719	48 6b c0 05	 imul	 rax, rax, 5
  0071d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  00725	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  0072d	e8 00 00 00 00	 call	 _byteswap_ushort
  00732	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tte$5[rsp]
  00737	48 83 c1 02	 add	 rcx, 2
  0073b	0f b7 d0	 movzx	 edx, ax
  0073e	e8 00 00 00 00	 call	 store_hw_noswap

; 817  :         STORE_FW(tte->retna,  newregs->psw.IA_L | PROBSTATE(&newregs->psw));

  00743	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  0074b	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0074f	83 e0 01	 and	 eax, 1
  00752	85 c0		 test	 eax, eax
  00754	74 0a		 je	 SHORT $LN35@z900_trace
  00756	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv363[rsp], 1
  0075e	eb 08		 jmp	 SHORT $LN36@z900_trace
$LN35@z900_trace:
  00760	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv363[rsp], 0
$LN36@z900_trace:
  00768	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00770	8b 4c 24 48	 mov	 ecx, DWORD PTR tv363[rsp]
  00774	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0077a	0b c1		 or	 eax, ecx
  0077c	8b c8		 mov	 ecx, eax
  0077e	e8 00 00 00 00	 call	 _byteswap_ulong
  00783	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tte$5[rsp]
  00788	48 83 c1 04	 add	 rcx, 4
  0078c	8b d0		 mov	 edx, eax
  0078e	e8 00 00 00 00	 call	 store_fw_noswap

; 818  :         STORE_FW(tte->newia, regs->psw.IA_L);

  00793	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0079b	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  007a1	e8 00 00 00 00	 call	 _byteswap_ulong
  007a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tte$5[rsp]
  007ab	48 83 c1 08	 add	 rcx, 8
  007af	8b d0		 mov	 edx, eax
  007b1	e8 00 00 00 00	 call	 store_fw_noswap

; 819  :     }

  007b6	e9 84 05 00 00	 jmp	 $LN19@z900_trace
$LN18@z900_trace:

; 820  :     else
; 821  :     if(regs->psw.amode64 && regs->psw.IA_H != 0 && newregs->psw.amode64 && newregs->psw.IA_H == 0)

  007bb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007c3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007c9	83 e0 01	 and	 eax, 1
  007cc	85 c0		 test	 eax, eax
  007ce	0f 84 47 01 00
	00		 je	 $LN20@z900_trace
  007d4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007dc	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  007e3	0f 84 32 01 00
	00		 je	 $LN20@z900_trace
  007e9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  007f1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007f7	83 e0 01	 and	 eax, 1
  007fa	85 c0		 test	 eax, eax
  007fc	0f 84 19 01 00
	00		 je	 $LN20@z900_trace
  00802	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  0080a	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00811	0f 85 04 01 00
	00		 jne	 $LN20@z900_trace

; 822  :     {
; 823  :         TRACE_F6_PR *tte;
; 824  :         size = sizeof(TRACE_F6_PR);

  00817	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR size$[rsp], 16

; 825  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0081f	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00827	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0082b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  00830	e8 00 00 00 00	 call	 z900_get_trace_entry
  00835	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 826  :         tte = (void*)(regs->mainstor + raddr);

  0083a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00842	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00849	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0084e	48 89 44 24 78	 mov	 QWORD PTR tte$6[rsp], rax

; 827  :         tte->format = TRACE_F6_PR_FMT;

  00853	48 8b 44 24 78	 mov	 rax, QWORD PTR tte$6[rsp]
  00858	c6 00 33	 mov	 BYTE PTR [rax], 51	; 00000033H

; 828  :         tte->pswkey = regs->psw.pkey | TRACE_F6_PR_FM2;

  0085b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00863	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00867	83 c8 0b	 or	 eax, 11
  0086a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tte$6[rsp]
  0086f	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 829  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  00872	b8 08 00 00 00	 mov	 eax, 8
  00877	48 6b c0 05	 imul	 rax, rax, 5
  0087b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  00883	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  0088b	e8 00 00 00 00	 call	 _byteswap_ushort
  00890	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tte$6[rsp]
  00895	48 83 c1 02	 add	 rcx, 2
  00899	0f b7 d0	 movzx	 edx, ax
  0089c	e8 00 00 00 00	 call	 store_hw_noswap

; 830  :         STORE_FW(tte->retna,  newregs->psw.IA_L | PROBSTATE(&newregs->psw));

  008a1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  008a9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  008ad	83 e0 01	 and	 eax, 1
  008b0	85 c0		 test	 eax, eax
  008b2	74 0a		 je	 SHORT $LN37@z900_trace
  008b4	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv412[rsp], 1
  008bc	eb 08		 jmp	 SHORT $LN38@z900_trace
$LN37@z900_trace:
  008be	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv412[rsp], 0
$LN38@z900_trace:
  008c6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  008ce	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv412[rsp]
  008d2	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  008d8	0b c1		 or	 eax, ecx
  008da	8b c8		 mov	 ecx, eax
  008dc	e8 00 00 00 00	 call	 _byteswap_ulong
  008e1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tte$6[rsp]
  008e6	48 83 c1 04	 add	 rcx, 4
  008ea	8b d0		 mov	 edx, eax
  008ec	e8 00 00 00 00	 call	 store_fw_noswap

; 831  :         STORE_DW(tte->newia, regs->psw.IA_G);

  008f1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008f9	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  00900	e8 00 00 00 00	 call	 _byteswap_uint64
  00905	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tte$6[rsp]
  0090a	48 83 c1 08	 add	 rcx, 8
  0090e	48 8b d0	 mov	 rdx, rax
  00911	e8 00 00 00 00	 call	 store_dw_noswap

; 832  :     }

  00916	e9 24 04 00 00	 jmp	 $LN21@z900_trace
$LN20@z900_trace:

; 833  :     else
; 834  :     if(!regs->psw.amode64 && newregs->psw.amode64 && newregs->psw.IA_H != 0)

  0091b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00923	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00929	83 e0 01	 and	 eax, 1
  0092c	85 c0		 test	 eax, eax
  0092e	0f 85 6a 01 00
	00		 jne	 $LN22@z900_trace
  00934	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  0093c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00942	83 e0 01	 and	 eax, 1
  00945	85 c0		 test	 eax, eax
  00947	0f 84 51 01 00
	00		 je	 $LN22@z900_trace
  0094d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00955	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  0095c	0f 84 3c 01 00
	00		 je	 $LN22@z900_trace

; 835  :     {
; 836  :         TRACE_F7_PR *tte;
; 837  :         size = sizeof(TRACE_F7_PR);

  00962	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR size$[rsp], 16

; 838  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0096a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00972	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00976	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  0097b	e8 00 00 00 00	 call	 z900_get_trace_entry
  00980	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 839  :         tte = (void*)(regs->mainstor + raddr);

  00985	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0098d	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00994	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00999	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tte$7[rsp], rax

; 840  :         tte->format = TRACE_F7_PR_FMT;

  009a1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tte$7[rsp]
  009a9	c6 00 33	 mov	 BYTE PTR [rax], 51	; 00000033H

; 841  :         tte->pswkey = regs->psw.pkey | TRACE_F7_PR_FM2;

  009ac	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b4	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  009b8	83 c8 0c	 or	 eax, 12
  009bb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tte$7[rsp]
  009c3	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 842  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  009c6	b8 08 00 00 00	 mov	 eax, 8
  009cb	48 6b c0 05	 imul	 rax, rax, 5
  009cf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  009d7	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  009df	e8 00 00 00 00	 call	 _byteswap_ushort
  009e4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tte$7[rsp]
  009ec	48 83 c1 02	 add	 rcx, 2
  009f0	0f b7 d0	 movzx	 edx, ax
  009f3	e8 00 00 00 00	 call	 store_hw_noswap

; 843  :         STORE_DW(tte->retna,  newregs->psw.IA_G | PROBSTATE(&newregs->psw));

  009f8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00a00	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00a04	83 e0 01	 and	 eax, 1
  00a07	85 c0		 test	 eax, eax
  00a09	74 0e		 je	 SHORT $LN39@z900_trace
  00a0b	48 c7 84 24 98
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv459[rsp], 1
  00a17	eb 0c		 jmp	 SHORT $LN40@z900_trace
$LN39@z900_trace:
  00a19	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv459[rsp], 0
$LN40@z900_trace:
  00a25	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00a2d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv459[rsp]
  00a35	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00a3c	48 0b c1	 or	 rax, rcx
  00a3f	48 8b c8	 mov	 rcx, rax
  00a42	e8 00 00 00 00	 call	 _byteswap_uint64
  00a47	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tte$7[rsp]
  00a4f	48 83 c1 04	 add	 rcx, 4
  00a53	48 8b d0	 mov	 rdx, rax
  00a56	e8 00 00 00 00	 call	 store_dw_noswap

; 844  :         STORE_FW(tte->newia, (regs->psw.amode << 31)

  00a5b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a63	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a69	d1 e8		 shr	 eax, 1
  00a6b	83 e0 01	 and	 eax, 1
  00a6e	c1 e0 1f	 shl	 eax, 31
  00a71	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a79	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  00a7f	8b c8		 mov	 ecx, eax
  00a81	e8 00 00 00 00	 call	 _byteswap_ulong
  00a86	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tte$7[rsp]
  00a8e	48 83 c1 0c	 add	 rcx, 12
  00a92	8b d0		 mov	 edx, eax
  00a94	e8 00 00 00 00	 call	 store_fw_noswap

; 845  :                                  | regs->psw.IA_L);
; 846  :     }

  00a99	e9 a1 02 00 00	 jmp	 $LN23@z900_trace
$LN22@z900_trace:

; 847  :     else
; 848  :     if(regs->psw.amode64 && regs->psw.IA_H == 0 && newregs->psw.amode64 && newregs->psw.IA_H != 0)

  00a9e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aa6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00aac	83 e0 01	 and	 eax, 1
  00aaf	85 c0		 test	 eax, eax
  00ab1	0f 84 67 01 00
	00		 je	 $LN24@z900_trace
  00ab7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00abf	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00ac6	0f 85 52 01 00
	00		 jne	 $LN24@z900_trace
  00acc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00ad4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00ada	83 e0 01	 and	 eax, 1
  00add	85 c0		 test	 eax, eax
  00adf	0f 84 39 01 00
	00		 je	 $LN24@z900_trace
  00ae5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00aed	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00af4	0f 84 24 01 00
	00		 je	 $LN24@z900_trace

; 849  :     {
; 850  :         TRACE_F8_PR *tte;
; 851  :         size = sizeof(TRACE_F8_PR);

  00afa	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR size$[rsp], 16

; 852  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00b02	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00b0a	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00b0e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  00b13	e8 00 00 00 00	 call	 z900_get_trace_entry
  00b18	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 853  :         tte = (void*)(regs->mainstor + raddr);

  00b1d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b25	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00b2c	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00b31	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tte$8[rsp], rax

; 854  :         tte->format = TRACE_F8_PR_FMT;

  00b39	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tte$8[rsp]
  00b41	c6 00 33	 mov	 BYTE PTR [rax], 51	; 00000033H

; 855  :         tte->pswkey = regs->psw.pkey | TRACE_F8_PR_FM2;

  00b44	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b4c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00b50	83 c8 0e	 or	 eax, 14
  00b53	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tte$8[rsp]
  00b5b	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 856  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  00b5e	b8 08 00 00 00	 mov	 eax, 8
  00b63	48 6b c0 05	 imul	 rax, rax, 5
  00b67	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  00b6f	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  00b77	e8 00 00 00 00	 call	 _byteswap_ushort
  00b7c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tte$8[rsp]
  00b84	48 83 c1 02	 add	 rcx, 2
  00b88	0f b7 d0	 movzx	 edx, ax
  00b8b	e8 00 00 00 00	 call	 store_hw_noswap

; 857  :         STORE_DW(tte->retna,  newregs->psw.IA_G | PROBSTATE(&newregs->psw));

  00b90	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00b98	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00b9c	83 e0 01	 and	 eax, 1
  00b9f	85 c0		 test	 eax, eax
  00ba1	74 0e		 je	 SHORT $LN41@z900_trace
  00ba3	48 c7 84 24 a0
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv513[rsp], 1
  00baf	eb 0c		 jmp	 SHORT $LN42@z900_trace
$LN41@z900_trace:
  00bb1	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv513[rsp], 0
$LN42@z900_trace:
  00bbd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00bc5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv513[rsp]
  00bcd	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00bd4	48 0b c1	 or	 rax, rcx
  00bd7	48 8b c8	 mov	 rcx, rax
  00bda	e8 00 00 00 00	 call	 _byteswap_uint64
  00bdf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tte$8[rsp]
  00be7	48 83 c1 04	 add	 rcx, 4
  00beb	48 8b d0	 mov	 rdx, rax
  00bee	e8 00 00 00 00	 call	 store_dw_noswap

; 858  :         STORE_FW(tte->newia, regs->psw.IA_L);

  00bf3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bfb	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  00c01	e8 00 00 00 00	 call	 _byteswap_ulong
  00c06	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tte$8[rsp]
  00c0e	48 83 c1 0c	 add	 rcx, 12
  00c12	8b d0		 mov	 edx, eax
  00c14	e8 00 00 00 00	 call	 store_fw_noswap

; 859  :     }

  00c19	e9 21 01 00 00	 jmp	 $LN25@z900_trace
$LN24@z900_trace:

; 860  :     else
; 861  :     /* if(regs->psw.amode64 && regs->psw.IA_H != 0 && newregs->psw.amode64 && newregs->psw.IA_H != 0) */
; 862  :     {
; 863  :         TRACE_F9_PR *tte;
; 864  :         size = sizeof(TRACE_F9_PR);

  00c1e	c7 44 24 20 14
	00 00 00	 mov	 DWORD PTR size$[rsp], 20

; 865  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00c26	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00c2e	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00c32	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  00c37	e8 00 00 00 00	 call	 z900_get_trace_entry
  00c3c	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 866  :         tte = (void*)(regs->mainstor + raddr);

  00c41	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c49	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00c50	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00c55	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tte$9[rsp], rax

; 867  :         tte->format = TRACE_F9_PR_FMT;

  00c5d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tte$9[rsp]
  00c65	c6 00 34	 mov	 BYTE PTR [rax], 52	; 00000034H

; 868  :         tte->pswkey = regs->psw.pkey | TRACE_F9_PR_FM2;

  00c68	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c70	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00c74	83 c8 0f	 or	 eax, 15
  00c77	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tte$9[rsp]
  00c7f	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 869  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  00c82	b8 08 00 00 00	 mov	 eax, 8
  00c87	48 6b c0 05	 imul	 rax, rax, 5
  00c8b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR newregs$[rsp]
  00c93	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  00c9b	e8 00 00 00 00	 call	 _byteswap_ushort
  00ca0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tte$9[rsp]
  00ca8	48 83 c1 02	 add	 rcx, 2
  00cac	0f b7 d0	 movzx	 edx, ax
  00caf	e8 00 00 00 00	 call	 store_hw_noswap

; 870  :         STORE_DW(tte->retna,  newregs->psw.IA_G | PROBSTATE(&newregs->psw));

  00cb4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00cbc	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00cc0	83 e0 01	 and	 eax, 1
  00cc3	85 c0		 test	 eax, eax
  00cc5	74 0e		 je	 SHORT $LN43@z900_trace
  00cc7	48 c7 84 24 a8
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv552[rsp], 1
  00cd3	eb 0c		 jmp	 SHORT $LN44@z900_trace
$LN43@z900_trace:
  00cd5	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv552[rsp], 0
$LN44@z900_trace:
  00ce1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR newregs$[rsp]
  00ce9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv552[rsp]
  00cf1	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00cf8	48 0b c1	 or	 rax, rcx
  00cfb	48 8b c8	 mov	 rcx, rax
  00cfe	e8 00 00 00 00	 call	 _byteswap_uint64
  00d03	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tte$9[rsp]
  00d0b	48 83 c1 04	 add	 rcx, 4
  00d0f	48 8b d0	 mov	 rdx, rax
  00d12	e8 00 00 00 00	 call	 store_dw_noswap

; 871  :         STORE_DW(tte->newia, regs->psw.IA_G);

  00d17	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d1f	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  00d26	e8 00 00 00 00	 call	 _byteswap_uint64
  00d2b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tte$9[rsp]
  00d33	48 83 c1 0c	 add	 rcx, 12
  00d37	48 8b d0	 mov	 rdx, rax
  00d3a	e8 00 00 00 00	 call	 store_dw_noswap
$LN25@z900_trace:
$LN23@z900_trace:
$LN21@z900_trace:
$LN19@z900_trace:
$LN17@z900_trace:
$LN15@z900_trace:
$LN13@z900_trace:
$LN11@z900_trace:

; 872  :     }
; 873  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 874  : 
; 875  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  00d3f	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d47	44 8b 44 24 20	 mov	 r8d, DWORD PTR size$[rsp]
  00d4c	48 8b 54 24 28	 mov	 rdx, QWORD PTR raddr$[rsp]
  00d51	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ag$[rsp]
  00d56	e8 00 00 00 00	 call	 z900_set_trace_entry

; 876  : 
; 877  : } /* end function ARCH_DEP(trace_pr) */

  00d5b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00d62	c3		 ret	 0
z900_trace_pr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
size$ = 32
raddr$ = 40
eamode$ = 48
ag$ = 56
tv192 = 64
tv234 = 68
tv313 = 72
tv387 = 76
tte$1 = 80
tte$2 = 88
tte$3 = 96
tte$4 = 104
tte$5 = 112
tte$6 = 120
tte$7 = 128
tv152 = 136
tv275 = 144
tv349 = 152
pcea$ = 176
regs$ = 184
z900_trace_pc PROC

; 599  : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@z900_trace:

; 600  : RADR raddr;
; 601  : RADR ag;
; 602  : int  size;
; 603  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 604  : int  eamode;
; 605  : #endif
; 606  : 
; 607  :     MAYBE_SET_PSW_IA_FROM_IP(regs);

  00010	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00018	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00020	74 51		 je	 SHORT $LN5@z900_trace
  00022	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00039	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0003d	48 2b c1	 sub	 rax, rcx
  00040	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0004f	48 03 c8	 add	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00064	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN5@z900_trace:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 97		 jne	 SHORT $LN4@z900_trace

; 608  : 
; 609  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 610  : 
; 611  :     eamode = regs->psw.amode64;

  00079	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00087	83 e0 01	 and	 eax, 1
  0008a	89 44 24 30	 mov	 DWORD PTR eamode$[rsp], eax

; 612  : 
; 613  :     if (ASN_AND_LX_REUSE_ENABLED(regs))

  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	48 6b c0 00	 imul	 rax, rax, 0
  00097	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  000a7	83 e0 02	 and	 eax, 2
  000aa	85 c0		 test	 eax, eax
  000ac	0f 84 89 05 00
	00		 je	 $LN6@z900_trace
  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 01	 imul	 rax, rax, 1
  000bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ca	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000cf	85 c0		 test	 eax, eax
  000d1	0f 84 64 05 00
	00		 je	 $LN6@z900_trace

; 614  :     {
; 615  :         if ((pcea & PC_BIT44) && regs->psw.amode64 && regs->psw.IA_H)

  000d7	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR pcea$[rsp]
  000de	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e3	85 c0		 test	 eax, eax
  000e5	0f 84 26 01 00
	00		 je	 $LN8@z900_trace
  000eb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000f9	83 e0 01	 and	 eax, 1
  000fc	85 c0		 test	 eax, eax
  000fe	0f 84 0d 01 00
	00		 je	 $LN8@z900_trace
  00104	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010c	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00113	0f 84 f8 00 00
	00		 je	 $LN8@z900_trace

; 616  :         {
; 617  :             /* In 64-bit mode, regardless of resulting mode, when
; 618  :                ASN-and-LX-reuse is enabled, 32-bit PC number is used,
; 619  :                and bits 0-31 of return address are not all zeros */
; 620  :             TRACE_F7_PC *tte;
; 621  :             size = sizeof(TRACE_F7_PC);

  00119	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR size$[rsp], 16

; 622  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00121	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00129	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0012d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  00132	e8 00 00 00 00	 call	 z900_get_trace_entry
  00137	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 623  :             tte = (void*)(regs->mainstor + raddr);

  0013c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00144	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0014b	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00150	48 89 44 24 50	 mov	 QWORD PTR tte$1[rsp], rax

; 624  :             tte->format = TRACE_F7_PC_FMT;

  00155	48 8b 44 24 50	 mov	 rax, QWORD PTR tte$1[rsp]
  0015a	c6 00 23	 mov	 BYTE PTR [rax], 35	; 00000023H

; 625  :             tte->pswkey = regs->psw.pkey | TRACE_F7_PC_FM2 | eamode;

  0015d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00169	83 c8 0e	 or	 eax, 14
  0016c	0b 44 24 30	 or	 eax, DWORD PTR eamode$[rsp]
  00170	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$1[rsp]
  00175	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 626  :             STORE_HW(tte->resv, 0x0000);

  00178	33 c9		 xor	 ecx, ecx
  0017a	e8 00 00 00 00	 call	 _byteswap_ushort
  0017f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$1[rsp]
  00184	48 83 c1 02	 add	 rcx, 2
  00188	0f b7 d0	 movzx	 edx, ax
  0018b	e8 00 00 00 00	 call	 store_hw_noswap

; 627  :             STORE_DW(tte->retna, regs->psw.IA_G | PROBSTATE(&regs->psw));

  00190	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0019c	83 e0 01	 and	 eax, 1
  0019f	85 c0		 test	 eax, eax
  001a1	74 0e		 je	 SHORT $LN19@z900_trace
  001a3	48 c7 84 24 88
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv152[rsp], 1
  001af	eb 0c		 jmp	 SHORT $LN20@z900_trace
$LN19@z900_trace:
  001b1	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv152[rsp], 0
$LN20@z900_trace:
  001bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  001cd	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  001d4	48 0b c1	 or	 rax, rcx
  001d7	48 8b c8	 mov	 rcx, rax
  001da	e8 00 00 00 00	 call	 _byteswap_uint64
  001df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$1[rsp]
  001e4	48 83 c1 04	 add	 rcx, 4
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 store_dw_noswap

; 628  :             STORE_FW(tte->pcnum, pcea);

  001f0	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR pcea$[rsp]
  001f7	e8 00 00 00 00	 call	 _byteswap_ulong
  001fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tte$1[rsp]
  00201	48 83 c1 0c	 add	 rcx, 12
  00205	8b d0		 mov	 edx, eax
  00207	e8 00 00 00 00	 call	 store_fw_noswap

; 629  :         }

  0020c	e9 25 04 00 00	 jmp	 $LN9@z900_trace
$LN8@z900_trace:

; 630  :         else
; 631  :         if ((pcea & PC_BIT44) && regs->psw.amode64)

  00211	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR pcea$[rsp]
  00218	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0021d	85 c0		 test	 eax, eax
  0021f	0f 84 01 01 00
	00		 je	 $LN10@z900_trace
  00225	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00233	83 e0 01	 and	 eax, 1
  00236	85 c0		 test	 eax, eax
  00238	0f 84 e8 00 00
	00		 je	 $LN10@z900_trace

; 632  :         {
; 633  :             /* In 64-bit mode, regardless of resulting mode, when
; 634  :                ASN-and-LX-reuse is enabled, 32-bit PC number is used,
; 635  :                and bits 0-31 of return address are all zeros */
; 636  :             TRACE_F6_PC *tte;
; 637  :             size = sizeof(TRACE_F6_PC);

  0023e	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 638  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00246	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0024e	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00252	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  00257	e8 00 00 00 00	 call	 z900_get_trace_entry
  0025c	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 639  :             tte = (void*)(regs->mainstor + raddr);

  00261	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00269	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00270	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00275	48 89 44 24 58	 mov	 QWORD PTR tte$2[rsp], rax

; 640  :             tte->format = TRACE_F6_PC_FMT;

  0027a	48 8b 44 24 58	 mov	 rax, QWORD PTR tte$2[rsp]
  0027f	c6 00 22	 mov	 BYTE PTR [rax], 34	; 00000022H

; 641  :             tte->pswkey = regs->psw.pkey | TRACE_F6_PC_FM2 | eamode;

  00282	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0028e	83 c8 0a	 or	 eax, 10
  00291	0b 44 24 30	 or	 eax, DWORD PTR eamode$[rsp]
  00295	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$2[rsp]
  0029a	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 642  :             STORE_HW(tte->resv, 0x0000);

  0029d	33 c9		 xor	 ecx, ecx
  0029f	e8 00 00 00 00	 call	 _byteswap_ushort
  002a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$2[rsp]
  002a9	48 83 c1 02	 add	 rcx, 2
  002ad	0f b7 d0	 movzx	 edx, ax
  002b0	e8 00 00 00 00	 call	 store_hw_noswap

; 643  :             STORE_FW(tte->retna, regs->psw.IA_L | PROBSTATE(&regs->psw));

  002b5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  002c1	83 e0 01	 and	 eax, 1
  002c4	85 c0		 test	 eax, eax
  002c6	74 0a		 je	 SHORT $LN21@z900_trace
  002c8	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  002d0	eb 08		 jmp	 SHORT $LN22@z900_trace
$LN21@z900_trace:
  002d2	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN22@z900_trace:
  002da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e2	8b 4c 24 40	 mov	 ecx, DWORD PTR tv192[rsp]
  002e6	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002ec	0b c1		 or	 eax, ecx
  002ee	8b c8		 mov	 ecx, eax
  002f0	e8 00 00 00 00	 call	 _byteswap_ulong
  002f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$2[rsp]
  002fa	48 83 c1 04	 add	 rcx, 4
  002fe	8b d0		 mov	 edx, eax
  00300	e8 00 00 00 00	 call	 store_fw_noswap

; 644  :             STORE_FW(tte->pcnum, pcea);

  00305	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR pcea$[rsp]
  0030c	e8 00 00 00 00	 call	 _byteswap_ulong
  00311	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tte$2[rsp]
  00316	48 83 c1 08	 add	 rcx, 8
  0031a	8b d0		 mov	 edx, eax
  0031c	e8 00 00 00 00	 call	 store_fw_noswap

; 645  :         }

  00321	e9 10 03 00 00	 jmp	 $LN11@z900_trace
$LN10@z900_trace:

; 646  :         else
; 647  :         if ((pcea & PC_BIT44))

  00326	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR pcea$[rsp]
  0032d	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00332	85 c0		 test	 eax, eax
  00334	0f 84 fc 00 00
	00		 je	 $LN12@z900_trace

; 648  :         {
; 649  :             /* In 24-bit or 31-bit mode, regardless of resulting mode, when
; 650  :                ASN-and-LX-reuse is enabled and 32-bit PC number is used */
; 651  :             TRACE_F5_PC *tte;
; 652  :             size = sizeof(TRACE_F5_PC);

  0033a	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 653  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00342	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0034a	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0034e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  00353	e8 00 00 00 00	 call	 z900_get_trace_entry
  00358	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 654  :             tte = (void*)(regs->mainstor + raddr);

  0035d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00365	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0036c	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00371	48 89 44 24 60	 mov	 QWORD PTR tte$3[rsp], rax

; 655  :             tte->format = TRACE_F5_PC_FMT;

  00376	48 8b 44 24 60	 mov	 rax, QWORD PTR tte$3[rsp]
  0037b	c6 00 22	 mov	 BYTE PTR [rax], 34	; 00000022H

; 656  :             tte->pswkey = regs->psw.pkey | TRACE_F5_PC_FM2 | eamode;

  0037e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00386	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0038a	83 c8 08	 or	 eax, 8
  0038d	0b 44 24 30	 or	 eax, DWORD PTR eamode$[rsp]
  00391	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$3[rsp]
  00396	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 657  :             STORE_HW(tte->resv, 0x0000);

  00399	33 c9		 xor	 ecx, ecx
  0039b	e8 00 00 00 00	 call	 _byteswap_ushort
  003a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$3[rsp]
  003a5	48 83 c1 02	 add	 rcx, 2
  003a9	0f b7 d0	 movzx	 edx, ax
  003ac	e8 00 00 00 00	 call	 store_hw_noswap

; 658  :             STORE_FW(tte->retna, (regs->psw.amode << 31) | regs->psw.IA_L | PROBSTATE(&regs->psw));

  003b1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  003bd	83 e0 01	 and	 eax, 1
  003c0	85 c0		 test	 eax, eax
  003c2	74 0a		 je	 SHORT $LN23@z900_trace
  003c4	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv234[rsp], 1
  003cc	eb 08		 jmp	 SHORT $LN24@z900_trace
$LN23@z900_trace:
  003ce	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
$LN24@z900_trace:
  003d6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003de	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003e4	d1 e8		 shr	 eax, 1
  003e6	83 e0 01	 and	 eax, 1
  003e9	c1 e0 1f	 shl	 eax, 31
  003ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f4	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  003fa	0b 44 24 44	 or	 eax, DWORD PTR tv234[rsp]
  003fe	8b c8		 mov	 ecx, eax
  00400	e8 00 00 00 00	 call	 _byteswap_ulong
  00405	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$3[rsp]
  0040a	48 83 c1 04	 add	 rcx, 4
  0040e	8b d0		 mov	 edx, eax
  00410	e8 00 00 00 00	 call	 store_fw_noswap

; 659  :             STORE_FW(tte->pcnum, pcea);

  00415	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR pcea$[rsp]
  0041c	e8 00 00 00 00	 call	 _byteswap_ulong
  00421	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tte$3[rsp]
  00426	48 83 c1 08	 add	 rcx, 8
  0042a	8b d0		 mov	 edx, eax
  0042c	e8 00 00 00 00	 call	 store_fw_noswap

; 660  :         }

  00431	e9 00 02 00 00	 jmp	 $LN13@z900_trace
$LN12@z900_trace:

; 661  :         else
; 662  :         if(regs->psw.amode64)

  00436	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00444	83 e0 01	 and	 eax, 1
  00447	85 c0		 test	 eax, eax
  00449	0f 84 f4 00 00
	00		 je	 $LN14@z900_trace

; 663  :         {
; 664  :             /* In 64-bit mode, regardless of resulting mode, when
; 665  :                ASN-and-LX-reuse is enabled and 20-bit PC number is used */
; 666  :             TRACE_F4_PC *tte;
; 667  :             size = sizeof(TRACE_F4_PC);

  0044f	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 668  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00457	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0045f	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00463	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  00468	e8 00 00 00 00	 call	 z900_get_trace_entry
  0046d	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 669  :             tte = (void*)(regs->mainstor + raddr);

  00472	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047a	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00481	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00486	48 89 44 24 68	 mov	 QWORD PTR tte$4[rsp], rax

; 670  :             tte->format = TRACE_F4_PC_FMT;

  0048b	48 8b 44 24 68	 mov	 rax, QWORD PTR tte$4[rsp]
  00490	c6 00 22	 mov	 BYTE PTR [rax], 34	; 00000022H

; 671  :             tte->pswkey_pcnum_hi = regs->psw.pkey | ((pcea & 0xF0000) >> 16);

  00493	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0049b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0049f	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR pcea$[rsp]
  004a6	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  004ac	c1 e9 10	 shr	 ecx, 16
  004af	0b c1		 or	 eax, ecx
  004b1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tte$4[rsp]
  004b6	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 672  :             STORE_HW(tte->pcnum_lo, pcea & 0x0FFFF);

  004b9	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR pcea$[rsp]
  004c0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  004c5	0f b7 c8	 movzx	 ecx, ax
  004c8	e8 00 00 00 00	 call	 _byteswap_ushort
  004cd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tte$4[rsp]
  004d2	48 83 c1 02	 add	 rcx, 2
  004d6	0f b7 d0	 movzx	 edx, ax
  004d9	e8 00 00 00 00	 call	 store_hw_noswap

; 673  :             STORE_DW(tte->retna, regs->psw.IA_G | PROBSTATE(&regs->psw));

  004de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e6	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  004ea	83 e0 01	 and	 eax, 1
  004ed	85 c0		 test	 eax, eax
  004ef	74 0e		 je	 SHORT $LN25@z900_trace
  004f1	48 c7 84 24 90
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv275[rsp], 1
  004fd	eb 0c		 jmp	 SHORT $LN26@z900_trace
$LN25@z900_trace:
  004ff	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv275[rsp], 0
$LN26@z900_trace:
  0050b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00513	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv275[rsp]
  0051b	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00522	48 0b c1	 or	 rax, rcx
  00525	48 8b c8	 mov	 rcx, rax
  00528	e8 00 00 00 00	 call	 _byteswap_uint64
  0052d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tte$4[rsp]
  00532	48 83 c1 04	 add	 rcx, 4
  00536	48 8b d0	 mov	 rdx, rax
  00539	e8 00 00 00 00	 call	 store_dw_noswap

; 674  :         }

  0053e	e9 f3 00 00 00	 jmp	 $LN15@z900_trace
$LN14@z900_trace:

; 675  :         else
; 676  :         {
; 677  :             /* In 24-bit or 31-bit mode, regardless of resulting mode, when
; 678  :                ASN-and-LX-reuse is enabled and 20-bit PC number is used */
; 679  :             TRACE_F3_PC *tte;
; 680  :             size = sizeof(TRACE_F3_PC);

  00543	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 681  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0054b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00553	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00557	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  0055c	e8 00 00 00 00	 call	 z900_get_trace_entry
  00561	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 682  :             tte = (void*)(regs->mainstor + raddr);

  00566	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00575	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0057a	48 89 44 24 70	 mov	 QWORD PTR tte$5[rsp], rax

; 683  :             tte->format = TRACE_F3_PC_FMT;

  0057f	48 8b 44 24 70	 mov	 rax, QWORD PTR tte$5[rsp]
  00584	c6 00 21	 mov	 BYTE PTR [rax], 33	; 00000021H

; 684  :             tte->pswkey_pcnum_hi = regs->psw.pkey | ((pcea & 0xF0000) >> 16);

  00587	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00593	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR pcea$[rsp]
  0059a	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  005a0	c1 e9 10	 shr	 ecx, 16
  005a3	0b c1		 or	 eax, ecx
  005a5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tte$5[rsp]
  005aa	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 685  :             STORE_HW(tte->pcnum_lo, pcea & 0x0FFFF);

  005ad	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR pcea$[rsp]
  005b4	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  005b9	0f b7 c8	 movzx	 ecx, ax
  005bc	e8 00 00 00 00	 call	 _byteswap_ushort
  005c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tte$5[rsp]
  005c6	48 83 c1 02	 add	 rcx, 2
  005ca	0f b7 d0	 movzx	 edx, ax
  005cd	e8 00 00 00 00	 call	 store_hw_noswap

; 686  :             STORE_FW(tte->retna, (regs->psw.amode << 31) | regs->psw.IA_L | PROBSTATE(&regs->psw));

  005d2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005da	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  005de	83 e0 01	 and	 eax, 1
  005e1	85 c0		 test	 eax, eax
  005e3	74 0a		 je	 SHORT $LN27@z900_trace
  005e5	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv313[rsp], 1
  005ed	eb 08		 jmp	 SHORT $LN28@z900_trace
$LN27@z900_trace:
  005ef	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv313[rsp], 0
$LN28@z900_trace:
  005f7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ff	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00605	d1 e8		 shr	 eax, 1
  00607	83 e0 01	 and	 eax, 1
  0060a	c1 e0 1f	 shl	 eax, 31
  0060d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00615	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  0061b	0b 44 24 48	 or	 eax, DWORD PTR tv313[rsp]
  0061f	8b c8		 mov	 ecx, eax
  00621	e8 00 00 00 00	 call	 _byteswap_ulong
  00626	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tte$5[rsp]
  0062b	48 83 c1 04	 add	 rcx, 4
  0062f	8b d0		 mov	 edx, eax
  00631	e8 00 00 00 00	 call	 store_fw_noswap
$LN15@z900_trace:
$LN13@z900_trace:
$LN11@z900_trace:
$LN9@z900_trace:

; 687  :         }
; 688  :     } /* end ASN_AND_LX_REUSE_ENABLED */

  00636	e9 0f 02 00 00	 jmp	 $LN7@z900_trace
$LN6@z900_trace:

; 689  :     else
; 690  :     if(regs->psw.amode64)

  0063b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00643	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00649	83 e0 01	 and	 eax, 1
  0064c	85 c0		 test	 eax, eax
  0064e	0f 84 f4 00 00
	00		 je	 $LN16@z900_trace

; 691  :     {
; 692  :         /* In 64-bit mode, regardless of resulting mode,
; 693  :            when ASN-and-LX-reuse is not enabled */
; 694  :         TRACE_F2_PC *tte;
; 695  :         size = sizeof(TRACE_F2_PC);

  00654	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 696  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0065c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00664	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00668	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  0066d	e8 00 00 00 00	 call	 z900_get_trace_entry
  00672	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 697  :         tte = (void*)(regs->mainstor + raddr);

  00677	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00686	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0068b	48 89 44 24 78	 mov	 QWORD PTR tte$6[rsp], rax

; 698  :         tte->format = TRACE_F2_PC_FMT;

  00690	48 8b 44 24 78	 mov	 rax, QWORD PTR tte$6[rsp]
  00695	c6 00 22	 mov	 BYTE PTR [rax], 34	; 00000022H

; 699  :         tte->pswkey_pcnum_hi = regs->psw.pkey | ((pcea & 0xF0000) >> 16);

  00698	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a0	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  006a4	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR pcea$[rsp]
  006ab	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  006b1	c1 e9 10	 shr	 ecx, 16
  006b4	0b c1		 or	 eax, ecx
  006b6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tte$6[rsp]
  006bb	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 700  :         STORE_HW(tte->pcnum_lo, pcea & 0x0FFFF);

  006be	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR pcea$[rsp]
  006c5	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006ca	0f b7 c8	 movzx	 ecx, ax
  006cd	e8 00 00 00 00	 call	 _byteswap_ushort
  006d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tte$6[rsp]
  006d7	48 83 c1 02	 add	 rcx, 2
  006db	0f b7 d0	 movzx	 edx, ax
  006de	e8 00 00 00 00	 call	 store_hw_noswap

; 701  :         STORE_DW(tte->retna, regs->psw.IA_G | PROBSTATE(&regs->psw));

  006e3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006eb	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  006ef	83 e0 01	 and	 eax, 1
  006f2	85 c0		 test	 eax, eax
  006f4	74 0e		 je	 SHORT $LN29@z900_trace
  006f6	48 c7 84 24 98
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv349[rsp], 1
  00702	eb 0c		 jmp	 SHORT $LN30@z900_trace
$LN29@z900_trace:
  00704	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv349[rsp], 0
$LN30@z900_trace:
  00710	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00718	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv349[rsp]
  00720	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00727	48 0b c1	 or	 rax, rcx
  0072a	48 8b c8	 mov	 rcx, rax
  0072d	e8 00 00 00 00	 call	 _byteswap_uint64
  00732	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tte$6[rsp]
  00737	48 83 c1 04	 add	 rcx, 4
  0073b	48 8b d0	 mov	 rdx, rax
  0073e	e8 00 00 00 00	 call	 store_dw_noswap

; 702  :     }

  00743	e9 02 01 00 00	 jmp	 $LN17@z900_trace
$LN16@z900_trace:

; 703  :     else
; 704  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 705  :     {
; 706  :         /* In 24-bit or 31-bit mode, regardless of resulting mode,
; 707  :            when ASN-and-LX-reuse is not enabled */
; 708  :         TRACE_F1_PC *tte;
; 709  :         size = sizeof(TRACE_F1_PC);

  00748	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 710  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00750	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00758	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0075c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  00761	e8 00 00 00 00	 call	 z900_get_trace_entry
  00766	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 711  :         tte = (void*)(regs->mainstor + raddr);

  0076b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00773	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0077a	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0077f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tte$7[rsp], rax

; 712  :         tte->format = TRACE_F1_PC_FMT;

  00787	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tte$7[rsp]
  0078f	c6 00 21	 mov	 BYTE PTR [rax], 33	; 00000021H

; 713  :         tte->pswkey_pcnum_hi = regs->psw.pkey | ((pcea & 0xF0000) >> 16);

  00792	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0079a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0079e	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR pcea$[rsp]
  007a5	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  007ab	c1 e9 10	 shr	 ecx, 16
  007ae	0b c1		 or	 eax, ecx
  007b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tte$7[rsp]
  007b8	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 714  :         STORE_HW(tte->pcnum_lo, pcea & 0x0FFFF);

  007bb	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR pcea$[rsp]
  007c2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  007c7	0f b7 c8	 movzx	 ecx, ax
  007ca	e8 00 00 00 00	 call	 _byteswap_ushort
  007cf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tte$7[rsp]
  007d7	48 83 c1 02	 add	 rcx, 2
  007db	0f b7 d0	 movzx	 edx, ax
  007de	e8 00 00 00 00	 call	 store_hw_noswap

; 715  :         STORE_FW(tte->retna, (regs->psw.amode << 31) | regs->psw.IA_L | PROBSTATE(&regs->psw));

  007e3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007eb	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  007ef	83 e0 01	 and	 eax, 1
  007f2	85 c0		 test	 eax, eax
  007f4	74 0a		 je	 SHORT $LN31@z900_trace
  007f6	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv387[rsp], 1
  007fe	eb 08		 jmp	 SHORT $LN32@z900_trace
$LN31@z900_trace:
  00800	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv387[rsp], 0
$LN32@z900_trace:
  00808	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00810	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00816	d1 e8		 shr	 eax, 1
  00818	83 e0 01	 and	 eax, 1
  0081b	c1 e0 1f	 shl	 eax, 31
  0081e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00826	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  0082c	0b 44 24 4c	 or	 eax, DWORD PTR tv387[rsp]
  00830	8b c8		 mov	 ecx, eax
  00832	e8 00 00 00 00	 call	 _byteswap_ulong
  00837	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tte$7[rsp]
  0083f	48 83 c1 04	 add	 rcx, 4
  00843	8b d0		 mov	 edx, eax
  00845	e8 00 00 00 00	 call	 store_fw_noswap
$LN17@z900_trace:
$LN7@z900_trace:

; 716  :     }
; 717  : 
; 718  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  0084a	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00852	44 8b 44 24 20	 mov	 r8d, DWORD PTR size$[rsp]
  00857	48 8b 54 24 28	 mov	 rdx, QWORD PTR raddr$[rsp]
  0085c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ag$[rsp]
  00861	e8 00 00 00 00	 call	 z900_set_trace_entry

; 719  : 
; 720  : } /* end function ARCH_DEP(trace_pc) */

  00866	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0086d	c3		 ret	 0
z900_trace_pc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
nbit$ = 32
tv65 = 36
size$ = 40
tte$1 = 48
raddr$ = 56
ag$ = 64
ssair$ = 96
sasn$ = 104
regs$ = 112
z900_trace_ssar PROC

; 566  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 567  : RADR raddr;
; 568  : RADR ag;
; 569  : int  size;
; 570  : BYTE nbit = (ssair ? 1 : 0);

  00012	83 7c 24 60 00	 cmp	 DWORD PTR ssair$[rsp], 0
  00017	74 0a		 je	 SHORT $LN3@z900_trace
  00019	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  00021	eb 08		 jmp	 SHORT $LN4@z900_trace
$LN3@z900_trace:
  00023	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN4@z900_trace:
  0002b	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv65[rsp]
  00030	88 44 24 20	 mov	 BYTE PTR nbit$[rsp], al

; 571  : 
; 572  :     {
; 573  :         TRACE_F1_SSAR *tte;
; 574  :         size = sizeof(TRACE_F1_SSAR);

  00034	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR size$[rsp], 4

; 575  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0003c	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00041	8b 54 24 28	 mov	 edx, DWORD PTR size$[rsp]
  00045	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ag$[rsp]
  0004a	e8 00 00 00 00	 call	 z900_get_trace_entry
  0004f	48 89 44 24 38	 mov	 QWORD PTR raddr$[rsp], rax

; 576  :         tte = (void*)(regs->mainstor + raddr);

  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00060	48 03 44 24 38	 add	 rax, QWORD PTR raddr$[rsp]
  00065	48 89 44 24 30	 mov	 QWORD PTR tte$1[rsp], rax

; 577  :         tte->format = TRACE_F1_SSAR_FMT;

  0006a	48 8b 44 24 30	 mov	 rax, QWORD PTR tte$1[rsp]
  0006f	c6 00 10	 mov	 BYTE PTR [rax], 16

; 578  :         tte->extfmt = 0 | nbit;

  00072	48 8b 44 24 30	 mov	 rax, QWORD PTR tte$1[rsp]
  00077	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR nbit$[rsp]
  0007c	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 579  :         STORE_HW(tte->newsasn,sasn);

  0007f	0f b7 4c 24 68	 movzx	 ecx, WORD PTR sasn$[rsp]
  00084	e8 00 00 00 00	 call	 _byteswap_ushort
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tte$1[rsp]
  0008e	48 83 c1 02	 add	 rcx, 2
  00092	0f b7 d0	 movzx	 edx, ax
  00095	e8 00 00 00 00	 call	 store_hw_noswap

; 580  :     }
; 581  : 
; 582  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  0009a	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0009f	44 8b 44 24 28	 mov	 r8d, DWORD PTR size$[rsp]
  000a4	48 8b 54 24 38	 mov	 rdx, QWORD PTR raddr$[rsp]
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ag$[rsp]
  000ae	e8 00 00 00 00	 call	 z900_set_trace_entry

; 583  : 
; 584  : } /* end function ARCH_DEP(trace_ssar) */

  000b3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000b7	c3		 ret	 0
z900_trace_ssar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
size$ = 32
tte$1 = 40
tte$2 = 48
raddr$ = 56
ag$ = 64
alet$ = 96
ia$ = 104
regs$ = 112
z900_trace_bsg PROC

; 513  : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 514  : RADR raddr;
; 515  : RADR ag;
; 516  : int  size;
; 517  : 
; 518  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 519  :     if(regs->psw.amode64)

  00012	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00017	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001d	83 e0 01	 and	 eax, 1
  00020	85 c0		 test	 eax, eax
  00022	0f 84 b5 00 00
	00		 je	 $LN2@z900_trace

; 520  :     {
; 521  :         TRACE_F2_BSG *tte;
; 522  :         size = sizeof(TRACE_F2_BSG);

  00028	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 523  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00030	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00035	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00039	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ag$[rsp]
  0003e	e8 00 00 00 00	 call	 z900_get_trace_entry
  00043	48 89 44 24 38	 mov	 QWORD PTR raddr$[rsp], rax

; 524  :         tte = (void*)(regs->mainstor + raddr);

  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0004d	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00054	48 03 44 24 38	 add	 rax, QWORD PTR raddr$[rsp]
  00059	48 89 44 24 28	 mov	 QWORD PTR tte$1[rsp], rax

; 525  :         tte->format = TRACE_F2_BSG_FMT;

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR tte$1[rsp]
  00063	c6 00 42	 mov	 BYTE PTR [rax], 66	; 00000042H

; 526  :         tte->alet[0] = (alet >> 16) & 0xFF;

  00066	8b 44 24 60	 mov	 eax, DWORD PTR alet$[rsp]
  0006a	c1 e8 10	 shr	 eax, 16
  0006d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00072	b9 01 00 00 00	 mov	 ecx, 1
  00077	48 6b c9 00	 imul	 rcx, rcx, 0
  0007b	48 8b 54 24 28	 mov	 rdx, QWORD PTR tte$1[rsp]
  00080	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 527  :         tte->alet[1] = (alet >> 8) & 0xFF;

  00084	8b 44 24 60	 mov	 eax, DWORD PTR alet$[rsp]
  00088	c1 e8 08	 shr	 eax, 8
  0008b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	48 6b c9 01	 imul	 rcx, rcx, 1
  00099	48 8b 54 24 28	 mov	 rdx, QWORD PTR tte$1[rsp]
  0009e	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 528  :         tte->alet[2] = alet & 0xFF;

  000a2	8b 44 24 60	 mov	 eax, DWORD PTR alet$[rsp]
  000a6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ab	b9 01 00 00 00	 mov	 ecx, 1
  000b0	48 6b c9 02	 imul	 rcx, rcx, 2
  000b4	48 8b 54 24 28	 mov	 rdx, QWORD PTR tte$1[rsp]
  000b9	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 529  :         STORE_DW(tte->newia,ia);

  000bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ia$[rsp]
  000c2	e8 00 00 00 00	 call	 _byteswap_uint64
  000c7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tte$1[rsp]
  000cc	48 83 c1 04	 add	 rcx, 4
  000d0	48 8b d0	 mov	 rdx, rax
  000d3	e8 00 00 00 00	 call	 store_dw_noswap

; 530  :     }

  000d8	e9 df 00 00 00	 jmp	 $LN3@z900_trace
$LN2@z900_trace:

; 531  :     else
; 532  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 533  :     {
; 534  :         TRACE_F1_BSG *tte;
; 535  :         size = sizeof(TRACE_F1_BSG);

  000dd	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 536  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  000e5	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000ea	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  000ee	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ag$[rsp]
  000f3	e8 00 00 00 00	 call	 z900_get_trace_entry
  000f8	48 89 44 24 38	 mov	 QWORD PTR raddr$[rsp], rax

; 537  :         tte = (void*)(regs->mainstor + raddr);

  000fd	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00102	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00109	48 03 44 24 38	 add	 rax, QWORD PTR raddr$[rsp]
  0010e	48 89 44 24 30	 mov	 QWORD PTR tte$2[rsp], rax

; 538  :         tte->format = TRACE_F1_BSG_FMT;

  00113	48 8b 44 24 30	 mov	 rax, QWORD PTR tte$2[rsp]
  00118	c6 00 41	 mov	 BYTE PTR [rax], 65	; 00000041H

; 539  :         tte->alet[0] = ((alet >> 17) & 0x80) | ((alet >> 16) & 0x7F);

  0011b	8b 44 24 60	 mov	 eax, DWORD PTR alet$[rsp]
  0011f	c1 e8 11	 shr	 eax, 17
  00122	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00127	8b 4c 24 60	 mov	 ecx, DWORD PTR alet$[rsp]
  0012b	c1 e9 10	 shr	 ecx, 16
  0012e	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00131	0b c1		 or	 eax, ecx
  00133	b9 01 00 00 00	 mov	 ecx, 1
  00138	48 6b c9 00	 imul	 rcx, rcx, 0
  0013c	48 8b 54 24 30	 mov	 rdx, QWORD PTR tte$2[rsp]
  00141	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 540  :         tte->alet[1] = (alet >> 8) & 0xFF;

  00145	8b 44 24 60	 mov	 eax, DWORD PTR alet$[rsp]
  00149	c1 e8 08	 shr	 eax, 8
  0014c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00151	b9 01 00 00 00	 mov	 ecx, 1
  00156	48 6b c9 01	 imul	 rcx, rcx, 1
  0015a	48 8b 54 24 30	 mov	 rdx, QWORD PTR tte$2[rsp]
  0015f	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 541  :         tte->alet[2] = alet & 0xFF;

  00163	8b 44 24 60	 mov	 eax, DWORD PTR alet$[rsp]
  00167	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0016c	b9 01 00 00 00	 mov	 ecx, 1
  00171	48 6b c9 02	 imul	 rcx, rcx, 2
  00175	48 8b 54 24 30	 mov	 rdx, QWORD PTR tte$2[rsp]
  0017a	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 542  :         if ((ia & 0x80000000) == 0)

  0017e	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00183	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ia$[rsp]
  00188	48 23 c8	 and	 rcx, rax
  0018b	48 8b c1	 mov	 rax, rcx
  0018e	48 85 c0	 test	 rax, rax
  00191	75 10		 jne	 SHORT $LN4@z900_trace

; 543  :             ia &=0x00FFFFFF;

  00193	48 8b 44 24 68	 mov	 rax, QWORD PTR ia$[rsp]
  00198	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0019e	48 89 44 24 68	 mov	 QWORD PTR ia$[rsp], rax
$LN4@z900_trace:

; 544  :         STORE_FW(tte->newia,ia);

  001a3	8b 4c 24 68	 mov	 ecx, DWORD PTR ia$[rsp]
  001a7	e8 00 00 00 00	 call	 _byteswap_ulong
  001ac	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tte$2[rsp]
  001b1	48 83 c1 04	 add	 rcx, 4
  001b5	8b d0		 mov	 edx, eax
  001b7	e8 00 00 00 00	 call	 store_fw_noswap
$LN3@z900_trace:

; 545  :     }
; 546  : 
; 547  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  001bc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  001c1	44 8b 44 24 20	 mov	 r8d, DWORD PTR size$[rsp]
  001c6	48 8b 54 24 38	 mov	 rdx, QWORD PTR raddr$[rsp]
  001cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ag$[rsp]
  001d0	e8 00 00 00 00	 call	 z900_set_trace_entry

; 548  : 
; 549  : } /* end function ARCH_DEP(trace_bsg) */

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
z900_trace_bsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
size$ = 32
raddr$ = 40
tte$1 = 48
ag$ = 56
tte$2 = 64
tte$3 = 72
amode$ = 96
ia$ = 104
regs$ = 112
z900_trace_br PROC

; 458  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 459  : RADR raddr;
; 460  : RADR ag;
; 461  : int  size;
; 462  : 
; 463  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 464  :     if(amode && ia > 0xFFFFFFFFULL)

  00012	83 7c 24 60 00	 cmp	 DWORD PTR amode$[rsp], 0
  00017	0f 84 8b 00 00
	00		 je	 $LN2@z900_trace
  0001d	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00022	48 39 44 24 68	 cmp	 QWORD PTR ia$[rsp], rax
  00027	76 7f		 jbe	 SHORT $LN2@z900_trace

; 465  :     {
; 466  :         TRACE_F3_BR *tte;
; 467  :         size = sizeof(TRACE_F3_BR);

  00029	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 468  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00031	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00036	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0003a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  0003f	e8 00 00 00 00	 call	 z900_get_trace_entry
  00044	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 469  :         tte = (void*)(regs->mainstor + raddr);

  00049	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00055	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0005a	48 89 44 24 30	 mov	 QWORD PTR tte$1[rsp], rax

; 470  :         tte->format = TRACE_F3_BR_FMT;

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR tte$1[rsp]
  00064	c6 00 52	 mov	 BYTE PTR [rax], 82	; 00000052H

; 471  :         tte->fmt2 = TRACE_F3_BR_FM2;

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR tte$1[rsp]
  0006c	c6 40 01 c0	 mov	 BYTE PTR [rax+1], 192	; 000000c0H

; 472  :         STORE_HW(tte->resv,0);

  00070	33 c9		 xor	 ecx, ecx
  00072	e8 00 00 00 00	 call	 _byteswap_ushort
  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tte$1[rsp]
  0007c	48 83 c1 02	 add	 rcx, 2
  00080	0f b7 d0	 movzx	 edx, ax
  00083	e8 00 00 00 00	 call	 store_hw_noswap

; 473  :         STORE_DW(tte->newia64,ia);

  00088	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ia$[rsp]
  0008d	e8 00 00 00 00	 call	 _byteswap_uint64
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tte$1[rsp]
  00097	48 83 c1 04	 add	 rcx, 4
  0009b	48 8b d0	 mov	 rdx, rax
  0009e	e8 00 00 00 00	 call	 store_dw_noswap

; 474  :     }

  000a3	e9 b6 00 00 00	 jmp	 $LN3@z900_trace
$LN2@z900_trace:

; 475  :     else
; 476  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 477  :     if(amode)

  000a8	83 7c 24 60 00	 cmp	 DWORD PTR amode$[rsp], 0
  000ad	74 5b		 je	 SHORT $LN4@z900_trace

; 478  :     {
; 479  :         TRACE_F2_BR *tte;
; 480  :         size = sizeof(TRACE_F2_BR);

  000af	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR size$[rsp], 4

; 481  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  000b7	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000bc	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  000c0	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  000c5	e8 00 00 00 00	 call	 z900_get_trace_entry
  000ca	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 482  :         tte = (void*)(regs->mainstor + raddr);

  000cf	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000db	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  000e0	48 89 44 24 40	 mov	 QWORD PTR tte$2[rsp], rax

; 483  :         STORE_FW(tte->newia31,ia | 0x80000000);

  000e5	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  000ea	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ia$[rsp]
  000ef	48 0b c8	 or	 rcx, rax
  000f2	48 8b c1	 mov	 rax, rcx
  000f5	8b c8		 mov	 ecx, eax
  000f7	e8 00 00 00 00	 call	 _byteswap_ulong
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$2[rsp]
  00101	8b d0		 mov	 edx, eax
  00103	e8 00 00 00 00	 call	 store_fw_noswap

; 484  :     }

  00108	eb 54		 jmp	 SHORT $LN5@z900_trace
$LN4@z900_trace:

; 485  :     else
; 486  :     {
; 487  :         TRACE_F1_BR *tte;
; 488  :         size = sizeof(TRACE_F1_BR);

  0010a	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR size$[rsp], 4

; 489  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00112	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00117	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0011b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  00120	e8 00 00 00 00	 call	 z900_get_trace_entry
  00125	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 490  :         tte = (void*)(regs->mainstor + raddr);

  0012a	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00136	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0013b	48 89 44 24 48	 mov	 QWORD PTR tte$3[rsp], rax

; 491  :         STORE_FW(tte->newia24,ia & 0x00FFFFFF);

  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR ia$[rsp]
  00145	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0014b	8b c8		 mov	 ecx, eax
  0014d	e8 00 00 00 00	 call	 _byteswap_ulong
  00152	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$3[rsp]
  00157	8b d0		 mov	 edx, eax
  00159	e8 00 00 00 00	 call	 store_fw_noswap
$LN5@z900_trace:
$LN3@z900_trace:

; 492  :     }
; 493  : 
; 494  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  0015e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 44 24 20	 mov	 r8d, DWORD PTR size$[rsp]
  00168	48 8b 54 24 28	 mov	 rdx, QWORD PTR raddr$[rsp]
  0016d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ag$[rsp]
  00172	e8 00 00 00 00	 call	 z900_set_trace_entry

; 495  : 
; 496  : } /* end function ARCH_DEP(trace_br) */

  00177	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0017b	c3		 ret	 0
z900_trace_br ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
tv79 = 0
abs_host$ = 8
abs_guest$ = 32
raddr$ = 40
size$ = 48
regs$ = 56
s390_set_trace_entry PROC

; 421  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 422  : #if defined(_FEATURE_SIE)
; 423  : RADR abs_host;
; 424  : 
; 425  :     abs_host = raddr;

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR raddr$[rsp]
  0001d	48 89 44 24 08	 mov	 QWORD PTR abs_host$[rsp], rax

; 426  : #endif /*defined(_FEATURE_SIE)*/
; 427  : 
; 428  :     raddr += size;

  00022	48 63 44 24 30	 movsxd	 rax, DWORD PTR size$[rsp]
  00027	48 8b 4c 24 28	 mov	 rcx, QWORD PTR raddr$[rsp]
  0002c	48 03 c8	 add	 rcx, rax
  0002f	48 8b c1	 mov	 rax, rcx
  00032	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 429  : 
; 430  : #if defined(_FEATURE_SIE)
; 431  :     /* Recalculate the Guest absolute address */
; 432  :     raddr = abs_guest + (raddr - abs_host);

  00037	48 8b 44 24 08	 mov	 rax, QWORD PTR abs_host$[rsp]
  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR raddr$[rsp]
  00041	48 2b c8	 sub	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs_guest$[rsp]
  0004c	48 03 c8	 add	 rcx, rax
  0004f	48 8b c1	 mov	 rax, rcx
  00052	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 433  : #endif /*defined(_FEATURE_SIE)*/
; 434  : 
; 435  :     /* Convert trace entry absolute address back to real address */
; 436  :     raddr = APPLY_PREFIXING (raddr, regs->PX);

  00057	8b 44 24 28	 mov	 eax, DWORD PTR raddr$[rsp]
  0005b	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00061	48 85 c0	 test	 rax, rax
  00064	74 22		 je	 SHORT $LN3@s390_set_t
  00066	8b 44 24 28	 mov	 eax, DWORD PTR raddr$[rsp]
  0006a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00078	48 3b c1	 cmp	 rax, rcx
  0007b	74 0b		 je	 SHORT $LN3@s390_set_t
  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR raddr$[rsp]
  00082	48 89 04 24	 mov	 QWORD PTR tv79[rsp], rax
  00086	eb 16		 jmp	 SHORT $LN4@s390_set_t
$LN3@s390_set_t:
  00088	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00090	8b 4c 24 28	 mov	 ecx, DWORD PTR raddr$[rsp]
  00094	33 c8		 xor	 ecx, eax
  00096	8b c1		 mov	 eax, ecx
  00098	8b c0		 mov	 eax, eax
  0009a	48 89 04 24	 mov	 QWORD PTR tv79[rsp], rax
$LN4@s390_set_t:
  0009e	48 8b 04 24	 mov	 rax, QWORD PTR tv79[rsp]
  000a2	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 437  : 
; 438  :     /* Return updated value of control register 12 */
; 439  :     return (regs->CR(12) & ~CR12_TRACEEA) | raddr;

  000a7	b8 08 00 00 00	 mov	 eax, 8
  000ac	48 6b c0 0d	 imul	 rax, rax, 13
  000b0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000bc	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000c1	8b c0		 mov	 eax, eax
  000c3	48 0b 44 24 28	 or	 rax, QWORD PTR raddr$[rsp]

; 440  : 
; 441  : } /* end function ARCH_DEP(set_trace_entry) */

  000c8	48 83 c4 18	 add	 rsp, 24
  000cc	c3		 ret	 0
s390_set_trace_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
n$ = 48
tv135 = 56
tv168 = 64
abs_guest$ = 96
size$ = 104
regs$ = 112
s390_get_trace_entry PROC

; 370  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 371  : RADR    n;                              /* Addr of trace table entry */
; 372  : 
; 373  :     /* Obtain the trace entry address from control register 12 */
; 374  :     n = regs->CR(12) & CR12_TRACEEA;

  00012	b8 08 00 00 00	 mov	 eax, 8
  00017	48 6b c0 0d	 imul	 rax, rax, 13
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00020	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00027	25 fc ff ff 7f	 and	 eax, 2147483644		; 7ffffffcH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 375  : 
; 376  :     /* Apply low-address protection to trace entry address */
; 377  :     if (ARCH_DEP(is_low_address_protected) (n, regs))

  00033	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00038	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  0003c	e8 00 00 00 00	 call	 s390_is_low_address_protected
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	74 31		 je	 SHORT $LN5@s390_get_t

; 378  :     {
; 379  : #ifdef FEATURE_SUPPRESSION_ON_PROTECTION
; 380  :         regs->TEA = (n & STORAGE_KEY_PAGEMASK);

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0004d	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00053	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 381  :         regs->excarid = 0;

  0005e	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00063	c6 80 3e 08 00
	00 00		 mov	 BYTE PTR [rax+2110], 0

; 382  : #endif /*FEATURE_SUPPRESSION_ON_PROTECTION*/
; 383  :         ARCH_DEP(program_interrupt) (regs, PGM_PROTECTION_EXCEPTION);

  0006a	ba 04 00 00 00	 mov	 edx, 4
  0006f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	e8 00 00 00 00	 call	 s390_program_interrupt
$LN5@s390_get_t:

; 384  :     }
; 385  : 
; 386  :     /* Program check if trace entry is outside main storage */
; 387  :     if ( n > regs->mainlim )

  00079	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00085	48 39 44 24 30	 cmp	 QWORD PTR n$[rsp], rax
  0008a	76 0f		 jbe	 SHORT $LN6@s390_get_t

; 388  :         ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  0008c	ba 05 00 00 00	 mov	 edx, 5
  00091	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	e8 00 00 00 00	 call	 s390_program_interrupt
$LN6@s390_get_t:

; 389  : 
; 390  :     /* Program check if storing would overflow a 4K page boundary */
; 391  :     if ( ((n + size) & PAGEFRAME_PAGEMASK) != (n & PAGEFRAME_PAGEMASK) )

  0009b	48 63 44 24 68	 movsxd	 rax, DWORD PTR size$[rsp]
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000a5	48 03 c8	 add	 rcx, rax
  000a8	48 8b c1	 mov	 rax, rcx
  000ab	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  000b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000b6	48 81 e1 00 f0
	ff 7f		 and	 rcx, 2147479552		; 7ffff000H
  000bd	48 3b c1	 cmp	 rax, rcx
  000c0	74 0f		 je	 SHORT $LN7@s390_get_t

; 392  :         ARCH_DEP(program_interrupt) (regs, PGM_TRACE_TABLE_EXCEPTION);

  000c2	ba 16 00 00 00	 mov	 edx, 22
  000c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	e8 00 00 00 00	 call	 s390_program_interrupt
$LN7@s390_get_t:

; 393  : 
; 394  :     /* Convert trace entry real address to absolute address */
; 395  :     n = APPLY_PREFIXING (n, regs->PX);

  000d1	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]
  000d5	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000db	48 85 c0	 test	 rax, rax
  000de	74 23		 je	 SHORT $LN10@s390_get_t
  000e0	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]
  000e4	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000f2	48 3b c1	 cmp	 rax, rcx
  000f5	74 0c		 je	 SHORT $LN10@s390_get_t
  000f7	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  000fc	48 89 44 24 38	 mov	 QWORD PTR tv135[rsp], rax
  00101	eb 17		 jmp	 SHORT $LN11@s390_get_t
$LN10@s390_get_t:
  00103	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00108	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0010b	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  0010f	33 c8		 xor	 ecx, eax
  00111	8b c1		 mov	 eax, ecx
  00113	8b c0		 mov	 eax, eax
  00115	48 89 44 24 38	 mov	 QWORD PTR tv135[rsp], rax
$LN11@s390_get_t:
  0011a	48 8b 44 24 38	 mov	 rax, QWORD PTR tv135[rsp]
  0011f	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 396  : 
; 397  : #if defined(_FEATURE_SIE)
; 398  :     *abs_guest = n;

  00124	48 8b 44 24 60	 mov	 rax, QWORD PTR abs_guest$[rsp]
  00129	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  0012e	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN4@s390_get_t:

; 399  : 
; 400  :     SIE_TRANSLATE(&n, ACCTYPE_WRITE, regs);

  00131	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00136	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0013c	d1 e8		 shr	 eax, 1
  0013e	83 e0 01	 and	 eax, 1
  00141	85 c0		 test	 eax, eax
  00143	0f 84 ca 00 00
	00		 je	 $LN8@s390_get_t
  00149	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00154	c1 e8 02	 shr	 eax, 2
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	0f 85 b1 00 00
	00		 jne	 $LN8@s390_get_t
  00162	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00167	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016e	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00172	75 44		 jne	 SHORT $LN12@s390_get_t
  00174	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00179	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00180	48 03 44 24 30	 add	 rax, QWORD PTR n$[rsp]
  00185	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0018e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00193	41 b9 02 00 00
	00		 mov	 r9d, 2
  00199	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0019e	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  001a5	ba fd ff ff ff	 mov	 edx, -3
  001aa	8b c8		 mov	 ecx, eax
  001ac	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001b1	48 89 44 24 40	 mov	 QWORD PTR tv168[rsp], rax
  001b6	eb 43		 jmp	 SHORT $LN13@s390_get_t
$LN12@s390_get_t:
  001b8	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  001c4	48 03 44 24 30	 add	 rax, QWORD PTR n$[rsp]
  001c9	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  001d2	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  001d7	41 b9 02 00 00
	00		 mov	 r9d, 2
  001dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001e2	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  001e9	ba fd ff ff ff	 mov	 edx, -3
  001ee	48 8b c8	 mov	 rcx, rax
  001f1	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001f6	48 89 44 24 40	 mov	 QWORD PTR tv168[rsp], rax
$LN13@s390_get_t:
  001fb	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00200	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00207	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  0020e	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax
$LN8@s390_get_t:
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 14 ff ff
	ff		 jne	 $LN4@s390_get_t

; 401  : 
; 402  : #endif /*defined(_FEATURE_SIE)*/
; 403  : 
; 404  :     return n;

  0021d	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]

; 405  : 
; 406  : } /* end function ARCH_DEP(get_trace_entry) */

  00222	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00226	c3		 ret	 0
s390_get_trace_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_is_low_address_protected
_TEXT	SEGMENT
addr$ = 8
regs$ = 16
s390_is_low_address_protected PROC			; COMDAT

; 419  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 420  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 421  :     /* For z/Arch, low-address protection applies to locations
; 422  :        0-511 (0000-01FF) and also 4096-4607 (1000-11FF) */
; 423  :     if (addr & 0xFFFFFFFFFFFFEE00ULL)
; 424  : #else
; 425  :     /* For S/370 and ESA/390, low-address protection applies
; 426  :        only to locations 0-511 */
; 427  :     if (addr > 511)

  00009	81 7c 24 08 ff
	01 00 00	 cmp	 DWORD PTR addr$[rsp], 511 ; 000001ffH
  00011	76 04		 jbe	 SHORT $LN2@s390_is_lo

; 428  : #endif
; 429  :         return false;

  00013	32 c0		 xor	 al, al
  00015	eb 50		 jmp	 SHORT $LN1@s390_is_lo
$LN2@s390_is_lo:

; 430  : 
; 431  :     /* Low-address protection applies only if the low-address
; 432  :        protection control bit in control register 0 is set */
; 433  :     if (!(regs->CR(0) & CR0_LOW_PROT))

  00017	b8 08 00 00 00	 mov	 eax, 8
  0001c	48 6b c0 01	 imul	 rax, rax, 1
  00020	48 8b 4c 24 10	 mov	 rcx, QWORD PTR regs$[rsp]
  00025	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0002c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00031	85 c0		 test	 eax, eax
  00033	75 04		 jne	 SHORT $LN3@s390_is_lo

; 434  :         return false;

  00035	32 c0		 xor	 al, al
  00037	eb 2e		 jmp	 SHORT $LN1@s390_is_lo
$LN3@s390_is_lo:

; 435  : 
; 436  : #if defined( _FEATURE_SIE )
; 437  :     /* Host low-address protection is not applied to guest
; 438  :        references to guest storage */
; 439  :     if (regs->sie_active)

  00039	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00044	83 e0 01	 and	 eax, 1
  00047	85 c0		 test	 eax, eax
  00049	74 04		 je	 SHORT $LN4@s390_is_lo

; 440  :         return false;

  0004b	32 c0		 xor	 al, al
  0004d	eb 18		 jmp	 SHORT $LN1@s390_is_lo
$LN4@s390_is_lo:

; 441  : #endif
; 442  : 
; 443  :     /* Low-addr protection doesn't apply to private address spaces */
; 444  :     if (regs->dat.pvtaddr)

  0004f	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  00054	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 04		 je	 SHORT $LN5@s390_is_lo

; 445  :         return false;

  00061	32 c0		 xor	 al, al
  00063	eb 02		 jmp	 SHORT $LN1@s390_is_lo
$LN5@s390_is_lo:

; 446  : 
; 447  :     return true;      // (location *IS* low-address protected)

  00065	b0 01		 mov	 al, 1
$LN1@s390_is_lo:

; 448  : 
; 449  : } /* end function is_low_address_protected */

  00067	c3		 ret	 0
s390_is_low_address_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
fast$1 = 32
i$ = 36
j$ = 40
tv74 = 44
tv78 = 48
n$ = 52
size$ = 56
dreg$ = 64
tte$2 = 72
raddr$ = 80
tv142 = 88
ag$ = 96
$T3 = 112
ETOD$ = 128
__$ArrayPad$ = 144
r1$ = 192
r3$ = 200
op$ = 208
regs$ = 216
s390_trace_tr PROC

; 1063 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1064 : RADR raddr;
; 1065 : RADR ag;
; 1066 : int  size;
; 1067 : int  i, j, n;
; 1068 : U64  dreg;
; 1069 : ETOD ETOD;
; 1070 : 
; 1071 :     {
; 1072 :         TRACE_F1_TR *tte;
; 1073 :         BYTE fast;
; 1074 : 
; 1075 :         size = sizeof(TRACE_F1_TR);

  0002d	c7 44 24 38 4c
	00 00 00	 mov	 DWORD PTR size$[rsp], 76 ; 0000004cH

; 1076 :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00035	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0003d	8b 54 24 38	 mov	 edx, DWORD PTR size$[rsp]
  00041	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ag$[rsp]
  00046	e8 00 00 00 00	 call	 s390_get_trace_entry
  0004b	48 89 44 24 50	 mov	 QWORD PTR raddr$[rsp], rax

; 1077 :         tte = (void*)(regs->mainstor + raddr);

  00050	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00058	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0005f	48 03 44 24 50	 add	 rax, QWORD PTR raddr$[rsp]
  00064	48 89 44 24 48	 mov	 QWORD PTR tte$2[rsp], rax

; 1078 : 
; 1079 :         /* Determine if fast clock format */
; 1080 : #if defined(FEATURE_025_STORE_CLOCK_FAST_FACILITY)
; 1081 :         if (FACILITY_ENABLED( 025_STORE_CLOCK_FAST, regs ))
; 1082 :             fast = (regs->CR(0) & CR0_TRACE_TOD) >> 31;
; 1083 :         else
; 1084 : #endif
; 1085 :             fast = 0;

  00069	c6 44 24 20 00	 mov	 BYTE PTR fast$1[rsp], 0

; 1086 : 
; 1087 :         /* Calculate the number of registers to be traced, minus 1 */
; 1088 :         n = ( r3 < r1 ) ? r3 + 16 - r1 : r3 - r1;

  0006e	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00075	39 84 24 c8 00
	00 00		 cmp	 DWORD PTR r3$[rsp], eax
  0007c	7d 17		 jge	 SHORT $LN7@s390_trace
  0007e	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00085	83 c0 10	 add	 eax, 16
  00088	2b 84 24 c0 00
	00 00		 sub	 eax, DWORD PTR r1$[rsp]
  0008f	89 44 24 2c	 mov	 DWORD PTR tv74[rsp], eax
  00093	eb 16		 jmp	 SHORT $LN8@s390_trace
$LN7@s390_trace:
  00095	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  0009c	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR r3$[rsp]
  000a3	2b c8		 sub	 ecx, eax
  000a5	8b c1		 mov	 eax, ecx
  000a7	89 44 24 2c	 mov	 DWORD PTR tv74[rsp], eax
$LN8@s390_trace:
  000ab	8b 44 24 2c	 mov	 eax, DWORD PTR tv74[rsp]
  000af	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 1089 : 
; 1090 :         /* Retrieve the TOD clock value bits 16-63 */
; 1091 :         etod_clock(regs, &ETOD, fast ? ETOD_fast : ETOD_standard);

  000b3	0f b6 44 24 20	 movzx	 eax, BYTE PTR fast$1[rsp]
  000b8	85 c0		 test	 eax, eax
  000ba	74 0a		 je	 SHORT $LN9@s390_trace
  000bc	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  000c4	eb 08		 jmp	 SHORT $LN10@s390_trace
$LN9@s390_trace:
  000c6	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv78[rsp], 2
$LN10@s390_trace:
  000ce	44 8b 44 24 30	 mov	 r8d, DWORD PTR tv78[rsp]
  000d3	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR ETOD$[rsp]
  000db	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	e8 00 00 00 00	 call	 etod_clock

; 1092 :         dreg = ETOD2TOD(ETOD) & 0x0000FFFFFFFFFFFFULL;

  000e8	48 8d 44 24 70	 lea	 rax, QWORD PTR $T3[rsp]
  000ed	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ETOD$[rsp]
  000f5	48 8b f8	 mov	 rdi, rax
  000f8	48 8b f1	 mov	 rsi, rcx
  000fb	b9 10 00 00 00	 mov	 ecx, 16
  00100	f3 a4		 rep movsb
  00102	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T3[rsp]
  00107	e8 00 00 00 00	 call	 ETOD2TOD
  0010c	48 b9 ff ff ff
	ff ff ff 00 00	 mov	 rcx, 281474976710655	; 0000ffffffffffffH
  00116	48 23 c1	 and	 rax, rcx
  00119	48 89 44 24 40	 mov	 QWORD PTR dreg$[rsp], rax

; 1093 : 
; 1094 :         /* Set format information */
; 1095 :         dreg |= /* tte->format = */ ((U64)(TRACE_F1_TR_FMT | n)) << 56;

  0011e	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00122	83 c8 70	 or	 eax, 112		; 00000070H
  00125	48 98		 cdqe
  00127	48 c1 e0 38	 shl	 rax, 56			; 00000038H
  0012b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dreg$[rsp]
  00130	48 0b c8	 or	 rcx, rax
  00133	48 8b c1	 mov	 rax, rcx
  00136	48 89 44 24 40	 mov	 QWORD PTR dreg$[rsp], rax

; 1096 :         dreg |= /* tte->fmt2 =   */  (U64)TRACE_F1_TR_FM2        << 48;

  0013b	48 8b 44 24 40	 mov	 rax, QWORD PTR dreg$[rsp]
  00140	48 89 44 24 40	 mov	 QWORD PTR dreg$[rsp], rax

; 1097 : 
; 1098 :         /* Store format information and bits 16-63 of the TOD clock
; 1099 :          * value
; 1100 :          */
; 1101 :         STORE_DW(tte, dreg);

  00145	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dreg$[rsp]
  0014a	e8 00 00 00 00	 call	 _byteswap_uint64
  0014f	48 8b d0	 mov	 rdx, rax
  00152	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$2[rsp]
  00157	e8 00 00 00 00	 call	 store_dw_noswap

; 1102 : 
; 1103 :         /* Store trace operand */
; 1104 : #if defined(FEATURE_025_STORE_CLOCK_FAST_FACILITY)
; 1105 :         if (FACILITY_ENABLED( 025_STORE_CLOCK_FAST, regs ))
; 1106 :         {
; 1107 :             if (fast)
; 1108 :             {
; 1109 :                 op &= 0xFF00FFFF;
; 1110 :                 /* FIXME: OR-in model dependent code
; 1111 :                 op |= model_code << 16;
; 1112 :                  */
; 1113 :             }
; 1114 :         }
; 1115 : #endif
; 1116 :         STORE_FW(tte->operand, op);

  0015c	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR op$[rsp]
  00163	e8 00 00 00 00	 call	 _byteswap_ulong
  00168	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tte$2[rsp]
  0016d	48 83 c1 08	 add	 rcx, 8
  00171	8b d0		 mov	 edx, eax
  00173	e8 00 00 00 00	 call	 store_fw_noswap

; 1117 : 
; 1118 :         for(i = r1, j = 0; ; )

  00178	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  0017f	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  00183	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
$LN2@s390_trace:

; 1119 :         {
; 1120 :             STORE_FW(tte->reg[j++], regs->GR_L(i));

  0018b	48 8b 44 24 48	 mov	 rax, QWORD PTR tte$2[rsp]
  00190	48 83 c0 0c	 add	 rax, 12
  00194	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR j$[rsp]
  00199	48 c1 e1 02	 shl	 rcx, 2
  0019d	48 03 c1	 add	 rax, rcx
  001a0	48 89 44 24 58	 mov	 QWORD PTR tv142[rsp], rax
  001a5	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  001aa	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  001b9	e8 00 00 00 00	 call	 _byteswap_ulong
  001be	8b d0		 mov	 edx, eax
  001c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv142[rsp]
  001c5	e8 00 00 00 00	 call	 store_fw_noswap
  001ca	8b 44 24 28	 mov	 eax, DWORD PTR j$[rsp]
  001ce	ff c0		 inc	 eax
  001d0	89 44 24 28	 mov	 DWORD PTR j$[rsp], eax

; 1121 : 
; 1122 :             /* Regdump is complete when r3 is done */
; 1123 :             if(r3 == i) break;

  001d4	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  001d8	39 84 24 c8 00
	00 00		 cmp	 DWORD PTR r3$[rsp], eax
  001df	75 02		 jne	 SHORT $LN5@s390_trace
  001e1	eb 17		 jmp	 SHORT $LN3@s390_trace
$LN5@s390_trace:

; 1124 : 
; 1125 :             /* Update register number and wrap */
; 1126 :             i++; i &= 15;

  001e3	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  001e7	ff c0		 inc	 eax
  001e9	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  001ed	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  001f1	83 e0 0f	 and	 eax, 15
  001f4	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax

; 1127 :         }

  001f8	eb 91		 jmp	 SHORT $LN2@s390_trace
$LN3@s390_trace:

; 1128 : 
; 1129 :     }
; 1130 : 
; 1131 :     return ARCH_DEP(set_trace_entry) (ag, raddr, size - (4 * (15 - n)), regs);

  001fa	b8 0f 00 00 00	 mov	 eax, 15
  001ff	2b 44 24 34	 sub	 eax, DWORD PTR n$[rsp]
  00203	c1 e0 02	 shl	 eax, 2
  00206	8b 4c 24 38	 mov	 ecx, DWORD PTR size$[rsp]
  0020a	2b c8		 sub	 ecx, eax
  0020c	8b c1		 mov	 eax, ecx
  0020e	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00216	44 8b c0	 mov	 r8d, eax
  00219	48 8b 54 24 50	 mov	 rdx, QWORD PTR raddr$[rsp]
  0021e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ag$[rsp]
  00223	e8 00 00 00 00	 call	 s390_set_trace_entry

; 1132 : 
; 1133 : } /* end function ARCH_DEP(trace_tr) */

  00228	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00230	48 33 cc	 xor	 rcx, rsp
  00233	e8 00 00 00 00	 call	 __security_check_cookie
  00238	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0023f	5f		 pop	 rdi
  00240	5e		 pop	 rsi
  00241	c3		 ret	 0
s390_trace_tr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
nbit$ = 32
tv65 = 36
size$ = 40
tte$1 = 48
raddr$ = 56
ag$ = 64
pti$ = 96
pasn$ = 104
gpr2$ = 112
regs$ = 120
s390_trace_pt PROC

; 899  : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 900  : RADR raddr;
; 901  : RADR ag;
; 902  : int  size;
; 903  : BYTE nbit = (pti ? 1 : 0);

  00017	83 7c 24 60 00	 cmp	 DWORD PTR pti$[rsp], 0
  0001c	74 0a		 je	 SHORT $LN3@s390_trace
  0001e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  00026	eb 08		 jmp	 SHORT $LN4@s390_trace
$LN3@s390_trace:
  00028	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN4@s390_trace:
  00030	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv65[rsp]
  00035	88 44 24 20	 mov	 BYTE PTR nbit$[rsp], al

; 904  : 
; 905  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 906  :     if(regs->psw.amode64 && gpr2 > 0xFFFFFFFFULL)
; 907  :     {
; 908  :         TRACE_F3_PT *tte;
; 909  :         size = sizeof(TRACE_F3_PT);
; 910  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 911  :         tte = (void*)(regs->mainstor + raddr);
; 912  :         tte->format = TRACE_F3_PT_FMT;
; 913  :         tte->pswkey = regs->psw.pkey | TRACE_F3_PT_FM2 | nbit;
; 914  :         STORE_HW(tte->newpasn, pasn);
; 915  :         STORE_DW(tte->r2, gpr2);
; 916  :     }
; 917  :     else
; 918  :     if(regs->psw.amode64)
; 919  :     {
; 920  :         TRACE_F2_PT *tte;
; 921  :         size = sizeof(TRACE_F2_PT);
; 922  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 923  :         tte = (void*)(regs->mainstor + raddr);
; 924  :         tte->format = TRACE_F2_PT_FMT;
; 925  :         tte->pswkey = regs->psw.pkey | TRACE_F2_PT_FM2 | nbit;
; 926  :         STORE_HW(tte->newpasn, pasn);
; 927  :         STORE_FW(tte->r2, gpr2 & 0xFFFFFFFF);
; 928  :     }
; 929  :     else
; 930  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 931  :     {
; 932  :         TRACE_F1_PT *tte;
; 933  :         size = sizeof(TRACE_F1_PT);

  00039	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 934  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00041	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00046	8b 54 24 28	 mov	 edx, DWORD PTR size$[rsp]
  0004a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ag$[rsp]
  0004f	e8 00 00 00 00	 call	 s390_get_trace_entry
  00054	48 89 44 24 38	 mov	 QWORD PTR raddr$[rsp], rax

; 935  :         tte = (void*)(regs->mainstor + raddr);

  00059	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00065	48 03 44 24 38	 add	 rax, QWORD PTR raddr$[rsp]
  0006a	48 89 44 24 30	 mov	 QWORD PTR tte$1[rsp], rax

; 936  :         tte->format = TRACE_F1_PT_FMT;

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR tte$1[rsp]
  00074	c6 00 31	 mov	 BYTE PTR [rax], 49	; 00000031H

; 937  :         tte->pswkey = regs->psw.pkey | TRACE_F1_PT_FM2 | nbit;

  00077	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00080	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR nbit$[rsp]
  00085	0b c1		 or	 eax, ecx
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tte$1[rsp]
  0008c	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 938  :         STORE_HW(tte->newpasn, pasn);

  0008f	0f b7 4c 24 68	 movzx	 ecx, WORD PTR pasn$[rsp]
  00094	e8 00 00 00 00	 call	 _byteswap_ushort
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tte$1[rsp]
  0009e	48 83 c1 02	 add	 rcx, 2
  000a2	0f b7 d0	 movzx	 edx, ax
  000a5	e8 00 00 00 00	 call	 store_hw_noswap

; 939  :         STORE_FW(tte->r2, gpr2 & 0xFFFFFFFF);

  000aa	8b 4c 24 70	 mov	 ecx, DWORD PTR gpr2$[rsp]
  000ae	e8 00 00 00 00	 call	 _byteswap_ulong
  000b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tte$1[rsp]
  000b8	48 83 c1 04	 add	 rcx, 4
  000bc	8b d0		 mov	 edx, eax
  000be	e8 00 00 00 00	 call	 store_fw_noswap

; 940  :     }
; 941  : 
; 942  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  000c3	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  000c8	44 8b 44 24 28	 mov	 r8d, DWORD PTR size$[rsp]
  000cd	48 8b 54 24 38	 mov	 rdx, QWORD PTR raddr$[rsp]
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ag$[rsp]
  000d7	e8 00 00 00 00	 call	 s390_set_trace_entry

; 943  : 
; 944  : } /* end function ARCH_DEP(trace_pt) */

  000dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e0	c3		 ret	 0
s390_trace_pt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
tv153 = 32
size$ = 36
tte$1 = 40
raddr$ = 48
ag$ = 56
newregs$ = 80
regs$ = 88
s390_trace_pr PROC

; 740  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_trace:

; 741  : RADR raddr;
; 742  : RADR ag;
; 743  : int  size;
; 744  : 
; 745  :     MAYBE_SET_PSW_IA_FROM_IP(regs);

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0001b	74 3f		 je	 SHORT $LN8@s390_trace
  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00028	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00032	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00039	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0003d	48 2b ca	 sub	 rcx, rdx
  00040	48 03 c1	 add	 rax, rcx
  00043	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0004e	48 23 c1	 and	 rax, rcx
  00051	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN8@s390_trace:
  0005c	33 c0		 xor	 eax, eax
  0005e	85 c0		 test	 eax, eax
  00060	75 ac		 jne	 SHORT $LN4@s390_trace
$LN7@s390_trace:

; 746  :     MAYBE_SET_PSW_IA_FROM_IP(newregs);

  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00067	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0006f	74 3f		 je	 SHORT $LN9@s390_trace
  00071	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00076	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  00081	48 8b 54 24 50	 mov	 rdx, QWORD PTR newregs$[rsp]
  00086	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0008d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00091	48 2b ca	 sub	 rcx, rdx
  00094	48 03 c1	 add	 rax, rcx
  00097	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  0009c	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  000a2	48 23 c1	 and	 rax, rcx
  000a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  000aa	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN9@s390_trace:
  000b0	33 c0		 xor	 eax, eax
  000b2	85 c0		 test	 eax, eax
  000b4	75 ac		 jne	 SHORT $LN7@s390_trace

; 747  : 
; 748  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 749  :     if(!regs->psw.amode64 && !newregs->psw.amode64)
; 750  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 751  :     {
; 752  :         TRACE_F1_PR *tte;
; 753  :         size = sizeof(TRACE_F1_PR);

  000b6	c7 44 24 24 0c
	00 00 00	 mov	 DWORD PTR size$[rsp], 12

; 754  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  000be	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000c3	8b 54 24 24	 mov	 edx, DWORD PTR size$[rsp]
  000c7	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  000cc	e8 00 00 00 00	 call	 s390_get_trace_entry
  000d1	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 755  :         tte = (void*)(regs->mainstor + raddr);

  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000e2	48 03 44 24 30	 add	 rax, QWORD PTR raddr$[rsp]
  000e7	48 89 44 24 28	 mov	 QWORD PTR tte$1[rsp], rax

; 756  :         tte->format = TRACE_F1_PR_FMT;

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR tte$1[rsp]
  000f1	c6 00 32	 mov	 BYTE PTR [rax], 50	; 00000032H

; 757  :         tte->pswkey = regs->psw.pkey | TRACE_F1_PR_FM2;

  000f4	48 8b 44 24 28	 mov	 rax, QWORD PTR tte$1[rsp]
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00102	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 758  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 05	 imul	 rax, rax, 5
  0010e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  00113	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  0011b	e8 00 00 00 00	 call	 _byteswap_ushort
  00120	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tte$1[rsp]
  00125	48 83 c1 02	 add	 rcx, 2
  00129	0f b7 d0	 movzx	 edx, ax
  0012c	e8 00 00 00 00	 call	 store_hw_noswap

; 759  :         STORE_FW(tte->retna, (newregs->psw.amode << 31)

  00131	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00136	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0013a	83 e0 01	 and	 eax, 1
  0013d	85 c0		 test	 eax, eax
  0013f	74 0a		 je	 SHORT $LN11@s390_trace
  00141	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  00149	eb 08		 jmp	 SHORT $LN12@s390_trace
$LN11@s390_trace:
  0014b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN12@s390_trace:
  00153	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00158	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0015e	d1 e8		 shr	 eax, 1
  00160	83 e0 01	 and	 eax, 1
  00163	c1 e0 1f	 shl	 eax, 31
  00166	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  0016b	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  00171	0b 44 24 20	 or	 eax, DWORD PTR tv153[rsp]
  00175	8b c8		 mov	 ecx, eax
  00177	e8 00 00 00 00	 call	 _byteswap_ulong
  0017c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tte$1[rsp]
  00181	48 83 c1 04	 add	 rcx, 4
  00185	8b d0		 mov	 edx, eax
  00187	e8 00 00 00 00	 call	 store_fw_noswap

; 760  :                                 | newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 761  :         STORE_FW(tte->newia, (regs->psw.amode << 31)

  0018c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00191	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00197	d1 e8		 shr	 eax, 1
  00199	83 e0 01	 and	 eax, 1
  0019c	c1 e0 1f	 shl	 eax, 31
  0019f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001a4	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  001aa	8b c8		 mov	 ecx, eax
  001ac	e8 00 00 00 00	 call	 _byteswap_ulong
  001b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tte$1[rsp]
  001b6	48 83 c1 08	 add	 rcx, 8
  001ba	8b d0		 mov	 edx, eax
  001bc	e8 00 00 00 00	 call	 store_fw_noswap

; 762  :                                  | regs->psw.IA_L);
; 763  :     }
; 764  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 765  :     else
; 766  :     if(regs->psw.amode64 && regs->psw.IA_H == 0 && !newregs->psw.amode64)
; 767  :     {
; 768  :         TRACE_F2_PR *tte;
; 769  :         size = sizeof(TRACE_F2_PR);
; 770  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 771  :         tte = (void*)(regs->mainstor + raddr);
; 772  :         tte->format = TRACE_F2_PR_FMT;
; 773  :         tte->pswkey = regs->psw.pkey | TRACE_F2_PR_FM2;
; 774  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));
; 775  :         STORE_FW(tte->retna, (newregs->psw.amode << 31)
; 776  :                                 | newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 777  :         STORE_FW(tte->newia, regs->psw.IA_L);
; 778  :     }
; 779  :     else
; 780  :     if(regs->psw.amode64 && regs->psw.IA_H != 0 && !newregs->psw.amode64)
; 781  :     {
; 782  :         TRACE_F3_PR *tte;
; 783  :         size = sizeof(TRACE_F3_PR);
; 784  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 785  :         tte = (void*)(regs->mainstor + raddr);
; 786  :         tte->format = TRACE_F3_PR_FMT;
; 787  :         tte->pswkey = regs->psw.pkey | TRACE_F3_PR_FM2;
; 788  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));
; 789  :         STORE_FW(tte->retna, (newregs->psw.amode << 31)
; 790  :                                 | newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 791  :         STORE_DW(tte->newia, regs->psw.IA_G);
; 792  :     }
; 793  :     else
; 794  :     if(!regs->psw.amode64  && newregs->psw.amode64 && newregs->psw.IA_H == 0)
; 795  :     {
; 796  :         TRACE_F4_PR *tte;
; 797  :         size = sizeof(TRACE_F4_PR);
; 798  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 799  :         tte = (void*)(regs->mainstor + raddr);
; 800  :         tte->format = TRACE_F4_PR_FMT;
; 801  :         tte->pswkey = regs->psw.pkey | TRACE_F4_PR_FM2;
; 802  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));
; 803  :         STORE_FW(tte->retna,  newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 804  :         STORE_FW(tte->newia, (regs->psw.amode << 31)
; 805  :                                  | regs->psw.IA_L);
; 806  :     }
; 807  :     else
; 808  :     if(regs->psw.amode64 && regs->psw.IA_H == 0 && newregs->psw.amode64 && newregs->psw.IA_H == 0)
; 809  :     {
; 810  :         TRACE_F5_PR *tte;
; 811  :         size = sizeof(TRACE_F5_PR);
; 812  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 813  :         tte = (void*)(regs->mainstor + raddr);
; 814  :         tte->format = TRACE_F5_PR_FMT;
; 815  :         tte->pswkey = regs->psw.pkey | TRACE_F5_PR_FM2;
; 816  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));
; 817  :         STORE_FW(tte->retna,  newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 818  :         STORE_FW(tte->newia, regs->psw.IA_L);
; 819  :     }
; 820  :     else
; 821  :     if(regs->psw.amode64 && regs->psw.IA_H != 0 && newregs->psw.amode64 && newregs->psw.IA_H == 0)
; 822  :     {
; 823  :         TRACE_F6_PR *tte;
; 824  :         size = sizeof(TRACE_F6_PR);
; 825  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 826  :         tte = (void*)(regs->mainstor + raddr);
; 827  :         tte->format = TRACE_F6_PR_FMT;
; 828  :         tte->pswkey = regs->psw.pkey | TRACE_F6_PR_FM2;
; 829  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));
; 830  :         STORE_FW(tte->retna,  newregs->psw.IA_L | PROBSTATE(&newregs->psw));
; 831  :         STORE_DW(tte->newia, regs->psw.IA_G);
; 832  :     }
; 833  :     else
; 834  :     if(!regs->psw.amode64 && newregs->psw.amode64 && newregs->psw.IA_H != 0)
; 835  :     {
; 836  :         TRACE_F7_PR *tte;
; 837  :         size = sizeof(TRACE_F7_PR);
; 838  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 839  :         tte = (void*)(regs->mainstor + raddr);
; 840  :         tte->format = TRACE_F7_PR_FMT;
; 841  :         tte->pswkey = regs->psw.pkey | TRACE_F7_PR_FM2;
; 842  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));
; 843  :         STORE_DW(tte->retna,  newregs->psw.IA_G | PROBSTATE(&newregs->psw));
; 844  :         STORE_FW(tte->newia, (regs->psw.amode << 31)
; 845  :                                  | regs->psw.IA_L);
; 846  :     }
; 847  :     else
; 848  :     if(regs->psw.amode64 && regs->psw.IA_H == 0 && newregs->psw.amode64 && newregs->psw.IA_H != 0)
; 849  :     {
; 850  :         TRACE_F8_PR *tte;
; 851  :         size = sizeof(TRACE_F8_PR);
; 852  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 853  :         tte = (void*)(regs->mainstor + raddr);
; 854  :         tte->format = TRACE_F8_PR_FMT;
; 855  :         tte->pswkey = regs->psw.pkey | TRACE_F8_PR_FM2;
; 856  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));
; 857  :         STORE_DW(tte->retna,  newregs->psw.IA_G | PROBSTATE(&newregs->psw));
; 858  :         STORE_FW(tte->newia, regs->psw.IA_L);
; 859  :     }
; 860  :     else
; 861  :     /* if(regs->psw.amode64 && regs->psw.IA_H != 0 && newregs->psw.amode64 && newregs->psw.IA_H != 0) */
; 862  :     {
; 863  :         TRACE_F9_PR *tte;
; 864  :         size = sizeof(TRACE_F9_PR);
; 865  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 866  :         tte = (void*)(regs->mainstor + raddr);
; 867  :         tte->format = TRACE_F9_PR_FMT;
; 868  :         tte->pswkey = regs->psw.pkey | TRACE_F9_PR_FM2;
; 869  :         STORE_HW(tte->newpasn, newregs->CR_LHL(4));
; 870  :         STORE_DW(tte->retna,  newregs->psw.IA_G | PROBSTATE(&newregs->psw));
; 871  :         STORE_DW(tte->newia, regs->psw.IA_G);
; 872  :     }
; 873  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 874  : 
; 875  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  001c1	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  001c6	44 8b 44 24 24	 mov	 r8d, DWORD PTR size$[rsp]
  001cb	48 8b 54 24 30	 mov	 rdx, QWORD PTR raddr$[rsp]
  001d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ag$[rsp]
  001d5	e8 00 00 00 00	 call	 s390_set_trace_entry

; 876  : 
; 877  : } /* end function ARCH_DEP(trace_pr) */

  001da	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001de	c3		 ret	 0
s390_trace_pr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
tv142 = 32
size$ = 36
tte$1 = 40
raddr$ = 48
ag$ = 56
pcea$ = 80
regs$ = 88
s390_trace_pc PROC

; 599  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_trace:

; 600  : RADR raddr;
; 601  : RADR ag;
; 602  : int  size;
; 603  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 604  : int  eamode;
; 605  : #endif
; 606  : 
; 607  :     MAYBE_SET_PSW_IA_FROM_IP(regs);

  0000d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00012	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0001a	74 3f		 je	 SHORT $LN5@s390_trace
  0001c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00027	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00031	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00038	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0003c	48 2b ca	 sub	 rcx, rdx
  0003f	48 03 c1	 add	 rax, rcx
  00042	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00047	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0004d	48 23 c1	 and	 rax, rcx
  00050	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00055	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN5@s390_trace:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 ac		 jne	 SHORT $LN4@s390_trace

; 608  : 
; 609  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 610  : 
; 611  :     eamode = regs->psw.amode64;
; 612  : 
; 613  :     if (ASN_AND_LX_REUSE_ENABLED(regs))
; 614  :     {
; 615  :         if ((pcea & PC_BIT44) && regs->psw.amode64 && regs->psw.IA_H)
; 616  :         {
; 617  :             /* In 64-bit mode, regardless of resulting mode, when
; 618  :                ASN-and-LX-reuse is enabled, 32-bit PC number is used,
; 619  :                and bits 0-31 of return address are not all zeros */
; 620  :             TRACE_F7_PC *tte;
; 621  :             size = sizeof(TRACE_F7_PC);
; 622  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 623  :             tte = (void*)(regs->mainstor + raddr);
; 624  :             tte->format = TRACE_F7_PC_FMT;
; 625  :             tte->pswkey = regs->psw.pkey | TRACE_F7_PC_FM2 | eamode;
; 626  :             STORE_HW(tte->resv, 0x0000);
; 627  :             STORE_DW(tte->retna, regs->psw.IA_G | PROBSTATE(&regs->psw));
; 628  :             STORE_FW(tte->pcnum, pcea);
; 629  :         }
; 630  :         else
; 631  :         if ((pcea & PC_BIT44) && regs->psw.amode64)
; 632  :         {
; 633  :             /* In 64-bit mode, regardless of resulting mode, when
; 634  :                ASN-and-LX-reuse is enabled, 32-bit PC number is used,
; 635  :                and bits 0-31 of return address are all zeros */
; 636  :             TRACE_F6_PC *tte;
; 637  :             size = sizeof(TRACE_F6_PC);
; 638  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 639  :             tte = (void*)(regs->mainstor + raddr);
; 640  :             tte->format = TRACE_F6_PC_FMT;
; 641  :             tte->pswkey = regs->psw.pkey | TRACE_F6_PC_FM2 | eamode;
; 642  :             STORE_HW(tte->resv, 0x0000);
; 643  :             STORE_FW(tte->retna, regs->psw.IA_L | PROBSTATE(&regs->psw));
; 644  :             STORE_FW(tte->pcnum, pcea);
; 645  :         }
; 646  :         else
; 647  :         if ((pcea & PC_BIT44))
; 648  :         {
; 649  :             /* In 24-bit or 31-bit mode, regardless of resulting mode, when
; 650  :                ASN-and-LX-reuse is enabled and 32-bit PC number is used */
; 651  :             TRACE_F5_PC *tte;
; 652  :             size = sizeof(TRACE_F5_PC);
; 653  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 654  :             tte = (void*)(regs->mainstor + raddr);
; 655  :             tte->format = TRACE_F5_PC_FMT;
; 656  :             tte->pswkey = regs->psw.pkey | TRACE_F5_PC_FM2 | eamode;
; 657  :             STORE_HW(tte->resv, 0x0000);
; 658  :             STORE_FW(tte->retna, (regs->psw.amode << 31) | regs->psw.IA_L | PROBSTATE(&regs->psw));
; 659  :             STORE_FW(tte->pcnum, pcea);
; 660  :         }
; 661  :         else
; 662  :         if(regs->psw.amode64)
; 663  :         {
; 664  :             /* In 64-bit mode, regardless of resulting mode, when
; 665  :                ASN-and-LX-reuse is enabled and 20-bit PC number is used */
; 666  :             TRACE_F4_PC *tte;
; 667  :             size = sizeof(TRACE_F4_PC);
; 668  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 669  :             tte = (void*)(regs->mainstor + raddr);
; 670  :             tte->format = TRACE_F4_PC_FMT;
; 671  :             tte->pswkey_pcnum_hi = regs->psw.pkey | ((pcea & 0xF0000) >> 16);
; 672  :             STORE_HW(tte->pcnum_lo, pcea & 0x0FFFF);
; 673  :             STORE_DW(tte->retna, regs->psw.IA_G | PROBSTATE(&regs->psw));
; 674  :         }
; 675  :         else
; 676  :         {
; 677  :             /* In 24-bit or 31-bit mode, regardless of resulting mode, when
; 678  :                ASN-and-LX-reuse is enabled and 20-bit PC number is used */
; 679  :             TRACE_F3_PC *tte;
; 680  :             size = sizeof(TRACE_F3_PC);
; 681  :             raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 682  :             tte = (void*)(regs->mainstor + raddr);
; 683  :             tte->format = TRACE_F3_PC_FMT;
; 684  :             tte->pswkey_pcnum_hi = regs->psw.pkey | ((pcea & 0xF0000) >> 16);
; 685  :             STORE_HW(tte->pcnum_lo, pcea & 0x0FFFF);
; 686  :             STORE_FW(tte->retna, (regs->psw.amode << 31) | regs->psw.IA_L | PROBSTATE(&regs->psw));
; 687  :         }
; 688  :     } /* end ASN_AND_LX_REUSE_ENABLED */
; 689  :     else
; 690  :     if(regs->psw.amode64)
; 691  :     {
; 692  :         /* In 64-bit mode, regardless of resulting mode,
; 693  :            when ASN-and-LX-reuse is not enabled */
; 694  :         TRACE_F2_PC *tte;
; 695  :         size = sizeof(TRACE_F2_PC);
; 696  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 697  :         tte = (void*)(regs->mainstor + raddr);
; 698  :         tte->format = TRACE_F2_PC_FMT;
; 699  :         tte->pswkey_pcnum_hi = regs->psw.pkey | ((pcea & 0xF0000) >> 16);
; 700  :         STORE_HW(tte->pcnum_lo, pcea & 0x0FFFF);
; 701  :         STORE_DW(tte->retna, regs->psw.IA_G | PROBSTATE(&regs->psw));
; 702  :     }
; 703  :     else
; 704  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 705  :     {
; 706  :         /* In 24-bit or 31-bit mode, regardless of resulting mode,
; 707  :            when ASN-and-LX-reuse is not enabled */
; 708  :         TRACE_F1_PC *tte;
; 709  :         size = sizeof(TRACE_F1_PC);

  00061	c7 44 24 24 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 710  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00069	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0006e	8b 54 24 24	 mov	 edx, DWORD PTR size$[rsp]
  00072	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  00077	e8 00 00 00 00	 call	 s390_get_trace_entry
  0007c	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 711  :         tte = (void*)(regs->mainstor + raddr);

  00081	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00086	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0008d	48 03 44 24 30	 add	 rax, QWORD PTR raddr$[rsp]
  00092	48 89 44 24 28	 mov	 QWORD PTR tte$1[rsp], rax

; 712  :         tte->format = TRACE_F1_PC_FMT;

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR tte$1[rsp]
  0009c	c6 00 21	 mov	 BYTE PTR [rax], 33	; 00000021H

; 713  :         tte->pswkey_pcnum_hi = regs->psw.pkey | ((pcea & 0xF0000) >> 16);

  0009f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000a8	8b 4c 24 50	 mov	 ecx, DWORD PTR pcea$[rsp]
  000ac	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  000b2	c1 e9 10	 shr	 ecx, 16
  000b5	0b c1		 or	 eax, ecx
  000b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tte$1[rsp]
  000bc	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 714  :         STORE_HW(tte->pcnum_lo, pcea & 0x0FFFF);

  000bf	8b 44 24 50	 mov	 eax, DWORD PTR pcea$[rsp]
  000c3	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000c8	0f b7 c8	 movzx	 ecx, ax
  000cb	e8 00 00 00 00	 call	 _byteswap_ushort
  000d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tte$1[rsp]
  000d5	48 83 c1 02	 add	 rcx, 2
  000d9	0f b7 d0	 movzx	 edx, ax
  000dc	e8 00 00 00 00	 call	 store_hw_noswap

; 715  :         STORE_FW(tte->retna, (regs->psw.amode << 31) | regs->psw.IA_L | PROBSTATE(&regs->psw));

  000e1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000ea	83 e0 01	 and	 eax, 1
  000ed	85 c0		 test	 eax, eax
  000ef	74 0a		 je	 SHORT $LN7@s390_trace
  000f1	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  000f9	eb 08		 jmp	 SHORT $LN8@s390_trace
$LN7@s390_trace:
  000fb	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN8@s390_trace:
  00103	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00108	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0010e	d1 e8		 shr	 eax, 1
  00110	83 e0 01	 and	 eax, 1
  00113	c1 e0 1f	 shl	 eax, 31
  00116	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	0b 81 88 00 00
	00		 or	 eax, DWORD PTR [rcx+136]
  00121	0b 44 24 20	 or	 eax, DWORD PTR tv142[rsp]
  00125	8b c8		 mov	 ecx, eax
  00127	e8 00 00 00 00	 call	 _byteswap_ulong
  0012c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tte$1[rsp]
  00131	48 83 c1 04	 add	 rcx, 4
  00135	8b d0		 mov	 edx, eax
  00137	e8 00 00 00 00	 call	 store_fw_noswap

; 716  :     }
; 717  : 
; 718  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  0013c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  00141	44 8b 44 24 24	 mov	 r8d, DWORD PTR size$[rsp]
  00146	48 8b 54 24 30	 mov	 rdx, QWORD PTR raddr$[rsp]
  0014b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ag$[rsp]
  00150	e8 00 00 00 00	 call	 s390_set_trace_entry

; 719  : 
; 720  : } /* end function ARCH_DEP(trace_pc) */

  00155	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00159	c3		 ret	 0
s390_trace_pc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
nbit$ = 32
tv65 = 36
size$ = 40
tte$1 = 48
raddr$ = 56
ag$ = 64
ssair$ = 96
sasn$ = 104
regs$ = 112
s390_trace_ssar PROC

; 566  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 567  : RADR raddr;
; 568  : RADR ag;
; 569  : int  size;
; 570  : BYTE nbit = (ssair ? 1 : 0);

  00012	83 7c 24 60 00	 cmp	 DWORD PTR ssair$[rsp], 0
  00017	74 0a		 je	 SHORT $LN3@s390_trace
  00019	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  00021	eb 08		 jmp	 SHORT $LN4@s390_trace
$LN3@s390_trace:
  00023	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN4@s390_trace:
  0002b	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv65[rsp]
  00030	88 44 24 20	 mov	 BYTE PTR nbit$[rsp], al

; 571  : 
; 572  :     {
; 573  :         TRACE_F1_SSAR *tte;
; 574  :         size = sizeof(TRACE_F1_SSAR);

  00034	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR size$[rsp], 4

; 575  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  0003c	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00041	8b 54 24 28	 mov	 edx, DWORD PTR size$[rsp]
  00045	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ag$[rsp]
  0004a	e8 00 00 00 00	 call	 s390_get_trace_entry
  0004f	48 89 44 24 38	 mov	 QWORD PTR raddr$[rsp], rax

; 576  :         tte = (void*)(regs->mainstor + raddr);

  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00060	48 03 44 24 38	 add	 rax, QWORD PTR raddr$[rsp]
  00065	48 89 44 24 30	 mov	 QWORD PTR tte$1[rsp], rax

; 577  :         tte->format = TRACE_F1_SSAR_FMT;

  0006a	48 8b 44 24 30	 mov	 rax, QWORD PTR tte$1[rsp]
  0006f	c6 00 10	 mov	 BYTE PTR [rax], 16

; 578  :         tte->extfmt = 0 | nbit;

  00072	48 8b 44 24 30	 mov	 rax, QWORD PTR tte$1[rsp]
  00077	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR nbit$[rsp]
  0007c	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 579  :         STORE_HW(tte->newsasn,sasn);

  0007f	0f b7 4c 24 68	 movzx	 ecx, WORD PTR sasn$[rsp]
  00084	e8 00 00 00 00	 call	 _byteswap_ushort
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tte$1[rsp]
  0008e	48 83 c1 02	 add	 rcx, 2
  00092	0f b7 d0	 movzx	 edx, ax
  00095	e8 00 00 00 00	 call	 store_hw_noswap

; 580  :     }
; 581  : 
; 582  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  0009a	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0009f	44 8b 44 24 28	 mov	 r8d, DWORD PTR size$[rsp]
  000a4	48 8b 54 24 38	 mov	 rdx, QWORD PTR raddr$[rsp]
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ag$[rsp]
  000ae	e8 00 00 00 00	 call	 s390_set_trace_entry

; 583  : 
; 584  : } /* end function ARCH_DEP(trace_ssar) */

  000b3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000b7	c3		 ret	 0
s390_trace_ssar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
size$ = 32
tte$1 = 40
raddr$ = 48
ag$ = 56
alet$ = 80
ia$ = 88
regs$ = 96
s390_trace_bsg PROC

; 513  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 514  : RADR raddr;
; 515  : RADR ag;
; 516  : int  size;
; 517  : 
; 518  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 519  :     if(regs->psw.amode64)
; 520  :     {
; 521  :         TRACE_F2_BSG *tte;
; 522  :         size = sizeof(TRACE_F2_BSG);
; 523  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 524  :         tte = (void*)(regs->mainstor + raddr);
; 525  :         tte->format = TRACE_F2_BSG_FMT;
; 526  :         tte->alet[0] = (alet >> 16) & 0xFF;
; 527  :         tte->alet[1] = (alet >> 8) & 0xFF;
; 528  :         tte->alet[2] = alet & 0xFF;
; 529  :         STORE_DW(tte->newia,ia);
; 530  :     }
; 531  :     else
; 532  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 533  :     {
; 534  :         TRACE_F1_BSG *tte;
; 535  :         size = sizeof(TRACE_F1_BSG);

  00011	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 536  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00019	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  0001e	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00022	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ag$[rsp]
  00027	e8 00 00 00 00	 call	 s390_get_trace_entry
  0002c	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 537  :         tte = (void*)(regs->mainstor + raddr);

  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00036	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0003d	48 03 44 24 30	 add	 rax, QWORD PTR raddr$[rsp]
  00042	48 89 44 24 28	 mov	 QWORD PTR tte$1[rsp], rax

; 538  :         tte->format = TRACE_F1_BSG_FMT;

  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR tte$1[rsp]
  0004c	c6 00 41	 mov	 BYTE PTR [rax], 65	; 00000041H

; 539  :         tte->alet[0] = ((alet >> 17) & 0x80) | ((alet >> 16) & 0x7F);

  0004f	8b 44 24 50	 mov	 eax, DWORD PTR alet$[rsp]
  00053	c1 e8 11	 shr	 eax, 17
  00056	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0005b	8b 4c 24 50	 mov	 ecx, DWORD PTR alet$[rsp]
  0005f	c1 e9 10	 shr	 ecx, 16
  00062	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00065	0b c1		 or	 eax, ecx
  00067	b9 01 00 00 00	 mov	 ecx, 1
  0006c	48 6b c9 00	 imul	 rcx, rcx, 0
  00070	48 8b 54 24 28	 mov	 rdx, QWORD PTR tte$1[rsp]
  00075	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 540  :         tte->alet[1] = (alet >> 8) & 0xFF;

  00079	8b 44 24 50	 mov	 eax, DWORD PTR alet$[rsp]
  0007d	c1 e8 08	 shr	 eax, 8
  00080	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00085	b9 01 00 00 00	 mov	 ecx, 1
  0008a	48 6b c9 01	 imul	 rcx, rcx, 1
  0008e	48 8b 54 24 28	 mov	 rdx, QWORD PTR tte$1[rsp]
  00093	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 541  :         tte->alet[2] = alet & 0xFF;

  00097	8b 44 24 50	 mov	 eax, DWORD PTR alet$[rsp]
  0009b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a0	b9 01 00 00 00	 mov	 ecx, 1
  000a5	48 6b c9 02	 imul	 rcx, rcx, 2
  000a9	48 8b 54 24 28	 mov	 rdx, QWORD PTR tte$1[rsp]
  000ae	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 542  :         if ((ia & 0x80000000) == 0)

  000b2	8b 44 24 58	 mov	 eax, DWORD PTR ia$[rsp]
  000b6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000bb	85 c0		 test	 eax, eax
  000bd	75 0d		 jne	 SHORT $LN2@s390_trace

; 543  :             ia &=0x00FFFFFF;

  000bf	8b 44 24 58	 mov	 eax, DWORD PTR ia$[rsp]
  000c3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c8	89 44 24 58	 mov	 DWORD PTR ia$[rsp], eax
$LN2@s390_trace:

; 544  :         STORE_FW(tte->newia,ia);

  000cc	8b 4c 24 58	 mov	 ecx, DWORD PTR ia$[rsp]
  000d0	e8 00 00 00 00	 call	 _byteswap_ulong
  000d5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tte$1[rsp]
  000da	48 83 c1 04	 add	 rcx, 4
  000de	8b d0		 mov	 edx, eax
  000e0	e8 00 00 00 00	 call	 store_fw_noswap

; 545  :     }
; 546  : 
; 547  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  000e5	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  000ea	44 8b 44 24 20	 mov	 r8d, DWORD PTR size$[rsp]
  000ef	48 8b 54 24 30	 mov	 rdx, QWORD PTR raddr$[rsp]
  000f4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ag$[rsp]
  000f9	e8 00 00 00 00	 call	 s390_set_trace_entry

; 548  : 
; 549  : } /* end function ARCH_DEP(trace_bsg) */

  000fe	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00102	c3		 ret	 0
s390_trace_bsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\trace.c
_TEXT	SEGMENT
size$ = 32
raddr$ = 40
ag$ = 48
tte$1 = 56
tte$2 = 64
amode$ = 96
ia$ = 104
regs$ = 112
s390_trace_br PROC

; 458  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 459  : RADR raddr;
; 460  : RADR ag;
; 461  : int  size;
; 462  : 
; 463  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 464  :     if(amode && ia > 0xFFFFFFFFULL)
; 465  :     {
; 466  :         TRACE_F3_BR *tte;
; 467  :         size = sizeof(TRACE_F3_BR);
; 468  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);
; 469  :         tte = (void*)(regs->mainstor + raddr);
; 470  :         tte->format = TRACE_F3_BR_FMT;
; 471  :         tte->fmt2 = TRACE_F3_BR_FM2;
; 472  :         STORE_HW(tte->resv,0);
; 473  :         STORE_DW(tte->newia64,ia);
; 474  :     }
; 475  :     else
; 476  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 477  :     if(amode)

  00011	83 7c 24 60 00	 cmp	 DWORD PTR amode$[rsp], 0
  00016	74 53		 je	 SHORT $LN2@s390_trace

; 478  :     {
; 479  :         TRACE_F2_BR *tte;
; 480  :         size = sizeof(TRACE_F2_BR);

  00018	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR size$[rsp], 4

; 481  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00020	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00025	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  00029	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  0002e	e8 00 00 00 00	 call	 s390_get_trace_entry
  00033	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 482  :         tte = (void*)(regs->mainstor + raddr);

  00038	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00044	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  00049	48 89 44 24 38	 mov	 QWORD PTR tte$1[rsp], rax

; 483  :         STORE_FW(tte->newia31,ia | 0x80000000);

  0004e	8b 44 24 68	 mov	 eax, DWORD PTR ia$[rsp]
  00052	0f ba e8 1f	 bts	 eax, 31
  00056	8b c8		 mov	 ecx, eax
  00058	e8 00 00 00 00	 call	 _byteswap_ulong
  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tte$1[rsp]
  00062	8b d0		 mov	 edx, eax
  00064	e8 00 00 00 00	 call	 store_fw_noswap

; 484  :     }

  00069	eb 52		 jmp	 SHORT $LN3@s390_trace
$LN2@s390_trace:

; 485  :     else
; 486  :     {
; 487  :         TRACE_F1_BR *tte;
; 488  :         size = sizeof(TRACE_F1_BR);

  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR size$[rsp], 4

; 489  :         raddr = ARCH_DEP(get_trace_entry) (&ag, size, regs);

  00073	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00078	8b 54 24 20	 mov	 edx, DWORD PTR size$[rsp]
  0007c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ag$[rsp]
  00081	e8 00 00 00 00	 call	 s390_get_trace_entry
  00086	48 89 44 24 28	 mov	 QWORD PTR raddr$[rsp], rax

; 490  :         tte = (void*)(regs->mainstor + raddr);

  0008b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00097	48 03 44 24 28	 add	 rax, QWORD PTR raddr$[rsp]
  0009c	48 89 44 24 40	 mov	 QWORD PTR tte$2[rsp], rax

; 491  :         STORE_FW(tte->newia24,ia & 0x00FFFFFF);

  000a1	8b 44 24 68	 mov	 eax, DWORD PTR ia$[rsp]
  000a5	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000aa	8b c8		 mov	 ecx, eax
  000ac	e8 00 00 00 00	 call	 _byteswap_ulong
  000b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tte$2[rsp]
  000b6	8b d0		 mov	 edx, eax
  000b8	e8 00 00 00 00	 call	 store_fw_noswap
$LN3@s390_trace:

; 492  :     }
; 493  : 
; 494  :     return ARCH_DEP(set_trace_entry) (ag, raddr, size, regs);

  000bd	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000c2	44 8b 44 24 20	 mov	 r8d, DWORD PTR size$[rsp]
  000c7	48 8b 54 24 28	 mov	 rdx, QWORD PTR raddr$[rsp]
  000cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ag$[rsp]
  000d1	e8 00 00 00 00	 call	 s390_set_trace_entry

; 495  : 
; 496  : } /* end function ARCH_DEP(trace_br) */

  000d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000da	c3		 ret	 0
s390_trace_br ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
ETOD$ = 8
ETOD2TOD PROC

; 205  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 206  :     return ((ETOD.high << 8) | (ETOD.low >> (64-8)));

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0000e	48 c1 e0 08	 shl	 rax, 8
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  0001e	48 0b c1	 or	 rax, rcx

; 207  : }

  00021	c3		 ret	 0
ETOD2TOD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
low$ = 0
high$ = 8
tv157 = 16
tv160 = 24
tv169 = 32
tv175 = 40
tv178 = 48
tv183 = 56
result$ = 80
a$ = 88
shift$ = 96
ETOD_shift PROC

; 284  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 285  :     register U64 high;
; 286  :     register U64 low;
; 287  : 
; 288  :     if (shift == 0)                 /* Zero shift: copy in to out */

  00013	83 7c 24 60 00	 cmp	 DWORD PTR shift$[rsp], 0
  00018	75 1f		 jne	 SHORT $LN2@ETOD_shift

; 289  :     {
; 290  :         high = a.high;

  0001a	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  0001f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00023	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax

; 291  :         low  = a.low;

  00028	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax

; 292  :     }

  00034	e9 9d 01 00 00	 jmp	 $LN3@ETOD_shift
$LN2@ETOD_shift:

; 293  :     else if (shift < 0)             /* Negtative: shift LEFT */

  00039	83 7c 24 60 00	 cmp	 DWORD PTR shift$[rsp], 0
  0003e	0f 8d d0 00 00
	00		 jge	 $LN4@ETOD_shift

; 294  :     {
; 295  :         shift = -shift;             /* (get positive shift amount) */

  00044	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  00048	f7 d8		 neg	 eax
  0004a	89 44 24 60	 mov	 DWORD PTR shift$[rsp], eax

; 296  : 
; 297  :         if (shift >= 64)            /* Negtative: shift LEFT >= 64 */

  0004e	83 7c 24 60 40	 cmp	 DWORD PTR shift$[rsp], 64 ; 00000040H
  00053	7c 5e		 jl	 SHORT $LN6@ETOD_shift

; 298  :         {
; 299  :             shift -= 64;            /* (get shift amount 0-64) */

  00055	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  00059	83 e8 40	 sub	 eax, 64			; 00000040H
  0005c	89 44 24 60	 mov	 DWORD PTR shift$[rsp], eax

; 300  : 
; 301  :             if (shift == 0)

  00060	83 7c 24 60 00	 cmp	 DWORD PTR shift$[rsp], 0
  00065	75 0f		 jne	 SHORT $LN8@ETOD_shift

; 302  :                 high = a.low;

  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  0006c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006f	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax
  00074	eb 33		 jmp	 SHORT $LN9@ETOD_shift
$LN8@ETOD_shift:

; 303  :             else if (shift > 64)

  00076	83 7c 24 60 40	 cmp	 DWORD PTR shift$[rsp], 64 ; 00000040H
  0007b	7e 0b		 jle	 SHORT $LN10@ETOD_shift

; 304  :                 high = 0;

  0007d	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR high$[rsp], 0
  00086	eb 21		 jmp	 SHORT $LN11@ETOD_shift
$LN10@ETOD_shift:

; 305  :             else
; 306  :                 high = a.low << shift;

  00088	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  0008c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  00091	48 89 4c 24 10	 mov	 QWORD PTR tv157[rsp], rcx
  00096	0f b6 c8	 movzx	 ecx, al
  00099	48 8b 44 24 10	 mov	 rax, QWORD PTR tv157[rsp]
  0009e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a1	48 d3 e0	 shl	 rax, cl
  000a4	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax
$LN11@ETOD_shift:
$LN9@ETOD_shift:

; 307  : 
; 308  :             low = 0;

  000a9	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR low$[rsp], 0

; 309  :         }

  000b1	eb 5c		 jmp	 SHORT $LN7@ETOD_shift
$LN6@ETOD_shift:

; 310  :         else                        /* Negtative: shift LEFT < 64 */
; 311  :         {
; 312  :             high = a.high << shift | a.low >> (64 - shift);

  000b3	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  000b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  000bc	48 89 4c 24 18	 mov	 QWORD PTR tv160[rsp], rcx
  000c1	0f b6 c8	 movzx	 ecx, al
  000c4	48 8b 44 24 18	 mov	 rax, QWORD PTR tv160[rsp]
  000c9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000cd	48 d3 e0	 shl	 rax, cl
  000d0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000d5	2b 4c 24 60	 sub	 ecx, DWORD PTR shift$[rsp]
  000d9	48 8b 54 24 58	 mov	 rdx, QWORD PTR a$[rsp]
  000de	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000e1	48 d3 ea	 shr	 rdx, cl
  000e4	48 8b ca	 mov	 rcx, rdx
  000e7	48 0b c1	 or	 rax, rcx
  000ea	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax

; 313  :             low  = a.low << shift;

  000ef	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  000f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  000f8	48 89 4c 24 20	 mov	 QWORD PTR tv169[rsp], rcx
  000fd	0f b6 c8	 movzx	 ecx, al
  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR tv169[rsp]
  00105	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00108	48 d3 e0	 shl	 rax, cl
  0010b	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax
$LN7@ETOD_shift:

; 314  :         }
; 315  :     }

  0010f	e9 c2 00 00 00	 jmp	 $LN5@ETOD_shift
$LN4@ETOD_shift:

; 316  :     else if (shift >= 64)           /* Positive: shift RIGHT >= 64 */

  00114	83 7c 24 60 40	 cmp	 DWORD PTR shift$[rsp], 64 ; 00000040H
  00119	7c 5e		 jl	 SHORT $LN12@ETOD_shift

; 317  :     {
; 318  :         shift -= 64;                /* (get shift amount 0-64) */

  0011b	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  0011f	83 e8 40	 sub	 eax, 64			; 00000040H
  00122	89 44 24 60	 mov	 DWORD PTR shift$[rsp], eax

; 319  :         high   = 0;

  00126	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR high$[rsp], 0

; 320  : 
; 321  :         if (shift == 0)

  0012f	83 7c 24 60 00	 cmp	 DWORD PTR shift$[rsp], 0
  00134	75 0f		 jne	 SHORT $LN14@ETOD_shift

; 322  :             low = a.high;

  00136	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  0013b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0013f	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax
  00143	eb 32		 jmp	 SHORT $LN15@ETOD_shift
$LN14@ETOD_shift:

; 323  :         else if (shift < 64)

  00145	83 7c 24 60 40	 cmp	 DWORD PTR shift$[rsp], 64 ; 00000040H
  0014a	7d 23		 jge	 SHORT $LN16@ETOD_shift

; 324  :             low = a.high >> shift;

  0014c	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  00150	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  00155	48 89 4c 24 28	 mov	 QWORD PTR tv175[rsp], rcx
  0015a	0f b6 c8	 movzx	 ecx, al
  0015d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv175[rsp]
  00162	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00166	48 d3 e8	 shr	 rax, cl
  00169	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax
  0016d	eb 08		 jmp	 SHORT $LN17@ETOD_shift
$LN16@ETOD_shift:

; 325  :         else
; 326  :             low = 0;

  0016f	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR low$[rsp], 0
$LN17@ETOD_shift:
$LN15@ETOD_shift:

; 327  :     }

  00177	eb 5d		 jmp	 SHORT $LN13@ETOD_shift
$LN12@ETOD_shift:

; 328  :     else                            /* Positive: shift RIGHT < 64 */
; 329  :     {
; 330  :         high = a.high >> shift;

  00179	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  0017d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  00182	48 89 4c 24 30	 mov	 QWORD PTR tv178[rsp], rcx
  00187	0f b6 c8	 movzx	 ecx, al
  0018a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv178[rsp]
  0018f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00193	48 d3 e8	 shr	 rax, cl
  00196	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax

; 331  :         low  = a.high << (64 - shift) | a.low >> shift;

  0019b	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  001a0	2b 44 24 60	 sub	 eax, DWORD PTR shift$[rsp]
  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  001a9	48 89 4c 24 38	 mov	 QWORD PTR tv183[rsp], rcx
  001ae	0f b6 c8	 movzx	 ecx, al
  001b1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv183[rsp]
  001b6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001ba	48 d3 e0	 shl	 rax, cl
  001bd	8b 4c 24 60	 mov	 ecx, DWORD PTR shift$[rsp]
  001c1	48 8b 54 24 58	 mov	 rdx, QWORD PTR a$[rsp]
  001c6	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  001c9	48 d3 ea	 shr	 rdx, cl
  001cc	48 8b ca	 mov	 rcx, rdx
  001cf	48 0b c1	 or	 rax, rcx
  001d2	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax
$LN13@ETOD_shift:
$LN5@ETOD_shift:
$LN3@ETOD_shift:

; 332  :     }
; 333  : 
; 334  :     result->low  = low;

  001d6	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  001db	48 8b 0c 24	 mov	 rcx, QWORD PTR low$[rsp]
  001df	48 89 08	 mov	 QWORD PTR [rax], rcx

; 335  :     result->high = high;

  001e2	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  001e7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR high$[rsp]
  001ec	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 336  : }

  001f0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f4	c3		 ret	 0
ETOD_shift ENDP
_TEXT	ENDS
END
