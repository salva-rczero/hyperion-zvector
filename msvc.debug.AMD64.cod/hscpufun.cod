; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG159226 DB	'qproc', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	stopall_cmd
PUBLIC	start_cmd_cpu
PUBLIC	stop_cmd_cpu
PUBLIC	restart_cmd
PUBLIC	cpu_cmd
PUBLIC	startall_cmd
PUBLIC	cf_cmd
PUBLIC	cfall_cmd
PUBLIC	sysreset_cmd
PUBLIC	sysclear_cmd
PUBLIC	ipl_cmd
PUBLIC	iplc_cmd
PUBLIC	ext_cmd
PUBLIC	timerint_cmd
PUBLIC	format_tod
PUBLIC	clocks_cmd
PUBLIC	store_cmd
PUBLIC	alrf_cmd
PUBLIC	cmpscpad_cmd
EXTRN	__imp_islower:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	etod_clock:PROC
EXTRN	get_cpu_timer:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	store_status:PROC
EXTRN	load_ipl:PROC
EXTRN	system_reset:PROC
EXTRN	load_hmc:PROC
EXTRN	s370_sdias_store_status:PROC
EXTRN	support_boot:PROC
EXTRN	load_boot:PROC
EXTRN	txf_set_timerint:PROC
EXTRN	find_device_by_devnum:PROC
EXTRN	configure_cpu:PROC
EXTRN	deconfigure_cpu:PROC
EXTRN	configure_numcpu:PROC
EXTRN	qproc_cmd:PROC
EXTRN	InternalHercCmd:PROC
EXTRN	HercCmdLine:PROC
EXTRN	set_loadparm:PROC
EXTRN	str_loadparm:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	hw_tod:BYTE
EXTRN	tod_value:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG159095 DB	01H DUP (?)
$SG159283 DB	01H DUP (?)
$SG159295 DB	01H DUP (?)
$SG159316 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$strcaseabbrev DD imagerel strcaseabbrev
	DD	imagerel strcaseabbrev+320
	DD	imagerel $unwind$strcaseabbrev
$pdata$strupper DD imagerel strupper
	DD	imagerel strupper+114
	DD	imagerel $unwind$strupper
$pdata$stopall_cmd DD imagerel $LN11
	DD	imagerel $LN11+230
	DD	imagerel $unwind$stopall_cmd
$pdata$start_cmd_cpu DD imagerel $LN20
	DD	imagerel $LN20+815
	DD	imagerel $unwind$start_cmd_cpu
$pdata$stop_cmd_cpu DD imagerel $LN23
	DD	imagerel $LN23+816
	DD	imagerel $unwind$stop_cmd_cpu
$pdata$restart_cmd DD imagerel $LN19
	DD	imagerel $LN19+873
	DD	imagerel $unwind$restart_cmd
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpus_mask DD imagerel wakeup_cpus_mask
	DD	imagerel wakeup_cpus_mask+106
	DD	imagerel $unwind$wakeup_cpus_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$stop_all_cpus_intlock_held DD imagerel stop_all_cpus_intlock_held
	DD	imagerel stop_all_cpus_intlock_held+221
	DD	imagerel $unwind$stop_all_cpus_intlock_held
$pdata$are_any_cpus_started_intlock_held DD imagerel are_any_cpus_started_intlock_held
	DD	imagerel are_any_cpus_started_intlock_held+118
	DD	imagerel $unwind$are_any_cpus_started_intlock_held
$pdata$stop_all_cpus DD imagerel stop_all_cpus
	DD	imagerel stop_all_cpus+42
	DD	imagerel $unwind$stop_all_cpus
$pdata$missing_devnum DD imagerel missing_devnum
	DD	imagerel missing_devnum+80
	DD	imagerel $unwind$missing_devnum
$pdata$cpu_cmd DD imagerel $LN22
	DD	imagerel $LN22+983
	DD	imagerel $unwind$cpu_cmd
$pdata$startall_cmd DD imagerel $LN16
	DD	imagerel $LN16+452
	DD	imagerel $unwind$startall_cmd
$pdata$cf_cmd DD imagerel $LN23
	DD	imagerel $LN23+708
	DD	imagerel $unwind$cf_cmd
$pdata$cfall_cmd DD imagerel $LN21
	DD	imagerel $LN21+539
	DD	imagerel $unwind$cfall_cmd
$pdata$reset_cmd DD imagerel reset_cmd
	DD	imagerel reset_cmd+130
	DD	imagerel $unwind$reset_cmd
$pdata$sysreset_cmd DD imagerel $LN10
	DD	imagerel $LN10+543
	DD	imagerel $unwind$sysreset_cmd
$pdata$sysclear_cmd DD imagerel $LN5
	DD	imagerel $LN5+327
	DD	imagerel $unwind$sysclear_cmd
$pdata$ipl_cmd2 DD imagerel ipl_cmd2
	DD	imagerel ipl_cmd2+2442
	DD	imagerel $unwind$ipl_cmd2
$pdata$ipl_cmd DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$ipl_cmd
$pdata$iplc_cmd DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$iplc_cmd
$pdata$ext_cmd DD imagerel $LN22
	DD	imagerel $LN22+462
	DD	imagerel $unwind$ext_cmd
$pdata$timerint_cmd DD imagerel $LN26
	DD	imagerel $LN26+1453
	DD	imagerel $unwind$timerint_cmd
$pdata$format_tod DD imagerel $LN8
	DD	imagerel $LN8+576
	DD	imagerel $unwind$format_tod
$pdata$clocks_cmd DD imagerel $LN26
	DD	imagerel $LN26+3083
	DD	imagerel $unwind$clocks_cmd
$pdata$store_cmd DD imagerel $LN18
	DD	imagerel $LN18+753
	DD	imagerel $unwind$store_cmd
$pdata$alrf_cmd DD imagerel $LN14
	DD	imagerel $LN14+544
	DD	imagerel $unwind$alrf_cmd
$pdata$cmpscpad_cmd DD imagerel $LN16
	DD	imagerel $LN16+1068
	DD	imagerel $unwind$cmpscpad_cmd
pdata	ENDS
_DATA	SEGMENT
	ORG $+2
$SG158926 DB	'C:\papa\MyGit\hyperion-zvector\hinlines.h:466', 00H
	ORG $+2
$SG158979 DB	'C:\papa\MyGit\hyperion-zvector\hinlines.h:562', 00H
	ORG $+2
$SG158980 DB	'C:\papa\MyGit\hyperion-zvector\hinlines.h:566', 00H
	ORG $+2
$SG159053 DB	'E', 00H
	ORG $+2
$SG159091 DB	'W', 00H
	ORG $+2
$SG159054 DB	'HHC02201%s Device number missing', 0aH, 00H
	ORG $+2
$SG159096 DB	'I', 00H
	ORG $+2
$SG159055 DB	'missing_devnum', 00H
	ORG $+1
$SG159056 DB	'hscpufun.c', 00H
	ORG $+1
$SG159104 DB	'E', 00H
	ORG $+2
$SG159090 DB	' (currently offline)', 00H
	ORG $+3
$SG159092 DB	'HHC02240%s Processor %s%02X%s', 0aH, 00H
	ORG $+1
$SG159093 DB	'cpu_cmd', 00H
$SG159094 DB	'hscpufun.c', 00H
	ORG $+1
$SG159140 DB	'E', 00H
	ORG $+2
$SG159097 DB	'HHC02240%s Processor %s%02X%s', 0aH, 00H
	ORG $+1
$SG159098 DB	'cpu_cmd', 00H
$SG159099 DB	'hscpufun.c', 00H
	ORG $+1
$SG159102 DB	'%x%c', 00H
	ORG $+3
$SG159159 DB	'E', 00H
	ORG $+2
$SG159103 DB	': target processor is invalid', 00H
	ORG $+2
$SG159105 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159185 DB	'ON', 00H
	ORG $+1
$SG159106 DB	'cpu_cmd', 00H
$SG159107 DB	'hscpufun.c', 00H
	ORG $+1
$SG159187 DB	'OFF', 00H
$SG159136 DB	'hscpufun.c:112', 00H
	ORG $+1
$SG159138 DB	'hscpufun.c:121', 00H
	ORG $+1
$SG159139 DB	'hscpufun.c:125', 00H
	ORG $+1
$SG159194 DB	'HHC00819%s Processor %s%02X: online', 0aH, 00H
	ORG $+3
$SG159141 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+2
$SG159193 DB	'I', 00H
	ORG $+2
$SG159142 DB	'startall_cmd', 00H
	ORG $+3
$SG159143 DB	'hscpufun.c', 00H
	ORG $+5
$SG159161 DB	'stopall_cmd', 00H
$SG159195 DB	'cf_cmd', 00H
	ORG $+5
$SG159160 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+2
$SG159200 DB	'I', 00H
	ORG $+2
$SG159162 DB	'hscpufun.c', 00H
	ORG $+1
$SG159232 DB	'ON', 00H
	ORG $+1
$SG159188 DB	'hscpufun.c:176', 00H
	ORG $+1
$SG159196 DB	'hscpufun.c', 00H
	ORG $+1
$SG159235 DB	'OFF', 00H
$SG159201 DB	'HHC00820%s Processor %s%02X: offline', 0aH, 00H
	ORG $+2
$SG159202 DB	'cf_cmd', 00H
	ORG $+1
$SG159203 DB	'hscpufun.c', 00H
	ORG $+1
$SG159236 DB	'E', 00H
	ORG $+2
$SG159205 DB	'hscpufun.c:195', 00H
	ORG $+1
?qproc@?1??cfall_cmd@@9@9 DQ FLAT:$SG159226		; `cfall_cmd'::`2'::qproc
	DQ	0000000000000000H
$SG159237 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+1
$SG159243 DB	'E', 00H
	ORG $+2
$SG159238 DB	'cfall_cmd', 00H
	ORG $+2
$SG159284 DB	'E', 00H
	ORG $+2
$SG159239 DB	'hscpufun.c', 00H
	ORG $+5
$SG159270 DB	'hscpufun.c:287', 00H
	ORG $+1
$SG159285 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+6
$SG159244 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+2
$SG159294 DB	'normal', 00H
	ORG $+1
$SG159296 DB	'E', 00H
	ORG $+2
$SG159245 DB	'cfall_cmd', 00H
	ORG $+2
$SG159301 DB	'I', 00H
	ORG $+2
$SG159246 DB	'hscpufun.c', 00H
	ORG $+1
$SG159317 DB	'E', 00H
	ORG $+2
$SG159271 DB	'hscpufun.c:297', 00H
	ORG $+1
$SG159286 DB	'sysreset_cmd', 00H
	ORG $+3
$SG159287 DB	'hscpufun.c', 00H
	ORG $+1
$SG159291 DB	'clear', 00H
	ORG $+2
$SG159322 DB	'I', 00H
	ORG $+2
$SG159297 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159375 DB	'online', 00H
	ORG $+1
$SG159376 DB	'E', 00H
	ORG $+2
$SG159298 DB	'sysreset_cmd', 00H
	ORG $+3
$SG159299 DB	'hscpufun.c', 00H
	ORG $+1
$SG159382 DB	'E', 00H
	ORG $+2
$SG159302 DB	'HHC02311%s %s completed', 0aH, 00H
	ORG $+3
$SG159390 DB	'CLEAR', 00H
	ORG $+2
$SG159395 DB	'E', 00H
	ORG $+2
$SG159303 DB	'sysreset_cmd', 00H
	ORG $+3
$SG159304 DB	'hscpufun.c', 00H
	ORG $+1
$SG159403 DB	'E', 00H
	ORG $+2
$SG159318 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159410 DB	'E', 00H
	ORG $+2
$SG159319 DB	'sysclear_cmd', 00H
	ORG $+3
$SG159320 DB	'hscpufun.c', 00H
	ORG $+1
$SG159426 DB	'E', 00H
	ORG $+2
$SG159323 DB	'HHC02311%s %s completed', 0aH, 00H
	ORG $+3
$SG159420 DB	'%hx%c', 00H
	ORG $+2
$SG159479 DB	'E', 00H
	ORG $+2
$SG159324 DB	'sysclear_cmd', 00H
	ORG $+3
$SG159325 DB	'hscpufun.c', 00H
	ORG $+1
$SG159484 DB	'I', 00H
	ORG $+2
$SG159377 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+2
$SG159491 DB	'online', 00H
	ORG $+1
$SG159492 DB	'W', 00H
	ORG $+2
$SG159378 DB	'ipl_cmd2', 00H
	ORG $+3
$SG159424 DB	'%hd%c', 00H
	ORG $+2
$SG159538 DB	'I', 00H
	ORG $+2
$SG159379 DB	'hscpufun.c', 00H
	ORG $+1
$SG159574 DB	'I', 00H
	ORG $+2
$SG159383 DB	'HHC00818%s Processor %s%02X: not eligible for ipl nor re'
	DB	'start', 0aH, 00H
	ORG $+1
$SG159384 DB	'ipl_cmd2', 00H
	ORG $+3
$SG159570 DB	'RESET', 00H
	ORG $+2
$SG159582 DB	'%d', 00H
	ORG $+1
$SG159385 DB	'hscpufun.c', 00H
	ORG $+1
$SG159583 DB	'I', 00H
	ORG $+2
$SG159393 DB	'LOADPARM', 00H
	ORG $+7
$SG159396 DB	'HHC02202%s Missing argument(s). Type ''help %s'' for ass'
	DB	'istance.', 0aH, 00H
$SG159397 DB	'ipl_cmd2', 00H
	ORG $+3
$SG159588 DB	'E', 00H
	ORG $+2
$SG159398 DB	'hscpufun.c', 00H
	ORG $+1
$SG159401 DB	'PARM', 00H
	ORG $+7
$SG159406 DB	'hscpufun.c', 00H
	ORG $+5
$SG159409 DB	': unrecognized option', 00H
	ORG $+2
$SG159404 DB	'HHC02202%s Missing argument(s). Type ''help %s'' for ass'
	DB	'istance.', 0aH, 00H
$SG159405 DB	'ipl_cmd2', 00H
	ORG $+3
$SG159595 DB	'%d', 00H
	ORG $+1
$SG159411 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159596 DB	'I', 00H
	ORG $+2
$SG159412 DB	'ipl_cmd2', 00H
	ORG $+3
$SG159600 DB	'E', 00H
	ORG $+2
$SG159413 DB	'hscpufun.c', 00H
	ORG $+1
$SG159675 DB	'W', 00H
	ORG $+2
$SG159414 DB	'hscpufun.c:488', 00H
	ORG $+1
$SG159425 DB	': LCSS id is invalid', 00H
	ORG $+3
$SG159427 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159674 DB	'online', 00H
	ORG $+1
$SG159684 DB	'I', 00H
	ORG $+2
$SG159428 DB	'ipl_cmd2', 00H
	ORG $+3
$SG159689 DB	'I', 00H
	ORG $+2
$SG159429 DB	'hscpufun.c', 00H
	ORG $+1
$SG159696 DB	'I', 00H
	ORG $+2
$SG159430 DB	'hscpufun.c:549', 00H
	ORG $+1
$SG159433 DB	'hscpufun.c:571', 00H
	ORG $+1
$SG159480 DB	'HHC00818%s Processor %s%02X: not eligible for ipl nor re'
	DB	'start', 0aH, 00H
	ORG $+1
$SG159481 DB	'restart_cmd', 00H
$SG159701 DB	'I', 00H
	ORG $+2
$SG159482 DB	'hscpufun.c', 00H
	ORG $+1
$SG159709 DB	'I', 00H
	ORG $+2
$SG159483 DB	'restart', 00H
$SG159485 DB	'HHC02228%s %s key pressed', 0aH, 00H
	ORG $+1
$SG159715 DB	'I', 00H
	ORG $+2
$SG159486 DB	'restart_cmd', 00H
$SG159722 DB	'I', 00H
	ORG $+2
$SG159487 DB	'hscpufun.c', 00H
	ORG $+1
$SG159727 DB	'I', 00H
	ORG $+2
$SG159488 DB	'hscpufun.c:619', 00H
	ORG $+1
$SG159490 DB	'hscpufun.c:623', 00H
	ORG $+1
$SG159493 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+2
$SG159732 DB	'I', 00H
	ORG $+2
$SG159494 DB	'restart_cmd', 00H
$SG159738 DB	'I', 00H
	ORG $+2
$SG159495 DB	'hscpufun.c', 00H
	ORG $+1
$SG159742 DB	'E', 00H
	ORG $+2
$SG159497 DB	'hscpufun.c:642', 00H
	ORG $+1
$SG159498 DB	'hscpufun.c:645', 00H
	ORG $+1
$SG159532 DB	'hscpufun.c:660', 00H
	ORG $+1
$SG159537 DB	'interrupt', 00H
	ORG $+2
$SG159772 DB	'online', 00H
	ORG $+1
$SG159773 DB	'W', 00H
	ORG $+2
$SG159539 DB	'HHC02228%s %s key pressed', 0aH, 00H
	ORG $+1
$SG159778 DB	'E', 00H
	ORG $+2
$SG159540 DB	'ext_cmd', 00H
$SG159541 DB	'hscpufun.c', 00H
	ORG $+1
$SG159783 DB	'I', 00H
	ORG $+2
$SG159542 DB	'hscpufun.c:668', 00H
	ORG $+1
$SG159543 DB	'hscpufun.c:670', 00H
	ORG $+1
$SG159569 DB	'DEFAULT', 00H
$SG159575 DB	'HHC02204%s %-14s set to %s', 0aH, 00H
$SG159818 DB	'W', 00H
	ORG $+2
$SG159576 DB	'timerint_cmd', 00H
	ORG $+3
$SG159577 DB	'hscpufun.c', 00H
	ORG $+1
$SG159580 DB	'%d%c', 00H
	ORG $+3
$SG159824 DB	'I', 00H
	ORG $+2
$SG159584 DB	'HHC02204%s %-14s set to %s', 0aH, 00H
$SG159829 DB	'W', 00H
	ORG $+2
$SG159585 DB	'timerint_cmd', 00H
	ORG $+3
$SG159586 DB	'hscpufun.c', 00H
	ORG $+1
$SG159869 DB	'W', 00H
	ORG $+2
$SG159587 DB	': must be ''default'' or n where 50 <= n <= 1000000', 00H
	ORG $+2
$SG159828 DB	'online', 00H
	ORG $+1
$SG159875 DB	'I', 00H
	ORG $+2
$SG159589 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159879 DB	'online', 00H
	ORG $+1
$SG159880 DB	'W', 00H
	ORG $+2
$SG159590 DB	'timerint_cmd', 00H
	ORG $+3
$SG159591 DB	'hscpufun.c', 00H
	ORG $+1
$SG159904 DB	'E', 00H
	ORG $+2
$SG159597 DB	'HHC02203%s %-14s: %s', 0aH, 00H
	ORG $+2
$SG159598 DB	'timerint_cmd', 00H
	ORG $+3
$SG159599 DB	'hscpufun.c', 00H
	ORG $+5
$SG159602 DB	'timerint_cmd', 00H
	ORG $+3
$SG159671 DB	'hscpufun.c:852', 00H
	ORG $+1
$SG159676 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+6
$SG159601 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+2
$SG159912 DB	'W', 00H
	ORG $+2
$SG159603 DB	'hscpufun.c', 00H
	ORG $+1
$SG159943 DB	'E', 00H
	ORG $+2
$SG159624 DB	'%4d.%03d %02d:%02d:%02d.%06d', 00H
	ORG $+3
$SG159673 DB	'hscpufun.c:856', 00H
	ORG $+1
$SG159677 DB	'clocks_cmd', 00H
	ORG $+1
$SG159950 DB	'E', 00H
	ORG $+2
$SG159678 DB	'hscpufun.c', 00H
	ORG $+1
$SG159959 DB	'E', 00H
	ORG $+2
$SG159681 DB	'%02u:%02u:%02u.%06u', 00H
$SG159964 DB	'%d', 00H
	ORG $+1
$SG159682 DB	'hscpufun.c:891', 00H
	ORG $+1
$SG159683 DB	'tod = %16.16llX    %s', 00H
	ORG $+2
$SG159685 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159686 DB	'clocks_cmd', 00H
	ORG $+1
$SG159965 DB	'I', 00H
	ORG $+2
$SG159687 DB	'hscpufun.c', 00H
	ORG $+1
$SG159970 DB	'%d', 00H
	ORG $+1
$SG159688 DB	'h/w = %16.16llX    %s', 00H
	ORG $+2
$SG159690 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159691 DB	'clocks_cmd', 00H
	ORG $+1
$SG159971 DB	'I', 00H
	ORG $+2
$SG159692 DB	'hscpufun.c', 00H
	ORG $+5
$SG159695 DB	'off = %16.16llX   %c%s', 00H
	ORG $+1
$SG159697 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159698 DB	'clocks_cmd', 00H
	ORG $+5
$SG159699 DB	'hscpufun.c', 00H
	ORG $+5
$SG159700 DB	'ckc = %16.16llX    %s', 00H
	ORG $+2
$SG159702 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159703 DB	'clocks_cmd', 00H
	ORG $+5
$SG159704 DB	'hscpufun.c', 00H
	ORG $+5
$SG159707 DB	'cpt = %16.16llX', 00H
$SG159708 DB	'cpt = %16.16llX         not decrementing', 00H
	ORG $+3
$SG159910 DB	'QUERY', 00H
	ORG $+6
$SG159710 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159711 DB	'clocks_cmd', 00H
	ORG $+5
$SG159712 DB	'hscpufun.c', 00H
	ORG $+5
$SG159714 DB	'vtod = %16.16llX    %s', 00H
	ORG $+1
$SG159716 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159717 DB	'clocks_cmd', 00H
	ORG $+5
$SG159718 DB	'hscpufun.c', 00H
	ORG $+5
$SG159721 DB	'voff = %16.16llX   %c%s', 00H
$SG159723 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159724 DB	'clocks_cmd', 00H
	ORG $+5
$SG159725 DB	'hscpufun.c', 00H
	ORG $+5
$SG159726 DB	'vckc = %16.16llX    %s', 00H
	ORG $+1
$SG159728 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159729 DB	'clocks_cmd', 00H
	ORG $+5
$SG159730 DB	'hscpufun.c', 00H
	ORG $+5
$SG159731 DB	'vcpt = %16.16llX', 00H
	ORG $+7
$SG159733 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159734 DB	'clocks_cmd', 00H
	ORG $+5
$SG159735 DB	'hscpufun.c', 00H
	ORG $+5
$SG159737 DB	'itm = %8.8X                     %s', 00H
	ORG $+5
$SG159739 DB	'HHC02274%s %s', 0aH, 00H
	ORG $+1
$SG159740 DB	'clocks_cmd', 00H
	ORG $+5
$SG159741 DB	'hscpufun.c', 00H
	ORG $+5
$SG159743 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+6
$SG159744 DB	'clocks_cmd', 00H
	ORG $+5
$SG159745 DB	'hscpufun.c', 00H
	ORG $+5
$SG159769 DB	'hscpufun.c:989', 00H
	ORG $+1
$SG159771 DB	'hscpufun.c:993', 00H
	ORG $+1
$SG159774 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+6
$SG159775 DB	'store_cmd', 00H
	ORG $+6
$SG159776 DB	'hscpufun.c', 00H
	ORG $+5
$SG159779 DB	'HHC02224%s Store status rejected: CPU not stopped', 0aH, 00H
	ORG $+5
$SG159780 DB	'store_cmd', 00H
	ORG $+6
$SG159781 DB	'hscpufun.c', 00H
	ORG $+5
$SG159782 DB	'hscpufun.c:1013', 00H
$SG159784 DB	'HHC00817%s Processor %s%02X: store status completed', 0aH
	DB	00H
	ORG $+3
$SG159785 DB	'store_cmd', 00H
	ORG $+6
$SG159786 DB	'hscpufun.c', 00H
	ORG $+5
$SG159812 DB	'hscpufun.c:1033', 00H
$SG159817 DB	'stopped', 00H
$SG159819 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+6
$SG159820 DB	'start_cmd_cpu', 00H
	ORG $+2
$SG159821 DB	'hscpufun.c', 00H
	ORG $+5
$SG159822 DB	'hscpufun.c:1050', 00H
$SG159823 DB	'running state selected', 00H
	ORG $+1
$SG159825 DB	'HHC00834%s Processor %s%02X: %s', 0aH, 00H
	ORG $+7
$SG159826 DB	'start_cmd_cpu', 00H
	ORG $+2
$SG159827 DB	'hscpufun.c', 00H
	ORG $+5
$SG159830 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+6
$SG159831 DB	'start_cmd_cpu', 00H
	ORG $+2
$SG159832 DB	'hscpufun.c', 00H
	ORG $+5
$SG159833 DB	'hscpufun.c:1060', 00H
$SG159863 DB	'hscpufun.c:1078', 00H
$SG159868 DB	'started', 00H
$SG159870 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+6
$SG159871 DB	'stop_cmd_cpu', 00H
	ORG $+3
$SG159872 DB	'hscpufun.c', 00H
	ORG $+5
$SG159873 DB	'hscpufun.c:1093', 00H
$SG159874 DB	'manual state selected', 00H
	ORG $+2
$SG159876 DB	'HHC00834%s Processor %s%02X: %s', 0aH, 00H
	ORG $+7
$SG159877 DB	'stop_cmd_cpu', 00H
	ORG $+3
$SG159878 DB	'hscpufun.c', 00H
	ORG $+5
$SG159881 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+6
$SG159882 DB	'stop_cmd_cpu', 00H
	ORG $+3
$SG159883 DB	'hscpufun.c', 00H
	ORG $+5
$SG159884 DB	'hscpufun.c:1103', 00H
$SG159905 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+6
$SG159906 DB	'alrf_cmd', 00H
	ORG $+7
$SG159907 DB	'hscpufun.c', 00H
	ORG $+5
$SG159911 DB	'; use ''ARCHLVL %s 006_ASN_LX_REUSE'' instead', 00H
	ORG $+4
$SG159913 DB	'HHC02256%s Command ''%s'' is deprecated%s', 0aH, 00H
	ORG $+7
$SG159914 DB	'alrf_cmd', 00H
	ORG $+7
$SG159915 DB	'hscpufun.c', 00H
	ORG $+5
$SG159944 DB	'HHC01455%s Invalid number of arguments for %s', 0aH, 00H
	ORG $+1
$SG159945 DB	'cmpscpad_cmd', 00H
	ORG $+3
$SG159946 DB	'hscpufun.c', 00H
	ORG $+5
$SG159947 DB	'hscpufun.c:1163', 00H
$SG159949 DB	'hscpufun.c:1167', 00H
$SG159951 DB	'HHC02389%s CPUs must be offline or stopped', 0aH, 00H
	ORG $+4
$SG159952 DB	'cmpscpad_cmd', 00H
	ORG $+3
$SG159953 DB	'hscpufun.c', 00H
	ORG $+5
$SG159958 DB	'hscpufun.c:1187', 00H
$SG159960 DB	'HHC17014%s %s value is invalid; valid range is %d - %d', 0aH
	DB	00H
$SG159961 DB	'cmpscpad_cmd', 00H
	ORG $+3
$SG159962 DB	'hscpufun.c', 00H
	ORG $+5
$SG159963 DB	'hscpufun.c:1196', 00H
$SG159966 DB	'HHC02204%s %-14s set to %s', 0aH, 00H
	ORG $+4
$SG159967 DB	'cmpscpad_cmd', 00H
	ORG $+3
$SG159968 DB	'hscpufun.c', 00H
	ORG $+5
$SG159969 DB	'hscpufun.c:1206', 00H
$SG159972 DB	'HHC02203%s %-14s: %s', 0aH, 00H
	ORG $+2
$SG159973 DB	'cmpscpad_cmd', 00H
	ORG $+3
$SG159974 DB	'hscpufun.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cmpscpad_cmd
	DD	01fH
	DD	0414H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:alrf_cmd
	DD	020H
	DD	0207H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clocks_cmd
	DD	021H
	DD	0bf1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:timerint_cmd
	DD	01fH
	DD	0595H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cpu_cmd
	DD	020H
	DD	03beH
voltbl	ENDS
xdata	SEGMENT
$unwind$strcaseabbrev DD 011301H
	DD	08213H
$unwind$strupper DD 010e01H
	DD	0620eH
$unwind$stopall_cmd DD 011201H
	DD	0a212H
$unwind$start_cmd_cpu DD 021501H
	DD	0110115H
$unwind$stop_cmd_cpu DD 021501H
	DD	0110115H
$unwind$restart_cmd DD 011201H
	DD	0c212H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpus_mask DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$stop_all_cpus_intlock_held DD 010401H
	DD	08204H
$unwind$are_any_cpus_started_intlock_held DD 010401H
	DD	02204H
$unwind$stop_all_cpus DD 010401H
	DD	04204H
$unwind$missing_devnum DD 010401H
	DD	08204H
$unwind$cpu_cmd DD 032819H
	DD	0340116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$startall_cmd DD 011201H
	DD	0c212H
$unwind$cf_cmd DD 011201H
	DD	0e212H
$unwind$cfall_cmd DD 011201H
	DD	0c212H
$unwind$reset_cmd DD 011701H
	DD	06217H
$unwind$sysreset_cmd DD 011201H
	DD	0e212H
$unwind$sysclear_cmd DD 011201H
	DD	0e212H
$unwind$ipl_cmd2 DD 031b01H
	DD	01c011bH
	DD	07014H
$unwind$ipl_cmd DD 011201H
	DD	06212H
$unwind$iplc_cmd DD 011201H
	DD	06212H
$unwind$ext_cmd DD 011201H
	DD	0a212H
$unwind$timerint_cmd DD 022719H
	DD	01d0115H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$format_tod DD 011301H
	DD	0c213H
$unwind$clocks_cmd DD 042919H
	DD	03f0117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$store_cmd DD 011201H
	DD	0e212H
$unwind$alrf_cmd DD 032819H
	DD	0200116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$cmpscpad_cmd DD 022719H
	DD	0150115H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
bits$ = 80
ptr$ = 88
nxt$ = 96
tv77 = 104
tv157 = 112
tv177 = 120
tv198 = 128
buf$ = 136
__$ArrayPad$ = 144
argc$ = 176
argv$ = 184
cmdline$ = 192
cmpscpad_cmd PROC

; 1144 : {

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cmpscpad_c:

; 1145 :     int bits;
; 1146 :     const char* ptr;
; 1147 :     char* nxt;
; 1148 :     char buf[8];
; 1149 : 
; 1150 :     UPPER_ARGV_0( argv );

  00027	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  00030	74 47		 je	 SHORT $LN8@cmpscpad_c
  00032	b8 08 00 00 00	 mov	 eax, 8
  00037	48 6b c0 00	 imul	 rax, rax, 0
  0003b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00043	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00048	74 2f		 je	 SHORT $LN8@cmpscpad_c
  0004a	b8 08 00 00 00	 mov	 eax, 8
  0004f	48 6b c0 00	 imul	 rax, rax, 0
  00053	b9 08 00 00 00	 mov	 ecx, 8
  00058	48 6b c9 00	 imul	 rcx, rcx, 0
  0005c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00064	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  00068	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00070	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  00074	e8 00 00 00 00	 call	 strupper
$LN8@cmpscpad_c:
  00079	33 c0		 xor	 eax, eax
  0007b	85 c0		 test	 eax, eax
  0007d	75 a8		 jne	 SHORT $LN4@cmpscpad_c
$LN7@cmpscpad_c:

; 1151 : 
; 1152 :     UNREFERENCED( cmdline );

  0007f	33 c0		 xor	 eax, eax
  00081	85 c0		 test	 eax, eax
  00083	75 fa		 jne	 SHORT $LN7@cmpscpad_c

; 1153 : 
; 1154 :     if ( argc > 2 )

  00085	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0008d	7e 75		 jle	 SHORT $LN9@cmpscpad_c

; 1155 :     {
; 1156 :         // "Invalid number of arguments for %s"
; 1157 :         WRMSG( HHC01455, "E", argv[0] );

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 00	 imul	 rax, rax, 0
  00098	48 89 44 24 68	 mov	 QWORD PTR tv77[rsp], rax
  0009d	b9 01 00 00 00	 mov	 ecx, 1
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000b0	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv77[rsp]
  000b5	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  000b9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159943
  000c5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159944
  000d1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000db	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159945
  000e8	ba 85 04 00 00	 mov	 edx, 1157		; 00000485H
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159946
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1158 :         return HERROR;

  000fa	b8 ff ff ff ff	 mov	 eax, -1
  000ff	e9 10 03 00 00	 jmp	 $LN1@cmpscpad_c
$LN9@cmpscpad_c:

; 1159 :     }
; 1160 : 
; 1161 :     /* Ensure all CPUs have been stopped */
; 1162 : 
; 1163 :     OBTAIN_INTLOCK( NULL );

  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159947
  0010b	33 c9		 xor	 ecx, ecx
  0010d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1164 : 
; 1165 :     if (are_any_cpus_started_intlock_held())

  00112	e8 00 00 00 00	 call	 are_any_cpus_started_intlock_held
  00117	0f b6 c0	 movzx	 eax, al
  0011a	85 c0		 test	 eax, eax
  0011c	74 5f		 je	 SHORT $LN10@cmpscpad_c

; 1166 :     {
; 1167 :         RELEASE_INTLOCK( NULL );

  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159949
  00125	33 c9		 xor	 ecx, ecx
  00127	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1168 :         // "CPUs must be offline or stopped"
; 1169 :         WRMSG( HHC02389, "E" );

  0012c	b9 01 00 00 00	 mov	 ecx, 1
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159950
  0013e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159951
  0014a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00154	41 b9 03 00 00
	00		 mov	 r9d, 3
  0015a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159952
  00161	ba 91 04 00 00	 mov	 edx, 1169		; 00000491H
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159953
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1170 :         return HERRCPUONL;

  00173	b8 fd ff ff ff	 mov	 eax, -3
  00178	e9 97 02 00 00	 jmp	 $LN1@cmpscpad_c
$LN10@cmpscpad_c:

; 1171 :     }
; 1172 : 
; 1173 :     if ( argc == 2 )

  0017d	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00185	0f 85 ca 01 00
	00		 jne	 $LN11@cmpscpad_c

; 1174 :     {
; 1175 :         ptr   = argv[1];

  0018b	b8 08 00 00 00	 mov	 eax, 8
  00190	48 6b c0 01	 imul	 rax, rax, 1
  00194	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0019c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  001a0	48 89 44 24 58	 mov	 QWORD PTR ptr$[rsp], rax

; 1176 :         errno = 0;

  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ab	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1177 :         bits  = (int) strtoul( ptr, &nxt, 10 );

  001b1	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001b7	48 8d 54 24 60	 lea	 rdx, QWORD PTR nxt$[rsp]
  001bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ptr$[rsp]
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  001c7	89 44 24 50	 mov	 DWORD PTR bits$[rsp], eax

; 1178 : 
; 1179 :         if (0
; 1180 :             || errno != 0
; 1181 :             || nxt == ptr
; 1182 :             || *nxt != 0
; 1183 :             || bits < MIN_CMPSC_ZP_BITS
; 1184 :             || bits > MAX_CMPSC_ZP_BITS

  001cb	33 c0		 xor	 eax, eax
  001cd	85 c0		 test	 eax, eax
  001cf	75 35		 jne	 SHORT $LN14@cmpscpad_c
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d7	83 38 00	 cmp	 DWORD PTR [rax], 0
  001da	75 2a		 jne	 SHORT $LN14@cmpscpad_c
  001dc	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  001e1	48 39 44 24 60	 cmp	 QWORD PTR nxt$[rsp], rax
  001e6	74 1e		 je	 SHORT $LN14@cmpscpad_c
  001e8	48 8b 44 24 60	 mov	 rax, QWORD PTR nxt$[rsp]
  001ed	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001f0	85 c0		 test	 eax, eax
  001f2	75 12		 jne	 SHORT $LN14@cmpscpad_c
  001f4	83 7c 24 50 01	 cmp	 DWORD PTR bits$[rsp], 1
  001f9	7c 0b		 jl	 SHORT $LN14@cmpscpad_c
  001fb	83 7c 24 50 0c	 cmp	 DWORD PTR bits$[rsp], 12
  00200	0f 8e 93 00 00
	00		 jle	 $LN13@cmpscpad_c
$LN14@cmpscpad_c:

; 1185 :         )
; 1186 :         {
; 1187 :             RELEASE_INTLOCK( NULL );

  00206	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159958
  0020d	33 c9		 xor	 ecx, ecx
  0020f	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1188 :             // "%s value is invalid; valid range is %d - %d"
; 1189 :             WRMSG( HHC17014 , "E", argv[0],

  00214	b8 08 00 00 00	 mov	 eax, 8
  00219	48 6b c0 00	 imul	 rax, rax, 0
  0021d	48 89 44 24 70	 mov	 QWORD PTR tv157[rsp], rax
  00222	b9 01 00 00 00	 mov	 ecx, 1
  00227	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022d	c7 44 24 48 0c
	00 00 00	 mov	 DWORD PTR [rsp+72], 12
  00235	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR [rsp+64], 1
  0023d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00245	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv157[rsp]
  0024a	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0024e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00253	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159959
  0025a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0025f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159960
  00266	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0026b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00270	41 b9 03 00 00
	00		 mov	 r9d, 3
  00276	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159961
  0027d	ba a6 04 00 00	 mov	 edx, 1190		; 000004a6H
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159962
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1190 :                 MIN_CMPSC_ZP_BITS, MAX_CMPSC_ZP_BITS );
; 1191 :             return HERROR;

  0028f	b8 ff ff ff ff	 mov	 eax, -1
  00294	e9 7b 01 00 00	 jmp	 $LN1@cmpscpad_c
$LN13@cmpscpad_c:

; 1192 :         }
; 1193 : 
; 1194 :         /* Update SYSBLK with new value */
; 1195 :         sysblk.zpbits = (BYTE) bits;

  00299	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002a0	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR bits$[rsp]
  002a5	88 88 99 0e 00
	00		 mov	 BYTE PTR [rax+3737], cl

; 1196 :         RELEASE_INTLOCK( NULL );

  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159963
  002b2	33 c9		 xor	 ecx, ecx
  002b4	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1197 : 
; 1198 :         MSGBUF( buf, "%d", bits );

  002b9	44 8b 4c 24 50	 mov	 r9d, DWORD PTR bits$[rsp]
  002be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159964
  002c5	ba 08 00 00 00	 mov	 edx, 8
  002ca	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1199 :         // "%-14s set to %s"
; 1200 :         WRMSG( HHC02204, "I", argv[0], buf );

  002d8	b8 08 00 00 00	 mov	 eax, 8
  002dd	48 6b c0 00	 imul	 rax, rax, 0
  002e1	48 89 44 24 78	 mov	 QWORD PTR tv177[rsp], rax
  002e6	b9 01 00 00 00	 mov	 ecx, 1
  002eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f1	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002f9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002fe	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00306	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv177[rsp]
  0030b	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0030f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00314	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159965
  0031b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00320	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159966
  00327	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00331	41 b9 03 00 00
	00		 mov	 r9d, 3
  00337	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159967
  0033e	ba b0 04 00 00	 mov	 edx, 1200		; 000004b0H
  00343	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159968
  0034a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1201 :     }

  00350	e9 bd 00 00 00	 jmp	 $LN12@cmpscpad_c
$LN11@cmpscpad_c:

; 1202 :     else
; 1203 :     {
; 1204 :         /* Display current SYSBLK value */
; 1205 :         bits = sysblk.zpbits;

  00355	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0035c	0f b6 80 99 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3737]
  00363	89 44 24 50	 mov	 DWORD PTR bits$[rsp], eax

; 1206 :         RELEASE_INTLOCK( NULL );

  00367	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159969
  0036e	33 c9		 xor	 ecx, ecx
  00370	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1207 : 
; 1208 :         MSGBUF( buf, "%d", bits );

  00375	44 8b 4c 24 50	 mov	 r9d, DWORD PTR bits$[rsp]
  0037a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159970
  00381	ba 08 00 00 00	 mov	 edx, 8
  00386	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0038e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1209 :         // "%-14s: %s"
; 1210 :         WRMSG( HHC02203, "I", argv[0], buf );

  00394	b8 08 00 00 00	 mov	 eax, 8
  00399	48 6b c0 00	 imul	 rax, rax, 0
  0039d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  003a5	b9 01 00 00 00	 mov	 ecx, 1
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b0	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003b8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003bd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003c5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv198[rsp]
  003cd	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  003d1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159971
  003dd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159972
  003e9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f3	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159973
  00400	ba ba 04 00 00	 mov	 edx, 1210		; 000004baH
  00405	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159974
  0040c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@cmpscpad_c:

; 1211 :     }
; 1212 : 
; 1213 :     return HNOERROR;

  00412	33 c0		 xor	 eax, eax
$LN1@cmpscpad_c:

; 1214 : }

  00414	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0041c	48 33 cc	 xor	 rcx, rsp
  0041f	e8 00 00 00 00	 call	 __security_check_cookie
  00424	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0042b	c3		 ret	 0
cmpscpad_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
archlvl_func$ = 80
tv82 = 88
tv139 = 96
buffer$ = 112
__$ArrayPad$ = 240
argc$ = 272
argv$ = 280
cmdline$ = 288
alrf_cmd PROC

; 1113 : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1114 :     char   buffer[128] = {0};

  00028	48 8d 44 24 70	 lea	 rax, QWORD PTR buffer$[rsp]
  0002d	48 8b f8	 mov	 rdi, rax
  00030	33 c0		 xor	 eax, eax
  00032	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00037	f3 aa		 rep stosb
$LN4@alrf_cmd:

; 1115 :     char*  archlvl_func;
; 1116 : 
; 1117 :     UNREFERENCED( cmdline );

  00039	33 c0		 xor	 eax, eax
  0003b	85 c0		 test	 eax, eax
  0003d	75 fa		 jne	 SHORT $LN4@alrf_cmd
$LN7@alrf_cmd:

; 1118 :     UPPER_ARGV_0( argv );

  0003f	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  00048	74 47		 je	 SHORT $LN8@alrf_cmd
  0004a	b8 08 00 00 00	 mov	 eax, 8
  0004f	48 6b c0 00	 imul	 rax, rax, 0
  00053	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0005b	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00060	74 2f		 je	 SHORT $LN8@alrf_cmd
  00062	b8 08 00 00 00	 mov	 eax, 8
  00067	48 6b c0 00	 imul	 rax, rax, 0
  0006b	b9 08 00 00 00	 mov	 ecx, 8
  00070	48 6b c9 00	 imul	 rcx, rcx, 0
  00074	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0007c	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  00080	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00088	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  0008c	e8 00 00 00 00	 call	 strupper
$LN8@alrf_cmd:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 a8		 jne	 SHORT $LN7@alrf_cmd

; 1119 : 
; 1120 :     if (argc < 1 || argc > 2)

  00097	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0009f	7c 0a		 jl	 SHORT $LN10@alrf_cmd
  000a1	83 bc 24 10 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  000a9	7e 75		 jle	 SHORT $LN9@alrf_cmd
$LN10@alrf_cmd:

; 1121 :     {
; 1122 :         // "Invalid command usage. Type 'help %s' for assistance."
; 1123 :         WRMSG( HHC02299, "E", argv[0] );

  000ab	b8 08 00 00 00	 mov	 eax, 8
  000b0	48 6b c0 00	 imul	 rax, rax, 0
  000b4	48 89 44 24 58	 mov	 QWORD PTR tv82[rsp], rax
  000b9	b9 01 00 00 00	 mov	 ecx, 1
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000cc	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv82[rsp]
  000d1	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  000d5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159904
  000e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159905
  000ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159906
  00104	ba 63 04 00 00	 mov	 edx, 1123		; 00000463H
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159907
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1124 :         return -1;

  00116	b8 ff ff ff ff	 mov	 eax, -1
  0011b	e9 e7 00 00 00	 jmp	 $LN1@alrf_cmd
$LN9@alrf_cmd:

; 1125 :     }
; 1126 : 
; 1127 :     if      (argc == 1)    archlvl_func = "QUERY";

  00120	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00128	75 0e		 jne	 SHORT $LN11@alrf_cmd
  0012a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159910
  00131	48 89 44 24 50	 mov	 QWORD PTR archlvl_func$[rsp], rax
  00136	eb 34		 jmp	 SHORT $LN12@alrf_cmd
$LN11@alrf_cmd:

; 1128 :     else /* (argc == 2) */ archlvl_func = STR2UPPER( argv[1] );

  00138	b8 08 00 00 00	 mov	 eax, 8
  0013d	48 6b c0 01	 imul	 rax, rax, 1
  00141	b9 08 00 00 00	 mov	 ecx, 8
  00146	48 6b c9 01	 imul	 rcx, rcx, 1
  0014a	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00152	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  00156	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0015e	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  00162	e8 00 00 00 00	 call	 strupper
  00167	48 89 44 24 50	 mov	 QWORD PTR archlvl_func$[rsp], rax
$LN12@alrf_cmd:

; 1129 : 
; 1130 :     MSGBUF( buffer, "; use 'ARCHLVL %s 006_ASN_LX_REUSE' instead", archlvl_func );

  0016c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR archlvl_func$[rsp]
  00171	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159911
  00178	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0017d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buffer$[rsp]
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1131 : 
; 1132 :     // "Command '%s' is deprecated%s"
; 1133 :     WRMSG( HHC02256, "W", argv[0], buffer );

  00188	b8 08 00 00 00	 mov	 eax, 8
  0018d	48 6b c0 00	 imul	 rax, rax, 0
  00191	48 89 44 24 60	 mov	 QWORD PTR tv139[rsp], rax
  00196	b9 01 00 00 00	 mov	 ecx, 1
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buffer$[rsp]
  001a6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ab	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001b3	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv139[rsp]
  001b8	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159912
  001c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159913
  001d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001de	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159914
  001eb	ba 6d 04 00 00	 mov	 edx, 1133		; 0000046dH
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159915
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1134 : 
; 1135 :     return InternalHercCmd( buffer );

  001fd	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buffer$[rsp]
  00202	e8 00 00 00 00	 call	 InternalHercCmd
$LN1@alrf_cmd:

; 1136 : }

  00207	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0020f	48 33 cc	 xor	 rcx, rsp
  00212	e8 00 00 00 00	 call	 __security_check_cookie
  00217	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  0021e	5f		 pop	 rdi
  0021f	c3		 ret	 0
alrf_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
tv178 = 80
regs$ = 88
tv133 = 96
tv180 = 104
argc$ = 128
argv$ = 136
cmdline$ = 144
store_cmd PROC

; 980  : {

$LN18:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN4@store_cmd:

; 981  : REGS *regs;
; 982  : 
; 983  :     UPPER_ARGV_0( argv );

  00012	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  0001b	74 47		 je	 SHORT $LN14@store_cmd
  0001d	b8 08 00 00 00	 mov	 eax, 8
  00022	48 6b c0 00	 imul	 rax, rax, 0
  00026	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0002e	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00033	74 2f		 je	 SHORT $LN14@store_cmd
  00035	b8 08 00 00 00	 mov	 eax, 8
  0003a	48 6b c0 00	 imul	 rax, rax, 0
  0003e	b9 08 00 00 00	 mov	 ecx, 8
  00043	48 6b c9 00	 imul	 rcx, rcx, 0
  00047	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0004f	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  00053	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0005b	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  0005f	e8 00 00 00 00	 call	 strupper
$LN14@store_cmd:
  00064	33 c0		 xor	 eax, eax
  00066	85 c0		 test	 eax, eax
  00068	75 a8		 jne	 SHORT $LN4@store_cmd
$LN7@store_cmd:

; 984  : 
; 985  :     UNREFERENCED(cmdline);

  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 fa		 jne	 SHORT $LN7@store_cmd
$LN10@store_cmd:

; 986  :     UNREFERENCED(argc);

  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 fa		 jne	 SHORT $LN10@store_cmd
$LN13@store_cmd:

; 987  :     UNREFERENCED(argv);

  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 fa		 jne	 SHORT $LN13@store_cmd

; 988  : 
; 989  :     obtain_lock(&sysblk.cpulock[sysblk.pcpu]);

  0007c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00083	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00091	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159769
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 990  : 
; 991  :     if (!IS_CPU_ONLINE(sysblk.pcpu))

  000a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b0	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000be	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000c7	0f 85 ca 00 00
	00		 jne	 $LN15@store_cmd

; 992  :     {
; 993  :         release_lock(&sysblk.cpulock[sysblk.pcpu]);

  000cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d4	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e2	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  000ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159771
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 994  :         WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "online");

  000fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00101	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00108	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0010f	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0011d	48 89 44 24 60	 mov	 QWORD PTR tv133[rsp], rax
  00122	b9 01 00 00 00	 mov	 ecx, 1
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159772
  00134	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00139	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00140	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00146	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0014a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv133[rsp]
  0014f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159773
  0015b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159774
  00167	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00171	41 b9 03 00 00
	00		 mov	 r9d, 3
  00177	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159775
  0017e	ba e2 03 00 00	 mov	 edx, 994		; 000003e2H
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159776
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 995  :         return 0;

  00190	33 c0		 xor	 eax, eax
  00192	e9 55 01 00 00	 jmp	 $LN1@store_cmd
$LN15@store_cmd:

; 996  :     }
; 997  :     regs = sysblk.regs[sysblk.pcpu];

  00197	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0019e	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001ac	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001b4	48 89 44 24 58	 mov	 QWORD PTR regs$[rsp], rax

; 998  : 
; 999  :     /* Command is valid only when CPU is stopped */
; 1000 :     if (regs->cpustate != CPUSTATE_STOPPED)

  001b9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001be	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  001c2	83 f8 03	 cmp	 eax, 3
  001c5	74 51		 je	 SHORT $LN16@store_cmd

; 1001 :     {
; 1002 :         WRMSG(HHC02224, "E");

  001c7	b9 01 00 00 00	 mov	 ecx, 1
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159778
  001d9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159779
  001e5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ef	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159780
  001fc	ba ea 03 00 00	 mov	 edx, 1002		; 000003eaH
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159781
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1003 :         return -1;

  0020e	b8 ff ff ff ff	 mov	 eax, -1
  00213	e9 d4 00 00 00	 jmp	 $LN1@store_cmd
$LN16@store_cmd:

; 1004 :     }
; 1005 : 
; 1006 :     /* Store status in 512 byte block at absolute location 0 */
; 1007 :     store_status (regs, 0);

  00218	33 d2		 xor	 edx, edx
  0021a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	e8 00 00 00 00	 call	 store_status

; 1008 : 
; 1009 : #if defined(_FEATURE_HARDWARE_LOADER)
; 1010 :     ARCH_DEP(sdias_store_status)(regs);

  00224	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	e8 00 00 00 00	 call	 s370_sdias_store_status

; 1011 : #endif /*defined(_FEATURE_HARDWARE_LOADER)*/
; 1012 : 
; 1013 :     release_lock(&sysblk.cpulock[sysblk.pcpu]);

  0022e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00235	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0023c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00243	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0024b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159782
  00252	48 8b c8	 mov	 rcx, rax
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1014 : 
; 1015 :     WRMSG(HHC00817, "I", PTYPSTR(regs->cpuad), regs->cpuad);

  0025b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00260	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00267	89 44 24 50	 mov	 DWORD PTR tv178[rsp], eax
  0026b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00277	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0027e	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0028c	48 89 44 24 68	 mov	 QWORD PTR tv180[rsp], rax
  00291	b9 01 00 00 00	 mov	 ecx, 1
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029c	8b 4c 24 50	 mov	 ecx, DWORD PTR tv178[rsp]
  002a0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv180[rsp]
  002a9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159783
  002b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159784
  002c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159785
  002d8	ba f7 03 00 00	 mov	 edx, 1015		; 000003f7H
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159786
  002e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1016 : 
; 1017 :     return 0;

  002ea	33 c0		 xor	 eax, eax
$LN1@store_cmd:

; 1018 : }

  002ec	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002f0	c3		 ret	 0
store_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
vepoch_sign$ = 80
epoch_sign$ = 81
sie_flag$ = 82
arch370_flag$ = 83
itimer$ = 84
regs$ = 88
rc$ = 96
vepoch_now$ = 104
epoch_now$ = 112
tv184 = 120
tv187 = 124
tv190 = 128
tv253 = 132
tv375 = 136
vtod_now$ = 144
vepoch_now_abs$ = 152
vclkc_now$ = 160
epoch_now_abs$ = 168
clkc_now$ = 176
cpt_now$ = 184
vcpt_now$ = 192
tv132 = 200
tv204 = 208
tv225 = 216
tv248 = 224
tv271 = 232
tv347 = 240
tv370 = 248
tv393 = 256
tv444 = 264
$T1 = 272
$T2 = 288
hw_now$ = 304
tod_now$ = 320
buf$ = 336
clock_buf$ = 416
itimer_formatted$ = 448
__$ArrayPad$ = 480
argc$ = 528
argv$ = 536
cmdline$ = 544
clocks_cmd PROC

; 821  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 822  : REGS *regs;
; 823  : char clock_buf[30];
; 824  : ETOD tod_now;
; 825  : ETOD hw_now;
; 826  : S64 epoch_now;
; 827  : U64 epoch_now_abs;
; 828  : char epoch_sign;
; 829  : U64 clkc_now;
; 830  : S64 cpt_now;
; 831  : #if defined(_FEATURE_SIE)
; 832  : U64 vtod_now = 0;

  00029	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR vtod_now$[rsp], 0

; 833  : S64 vepoch_now = 0;

  00035	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR vepoch_now$[rsp], 0

; 834  : U64 vepoch_now_abs = 0;

  0003e	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR vepoch_now_abs$[rsp], 0

; 835  : char vepoch_sign = ' ';

  0004a	c6 44 24 50 20	 mov	 BYTE PTR vepoch_sign$[rsp], 32 ; 00000020H

; 836  : U64 vclkc_now = 0;

  0004f	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR vclkc_now$[rsp], 0

; 837  : S64 vcpt_now = 0;

  0005b	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR vcpt_now$[rsp], 0

; 838  : char sie_flag = 0;

  00067	c6 44 24 52 00	 mov	 BYTE PTR sie_flag$[rsp], 0

; 839  : #endif
; 840  : U32 itimer = 0;

  0006c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR itimer$[rsp], 0

; 841  : char itimer_formatted[32];
; 842  : char arch370_flag = 0;

  00074	c6 44 24 53 00	 mov	 BYTE PTR arch370_flag$[rsp], 0

; 843  : char buf[72];
; 844  : int rc = 0;

  00079	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@clocks_cmd:

; 845  : 
; 846  :     UPPER_ARGV_0( argv );

  00081	48 83 bc 24 18
	02 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  0008a	74 47		 je	 SHORT $LN11@clocks_cmd
  0008c	b8 08 00 00 00	 mov	 eax, 8
  00091	48 6b c0 00	 imul	 rax, rax, 0
  00095	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0009d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000a2	74 2f		 je	 SHORT $LN11@clocks_cmd
  000a4	b8 08 00 00 00	 mov	 eax, 8
  000a9	48 6b c0 00	 imul	 rax, rax, 0
  000ad	b9 08 00 00 00	 mov	 ecx, 8
  000b2	48 6b c9 00	 imul	 rcx, rcx, 0
  000b6	48 8b 94 24 18
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000be	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  000c2	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000ca	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  000ce	e8 00 00 00 00	 call	 strupper
$LN11@clocks_cmd:
  000d3	33 c0		 xor	 eax, eax
  000d5	85 c0		 test	 eax, eax
  000d7	75 a8		 jne	 SHORT $LN4@clocks_cmd
$LN7@clocks_cmd:

; 847  : 
; 848  :     UNREFERENCED(cmdline);

  000d9	33 c0		 xor	 eax, eax
  000db	85 c0		 test	 eax, eax
  000dd	75 fa		 jne	 SHORT $LN7@clocks_cmd

; 849  : 
; 850  :     if ( argc == 1 ) for (;;)

  000df	83 bc 24 10 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000e7	0f 85 87 0a 00
	00		 jne	 $LN12@clocks_cmd
$LN8@clocks_cmd:

; 851  :     {
; 852  :         obtain_lock(&sysblk.cpulock[sysblk.pcpu]);

  000ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f4	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00102	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159671
  00111	48 8b c8	 mov	 rcx, rax
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 853  : 
; 854  :         if (!IS_CPU_ONLINE(sysblk.pcpu))

  0011a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00121	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00128	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012f	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00138	0f 85 ce 00 00
	00		 jne	 $LN14@clocks_cmd

; 855  :         {
; 856  :             release_lock(&sysblk.cpulock[sysblk.pcpu]);

  0013e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00145	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0014c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00153	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159673
  00162	48 8b c8	 mov	 rcx, rax
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 857  :             WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "online");

  0016b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00172	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00179	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00180	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0018e	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  00196	b9 01 00 00 00	 mov	 ecx, 1
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159674
  001a8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001b4	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  001ba	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001be	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  001c6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159675
  001d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159676
  001de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159677
  001f5	ba 59 03 00 00	 mov	 edx, 857		; 00000359H
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159678
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 858  :             break;

  00207	e9 66 09 00 00	 jmp	 $LN9@clocks_cmd
$LN14@clocks_cmd:

; 859  :         }
; 860  :         regs = sysblk.regs[sysblk.pcpu];

  0020c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00213	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0021a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00221	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00229	48 89 44 24 58	 mov	 QWORD PTR regs$[rsp], rax

; 861  : 
; 862  :     /* Get the clock values all at once for consistency and so we can
; 863  :         release the CPU lock more quickly. */
; 864  :         etod_clock(regs, &tod_now, ETOD_fast);

  0022e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00234	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR tod_now$[rsp]
  0023c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00241	e8 00 00 00 00	 call	 etod_clock

; 865  :         hw_now.high = hw_tod.high;

  00246	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR hw_tod+8
  0024d	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR hw_now$[rsp+8], rax

; 866  :         hw_now.low  = hw_tod.low;

  00255	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hw_tod
  0025c	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR hw_now$[rsp], rax

; 867  :         epoch_now = regs->tod_epoch;

  00264	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00269	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  00270	48 89 44 24 70	 mov	 QWORD PTR epoch_now$[rsp], rax

; 868  :         clkc_now = regs->clkc;

  00275	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0027a	48 8b 80 48 07
	00 00		 mov	 rax, QWORD PTR [rax+1864]
  00281	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR clkc_now$[rsp], rax

; 869  :         cpt_now = CPU_TIMER(regs);

  00289	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	e8 00 00 00 00	 call	 get_cpu_timer
  00293	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR cpt_now$[rsp], rax

; 870  : #if defined(_FEATURE_SIE)
; 871  :         if ( regs->sie_active )

  0029b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  002a0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002a6	83 e0 01	 and	 eax, 1
  002a9	85 c0		 test	 eax, eax
  002ab	0f 84 83 00 00
	00		 je	 $LN15@clocks_cmd

; 872  :         {
; 873  :             vtod_now = TOD_CLOCK(GUESTREGS);

  002b1	48 b8 ff ff ff
	ff ff ff ff 00	 mov	 rax, 72057594037927935	; 00ffffffffffffffH
  002bb	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR tod_value+8
  002c2	48 23 c8	 and	 rcx, rax
  002c5	48 8b c1	 mov	 rax, rcx
  002c8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  002d4	48 03 81 40 07
	00 00		 add	 rax, QWORD PTR [rcx+1856]
  002db	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR vtod_now$[rsp], rax

; 874  :             vepoch_now = GUESTREGS->tod_epoch;

  002e3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  002e8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  002ef	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  002f6	48 89 44 24 68	 mov	 QWORD PTR vepoch_now$[rsp], rax

; 875  :             vclkc_now = GUESTREGS->clkc;

  002fb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00300	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00307	48 8b 80 48 07
	00 00		 mov	 rax, QWORD PTR [rax+1864]
  0030e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR vclkc_now$[rsp], rax

; 876  :             vcpt_now = CPU_TIMER(GUESTREGS);

  00316	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0031b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00322	e8 00 00 00 00	 call	 get_cpu_timer
  00327	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR vcpt_now$[rsp], rax

; 877  :             sie_flag = 1;

  0032f	c6 44 24 52 01	 mov	 BYTE PTR sie_flag$[rsp], 1
$LN15@clocks_cmd:

; 878  :         }
; 879  : #endif
; 880  :         if (regs->arch_mode == ARCH_370_IDX)

  00334	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00339	83 78 64 00	 cmp	 DWORD PTR [rax+100], 0
  0033d	0f 85 c3 00 00
	00		 jne	 $LN16@clocks_cmd

; 881  :         {
; 882  :             itimer = INT_TIMER(regs);

  00343	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00348	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR hw_tod+8
  0034f	48 8b 80 60 07
	00 00		 mov	 rax, QWORD PTR [rax+1888]
  00356	48 2b c1	 sub	 rax, rcx
  00359	48 6b c0 03	 imul	 rax, rax, 3
  0035d	48 99		 cdq
  0035f	b9 71 02 00 00	 mov	 ecx, 625		; 00000271H
  00364	48 f7 f9	 idiv	 rcx
  00367	89 44 24 54	 mov	 DWORD PTR itimer$[rsp], eax

; 883  :         /* The interval timer counts 76800 per second, or one every
; 884  :            13.0208 microseconds. */
; 885  :             MSGBUF(itimer_formatted,"%02u:%02u:%02u.%06u",

  0036b	33 d2		 xor	 edx, edx
  0036d	8b 44 24 54	 mov	 eax, DWORD PTR itimer$[rsp]
  00371	b9 00 2c 01 00	 mov	 ecx, 76800		; 00012c00H
  00376	f7 f1		 div	 ecx
  00378	8b c2		 mov	 eax, edx
  0037a	6b c0 0d	 imul	 eax, eax, 13
  0037d	89 44 24 78	 mov	 DWORD PTR tv184[rsp], eax
  00381	33 d2		 xor	 edx, edx
  00383	8b 44 24 54	 mov	 eax, DWORD PTR itimer$[rsp]
  00387	b9 00 50 46 00	 mov	 ecx, 4608000		; 00465000H
  0038c	f7 f1		 div	 ecx
  0038e	8b c2		 mov	 eax, edx
  00390	33 d2		 xor	 edx, edx
  00392	b9 00 2c 01 00	 mov	 ecx, 76800		; 00012c00H
  00397	f7 f1		 div	 ecx
  00399	89 44 24 7c	 mov	 DWORD PTR tv187[rsp], eax
  0039d	33 d2		 xor	 edx, edx
  0039f	8b 44 24 54	 mov	 eax, DWORD PTR itimer$[rsp]
  003a3	b9 00 c0 7a 10	 mov	 ecx, 276480000		; 107ac000H
  003a8	f7 f1		 div	 ecx
  003aa	8b c2		 mov	 eax, edx
  003ac	33 d2		 xor	 edx, edx
  003ae	b9 00 50 46 00	 mov	 ecx, 4608000		; 00465000H
  003b3	f7 f1		 div	 ecx
  003b5	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv190[rsp], eax
  003bc	33 d2		 xor	 edx, edx
  003be	8b 44 24 54	 mov	 eax, DWORD PTR itimer$[rsp]
  003c2	b9 00 c0 7a 10	 mov	 ecx, 276480000		; 107ac000H
  003c7	f7 f1		 div	 ecx
  003c9	8b 4c 24 78	 mov	 ecx, DWORD PTR tv184[rsp]
  003cd	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  003d1	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv187[rsp]
  003d5	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  003d9	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv190[rsp]
  003e0	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  003e4	44 8b c8	 mov	 r9d, eax
  003e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159681
  003ee	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  003f3	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR itimer_formatted$[rsp]
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 886  :                 (itimer/(76800*60*60)),((itimer%(76800*60*60))/(76800*60)),
; 887  :                 ((itimer%(76800*60))/76800),((itimer%76800)*13));
; 888  :             arch370_flag = 1;

  00401	c6 44 24 53 01	 mov	 BYTE PTR arch370_flag$[rsp], 1
$LN16@clocks_cmd:

; 889  :         }
; 890  : 
; 891  :         release_lock(&sysblk.cpulock[sysblk.pcpu]);

  00406	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0040d	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00414	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0041b	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159682
  0042a	48 8b c8	 mov	 rcx, rax
  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 892  : 
; 893  :         MSGBUF( buf, "tod = %16.16"PRIX64"    %s",

  00433	41 b8 01 00 00
	00		 mov	 r8d, 1
  00439	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR tod_now$[rsp+8]
  00441	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR clock_buf$[rsp]
  00449	e8 00 00 00 00	 call	 format_tod
  0044e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv204[rsp], rax
  00456	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  0045e	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR tod_now$[rsp]
  00466	48 8b f9	 mov	 rdi, rcx
  00469	48 8b f2	 mov	 rsi, rdx
  0046c	b9 10 00 00 00	 mov	 ecx, 16
  00471	f3 a4		 rep movsb
  00473	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  0047b	e8 00 00 00 00	 call	 ETOD2TOD
  00480	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv204[rsp]
  00488	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0048d	4c 8b c8	 mov	 r9, rax
  00490	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159683
  00497	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  0049c	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 894  :                 ETOD2TOD(tod_now), format_tod(clock_buf,tod_now.high,TRUE) );
; 895  :         WRMSG(HHC02274, "I", buf);

  004aa	b9 01 00 00 00	 mov	 ecx, 1
  004af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b5	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159684
  004c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159685
  004d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004df	41 b9 03 00 00
	00		 mov	 r9d, 3
  004e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159686
  004ec	ba 7f 03 00 00	 mov	 edx, 895		; 0000037fH
  004f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159687
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 896  : 
; 897  :         MSGBUF( buf, "h/w = %16.16"PRIX64"    %s",

  004fe	41 b8 01 00 00
	00		 mov	 r8d, 1
  00504	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR hw_now$[rsp+8]
  0050c	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR clock_buf$[rsp]
  00514	e8 00 00 00 00	 call	 format_tod
  00519	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv225[rsp], rax
  00521	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  00529	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR hw_now$[rsp]
  00531	48 8b f9	 mov	 rdi, rcx
  00534	48 8b f2	 mov	 rsi, rdx
  00537	b9 10 00 00 00	 mov	 ecx, 16
  0053c	f3 a4		 rep movsb
  0053e	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  00546	e8 00 00 00 00	 call	 ETOD2TOD
  0054b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv225[rsp]
  00553	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00558	4c 8b c8	 mov	 r9, rax
  0055b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159688
  00562	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00567	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0056f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 898  :                 ETOD2TOD(hw_now), format_tod(clock_buf,hw_now.high,TRUE) );
; 899  :         WRMSG(HHC02274, "I", buf);

  00575	b9 01 00 00 00	 mov	 ecx, 1
  0057a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00580	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00588	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159689
  00594	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00599	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159690
  005a0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005aa	41 b9 03 00 00
	00		 mov	 r9d, 3
  005b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159691
  005b7	ba 83 03 00 00	 mov	 edx, 899		; 00000383H
  005bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159692
  005c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 900  : 
; 901  :         if (epoch_now < 0)

  005c9	48 83 7c 24 70
	00		 cmp	 QWORD PTR epoch_now$[rsp], 0
  005cf	7d 17		 jge	 SHORT $LN17@clocks_cmd

; 902  :         {
; 903  :             epoch_now_abs = -(epoch_now);

  005d1	48 8b 44 24 70	 mov	 rax, QWORD PTR epoch_now$[rsp]
  005d6	48 f7 d8	 neg	 rax
  005d9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR epoch_now_abs$[rsp], rax

; 904  :             epoch_sign = '-';

  005e1	c6 44 24 51 2d	 mov	 BYTE PTR epoch_sign$[rsp], 45 ; 0000002dH

; 905  :         }

  005e6	eb 12		 jmp	 SHORT $LN18@clocks_cmd
$LN17@clocks_cmd:

; 906  :         else
; 907  :         {
; 908  :             epoch_now_abs = epoch_now;

  005e8	48 8b 44 24 70	 mov	 rax, QWORD PTR epoch_now$[rsp]
  005ed	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR epoch_now_abs$[rsp], rax

; 909  :             epoch_sign = ' ';

  005f5	c6 44 24 51 20	 mov	 BYTE PTR epoch_sign$[rsp], 32 ; 00000020H
$LN18@clocks_cmd:

; 910  :         }
; 911  :         MSGBUF( buf, "off = %16.16"PRIX64"   %c%s",

  005fa	45 33 c0	 xor	 r8d, r8d
  005fd	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR epoch_now_abs$[rsp]
  00605	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR clock_buf$[rsp]
  0060d	e8 00 00 00 00	 call	 format_tod
  00612	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv248[rsp], rax
  0061a	0f be 4c 24 51	 movsx	 ecx, BYTE PTR epoch_sign$[rsp]
  0061f	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv253[rsp], ecx
  00626	48 8b 4c 24 70	 mov	 rcx, QWORD PTR epoch_now$[rsp]
  0062b	e8 00 00 00 00	 call	 ETOD_high64_to_TOD_high56
  00630	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv248[rsp]
  00638	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0063d	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv253[rsp]
  00644	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00648	4c 8b c8	 mov	 r9, rax
  0064b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159695
  00652	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00657	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0065f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 912  :                 ETOD_high64_to_TOD_high56(epoch_now), epoch_sign,
; 913  :                 format_tod(clock_buf,epoch_now_abs,FALSE) );
; 914  :         WRMSG(HHC02274, "I", buf);

  00665	b9 01 00 00 00	 mov	 ecx, 1
  0066a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00670	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00678	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0067d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159696
  00684	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00689	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159697
  00690	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00695	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0069a	41 b9 03 00 00
	00		 mov	 r9d, 3
  006a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159698
  006a7	ba 92 03 00 00	 mov	 edx, 914		; 00000392H
  006ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159699
  006b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 915  : 
; 916  :         MSGBUF( buf, "ckc = %16.16"PRIX64"    %s",

  006b9	41 b8 01 00 00
	00		 mov	 r8d, 1
  006bf	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR clkc_now$[rsp]
  006c7	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR clock_buf$[rsp]
  006cf	e8 00 00 00 00	 call	 format_tod
  006d4	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv271[rsp], rax
  006dc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR clkc_now$[rsp]
  006e4	e8 00 00 00 00	 call	 ETOD_high64_to_TOD_high56
  006e9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv271[rsp]
  006f1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006f6	4c 8b c8	 mov	 r9, rax
  006f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159700
  00700	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00705	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0070d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 917  :                 ETOD_high64_to_TOD_high56(clkc_now), format_tod(clock_buf,clkc_now,TRUE) );
; 918  :         WRMSG(HHC02274, "I", buf);

  00713	b9 01 00 00 00	 mov	 ecx, 1
  00718	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0071e	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00726	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0072b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159701
  00732	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00737	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159702
  0073e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00743	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00748	41 b9 03 00 00
	00		 mov	 r9d, 3
  0074e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159703
  00755	ba 96 03 00 00	 mov	 edx, 918		; 00000396H
  0075a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159704
  00761	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 919  : 
; 920  :         if (regs->cpustate != CPUSTATE_STOPPED)

  00767	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0076c	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00770	83 f8 03	 cmp	 eax, 3
  00773	74 24		 je	 SHORT $LN19@clocks_cmd

; 921  :             MSGBUF( buf, "cpt = %16.16"PRIX64, cpt_now );

  00775	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR cpt_now$[rsp]
  0077d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159707
  00784	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00789	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00791	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00797	eb 22		 jmp	 SHORT $LN20@clocks_cmd
$LN19@clocks_cmd:

; 922  :         else
; 923  :             MSGBUF( buf, "cpt = %16.16"PRIX64"         not decrementing", cpt_now );

  00799	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR cpt_now$[rsp]
  007a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159708
  007a8	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  007ad	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  007b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN20@clocks_cmd:

; 924  :         WRMSG(HHC02274, "I", buf);

  007bb	b9 01 00 00 00	 mov	 ecx, 1
  007c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007c6	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  007ce	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159709
  007da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159710
  007e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  007f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159711
  007fd	ba 9c 03 00 00	 mov	 edx, 924		; 0000039cH
  00802	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159712
  00809	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 925  : 
; 926  : #if defined(_FEATURE_SIE)
; 927  :         if (sie_flag)

  0080f	0f be 44 24 52	 movsx	 eax, BYTE PTR sie_flag$[rsp]
  00814	85 c0		 test	 eax, eax
  00816	0f 84 c2 02 00
	00		 je	 $LN21@clocks_cmd

; 928  :         {
; 929  : 
; 930  :             MSGBUF( buf, "vtod = %16.16"PRIX64"    %s",

  0081c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00822	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR vtod_now$[rsp]
  0082a	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR clock_buf$[rsp]
  00832	e8 00 00 00 00	 call	 format_tod
  00837	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv347[rsp], rax
  0083f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR vtod_now$[rsp]
  00847	e8 00 00 00 00	 call	 ETOD_high64_to_TOD_high56
  0084c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv347[rsp]
  00854	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00859	4c 8b c8	 mov	 r9, rax
  0085c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159714
  00863	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00868	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00870	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 931  :                     ETOD_high64_to_TOD_high56(vtod_now), format_tod(clock_buf,vtod_now,TRUE) );
; 932  :             WRMSG(HHC02274, "I", buf);

  00876	b9 01 00 00 00	 mov	 ecx, 1
  0087b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00881	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00889	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0088e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159715
  00895	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0089a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159716
  008a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159717
  008b8	ba a4 03 00 00	 mov	 edx, 932		; 000003a4H
  008bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159718
  008c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 933  : 
; 934  :             if (vepoch_now < 0)

  008ca	48 83 7c 24 68
	00		 cmp	 QWORD PTR vepoch_now$[rsp], 0
  008d0	7d 17		 jge	 SHORT $LN22@clocks_cmd

; 935  :             {
; 936  :                 vepoch_now_abs = -(vepoch_now);

  008d2	48 8b 44 24 68	 mov	 rax, QWORD PTR vepoch_now$[rsp]
  008d7	48 f7 d8	 neg	 rax
  008da	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR vepoch_now_abs$[rsp], rax

; 937  :                 vepoch_sign = '-';

  008e2	c6 44 24 50 2d	 mov	 BYTE PTR vepoch_sign$[rsp], 45 ; 0000002dH

; 938  :             }

  008e7	eb 12		 jmp	 SHORT $LN23@clocks_cmd
$LN22@clocks_cmd:

; 939  :             else
; 940  :             {
; 941  :                 vepoch_now_abs = vepoch_now;

  008e9	48 8b 44 24 68	 mov	 rax, QWORD PTR vepoch_now$[rsp]
  008ee	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR vepoch_now_abs$[rsp], rax

; 942  :                 vepoch_sign = ' ';

  008f6	c6 44 24 50 20	 mov	 BYTE PTR vepoch_sign$[rsp], 32 ; 00000020H
$LN23@clocks_cmd:

; 943  :             }
; 944  :             MSGBUF( buf, "voff = %16.16"PRIX64"   %c%s",

  008fb	45 33 c0	 xor	 r8d, r8d
  008fe	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR vepoch_now_abs$[rsp]
  00906	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR clock_buf$[rsp]
  0090e	e8 00 00 00 00	 call	 format_tod
  00913	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv370[rsp], rax
  0091b	0f be 4c 24 50	 movsx	 ecx, BYTE PTR vepoch_sign$[rsp]
  00920	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv375[rsp], ecx
  00927	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vepoch_now$[rsp]
  0092c	e8 00 00 00 00	 call	 ETOD_high64_to_TOD_high56
  00931	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv370[rsp]
  00939	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0093e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv375[rsp]
  00945	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00949	4c 8b c8	 mov	 r9, rax
  0094c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159721
  00953	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00958	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00960	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 945  :                     ETOD_high64_to_TOD_high56(vepoch_now), vepoch_sign,
; 946  :                     format_tod(clock_buf,vepoch_now_abs,FALSE) );
; 947  :             WRMSG(HHC02274, "I", buf);

  00966	b9 01 00 00 00	 mov	 ecx, 1
  0096b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00971	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00979	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0097e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159722
  00985	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0098a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159723
  00991	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00996	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0099b	41 b9 03 00 00
	00		 mov	 r9d, 3
  009a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159724
  009a8	ba b3 03 00 00	 mov	 edx, 947		; 000003b3H
  009ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159725
  009b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 948  : 
; 949  :             MSGBUF( buf, "vckc = %16.16"PRIX64"    %s",

  009ba	41 b8 01 00 00
	00		 mov	 r8d, 1
  009c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR vclkc_now$[rsp]
  009c8	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR clock_buf$[rsp]
  009d0	e8 00 00 00 00	 call	 format_tod
  009d5	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv393[rsp], rax
  009dd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR vclkc_now$[rsp]
  009e5	e8 00 00 00 00	 call	 ETOD_high64_to_TOD_high56
  009ea	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv393[rsp]
  009f2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009f7	4c 8b c8	 mov	 r9, rax
  009fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159726
  00a01	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00a06	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00a0e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 950  :                     ETOD_high64_to_TOD_high56(vclkc_now), format_tod(clock_buf,vclkc_now,TRUE) );
; 951  :             WRMSG(HHC02274, "I", buf);

  00a14	b9 01 00 00 00	 mov	 ecx, 1
  00a19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a1f	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00a27	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159727
  00a33	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159728
  00a3f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a44	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a49	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a4f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159729
  00a56	ba b7 03 00 00	 mov	 edx, 951		; 000003b7H
  00a5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159730
  00a62	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 952  : 
; 953  :             MSGBUF( buf, "vcpt = %16.16"PRIX64, vcpt_now );

  00a68	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR vcpt_now$[rsp]
  00a70	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159731
  00a77	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00a7c	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00a84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 954  :             WRMSG(HHC02274, "I", buf);

  00a8a	b9 01 00 00 00	 mov	 ecx, 1
  00a8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a95	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00a9d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00aa2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159732
  00aa9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159733
  00ab5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00abf	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ac5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159734
  00acc	ba ba 03 00 00	 mov	 edx, 954		; 000003baH
  00ad1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159735
  00ad8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@clocks_cmd:

; 955  :         }
; 956  : #endif
; 957  : 
; 958  :         if (arch370_flag)

  00ade	0f be 44 24 53	 movsx	 eax, BYTE PTR arch370_flag$[rsp]
  00ae3	85 c0		 test	 eax, eax
  00ae5	0f 84 80 00 00
	00		 je	 $LN24@clocks_cmd

; 959  :         {
; 960  :             MSGBUF( buf, "itm = %8.8"PRIX32"                     %s",

  00aeb	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR itimer_formatted$[rsp]
  00af3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00af8	44 8b 4c 24 54	 mov	 r9d, DWORD PTR itimer$[rsp]
  00afd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159737
  00b04	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00b09	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00b11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 961  :                    itimer, itimer_formatted );
; 962  :             WRMSG(HHC02274, "I", buf);

  00b17	b9 01 00 00 00	 mov	 ecx, 1
  00b1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b22	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00b2a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159738
  00b36	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159739
  00b42	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b47	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b4c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b52	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159740
  00b59	ba c2 03 00 00	 mov	 edx, 962		; 000003c2H
  00b5e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159741
  00b65	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@clocks_cmd:

; 963  :         }
; 964  :         break;

  00b6b	eb 05		 jmp	 SHORT $LN9@clocks_cmd

; 965  :     }

  00b6d	e9 7b f5 ff ff	 jmp	 $LN8@clocks_cmd
$LN9@clocks_cmd:
  00b72	eb 79		 jmp	 SHORT $LN13@clocks_cmd
$LN12@clocks_cmd:

; 966  :     else
; 967  :     {
; 968  :         WRMSG( HHC02299, "E", argv[0] );

  00b74	b8 08 00 00 00	 mov	 eax, 8
  00b79	48 6b c0 00	 imul	 rax, rax, 0
  00b7d	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv444[rsp], rax
  00b85	b9 01 00 00 00	 mov	 ecx, 1
  00b8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b90	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b98	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR tv444[rsp]
  00ba0	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00ba4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ba9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159742
  00bb0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bb5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159743
  00bbc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bc1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bc6	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bcc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159744
  00bd3	ba c8 03 00 00	 mov	 edx, 968		; 000003c8H
  00bd8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159745
  00bdf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 969  :         rc = -1;

  00be5	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN13@clocks_cmd:

; 970  :     }
; 971  : 
; 972  :     return rc;

  00bed	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]

; 973  : }

  00bf1	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00bf9	48 33 cc	 xor	 rcx, rsp
  00bfc	e8 00 00 00 00	 call	 __security_check_cookie
  00c01	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  00c08	5f		 pop	 rdi
  00c09	5e		 pop	 rsi
  00c0a	c3		 ret	 0
clocks_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
years$ = 64
days$ = 68
leapyear$ = 72
microseconds$ = 76
seconds$ = 80
minutes$ = 84
hours$ = 88
buf$ = 112
tod$ = 120
flagdate$ = 128
format_tod PROC

; 773  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 774  :     int leapyear, years, days, hours, minutes, seconds, microseconds;
; 775  : 
; 776  :     if ( tod >= ETOD_YEAR )

  00013	48 b8 00 00 3e
	c1 e8 ca 01 00	 mov	 rax, 504576000000000	; 0001cae8c13e0000H
  0001d	48 39 44 24 78	 cmp	 QWORD PTR tod$[rsp], rax
  00022	0f 82 e5 00 00
	00		 jb	 $LN2@format_tod

; 777  :     {
; 778  :         tod -= ETOD_YEAR;

  00028	48 b8 00 00 3e
	c1 e8 ca 01 00	 mov	 rax, 504576000000000	; 0001cae8c13e0000H
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tod$[rsp]
  00037	48 2b c8	 sub	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 44 24 78	 mov	 QWORD PTR tod$[rsp], rax

; 779  :         years = (tod / ETOD_4YEARS * 4) + 1;

  00042	33 d2		 xor	 edx, edx
  00044	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  00049	48 b9 00 00 6e
	e2 e4 2c 07 00	 mov	 rcx, 2019686400000000	; 00072ce4e26e0000H
  00053	48 f7 f1	 div	 rcx
  00056	48 8d 04 85 01
	00 00 00	 lea	 rax, QWORD PTR [rax*4+1]
  0005e	89 44 24 40	 mov	 DWORD PTR years$[rsp], eax

; 780  :         tod %= ETOD_4YEARS;

  00062	33 d2		 xor	 edx, edx
  00064	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  00069	48 b9 00 00 6e
	e2 e4 2c 07 00	 mov	 rcx, 2019686400000000	; 00072ce4e26e0000H
  00073	48 f7 f1	 div	 rcx
  00076	48 8b c2	 mov	 rax, rdx
  00079	48 89 44 24 78	 mov	 QWORD PTR tod$[rsp], rax

; 781  :         if ( ( leapyear = tod / ETOD_YEAR ) == 4 )

  0007e	33 d2		 xor	 edx, edx
  00080	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  00085	48 b9 00 00 3e
	c1 e8 ca 01 00	 mov	 rcx, 504576000000000	; 0001cae8c13e0000H
  0008f	48 f7 f1	 div	 rcx
  00092	89 44 24 48	 mov	 DWORD PTR leapyear$[rsp], eax
  00096	83 7c 24 48 04	 cmp	 DWORD PTR leapyear$[rsp], 4
  0009b	75 42		 jne	 SHORT $LN4@format_tod

; 782  :         {
; 783  :             tod %= ETOD_YEAR;

  0009d	33 d2		 xor	 edx, edx
  0009f	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  000a4	48 b9 00 00 3e
	c1 e8 ca 01 00	 mov	 rcx, 504576000000000	; 0001cae8c13e0000H
  000ae	48 f7 f1	 div	 rcx
  000b1	48 8b c2	 mov	 rax, rdx
  000b4	48 89 44 24 78	 mov	 QWORD PTR tod$[rsp], rax

; 784  :             years--;

  000b9	8b 44 24 40	 mov	 eax, DWORD PTR years$[rsp]
  000bd	ff c8		 dec	 eax
  000bf	89 44 24 40	 mov	 DWORD PTR years$[rsp], eax

; 785  :             tod += ETOD_YEAR;

  000c3	48 b8 00 00 3e
	c1 e8 ca 01 00	 mov	 rax, 504576000000000	; 0001cae8c13e0000H
  000cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tod$[rsp]
  000d2	48 03 c8	 add	 rcx, rax
  000d5	48 8b c1	 mov	 rax, rcx
  000d8	48 89 44 24 78	 mov	 QWORD PTR tod$[rsp], rax

; 786  :         }

  000dd	eb 1c		 jmp	 SHORT $LN5@format_tod
$LN4@format_tod:

; 787  :         else
; 788  :             tod %= ETOD_YEAR;

  000df	33 d2		 xor	 edx, edx
  000e1	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  000e6	48 b9 00 00 3e
	c1 e8 ca 01 00	 mov	 rcx, 504576000000000	; 0001cae8c13e0000H
  000f0	48 f7 f1	 div	 rcx
  000f3	48 8b c2	 mov	 rax, rdx
  000f6	48 89 44 24 78	 mov	 QWORD PTR tod$[rsp], rax
$LN5@format_tod:

; 789  : 
; 790  :         years += leapyear;

  000fb	8b 44 24 48	 mov	 eax, DWORD PTR leapyear$[rsp]
  000ff	8b 4c 24 40	 mov	 ecx, DWORD PTR years$[rsp]
  00103	03 c8		 add	 ecx, eax
  00105	8b c1		 mov	 eax, ecx
  00107	89 44 24 40	 mov	 DWORD PTR years$[rsp], eax

; 791  :     }

  0010b	eb 08		 jmp	 SHORT $LN3@format_tod
$LN2@format_tod:

; 792  :     else
; 793  :         years = 0;

  0010d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR years$[rsp], 0
$LN3@format_tod:

; 794  : 
; 795  :     days = tod / ETOD_DAY;

  00115	33 d2		 xor	 edx, edx
  00117	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  0011c	48 b9 00 00 76
	dd 41 01 00 00	 mov	 rcx, 1382400000000	; 00000141dd760000H
  00126	48 f7 f1	 div	 rcx
  00129	89 44 24 44	 mov	 DWORD PTR days$[rsp], eax

; 796  :     tod %= ETOD_DAY;

  0012d	33 d2		 xor	 edx, edx
  0012f	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  00134	48 b9 00 00 76
	dd 41 01 00 00	 mov	 rcx, 1382400000000	; 00000141dd760000H
  0013e	48 f7 f1	 div	 rcx
  00141	48 8b c2	 mov	 rax, rdx
  00144	48 89 44 24 78	 mov	 QWORD PTR tod$[rsp], rax

; 797  :     hours = tod / ETOD_HOUR;

  00149	33 d2		 xor	 edx, edx
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  00150	48 b9 00 40 3a
	69 0d 00 00 00	 mov	 rcx, 57600000000	; 0000000d693a4000H
  0015a	48 f7 f1	 div	 rcx
  0015d	89 44 24 58	 mov	 DWORD PTR hours$[rsp], eax

; 798  :     tod %= ETOD_HOUR;

  00161	33 d2		 xor	 edx, edx
  00163	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  00168	48 b9 00 40 3a
	69 0d 00 00 00	 mov	 rcx, 57600000000	; 0000000d693a4000H
  00172	48 f7 f1	 div	 rcx
  00175	48 8b c2	 mov	 rax, rdx
  00178	48 89 44 24 78	 mov	 QWORD PTR tod$[rsp], rax

; 799  :     minutes = tod / ETOD_MIN;

  0017d	33 d2		 xor	 edx, edx
  0017f	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  00184	b9 00 70 38 39	 mov	 ecx, 960000000		; 39387000H
  00189	48 f7 f1	 div	 rcx
  0018c	89 44 24 54	 mov	 DWORD PTR minutes$[rsp], eax

; 800  :     tod %= ETOD_MIN;

  00190	33 d2		 xor	 edx, edx
  00192	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  00197	b9 00 70 38 39	 mov	 ecx, 960000000		; 39387000H
  0019c	48 f7 f1	 div	 rcx
  0019f	48 8b c2	 mov	 rax, rdx
  001a2	48 89 44 24 78	 mov	 QWORD PTR tod$[rsp], rax

; 801  :     seconds = tod / ETOD_SEC;

  001a7	33 d2		 xor	 edx, edx
  001a9	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  001ae	b9 00 24 f4 00	 mov	 ecx, 16000000		; 00f42400H
  001b3	48 f7 f1	 div	 rcx
  001b6	89 44 24 50	 mov	 DWORD PTR seconds$[rsp], eax

; 802  :     microseconds = (tod % ETOD_SEC) / ETOD_USEC;

  001ba	33 d2		 xor	 edx, edx
  001bc	48 8b 44 24 78	 mov	 rax, QWORD PTR tod$[rsp]
  001c1	b9 00 24 f4 00	 mov	 ecx, 16000000		; 00f42400H
  001c6	48 f7 f1	 div	 rcx
  001c9	48 8b c2	 mov	 rax, rdx
  001cc	33 d2		 xor	 edx, edx
  001ce	b9 10 00 00 00	 mov	 ecx, 16
  001d3	48 f7 f1	 div	 rcx
  001d6	89 44 24 4c	 mov	 DWORD PTR microseconds$[rsp], eax

; 803  : 
; 804  :     if (flagdate)

  001da	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR flagdate$[rsp], 0
  001e2	74 17		 je	 SHORT $LN6@format_tod

; 805  :     {
; 806  :         years += 1900;

  001e4	8b 44 24 40	 mov	 eax, DWORD PTR years$[rsp]
  001e8	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  001ed	89 44 24 40	 mov	 DWORD PTR years$[rsp], eax

; 807  :         days += 1;

  001f1	8b 44 24 44	 mov	 eax, DWORD PTR days$[rsp]
  001f5	ff c0		 inc	 eax
  001f7	89 44 24 44	 mov	 DWORD PTR days$[rsp], eax
$LN6@format_tod:

; 808  :     }
; 809  : 
; 810  :     sprintf(buf,"%4d.%03d %02d:%02d:%02d.%06d",

  001fb	8b 44 24 4c	 mov	 eax, DWORD PTR microseconds$[rsp]
  001ff	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00203	8b 44 24 50	 mov	 eax, DWORD PTR seconds$[rsp]
  00207	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0020b	8b 44 24 54	 mov	 eax, DWORD PTR minutes$[rsp]
  0020f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00213	8b 44 24 58	 mov	 eax, DWORD PTR hours$[rsp]
  00217	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0021b	44 8b 4c 24 44	 mov	 r9d, DWORD PTR days$[rsp]
  00220	44 8b 44 24 40	 mov	 r8d, DWORD PTR years$[rsp]
  00225	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159624
  0022c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00231	e8 00 00 00 00	 call	 sprintf

; 811  :         years,days,hours,minutes,seconds,microseconds);
; 812  : 
; 813  :     return buf;

  00236	48 8b 44 24 70	 mov	 rax, QWORD PTR buf$[rsp]

; 814  : }

  0023b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0023f	c3		 ret	 0
format_tod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
timerint$1 = 80
rc$ = 84
c$2 = 88
tv216 = 92
tv140 = 96
tv143 = 104
tv178 = 112
tv191 = 120
tv226 = 128
tv238 = 136
buf$3 = 144
buf$4 = 176
__$ArrayPad$ = 208
argc$ = 240
argv$ = 248
cmdline$ = 256
timerint_cmd PROC

; 679  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 680  :     int rc = 0;

  00027	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@timerint_c:

; 681  :     UNREFERENCED( cmdline );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@timerint_c
$LN7@timerint_c:

; 682  : 
; 683  :     UPPER_ARGV_0( argv );

  00035	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  0003e	74 47		 je	 SHORT $LN8@timerint_c
  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00051	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00056	74 2f		 je	 SHORT $LN8@timerint_c
  00058	b8 08 00 00 00	 mov	 eax, 8
  0005d	48 6b c0 00	 imul	 rax, rax, 0
  00061	b9 08 00 00 00	 mov	 ecx, 8
  00066	48 6b c9 00	 imul	 rcx, rcx, 0
  0006a	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00072	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  00076	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0007e	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  00082	e8 00 00 00 00	 call	 strupper
$LN8@timerint_c:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 a8		 jne	 SHORT $LN7@timerint_c

; 684  : 
; 685  :     if (argc == 2)  /* Define a new value? */

  0008d	83 bc 24 f0 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00095	0f 85 c7 03 00
	00		 jne	 $LN9@timerint_c

; 686  :     {
; 687  :         if (CMD( argv[1], DEFAULT, 7 ) || CMD( argv[1], RESET, 5 ))

  0009b	b8 08 00 00 00	 mov	 eax, 8
  000a0	48 6b c0 01	 imul	 rax, rax, 1
  000a4	41 b8 07 00 00
	00		 mov	 r8d, 7
  000aa	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000b2	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159569
  000bd	e8 00 00 00 00	 call	 strcaseabbrev
  000c2	85 c0		 test	 eax, eax
  000c4	75 2f		 jne	 SHORT $LN13@timerint_c
  000c6	b8 08 00 00 00	 mov	 eax, 8
  000cb	48 6b c0 01	 imul	 rax, rax, 1
  000cf	41 b8 05 00 00
	00		 mov	 r8d, 5
  000d5	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000dd	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159570
  000e8	e8 00 00 00 00	 call	 strcaseabbrev
  000ed	85 c0		 test	 eax, eax
  000ef	0f 84 29 01 00
	00		 je	 $LN11@timerint_c
$LN13@timerint_c:

; 688  :         {
; 689  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 690  :             if (FACILITY_ENABLED_ARCH( 073_TRANSACT_EXEC, sysblk.arch_mode ))

  000f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000fc	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  00103	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00107	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0010e	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  00116	b9 01 00 00 00	 mov	 ecx, 1
  0011b	48 6b c9 09	 imul	 rcx, rcx, 9
  0011f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00123	83 e0 40	 and	 eax, 64			; 00000040H
  00126	85 c0		 test	 eax, eax
  00128	74 24		 je	 SHORT $LN14@timerint_c

; 691  :             {
; 692  :                 sysblk.timerint     = DEF_TXF_TIMERINT;

  0012a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00131	c7 80 60 11 00
	00 90 01 00 00	 mov	 DWORD PTR [rax+4448], 400 ; 00000190H

; 693  :                 sysblk.txf_timerint = DEF_TXF_TIMERINT;

  0013b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00142	c7 80 74 05 00
	00 90 01 00 00	 mov	 DWORD PTR [rax+1396], 400 ; 00000190H

; 694  :             }

  0014c	eb 22		 jmp	 SHORT $LN15@timerint_c
$LN14@timerint_c:

; 695  :             else
; 696  : #endif
; 697  :             {
; 698  :                 sysblk.timerint     = DEF_TOD_UPDATE_USECS;

  0014e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00155	c7 80 60 11 00
	00 32 00 00 00	 mov	 DWORD PTR [rax+4448], 50 ; 00000032H

; 699  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 700  :                 sysblk.txf_timerint = DEF_TOD_UPDATE_USECS;

  0015f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00166	c7 80 74 05 00
	00 32 00 00 00	 mov	 DWORD PTR [rax+1396], 50 ; 00000032H
$LN15@timerint_c:

; 701  : #endif
; 702  :             }
; 703  : 
; 704  :             if (MLVL( VERBOSE ))

  00170	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00177	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0017d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00182	85 c0		 test	 eax, eax
  00184	0f 84 8f 00 00
	00		 je	 $LN16@timerint_c

; 705  :             {
; 706  :                 // "%-14s set to %s"
; 707  :                 WRMSG( HHC02204, "I", argv[0], argv[1] );

  0018a	b8 08 00 00 00	 mov	 eax, 8
  0018f	48 6b c0 01	 imul	 rax, rax, 1
  00193	48 89 44 24 60	 mov	 QWORD PTR tv140[rsp], rax
  00198	b9 08 00 00 00	 mov	 ecx, 8
  0019d	48 6b c9 00	 imul	 rcx, rcx, 0
  001a1	48 89 4c 24 68	 mov	 QWORD PTR tv143[rsp], rcx
  001a6	b9 01 00 00 00	 mov	 ecx, 1
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001b9	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv140[rsp]
  001be	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001c2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001c7	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001cf	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv143[rsp]
  001d4	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001d8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159574
  001e4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159575
  001f0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fa	41 b9 03 00 00
	00		 mov	 r9d, 3
  00200	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159576
  00207	ba c3 02 00 00	 mov	 edx, 707		; 000002c3H
  0020c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159577
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@timerint_c:

; 708  :             }
; 709  :         }

  00219	e9 c6 01 00 00	 jmp	 $LN12@timerint_c
$LN11@timerint_c:

; 710  :         else
; 711  :         {
; 712  :             int timerint = 0; BYTE c;

  0021e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR timerint$1[rsp], 0

; 713  : 
; 714  :             if (1
; 715  :                 && sscanf( argv[1], "%d%c", &timerint, &c ) == 1
; 716  :                 && timerint >= MIN_TOD_UPDATE_USECS
; 717  :                 && timerint <= MAX_TOD_UPDATE_USECS

  00226	33 c0		 xor	 eax, eax
  00228	83 f8 01	 cmp	 eax, 1
  0022b	0f 84 34 01 00
	00		 je	 $LN17@timerint_c
  00231	b8 08 00 00 00	 mov	 eax, 8
  00236	48 6b c0 01	 imul	 rax, rax, 1
  0023a	4c 8d 4c 24 58	 lea	 r9, QWORD PTR c$2[rsp]
  0023f	4c 8d 44 24 50	 lea	 r8, QWORD PTR timerint$1[rsp]
  00244	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159580
  0024b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00253	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00257	e8 00 00 00 00	 call	 sscanf
  0025c	83 f8 01	 cmp	 eax, 1
  0025f	0f 85 00 01 00
	00		 jne	 $LN17@timerint_c
  00265	83 7c 24 50 32	 cmp	 DWORD PTR timerint$1[rsp], 50 ; 00000032H
  0026a	0f 8c f5 00 00
	00		 jl	 $LN17@timerint_c
  00270	81 7c 24 50 40
	42 0f 00	 cmp	 DWORD PTR timerint$1[rsp], 1000000 ; 000f4240H
  00278	0f 8f e7 00 00
	00		 jg	 $LN17@timerint_c

; 718  :             )
; 719  :             {
; 720  :                 sysblk.timerint     = timerint;

  0027e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00285	8b 4c 24 50	 mov	 ecx, DWORD PTR timerint$1[rsp]
  00289	89 88 60 11 00
	00		 mov	 DWORD PTR [rax+4448], ecx

; 721  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 722  :                 sysblk.txf_timerint = sysblk.timerint;

  0028f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00296	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0029d	8b 89 60 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4448]
  002a3	89 88 74 05 00
	00		 mov	 DWORD PTR [rax+1396], ecx

; 723  : #endif
; 724  :                 if (MLVL( VERBOSE ))

  002a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002b0	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  002b6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002bb	85 c0		 test	 eax, eax
  002bd	0f 84 a0 00 00
	00		 je	 $LN19@timerint_c

; 725  :                 {
; 726  :                     char buf[25];
; 727  :                     MSGBUF( buf, "%d", sysblk.timerint );

  002c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ca	44 8b 88 60 11
	00 00		 mov	 r9d, DWORD PTR [rax+4448]
  002d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159582
  002d8	ba 19 00 00 00	 mov	 edx, 25
  002dd	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 728  :                     // "%-14s set to %s"
; 729  :                     WRMSG( HHC02204, "I", argv[0], buf );

  002eb	b8 08 00 00 00	 mov	 eax, 8
  002f0	48 6b c0 00	 imul	 rax, rax, 0
  002f4	48 89 44 24 70	 mov	 QWORD PTR tv178[rsp], rax
  002f9	b9 01 00 00 00	 mov	 ecx, 1
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00304	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  0030c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00311	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00319	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv178[rsp]
  0031e	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00322	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159583
  0032e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159584
  0033a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0033f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00344	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159585
  00351	ba d9 02 00 00	 mov	 edx, 729		; 000002d9H
  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159586
  0035d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@timerint_c:

; 730  :                 }
; 731  :             }

  00363	eb 7f		 jmp	 SHORT $LN18@timerint_c
$LN17@timerint_c:

; 732  :             else
; 733  :             {
; 734  :                 // "Invalid argument '%s'%s"
; 735  :                 WRMSG( HHC02205, "E", argv[1], ": must be 'default' or n where "

  00365	b8 08 00 00 00	 mov	 eax, 8
  0036a	48 6b c0 01	 imul	 rax, rax, 1
  0036e	48 89 44 24 78	 mov	 QWORD PTR tv191[rsp], rax
  00373	b9 01 00 00 00	 mov	 ecx, 1
  00378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159587
  00385	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0038a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00392	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv191[rsp]
  00397	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0039b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159588
  003a7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159589
  003b3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003bd	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159590
  003ca	ba e1 02 00 00	 mov	 edx, 737		; 000002e1H
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159591
  003d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 736  :                     QSTR( MIN_TOD_UPDATE_USECS ) " <= n <= "
; 737  :                     QSTR( MAX_TOD_UPDATE_USECS ) );
; 738  :                 rc = -1;

  003dc	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN18@timerint_c:
$LN12@timerint_c:

; 739  :             }
; 740  :         }
; 741  : 
; 742  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 743  : 
; 744  :         if (rc == 0 && sysblk.config_processed)

  003e4	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  003e9	75 72		 jne	 SHORT $LN20@timerint_c
  003eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003f2	83 b8 98 12 00
	00 00		 cmp	 DWORD PTR [rax+4760], 0
  003f9	74 62		 je	 SHORT $LN20@timerint_c

; 745  :         {
; 746  :             sysblk.cfg_timerint = sysblk.timerint;

  003fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00402	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00409	8b 89 60 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4448]
  0040f	89 88 64 11 00
	00		 mov	 DWORD PTR [rax+4452], ecx

; 747  :             txf_set_timerint( FACILITY_ENABLED_ARCH( 073_TRANSACT_EXEC, ARCH_900_IDX ));

  00415	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  0041a	48 6b c0 02	 imul	 rax, rax, 2
  0041e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00425	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  0042d	b9 01 00 00 00	 mov	 ecx, 1
  00432	48 6b c9 09	 imul	 rcx, rcx, 9
  00436	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0043a	83 e0 40	 and	 eax, 64			; 00000040H
  0043d	85 c0		 test	 eax, eax
  0043f	75 0a		 jne	 SHORT $LN24@timerint_c
  00441	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
  00449	eb 08		 jmp	 SHORT $LN25@timerint_c
$LN24@timerint_c:
  0044b	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv216[rsp], 1
$LN25@timerint_c:
  00453	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR tv216[rsp]
  00458	e8 00 00 00 00	 call	 txf_set_timerint
$LN20@timerint_c:

; 748  :         }
; 749  : #endif
; 750  :     }

  0045d	e9 2f 01 00 00	 jmp	 $LN10@timerint_c
$LN9@timerint_c:

; 751  :     else if (argc == 1)

  00462	83 bc 24 f0 00
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0046a	0f 85 a8 00 00
	00		 jne	 $LN21@timerint_c

; 752  :     {
; 753  :         /* Display the current value */
; 754  :         char buf[25];
; 755  :         MSGBUF( buf, "%d", sysblk.timerint );

  00470	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00477	44 8b 88 60 11
	00 00		 mov	 r9d, DWORD PTR [rax+4448]
  0047e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159595
  00485	ba 19 00 00 00	 mov	 edx, 25
  0048a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  00492	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 756  :         // "%-14s: %s"
; 757  :         WRMSG( HHC02203, "I", argv[0], buf );

  00498	b8 08 00 00 00	 mov	 eax, 8
  0049d	48 6b c0 00	 imul	 rax, rax, 0
  004a1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
  004a9	b9 01 00 00 00	 mov	 ecx, 1
  004ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b4	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  004bc	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004c1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004c9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv226[rsp]
  004d1	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  004d5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159596
  004e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159597
  004ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  004fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159598
  00504	ba f5 02 00 00	 mov	 edx, 757		; 000002f5H
  00509	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159599
  00510	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 758  :     }

  00516	eb 79		 jmp	 SHORT $LN22@timerint_c
$LN21@timerint_c:

; 759  :     else
; 760  :     {
; 761  :         // "Invalid command usage. Type 'help %s' for assistance."
; 762  :         WRMSG( HHC02299, "E", argv[0] );

  00518	b8 08 00 00 00	 mov	 eax, 8
  0051d	48 6b c0 00	 imul	 rax, rax, 0
  00521	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv238[rsp], rax
  00529	b9 01 00 00 00	 mov	 ecx, 1
  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00534	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0053c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv238[rsp]
  00544	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00548	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0054d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159600
  00554	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00559	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159601
  00560	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00565	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00570	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159602
  00577	ba fa 02 00 00	 mov	 edx, 762		; 000002faH
  0057c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159603
  00583	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 763  :         rc = -1;

  00589	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN22@timerint_c:
$LN10@timerint_c:

; 764  :     }
; 765  : 
; 766  :     return rc;

  00591	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]

; 767  : }

  00595	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0059d	48 33 cc	 xor	 rcx, rsp
  005a0	e8 00 00 00 00	 call	 __security_check_cookie
  005a5	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  005ac	c3		 ret	 0
timerint_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
i$1 = 64
mask$2 = 72
argc$ = 96
argv$ = 104
cmdline$ = 112
ext_cmd	PROC

; 655  : {

$LN22:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@ext_cmd:

; 656  :     UNREFERENCED(cmdline);

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@ext_cmd
$LN7@ext_cmd:

; 657  :     UNREFERENCED(argc);

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN7@ext_cmd
$LN10@ext_cmd:

; 658  :     UNREFERENCED(argv);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN10@ext_cmd

; 659  : 
; 660  :     OBTAIN_INTLOCK(NULL);

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159532
  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN13@ext_cmd:

; 661  : 
; 662  :     ON_IC_INTKEY;

  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00039	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0003f	83 e0 40	 and	 eax, 64			; 00000040H
  00042	85 c0		 test	 eax, eax
  00044	0f 85 f8 00 00
	00		 jne	 $LN17@ext_cmd
  0004a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00051	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00057	83 c8 40	 or	 eax, 64			; 00000040H
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00061	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00067	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006e	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00075	48 89 44 24 48	 mov	 QWORD PTR mask$2[rsp], rax
  0007a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00082	eb 0a		 jmp	 SHORT $LN16@ext_cmd
$LN14@ext_cmd:
  00084	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00088	ff c0		 inc	 eax
  0008a	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN16@ext_cmd:
  0008e	48 83 7c 24 48
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  00094	0f 84 a8 00 00
	00		 je	 $LN15@ext_cmd
  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR mask$2[rsp]
  0009f	48 83 e0 01	 and	 rax, 1
  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 84 84 00 00
	00		 je	 $LN18@ext_cmd
  000ac	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  000b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b8	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000c0	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000c3	83 e0 40	 and	 eax, 64			; 00000040H
  000c6	85 c0		 test	 eax, eax
  000c8	74 35		 je	 SHORT $LN19@ext_cmd
  000ca	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  000cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000d6	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000de	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000e1	0d 40 00 00 80	 or	 eax, -2147483584	; 80000040H
  000e6	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$1[rsp]
  000eb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000f2	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  000fa	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  000fd	eb 31		 jmp	 SHORT $LN20@ext_cmd
$LN19@ext_cmd:
  000ff	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  00104	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0010b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00113	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00116	83 c8 40	 or	 eax, 64			; 00000040H
  00119	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0011e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00125	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0012d	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN20@ext_cmd:
$LN18@ext_cmd:
  00130	48 8b 44 24 48	 mov	 rax, QWORD PTR mask$2[rsp]
  00135	48 d1 e8	 shr	 rax, 1
  00138	48 89 44 24 48	 mov	 QWORD PTR mask$2[rsp], rax
  0013d	e9 42 ff ff ff	 jmp	 $LN14@ext_cmd
$LN15@ext_cmd:
$LN17@ext_cmd:
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	0f 85 e6 fe ff
	ff		 jne	 $LN13@ext_cmd

; 663  : 
; 664  :     // "%s key pressed"
; 665  :     WRMSG(HHC02228, "I", "interrupt");

  0014c	b9 01 00 00 00	 mov	 ecx, 1
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159537
  0015e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159538
  0016a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0016f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159539
  00176	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00180	41 b9 03 00 00
	00		 mov	 r9d, 3
  00186	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159540
  0018d	ba 99 02 00 00	 mov	 edx, 665		; 00000299H
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159541
  00199	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 666  : 
; 667  :     /* Signal waiting CPUs that an interrupt is pending */
; 668  :     WAKEUP_CPUS_MASK (sysblk.waiting_mask);

  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159542
  001a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ad	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  001b4	e8 00 00 00 00	 call	 wakeup_cpus_mask

; 669  : 
; 670  :     RELEASE_INTLOCK(NULL);

  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159543
  001c0	33 c9		 xor	 ecx, ecx
  001c2	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 671  : 
; 672  :     return 0;

  001c7	33 c0		 xor	 eax, eax

; 673  : }

  001c9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001cd	c3		 ret	 0
ext_cmd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
clear$ = 32
argc$ = 64
argv$ = 72
cmdline$ = 80
iplc_cmd PROC

; 591  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 592  :     const bool clear = true;

  00012	c6 44 24 20 01	 mov	 BYTE PTR clear$[rsp], 1

; 593  :     return ipl_cmd2( argc, argv, cmdline, clear );

  00017	44 0f b6 4c 24
	20		 movzx	 r9d, BYTE PTR clear$[rsp]
  0001d	4c 8b 44 24 50	 mov	 r8, QWORD PTR cmdline$[rsp]
  00022	48 8b 54 24 48	 mov	 rdx, QWORD PTR argv$[rsp]
  00027	8b 4c 24 40	 mov	 ecx, DWORD PTR argc$[rsp]
  0002b	e8 00 00 00 00	 call	 ipl_cmd2

; 594  : }

  00030	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00034	c3		 ret	 0
iplc_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
clear$ = 32
argc$ = 64
argv$ = 72
cmdline$ = 80
ipl_cmd	PROC

; 581  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 582  :     const bool clear = false;

  00012	c6 44 24 20 00	 mov	 BYTE PTR clear$[rsp], 0

; 583  :     return ipl_cmd2( argc, argv, cmdline, clear );

  00017	44 0f b6 4c 24
	20		 movzx	 r9d, BYTE PTR clear$[rsp]
  0001d	4c 8b 44 24 50	 mov	 r8, QWORD PTR cmdline$[rsp]
  00022	48 8b 54 24 48	 mov	 rdx, QWORD PTR argv$[rsp]
  00027	8b 4c 24 40	 mov	 ecx, DWORD PTR argc$[rsp]
  0002b	e8 00 00 00 00	 call	 ipl_cmd2

; 584  : }

  00030	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00034	c3		 ret	 0
ipl_cmd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
clear$ = 80
argnum$1 = 84
save_ch$2 = 88
i$3 = 92
c$4 = 96
lcss$5 = 100
j$6 = 104
devnum$7 = 108
cdev$8 = 112
psi$9 = 120
rc$ = 128
clcss$10 = 136
orig_loadparm$11 = 144
len$12 = 152
loadparm$ = 160
dev$13 = 168
tv74 = 176
tv140 = 184
tv182 = 192
tv208 = 200
tv288 = 208
argc$ = 240
argv$ = 248
cmdline$ = 256
clear_opt$ = 264
ipl_cmd2 PROC

; 370  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	57		 push	 rdi
  00014	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H

; 371  : int     rc;                             /* Return code               */
; 372  : bool    clear        = clear_opt;       /* Called with clear option  */

  0001b	0f b6 84 24 08
	01 00 00	 movzx	 eax, BYTE PTR clear_opt$[rsp]
  00023	88 44 24 50	 mov	 BYTE PTR clear$[rsp], al

; 373  : char*   loadparm     = NULL;            /* Pointer to LOADPARM arg   */

  00027	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR loadparm$[rsp], 0
$LN4@ipl_cmd2:

; 374  : 
; 375  :     UNREFERENCED( cmdline );

  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 fa		 jne	 SHORT $LN4@ipl_cmd2

; 376  : 
; 377  :     /* Primary CPU must be online */
; 378  :     if (!IS_CPU_ONLINE( sysblk.pcpu ))

  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00040	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00057	0f 85 a6 00 00
	00		 jne	 $LN14@ipl_cmd2

; 379  :     {
; 380  :         // "Processor %s%02X: processor is not %s"
; 381  :         WRMSG( HHC00816, "E", PTYPSTR( sysblk.pcpu ), sysblk.pcpu, "online" );

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00064	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0006b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00072	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00080	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv74[rsp], rax
  00088	b9 01 00 00 00	 mov	 ecx, 1
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159375
  0009a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a6	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  000ac	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000b0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv74[rsp]
  000b8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159376
  000c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159377
  000d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000da	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159378
  000e7	ba 7d 01 00 00	 mov	 edx, 381		; 0000017dH
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159379
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 382  :         return -1;

  000f9	b8 ff ff ff ff	 mov	 eax, -1
  000fe	e9 7e 08 00 00	 jmp	 $LN1@ipl_cmd2
$LN14@ipl_cmd2:

; 383  :     }
; 384  : 
; 385  :     /* Check that target processor type allows IPL */
; 386  :     if (0
; 387  :         || SCCB_PTYP_ZAAP == sysblk.ptyp[ sysblk.pcpu ]
; 388  :         || SCCB_PTYP_ZIIP == sysblk.ptyp[ sysblk.pcpu ]

  00103	33 c0		 xor	 eax, eax
  00105	85 c0		 test	 eax, eax
  00107	75 48		 jne	 SHORT $LN16@ipl_cmd2
  00109	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00110	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00117	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0011e	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  00126	83 f8 02	 cmp	 eax, 2
  00129	74 26		 je	 SHORT $LN16@ipl_cmd2
  0012b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00132	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00139	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00140	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  00148	83 f8 05	 cmp	 eax, 5
  0014b	0f 85 9a 00 00
	00		 jne	 $LN15@ipl_cmd2
$LN16@ipl_cmd2:

; 389  :     )
; 390  :     {
; 391  :         // "Processor %s%02X: not eligible for ipl nor restart"
; 392  :         WRMSG( HHC00818, "E", PTYPSTR( sysblk.pcpu ), sysblk.pcpu );

  00151	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00158	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0015f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00166	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00174	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
  0017c	b9 01 00 00 00	 mov	 ecx, 1
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00187	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0018e	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00194	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00198	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv140[rsp]
  001a0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159382
  001ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159383
  001b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159384
  001cf	ba 88 01 00 00	 mov	 edx, 392		; 00000188H
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159385
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 393  :         return -1;

  001e1	b8 ff ff ff ff	 mov	 eax, -1
  001e6	e9 96 07 00 00	 jmp	 $LN1@ipl_cmd2
$LN15@ipl_cmd2:

; 394  :     }
; 395  : 
; 396  :     /* Check the parameters of the IPL command */
; 397  :     if (argc < 2)

  001eb	83 bc 24 f0 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  001f3	7d 0f		 jge	 SHORT $LN17@ipl_cmd2

; 398  :     {
; 399  :         missing_devnum();

  001f5	e8 00 00 00 00	 call	 missing_devnum

; 400  :         return -1;

  001fa	b8 ff ff ff ff	 mov	 eax, -1
  001ff	e9 7d 07 00 00	 jmp	 $LN1@ipl_cmd2
$LN17@ipl_cmd2:

; 401  :     }
; 402  : 
; 403  :     sysblk.haveiplparm = false;

  00204	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00211	0f ba f0 15	 btr	 eax, 21
  00215	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0021c	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 404  : 
; 405  :     if (argc > 2)

  00222	83 bc 24 f0 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0022a	0f 8e 26 04 00
	00		 jle	 $LN18@ipl_cmd2

; 406  :     {
; 407  :         int  argnum;
; 408  : 
; 409  :         /* Parse optional command-line arguments... */
; 410  :         for (argnum=2; argnum < argc; argnum++)

  00230	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR argnum$1[rsp], 2
  00238	eb 0a		 jmp	 SHORT $LN7@ipl_cmd2
$LN5@ipl_cmd2:
  0023a	8b 44 24 54	 mov	 eax, DWORD PTR argnum$1[rsp]
  0023e	ff c0		 inc	 eax
  00240	89 44 24 54	 mov	 DWORD PTR argnum$1[rsp], eax
$LN7@ipl_cmd2:
  00244	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0024b	39 44 24 54	 cmp	 DWORD PTR argnum$1[rsp], eax
  0024f	0f 8d 01 04 00
	00		 jge	 $LN6@ipl_cmd2

; 411  :         {
; 412  :             /* Check if 'CLEAR' option */
; 413  :             if (CMD( argv[ argnum ], CLEAR, 2 ))

  00255	48 63 44 24 54	 movsxd	 rax, DWORD PTR argnum$1[rsp]
  0025a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00260	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00268	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159390
  00273	e8 00 00 00 00	 call	 strcaseabbrev
  00278	85 c0		 test	 eax, eax
  0027a	74 0a		 je	 SHORT $LN19@ipl_cmd2

; 414  :             {
; 415  :                 clear = true;

  0027c	c6 44 24 50 01	 mov	 BYTE PTR clear$[rsp], 1

; 416  :             }

  00281	e9 cb 03 00 00	 jmp	 $LN20@ipl_cmd2
$LN19@ipl_cmd2:

; 417  : 
; 418  :             /* Check if 'LOADPARM' option */
; 419  :             else if (CMD( argv[ argnum ], LOADPARM, 4 ))

  00286	48 63 44 24 54	 movsxd	 rax, DWORD PTR argnum$1[rsp]
  0028b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00291	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00299	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0029d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159393
  002a4	e8 00 00 00 00	 call	 strcaseabbrev
  002a9	85 c0		 test	 eax, eax
  002ab	0f 84 b3 00 00
	00		 je	 $LN21@ipl_cmd2

; 420  :             {
; 421  :                 /* It's silly to specify 'LOADPARM' and not provide one */
; 422  :                 if (argc < (argnum+2))

  002b1	8b 44 24 54	 mov	 eax, DWORD PTR argnum$1[rsp]
  002b5	83 c0 02	 add	 eax, 2
  002b8	39 84 24 f0 00
	00 00		 cmp	 DWORD PTR argc$[rsp], eax
  002bf	7d 7b		 jge	 SHORT $LN23@ipl_cmd2

; 423  :                 {
; 424  :                     // "Missing argument(s). Type 'help %s' for assistance."
; 425  :                     WRMSG( HHC02202, "E", argv[0] );

  002c1	b8 08 00 00 00	 mov	 eax, 8
  002c6	48 6b c0 00	 imul	 rax, rax, 0
  002ca	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv182[rsp], rax
  002d2	b9 01 00 00 00	 mov	 ecx, 1
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002dd	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002e5	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv182[rsp]
  002ed	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  002f1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159395
  002fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159396
  00309	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0030e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00313	41 b9 03 00 00
	00		 mov	 r9d, 3
  00319	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159397
  00320	ba a9 01 00 00	 mov	 edx, 425		; 000001a9H
  00325	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159398
  0032c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 426  :                     return -1;

  00332	b8 ff ff ff ff	 mov	 eax, -1
  00337	e9 45 06 00 00	 jmp	 $LN1@ipl_cmd2
$LN23@ipl_cmd2:

; 427  :                 }
; 428  :                 loadparm = argv[ ++argnum ];

  0033c	8b 44 24 54	 mov	 eax, DWORD PTR argnum$1[rsp]
  00340	ff c0		 inc	 eax
  00342	89 44 24 54	 mov	 DWORD PTR argnum$1[rsp], eax
  00346	48 63 44 24 54	 movsxd	 rax, DWORD PTR argnum$1[rsp]
  0034b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00353	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00357	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR loadparm$[rsp], rax

; 429  :             }

  0035f	e9 ed 02 00 00	 jmp	 $LN22@ipl_cmd2
$LN21@ipl_cmd2:

; 430  : 
; 431  :             /* LASTLY, check if start of 'PARM' data */
; 432  :             else if (CMD( argv[ argnum ], PARM, 4 ))

  00364	48 63 44 24 54	 movsxd	 rax, DWORD PTR argnum$1[rsp]
  00369	41 b8 04 00 00
	00		 mov	 r8d, 4
  0036f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00377	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0037b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159401
  00382	e8 00 00 00 00	 call	 strcaseabbrev
  00387	85 c0		 test	 eax, eax
  00389	0f 84 3f 02 00
	00		 je	 $LN24@ipl_cmd2

; 433  :             {
; 434  :                 /* PROGRAMMING NOTE: the 'PARM' option, if specified,
; 435  :                    must be the last option specified on the command line
; 436  :                    as all remaining arguments are interpreted as being
; 437  :                    the actual parm data to be loaded into the registers.
; 438  :                 */
; 439  :                 int i, j, len;
; 440  :                 size_t psi;
; 441  : 
; 442  :                 /* It's silly to specify 'PARM' and not provide one */
; 443  :                 if (argc < (argnum+2))

  0038f	8b 44 24 54	 mov	 eax, DWORD PTR argnum$1[rsp]
  00393	83 c0 02	 add	 eax, 2
  00396	39 84 24 f0 00
	00 00		 cmp	 DWORD PTR argc$[rsp], eax
  0039d	7d 7b		 jge	 SHORT $LN26@ipl_cmd2

; 444  :                 {
; 445  :                     // "Missing argument(s). Type 'help %s' for assistance."
; 446  :                     WRMSG( HHC02202, "E", argv[0] );

  0039f	b8 08 00 00 00	 mov	 eax, 8
  003a4	48 6b c0 00	 imul	 rax, rax, 0
  003a8	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv208[rsp], rax
  003b0	b9 01 00 00 00	 mov	 ecx, 1
  003b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003bb	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003c3	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv208[rsp]
  003cb	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  003cf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159403
  003db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159404
  003e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159405
  003fe	ba be 01 00 00	 mov	 edx, 446		; 000001beH
  00403	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159406
  0040a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 447  :                     return -1;

  00410	b8 ff ff ff ff	 mov	 eax, -1
  00415	e9 67 05 00 00	 jmp	 $LN1@ipl_cmd2
$LN26@ipl_cmd2:

; 448  :                 }
; 449  : 
; 450  : #define  SIZEOF_IPLPARM     sizeof( sysblk.iplparmstring )
; 451  : 
; 452  :                 sysblk.haveiplparm = true;

  0041a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00421	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00427	0f ba e8 15	 bts	 eax, 21
  0042b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00432	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 453  :                 memset( sysblk.iplparmstring, 0, SIZEOF_IPLPARM );

  00438	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0043f	48 05 f8 12 00
	00		 add	 rax, 4856		; 000012f8H
  00445	48 8b f8	 mov	 rdi, rax
  00448	33 c0		 xor	 eax, eax
  0044a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0044f	f3 aa		 rep stosb

; 454  : 
; 455  :                 /* Each remaining argument is IPL 'PARM' data... */
; 456  :                 for (i = (argnum+1), psi=0; i < argc && psi < SIZEOF_IPLPARM; i++)

  00451	8b 44 24 54	 mov	 eax, DWORD PTR argnum$1[rsp]
  00455	ff c0		 inc	 eax
  00457	89 44 24 5c	 mov	 DWORD PTR i$3[rsp], eax
  0045b	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR psi$9[rsp], 0
  00464	eb 0a		 jmp	 SHORT $LN10@ipl_cmd2
$LN8@ipl_cmd2:
  00466	8b 44 24 5c	 mov	 eax, DWORD PTR i$3[rsp]
  0046a	ff c0		 inc	 eax
  0046c	89 44 24 5c	 mov	 DWORD PTR i$3[rsp], eax
$LN10@ipl_cmd2:
  00470	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00477	39 44 24 5c	 cmp	 DWORD PTR i$3[rsp], eax
  0047b	0f 8d 43 01 00
	00		 jge	 $LN9@ipl_cmd2
  00481	48 83 7c 24 78
	40		 cmp	 QWORD PTR psi$9[rsp], 64 ; 00000040H
  00487	0f 83 37 01 00
	00		 jae	 $LN9@ipl_cmd2

; 457  :                 {
; 458  :                     /* Leave a blank between each PARM argument */
; 459  :                     if (i != (argnum+1))

  0048d	8b 44 24 54	 mov	 eax, DWORD PTR argnum$1[rsp]
  00491	ff c0		 inc	 eax
  00493	39 44 24 5c	 cmp	 DWORD PTR i$3[rsp], eax
  00497	74 2d		 je	 SHORT $LN27@ipl_cmd2

; 460  :                         sysblk.iplparmstring[ psi++ ] = host_to_guest(' ');

  00499	b1 20		 mov	 cl, 32			; 00000020H
  0049b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  004a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR psi$9[rsp]
  004a6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004ad	48 03 d1	 add	 rdx, rcx
  004b0	48 8b ca	 mov	 rcx, rdx
  004b3	88 81 f8 12 00
	00		 mov	 BYTE PTR [rcx+4856], al
  004b9	48 8b 44 24 78	 mov	 rax, QWORD PTR psi$9[rsp]
  004be	48 ff c0	 inc	 rax
  004c1	48 89 44 24 78	 mov	 QWORD PTR psi$9[rsp], rax
$LN27@ipl_cmd2:

; 461  : 
; 462  :                     /* Convert argument to uppercase EBCDIC and
; 463  :                        save it in the SYSBLK iplparmstring field
; 464  :                     */
; 465  :                     for (j=0, len = (int) strlen( argv[i] ); j < len && psi < SIZEOF_IPLPARM; j++)

  004c6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR j$6[rsp], 0
  004ce	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$3[rsp]
  004d3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004db	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004df	e8 00 00 00 00	 call	 strlen
  004e4	89 84 24 98 00
	00 00		 mov	 DWORD PTR len$12[rsp], eax
  004eb	eb 0a		 jmp	 SHORT $LN13@ipl_cmd2
$LN11@ipl_cmd2:
  004ed	8b 44 24 68	 mov	 eax, DWORD PTR j$6[rsp]
  004f1	ff c0		 inc	 eax
  004f3	89 44 24 68	 mov	 DWORD PTR j$6[rsp], eax
$LN13@ipl_cmd2:
  004f7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$12[rsp]
  004fe	39 44 24 68	 cmp	 DWORD PTR j$6[rsp], eax
  00502	0f 8d b7 00 00
	00		 jge	 $LN12@ipl_cmd2
  00508	48 83 7c 24 78
	40		 cmp	 QWORD PTR psi$9[rsp], 64 ; 00000040H
  0050e	0f 83 ab 00 00
	00		 jae	 $LN12@ipl_cmd2

; 466  :                     {
; 467  :                         if (islower( argv[i][j] ))

  00514	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$3[rsp]
  00519	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR j$6[rsp]
  0051e	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00526	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  0052a	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0052e	8b c8		 mov	 ecx, eax
  00530	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_islower
  00536	85 c0		 test	 eax, eax
  00538	74 3b		 je	 SHORT $LN28@ipl_cmd2

; 468  :                             argv[i][j] = toupper( argv[i][j] );

  0053a	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$3[rsp]
  0053f	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR j$6[rsp]
  00544	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0054c	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00550	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00554	8b c8		 mov	 ecx, eax
  00556	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  0055c	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR i$3[rsp]
  00561	48 63 54 24 68	 movsxd	 rdx, DWORD PTR j$6[rsp]
  00566	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR argv$[rsp]
  0056e	48 8b 0c cf	 mov	 rcx, QWORD PTR [rdi+rcx*8]
  00572	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
$LN28@ipl_cmd2:

; 469  : 
; 470  :                         sysblk.iplparmstring[ psi++ ] = host_to_guest( argv[i][j] );

  00575	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$3[rsp]
  0057a	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR j$6[rsp]
  0057f	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00587	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  0058b	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  00595	48 8b 4c 24 78	 mov	 rcx, QWORD PTR psi$9[rsp]
  0059a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005a1	48 03 d1	 add	 rdx, rcx
  005a4	48 8b ca	 mov	 rcx, rdx
  005a7	88 81 f8 12 00
	00		 mov	 BYTE PTR [rcx+4856], al
  005ad	48 8b 44 24 78	 mov	 rax, QWORD PTR psi$9[rsp]
  005b2	48 ff c0	 inc	 rax
  005b5	48 89 44 24 78	 mov	 QWORD PTR psi$9[rsp], rax

; 471  :                     }

  005ba	e9 2e ff ff ff	 jmp	 $LN11@ipl_cmd2
$LN12@ipl_cmd2:

; 472  :                 }

  005bf	e9 a2 fe ff ff	 jmp	 $LN8@ipl_cmd2
$LN9@ipl_cmd2:

; 473  : 
; 474  :                 /* No more arguments remain. (See PROGRAMMING NOTE) */
; 475  :                 break;

  005c4	e9 8d 00 00 00	 jmp	 $LN6@ipl_cmd2

; 476  :             }

  005c9	e9 83 00 00 00	 jmp	 $LN25@ipl_cmd2
$LN24@ipl_cmd2:

; 477  :             else
; 478  :             {
; 479  :                 // "Invalid argument %s%s"
; 480  :                 WRMSG( HHC02205, "E", argv[ argnum ], ": unrecognized option" );

  005ce	48 63 44 24 54	 movsxd	 rax, DWORD PTR argnum$1[rsp]
  005d3	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv288[rsp], rax
  005db	b9 01 00 00 00	 mov	 ecx, 1
  005e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159409
  005ed	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  005f2	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005fa	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR tv288[rsp]
  00602	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00606	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0060b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159410
  00612	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00617	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159411
  0061e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00623	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00628	41 b9 03 00 00
	00		 mov	 r9d, 3
  0062e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159412
  00635	ba e0 01 00 00	 mov	 edx, 480		; 000001e0H
  0063a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159413
  00641	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 481  :                 return -1;

  00647	b8 ff ff ff ff	 mov	 eax, -1
  0064c	e9 30 03 00 00	 jmp	 $LN1@ipl_cmd2
$LN25@ipl_cmd2:
$LN22@ipl_cmd2:
$LN20@ipl_cmd2:

; 482  :             }
; 483  :         }

  00651	e9 e4 fb ff ff	 jmp	 $LN5@ipl_cmd2
$LN6@ipl_cmd2:
$LN18@ipl_cmd2:

; 484  :     }
; 485  : 
; 486  :     /* Attempt the IPL... (first argument determines how we do it) */
; 487  : 
; 488  :     OBTAIN_INTLOCK( NULL );

  00656	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159414
  0065d	33 c9		 xor	 ecx, ecx
  0065f	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 489  :     {
; 490  :         char*  cdev;
; 491  :         char*  clcss;
; 492  :         char*  orig_loadparm;
; 493  :         U16    devnum;
; 494  :         BYTE   c;
; 495  :         char   save_ch=0;

  00664	c6 44 24 58 00	 mov	 BYTE PTR save_ch$2[rsp], 0

; 496  : 
; 497  :         /* Start with default LOADPARM value */
; 498  :         set_loadparm( sysblk.loadparm );

  00669	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00670	48 05 38 13 00
	00		 add	 rax, 4920		; 00001338H
  00676	48 8b c8	 mov	 rcx, rax
  00679	e8 00 00 00 00	 call	 set_loadparm

; 499  : 
; 500  :         /* Save the LOADPARM in case of error */
; 501  :         orig_loadparm = strdup( str_loadparm() );

  0067e	e8 00 00 00 00	 call	 str_loadparm
  00683	48 8b c8	 mov	 rcx, rax
  00686	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0068c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR orig_loadparm$11[rsp], rax

; 502  : 
; 503  :         /* Set the LOADPARM if specified */
; 504  :         if (loadparm)

  00694	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR loadparm$[rsp], 0
  0069d	74 0d		 je	 SHORT $LN29@ipl_cmd2

; 505  :             set_loadparm( loadparm );

  0069f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR loadparm$[rsp]
  006a7	e8 00 00 00 00	 call	 set_loadparm
$LN29@ipl_cmd2:

; 506  : 
; 507  :         /* The ipl device number might be in format lcss:devnum */
; 508  :         if ((cdev = strchr( argv[1], ':' )))

  006ac	b8 08 00 00 00	 mov	 eax, 8
  006b1	48 6b c0 01	 imul	 rax, rax, 1
  006b5	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  006ba	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006c2	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  006c6	e8 00 00 00 00	 call	 strchr
  006cb	48 89 44 24 70	 mov	 QWORD PTR cdev$8[rsp], rax
  006d0	48 83 7c 24 70
	00		 cmp	 QWORD PTR cdev$8[rsp], 0
  006d6	74 40		 je	 SHORT $LN30@ipl_cmd2

; 509  :         {
; 510  :             clcss = argv[1];

  006d8	b8 08 00 00 00	 mov	 eax, 8
  006dd	48 6b c0 01	 imul	 rax, rax, 1
  006e1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006e9	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  006ed	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR clcss$10[rsp], rax

; 511  :             save_ch = *cdev;

  006f5	48 8b 44 24 70	 mov	 rax, QWORD PTR cdev$8[rsp]
  006fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006fd	88 44 24 58	 mov	 BYTE PTR save_ch$2[rsp], al

; 512  :             *cdev = '\0';

  00701	48 8b 44 24 70	 mov	 rax, QWORD PTR cdev$8[rsp]
  00706	c6 00 00	 mov	 BYTE PTR [rax], 0

; 513  :             cdev++;

  00709	48 8b 44 24 70	 mov	 rax, QWORD PTR cdev$8[rsp]
  0070e	48 ff c0	 inc	 rax
  00711	48 89 44 24 70	 mov	 QWORD PTR cdev$8[rsp], rax

; 514  :         }

  00716	eb 26		 jmp	 SHORT $LN31@ipl_cmd2
$LN30@ipl_cmd2:

; 515  :         else
; 516  :         {
; 517  :             clcss = NULL;

  00718	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR clcss$10[rsp], 0

; 518  :             cdev = argv[1];

  00724	b8 08 00 00 00	 mov	 eax, 8
  00729	48 6b c0 01	 imul	 rax, rax, 1
  0072d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00735	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00739	48 89 44 24 70	 mov	 QWORD PTR cdev$8[rsp], rax
$LN31@ipl_cmd2:

; 519  :         }
; 520  : 
; 521  :         /* If the ipl device is not a valid hex number, then
; 522  :            we assume this is a load from the service processor */
; 523  :         if (sscanf( cdev, "%hx%c", &devnum, &c ) != 1)

  0073e	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$4[rsp]
  00743	4c 8d 44 24 6c	 lea	 r8, QWORD PTR devnum$7[rsp]
  00748	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159420
  0074f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cdev$8[rsp]
  00754	e8 00 00 00 00	 call	 sscanf
  00759	83 f8 01	 cmp	 eax, 1
  0075c	74 7e		 je	 SHORT $LN32@ipl_cmd2

; 524  :         {
; 525  :             free( orig_loadparm );

  0075e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR orig_loadparm$11[rsp]
  00766	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 526  :             if (cdev != argv[1])

  0076c	b8 08 00 00 00	 mov	 eax, 8
  00771	48 6b c0 01	 imul	 rax, rax, 1
  00775	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0077d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00781	48 39 44 24 70	 cmp	 QWORD PTR cdev$8[rsp], rax
  00786	74 19		 je	 SHORT $LN34@ipl_cmd2

; 527  :                 *--cdev = save_ch;

  00788	48 8b 44 24 70	 mov	 rax, QWORD PTR cdev$8[rsp]
  0078d	48 ff c8	 dec	 rax
  00790	48 89 44 24 70	 mov	 QWORD PTR cdev$8[rsp], rax
  00795	48 8b 44 24 70	 mov	 rax, QWORD PTR cdev$8[rsp]
  0079a	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR save_ch$2[rsp]
  0079f	88 08		 mov	 BYTE PTR [rax], cl
$LN34@ipl_cmd2:

; 528  :             rc = load_hmc( argv[1], sysblk.pcpu, clear );

  007a1	0f b6 44 24 50	 movzx	 eax, BYTE PTR clear$[rsp]
  007a6	b9 08 00 00 00	 mov	 ecx, 8
  007ab	48 6b c9 01	 imul	 rcx, rcx, 1
  007af	44 8b c0	 mov	 r8d, eax
  007b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007b9	8b 90 54 13 00
	00		 mov	 edx, DWORD PTR [rax+4948]
  007bf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  007c7	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  007cb	e8 00 00 00 00	 call	 load_hmc
  007d0	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 529  :         }

  007d7	e9 90 01 00 00	 jmp	 $LN33@ipl_cmd2
$LN32@ipl_cmd2:

; 530  :         else
; 531  :         {
; 532  :             U16 lcss;
; 533  : #if defined( _FEATURE_SCSI_IPL )
; 534  :             DEVBLK* dev;
; 535  : #endif
; 536  :             /* Parse the LCSS value if one was specified */
; 537  :             lcss = 0;

  007dc	33 c0		 xor	 eax, eax
  007de	66 89 44 24 64	 mov	 WORD PTR lcss$5[rsp], ax

; 538  :             if (clcss)

  007e3	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR clcss$10[rsp], 0
  007ec	0f 84 d8 00 00
	00		 je	 $LN35@ipl_cmd2

; 539  :             {
; 540  :                 if (sscanf( clcss, "%hd%c", &lcss, &c ) != 1)

  007f2	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$4[rsp]
  007f7	4c 8d 44 24 64	 lea	 r8, QWORD PTR lcss$5[rsp]
  007fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159424
  00803	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clcss$10[rsp]
  0080b	e8 00 00 00 00	 call	 sscanf
  00810	83 f8 01	 cmp	 eax, 1
  00813	0f 84 b1 00 00
	00		 je	 $LN36@ipl_cmd2

; 541  :                 {
; 542  :                     // "Invalid argument %s%s"
; 543  :                     WRMSG( HHC02205, "E", clcss, ": LCSS id is invalid" );

  00819	b9 01 00 00 00	 mov	 ecx, 1
  0081e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00824	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159425
  0082b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00830	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clcss$10[rsp]
  00838	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0083d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159426
  00844	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00849	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159427
  00850	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00855	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0085a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00860	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159428
  00867	ba 1f 02 00 00	 mov	 edx, 543		; 0000021fH
  0086c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159429
  00873	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 544  : 
; 545  :                     /* Restore original LOADPARM and exit */
; 546  :                     set_loadparm( orig_loadparm );

  00879	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR orig_loadparm$11[rsp]
  00881	e8 00 00 00 00	 call	 set_loadparm

; 547  :                     sysblk.haveiplparm = false;

  00886	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0088d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00893	0f ba f0 15	 btr	 eax, 21
  00897	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0089e	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 548  :                     free( orig_loadparm );

  008a4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR orig_loadparm$11[rsp]
  008ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 549  :                     RELEASE_INTLOCK( NULL );

  008b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159430
  008b9	33 c9		 xor	 ecx, ecx
  008bb	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 550  :                     return -1;

  008c0	b8 ff ff ff ff	 mov	 eax, -1
  008c5	e9 b7 00 00 00	 jmp	 $LN1@ipl_cmd2
$LN36@ipl_cmd2:
$LN35@ipl_cmd2:

; 551  :                 }
; 552  :             }
; 553  : 
; 554  :             /*-------------------*/
; 555  :             /*   Start the IPL   */
; 556  :             /*-------------------*/
; 557  : 
; 558  :             free( orig_loadparm );      /* (no longer needed) */

  008ca	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR orig_loadparm$11[rsp]
  008d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 559  : 
; 560  : #if defined( _FEATURE_SCSI_IPL )
; 561  :             if (1
; 562  :                 && (dev = find_device_by_devnum( lcss, devnum ))
; 563  :                 && support_boot( dev ) >= 0

  008d8	33 c0		 xor	 eax, eax
  008da	83 f8 01	 cmp	 eax, 1
  008dd	74 61		 je	 SHORT $LN37@ipl_cmd2
  008df	0f b7 54 24 6c	 movzx	 edx, WORD PTR devnum$7[rsp]
  008e4	0f b7 4c 24 64	 movzx	 ecx, WORD PTR lcss$5[rsp]
  008e9	e8 00 00 00 00	 call	 find_device_by_devnum
  008ee	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR dev$13[rsp], rax
  008f6	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR dev$13[rsp], 0
  008ff	74 3f		 je	 SHORT $LN37@ipl_cmd2
  00901	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR dev$13[rsp]
  00909	e8 00 00 00 00	 call	 support_boot
  0090e	85 c0		 test	 eax, eax
  00910	7c 2e		 jl	 SHORT $LN37@ipl_cmd2

; 564  :             )
; 565  :                 rc = load_boot( dev, sysblk.pcpu, clear, 0 );

  00912	0f b6 44 24 50	 movzx	 eax, BYTE PTR clear$[rsp]
  00917	45 33 c9	 xor	 r9d, r9d
  0091a	44 8b c0	 mov	 r8d, eax
  0091d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00924	8b 90 54 13 00
	00		 mov	 edx, DWORD PTR [rax+4948]
  0092a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR dev$13[rsp]
  00932	e8 00 00 00 00	 call	 load_boot
  00937	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  0093e	eb 2c		 jmp	 SHORT $LN38@ipl_cmd2
$LN37@ipl_cmd2:

; 566  :             else
; 567  : #endif
; 568  :                 rc = load_ipl( lcss, devnum, sysblk.pcpu, clear );

  00940	0f b6 44 24 50	 movzx	 eax, BYTE PTR clear$[rsp]
  00945	44 8b c8	 mov	 r9d, eax
  00948	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0094f	44 8b 80 54 13
	00 00		 mov	 r8d, DWORD PTR [rax+4948]
  00956	0f b7 54 24 6c	 movzx	 edx, WORD PTR devnum$7[rsp]
  0095b	0f b7 4c 24 64	 movzx	 ecx, WORD PTR lcss$5[rsp]
  00960	e8 00 00 00 00	 call	 load_ipl
  00965	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN38@ipl_cmd2:
$LN33@ipl_cmd2:

; 569  :         }
; 570  :     }
; 571  :     RELEASE_INTLOCK( NULL );

  0096c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159433
  00973	33 c9		 xor	 ecx, ecx
  00975	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 572  : 
; 573  :     return rc;

  0097a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
$LN1@ipl_cmd2:

; 574  : }

  00981	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00988	5f		 pop	 rdi
  00989	c3		 ret	 0
ipl_cmd2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
clear$ = 80
rc$ = 84
tv66 = 88
tv84 = 96
ac$ = 128
av$ = 136
cmdline$ = 144
sysclear_cmd PROC

; 343  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 344  :     int rc;
; 345  :     const bool clear = true;

  00012	c6 44 24 50 01	 mov	 BYTE PTR clear$[rsp], 1

; 346  : 
; 347  :     if (ac > 1)

  00017	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR ac$[rsp], 1
  0001f	0f 8e 81 00 00
	00		 jle	 $LN2@sysclear_c

; 348  :     {
; 349  :         // "Invalid argument %s%s"
; 350  :         WRMSG( HHC02205, "E", av[1], "" );

  00025	b8 08 00 00 00	 mov	 eax, 8
  0002a	48 6b c0 01	 imul	 rax, rax, 1
  0002e	48 89 44 24 58	 mov	 QWORD PTR tv66[rsp], rax
  00033	b9 01 00 00 00	 mov	 ecx, 1
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159316
  00045	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0004a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00052	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv66[rsp]
  00057	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0005b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159317
  00067	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159318
  00073	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00078	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159319
  0008a	ba 5e 01 00 00	 mov	 edx, 350		; 0000015eH
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159320
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 351  :         return -1;

  0009c	b8 ff ff ff ff	 mov	 eax, -1
  000a1	e9 9c 00 00 00	 jmp	 $LN1@sysclear_c
$LN2@sysclear_c:

; 352  :     }
; 353  : 
; 354  :     if ((rc = reset_cmd( ac, av, cmdline, clear )) >= 0)

  000a6	44 0f b6 4c 24
	50		 movzx	 r9d, BYTE PTR clear$[rsp]
  000ac	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR cmdline$[rsp]
  000b4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  000bc	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ac$[rsp]
  000c3	e8 00 00 00 00	 call	 reset_cmd
  000c8	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  000cc	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d1	7c 6b		 jl	 SHORT $LN3@sysclear_c

; 355  :         WRMSG( HHC02311, "I", av[0] ); // "%s completed"

  000d3	b8 08 00 00 00	 mov	 eax, 8
  000d8	48 6b c0 00	 imul	 rax, rax, 0
  000dc	48 89 44 24 60	 mov	 QWORD PTR tv84[rsp], rax
  000e1	b9 01 00 00 00	 mov	 ecx, 1
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ec	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  000f4	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv84[rsp]
  000f9	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  000fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159322
  00109	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159323
  00115	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00125	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159324
  0012c	ba 63 01 00 00	 mov	 edx, 355		; 00000163H
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159325
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@sysclear_c:

; 356  : 
; 357  :     // else error message already issued elsewhere
; 358  : 
; 359  :     return rc;

  0013e	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@sysclear_c:

; 360  : }

  00142	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00146	c3		 ret	 0
sysclear_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
clear$ = 80
rc$ = 84
tv66 = 88
tv92 = 96
ac$ = 128
av$ = 136
cmdline$ = 144
sysreset_cmd PROC

; 307  : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 308  :     int rc;
; 309  :     bool clear = false;  // (default)

  00012	c6 44 24 50 00	 mov	 BYTE PTR clear$[rsp], 0

; 310  : 
; 311  :     if (ac > 2)

  00017	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR ac$[rsp], 2
  0001f	0f 8e 81 00 00
	00		 jle	 $LN2@sysreset_c

; 312  :     {
; 313  :         // "Invalid argument %s%s"
; 314  :         WRMSG( HHC02205, "E", av[2], "" );

  00025	b8 08 00 00 00	 mov	 eax, 8
  0002a	48 6b c0 02	 imul	 rax, rax, 2
  0002e	48 89 44 24 58	 mov	 QWORD PTR tv66[rsp], rax
  00033	b9 01 00 00 00	 mov	 ecx, 1
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159283
  00045	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0004a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00052	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv66[rsp]
  00057	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0005b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159284
  00067	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159285
  00073	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00078	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159286
  0008a	ba 3a 01 00 00	 mov	 edx, 314		; 0000013aH
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159287
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 315  :         return -1;

  0009c	b8 ff ff ff ff	 mov	 eax, -1
  000a1	e9 74 01 00 00	 jmp	 $LN1@sysreset_c
$LN2@sysreset_c:

; 316  :     }
; 317  : 
; 318  :     if (ac == 2)

  000a6	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR ac$[rsp], 2
  000ae	0f 85 e1 00 00
	00		 jne	 $LN3@sysreset_c

; 319  :     {
; 320  :         if (     !strcasecmp( "clear",  av[1] )) clear = true;

  000b4	b8 08 00 00 00	 mov	 eax, 8
  000b9	48 6b c0 01	 imul	 rax, rax, 1
  000bd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  000c5	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159291
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000d6	85 c0		 test	 eax, eax
  000d8	75 0a		 jne	 SHORT $LN4@sysreset_c
  000da	c6 44 24 50 01	 mov	 BYTE PTR clear$[rsp], 1
  000df	e9 b1 00 00 00	 jmp	 $LN5@sysreset_c
$LN4@sysreset_c:

; 321  :         else if (!strcasecmp( "normal", av[1] )) clear = false;

  000e4	b8 08 00 00 00	 mov	 eax, 8
  000e9	48 6b c0 01	 imul	 rax, rax, 1
  000ed	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  000f5	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159294
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00106	85 c0		 test	 eax, eax
  00108	75 0a		 jne	 SHORT $LN6@sysreset_c
  0010a	c6 44 24 50 00	 mov	 BYTE PTR clear$[rsp], 0
  0010f	e9 81 00 00 00	 jmp	 $LN7@sysreset_c
$LN6@sysreset_c:

; 322  :         else
; 323  :         {
; 324  :             // "Invalid argument %s%s"
; 325  :             WRMSG( HHC02205, "E", av[1], "" );

  00114	b8 08 00 00 00	 mov	 eax, 8
  00119	48 6b c0 01	 imul	 rax, rax, 1
  0011d	48 89 44 24 60	 mov	 QWORD PTR tv92[rsp], rax
  00122	b9 01 00 00 00	 mov	 ecx, 1
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159295
  00134	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00139	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00141	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv92[rsp]
  00146	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0014a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159296
  00156	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159297
  00162	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00167	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00172	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159298
  00179	ba 45 01 00 00	 mov	 edx, 325		; 00000145H
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159299
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 326  :             return -1;

  0018b	b8 ff ff ff ff	 mov	 eax, -1
  00190	e9 85 00 00 00	 jmp	 $LN1@sysreset_c
$LN7@sysreset_c:
$LN5@sysreset_c:
$LN3@sysreset_c:

; 327  :         }
; 328  :     }
; 329  : 
; 330  :     if ((rc = reset_cmd( ac, av, cmdline, clear )) >= 0)

  00195	44 0f b6 4c 24
	50		 movzx	 r9d, BYTE PTR clear$[rsp]
  0019b	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR cmdline$[rsp]
  001a3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  001ab	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ac$[rsp]
  001b2	e8 00 00 00 00	 call	 reset_cmd
  001b7	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  001bb	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  001c0	7c 54		 jl	 SHORT $LN8@sysreset_c

; 331  :         WRMSG( HHC02311, "I", cmdline ); // "%s completed"

  001c2	b9 01 00 00 00	 mov	 ecx, 1
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001cd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  001d5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159301
  001e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159302
  001ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  001fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159303
  00204	ba 4b 01 00 00	 mov	 edx, 331		; 0000014bH
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159304
  00210	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@sysreset_c:

; 332  : 
; 333  :     // else error message already issued elsewhere
; 334  : 
; 335  :     return rc;

  00216	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@sysreset_c:

; 336  : }

  0021a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0021e	c3		 ret	 0
sysreset_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
ipl$ = 32
rc$ = 36
ac$ = 64
av$ = 72
cmdline$ = 80
clear$ = 88
reset_cmd PROC

; 279  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 280  :     int rc;
; 281  :     const bool ipl = false;

  00017	c6 44 24 20 00	 mov	 BYTE PTR ipl$[rsp], 0
$LN4@reset_cmd:

; 282  : 
; 283  :     UNREFERENCED( ac );

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN4@reset_cmd
$LN7@reset_cmd:

; 284  :     UNREFERENCED( av );

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 fa		 jne	 SHORT $LN7@reset_cmd
$LN10@reset_cmd:

; 285  :     UNREFERENCED( cmdline );

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	75 fa		 jne	 SHORT $LN10@reset_cmd

; 286  : 
; 287  :     OBTAIN_INTLOCK( NULL );

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159270
  00035	33 c9		 xor	 ecx, ecx
  00037	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 288  :     {
; 289  :         /* Note: there's no need to check if the CPUs are stopped.
; 290  :          * According to the Principles of Operation manual, both
; 291  :          * the system-reset-clear and system-reset-normal keys
; 292  :          * are effective when the CPU is in the operating, stopped,
; 293  :          * load, or check-stop state.
; 294  :          */
; 295  :         rc = system_reset( sysblk.arch_mode, clear, ipl, sysblk.pcpu );

  0003c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00043	44 8b 88 54 13
	00 00		 mov	 r9d, DWORD PTR [rax+4948]
  0004a	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR ipl$[rsp]
  00050	0f b6 54 24 58	 movzx	 edx, BYTE PTR clear$[rsp]
  00055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005c	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  00062	e8 00 00 00 00	 call	 system_reset
  00067	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 296  :     }
; 297  :     RELEASE_INTLOCK( NULL );

  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159271
  00072	33 c9		 xor	 ecx, ecx
  00074	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 298  : 
; 299  :     return rc;

  00079	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]

; 300  : }

  0007d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00081	c3		 ret	 0
reset_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
rc$ = 64
on$ = 68
tv136 = 72
tv145 = 80
argc$ = 112
argv$ = 120
cmdline$ = 128
cfall_cmd PROC

; 212  : {

$LN21:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 213  : static char* qproc[] = { "qproc", NULL };   // "qproc" command
; 214  : int rc = 0;

  00012	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 215  : int on = -1;

  0001a	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR on$[rsp], -1
$LN4@cfall_cmd:

; 216  : 
; 217  :     UPPER_ARGV_0( argv );

  00022	48 83 7c 24 78
	00		 cmp	 QWORD PTR argv$[rsp], 0
  00028	74 3e		 je	 SHORT $LN8@cfall_cmd
  0002a	b8 08 00 00 00	 mov	 eax, 8
  0002f	48 6b c0 00	 imul	 rax, rax, 0
  00033	48 8b 4c 24 78	 mov	 rcx, QWORD PTR argv$[rsp]
  00038	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0003d	74 29		 je	 SHORT $LN8@cfall_cmd
  0003f	b8 08 00 00 00	 mov	 eax, 8
  00044	48 6b c0 00	 imul	 rax, rax, 0
  00048	b9 08 00 00 00	 mov	 ecx, 8
  0004d	48 6b c9 00	 imul	 rcx, rcx, 0
  00051	48 8b 54 24 78	 mov	 rdx, QWORD PTR argv$[rsp]
  00056	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  0005a	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  0005f	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  00063	e8 00 00 00 00	 call	 strupper
$LN8@cfall_cmd:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 b4		 jne	 SHORT $LN4@cfall_cmd
$LN7@cfall_cmd:

; 218  : 
; 219  :     UNREFERENCED( cmdline );

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 fa		 jne	 SHORT $LN7@cfall_cmd

; 220  : 
; 221  :     if (argc == 2)

  00074	83 7c 24 70 02	 cmp	 DWORD PTR argc$[rsp], 2
  00079	0f 85 f1 00 00
	00		 jne	 $LN9@cfall_cmd

; 222  :     {
; 223  :              if (CMD( argv[1], ON,  2 )) on = 1; // (change to online)

  0007f	b8 08 00 00 00	 mov	 eax, 8
  00084	48 6b c0 01	 imul	 rax, rax, 1
  00088	41 b8 02 00 00
	00		 mov	 r8d, 2
  0008e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR argv$[rsp]
  00093	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159232
  0009e	e8 00 00 00 00	 call	 strcaseabbrev
  000a3	85 c0		 test	 eax, eax
  000a5	74 0d		 je	 SHORT $LN11@cfall_cmd
  000a7	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR on$[rsp], 1
  000af	e9 81 00 00 00	 jmp	 $LN12@cfall_cmd
$LN11@cfall_cmd:

; 224  :         else if (CMD( argv[1], OFF, 3 )) on = 0; // (change to offline)

  000b4	b8 08 00 00 00	 mov	 eax, 8
  000b9	48 6b c0 01	 imul	 rax, rax, 1
  000bd	41 b8 03 00 00
	00		 mov	 r8d, 3
  000c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR argv$[rsp]
  000c8	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159235
  000d3	e8 00 00 00 00	 call	 strcaseabbrev
  000d8	85 c0		 test	 eax, eax
  000da	74 0a		 je	 SHORT $LN13@cfall_cmd
  000dc	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR on$[rsp], 0
  000e4	eb 4f		 jmp	 SHORT $LN14@cfall_cmd
$LN13@cfall_cmd:

; 225  :         else
; 226  :         {
; 227  :             // "Missing or invalid argument(s)"
; 228  :             WRMSG( HHC17000, "E" );

  000e6	b9 01 00 00 00	 mov	 ecx, 1
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159236
  000f8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159237
  00104	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00109	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00114	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159238
  0011b	ba e4 00 00 00	 mov	 edx, 228		; 000000e4H
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159239
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 229  :             rc = -1;

  0012d	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN14@cfall_cmd:
$LN12@cfall_cmd:

; 230  :         }
; 231  :         if (rc == 0)

  00135	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0013a	75 2f		 jne	 SHORT $LN15@cfall_cmd

; 232  :         {
; 233  :             // configure number of online CPUs (i.e. NUMCPU)
; 234  :             rc = configure_numcpu( on ? sysblk.maxcpu : 0 );

  0013c	83 7c 24 44 00	 cmp	 DWORD PTR on$[rsp], 0
  00141	74 13		 je	 SHORT $LN19@cfall_cmd
  00143	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00150	89 44 24 48	 mov	 DWORD PTR tv136[rsp], eax
  00154	eb 08		 jmp	 SHORT $LN20@cfall_cmd
$LN19@cfall_cmd:
  00156	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN20@cfall_cmd:
  0015e	8b 4c 24 48	 mov	 ecx, DWORD PTR tv136[rsp]
  00162	e8 00 00 00 00	 call	 configure_numcpu
  00167	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN15@cfall_cmd:

; 235  :         }
; 236  :     }

  0016b	e9 a2 00 00 00	 jmp	 $LN10@cfall_cmd
$LN9@cfall_cmd:

; 237  :     else if (argc == 1)

  00170	83 7c 24 70 01	 cmp	 DWORD PTR argc$[rsp], 1
  00175	75 2b		 jne	 SHORT $LN16@cfall_cmd

; 238  :     {
; 239  :         // Show current CPU settings
; 240  :         rc = qproc_cmd( 1, qproc, *qproc );

  00177	b8 08 00 00 00	 mov	 eax, 8
  0017c	48 6b c0 00	 imul	 rax, rax, 0
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?qproc@?1??cfall_cmd@@9@9
  00187	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  0018b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?qproc@?1??cfall_cmd@@9@9
  00192	b9 01 00 00 00	 mov	 ecx, 1
  00197	e8 00 00 00 00	 call	 qproc_cmd
  0019c	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 241  :     }

  001a0	eb 70		 jmp	 SHORT $LN17@cfall_cmd
$LN16@cfall_cmd:

; 242  :     else
; 243  :     {
; 244  :         // "Invalid command usage. Type 'help %s' for assistance."
; 245  :         WRMSG( HHC02299, "E", argv[0] );

  001a2	b8 08 00 00 00	 mov	 eax, 8
  001a7	48 6b c0 00	 imul	 rax, rax, 0
  001ab	48 89 44 24 50	 mov	 QWORD PTR tv145[rsp], rax
  001b0	b9 01 00 00 00	 mov	 ecx, 1
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR argv$[rsp]
  001c0	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv145[rsp]
  001c5	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001c9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159243
  001d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159244
  001e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159245
  001f8	ba f5 00 00 00	 mov	 edx, 245		; 000000f5H
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159246
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 246  :         rc = -1;

  0020a	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN17@cfall_cmd:
$LN10@cfall_cmd:

; 247  :     }
; 248  :     return rc;

  00212	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 249  : }

  00216	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0021a	c3		 ret	 0
cfall_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
on$ = 80
tv134 = 88
tv157 = 96
argc$ = 128
argv$ = 136
cmdline$ = 144
cf_cmd	PROC

; 161  : {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 162  :     int on = -1;  // (-1 indicates no change wanted)

  00012	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR on$[rsp], -1
$LN4@cf_cmd:

; 163  : 
; 164  :     UPPER_ARGV_0( argv );

  0001a	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  00023	74 47		 je	 SHORT $LN8@cf_cmd
  00025	b8 08 00 00 00	 mov	 eax, 8
  0002a	48 6b c0 00	 imul	 rax, rax, 0
  0002e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00036	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0003b	74 2f		 je	 SHORT $LN8@cf_cmd
  0003d	b8 08 00 00 00	 mov	 eax, 8
  00042	48 6b c0 00	 imul	 rax, rax, 0
  00046	b9 08 00 00 00	 mov	 ecx, 8
  0004b	48 6b c9 00	 imul	 rcx, rcx, 0
  0004f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00057	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  0005b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00063	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  00067	e8 00 00 00 00	 call	 strupper
$LN8@cf_cmd:
  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 a8		 jne	 SHORT $LN4@cf_cmd
$LN7@cf_cmd:

; 165  : 
; 166  :     UNREFERENCED( cmdline );

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 fa		 jne	 SHORT $LN7@cf_cmd

; 167  : 
; 168  :     /* Change settings? */
; 169  :     if (argc == 2)

  00078	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00080	75 68		 jne	 SHORT $LN9@cf_cmd

; 170  :     {
; 171  :              if (CMD( argv[1], ON,  2 )) on = 1; // (change to online)

  00082	b8 08 00 00 00	 mov	 eax, 8
  00087	48 6b c0 01	 imul	 rax, rax, 1
  0008b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00091	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00099	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159185
  000a4	e8 00 00 00 00	 call	 strcaseabbrev
  000a9	85 c0		 test	 eax, eax
  000ab	74 0a		 je	 SHORT $LN10@cf_cmd
  000ad	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR on$[rsp], 1
  000b5	eb 33		 jmp	 SHORT $LN11@cf_cmd
$LN10@cf_cmd:

; 172  :         else if (CMD( argv[1], OFF, 3 )) on = 0; // (change to offline)

  000b7	b8 08 00 00 00	 mov	 eax, 8
  000bc	48 6b c0 01	 imul	 rax, rax, 1
  000c0	41 b8 03 00 00
	00		 mov	 r8d, 3
  000c6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000ce	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159187
  000d9	e8 00 00 00 00	 call	 strcaseabbrev
  000de	85 c0		 test	 eax, eax
  000e0	74 08		 je	 SHORT $LN12@cf_cmd
  000e2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR on$[rsp], 0
$LN12@cf_cmd:
$LN11@cf_cmd:
$LN9@cf_cmd:

; 173  :     }
; 174  : 
; 175  :     /* Display current settings or change to new settings */
; 176  :     OBTAIN_INTLOCK( NULL );

  000ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159188
  000f1	33 c9		 xor	 ecx, ecx
  000f3	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 177  :     {
; 178  :         if (IS_CPU_ONLINE( sysblk.pcpu ))

  000f8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ff	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00106	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0010d	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00116	0f 84 b5 00 00
	00		 je	 $LN13@cf_cmd

; 179  :         {
; 180  :             if (on < 0) // (no change; just show current setting)

  0011c	83 7c 24 50 00	 cmp	 DWORD PTR on$[rsp], 0
  00121	0f 8d 8c 00 00
	00		 jge	 $LN15@cf_cmd

; 181  :                 // "Processor %s%02X: online"
; 182  :                 WRMSG( HHC00819, "I", PTYPSTR( sysblk.pcpu ), sysblk.pcpu );

  00127	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012e	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00135	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0013c	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0014a	48 89 44 24 58	 mov	 QWORD PTR tv134[rsp], rax
  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00161	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00167	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0016b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv134[rsp]
  00170	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159193
  0017c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159194
  00188	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0018d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00192	41 b9 03 00 00
	00		 mov	 r9d, 3
  00198	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159195
  0019f	ba b6 00 00 00	 mov	 edx, 182		; 000000b6H
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159196
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  001b1	eb 19		 jmp	 SHORT $LN16@cf_cmd
$LN15@cf_cmd:

; 183  :             else if (on == 0) // (change to offline)

  001b3	83 7c 24 50 00	 cmp	 DWORD PTR on$[rsp], 0
  001b8	75 12		 jne	 SHORT $LN17@cf_cmd

; 184  :                 deconfigure_cpu( sysblk.pcpu );

  001ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c1	8b 88 54 13 00
	00		 mov	 ecx, DWORD PTR [rax+4948]
  001c7	e8 00 00 00 00	 call	 deconfigure_cpu
$LN17@cf_cmd:
$LN16@cf_cmd:

; 185  :         }

  001cc	e9 b0 00 00 00	 jmp	 $LN14@cf_cmd
$LN13@cf_cmd:

; 186  :         else // (cpu is currently offline)
; 187  :         {
; 188  :             if (on < 0) // (no change; show current setting)

  001d1	83 7c 24 50 00	 cmp	 DWORD PTR on$[rsp], 0
  001d6	0f 8d 8c 00 00
	00		 jge	 $LN18@cf_cmd

; 189  :                 // "Processor %s%02X: offline"
; 190  :                 WRMSG( HHC00820, "I", PTYPSTR( sysblk.pcpu ), sysblk.pcpu );

  001dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e3	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f1	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001ff	48 89 44 24 60	 mov	 QWORD PTR tv157[rsp], rax
  00204	b9 01 00 00 00	 mov	 ecx, 1
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00216	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  0021c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00220	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv157[rsp]
  00225	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159200
  00231	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159201
  0023d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00242	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00247	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159202
  00254	ba be 00 00 00	 mov	 edx, 190		; 000000beH
  00259	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159203
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00266	eb 19		 jmp	 SHORT $LN19@cf_cmd
$LN18@cf_cmd:

; 191  :             else if (on > 0) // (change to online)

  00268	83 7c 24 50 00	 cmp	 DWORD PTR on$[rsp], 0
  0026d	7e 12		 jle	 SHORT $LN20@cf_cmd

; 192  :                 configure_cpu( sysblk.pcpu );

  0026f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00276	8b 88 54 13 00
	00		 mov	 ecx, DWORD PTR [rax+4948]
  0027c	e8 00 00 00 00	 call	 configure_cpu
$LN20@cf_cmd:
$LN19@cf_cmd:
$LN14@cf_cmd:

; 193  :         }
; 194  :     }
; 195  :     RELEASE_INTLOCK( NULL );

  00281	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159205
  00288	33 c9		 xor	 ecx, ecx
  0028a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 196  : 
; 197  :     /* If settings changed, show results */
; 198  :     if (on >= 0)

  0028f	83 7c 24 50 00	 cmp	 DWORD PTR on$[rsp], 0
  00294	7c 27		 jl	 SHORT $LN21@cf_cmd

; 199  :     {
; 200  :         // (call ourselves again to display current settings)
; 201  :         cf_cmd( 1, argv, argv[0] );

  00296	b8 08 00 00 00	 mov	 eax, 8
  0029b	48 6b c0 00	 imul	 rax, rax, 0
  0029f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002a7	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  002ab	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  002b3	b9 01 00 00 00	 mov	 ecx, 1
  002b8	e8 00 00 00 00	 call	 cf_cmd
$LN21@cf_cmd:

; 202  :     }
; 203  : 
; 204  :     return 0;

  002bd	33 c0		 xor	 eax, eax

; 205  : }

  002bf	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002c3	c3		 ret	 0
cf_cmd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
i$ = 64
rc$ = 68
regs$1 = 72
mask$ = 80
tv133 = 88
argc$ = 112
argv$ = 120
cmdline$ = 128
startall_cmd PROC

; 101  : {

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 102  :     int i;
; 103  :     int rc = 0;

  00012	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@startall_c:

; 104  :     CPU_BITMAP mask;
; 105  : 
; 106  :     UPPER_ARGV_0( argv );

  0001a	48 83 7c 24 78
	00		 cmp	 QWORD PTR argv$[rsp], 0
  00020	74 3e		 je	 SHORT $LN11@startall_c
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	48 6b c0 00	 imul	 rax, rax, 0
  0002b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR argv$[rsp]
  00030	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00035	74 29		 je	 SHORT $LN11@startall_c
  00037	b8 08 00 00 00	 mov	 eax, 8
  0003c	48 6b c0 00	 imul	 rax, rax, 0
  00040	b9 08 00 00 00	 mov	 ecx, 8
  00045	48 6b c9 00	 imul	 rcx, rcx, 0
  00049	48 8b 54 24 78	 mov	 rdx, QWORD PTR argv$[rsp]
  0004e	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  00052	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  00057	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  0005b	e8 00 00 00 00	 call	 strupper
$LN11@startall_c:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 b4		 jne	 SHORT $LN4@startall_c
$LN7@startall_c:

; 107  : 
; 108  :     UNREFERENCED(cmdline);

  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 fa		 jne	 SHORT $LN7@startall_c

; 109  : 
; 110  :     if ( argc == 1 )

  0006c	83 7c 24 70 01	 cmp	 DWORD PTR argc$[rsp], 1
  00071	0f 85 d4 00 00
	00		 jne	 $LN12@startall_c

; 111  :     {
; 112  :         OBTAIN_INTLOCK(NULL);

  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159136
  0007e	33 c9		 xor	 ecx, ecx
  00080	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 113  :         mask = (~sysblk.started_mask) & sysblk.config_mask;

  00085	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008c	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00093	48 f7 d0	 not	 rax
  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009d	48 23 81 a8 12
	00 00		 and	 rax, QWORD PTR [rcx+4776]
  000a4	48 89 44 24 50	 mov	 QWORD PTR mask$[rsp], rax

; 114  :         for (i = 0; mask; i++)

  000a9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b1	eb 0a		 jmp	 SHORT $LN10@startall_c
$LN8@startall_c:
  000b3	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000b7	ff c0		 inc	 eax
  000b9	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN10@startall_c:
  000bd	48 83 7c 24 50
	00		 cmp	 QWORD PTR mask$[rsp], 0
  000c3	74 76		 je	 SHORT $LN9@startall_c

; 115  :         {
; 116  :             if (mask & 1)

  000c5	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$[rsp]
  000ca	48 83 e0 01	 and	 rax, 1
  000ce	48 85 c0	 test	 rax, rax
  000d1	74 56		 je	 SHORT $LN14@startall_c

; 117  :             {
; 118  :                 REGS *regs = sysblk.regs[i];

  000d3	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000df	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000e7	48 89 44 24 48	 mov	 QWORD PTR regs$1[rsp], rax

; 119  :                 regs->opinterv = 0;

  000ec	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$1[rsp]
  000f1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000f7	83 e0 ef	 and	 eax, -17		; ffffffefH
  000fa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$1[rsp]
  000ff	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 120  :                 regs->cpustate = CPUSTATE_STARTED;

  00105	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$1[rsp]
  0010a	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1

; 121  :                 signal_condition(&regs->intcond);

  0010e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$1[rsp]
  00113	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159138
  00120	48 8b c8	 mov	 rcx, rax
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN14@startall_c:

; 122  :             }
; 123  :             mask >>= 1;

  00129	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$[rsp]
  0012e	48 d1 e8	 shr	 rax, 1
  00131	48 89 44 24 50	 mov	 QWORD PTR mask$[rsp], rax

; 124  :         }

  00136	e9 78 ff ff ff	 jmp	 $LN8@startall_c
$LN9@startall_c:

; 125  :         RELEASE_INTLOCK(NULL);

  0013b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159139
  00142	33 c9		 xor	 ecx, ecx
  00144	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 126  :     }

  00149	eb 70		 jmp	 SHORT $LN13@startall_c
$LN12@startall_c:

; 127  :     else
; 128  :     {
; 129  :         WRMSG( HHC02299, "E", argv[0] );

  0014b	b8 08 00 00 00	 mov	 eax, 8
  00150	48 6b c0 00	 imul	 rax, rax, 0
  00154	48 89 44 24 58	 mov	 QWORD PTR tv133[rsp], rax
  00159	b9 01 00 00 00	 mov	 ecx, 1
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00164	48 8b 4c 24 78	 mov	 rcx, QWORD PTR argv$[rsp]
  00169	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv133[rsp]
  0016e	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00172	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159140
  0017e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159141
  0018a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0018f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00194	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159142
  001a1	ba 81 00 00 00	 mov	 edx, 129		; 00000081H
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159143
  001ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 130  :         rc = -1;

  001b3	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN13@startall_c:

; 131  :     }
; 132  :     return rc;

  001bb	8b 44 24 44	 mov	 eax, DWORD PTR rc$[rsp]

; 133  : }

  001bf	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001c3	c3		 ret	 0
startall_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
i$1 = 80
currcpu$ = 84
cpu$ = 88
n$2 = 92
c$ = 96
j$3 = 100
rc$ = 104
tv77 = 112
tv95 = 120
tv156 = 128
cmd$ = 144
__$ArrayPad$ = 400
argc$ = 432
argv$ = 440
cmdline$ = 448
cpu_cmd	PROC

; 29   : {

$LN22:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 30   :     BYTE  c;
; 31   :     int   rc       =  0;

  00028	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 32   :     int   cpu      = -1;

  00030	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR cpu$[rsp], -1

; 33   :     int   currcpu  = sysblk.pcpu;

  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003f	8b 80 54 13 00
	00		 mov	 eax, DWORD PTR [rax+4948]
  00045	89 44 24 54	 mov	 DWORD PTR currcpu$[rsp], eax

; 34   :     char  cmd[256] = {0};

  00049	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR cmd$[rsp]
  00051	48 8b f8	 mov	 rdi, rax
  00054	33 c0		 xor	 eax, eax
  00056	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0005b	f3 aa		 rep stosb

; 35   : 
; 36   :     if (argc < 2)

  0005d	83 bc 24 b0 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00065	0f 8d 2f 01 00
	00		 jge	 $LN14@cpu_cmd

; 37   :     {
; 38   :         if (!IS_CPU_ONLINE( currcpu ))

  0006b	48 63 44 24 54	 movsxd	 rax, DWORD PTR currcpu$[rsp]
  00070	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00077	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00080	0f 85 89 00 00
	00		 jne	 $LN15@cpu_cmd

; 39   :         {
; 40   :             // "Processor %s%02X%s"
; 41   :             WRMSG( HHC02240, "W", PTYPSTR( currcpu ), currcpu,

  00086	48 63 44 24 54	 movsxd	 rax, DWORD PTR currcpu$[rsp]
  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00092	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000a0	48 89 44 24 70	 mov	 QWORD PTR tv77[rsp], rax
  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159090
  000b7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000bc	8b 4c 24 54	 mov	 ecx, DWORD PTR currcpu$[rsp]
  000c0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv77[rsp]
  000c9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159091
  000d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159092
  000e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159093
  000f8	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159094
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 42   :                 " (currently offline)" );
; 43   :         }

  0010a	e9 84 00 00 00	 jmp	 $LN16@cpu_cmd
$LN15@cpu_cmd:

; 44   :         else
; 45   :         {
; 46   :             // "Processor %s%02X%s"
; 47   :             WRMSG( HHC02240, "I", PTYPSTR( currcpu ), currcpu, "" );

  0010f	48 63 44 24 54	 movsxd	 rax, DWORD PTR currcpu$[rsp]
  00114	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0011b	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00129	48 89 44 24 78	 mov	 QWORD PTR tv95[rsp], rax
  0012e	b9 01 00 00 00	 mov	 ecx, 1
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159095
  00140	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00145	8b 4c 24 54	 mov	 ecx, DWORD PTR currcpu$[rsp]
  00149	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0014d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv95[rsp]
  00152	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159096
  0015e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159097
  0016a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00174	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159098
  00181	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159099
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@cpu_cmd:

; 48   :         }
; 49   :         return 0;

  00193	33 c0		 xor	 eax, eax
  00195	e9 24 02 00 00	 jmp	 $LN1@cpu_cmd
$LN14@cpu_cmd:

; 50   :     }
; 51   : 
; 52   :     if (0
; 53   :         || sscanf(argv[1], "%x%c", &cpu, &c) != 1
; 54   :         || cpu < 0
; 55   :         || cpu >= sysblk.maxcpu

  0019a	33 c0		 xor	 eax, eax
  0019c	85 c0		 test	 eax, eax
  0019e	75 4e		 jne	 SHORT $LN18@cpu_cmd
  001a0	b8 08 00 00 00	 mov	 eax, 8
  001a5	48 6b c0 01	 imul	 rax, rax, 1
  001a9	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  001ae	4c 8d 44 24 58	 lea	 r8, QWORD PTR cpu$[rsp]
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159102
  001ba	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001c2	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001c6	e8 00 00 00 00	 call	 sscanf
  001cb	83 f8 01	 cmp	 eax, 1
  001ce	75 1e		 jne	 SHORT $LN18@cpu_cmd
  001d0	83 7c 24 58 00	 cmp	 DWORD PTR cpu$[rsp], 0
  001d5	7c 17		 jl	 SHORT $LN18@cpu_cmd
  001d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001de	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001e4	39 44 24 58	 cmp	 DWORD PTR cpu$[rsp], eax
  001e8	0f 8c 87 00 00
	00		 jl	 $LN17@cpu_cmd
$LN18@cpu_cmd:

; 56   :     )
; 57   :     {
; 58   :         // "Invalid argument %s%s"
; 59   :         WRMSG( HHC02205, "E", argv[1], ": target processor is invalid" );

  001ee	b8 08 00 00 00	 mov	 eax, 8
  001f3	48 6b c0 01	 imul	 rax, rax, 1
  001f7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  001ff	b9 01 00 00 00	 mov	 ecx, 1
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159103
  00211	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00216	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0021e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv156[rsp]
  00226	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0022a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0022f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159104
  00236	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159105
  00242	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00247	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00252	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159106
  00259	ba 3b 00 00 00	 mov	 edx, 59			; 0000003bH
  0025e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159107
  00265	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 60   :         return -1;

  0026b	b8 ff ff ff ff	 mov	 eax, -1
  00270	e9 49 01 00 00	 jmp	 $LN1@cpu_cmd
$LN17@cpu_cmd:

; 61   :     }
; 62   : 
; 63   :     sysblk.dummyregs.cpuad = cpu;

  00275	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0027c	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cpu$[rsp]
  00281	66 89 88 3c 1d
	00 00		 mov	 WORD PTR [rax+7484], cx

; 64   :     sysblk.pcpu = cpu;

  00288	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028f	8b 4c 24 58	 mov	 ecx, DWORD PTR cpu$[rsp]
  00293	89 88 54 13 00
	00		 mov	 DWORD PTR [rax+4948], ecx

; 65   : 
; 66   :     STRLCPY( cmd, cmdline );

  00299	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0029f	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR cmdline$[rsp]
  002a7	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 67   : 
; 68   :     if ( argc > 2 )

  002b5	83 bc 24 b0 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  002bd	0f 8e f7 00 00
	00		 jle	 $LN19@cpu_cmd

; 69   :     {
; 70   :          u_int i = 0;

  002c3	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0

; 71   :          u_int j = 0;

  002cb	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$3[rsp], 0

; 72   :          u_int n = (u_int)strlen(cmd);

  002d3	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  002db	e8 00 00 00 00	 call	 strlen
  002e0	89 44 24 5c	 mov	 DWORD PTR n$2[rsp], eax
  002e4	eb 0a		 jmp	 SHORT $LN4@cpu_cmd
$LN2@cpu_cmd:

; 73   : 
; 74   :          /* Skip leading blanks, if any */
; 75   :          for ( ; i < n && cmd[i] == ' '; i++ );

  002e6	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  002ea	ff c0		 inc	 eax
  002ec	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN4@cpu_cmd:
  002f0	8b 44 24 5c	 mov	 eax, DWORD PTR n$2[rsp]
  002f4	39 44 24 50	 cmp	 DWORD PTR i$1[rsp], eax
  002f8	73 13		 jae	 SHORT $LN3@cpu_cmd
  002fa	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  002fe	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  00306	83 f8 20	 cmp	 eax, 32			; 00000020H
  00309	75 02		 jne	 SHORT $LN3@cpu_cmd
  0030b	eb d9		 jmp	 SHORT $LN2@cpu_cmd
$LN3@cpu_cmd:

; 76   : 
; 77   :          /* Skip two words */
; 78   :          for ( ; j < 2; j++ )

  0030d	eb 0a		 jmp	 SHORT $LN7@cpu_cmd
$LN5@cpu_cmd:
  0030f	8b 44 24 64	 mov	 eax, DWORD PTR j$3[rsp]
  00313	ff c0		 inc	 eax
  00315	89 44 24 64	 mov	 DWORD PTR j$3[rsp], eax
$LN7@cpu_cmd:
  00319	83 7c 24 64 02	 cmp	 DWORD PTR j$3[rsp], 2
  0031e	73 54		 jae	 SHORT $LN6@cpu_cmd
  00320	eb 0a		 jmp	 SHORT $LN10@cpu_cmd
$LN8@cpu_cmd:

; 79   :          {
; 80   :            for ( ; i < n && cmd[i] != ' '; i++ );

  00322	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00326	ff c0		 inc	 eax
  00328	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN10@cpu_cmd:
  0032c	8b 44 24 5c	 mov	 eax, DWORD PTR n$2[rsp]
  00330	39 44 24 50	 cmp	 DWORD PTR i$1[rsp], eax
  00334	73 13		 jae	 SHORT $LN9@cpu_cmd
  00336	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0033a	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  00342	83 f8 20	 cmp	 eax, 32			; 00000020H
  00345	74 02		 je	 SHORT $LN9@cpu_cmd
  00347	eb d9		 jmp	 SHORT $LN8@cpu_cmd
$LN9@cpu_cmd:

; 81   :            for ( ; i < n && cmd[i] == ' '; i++ );

  00349	eb 0a		 jmp	 SHORT $LN13@cpu_cmd
$LN11@cpu_cmd:
  0034b	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0034f	ff c0		 inc	 eax
  00351	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN13@cpu_cmd:
  00355	8b 44 24 5c	 mov	 eax, DWORD PTR n$2[rsp]
  00359	39 44 24 50	 cmp	 DWORD PTR i$1[rsp], eax
  0035d	73 13		 jae	 SHORT $LN12@cpu_cmd
  0035f	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00363	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  0036b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0036e	75 02		 jne	 SHORT $LN12@cpu_cmd
  00370	eb d9		 jmp	 SHORT $LN11@cpu_cmd
$LN12@cpu_cmd:

; 82   :          }

  00372	eb 9b		 jmp	 SHORT $LN5@cpu_cmd
$LN6@cpu_cmd:

; 83   : 
; 84   :          /* Issue command to temporary target cpu */
; 85   :          if (i < n)

  00374	8b 44 24 5c	 mov	 eax, DWORD PTR n$2[rsp]
  00378	39 44 24 50	 cmp	 DWORD PTR i$1[rsp], eax
  0037c	73 3c		 jae	 SHORT $LN20@cpu_cmd

; 86   :          {
; 87   :              rc = HercCmdLine(cmd+i);

  0037e	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00382	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR cmd$[rsp+rax]
  0038a	48 8b c8	 mov	 rcx, rax
  0038d	e8 00 00 00 00	 call	 HercCmdLine
  00392	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 88   :              sysblk.pcpu = currcpu;

  00396	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0039d	8b 4c 24 54	 mov	 ecx, DWORD PTR currcpu$[rsp]
  003a1	89 88 54 13 00
	00		 mov	 DWORD PTR [rax+4948], ecx

; 89   :              sysblk.dummyregs.cpuad = currcpu;

  003a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003ae	0f b7 4c 24 54	 movzx	 ecx, WORD PTR currcpu$[rsp]
  003b3	66 89 88 3c 1d
	00 00		 mov	 WORD PTR [rax+7484], cx
$LN20@cpu_cmd:
$LN19@cpu_cmd:

; 90   :          }
; 91   :     }
; 92   : 
; 93   :     return rc;

  003ba	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cpu_cmd:

; 94   : }

  003be	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c6	48 33 cc	 xor	 rcx, rsp
  003c9	e8 00 00 00 00	 call	 __security_check_cookie
  003ce	48 81 c4 a0 01
	00 00		 add	 rsp, 416		; 000001a0H
  003d5	5f		 pop	 rdi
  003d6	c3		 ret	 0
cpu_cmd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
missing_devnum PROC

; 21   : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 22   :     WRMSG(HHC02201,"E");

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159053
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159054
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159055
  00039	ba 16 00 00 00	 mov	 edx, 22
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159056
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 23   : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
missing_devnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
stop_all_cpus PROC

; 561  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 562  :     OBTAIN_INTLOCK( NULL );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG158979
  0000b	33 c9		 xor	 ecx, ecx
  0000d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 563  :     {
; 564  :         stop_all_cpus_intlock_held();

  00012	e8 00 00 00 00	 call	 stop_all_cpus_intlock_held

; 565  :     }
; 566  :     RELEASE_INTLOCK( NULL );

  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG158980
  0001e	33 c9		 xor	 ecx, ecx
  00020	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 567  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
stop_all_cpus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
cpu$ = 0
are_any_cpus_started_intlock_held PROC

; 501  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 502  :     int cpu;
; 503  : 
; 504  :     if (sysblk.cpus)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00012	74 5b		 je	 SHORT $LN5@are_any_cp

; 505  :         for (cpu = 0; cpu < sysblk.hicpu; cpu++)

  00014	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cpu$[rsp], 0
  0001b	eb 08		 jmp	 SHORT $LN4@are_any_cp
$LN2@are_any_cp:
  0001d	8b 04 24	 mov	 eax, DWORD PTR cpu$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 04 24	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@are_any_cp:
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00032	39 04 24	 cmp	 DWORD PTR cpu$[rsp], eax
  00035	7d 38		 jge	 SHORT $LN3@are_any_cp

; 506  :             if (IS_CPU_ONLINE( cpu ))

  00037	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00042	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0004b	74 20		 je	 SHORT $LN6@are_any_cp

; 507  :                 if (sysblk.regs[ cpu ]->cpustate == CPUSTATE_STARTED)

  0004d	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00058	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00060	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00064	83 f8 01	 cmp	 eax, 1
  00067	75 04		 jne	 SHORT $LN7@are_any_cp

; 508  :                     return true;

  00069	b0 01		 mov	 al, 1
  0006b	eb 04		 jmp	 SHORT $LN1@are_any_cp
$LN7@are_any_cp:
$LN6@are_any_cp:
  0006d	eb ae		 jmp	 SHORT $LN2@are_any_cp
$LN3@are_any_cp:
$LN5@are_any_cp:

; 509  :     return false;

  0006f	32 c0		 xor	 al, al
$LN1@are_any_cp:

; 510  : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
are_any_cpus_started_intlock_held ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
cpu$ = 32
regs$ = 40
mask$ = 48
stop_all_cpus_intlock_held PROC

; 451  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 452  :     CPU_BITMAP  mask;
; 453  :     REGS*       regs;
; 454  :     int         cpu;
; 455  : 
; 456  :     mask = sysblk.started_mask & sysblk.config_mask;

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00012	48 8b 89 a8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4776]
  00019	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00020	48 23 c1	 and	 rax, rcx
  00023	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 457  : 
; 458  :     for (cpu=0; mask; cpu++)

  00028	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00030	eb 0a		 jmp	 SHORT $LN4@stop_all_c
$LN2@stop_all_c:
  00032	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  00036	ff c0		 inc	 eax
  00038	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@stop_all_c:
  0003c	48 83 7c 24 30
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00042	0f 84 90 00 00
	00		 je	 $LN3@stop_all_c

; 459  :     {
; 460  :         if (mask & 1)   // (configured and started?)

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  0004d	48 83 e0 01	 and	 rax, 1
  00051	48 85 c0	 test	 rax, rax
  00054	74 70		 je	 SHORT $LN8@stop_all_c

; 461  :         {
; 462  :             regs = sysblk.regs[ cpu ];

  00056	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00062	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0006a	48 89 44 24 28	 mov	 QWORD PTR regs$[rsp], rax

; 463  :             regs->opinterv = 1;

  0006f	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00074	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0007a	83 c8 10	 or	 eax, 16
  0007d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 464  :             regs->cpustate = CPUSTATE_STOPPING;

  00088	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN7@stop_all_c:

; 465  :             ON_IC_INTERRUPT( regs );

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00096	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00099	0f ba e8 1f	 bts	 eax, 31
  0009d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000a2	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  000a5	33 c0		 xor	 eax, eax
  000a7	85 c0		 test	 eax, eax
  000a9	75 e6		 jne	 SHORT $LN7@stop_all_c

; 466  :             signal_condition( &regs->intcond );

  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG158926
  000bd	48 8b c8	 mov	 rcx, rax
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN8@stop_all_c:

; 467  :         }
; 468  :          mask >>= 1;

  000c6	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  000cb	48 d1 e8	 shr	 rax, 1
  000ce	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 469  :     }

  000d3	e9 5a ff ff ff	 jmp	 $LN2@stop_all_c
$LN3@stop_all_c:

; 470  : }

  000d8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000dc	c3		 ret	 0
stop_all_cpus_intlock_held ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
mask$ = 64
location$ = 72
wakeup_cpus_mask PROC

; 325  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 326  :     int i;
; 327  : 
; 328  :     for (i=0; mask; mask >>= 1, i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0001d	48 d1 e8	 shr	 rax, 1
  00020	48 89 44 24 40	 mov	 QWORD PTR mask$[rsp], rax
  00025	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00035	74 2e		 je	 SHORT $LN3@wakeup_cpu

; 329  :     {
; 330  :         if (mask & 1)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0003c	48 83 e0 01	 and	 rax, 1
  00040	48 85 c0	 test	 rax, rax
  00043	74 1e		 je	 SHORT $LN5@wakeup_cpu

; 331  :             wakeup_cpu( sysblk.regs[i], location );

  00045	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00056	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0005e	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 332  :     }

  00063	eb b3		 jmp	 SHORT $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 333  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
wakeup_cpus_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
tv83 = 80
tv155 = 88
argc$ = 112
argv$ = 120
cmdline$ = 128
restart_cmd PROC

; 601  : {

$LN19:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@restart_cm:

; 602  :     UNREFERENCED(argc);

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@restart_cm
$LN7@restart_cm:

; 603  :     UNREFERENCED(argv);

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN7@restart_cm
$LN10@restart_cm:

; 604  :     UNREFERENCED(cmdline);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN10@restart_cm

; 605  : 
; 606  :     /* Check that target processor type allows IPL */
; 607  :     if (sysblk.ptyp[sysblk.pcpu] == SCCB_PTYP_ZAAP
; 608  :      || sysblk.ptyp[sysblk.pcpu] == SCCB_PTYP_ZIIP)

  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002b	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00039	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  00041	83 f8 02	 cmp	 eax, 2
  00044	74 26		 je	 SHORT $LN15@restart_cm
  00046	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004d	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005b	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  00063	83 f8 05	 cmp	 eax, 5
  00066	0f 85 94 00 00
	00		 jne	 $LN14@restart_cm
$LN15@restart_cm:

; 609  :     {
; 610  :         // "Processor %s%02X: not eligible for ipl nor restart"
; 611  :         WRMSG(HHC00818, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu);

  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00073	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00081	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0008f	48 89 44 24 50	 mov	 QWORD PTR tv83[rsp], rax
  00094	b9 01 00 00 00	 mov	 ecx, 1
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a6	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  000ac	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv83[rsp]
  000b5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159479
  000c1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159480
  000cd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159481
  000e4	ba 63 02 00 00	 mov	 edx, 611		; 00000263H
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159482
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 612  :         return -1;

  000f6	b8 ff ff ff ff	 mov	 eax, -1
  000fb	e9 64 02 00 00	 jmp	 $LN1@restart_cm
$LN14@restart_cm:

; 613  :     }
; 614  : 
; 615  :     // "%s key pressed"
; 616  :     WRMSG(HHC02228, "I", "restart");

  00100	b9 01 00 00 00	 mov	 ecx, 1
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159483
  00112	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159484
  0011e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159485
  0012a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00134	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159486
  00141	ba 68 02 00 00	 mov	 edx, 616		; 00000268H
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159487
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 617  : 
; 618  :     /* Obtain the interrupt lock */
; 619  :     OBTAIN_INTLOCK(NULL);

  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159488
  0015a	33 c9		 xor	 ecx, ecx
  0015c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 620  : 
; 621  :     if (!IS_CPU_ONLINE(sysblk.pcpu))

  00161	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00168	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0016f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00176	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0017f	0f 85 ae 00 00
	00		 jne	 $LN16@restart_cm

; 622  :     {
; 623  :         RELEASE_INTLOCK(NULL);

  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159490
  0018c	33 c9		 xor	 ecx, ecx
  0018e	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 624  :         // "Processor %s%02X: processor is not %s"
; 625  :         WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "online");

  00193	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0019a	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a8	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001b6	48 89 44 24 58	 mov	 QWORD PTR tv155[rsp], rax
  001bb	b9 01 00 00 00	 mov	 ecx, 1
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159491
  001cd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d9	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  001df	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001e3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv155[rsp]
  001e8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159492
  001f4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159493
  00200	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00205	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00210	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159494
  00217	ba 71 02 00 00	 mov	 edx, 625		; 00000271H
  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159495
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 626  :         return +1;

  00229	b8 01 00 00 00	 mov	 eax, 1
  0022e	e9 31 01 00 00	 jmp	 $LN1@restart_cm
$LN16@restart_cm:

; 627  :     }
; 628  : 
; 629  :     /* Consider a restart the same as an ipl */
; 630  :     sysblk.ipled = TRUE;

  00233	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0023a	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00240	83 c8 02	 or	 eax, 2
  00243	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0024a	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN13@restart_cm:

; 631  : 
; 632  :     /* Indicate that a restart interrupt is pending */
; 633  :     ON_IC_RESTART(sysblk.regs[sysblk.pcpu]);

  00250	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00257	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0025e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00265	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0026d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00270	0d 02 00 00 80	 or	 eax, -2147483646	; 80000002H
  00275	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0027c	48 63 89 54 13
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4948]
  00283	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0028a	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00292	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00295	33 c0		 xor	 eax, eax
  00297	85 c0		 test	 eax, eax
  00299	75 b5		 jne	 SHORT $LN13@restart_cm

; 634  : 
; 635  :     /* Ensure that a stopped CPU will recognize the restart */
; 636  :     if (sysblk.regs[sysblk.pcpu]->cpustate == CPUSTATE_STOPPED)

  0029b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002a2	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  002a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002b0	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  002b8	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  002bc	83 f8 03	 cmp	 eax, 3
  002bf	75 21		 jne	 SHORT $LN17@restart_cm

; 637  :         sysblk.regs[sysblk.pcpu]->cpustate = CPUSTATE_STOPPING;

  002c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002c8	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  002cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002d6	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  002de	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN17@restart_cm:

; 638  : 
; 639  :     sysblk.regs[sysblk.pcpu]->checkstop = 0;

  002e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002e9	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  002f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002f7	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  002ff	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00305	83 e0 df	 and	 eax, -33		; ffffffdfH
  00308	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0030f	48 63 89 54 13
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4948]
  00316	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0031d	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00325	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 640  : 
; 641  :     /* Signal CPU that an interrupt is pending */
; 642  :     WAKEUP_CPU (sysblk.regs[sysblk.pcpu]);

  0032b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00332	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00339	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159497
  00340	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00347	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0034f	e8 00 00 00 00	 call	 wakeup_cpu

; 643  : 
; 644  :     /* Release the interrupt lock */
; 645  :     RELEASE_INTLOCK(NULL);

  00354	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159498
  0035b	33 c9		 xor	 ecx, ecx
  0035d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 646  : 
; 647  :     return 0;

  00362	33 c0		 xor	 eax, eax
$LN1@restart_cm:

; 648  : }

  00364	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00368	c3		 ret	 0
restart_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
rc$ = 80
regs$1 = 88
tv129 = 96
tv159 = 104
tv179 = 112
argc$ = 144
argv$ = 152
cmdline$ = 160
stop_cmd_cpu PROC

; 1069 : {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1070 :     int rc = 0;

  00015	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@stop_cmd_c:

; 1071 : 
; 1072 :     UPPER_ARGV_0( argv );

  0001d	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  00026	74 47		 je	 SHORT $LN17@stop_cmd_c
  00028	b8 08 00 00 00	 mov	 eax, 8
  0002d	48 6b c0 00	 imul	 rax, rax, 0
  00031	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00039	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0003e	74 2f		 je	 SHORT $LN17@stop_cmd_c
  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	b9 08 00 00 00	 mov	 ecx, 8
  0004e	48 6b c9 00	 imul	 rcx, rcx, 0
  00052	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0005a	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  0005e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00066	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  0006a	e8 00 00 00 00	 call	 strupper
$LN17@stop_cmd_c:
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 a8		 jne	 SHORT $LN4@stop_cmd_c
$LN7@stop_cmd_c:

; 1073 : 
; 1074 :     UNREFERENCED(argc);

  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 fa		 jne	 SHORT $LN7@stop_cmd_c
$LN10@stop_cmd_c:

; 1075 :     UNREFERENCED(argv);

  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 fa		 jne	 SHORT $LN10@stop_cmd_c
$LN13@stop_cmd_c:

; 1076 :     UNREFERENCED(cmdline);

  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 fa		 jne	 SHORT $LN13@stop_cmd_c

; 1077 : 
; 1078 :     OBTAIN_INTLOCK(NULL);

  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159863
  0008e	33 c9		 xor	 ecx, ecx
  00090	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1079 : 
; 1080 :     if (IS_CPU_ONLINE(sysblk.pcpu))

  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009c	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000aa	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000b3	0f 84 bf 01 00
	00		 je	 $LN18@stop_cmd_c

; 1081 :     {
; 1082 :         REGS *regs = sysblk.regs[sysblk.pcpu];

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c0	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ce	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000d6	48 89 44 24 58	 mov	 QWORD PTR regs$1[rsp], rax

; 1083 :         if ( regs->cpustate != CPUSTATE_STARTED )

  000db	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  000e0	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  000e4	83 f8 01	 cmp	 eax, 1
  000e7	0f 84 a3 00 00
	00		 je	 $LN20@stop_cmd_c

; 1084 :         {
; 1085 :             WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "started");

  000ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f4	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00102	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00110	48 89 44 24 60	 mov	 QWORD PTR tv129[rsp], rax
  00115	b9 01 00 00 00	 mov	 ecx, 1
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159868
  00127	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0012c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00133	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00139	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0013d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv129[rsp]
  00142	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159869
  0014e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159870
  0015a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00164	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159871
  00171	ba 3d 04 00 00	 mov	 edx, 1085		; 0000043dH
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159872
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1086 :             rc = 1;

  00183	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1

; 1087 :         }

  0018b	e9 e3 00 00 00	 jmp	 $LN21@stop_cmd_c
$LN20@stop_cmd_c:

; 1088 :         else
; 1089 :         {
; 1090 :             regs->opinterv = 1;

  00190	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  00195	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019b	83 c8 10	 or	 eax, 16
  0019e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  001a3	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1091 :             regs->cpustate = CPUSTATE_STOPPING;

  001a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  001ae	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN16@stop_cmd_c:

; 1092 :             ON_IC_INTERRUPT(regs);

  001b2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  001b7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001ba	0f ba e8 1f	 bts	 eax, 31
  001be	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  001c3	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  001c6	33 c0		 xor	 eax, eax
  001c8	85 c0		 test	 eax, eax
  001ca	75 e6		 jne	 SHORT $LN16@stop_cmd_c

; 1093 :             WAKEUP_CPU (regs);

  001cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159873
  001d3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  001d8	e8 00 00 00 00	 call	 wakeup_cpu

; 1094 :             WRMSG( HHC00834, "I", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "manual state selected" );

  001dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e4	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001eb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f2	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00200	48 89 44 24 68	 mov	 QWORD PTR tv159[rsp], rax
  00205	b9 01 00 00 00	 mov	 ecx, 1
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159874
  00217	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0021c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00223	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00229	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0022d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv159[rsp]
  00232	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159875
  0023e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159876
  0024a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00254	41 b9 03 00 00
	00		 mov	 r9d, 3
  0025a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159877
  00261	ba 46 04 00 00	 mov	 edx, 1094		; 00000446H
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159878
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@stop_cmd_c:

; 1095 :         }
; 1096 :     }

  00273	e9 9e 00 00 00	 jmp	 $LN19@stop_cmd_c
$LN18@stop_cmd_c:

; 1097 :     else
; 1098 :     {
; 1099 :         WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "online");

  00278	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0027f	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00286	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0028d	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0029b	48 89 44 24 70	 mov	 QWORD PTR tv179[rsp], rax
  002a0	b9 01 00 00 00	 mov	 ecx, 1
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159879
  002b2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002be	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  002c4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002c8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv179[rsp]
  002cd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159880
  002d9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159881
  002e5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ef	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159882
  002fc	ba 4b 04 00 00	 mov	 edx, 1099		; 0000044bH
  00301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159883
  00308	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1100 :         rc = 1;

  0030e	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN19@stop_cmd_c:

; 1101 :     }
; 1102 : 
; 1103 :     RELEASE_INTLOCK(NULL);

  00316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159884
  0031d	33 c9		 xor	 ecx, ecx
  0031f	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1104 : 
; 1105 :     return rc;

  00324	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 1106 : }

  00328	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0032f	c3		 ret	 0
stop_cmd_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
rc$ = 80
regs$1 = 88
tv129 = 96
tv158 = 104
tv178 = 112
argc$ = 144
argv$ = 152
cmdline$ = 160
start_cmd_cpu PROC

; 1024 : {

$LN20:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1025 :     int rc = 0;

  00015	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@start_cmd_:

; 1026 : 
; 1027 :     UPPER_ARGV_0( argv );

  0001d	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  00026	74 47		 je	 SHORT $LN14@start_cmd_
  00028	b8 08 00 00 00	 mov	 eax, 8
  0002d	48 6b c0 00	 imul	 rax, rax, 0
  00031	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00039	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0003e	74 2f		 je	 SHORT $LN14@start_cmd_
  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	b9 08 00 00 00	 mov	 ecx, 8
  0004e	48 6b c9 00	 imul	 rcx, rcx, 0
  00052	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0005a	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  0005e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00066	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  0006a	e8 00 00 00 00	 call	 strupper
$LN14@start_cmd_:
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 a8		 jne	 SHORT $LN4@start_cmd_
$LN7@start_cmd_:

; 1028 : 
; 1029 :     UNREFERENCED(argc);

  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 fa		 jne	 SHORT $LN7@start_cmd_
$LN10@start_cmd_:

; 1030 :     UNREFERENCED(argv);

  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 fa		 jne	 SHORT $LN10@start_cmd_
$LN13@start_cmd_:

; 1031 :     UNREFERENCED(cmdline);

  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 fa		 jne	 SHORT $LN13@start_cmd_

; 1032 : 
; 1033 :     OBTAIN_INTLOCK(NULL);

  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159812
  0008e	33 c9		 xor	 ecx, ecx
  00090	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1034 :     {
; 1035 :         // Start just the target CPU...
; 1036 : 
; 1037 :         if (IS_CPU_ONLINE(sysblk.pcpu))

  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009c	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000aa	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000b3	0f 84 be 01 00
	00		 je	 $LN15@start_cmd_

; 1038 :         {
; 1039 :             REGS *regs = sysblk.regs[sysblk.pcpu];

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c0	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ce	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000d6	48 89 44 24 58	 mov	 QWORD PTR regs$1[rsp], rax

; 1040 :             if ( regs->cpustate == CPUSTATE_STARTED )

  000db	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  000e0	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  000e4	83 f8 01	 cmp	 eax, 1
  000e7	0f 85 a3 00 00
	00		 jne	 $LN17@start_cmd_

; 1041 :             {
; 1042 :                 WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "stopped");

  000ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f4	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00102	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00110	48 89 44 24 60	 mov	 QWORD PTR tv129[rsp], rax
  00115	b9 01 00 00 00	 mov	 ecx, 1
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159817
  00127	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0012c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00133	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00139	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0013d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv129[rsp]
  00142	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159818
  0014e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159819
  0015a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00164	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159820
  00171	ba 12 04 00 00	 mov	 edx, 1042		; 00000412H
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159821
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1043 :                 rc = 1;

  00183	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1

; 1044 :             }

  0018b	e9 e2 00 00 00	 jmp	 $LN18@start_cmd_
$LN17@start_cmd_:

; 1045 :             else
; 1046 :             {
; 1047 :                 regs->opinterv = 0;

  00190	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  00195	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019b	83 e0 ef	 and	 eax, -17		; ffffffefH
  0019e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  001a3	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1048 :                 regs->cpustate = CPUSTATE_STARTED;

  001a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  001ae	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1

; 1049 :                 regs->checkstop = 0;

  001b2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  001b7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001bd	83 e0 df	 and	 eax, -33		; ffffffdfH
  001c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  001c5	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1050 :                 WAKEUP_CPU(regs);

  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159822
  001d2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  001d7	e8 00 00 00 00	 call	 wakeup_cpu

; 1051 :                 WRMSG( HHC00834, "I", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "running state selected" );

  001dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e3	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f1	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001ff	48 89 44 24 68	 mov	 QWORD PTR tv158[rsp], rax
  00204	b9 01 00 00 00	 mov	 ecx, 1
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159823
  00216	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0021b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00222	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00228	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0022c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv158[rsp]
  00231	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159824
  0023d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159825
  00249	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00253	41 b9 03 00 00
	00		 mov	 r9d, 3
  00259	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159826
  00260	ba 1b 04 00 00	 mov	 edx, 1051		; 0000041bH
  00265	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159827
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@start_cmd_:

; 1052 :             }
; 1053 :         }

  00272	e9 9e 00 00 00	 jmp	 $LN16@start_cmd_
$LN15@start_cmd_:

; 1054 :         else
; 1055 :         {
; 1056 :             WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "online");

  00277	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0027e	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00285	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0028c	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00294	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0029a	48 89 44 24 70	 mov	 QWORD PTR tv178[rsp], rax
  0029f	b9 01 00 00 00	 mov	 ecx, 1
  002a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159828
  002b1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002bd	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  002c3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv178[rsp]
  002cc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159829
  002d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159830
  002e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159831
  002fb	ba 20 04 00 00	 mov	 edx, 1056		; 00000420H
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159832
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1057 :             rc = 1;

  0030d	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN16@start_cmd_:

; 1058 :         }
; 1059 :     }
; 1060 :     RELEASE_INTLOCK(NULL);

  00315	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159833
  0031c	33 c9		 xor	 ecx, ecx
  0031e	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1061 : 
; 1062 :     return rc;

  00323	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 1063 : }

  00327	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0032e	c3		 ret	 0
start_cmd_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscpufun.c
_TEXT	SEGMENT
tv77 = 64
argc$ = 96
argv$ = 104
cmdline$ = 112
stopall_cmd PROC

; 140  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@stopall_cm:

; 141  :     UNREFERENCED( cmdline );

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@stopall_cm
$LN7@stopall_cm:

; 142  : 
; 143  :     UPPER_ARGV_0( argv );

  00018	48 83 7c 24 68
	00		 cmp	 QWORD PTR argv$[rsp], 0
  0001e	74 3e		 je	 SHORT $LN8@stopall_cm
  00020	b8 08 00 00 00	 mov	 eax, 8
  00025	48 6b c0 00	 imul	 rax, rax, 0
  00029	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  0002e	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00033	74 29		 je	 SHORT $LN8@stopall_cm
  00035	b8 08 00 00 00	 mov	 eax, 8
  0003a	48 6b c0 00	 imul	 rax, rax, 0
  0003e	b9 08 00 00 00	 mov	 ecx, 8
  00043	48 6b c9 00	 imul	 rcx, rcx, 0
  00047	48 8b 54 24 68	 mov	 rdx, QWORD PTR argv$[rsp]
  0004c	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  00050	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00055	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  00059	e8 00 00 00 00	 call	 strupper
$LN8@stopall_cm:
  0005e	33 c0		 xor	 eax, eax
  00060	85 c0		 test	 eax, eax
  00062	75 b4		 jne	 SHORT $LN7@stopall_cm

; 144  : 
; 145  :     if (argc != 1)

  00064	83 7c 24 60 01	 cmp	 DWORD PTR argc$[rsp], 1
  00069	74 6f		 je	 SHORT $LN9@stopall_cm

; 146  :     {
; 147  :         // "Invalid command usage. Type 'help %s' for assistance."
; 148  :         WRMSG( HHC02299, "E", argv[0] );

  0006b	b8 08 00 00 00	 mov	 eax, 8
  00070	48 6b c0 00	 imul	 rax, rax, 0
  00074	48 89 44 24 40	 mov	 QWORD PTR tv77[rsp], rax
  00079	b9 01 00 00 00	 mov	 ecx, 1
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00089	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv77[rsp]
  0008e	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00092	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159159
  0009e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159160
  000aa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159161
  000c1	ba 94 00 00 00	 mov	 edx, 148		; 00000094H
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159162
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 149  :         return -1;

  000d3	b8 ff ff ff ff	 mov	 eax, -1
  000d8	eb 07		 jmp	 SHORT $LN1@stopall_cm
$LN9@stopall_cm:

; 150  :     }
; 151  : 
; 152  :     stop_all_cpus();

  000da	e8 00 00 00 00	 call	 stop_all_cpus

; 153  :     return 0;

  000df	33 c0		 xor	 eax, eax
$LN1@stopall_cm:

; 154  : }

  000e1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e5	c3		 ret	 0
stopall_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
etod$ = 8
ETOD_high64_to_TOD_high56 PROC

; 213  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 214  :     return (etod << 8);                 /* Adjust bit 59 to bit 51   */

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR etod$[rsp]
  0000a	48 c1 e0 08	 shl	 rax, 8

; 215  : }

  0000e	c3		 ret	 0
ETOD_high64_to_TOD_high56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
ETOD$ = 8
ETOD2TOD PROC

; 205  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 206  :     return ((ETOD.high << 8) | (ETOD.low >> (64-8)));

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0000e	48 c1 e0 08	 shl	 rax, 8
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  0001e	48 0b c1	 or	 rax, rcx

; 207  : }

  00021	c3		 ret	 0
ETOD2TOD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
s$ = 32
r$ = 40
result$ = 64
string$ = 72
strupper PROC

; 157  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 158  :     register char *r = result;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax

; 159  :     register char *s = string;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 160  :     for (; *s; r++, s++)

  00022	eb 1a		 jmp	 SHORT $LN4@strupper
$LN2@strupper:
  00024	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00029	48 ff c0	 inc	 rax
  0002c	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00036	48 ff c0	 inc	 rax
  00039	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN4@strupper:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00043	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00046	85 c0		 test	 eax, eax
  00048	74 16		 je	 SHORT $LN3@strupper

; 161  :     {
; 162  :         *r = asciitoupper(*s);

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0004f	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00052	e8 00 00 00 00	 call	 asciitoupper
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR r$[rsp]
  0005c	88 01		 mov	 BYTE PTR [rcx], al

; 163  :     }

  0005e	eb c4		 jmp	 SHORT $LN2@strupper
$LN3@strupper:

; 164  :     *r = 0;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00065	c6 00 00	 mov	 BYTE PTR [rax], 0

; 165  :     return result;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]

; 166  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
strupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
tv84 = 32
tv73 = 36
tv93 = 40
a$ = 48
s$ = 56
string$ = 80
abbrev$ = 88
n$ = 96
strcaseabbrev PROC

; 91   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 92   :     register const char *s = string;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00018	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 93   :     register const char *a = abbrev;

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 94   :     if (*a &&
; 95   :         *s &&

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 02 01 00
	00		 je	 $LN5@strcaseabb
  00037	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0003c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 f2 00 00
	00		 je	 $LN5@strcaseabb
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0004c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00054	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00057	3b c1		 cmp	 eax, ecx
  00059	74 30		 je	 SHORT $LN6@strcaseabb
  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00060	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00063	e8 00 00 00 00	 call	 asciitoupper
  00068	0f be c0	 movsx	 eax, al
  0006b	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  0006f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00074	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00077	e8 00 00 00 00	 call	 asciitoupper
  0007c	0f be c0	 movsx	 eax, al
  0007f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv73[rsp]
  00083	3b c8		 cmp	 ecx, eax
  00085	0f 85 ae 00 00
	00		 jne	 $LN5@strcaseabb
$LN6@strcaseabb:
$LN2@strcaseabb:

; 96   :         (*a == *s ||
; 97   :         asciitoupper(*a) == asciitoupper(*s)))
; 98   :     {
; 99   :         for (;;)
; 100  :         {
; 101  :             a++;

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 102  :             if (!*a)

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0009d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a0	85 c0		 test	 eax, eax
  000a2	75 31		 jne	 SHORT $LN7@strcaseabb

; 103  :                 return (((uintptr_t)a - (uintptr_t)abbrev) >= n);

  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  000ae	48 2b c8	 sub	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  000b8	48 3b c1	 cmp	 rax, rcx
  000bb	72 0a		 jb	 SHORT $LN12@strcaseabb
  000bd	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  000c5	eb 08		 jmp	 SHORT $LN13@strcaseabb
$LN12@strcaseabb:
  000c7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN13@strcaseabb:
  000cf	8b 44 24 20	 mov	 eax, DWORD PTR tv84[rsp]
  000d3	eb 66		 jmp	 SHORT $LN1@strcaseabb
$LN7@strcaseabb:

; 104  :             s++;

  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000da	48 ff c0	 inc	 rax
  000dd	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 105  :             if (!*s)

  000e2	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000e7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ea	85 c0		 test	 eax, eax
  000ec	75 02		 jne	 SHORT $LN8@strcaseabb

; 106  :                 break;

  000ee	eb 49		 jmp	 SHORT $LN3@strcaseabb
$LN8@strcaseabb:

; 107  :             if (*a == *s)

  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000f5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  000fd	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00100	3b c1		 cmp	 eax, ecx
  00102	75 02		 jne	 SHORT $LN9@strcaseabb

; 108  :                 continue;

  00104	eb 85		 jmp	 SHORT $LN2@strcaseabb
$LN9@strcaseabb:

; 109  :             if (asciitoupper(*a) != asciitoupper(*s))

  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0010b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0010e	e8 00 00 00 00	 call	 asciitoupper
  00113	0f be c0	 movsx	 eax, al
  00116	89 44 24 28	 mov	 DWORD PTR tv93[rsp], eax
  0011a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0011f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00122	e8 00 00 00 00	 call	 asciitoupper
  00127	0f be c0	 movsx	 eax, al
  0012a	8b 4c 24 28	 mov	 ecx, DWORD PTR tv93[rsp]
  0012e	3b c8		 cmp	 ecx, eax
  00130	74 02		 je	 SHORT $LN10@strcaseabb

; 110  :                 break;

  00132	eb 05		 jmp	 SHORT $LN3@strcaseabb
$LN10@strcaseabb:

; 111  :         }

  00134	e9 52 ff ff ff	 jmp	 $LN2@strcaseabb
$LN3@strcaseabb:
$LN5@strcaseabb:

; 112  :     }
; 113  :     return 0;

  00139	33 c0		 xor	 eax, eax
$LN1@strcaseabb:

; 114  : }

  0013b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013f	c3		 ret	 0
strcaseabbrev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
c$ = 8
asciitoupper PROC

; 29   : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 30   :   if (c < 'a' || c > 'z')

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000c	7c 0a		 jl	 SHORT $LN3@asciitoupp
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00016	7e 07		 jle	 SHORT $LN2@asciitoupp
$LN3@asciitoupp:

; 31   :       return c;

  00018	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0001d	eb 08		 jmp	 SHORT $LN1@asciitoupp
$LN2@asciitoupp:

; 32   :   return (c - 32);

  0001f	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 e8 20	 sub	 eax, 32			; 00000020H
$LN1@asciitoupp:

; 33   : }

  00027	c3		 ret	 0
asciitoupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
