; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	num_L1tab
PUBLIC	tracks_copied
PUBLIC	replace
PUBLIC	contigL2
PUBLIC	cckd64
PUBLIC	fba
PUBLIC	quiet
PUBLIC	verbose
PUBLIC	swaps_needed
PUBLIC	trkbuf
PUBLIC	icdevhdr32
PUBLIC	iL1tab32
PUBLIC	iL2tab32
PUBLIC	icdevhdr
PUBLIC	iL1tab
PUBLIC	iL2tab
PUBLIC	ocdevhdr
PUBLIC	oL1tab
PUBLIC	oL2tab
_BSS	SEGMENT
num_L1tab DD	01H DUP (?)
tracks_copied DD 01H DUP (?)
replace	DB	01H DUP (?)
	ALIGN	4

contigL2 DB	01H DUP (?)
	ALIGN	4

cckd64	DB	01H DUP (?)
	ALIGN	4

fba	DB	01H DUP (?)
	ALIGN	4

quiet	DB	01H DUP (?)
	ALIGN	4

verbose	DB	01H DUP (?)
	ALIGN	4

swaps_needed DB	01H DUP (?)
	ALIGN	4

trkbuf	DB	010000H DUP (?)
icdevhdr32 DB	0200H DUP (?)
	ALIGN	8

iL1tab32 DQ	01H DUP (?)
iL2tab32 DQ	01H DUP (?)
icdevhdr DB	0200H DUP (?)
iL1tab	DQ	01H DUP (?)
iL2tab	DQ	01H DUP (?)
ocdevhdr DB	0200H DUP (?)
oL1tab	DQ	01H DUP (?)
oL2tab	DQ	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	main
EXTRN	__imp__errno:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp__commit:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_are_big_endian:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_vsnprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_cckd64_swapend_chdr:PROC
EXTRN	__imp_cckd64_swapend_l1:PROC
EXTRN	__imp_cckd64_swapend_l2:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_dh_devid_str:PROC
EXTRN	__imp_dh_devid_typ:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$syntax DD imagerel syntax
	DD	imagerel syntax+400
	DD	imagerel $unwind$syntax
$pdata$cdevhdr_to_64 DD imagerel cdevhdr_to_64
	DD	imagerel cdevhdr_to_64+229
	DD	imagerel $unwind$cdevhdr_to_64
$pdata$L1tab_to_64 DD imagerel L1tab_to_64
	DD	imagerel L1tab_to_64+133
	DD	imagerel $unwind$L1tab_to_64
$pdata$L2tabs_to_64 DD imagerel L2tabs_to_64
	DD	imagerel L2tabs_to_64+324
	DD	imagerel $unwind$L2tabs_to_64
$pdata$are_swaps_needed DD imagerel are_swaps_needed
	DD	imagerel are_swaps_needed+142
	DD	imagerel $unwind$are_swaps_needed
$pdata$process_L2_tab DD imagerel process_L2_tab
	DD	imagerel process_L2_tab+1333
	DD	imagerel $unwind$process_L2_tab
$pdata$main DD	imagerel $LN138
	DD	imagerel $LN138+9226
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG168687 DB	'E', 00H
	ORG $+6
$SG168688 DB	'HHC02959%s Syntax error: %s', 0aH, 00H
	ORG $+3
$SG168689 DB	'syntax', 00H
	ORG $+1
$SG168690 DB	'convto64.c', 00H
	ORG $+1
$SG168691 DB	'I', 00H
	ORG $+2
$SG168692 DB	'HHC02950%s Usage: %s [-r] [-c] [-q] [-v] infile outfile', 0aH
	DB	'HHC02950I   infile    input file', 0aH, 'HHC02950I   outfile '
	DB	'  output file', 0aH, 'HHC02950I options:', 0aH, 'HHC02950I   '
	DB	'-r     Replace output file', 0aH, 'HHC02950I   -c     Write c'
	DB	'ontiguous L2 tables', 0aH, 'HHC02950I   -q     Minimal progre'
	DB	'ss messages', 0aH, 'HHC02950I   -v     Report every track cop'
	DB	'ied', 0aH, 00H
	ORG $+2
$SG168693 DB	'syntax', 00H
	ORG $+1
$SG168694 DB	'convto64.c', 00H
	ORG $+1
$SG168869 DB	'-q', 00H
	ORG $+1
$SG168863 DB	'Convert compressed ckd to cckd64 format', 00H
$SG168864 DB	'convto64', 00H
	ORG $+3
$SG168874 DB	'-v', 00H
	ORG $+1
$SG168870 DB	'--quiet', 00H
$SG168875 DB	'--verbose', 00H
	ORG $+2
$SG168879 DB	'-r', 00H
	ORG $+1
$SG168880 DB	'--replace', 00H
	ORG $+2
$SG168884 DB	'-c', 00H
	ORG $+1
$SG168885 DB	'--contig', 00H
	ORG $+3
$SG168890 DB	'%s', 00H
	ORG $+1
$SG168886 DB	'unrecognized option: %s', 00H
$SG168889 DB	'missing input-file specification', 00H
	ORG $+3
$SG168896 DB	'%s', 00H
	ORG $+1
$SG168893 DB	'extraneous parameter: %s', 00H
	ORG $+3
$SG168898 DB	'open()', 00H
	ORG $+1
$SG168899 DB	'E', 00H
	ORG $+2
$SG168895 DB	'missing output-file specification', 00H
	ORG $+2
$SG168903 DB	'I', 00H
	ORG $+2
$SG168900 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168901 DB	'main', 00H
	ORG $+3
$SG168902 DB	'convto64.c', 00H
	ORG $+1
$SG168909 DB	'E', 00H
	ORG $+2
$SG168904 DB	'HHC02962%s Converting "%s" to CCKD64 file format...', 0aH
	DB	00H
	ORG $+3
$SG168905 DB	'main', 00H
	ORG $+3
$SG168906 DB	'convto64.c', 00H
	ORG $+1
$SG168908 DB	'read()', 00H
	ORG $+1
$SG168914 DB	'E', 00H
	ORG $+2
$SG168910 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168911 DB	'main', 00H
	ORG $+3
$SG168912 DB	'convto64.c', 00H
	ORG $+5
$SG168915 DB	'HHC02960%s Dasd image file format unsupported or unrecog'
	DB	'nized: %s', 0aH, 00H
	ORG $+1
$SG168916 DB	'main', 00H
	ORG $+3
$SG168921 DB	'open()', 00H
	ORG $+1
$SG168922 DB	'E', 00H
	ORG $+2
$SG168917 DB	'convto64.c', 00H
	ORG $+1
$SG168935 DB	'E', 00H
	ORG $+2
$SG168923 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168924 DB	'main', 00H
	ORG $+3
$SG168925 DB	'convto64.c', 00H
	ORG $+1
$SG168943 DB	'E', 00H
	ORG $+2
$SG168934 DB	'write()', 00H
$SG168936 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168937 DB	'main', 00H
	ORG $+3
$SG168938 DB	'convto64.c', 00H
	ORG $+1
$SG168942 DB	'read()', 00H
	ORG $+1
$SG168949 DB	'E', 00H
	ORG $+2
$SG168944 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168945 DB	'main', 00H
	ORG $+3
$SG168946 DB	'convto64.c', 00H
	ORG $+1
$SG168948 DB	'read()', 00H
	ORG $+1
$SG168956 DB	'E', 00H
	ORG $+2
$SG168950 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168951 DB	'main', 00H
	ORG $+3
$SG168952 DB	'convto64.c', 00H
	ORG $+1
$SG168964 DB	'E', 00H
	ORG $+2
$SG168955 DB	'write()', 00H
$SG168957 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168958 DB	'main', 00H
	ORG $+3
$SG168959 DB	'convto64.c', 00H
	ORG $+1
$SG168970 DB	'E', 00H
	ORG $+2
$SG168961 DB	'TRKS=%d', 0aH, 00H
	ORG $+3
$SG168976 DB	'E', 00H
	ORG $+2
$SG168963 DB	'calloc()', 00H
	ORG $+3
$SG168983 DB	'read()', 00H
	ORG $+1
$SG168984 DB	'E', 00H
	ORG $+2
$SG168965 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168966 DB	'main', 00H
	ORG $+3
$SG168967 DB	'convto64.c', 00H
	ORG $+1
$SG168990 DB	'E', 00H
	ORG $+2
$SG168969 DB	'write()', 00H
$SG168971 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168972 DB	'main', 00H
	ORG $+3
$SG168973 DB	'convto64.c', 00H
	ORG $+1
$SG168996 DB	'E', 00H
	ORG $+2
$SG168975 DB	'calloc()', 00H
	ORG $+3
$SG168995 DB	'read()', 00H
	ORG $+1
$SG169003 DB	'E', 00H
	ORG $+2
$SG168977 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168978 DB	'main', 00H
	ORG $+3
$SG168979 DB	'convto64.c', 00H
	ORG $+1
$SG169009 DB	'E', 00H
	ORG $+2
$SG168985 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168986 DB	'main', 00H
	ORG $+3
$SG168987 DB	'convto64.c', 00H
	ORG $+1
$SG169016 DB	'E', 00H
	ORG $+2
$SG168989 DB	'calloc()', 00H
	ORG $+3
$SG169020 DB	'I', 00H
	ORG $+2
$SG168991 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168992 DB	'main', 00H
	ORG $+3
$SG168993 DB	'convto64.c', 00H
	ORG $+1
$SG169030 DB	'E', 00H
	ORG $+2
$SG168997 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168998 DB	'main', 00H
	ORG $+3
$SG168999 DB	'convto64.c', 00H
	ORG $+1
$SG169038 DB	'E', 00H
	ORG $+2
$SG169002 DB	'malloc()', 00H
	ORG $+3
$SG169037 DB	'read()', 00H
	ORG $+1
$SG169044 DB	'E', 00H
	ORG $+2
$SG169004 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169005 DB	'main', 00H
	ORG $+3
$SG169006 DB	'convto64.c', 00H
	ORG $+1
$SG169052 DB	'E', 00H
	ORG $+2
$SG169008 DB	'malloc()', 00H
	ORG $+3
$SG169043 DB	'read()', 00H
	ORG $+1
$SG169058 DB	'E', 00H
	ORG $+2
$SG169010 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169011 DB	'main', 00H
	ORG $+3
$SG169012 DB	'convto64.c', 00H
	ORG $+1
$SG169062 DB	'I', 00H
	ORG $+2
$SG169015 DB	'malloc()', 00H
	ORG $+3
$SG169071 DB	'E', 00H
	ORG $+2
$SG169017 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169018 DB	'main', 00H
	ORG $+3
$SG169019 DB	'convto64.c', 00H
	ORG $+1
$SG169077 DB	'E', 00H
	ORG $+2
$SG169021 DB	'HHC02951%s Gathering L2 tables...', 0aH, 00H
	ORG $+1
$SG169022 DB	'main', 00H
	ORG $+3
$SG169084 DB	'blocks', 00H
	ORG $+1
$SG169085 DB	'I', 00H
	ORG $+2
$SG169023 DB	'convto64.c', 00H
	ORG $+1
$SG169090 DB	'I', 00H
	ORG $+2
$SG169029 DB	'lseek()', 00H
$SG169031 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169032 DB	'main', 00H
	ORG $+3
$SG169033 DB	'convto64.c', 00H
	ORG $+1
$SG169096 DB	'E', 00H
	ORG $+2
$SG169039 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169040 DB	'main', 00H
	ORG $+3
$SG169041 DB	'convto64.c', 00H
	ORG $+1
$SG169102 DB	'E', 00H
	ORG $+2
$SG169045 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169046 DB	'main', 00H
	ORG $+3
$SG169047 DB	'convto64.c', 00H
	ORG $+1
$SG169109 DB	'E', 00H
	ORG $+2
$SG169051 DB	'lseek()', 00H
$SG169053 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169054 DB	'main', 00H
	ORG $+3
$SG169055 DB	'convto64.c', 00H
	ORG $+1
$SG169124 DB	'E', 00H
	ORG $+2
$SG169057 DB	'write()', 00H
$SG169059 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169060 DB	'main', 00H
	ORG $+3
$SG169061 DB	'convto64.c', 00H
	ORG $+1
$SG169130 DB	'E', 00H
	ORG $+2
$SG169063 DB	'HHC02952%s Copying L2 tables and associated track data..'
	DB	'.', 0aH, 00H
	ORG $+1
$SG169064 DB	'main', 00H
	ORG $+3
$SG169089 DB	'tracks', 00H
	ORG $+1
$SG169143 DB	'I', 00H
	ORG $+2
$SG169065 DB	'convto64.c', 00H
	ORG $+1
$SG169149 DB	'E', 00H
	ORG $+2
$SG169070 DB	'lseek()', 00H
$SG169072 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169073 DB	'main', 00H
	ORG $+3
$SG169074 DB	'convto64.c', 00H
	ORG $+1
$SG169154 DB	'I', 00H
	ORG $+2
$SG169076 DB	'write()', 00H
$SG169078 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169079 DB	'main', 00H
	ORG $+3
$SG169080 DB	'convto64.c', 00H
	ORG $+1
$SG169160 DB	'E', 00H
	ORG $+2
$SG169086 DB	'HHC02953%s Copying %s %d - %d ...', 0aH, 00H
	ORG $+1
$SG169087 DB	'main', 00H
	ORG $+3
$SG169166 DB	'E', 00H
	ORG $+2
$SG169088 DB	'convto64.c', 00H
	ORG $+1
$SG169171 DB	'I', 00H
	ORG $+2
$SG169091 DB	'HHC02953%s Copying %s %d - %d ...', 0aH, 00H
	ORG $+1
$SG169092 DB	'main', 00H
	ORG $+3
$SG169177 DB	'E', 00H
	ORG $+2
$SG169093 DB	'convto64.c', 00H
	ORG $+1
$SG169181 DB	'I', 00H
	ORG $+2
$SG169095 DB	'process_L2_tab()', 00H
	ORG $+3
$SG169217 DB	'blkgrp', 00H
	ORG $+1
$SG169219 DB	'I', 00H
	ORG $+2
$SG169097 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169098 DB	'main', 00H
	ORG $+3
$SG169099 DB	'convto64.c', 00H
	ORG $+1
$SG169225 DB	'E', 00H
	ORG $+2
$SG169101 DB	'lseek()', 00H
$SG169103 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169104 DB	'main', 00H
	ORG $+3
$SG169105 DB	'convto64.c', 00H
	ORG $+1
$SG169231 DB	'E', 00H
	ORG $+2
$SG169108 DB	'lseek()', 00H
$SG169110 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169111 DB	'main', 00H
	ORG $+3
$SG169112 DB	'convto64.c', 00H
	ORG $+1
$SG169114 DB	'main', 00H
	ORG $+3
$SG169218 DB	'track', 00H
	ORG $+2
$SG169230 DB	'read()', 00H
	ORG $+1
$SG169237 DB	'E', 00H
	ORG $+2
$SG169115 DB	'convto64.c', 00H
	ORG $+1
$SG169118 DB	'main', 00H
	ORG $+7
$SG169116 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169119 DB	'convto64.c', 00H
	ORG $+5
$SG169123 DB	'write()', 00H
$SG169120 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169125 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169126 DB	'main', 00H
	ORG $+3
$SG169127 DB	'convto64.c', 00H
	ORG $+1
$SG169243 DB	'E', 00H
	ORG $+2
$SG169129 DB	'lseek()', 00H
$SG169131 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169132 DB	'main', 00H
	ORG $+3
$SG169133 DB	'convto64.c', 00H
	ORG $+1
$SG169135 DB	'main', 00H
	ORG $+7
$SG169136 DB	'convto64.c', 00H
	ORG $+1
$SG169139 DB	'main', 00H
	ORG $+7
$SG169137 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169140 DB	'convto64.c', 00H
	ORG $+5
$SG169144 DB	'HHC02957%s %u tracks copied', 0aH, 00H
	ORG $+3
$SG169145 DB	'main', 00H
	ORG $+3
$SG169141 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169146 DB	'convto64.c', 00H
	ORG $+5
$SG169148 DB	'lseek()', 00H
$SG169150 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169151 DB	'main', 00H
	ORG $+3
$SG169152 DB	'convto64.c', 00H
	ORG $+5
$SG169155 DB	'HHC02954%s Writing cckd64 compressed device header...', 0aH
	DB	00H
	ORG $+1
$SG169156 DB	'main', 00H
	ORG $+3
$SG169157 DB	'convto64.c', 00H
	ORG $+5
$SG169159 DB	'lseek()', 00H
$SG169161 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169162 DB	'main', 00H
	ORG $+3
$SG169163 DB	'convto64.c', 00H
	ORG $+5
$SG169165 DB	'write()', 00H
$SG169167 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169168 DB	'main', 00H
	ORG $+3
$SG169169 DB	'convto64.c', 00H
	ORG $+5
$SG169172 DB	'HHC02955%s Writing L1 table...', 0aH, 00H
$SG169173 DB	'main', 00H
	ORG $+3
$SG169174 DB	'convto64.c', 00H
	ORG $+5
$SG169176 DB	'write()', 00H
$SG169178 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169179 DB	'main', 00H
	ORG $+3
$SG169180 DB	'convto64.c', 00H
	ORG $+5
$SG169182 DB	'HHC02961%s DASD operation completed', 0aH, 00H
	ORG $+3
$SG169183 DB	'main', 00H
	ORG $+3
$SG169184 DB	'convto64.c', 00H
	ORG $+5
$SG169213 DB	'TRK=%d', 0aH, 00H
$SG169220 DB	'HHC02956%s Copying %s %d data...', 0aH, 00H
	ORG $+6
$SG169221 DB	'process_L2_tab', 00H
	ORG $+1
$SG169222 DB	'convto64.c', 00H
	ORG $+5
$SG169224 DB	'lseek()', 00H
$SG169226 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169227 DB	'process_L2_tab', 00H
	ORG $+1
$SG169228 DB	'convto64.c', 00H
	ORG $+5
$SG169232 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169233 DB	'process_L2_tab', 00H
	ORG $+1
$SG169234 DB	'convto64.c', 00H
	ORG $+5
$SG169236 DB	'lseek()', 00H
$SG169238 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169239 DB	'process_L2_tab', 00H
	ORG $+1
$SG169240 DB	'convto64.c', 00H
	ORG $+5
$SG169242 DB	'write()', 00H
$SG169244 DB	'HHC02958%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169245 DB	'process_L2_tab', 00H
	ORG $+1
$SG169246 DB	'convto64.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01cH
	DD	023f0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$syntax DD 011801H
	DD	0c218H
$unwind$cdevhdr_to_64 DD 020301H
	DD	060027003H
$unwind$L1tab_to_64 DD 010401H
	DD	04204H
$unwind$L2tabs_to_64 DD 010401H
	DD	02204H
$unwind$are_swaps_needed DD 010901H
	DD	06209H
$unwind$process_L2_tab DD 021901H
	DD	0150119H
$unwind$main DD	042419H
	DD	0a30112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0500H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\convto64.c
_TEXT	SEGMENT
size$ = 80
i$ = 84
rc$ = 88
ofd$ = 92
size32$ = 96
ifd$ = 100
imgtyp$ = 104
tmppos$ = 112
curpos$ = 120
tv302 = 128
pgm$ = 136
cyls$ = 144
tv502 = 148
tv1087 = 152
tv1090 = 156
tv1104 = 160
tv1106 = 164
tv1131 = 168
ifile$ = 176
tv937 = 184
tv1036 = 192
tv199 = 200
tv228 = 208
ofile$ = 216
tv307 = 224
tv370 = 232
tv391 = 240
tv410 = 248
tv486 = 256
tv551 = 264
tv570 = 272
tv595 = 280
tv648 = 288
tv673 = 296
tv692 = 304
tv722 = 312
tv738 = 320
tv748 = 328
tv764 = 336
tv779 = 344
tv795 = 352
tv865 = 360
tv890 = 368
tv913 = 376
tv942 = 384
tv965 = 392
tv1041 = 400
tv1064 = 408
tv1134 = 416
tv1153 = 424
tv1179 = 432
tv1284 = 440
tv1303 = 448
tv1380 = 456
tv1412 = 464
tv1431 = 472
tv1467 = 480
devhdr$ = 496
pathname$ = 1008
__$ArrayPad$ = 1280
argc$ = 1328
argv$ = 1336
main	PROC

; 223  : {

$LN138:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 18 05
	00 00		 sub	 rsp, 1304		; 00000518H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 224  : char           *pgm;                    /* less any extension (.ext) */
; 225  : char           *ifile, *ofile;          /* -> Input/Output file names*/
; 226  : int             ifd,    ofd;            /* File descriptor integers  */
; 227  : int             i, cyls;                /* Work variables            */
; 228  : int             rc;                     /* Return code               */
; 229  : char            pathname[MAX_PATH];     /* file path in host format  */
; 230  : U32             imgtyp;                 /* Dasd image format         */
; 231  : U32             size32;                 /* Work: CCKD   I/O size     */
; 232  : U32             size;                   /* Work: CCKD64 I/O size     */
; 233  : off_t           curpos;                 /* Work: saved file position */
; 234  : off_t           tmppos;                 /* Work: lseek return code   */
; 235  : 
; 236  : CKD_DEVHDR      devhdr;                 /* Device header             */
; 237  : 
; 238  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00024	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  0002c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00031	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168863
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168864
  0003f	48 8b 94 24 38
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00047	8b 8c 24 30 05
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00054	89 84 24 30 05
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 239  : 
; 240  :     /* Parse options */
; 241  :     for (argc--, argv++ ; argc > 0 ; argc--, argv++)

  0005b	8b 84 24 30 05
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00062	ff c8		 dec	 eax
  00064	89 84 24 30 05
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0006b	48 8b 84 24 38
	05 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00073	48 83 c0 08	 add	 rax, 8
  00077	48 89 84 24 38
	05 00 00	 mov	 QWORD PTR argv$[rsp], rax
  0007f	eb 24		 jmp	 SHORT $LN4@main
$LN2@main:
  00081	8b 84 24 30 05
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00088	ff c8		 dec	 eax
  0008a	89 84 24 30 05
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00091	48 8b 84 24 38
	05 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00099	48 83 c0 08	 add	 rax, 8
  0009d	48 89 84 24 38
	05 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN4@main:
  000a5	83 bc 24 30 05
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  000ad	0f 8e d4 01 00
	00		 jle	 $LN3@main

; 242  :     {
; 243  :         /* End of options? */
; 244  :         if (argv[0][0] != '-')

  000b3	b8 08 00 00 00	 mov	 eax, 8
  000b8	48 6b c0 00	 imul	 rax, rax, 0
  000bc	b9 01 00 00 00	 mov	 ecx, 1
  000c1	48 6b c9 00	 imul	 rcx, rcx, 0
  000c5	48 8b 94 24 38
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000cd	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000d1	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000d5	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000d8	74 05		 je	 SHORT $LN44@main

; 245  :             break;

  000da	e9 a8 01 00 00	 jmp	 $LN3@main
$LN44@main:

; 246  : 
; 247  :         if (0
; 248  :             || strcasecmp( argv[0], "-q"      ) == 0
; 249  :             || strcasecmp( argv[0], "--quiet" ) == 0

  000df	33 c0		 xor	 eax, eax
  000e1	85 c0		 test	 eax, eax
  000e3	75 4c		 jne	 SHORT $LN47@main
  000e5	b8 08 00 00 00	 mov	 eax, 8
  000ea	48 6b c0 00	 imul	 rax, rax, 0
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168869
  000f5	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000fd	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00107	85 c0		 test	 eax, eax
  00109	74 26		 je	 SHORT $LN47@main
  0010b	b8 08 00 00 00	 mov	 eax, 8
  00110	48 6b c0 00	 imul	 rax, rax, 0
  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168870
  0011b	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00123	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0012d	85 c0		 test	 eax, eax
  0012f	75 0c		 jne	 SHORT $LN45@main
$LN47@main:

; 250  :         )
; 251  :         {
; 252  :             quiet = true;       /* Suppress track progress */

  00131	c6 05 00 00 00
	00 01		 mov	 BYTE PTR quiet, 1

; 253  :         }

  00138	e9 45 01 00 00	 jmp	 $LN46@main
$LN45@main:

; 254  :         else if (0
; 255  :             || strcasecmp( argv[0], "-v"        ) == 0
; 256  :             || strcasecmp( argv[0], "--verbose" ) == 0

  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 4c		 jne	 SHORT $LN50@main
  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 00	 imul	 rax, rax, 0
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168874
  00153	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0015b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00165	85 c0		 test	 eax, eax
  00167	74 26		 je	 SHORT $LN50@main
  00169	b8 08 00 00 00	 mov	 eax, 8
  0016e	48 6b c0 00	 imul	 rax, rax, 0
  00172	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168875
  00179	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00181	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0018b	85 c0		 test	 eax, eax
  0018d	75 0c		 jne	 SHORT $LN48@main
$LN50@main:

; 257  :         )
; 258  :         {
; 259  :             verbose = true;     /* report each track's progress */

  0018f	c6 05 00 00 00
	00 01		 mov	 BYTE PTR verbose, 1

; 260  :         }

  00196	e9 e7 00 00 00	 jmp	 $LN49@main
$LN48@main:

; 261  :         else if (0
; 262  :             || strcasecmp( argv[0], "-r"        ) == 0
; 263  :             || strcasecmp( argv[0], "--replace" ) == 0

  0019b	33 c0		 xor	 eax, eax
  0019d	85 c0		 test	 eax, eax
  0019f	75 4c		 jne	 SHORT $LN53@main
  001a1	b8 08 00 00 00	 mov	 eax, 8
  001a6	48 6b c0 00	 imul	 rax, rax, 0
  001aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168879
  001b1	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001b9	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001c3	85 c0		 test	 eax, eax
  001c5	74 26		 je	 SHORT $LN53@main
  001c7	b8 08 00 00 00	 mov	 eax, 8
  001cc	48 6b c0 00	 imul	 rax, rax, 0
  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168880
  001d7	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001df	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001e9	85 c0		 test	 eax, eax
  001eb	75 0c		 jne	 SHORT $LN51@main
$LN53@main:

; 264  :         )
; 265  :         {
; 266  :             replace = true;     /* replace output file */

  001ed	c6 05 00 00 00
	00 01		 mov	 BYTE PTR replace, 1

; 267  :         }

  001f4	e9 89 00 00 00	 jmp	 $LN52@main
$LN51@main:

; 268  :         else if (0
; 269  :             || strcasecmp( argv[0], "-c"       ) == 0
; 270  :             || strcasecmp( argv[0], "--contig" ) == 0

  001f9	33 c0		 xor	 eax, eax
  001fb	85 c0		 test	 eax, eax
  001fd	75 4c		 jne	 SHORT $LN56@main
  001ff	b8 08 00 00 00	 mov	 eax, 8
  00204	48 6b c0 00	 imul	 rax, rax, 0
  00208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168884
  0020f	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00217	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00221	85 c0		 test	 eax, eax
  00223	74 26		 je	 SHORT $LN56@main
  00225	b8 08 00 00 00	 mov	 eax, 8
  0022a	48 6b c0 00	 imul	 rax, rax, 0
  0022e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168885
  00235	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0023d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00247	85 c0		 test	 eax, eax
  00249	75 09		 jne	 SHORT $LN54@main
$LN56@main:

; 271  :         )
; 272  :         {
; 273  :             contigL2 = true;    /* contiguous L2s */

  0024b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR contigL2, 1

; 274  :         }

  00252	eb 2e		 jmp	 SHORT $LN55@main
$LN54@main:

; 275  :         else
; 276  :             return syntax( pgm, "unrecognized option: %s",

  00254	b8 08 00 00 00	 mov	 eax, 8
  00259	48 6b c0 00	 imul	 rax, rax, 0
  0025d	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00265	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  00269	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168886
  00270	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00278	e8 00 00 00 00	 call	 syntax
  0027d	e9 6e 21 00 00	 jmp	 $LN1@main
$LN55@main:
$LN52@main:
$LN49@main:
$LN46@main:

; 277  :                 argv[0] );
; 278  :     }

  00282	e9 fa fd ff ff	 jmp	 $LN2@main
$LN3@main:

; 279  : 
; 280  :     /* Parse arguments */
; 281  :     if (argc < 1)

  00287	83 bc 24 30 05
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0028f	7d 25		 jge	 SHORT $LN57@main

; 282  :         return syntax( pgm, "%s", "missing input-file specification" );

  00291	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168889
  00298	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168890
  0029f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  002a7	e8 00 00 00 00	 call	 syntax
  002ac	e9 3f 21 00 00	 jmp	 $LN1@main
  002b1	e9 9e 00 00 00	 jmp	 $LN58@main
$LN57@main:

; 283  :     else if (argc > 2)

  002b6	83 bc 24 30 05
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  002be	7e 30		 jle	 SHORT $LN59@main

; 284  :         return syntax( pgm, "extraneous parameter: %s", argv[2] );

  002c0	b8 08 00 00 00	 mov	 eax, 8
  002c5	48 6b c0 02	 imul	 rax, rax, 2
  002c9	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002d1	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  002d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168893
  002dc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  002e4	e8 00 00 00 00	 call	 syntax
  002e9	e9 02 21 00 00	 jmp	 $LN1@main
  002ee	eb 64		 jmp	 SHORT $LN60@main
$LN59@main:

; 285  :     else
; 286  :     {
; 287  :         ifile = argv[0];

  002f0	b8 08 00 00 00	 mov	 eax, 8
  002f5	48 6b c0 00	 imul	 rax, rax, 0
  002f9	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00301	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00305	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ifile$[rsp], rax

; 288  :         if (argc < 2)

  0030d	83 bc 24 30 05
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00315	7d 20		 jge	 SHORT $LN61@main

; 289  :             return syntax( pgm, "%s", "missing output-file specification" );

  00317	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168895
  0031e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168896
  00325	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0032d	e8 00 00 00 00	 call	 syntax
  00332	e9 b9 20 00 00	 jmp	 $LN1@main
$LN61@main:

; 290  :         ofile = argv[1];

  00337	b8 08 00 00 00	 mov	 eax, 8
  0033c	48 6b c0 01	 imul	 rax, rax, 1
  00340	48 8b 8c 24 38
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00348	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0034c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR ofile$[rsp], rax
$LN60@main:
$LN58@main:

; 291  :     }
; 292  : 
; 293  :     /* Open input file and verify correct format */
; 294  :     hostpath( pathname, ifile, sizeof( pathname ));

  00354	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0035a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ifile$[rsp]
  00362	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 295  :     if ((ifd = HOPEN( pathname, O_RDONLY | O_BINARY )) < 0)

  00370	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00375	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00383	89 44 24 64	 mov	 DWORD PTR ifd$[rsp], eax
  00387	83 7c 24 64 00	 cmp	 DWORD PTR ifd$[rsp], 0
  0038c	0f 8d 80 00 00
	00		 jge	 $LN62@main

; 296  :     {
; 297  :         // "Error in function %s: %s"
; 298  :         FWRMSG( stderr, HHC02958, "E", "open()", strerror( errno ));

  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00398	8b 08		 mov	 ecx, DWORD PTR [rax]
  0039a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003a0	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv199[rsp], rax
  003a8	b9 02 00 00 00	 mov	 ecx, 2
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv199[rsp]
  003bb	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168898
  003c7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168899
  003d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168900
  003df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168901
  003f6	ba 2a 01 00 00	 mov	 edx, 298		; 0000012aH
  003fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168902
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 299  :         return -1;

  00408	b8 ff ff ff ff	 mov	 eax, -1
  0040d	e9 de 1f 00 00	 jmp	 $LN1@main
$LN62@main:

; 300  :     }
; 301  : 
; 302  :     // "Converting \"%s\" to CCKD64 file format..."
; 303  :     WRMSG( HHC02962, "I", pathname );

  00412	b9 01 00 00 00	 mov	 ecx, 1
  00417	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0041d	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00425	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168903
  00431	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00436	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168904
  0043d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00442	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00447	41 b9 03 00 00
	00		 mov	 r9d, 3
  0044d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168905
  00454	ba 2f 01 00 00	 mov	 edx, 303		; 0000012fH
  00459	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168906
  00460	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 304  : 
; 305  :     /* Read the input file's device header */
; 306  :     size = (U32) sizeof( devhdr );

  00466	c7 44 24 50 00
	02 00 00	 mov	 DWORD PTR size$[rsp], 512 ; 00000200H

; 307  :     if ((rc = read( ifd, &devhdr, size )) < (int) size)

  0046e	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  00473	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  0047b	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  0047f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00485	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  00489	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0048d	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  00491	0f 8d 80 00 00
	00		 jge	 $LN63@main

; 308  :     {
; 309  :         // "Error in function %s: %s"
; 310  :         FWRMSG( stderr, HHC02958, "E", "read()", strerror( errno ));

  00497	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0049d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004a5	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv228[rsp], rax
  004ad	b9 02 00 00 00	 mov	 ecx, 2
  004b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv228[rsp]
  004c0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168908
  004cc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168909
  004d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168910
  004e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  004f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168911
  004fb	ba 36 01 00 00	 mov	 edx, 310		; 00000136H
  00500	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168912
  00507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 311  :         return -1;

  0050d	b8 ff ff ff ff	 mov	 eax, -1
  00512	e9 d9 1e 00 00	 jmp	 $LN1@main
$LN63@main:

; 312  :     }
; 313  : 
; 314  :     /* Input must be a compressed type */
; 315  :     if (!((imgtyp = dh_devid_typ( devhdr.dh_devid )) & ANY_CMP_OR_SF_TYP))

  00517	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_typ
  00525	89 44 24 68	 mov	 DWORD PTR imgtyp$[rsp], eax
  00529	8b 44 24 68	 mov	 eax, DWORD PTR imgtyp$[rsp]
  0052d	25 60 60 60 60	 and	 eax, 1616928864		; 60606060H
  00532	85 c0		 test	 eax, eax
  00534	75 68		 jne	 SHORT $LN64@main

; 316  :     {
; 317  :         // "Dasd image file format unsupported or unrecognized: %s"
; 318  :         FWRMSG( stderr, HHC02960, "E", ifile );

  00536	b9 02 00 00 00	 mov	 ecx, 2
  0053b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00541	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  00549	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0054e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168914
  00555	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168915
  00561	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00566	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00571	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168916
  00578	ba 3e 01 00 00	 mov	 edx, 318		; 0000013eH
  0057d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168917
  00584	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 319  :         return syntax( pgm, NULL );

  0058a	33 d2		 xor	 edx, edx
  0058c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00594	e8 00 00 00 00	 call	 syntax
  00599	e9 52 1e 00 00	 jmp	 $LN1@main
$LN64@main:

; 320  :     }
; 321  : 
; 322  :     /* Remember whether input is CCKD or CCKD64 */
; 323  :     if (imgtyp & ANY64_CMP_OR_SF_TYP)

  0059e	8b 44 24 68	 mov	 eax, DWORD PTR imgtyp$[rsp]
  005a2	25 60 00 60 00	 and	 eax, 6291552		; 00600060H
  005a7	85 c0		 test	 eax, eax
  005a9	74 07		 je	 SHORT $LN65@main

; 324  :         cckd64 = true;

  005ab	c6 05 00 00 00
	00 01		 mov	 BYTE PTR cckd64, 1
$LN65@main:

; 325  : 
; 326  :     /* Remember whether input is FBA or CKD */
; 327  :     if (imgtyp & FBA32_CMP_OR_SF_TYP)

  005b2	8b 44 24 68	 mov	 eax, DWORD PTR imgtyp$[rsp]
  005b6	25 00 60 00 00	 and	 eax, 24576		; 00006000H
  005bb	85 c0		 test	 eax, eax
  005bd	74 07		 je	 SHORT $LN66@main

; 328  :         fba = true;

  005bf	c6 05 00 00 00
	00 01		 mov	 BYTE PTR fba, 1
$LN66@main:

; 329  : 
; 330  :     /* Open ouput file */
; 331  :     hostpath( pathname, ofile, sizeof( pathname ));

  005c6	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  005cc	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR ofile$[rsp]
  005d4	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  005dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 332  :     if ((ofd = HOPEN( pathname,
; 333  :         O_CREAT | O_WRONLY | O_BINARY | (replace ? 0 : O_EXCL),
; 334  :         S_IRUSR | S_IWUSR | S_IRGRP)) < 0)

  005e2	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR replace
  005e9	85 c0		 test	 eax, eax
  005eb	74 0d		 je	 SHORT $LN136@main
  005ed	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv302[rsp], 0
  005f8	eb 0b		 jmp	 SHORT $LN137@main
$LN136@main:
  005fa	c7 84 24 80 00
	00 00 00 04 00
	00		 mov	 DWORD PTR tv302[rsp], 1024 ; 00000400H
$LN137@main:
  00605	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv302[rsp]
  0060c	0d 01 81 00 00	 or	 eax, 33025		; 00008101H
  00611	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00617	8b d0		 mov	 edx, eax
  00619	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00621	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00627	89 44 24 5c	 mov	 DWORD PTR ofd$[rsp], eax
  0062b	83 7c 24 5c 00	 cmp	 DWORD PTR ofd$[rsp], 0
  00630	0f 8d 80 00 00
	00		 jge	 $LN67@main

; 335  :     {
; 336  :         // "Error in function %s: %s"
; 337  :         FWRMSG( stderr, HHC02958, "E", "open()", strerror( errno ));

  00636	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0063c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0063e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00644	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv307[rsp], rax
  0064c	b9 02 00 00 00	 mov	 ecx, 2
  00651	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00657	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv307[rsp]
  0065f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00664	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168921
  0066b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00670	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168922
  00677	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0067c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168923
  00683	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00688	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00693	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168924
  0069a	ba 51 01 00 00	 mov	 edx, 337		; 00000151H
  0069f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168925
  006a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 338  :         return -1;

  006ac	b8 ff ff ff ff	 mov	 eax, -1
  006b1	e9 3a 1d 00 00	 jmp	 $LN1@main
$LN67@main:

; 339  :     }
; 340  : 
; 341  :     /* Convert the output file's device header */
; 342  :     if      (imgtyp & CKD_C370_TYP) memcpy(   devhdr.dh_devid,

  006b6	8b 44 24 68	 mov	 eax, DWORD PTR imgtyp$[rsp]
  006ba	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  006bf	85 c0		 test	 eax, eax
  006c1	74 18		 je	 SHORT $LN68@main
  006c3	b9 00 00 40 00	 mov	 ecx, 4194304		; 00400000H
  006c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_str
  006ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006d1	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR devhdr$[rsp], rax
  006d9	eb 6d		 jmp	 SHORT $LN69@main
$LN68@main:

; 343  :         dh_devid_str( CKD_C064_TYP ), sizeof( devhdr.dh_devid ));
; 344  : 
; 345  :     else if (imgtyp & CKD_S370_TYP) memcpy(   devhdr.dh_devid,

  006db	8b 44 24 68	 mov	 eax, DWORD PTR imgtyp$[rsp]
  006df	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  006e4	85 c0		 test	 eax, eax
  006e6	74 18		 je	 SHORT $LN70@main
  006e8	b9 00 00 20 00	 mov	 ecx, 2097152		; 00200000H
  006ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_str
  006f3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006f6	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR devhdr$[rsp], rax
  006fe	eb 48		 jmp	 SHORT $LN71@main
$LN70@main:

; 346  :         dh_devid_str( CKD_S064_TYP ), sizeof( devhdr.dh_devid ));
; 347  : 
; 348  :     else if (imgtyp & FBA_C370_TYP) memcpy(   devhdr.dh_devid,

  00700	8b 44 24 68	 mov	 eax, DWORD PTR imgtyp$[rsp]
  00704	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00709	85 c0		 test	 eax, eax
  0070b	74 18		 je	 SHORT $LN72@main
  0070d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00712	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_str
  00718	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0071b	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR devhdr$[rsp], rax
  00723	eb 23		 jmp	 SHORT $LN73@main
$LN72@main:

; 349  :         dh_devid_str( FBA_C064_TYP ), sizeof( devhdr.dh_devid ));
; 350  : 
; 351  :     else if (imgtyp & FBA_S370_TYP) memcpy(   devhdr.dh_devid,

  00725	8b 44 24 68	 mov	 eax, DWORD PTR imgtyp$[rsp]
  00729	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0072e	85 c0		 test	 eax, eax
  00730	74 16		 je	 SHORT $LN74@main
  00732	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00737	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_str
  0073d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00740	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR devhdr$[rsp], rax
$LN74@main:
$LN73@main:
$LN71@main:
$LN69@main:

; 352  :         dh_devid_str( FBA_S064_TYP ), sizeof( devhdr.dh_devid ));
; 353  : 
; 354  :     /* Write the output file's device header */
; 355  :     size = (U32) sizeof( devhdr );

  00748	c7 44 24 50 00
	02 00 00	 mov	 DWORD PTR size$[rsp], 512 ; 00000200H

; 356  :     if ((rc = write( ofd, &devhdr, size )) < (int) size)

  00750	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  00755	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  0075d	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  00761	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00767	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  0076b	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0076f	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  00773	0f 8d 80 00 00
	00		 jge	 $LN75@main

; 357  :     {
; 358  :         // "Error in function %s: %s"
; 359  :         FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  00779	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0077f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00781	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00787	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv370[rsp], rax
  0078f	b9 02 00 00 00	 mov	 ecx, 2
  00794	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0079a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv370[rsp]
  007a2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  007a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168934
  007ae	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168935
  007ba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168936
  007c6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d0	41 b9 03 00 00
	00		 mov	 r9d, 3
  007d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168937
  007dd	ba 67 01 00 00	 mov	 edx, 359		; 00000167H
  007e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168938
  007e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 360  :         return -1;

  007ef	b8 ff ff ff ff	 mov	 eax, -1
  007f4	e9 f7 1b 00 00	 jmp	 $LN1@main
$LN75@main:

; 361  :     }
; 362  : 
; 363  :     /* Read the input file's compressed device header */
; 364  :     if (cckd64)

  007f9	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  00800	85 c0		 test	 eax, eax
  00802	0f 84 b5 00 00
	00		 je	 $LN76@main

; 365  :     {
; 366  :         size = (U32) sizeof( icdevhdr );

  00808	c7 44 24 50 00
	02 00 00	 mov	 DWORD PTR size$[rsp], 512 ; 00000200H

; 367  :         if ((rc = read( ifd, &icdevhdr, size )) < (int) size)

  00810	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  00815	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:icdevhdr
  0081c	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  00820	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00826	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  0082a	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0082e	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  00832	0f 8d 80 00 00
	00		 jge	 $LN78@main

; 368  :         {
; 369  :             // "Error in function %s: %s"
; 370  :             FWRMSG( stderr, HHC02958, "E", "read()", strerror( errno ));

  00838	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0083e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00840	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00846	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv391[rsp], rax
  0084e	b9 02 00 00 00	 mov	 ecx, 2
  00853	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00859	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv391[rsp]
  00861	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00866	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168942
  0086d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00872	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168943
  00879	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0087e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168944
  00885	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0088a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0088f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00895	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168945
  0089c	ba 72 01 00 00	 mov	 edx, 370		; 00000172H
  008a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168946
  008a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 371  :             return -1;

  008ae	b8 ff ff ff ff	 mov	 eax, -1
  008b3	e9 38 1b 00 00	 jmp	 $LN1@main
$LN78@main:

; 372  :         }
; 373  :     }

  008b8	e9 b5 00 00 00	 jmp	 $LN77@main
$LN76@main:

; 374  :     else // (32-bit CCKD)
; 375  :     {
; 376  :         size32 = (U32) sizeof( icdevhdr32 );

  008bd	c7 44 24 60 00
	02 00 00	 mov	 DWORD PTR size32$[rsp], 512 ; 00000200H

; 377  :         if ((rc = read( ifd, &icdevhdr32, size32 )) < (int) size32)

  008c5	44 8b 44 24 60	 mov	 r8d, DWORD PTR size32$[rsp]
  008ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:icdevhdr32
  008d1	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  008d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  008db	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  008df	8b 44 24 60	 mov	 eax, DWORD PTR size32$[rsp]
  008e3	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  008e7	0f 8d 80 00 00
	00		 jge	 $LN79@main

; 378  :         {
; 379  :             // "Error in function %s: %s"
; 380  :             FWRMSG( stderr, HHC02958, "E", "read()", strerror( errno ));

  008ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  008f3	8b 08		 mov	 ecx, DWORD PTR [rax]
  008f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  008fb	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv410[rsp], rax
  00903	b9 02 00 00 00	 mov	 ecx, 2
  00908	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0090e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv410[rsp]
  00916	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0091b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168948
  00922	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00927	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168949
  0092e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00933	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168950
  0093a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0093f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00944	41 b9 03 00 00
	00		 mov	 r9d, 3
  0094a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168951
  00951	ba 7c 01 00 00	 mov	 edx, 380		; 0000017cH
  00956	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168952
  0095d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 381  :             return -1;

  00963	b8 ff ff ff ff	 mov	 eax, -1
  00968	e9 83 1a 00 00	 jmp	 $LN1@main
$LN79@main:

; 382  :         }
; 383  : 
; 384  :         /* Convert 32-bit CCKD compressed device header to 64-bit CCKD64 */
; 385  :         cdevhdr_to_64();

  0096d	e8 00 00 00 00	 call	 cdevhdr_to_64
$LN77@main:

; 386  :     }
; 387  : 
; 388  :     /* Determine whether endian swaps are going to be needed or not */
; 389  :     swaps_needed = are_swaps_needed( &icdevhdr );

  00972	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:icdevhdr
  00979	e8 00 00 00 00	 call	 are_swaps_needed
  0097e	88 05 00 00 00
	00		 mov	 BYTE PTR swaps_needed, al
$LN7@main:

; 390  : 
; 391  :     /* Swap input file's compressed device header before processing */
; 392  :     SWAP_CCKD64_DEVHDR( &icdevhdr );

  00984	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  0098b	85 c0		 test	 eax, eax
  0098d	74 0d		 je	 SHORT $LN80@main
  0098f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:icdevhdr
  00996	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_chdr
$LN80@main:
  0099c	33 c0		 xor	 eax, eax
  0099e	85 c0		 test	 eax, eax
  009a0	75 e2		 jne	 SHORT $LN7@main

; 393  : 
; 394  :     /* Copy the input file's compressed device header fields
; 395  :        to the output file's compressed device header fields.
; 396  :     */
; 397  :     memcpy( ocdevhdr.cdh_vrm, icdevhdr.cdh_vrm, sizeof( ocdevhdr.cdh_vrm ));

  009a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ocdevhdr
  009a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:icdevhdr
  009b0	48 8b f8	 mov	 rdi, rax
  009b3	48 8b f1	 mov	 rsi, rcx
  009b6	b9 03 00 00 00	 mov	 ecx, 3
  009bb	f3 a4		 rep movsb

; 398  : 
; 399  :     ocdevhdr.cdh_opts   =  icdevhdr.cdh_opts;

  009bd	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR icdevhdr+3
  009c4	88 05 03 00 00
	00		 mov	 BYTE PTR ocdevhdr+3, al

; 400  :     ocdevhdr.num_L1tab  =  icdevhdr.num_L1tab;

  009ca	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR icdevhdr+4
  009d0	89 05 04 00 00
	00		 mov	 DWORD PTR ocdevhdr+4, eax

; 401  :     ocdevhdr.num_L2tab  =  icdevhdr.num_L2tab;

  009d6	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR icdevhdr+8
  009dc	89 05 08 00 00
	00		 mov	 DWORD PTR ocdevhdr+8, eax

; 402  : 
; 403  :     ocdevhdr.cdh_size = 0;      // (we'll fill this in later)

  009e2	48 c7 05 10 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ocdevhdr+16, 0

; 404  :     ocdevhdr.cdh_used = 0;      // (we'll fill this in later)

  009ed	48 c7 05 18 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ocdevhdr+24, 0

; 405  : 
; 406  :     FETCH_LE_FW( cyls, icdevhdr.cdh_cyls );

  009f8	48 8d 0d 0c 00
	00 00		 lea	 rcx, OFFSET FLAT:icdevhdr+12
  009ff	e8 00 00 00 00	 call	 fetch_fw_noswap
  00a04	8b c8		 mov	 ecx, eax
  00a06	e8 00 00 00 00	 call	 _byteswap_ulong
  00a0b	8b c8		 mov	 ecx, eax
  00a0d	e8 00 00 00 00	 call	 _byteswap_ulong
  00a12	89 84 24 90 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax

; 407  :     STORE_LE_FW( ocdevhdr.cdh_cyls, cyls );

  00a19	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  00a20	e8 00 00 00 00	 call	 _byteswap_ulong
  00a25	8b c8		 mov	 ecx, eax
  00a27	e8 00 00 00 00	 call	 _byteswap_ulong
  00a2c	8b d0		 mov	 edx, eax
  00a2e	48 8d 0d 0c 00
	00 00		 lea	 rcx, OFFSET FLAT:ocdevhdr+12
  00a35	e8 00 00 00 00	 call	 store_fw_noswap

; 408  : 
; 409  :     ocdevhdr.cdh_nullfmt = icdevhdr.cdh_nullfmt;

  00a3a	0f b6 05 48 00
	00 00		 movzx	 eax, BYTE PTR icdevhdr+72
  00a41	88 05 48 00 00
	00		 mov	 BYTE PTR ocdevhdr+72, al

; 410  :     ocdevhdr.cmp_algo    = icdevhdr.cmp_algo;

  00a47	0f b6 05 49 00
	00 00		 movzx	 eax, BYTE PTR icdevhdr+73
  00a4e	88 05 49 00 00
	00		 mov	 BYTE PTR ocdevhdr+73, al

; 411  :     ocdevhdr.cmp_parm    = icdevhdr.cmp_parm;

  00a54	0f b7 05 4a 00
	00 00		 movzx	 eax, WORD PTR icdevhdr+74
  00a5b	66 89 05 4a 00
	00 00		 mov	 WORD PTR ocdevhdr+74, ax

; 412  : 
; 413  :     /* We don't copy free space so all of these will be zero */
; 414  : 
; 415  :     ocdevhdr.free_off     = 0;

  00a62	48 c7 05 20 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ocdevhdr+32, 0

; 416  :     ocdevhdr.free_total   = 0;

  00a6d	48 c7 05 28 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ocdevhdr+40, 0

; 417  :     ocdevhdr.free_largest = 0;

  00a78	48 c7 05 30 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ocdevhdr+48, 0

; 418  :     ocdevhdr.free_num     = 0;

  00a83	48 c7 05 38 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ocdevhdr+56, 0

; 419  :     ocdevhdr.free_imbed   = 0;

  00a8e	48 c7 05 40 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ocdevhdr+64, 0

; 420  : 
; 421  :     /* Write the output file's compressed device header.
; 422  :        We'll fix it up and rewrite it when we're done.
; 423  :     */
; 424  :     size = (U32) sizeof( ocdevhdr );

  00a99	c7 44 24 50 00
	02 00 00	 mov	 DWORD PTR size$[rsp], 512 ; 00000200H

; 425  :     if ((rc = write( ofd, &ocdevhdr, size )) < (int) size)

  00aa1	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  00aa6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ocdevhdr
  00aad	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  00ab1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00ab7	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  00abb	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00abf	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  00ac3	0f 8d 80 00 00
	00		 jge	 $LN81@main

; 426  :     {
; 427  :         // "Error in function %s: %s"
; 428  :         FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  00ac9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00acf	8b 08		 mov	 ecx, DWORD PTR [rax]
  00ad1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ad7	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv486[rsp], rax
  00adf	b9 02 00 00 00	 mov	 ecx, 2
  00ae4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00aea	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv486[rsp]
  00af2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00af7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168955
  00afe	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b03	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168956
  00b0a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168957
  00b16	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b1b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b20	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b26	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168958
  00b2d	ba ac 01 00 00	 mov	 edx, 428		; 000001acH
  00b32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168959
  00b39	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 429  :         return -1;

  00b3f	b8 ff ff ff ff	 mov	 eax, -1
  00b44	e9 a7 18 00 00	 jmp	 $LN1@main
$LN81@main:

; 430  :     }
; 431  : 
; 432  :     /* Save the number of L1 table entries */
; 433  :     num_L1tab = icdevhdr.num_L1tab;

  00b49	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR icdevhdr+4
  00b4f	89 05 00 00 00
	00		 mov	 DWORD PTR num_L1tab, eax
$LN10@main:

; 434  :     EXTGUIMSG( "TRKS=%d\n", num_L1tab * 256 );

  00b55	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00b5c	83 38 00	 cmp	 DWORD PTR [rax], 0
  00b5f	74 36		 je	 SHORT $LN82@main
  00b61	69 05 00 00 00
	00 00 01 00 00	 imul	 eax, DWORD PTR num_L1tab, 256 ; 00000100H
  00b6b	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv502[rsp], eax
  00b72	b9 02 00 00 00	 mov	 ecx, 2
  00b77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b7d	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv502[rsp]
  00b84	44 8b c1	 mov	 r8d, ecx
  00b87	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168961
  00b8e	48 8b c8	 mov	 rcx, rax
  00b91	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN82@main:
  00b97	33 c0		 xor	 eax, eax
  00b99	85 c0		 test	 eax, eax
  00b9b	75 b8		 jne	 SHORT $LN10@main

; 435  : 
; 436  :     /* Allocate room for the output file's L1 table */
; 437  :     size = (U32) (num_L1tab * sizeof( CCKD64_L1ENT ));

  00b9d	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR num_L1tab
  00ba4	48 c1 e0 03	 shl	 rax, 3
  00ba8	89 44 24 50	 mov	 DWORD PTR size$[rsp], eax

; 438  :     if (!(oL1tab = (CCKD64_L1ENT*) calloc( 1, size )))

  00bac	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00bb0	8b d0		 mov	 edx, eax
  00bb2	b9 01 00 00 00	 mov	 ecx, 1
  00bb7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00bbd	48 89 05 00 00
	00 00		 mov	 QWORD PTR oL1tab, rax
  00bc4	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR oL1tab, 0
  00bcc	0f 85 80 00 00
	00		 jne	 $LN83@main

; 439  :     {
; 440  :         // "Error in function %s: %s"
; 441  :         FWRMSG( stderr, HHC02958, "E", "calloc()", strerror( errno ));

  00bd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00bd8	8b 08		 mov	 ecx, DWORD PTR [rax]
  00bda	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00be0	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv551[rsp], rax
  00be8	b9 02 00 00 00	 mov	 ecx, 2
  00bed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bf3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv551[rsp]
  00bfb	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00c00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168963
  00c07	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168964
  00c13	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c18	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168965
  00c1f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c24	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c29	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c2f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168966
  00c36	ba b9 01 00 00	 mov	 edx, 441		; 000001b9H
  00c3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168967
  00c42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 442  :         return -1;

  00c48	b8 ff ff ff ff	 mov	 eax, -1
  00c4d	e9 9e 17 00 00	 jmp	 $LN1@main
$LN83@main:

; 443  :     }
; 444  : 
; 445  :     /* Write out (make room for) the output file's L1 table.
; 446  :        We'll fix it up and rewrite it later when we're done. */
; 447  :     if ((rc = write( ofd, oL1tab, size )) < (int) size )

  00c52	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  00c57	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR oL1tab
  00c5e	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  00c62	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00c68	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  00c6c	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00c70	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  00c74	0f 8d 80 00 00
	00		 jge	 $LN84@main

; 448  :     {
; 449  :         // "Error in function %s: %s"
; 450  :         FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  00c7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00c80	8b 08		 mov	 ecx, DWORD PTR [rax]
  00c82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00c88	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv570[rsp], rax
  00c90	b9 02 00 00 00	 mov	 ecx, 2
  00c95	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c9b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv570[rsp]
  00ca3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00ca8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168969
  00caf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00cb4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168970
  00cbb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168971
  00cc7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ccc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cd1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cd7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168972
  00cde	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  00ce3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168973
  00cea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 451  :         return -1;

  00cf0	b8 ff ff ff ff	 mov	 eax, -1
  00cf5	e9 f6 16 00 00	 jmp	 $LN1@main
$LN84@main:

; 452  :     }
; 453  : 
; 454  :     /* Allocate room for input file's 64-bit L1 table */
; 455  :     size = (U32) (num_L1tab * sizeof( CCKD64_L1ENT ));

  00cfa	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR num_L1tab
  00d01	48 c1 e0 03	 shl	 rax, 3
  00d05	89 44 24 50	 mov	 DWORD PTR size$[rsp], eax

; 456  :     if (!(iL1tab = (CCKD64_L1ENT*) calloc( 1, size )))

  00d09	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00d0d	8b d0		 mov	 edx, eax
  00d0f	b9 01 00 00 00	 mov	 ecx, 1
  00d14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00d1a	48 89 05 00 00
	00 00		 mov	 QWORD PTR iL1tab, rax
  00d21	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR iL1tab, 0
  00d29	0f 85 80 00 00
	00		 jne	 $LN85@main

; 457  :     {
; 458  :         // "Error in function %s: %s"
; 459  :         FWRMSG( stderr, HHC02958, "E", "calloc()", strerror( errno ));

  00d2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d35	8b 08		 mov	 ecx, DWORD PTR [rax]
  00d37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00d3d	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv595[rsp], rax
  00d45	b9 02 00 00 00	 mov	 ecx, 2
  00d4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d50	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv595[rsp]
  00d58	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00d5d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168975
  00d64	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d69	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168976
  00d70	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168977
  00d7c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d81	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d86	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d8c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168978
  00d93	ba cb 01 00 00	 mov	 edx, 459		; 000001cbH
  00d98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168979
  00d9f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 460  :         return -1;

  00da5	b8 ff ff ff ff	 mov	 eax, -1
  00daa	e9 41 16 00 00	 jmp	 $LN1@main
$LN85@main:

; 461  :     }
; 462  : 
; 463  :     /* Read the input file's L1 table */
; 464  :     if (cckd64)

  00daf	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  00db6	85 c0		 test	 eax, eax
  00db8	0f 84 ad 00 00
	00		 je	 $LN86@main

; 465  :     {
; 466  :         if ((rc = read( ifd, iL1tab, size )) < (int) size)

  00dbe	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  00dc3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR iL1tab
  00dca	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  00dce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00dd4	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  00dd8	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00ddc	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  00de0	0f 8d 80 00 00
	00		 jge	 $LN88@main

; 467  :         {
; 468  :             // "Error in function %s: %s"
; 469  :             FWRMSG( stderr, HHC02958, "E", "read()", strerror( errno ));

  00de6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00dec	8b 08		 mov	 ecx, DWORD PTR [rax]
  00dee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00df4	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv648[rsp], rax
  00dfc	b9 02 00 00 00	 mov	 ecx, 2
  00e01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e07	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv648[rsp]
  00e0f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00e14	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168983
  00e1b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e20	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168984
  00e27	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168985
  00e33	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e38	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e3d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e43	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168986
  00e4a	ba d5 01 00 00	 mov	 edx, 469		; 000001d5H
  00e4f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168987
  00e56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 470  :             return -1;

  00e5c	b8 ff ff ff ff	 mov	 eax, -1
  00e61	e9 8a 15 00 00	 jmp	 $LN1@main
$LN88@main:

; 471  :         }
; 472  :     }

  00e66	e9 7a 01 00 00	 jmp	 $LN87@main
$LN86@main:

; 473  :     else // (32-bit CCKD)
; 474  :     {
; 475  :         /* Allocate room for input file's 32-bit L1 table */
; 476  :         size32 = (U32) (num_L1tab * sizeof( CCKD_L1ENT ));

  00e6b	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR num_L1tab
  00e72	48 c1 e0 02	 shl	 rax, 2
  00e76	89 44 24 60	 mov	 DWORD PTR size32$[rsp], eax

; 477  :         if (!(iL1tab32 = (CCKD_L1ENT*) calloc( 1, size32 )))

  00e7a	8b 44 24 60	 mov	 eax, DWORD PTR size32$[rsp]
  00e7e	8b d0		 mov	 edx, eax
  00e80	b9 01 00 00 00	 mov	 ecx, 1
  00e85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00e8b	48 89 05 00 00
	00 00		 mov	 QWORD PTR iL1tab32, rax
  00e92	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR iL1tab32, 0
  00e9a	0f 85 80 00 00
	00		 jne	 $LN89@main

; 478  :         {
; 479  :             // "Error in function %s: %s"
; 480  :             FWRMSG( stderr, HHC02958, "E", "calloc()", strerror( errno ));

  00ea0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00ea6	8b 08		 mov	 ecx, DWORD PTR [rax]
  00ea8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00eae	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv673[rsp], rax
  00eb6	b9 02 00 00 00	 mov	 ecx, 2
  00ebb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ec1	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv673[rsp]
  00ec9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00ece	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168989
  00ed5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00eda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168990
  00ee1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ee6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168991
  00eed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ef2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ef7	41 b9 03 00 00
	00		 mov	 r9d, 3
  00efd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168992
  00f04	ba e0 01 00 00	 mov	 edx, 480		; 000001e0H
  00f09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168993
  00f10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 481  :             return -1;

  00f16	b8 ff ff ff ff	 mov	 eax, -1
  00f1b	e9 d0 14 00 00	 jmp	 $LN1@main
$LN89@main:

; 482  :         }
; 483  : 
; 484  :         /* Read the input file's 32-bit L1 table */
; 485  :         if ((rc = read( ifd, iL1tab32, size32 )) < (int) size32)

  00f20	44 8b 44 24 60	 mov	 r8d, DWORD PTR size32$[rsp]
  00f25	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR iL1tab32
  00f2c	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  00f30	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00f36	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  00f3a	8b 44 24 60	 mov	 eax, DWORD PTR size32$[rsp]
  00f3e	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  00f42	0f 8d 80 00 00
	00		 jge	 $LN90@main

; 486  :         {
; 487  :             // "Error in function %s: %s"
; 488  :             FWRMSG( stderr, HHC02958, "E", "read()", strerror( errno ));

  00f48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00f4e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00f50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00f56	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv692[rsp], rax
  00f5e	b9 02 00 00 00	 mov	 ecx, 2
  00f63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f69	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv692[rsp]
  00f71	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00f76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168995
  00f7d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f82	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168996
  00f89	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f8e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168997
  00f95	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f9a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f9f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fa5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168998
  00fac	ba e8 01 00 00	 mov	 edx, 488		; 000001e8H
  00fb1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168999
  00fb8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 489  :             return -1;

  00fbe	b8 ff ff ff ff	 mov	 eax, -1
  00fc3	e9 28 14 00 00	 jmp	 $LN1@main
$LN90@main:

; 490  :         }
; 491  : 
; 492  :         /* Convert the input file's 32-bit L1 table to 64-bit L1 table */
; 493  :         L1tab_to_64();

  00fc8	e8 00 00 00 00	 call	 L1tab_to_64

; 494  :         free( iL1tab32 );

  00fcd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL1tab32
  00fd4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 495  :         iL1tab32 = NULL;

  00fda	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR iL1tab32, 0
$LN87@main:
$LN13@main:

; 496  :     }
; 497  : 
; 498  :     /* Swap the input file's L1 table before processing it */
; 499  :     SWAP_CCKD64_L1TAB( iL1tab );

  00fe5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  00fec	85 c0		 test	 eax, eax
  00fee	74 13		 je	 SHORT $LN91@main
  00ff0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR num_L1tab
  00ff6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL1tab
  00ffd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_l1
$LN91@main:
  01003	33 c0		 xor	 eax, eax
  01005	85 c0		 test	 eax, eax
  01007	75 dc		 jne	 SHORT $LN13@main

; 500  : 
; 501  :     /* Allocate storage for the input and output file's L2 tables */
; 502  :     size = (U32) (num_L1tab * (256 * sizeof( CCKD64_L2ENT )));

  01009	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR num_L1tab
  01010	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  01017	89 44 24 50	 mov	 DWORD PTR size$[rsp], eax

; 503  :     if (!(iL2tab = (CCKD64_L2ENT*) malloc( size )))

  0101b	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0101f	8b c8		 mov	 ecx, eax
  01021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01027	48 89 05 00 00
	00 00		 mov	 QWORD PTR iL2tab, rax
  0102e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR iL2tab, 0
  01036	0f 85 80 00 00
	00		 jne	 $LN92@main

; 504  :     {
; 505  :         // "Error in function %s: %s"
; 506  :         FWRMSG( stderr, HHC02958, "E", "malloc()", strerror( errno ));

  0103c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01042	8b 08		 mov	 ecx, DWORD PTR [rax]
  01044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0104a	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv722[rsp], rax
  01052	b9 02 00 00 00	 mov	 ecx, 2
  01057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0105d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv722[rsp]
  01065	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0106a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169002
  01071	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169003
  0107d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169004
  01089	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0108e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01093	41 b9 03 00 00
	00		 mov	 r9d, 3
  01099	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169005
  010a0	ba fa 01 00 00	 mov	 edx, 506		; 000001faH
  010a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169006
  010ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 507  :         return -1;

  010b2	b8 ff ff ff ff	 mov	 eax, -1
  010b7	e9 34 13 00 00	 jmp	 $LN1@main
$LN92@main:

; 508  :     }
; 509  :     memset( iL2tab, 0xFF, size );

  010bc	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  010c0	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv738[rsp], rax
  010c8	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR iL2tab
  010cf	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  010d4	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv738[rsp]
  010dc	f3 aa		 rep stosb

; 510  :     if (!(oL2tab = (CCKD64_L2ENT*) malloc( size )))

  010de	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  010e2	8b c8		 mov	 ecx, eax
  010e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  010ea	48 89 05 00 00
	00 00		 mov	 QWORD PTR oL2tab, rax
  010f1	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR oL2tab, 0
  010f9	0f 85 80 00 00
	00		 jne	 $LN93@main

; 511  :     {
; 512  :         // "Error in function %s: %s"
; 513  :         FWRMSG( stderr, HHC02958, "E", "malloc()", strerror( errno ));

  010ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01105	8b 08		 mov	 ecx, DWORD PTR [rax]
  01107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0110d	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv748[rsp], rax
  01115	b9 02 00 00 00	 mov	 ecx, 2
  0111a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01120	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv748[rsp]
  01128	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0112d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169008
  01134	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169009
  01140	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169010
  0114c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01151	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01156	41 b9 03 00 00
	00		 mov	 r9d, 3
  0115c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169011
  01163	ba 01 02 00 00	 mov	 edx, 513		; 00000201H
  01168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169012
  0116f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 514  :         return -1;

  01175	b8 ff ff ff ff	 mov	 eax, -1
  0117a	e9 71 12 00 00	 jmp	 $LN1@main
$LN93@main:

; 515  :     }
; 516  :     memset( oL2tab, 0xFF, size );

  0117f	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  01183	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv764[rsp], rax
  0118b	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR oL2tab
  01192	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  01197	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv764[rsp]
  0119f	f3 aa		 rep stosb

; 517  :     if (!cckd64)

  011a1	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  011a8	85 c0		 test	 eax, eax
  011aa	0f 85 d5 00 00
	00		 jne	 $LN94@main

; 518  :     {
; 519  :         size32 = (U32) (num_L1tab * (256 * sizeof( CCKD_L2ENT )));

  011b0	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR num_L1tab
  011b7	48 69 c0 00 08
	00 00		 imul	 rax, rax, 2048		; 00000800H
  011be	89 44 24 60	 mov	 DWORD PTR size32$[rsp], eax

; 520  :         if (!(iL2tab32 = (CCKD_L2ENT*) malloc( size32 )))

  011c2	8b 44 24 60	 mov	 eax, DWORD PTR size32$[rsp]
  011c6	8b c8		 mov	 ecx, eax
  011c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  011ce	48 89 05 00 00
	00 00		 mov	 QWORD PTR iL2tab32, rax
  011d5	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR iL2tab32, 0
  011dd	0f 85 80 00 00
	00		 jne	 $LN95@main

; 521  :         {
; 522  :             // "Error in function %s: %s"
; 523  :             FWRMSG( stderr, HHC02958, "E", "malloc()", strerror( errno ));

  011e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  011e9	8b 08		 mov	 ecx, DWORD PTR [rax]
  011eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  011f1	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv779[rsp], rax
  011f9	b9 02 00 00 00	 mov	 ecx, 2
  011fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01204	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv779[rsp]
  0120c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169015
  01218	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0121d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169016
  01224	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169017
  01230	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01235	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0123a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01240	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169018
  01247	ba 0b 02 00 00	 mov	 edx, 523		; 0000020bH
  0124c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169019
  01253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 524  :             return -1;

  01259	b8 ff ff ff ff	 mov	 eax, -1
  0125e	e9 8d 11 00 00	 jmp	 $LN1@main
$LN95@main:

; 525  :         }
; 526  :         memset( iL2tab32, 0xFF, size32 );

  01263	8b 44 24 60	 mov	 eax, DWORD PTR size32$[rsp]
  01267	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv795[rsp], rax
  0126f	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR iL2tab32
  01276	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0127b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv795[rsp]
  01283	f3 aa		 rep stosb
$LN94@main:

; 527  :     }
; 528  : 
; 529  :     // "Gathering L2 tables..."
; 530  :     WRMSG( HHC02951, "I" );

  01285	b9 01 00 00 00	 mov	 ecx, 1
  0128a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169020
  01297	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0129c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169021
  012a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  012b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169022
  012ba	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  012bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169023
  012c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 531  : 
; 532  :     /* Read in all of the input file's L2 tables */
; 533  :     if (cckd64)

  012cc	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  012d3	85 c0		 test	 eax, eax
  012d5	74 0a		 je	 SHORT $LN96@main

; 534  :         size   = (U32) (256 * sizeof( CCKD64_L2ENT ));  // (i/p L2 table size)

  012d7	c7 44 24 50 00
	10 00 00	 mov	 DWORD PTR size$[rsp], 4096 ; 00001000H
  012df	eb 08		 jmp	 SHORT $LN97@main
$LN96@main:

; 535  :     else
; 536  :         size32 = (U32) (256 * sizeof( CCKD_L2ENT   ));  // (i/p L2 table size)

  012e1	c7 44 24 60 00
	08 00 00	 mov	 DWORD PTR size32$[rsp], 2048 ; 00000800H
$LN97@main:

; 537  :     for (i=0; i < num_L1tab; i++)

  012e9	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  012f1	eb 0a		 jmp	 SHORT $LN16@main
$LN14@main:
  012f3	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  012f7	ff c0		 inc	 eax
  012f9	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN16@main:
  012fd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_L1tab
  01303	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  01307	0f 8d 91 02 00
	00		 jge	 $LN15@main

; 538  :     {
; 539  :         /* Skip non-existent L2 tables */
; 540  :         if (iL1tab[i] == 0)

  0130d	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  01312	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL1tab
  01319	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0131e	75 16		 jne	 SHORT $LN98@main

; 541  :         {
; 542  :             oL1tab[i] = 0;

  01320	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  01325	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL1tab
  0132c	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 543  :             continue;

  01334	eb bd		 jmp	 SHORT $LN14@main
$LN98@main:

; 544  :         }
; 545  :         if (iL1tab[i] == ULLONG_MAX)

  01336	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0133b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL1tab
  01342	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  01347	75 16		 jne	 SHORT $LN99@main

; 546  :         {
; 547  :             oL1tab[i] = ULLONG_MAX;

  01349	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0134e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL1tab
  01355	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1

; 548  :             continue;

  0135d	eb 94		 jmp	 SHORT $LN14@main
$LN99@main:

; 549  :         }
; 550  :         if ((tmppos = lseek( ifd, iL1tab[i], SEEK_SET )) < 0)

  0135f	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  01364	45 33 c0	 xor	 r8d, r8d
  01367	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL1tab
  0136e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  01372	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  01376	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  0137c	48 89 44 24 70	 mov	 QWORD PTR tmppos$[rsp], rax
  01381	48 83 7c 24 70
	00		 cmp	 QWORD PTR tmppos$[rsp], 0
  01387	0f 8d 80 00 00
	00		 jge	 $LN100@main

; 551  :         {
; 552  :             // "Error in function %s: %s"
; 553  :             FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  0138d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01393	8b 08		 mov	 ecx, DWORD PTR [rax]
  01395	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0139b	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv865[rsp], rax
  013a3	b9 02 00 00 00	 mov	 ecx, 2
  013a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013ae	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv865[rsp]
  013b6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  013bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169029
  013c2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  013c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169030
  013ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169031
  013da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  013ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169032
  013f1	ba 29 02 00 00	 mov	 edx, 553		; 00000229H
  013f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169033
  013fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 554  :             return -1;

  01403	b8 ff ff ff ff	 mov	 eax, -1
  01408	e9 e3 0f 00 00	 jmp	 $LN1@main
$LN100@main:

; 555  :         }
; 556  :         if (cckd64)

  0140d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  01414	85 c0		 test	 eax, eax
  01416	0f 84 c4 00 00
	00		 je	 $LN101@main

; 557  :         {
; 558  :             if ((rc = read( ifd, &iL2tab[i*256], size )) < (int) size)

  0141c	69 44 24 54 00
	01 00 00	 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  01424	48 98		 cdqe
  01426	48 6b c0 10	 imul	 rax, rax, 16
  0142a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL2tab
  01431	48 03 c8	 add	 rcx, rax
  01434	48 8b c1	 mov	 rax, rcx
  01437	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  0143c	48 8b d0	 mov	 rdx, rax
  0143f	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  01443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  01449	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  0144d	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  01451	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  01455	0f 8d 80 00 00
	00		 jge	 $LN103@main

; 559  :             {
; 560  :                 // "Error in function %s: %s"
; 561  :                 FWRMSG( stderr, HHC02958, "E", "read()", strerror( errno ));

  0145b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01461	8b 08		 mov	 ecx, DWORD PTR [rax]
  01463	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01469	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv890[rsp], rax
  01471	b9 02 00 00 00	 mov	 ecx, 2
  01476	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0147c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv890[rsp]
  01484	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01489	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169037
  01490	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01495	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169038
  0149c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169039
  014a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  014b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169040
  014bf	ba 31 02 00 00	 mov	 edx, 561		; 00000231H
  014c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169041
  014cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 562  :                 return -1;

  014d1	b8 ff ff ff ff	 mov	 eax, -1
  014d6	e9 15 0f 00 00	 jmp	 $LN1@main
$LN103@main:

; 563  :             }
; 564  :         }

  014db	e9 b9 00 00 00	 jmp	 $LN102@main
$LN101@main:

; 565  :         else // (32-bit CCKD)
; 566  :         {
; 567  :             if ((rc = read( ifd, &iL2tab32[i*256], size32 )) < (int) size32)

  014e0	69 44 24 54 00
	01 00 00	 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  014e8	48 98		 cdqe
  014ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL2tab32
  014f1	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  014f5	44 8b 44 24 60	 mov	 r8d, DWORD PTR size32$[rsp]
  014fa	48 8b d0	 mov	 rdx, rax
  014fd	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  01501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  01507	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  0150b	8b 44 24 60	 mov	 eax, DWORD PTR size32$[rsp]
  0150f	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  01513	0f 8d 80 00 00
	00		 jge	 $LN104@main

; 568  :             {
; 569  :                 // "Error in function %s: %s"
; 570  :                 FWRMSG( stderr, HHC02958, "E", "read()", strerror( errno ));

  01519	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0151f	8b 08		 mov	 ecx, DWORD PTR [rax]
  01521	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01527	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv913[rsp], rax
  0152f	b9 02 00 00 00	 mov	 ecx, 2
  01534	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0153a	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv913[rsp]
  01542	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01547	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169043
  0154e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01553	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169044
  0155a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0155f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169045
  01566	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0156b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01570	41 b9 03 00 00
	00		 mov	 r9d, 3
  01576	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169046
  0157d	ba 3a 02 00 00	 mov	 edx, 570		; 0000023aH
  01582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169047
  01589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 571  :                 return -1;

  0158f	b8 ff ff ff ff	 mov	 eax, -1
  01594	e9 57 0e 00 00	 jmp	 $LN1@main
$LN104@main:
$LN102@main:

; 572  :             }
; 573  :         }
; 574  :     }

  01599	e9 55 fd ff ff	 jmp	 $LN14@main
$LN15@main:

; 575  : 
; 576  :     /* Convert 32-bit L2 tables to 64-bit CCKD64 */
; 577  :     if (!cckd64)

  0159e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  015a5	85 c0		 test	 eax, eax
  015a7	75 1d		 jne	 SHORT $LN105@main

; 578  :     {
; 579  :         L2tabs_to_64();

  015a9	e8 00 00 00 00	 call	 L2tabs_to_64

; 580  :         free( iL2tab32 );

  015ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL2tab32
  015b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 581  :         iL2tab32 = NULL;

  015bb	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR iL2tab32, 0
$LN105@main:

; 582  :     }
; 583  : 
; 584  :     /* Set output size = size of 64-bit CCKD64 L2 table */
; 585  :     size = (U32) (256 * sizeof( CCKD64_L2ENT ));

  015c6	c7 44 24 50 00
	10 00 00	 mov	 DWORD PTR size$[rsp], 4096 ; 00001000H

; 586  : 
; 587  :     if (contigL2)

  015ce	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR contigL2
  015d5	85 c0		 test	 eax, eax
  015d7	0f 84 a9 01 00
	00		 je	 $LN106@main

; 588  :     {
; 589  :         /* Write out all L2 tables to the output file (even empty ones).
; 590  :            We'll rewrite them all with their correct values later, once
; 591  :            their track data has been copied in our loop further below.
; 592  :            This ensures that none of the L2 tables will ever need to be
; 593  :            created or relocated since: 1) they'll always already exist,
; 594  :            and 2) they'll always exist in their preferred file location
; 595  :            (i.e. immediately following the L1 table).
; 596  :         */
; 597  :         for (i=0; i < num_L1tab; ++i)

  015dd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  015e5	eb 0a		 jmp	 SHORT $LN19@main
$LN17@main:
  015e7	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  015eb	ff c0		 inc	 eax
  015ed	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN19@main:
  015f1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_L1tab
  015f7	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  015fb	0f 8d 85 01 00
	00		 jge	 $LN18@main

; 598  :         {
; 599  :             if ((off_t)(oL1tab[i] = lseek( ofd, 0, SEEK_CUR )) < 0)

  01601	41 b8 01 00 00
	00		 mov	 r8d, 1
  01607	33 d2		 xor	 edx, edx
  01609	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  0160d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01613	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv937[rsp], rax
  0161b	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  01620	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL1tab
  01627	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv937[rsp]
  0162f	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  01633	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR tv937[rsp], 0
  0163c	0f 8d 80 00 00
	00		 jge	 $LN107@main

; 600  :             {
; 601  :                 // "Error in function %s: %s"
; 602  :                 FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  01642	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01648	8b 08		 mov	 ecx, DWORD PTR [rax]
  0164a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01650	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv942[rsp], rax
  01658	b9 02 00 00 00	 mov	 ecx, 2
  0165d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01663	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv942[rsp]
  0166b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01670	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169051
  01677	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0167c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169052
  01683	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01688	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169053
  0168f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01694	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01699	41 b9 03 00 00
	00		 mov	 r9d, 3
  0169f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169054
  016a6	ba 5a 02 00 00	 mov	 edx, 602		; 0000025aH
  016ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169055
  016b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 603  :                 return -1;

  016b8	b8 ff ff ff ff	 mov	 eax, -1
  016bd	e9 2e 0d 00 00	 jmp	 $LN1@main
$LN107@main:

; 604  :             }
; 605  :             if ((rc = write( ofd, &oL2tab[i*256], size )) < (int) size )

  016c2	69 44 24 54 00
	01 00 00	 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  016ca	48 98		 cdqe
  016cc	48 6b c0 10	 imul	 rax, rax, 16
  016d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL2tab
  016d7	48 03 c8	 add	 rcx, rax
  016da	48 8b c1	 mov	 rax, rcx
  016dd	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  016e2	48 8b d0	 mov	 rdx, rax
  016e5	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  016e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  016ef	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  016f3	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  016f7	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  016fb	0f 8d 80 00 00
	00		 jge	 $LN108@main

; 606  :             {
; 607  :                 // "Error in function %s: %s"
; 608  :                 FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  01701	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01707	8b 08		 mov	 ecx, DWORD PTR [rax]
  01709	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0170f	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv965[rsp], rax
  01717	b9 02 00 00 00	 mov	 ecx, 2
  0171c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01722	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv965[rsp]
  0172a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0172f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169057
  01736	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0173b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169058
  01742	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01747	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169059
  0174e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01753	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01758	41 b9 03 00 00
	00		 mov	 r9d, 3
  0175e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169060
  01765	ba 60 02 00 00	 mov	 edx, 608		; 00000260H
  0176a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169061
  01771	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 609  :                 return -1;

  01777	b8 ff ff ff ff	 mov	 eax, -1
  0177c	e9 6f 0c 00 00	 jmp	 $LN1@main
$LN108@main:

; 610  :             }
; 611  :         }

  01781	e9 61 fe ff ff	 jmp	 $LN17@main
$LN18@main:
$LN106@main:

; 612  :     }
; 613  : 
; 614  :     // "Copying L2 tables and associated track data..."
; 615  :     WRMSG( HHC02952, "I" );

  01786	b9 01 00 00 00	 mov	 ecx, 1
  0178b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01791	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169062
  01798	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0179d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169063
  017a4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  017a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017ae	41 b9 03 00 00
	00		 mov	 r9d, 3
  017b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169064
  017bb	ba 67 02 00 00	 mov	 edx, 615		; 00000267H
  017c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169065
  017c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 616  : 
; 617  :     /* Process all of the L2 tables... */
; 618  :     for (i=0; i < num_L1tab; i++)

  017cd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  017d5	eb 0a		 jmp	 SHORT $LN22@main
$LN20@main:
  017d7	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  017db	ff c0		 inc	 eax
  017dd	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN22@main:
  017e1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_L1tab
  017e7	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  017eb	0f 8d c3 07 00
	00		 jge	 $LN21@main

; 619  :     {
; 620  :         if (!contigL2)

  017f1	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR contigL2
  017f8	85 c0		 test	 eax, eax
  017fa	0f 85 ae 01 00
	00		 jne	 $LN109@main

; 621  :         {
; 622  :             if (0
; 623  :                 || iL1tab[i] == 0
; 624  :                 || iL1tab[i] == ULLONG_MAX

  01800	33 c0		 xor	 eax, eax
  01802	85 c0		 test	 eax, eax
  01804	75 26		 jne	 SHORT $LN111@main
  01806	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0180b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL1tab
  01812	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  01817	74 13		 je	 SHORT $LN111@main
  01819	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0181e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL1tab
  01825	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  0182a	75 02		 jne	 SHORT $LN110@main
$LN111@main:

; 625  :             )
; 626  :                 continue;   /* (skip L2 tables that don't exist) */

  0182c	eb a9		 jmp	 SHORT $LN20@main
$LN110@main:

; 627  : 
; 628  :             /* Make room for this L2 table in the output file.
; 629  :                We'll re-write it with the correct values after
; 630  :                it's been processed.
; 631  :             */
; 632  :             if ((off_t)(oL1tab[i] = lseek( ofd, 0, SEEK_CUR )) < 0)

  0182e	41 b8 01 00 00
	00		 mov	 r8d, 1
  01834	33 d2		 xor	 edx, edx
  01836	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  0183a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01840	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv1036[rsp], rax
  01848	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0184d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL1tab
  01854	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv1036[rsp]
  0185c	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  01860	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR tv1036[rsp], 0
  01869	0f 8d 80 00 00
	00		 jge	 $LN112@main

; 633  :             {
; 634  :                 // "Error in function %s: %s"
; 635  :                 FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  0186f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01875	8b 08		 mov	 ecx, DWORD PTR [rax]
  01877	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0187d	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv1041[rsp], rax
  01885	b9 02 00 00 00	 mov	 ecx, 2
  0188a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01890	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv1041[rsp]
  01898	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0189d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169070
  018a4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  018a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169071
  018b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  018b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169072
  018bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  018c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  018cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169073
  018d3	ba 7b 02 00 00	 mov	 edx, 635		; 0000027bH
  018d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169074
  018df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 636  :                 return -1;

  018e5	b8 ff ff ff ff	 mov	 eax, -1
  018ea	e9 01 0b 00 00	 jmp	 $LN1@main
$LN112@main:

; 637  :             }
; 638  :             if ((rc = write( ofd, &oL2tab[i*256], size )) < (int) size )

  018ef	69 44 24 54 00
	01 00 00	 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  018f7	48 98		 cdqe
  018f9	48 6b c0 10	 imul	 rax, rax, 16
  018fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL2tab
  01904	48 03 c8	 add	 rcx, rax
  01907	48 8b c1	 mov	 rax, rcx
  0190a	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  0190f	48 8b d0	 mov	 rdx, rax
  01912	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  01916	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0191c	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  01920	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  01924	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  01928	0f 8d 80 00 00
	00		 jge	 $LN113@main

; 639  :             {
; 640  :                 // "Error in function %s: %s"
; 641  :                 FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  0192e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01934	8b 08		 mov	 ecx, DWORD PTR [rax]
  01936	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0193c	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv1064[rsp], rax
  01944	b9 02 00 00 00	 mov	 ecx, 2
  01949	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0194f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv1064[rsp]
  01957	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0195c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169076
  01963	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01968	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169077
  0196f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01974	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169078
  0197b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01980	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01985	41 b9 03 00 00
	00		 mov	 r9d, 3
  0198b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169079
  01992	ba 81 02 00 00	 mov	 edx, 641		; 00000281H
  01997	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169080
  0199e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 642  :                 return -1;

  019a4	b8 ff ff ff ff	 mov	 eax, -1
  019a9	e9 42 0a 00 00	 jmp	 $LN1@main
$LN113@main:
$LN109@main:

; 643  :             }
; 644  :         }
; 645  : 
; 646  :         /* Report progress... */
; 647  :         if (!quiet && !verbose) // (!verbose since verbose reports each track)

  019ae	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR quiet
  019b5	85 c0		 test	 eax, eax
  019b7	0f 85 43 01 00
	00		 jne	 $LN114@main
  019bd	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR verbose
  019c4	85 c0		 test	 eax, eax
  019c6	0f 85 34 01 00
	00		 jne	 $LN114@main

; 648  :         {
; 649  :             if (fba)

  019cc	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  019d3	85 c0		 test	 eax, eax
  019d5	0f 84 98 00 00
	00		 je	 $LN115@main

; 650  :                 // "Copying %s %d - %d ..."
; 651  :                 WRMSG( HHC02953, "I", "blocks",

  019db	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  019df	ff c0		 inc	 eax
  019e1	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  019e7	6b c0 78	 imul	 eax, eax, 120		; 00000078H
  019ea	ff c8		 dec	 eax
  019ec	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv1087[rsp], eax
  019f3	69 4c 24 54 00
	01 00 00	 imul	 ecx, DWORD PTR i$[rsp], 256 ; 00000100H
  019fb	6b c9 78	 imul	 ecx, ecx, 120		; 00000078H
  019fe	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv1090[rsp], ecx
  01a05	b9 01 00 00 00	 mov	 ecx, 1
  01a0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a10	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv1087[rsp]
  01a17	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01a1b	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv1090[rsp]
  01a22	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01a26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169084
  01a2d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01a32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169085
  01a39	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01a3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169086
  01a45	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01a4a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01a4f	41 b9 03 00 00
	00		 mov	 r9d, 3
  01a55	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169087
  01a5c	ba 8d 02 00 00	 mov	 edx, 653		; 0000028dH
  01a61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169088
  01a68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01a6e	e9 8d 00 00 00	 jmp	 $LN116@main
$LN115@main:

; 652  :                     (CFBA_BLKS_PER_GRP * ( i    * 256)),
; 653  :                     (CFBA_BLKS_PER_GRP * ((i+1) * 256)) - 1 );
; 654  :             else
; 655  :                 // "Copying %s %d - %d ..."
; 656  :                 WRMSG( HHC02953, "I", "tracks", (i*256), ((i+1)*256) - 1 );

  01a73	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  01a77	ff c0		 inc	 eax
  01a79	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  01a7f	ff c8		 dec	 eax
  01a81	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv1104[rsp], eax
  01a88	69 4c 24 54 00
	01 00 00	 imul	 ecx, DWORD PTR i$[rsp], 256 ; 00000100H
  01a90	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv1106[rsp], ecx
  01a97	b9 01 00 00 00	 mov	 ecx, 1
  01a9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01aa2	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv1104[rsp]
  01aa9	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01aad	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv1106[rsp]
  01ab4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01ab8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169089
  01abf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01ac4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169090
  01acb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01ad0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169091
  01ad7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01adc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ae1	41 b9 03 00 00
	00		 mov	 r9d, 3
  01ae7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169092
  01aee	ba 90 02 00 00	 mov	 edx, 656		; 00000290H
  01af3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169093
  01afa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN116@main:
$LN114@main:

; 657  :         }
; 658  : 
; 659  :         /* Copy all of this L2 table's track data... */
; 660  :         if (process_L2_tab( i*256, ifd, &iL2tab[i*256], ofd, &oL2tab[i*256] ) < 0)

  01b00	69 44 24 54 00
	01 00 00	 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  01b08	48 98		 cdqe
  01b0a	48 6b c0 10	 imul	 rax, rax, 16
  01b0e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL2tab
  01b15	48 03 c8	 add	 rcx, rax
  01b18	48 8b c1	 mov	 rax, rcx
  01b1b	69 4c 24 54 00
	01 00 00	 imul	 ecx, DWORD PTR i$[rsp], 256 ; 00000100H
  01b23	48 63 c9	 movsxd	 rcx, ecx
  01b26	48 6b c9 10	 imul	 rcx, rcx, 16
  01b2a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR iL2tab
  01b31	48 03 d1	 add	 rdx, rcx
  01b34	48 8b ca	 mov	 rcx, rdx
  01b37	69 54 24 54 00
	01 00 00	 imul	 edx, DWORD PTR i$[rsp], 256 ; 00000100H
  01b3f	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv1131[rsp], edx
  01b46	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b4b	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR ofd$[rsp]
  01b50	4c 8b c1	 mov	 r8, rcx
  01b53	8b 54 24 64	 mov	 edx, DWORD PTR ifd$[rsp]
  01b57	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv1131[rsp]
  01b5e	8b c8		 mov	 ecx, eax
  01b60	e8 00 00 00 00	 call	 process_L2_tab
  01b65	85 c0		 test	 eax, eax
  01b67	0f 8d 80 00 00
	00		 jge	 $LN117@main

; 661  :         {
; 662  :             // "Error in function %s: %s"
; 663  :             FWRMSG( stderr, HHC02958, "E", "process_L2_tab()", strerror( errno ));

  01b6d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01b73	8b 08		 mov	 ecx, DWORD PTR [rax]
  01b75	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01b7b	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv1134[rsp], rax
  01b83	b9 02 00 00 00	 mov	 ecx, 2
  01b88	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b8e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv1134[rsp]
  01b96	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01b9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169095
  01ba2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01ba7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169096
  01bae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01bb3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169097
  01bba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01bbf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bc4	41 b9 03 00 00
	00		 mov	 r9d, 3
  01bca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169098
  01bd1	ba 97 02 00 00	 mov	 edx, 663		; 00000297H
  01bd6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169099
  01bdd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 664  :             return -1;

  01be3	b8 ff ff ff ff	 mov	 eax, -1
  01be8	e9 03 08 00 00	 jmp	 $LN1@main
$LN117@main:

; 665  :         }
; 666  : 
; 667  :         /* Save the current output file position */
; 668  :         if ((curpos = lseek( ofd, 0, SEEK_CUR )) < 0)

  01bed	41 b8 01 00 00
	00		 mov	 r8d, 1
  01bf3	33 d2		 xor	 edx, edx
  01bf5	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  01bf9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01bff	48 89 44 24 78	 mov	 QWORD PTR curpos$[rsp], rax
  01c04	48 83 7c 24 78
	00		 cmp	 QWORD PTR curpos$[rsp], 0
  01c0a	0f 8d 80 00 00
	00		 jge	 $LN118@main

; 669  :         {
; 670  :             // "Error in function %s: %s"
; 671  :             FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  01c10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01c16	8b 08		 mov	 ecx, DWORD PTR [rax]
  01c18	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01c1e	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv1153[rsp], rax
  01c26	b9 02 00 00 00	 mov	 ecx, 2
  01c2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01c31	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv1153[rsp]
  01c39	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01c3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169101
  01c45	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01c4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169102
  01c51	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01c56	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169103
  01c5d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c62	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c67	41 b9 03 00 00
	00		 mov	 r9d, 3
  01c6d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169104
  01c74	ba 9f 02 00 00	 mov	 edx, 671		; 0000029fH
  01c79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169105
  01c80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 672  :             return -1;

  01c86	b8 ff ff ff ff	 mov	 eax, -1
  01c8b	e9 60 07 00 00	 jmp	 $LN1@main
$LN118@main:
$LN25@main:

; 673  :         }
; 674  : 
; 675  :         /* Swap the output L2 table before writing it out */
; 676  :         SWAP_CCKD64_L2TAB( oL2tab );

  01c90	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  01c97	85 c0		 test	 eax, eax
  01c99	74 0d		 je	 SHORT $LN119@main
  01c9b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL2tab
  01ca2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_l2
$LN119@main:
  01ca8	33 c0		 xor	 eax, eax
  01caa	85 c0		 test	 eax, eax
  01cac	75 e2		 jne	 SHORT $LN25@main

; 677  : 
; 678  :         /* Re-write output file's L2 table with now accurate values */
; 679  :         if ((tmppos = lseek( ofd, oL1tab[i], SEEK_SET )) < 0)

  01cae	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  01cb3	45 33 c0	 xor	 r8d, r8d
  01cb6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL1tab
  01cbd	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  01cc1	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  01cc5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01ccb	48 89 44 24 70	 mov	 QWORD PTR tmppos$[rsp], rax
  01cd0	48 83 7c 24 70
	00		 cmp	 QWORD PTR tmppos$[rsp], 0
  01cd6	0f 8d 80 00 00
	00		 jge	 $LN120@main

; 680  :         {
; 681  :             // "Error in function %s: %s"
; 682  :             FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  01cdc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01ce2	8b 08		 mov	 ecx, DWORD PTR [rax]
  01ce4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01cea	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv1179[rsp], rax
  01cf2	b9 02 00 00 00	 mov	 ecx, 2
  01cf7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01cfd	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv1179[rsp]
  01d05	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01d0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169108
  01d11	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01d16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169109
  01d1d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01d22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169110
  01d29	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01d2e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d33	41 b9 03 00 00
	00		 mov	 r9d, 3
  01d39	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169111
  01d40	ba aa 02 00 00	 mov	 edx, 682		; 000002aaH
  01d45	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169112
  01d4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 683  :             return -1;

  01d52	b8 ff ff ff ff	 mov	 eax, -1
  01d57	e9 94 06 00 00	 jmp	 $LN1@main
$LN120@main:
$LN28@main:

; 684  :         }
; 685  :         ASSERT( tmppos == oL1tab[i] );

  01d5c	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  01d61	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL1tab
  01d68	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01d6c	48 39 44 24 70	 cmp	 QWORD PTR tmppos$[rsp], rax
  01d71	74 5c		 je	 SHORT $LN121@main
$LN31@main:
  01d73	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169114
  01d7a	41 b8 ad 02 00
	00		 mov	 r8d, 685		; 000002adH
  01d80	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169115
  01d87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169116
  01d8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01d94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01d9a	85 c0		 test	 eax, eax
  01d9c	74 20		 je	 SHORT $LN122@main
  01d9e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169118
  01da5	41 b8 ad 02 00
	00		 mov	 r8d, 685		; 000002adH
  01dab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169119
  01db2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169120
  01db9	e8 00 00 00 00	 call	 DebuggerTrace
$LN122@main:
  01dbe	33 c0		 xor	 eax, eax
  01dc0	85 c0		 test	 eax, eax
  01dc2	75 af		 jne	 SHORT $LN31@main
  01dc4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01dca	85 c0		 test	 eax, eax
  01dcc	74 01		 je	 SHORT $LN123@main
  01dce	cc		 int	 3
$LN123@main:
$LN121@main:
  01dcf	33 c0		 xor	 eax, eax
  01dd1	85 c0		 test	 eax, eax
  01dd3	75 87		 jne	 SHORT $LN28@main

; 686  :         if ((rc = write( ofd, &oL2tab[i*256], size )) < (int) size )

  01dd5	69 44 24 54 00
	01 00 00	 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  01ddd	48 98		 cdqe
  01ddf	48 6b c0 10	 imul	 rax, rax, 16
  01de3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL2tab
  01dea	48 03 c8	 add	 rcx, rax
  01ded	48 8b c1	 mov	 rax, rcx
  01df0	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  01df5	48 8b d0	 mov	 rdx, rax
  01df8	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  01dfc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  01e02	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  01e06	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  01e0a	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  01e0e	0f 8d 80 00 00
	00		 jge	 $LN124@main

; 687  :         {
; 688  :             // "Error in function %s: %s"
; 689  :             FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  01e14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01e1a	8b 08		 mov	 ecx, DWORD PTR [rax]
  01e1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01e22	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv1284[rsp], rax
  01e2a	b9 02 00 00 00	 mov	 ecx, 2
  01e2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01e35	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv1284[rsp]
  01e3d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01e42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169123
  01e49	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01e4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169124
  01e55	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169125
  01e61	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e66	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e6b	41 b9 03 00 00
	00		 mov	 r9d, 3
  01e71	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169126
  01e78	ba b1 02 00 00	 mov	 edx, 689		; 000002b1H
  01e7d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169127
  01e84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 690  :             return -1;

  01e8a	b8 ff ff ff ff	 mov	 eax, -1
  01e8f	e9 5c 05 00 00	 jmp	 $LN1@main
$LN124@main:

; 691  :         }
; 692  : 
; 693  :         /* Restore output file position back to where it was */
; 694  :         if ((tmppos = lseek( ofd, curpos, SEEK_SET )) < 0)

  01e94	45 33 c0	 xor	 r8d, r8d
  01e97	48 8b 54 24 78	 mov	 rdx, QWORD PTR curpos$[rsp]
  01e9c	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  01ea0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01ea6	48 89 44 24 70	 mov	 QWORD PTR tmppos$[rsp], rax
  01eab	48 83 7c 24 70
	00		 cmp	 QWORD PTR tmppos$[rsp], 0
  01eb1	0f 8d 80 00 00
	00		 jge	 $LN125@main

; 695  :         {
; 696  :             // "Error in function %s: %s"
; 697  :             FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  01eb7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01ebd	8b 08		 mov	 ecx, DWORD PTR [rax]
  01ebf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01ec5	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1303[rsp], rax
  01ecd	b9 02 00 00 00	 mov	 ecx, 2
  01ed2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01ed8	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv1303[rsp]
  01ee0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01ee5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169129
  01eec	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01ef1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169130
  01ef8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01efd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169131
  01f04	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01f09	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01f0e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01f14	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169132
  01f1b	ba b9 02 00 00	 mov	 edx, 697		; 000002b9H
  01f20	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169133
  01f27	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 698  :             return -1;

  01f2d	b8 ff ff ff ff	 mov	 eax, -1
  01f32	e9 b9 04 00 00	 jmp	 $LN1@main
$LN125@main:
$LN34@main:

; 699  :         }
; 700  :         ASSERT( tmppos == curpos );

  01f37	48 8b 44 24 78	 mov	 rax, QWORD PTR curpos$[rsp]
  01f3c	48 39 44 24 70	 cmp	 QWORD PTR tmppos$[rsp], rax
  01f41	74 5c		 je	 SHORT $LN126@main
$LN37@main:
  01f43	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169135
  01f4a	41 b8 bc 02 00
	00		 mov	 r8d, 700		; 000002bcH
  01f50	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169136
  01f57	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169137
  01f5e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01f64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01f6a	85 c0		 test	 eax, eax
  01f6c	74 20		 je	 SHORT $LN127@main
  01f6e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169139
  01f75	41 b8 bc 02 00
	00		 mov	 r8d, 700		; 000002bcH
  01f7b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169140
  01f82	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169141
  01f89	e8 00 00 00 00	 call	 DebuggerTrace
$LN127@main:
  01f8e	33 c0		 xor	 eax, eax
  01f90	85 c0		 test	 eax, eax
  01f92	75 af		 jne	 SHORT $LN37@main
  01f94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01f9a	85 c0		 test	 eax, eax
  01f9c	74 01		 je	 SHORT $LN128@main
  01f9e	cc		 int	 3
$LN128@main:
$LN126@main:
  01f9f	33 c0		 xor	 eax, eax
  01fa1	85 c0		 test	 eax, eax
  01fa3	75 92		 jne	 SHORT $LN34@main

; 701  : 
; 702  :         /* Flush what we've got so far */
; 703  :         fdatasync( ofd );

  01fa5	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  01fa9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit

; 704  :     }

  01faf	e9 23 f8 ff ff	 jmp	 $LN20@main
$LN21@main:

; 705  :     /* (end process L2 tables) */
; 706  : 
; 707  :     // "%"PRIu32" tracks copied"
; 708  :     WRMSG( HHC02957, "I", tracks_copied );

  01fb4	b9 01 00 00 00	 mov	 ecx, 1
  01fb9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01fbf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR tracks_copied
  01fc5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01fc9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169143
  01fd0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01fd5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169144
  01fdc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01fe1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01fe6	41 b9 03 00 00
	00		 mov	 r9d, 3
  01fec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169145
  01ff3	ba c4 02 00 00	 mov	 edx, 708		; 000002c4H
  01ff8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169146
  01fff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 709  : 
; 710  :     /* Now that all of the output file's data has been written,
; 711  :        save the current file position as the output file's size.
; 712  :     */
; 713  :     if ((curpos = lseek( ofd, 0, SEEK_CUR )) < 0)

  02005	41 b8 01 00 00
	00		 mov	 r8d, 1
  0200b	33 d2		 xor	 edx, edx
  0200d	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  02011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  02017	48 89 44 24 78	 mov	 QWORD PTR curpos$[rsp], rax
  0201c	48 83 7c 24 78
	00		 cmp	 QWORD PTR curpos$[rsp], 0
  02022	0f 8d 80 00 00
	00		 jge	 $LN129@main

; 714  :     {
; 715  :         // "Error in function %s: %s"
; 716  :         FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  02028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0202e	8b 08		 mov	 ecx, DWORD PTR [rax]
  02030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02036	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1380[rsp], rax
  0203e	b9 02 00 00 00	 mov	 ecx, 2
  02043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02049	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv1380[rsp]
  02051	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169148
  0205d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169149
  02069	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0206e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169150
  02075	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0207a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0207f	41 b9 03 00 00
	00		 mov	 r9d, 3
  02085	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169151
  0208c	ba cc 02 00 00	 mov	 edx, 716		; 000002ccH
  02091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169152
  02098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 717  :         return -1;

  0209e	b8 ff ff ff ff	 mov	 eax, -1
  020a3	e9 48 03 00 00	 jmp	 $LN1@main
$LN129@main:

; 718  :     }
; 719  : 
; 720  :     /* Fix up the output file's compressed device header */
; 721  :     ocdevhdr.cdh_size = curpos;

  020a8	48 8b 44 24 78	 mov	 rax, QWORD PTR curpos$[rsp]
  020ad	48 89 05 10 00
	00 00		 mov	 QWORD PTR ocdevhdr+16, rax

; 722  :     ocdevhdr.cdh_used = curpos;

  020b4	48 8b 44 24 78	 mov	 rax, QWORD PTR curpos$[rsp]
  020b9	48 89 05 18 00
	00 00		 mov	 QWORD PTR ocdevhdr+24, rax
$LN40@main:

; 723  : 
; 724  :     /* Swap the output compressed device header before writing it */
; 725  :     SWAP_CCKD64_DEVHDR( &ocdevhdr );

  020c0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  020c7	85 c0		 test	 eax, eax
  020c9	74 0d		 je	 SHORT $LN130@main
  020cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ocdevhdr
  020d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_chdr
$LN130@main:
  020d8	33 c0		 xor	 eax, eax
  020da	85 c0		 test	 eax, eax
  020dc	75 e2		 jne	 SHORT $LN40@main

; 726  : 
; 727  :     // "Writing cckd64 compressed device header..."
; 728  :     WRMSG( HHC02954, "I" );

  020de	b9 01 00 00 00	 mov	 ecx, 1
  020e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  020e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169154
  020f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  020f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169155
  020fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02101	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02106	41 b9 03 00 00
	00		 mov	 r9d, 3
  0210c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169156
  02113	ba d8 02 00 00	 mov	 edx, 728		; 000002d8H
  02118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169157
  0211f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 729  : 
; 730  :     /* Re-write output file's compressed device header */
; 731  :     if ((tmppos = lseek( ofd, CCKD64_DEVHDR_POS, SEEK_SET )) < 0)

  02125	45 33 c0	 xor	 r8d, r8d
  02128	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0212d	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  02131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  02137	48 89 44 24 70	 mov	 QWORD PTR tmppos$[rsp], rax
  0213c	48 83 7c 24 70
	00		 cmp	 QWORD PTR tmppos$[rsp], 0
  02142	0f 8d 80 00 00
	00		 jge	 $LN131@main

; 732  :     {
; 733  :         // "Error in function %s: %s"
; 734  :         FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  02148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0214e	8b 08		 mov	 ecx, DWORD PTR [rax]
  02150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02156	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv1412[rsp], rax
  0215e	b9 02 00 00 00	 mov	 ecx, 2
  02163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02169	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR tv1412[rsp]
  02171	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169159
  0217d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169160
  02189	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0218e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169161
  02195	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0219a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0219f	41 b9 03 00 00
	00		 mov	 r9d, 3
  021a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169162
  021ac	ba de 02 00 00	 mov	 edx, 734		; 000002deH
  021b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169163
  021b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 735  :         return -1;

  021be	b8 ff ff ff ff	 mov	 eax, -1
  021c3	e9 28 02 00 00	 jmp	 $LN1@main
$LN131@main:

; 736  :     }
; 737  :     size = (U32) sizeof( ocdevhdr );

  021c8	c7 44 24 50 00
	02 00 00	 mov	 DWORD PTR size$[rsp], 512 ; 00000200H

; 738  :     if ((rc = write( ofd, &ocdevhdr, size )) < (int) size)

  021d0	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  021d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ocdevhdr
  021dc	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  021e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  021e6	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  021ea	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  021ee	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  021f2	0f 8d 80 00 00
	00		 jge	 $LN132@main

; 739  :     {
; 740  :         // "Error in function %s: %s"
; 741  :         FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  021f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  021fe	8b 08		 mov	 ecx, DWORD PTR [rax]
  02200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02206	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv1431[rsp], rax
  0220e	b9 02 00 00 00	 mov	 ecx, 2
  02213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02219	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR tv1431[rsp]
  02221	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169165
  0222d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169166
  02239	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0223e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169167
  02245	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0224a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0224f	41 b9 03 00 00
	00		 mov	 r9d, 3
  02255	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169168
  0225c	ba e5 02 00 00	 mov	 edx, 741		; 000002e5H
  02261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169169
  02268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 742  :         return -1;

  0226e	b8 ff ff ff ff	 mov	 eax, -1
  02273	e9 78 01 00 00	 jmp	 $LN1@main
$LN132@main:
$LN43@main:

; 743  :     }
; 744  : 
; 745  :     /* Swap the output L1 table before writing it out */
; 746  :     SWAP_CCKD64_L1TAB( oL1tab );

  02278	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  0227f	85 c0		 test	 eax, eax
  02281	74 13		 je	 SHORT $LN133@main
  02283	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR num_L1tab
  02289	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR oL1tab
  02290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_l1
$LN133@main:
  02296	33 c0		 xor	 eax, eax
  02298	85 c0		 test	 eax, eax
  0229a	75 dc		 jne	 SHORT $LN43@main

; 747  : 
; 748  :     // "Writing L1 table..."
; 749  :     WRMSG( HHC02955, "I" );

  0229c	b9 01 00 00 00	 mov	 ecx, 1
  022a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  022a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169171
  022ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  022b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169172
  022ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  022bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  022c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  022ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169173
  022d1	ba ed 02 00 00	 mov	 edx, 749		; 000002edH
  022d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169174
  022dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 750  : 
; 751  :     /* Re-write the output file's now accurate L1 table */
; 752  :     size = (U32) (num_L1tab * sizeof( CCKD64_L1ENT ));

  022e3	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR num_L1tab
  022ea	48 c1 e0 03	 shl	 rax, 3
  022ee	89 44 24 50	 mov	 DWORD PTR size$[rsp], eax

; 753  :     if ((rc = write( ofd, oL1tab, size )) < (int) size )

  022f2	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  022f7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR oL1tab
  022fe	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  02302	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  02308	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  0230c	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  02310	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  02314	7d 7d		 jge	 SHORT $LN134@main

; 754  :     {
; 755  :         // "Error in function %s: %s"
; 756  :         FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  02316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0231c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0231e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02324	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv1467[rsp], rax
  0232c	b9 02 00 00 00	 mov	 ecx, 2
  02331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02337	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR tv1467[rsp]
  0233f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169176
  0234b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169177
  02357	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0235c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169178
  02363	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02368	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0236d	41 b9 03 00 00
	00		 mov	 r9d, 3
  02373	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169179
  0237a	ba f4 02 00 00	 mov	 edx, 756		; 000002f4H
  0237f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169180
  02386	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 757  :         return -1;

  0238c	b8 ff ff ff ff	 mov	 eax, -1
  02391	eb 5d		 jmp	 SHORT $LN1@main
$LN134@main:

; 758  :     }
; 759  : 
; 760  :     /* We're done! Close our input and output files and exit! */
; 761  :     close( ofd );

  02393	8b 4c 24 5c	 mov	 ecx, DWORD PTR ofd$[rsp]
  02397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 762  :     close( ifd );

  0239d	8b 4c 24 64	 mov	 ecx, DWORD PTR ifd$[rsp]
  023a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 763  : 
; 764  :     // "DASD operation completed"
; 765  :     WRMSG( HHC02961, "I" );

  023a7	b9 01 00 00 00	 mov	 ecx, 1
  023ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  023b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169181
  023b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  023be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169182
  023c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  023ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  023cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  023d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169183
  023dc	ba fd 02 00 00	 mov	 edx, 765		; 000002fdH
  023e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169184
  023e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 766  : 
; 767  :     return 0;

  023ee	33 c0		 xor	 eax, eax
$LN1@main:

; 768  : }

  023f0	48 8b 8c 24 00
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  023f8	48 33 cc	 xor	 rcx, rsp
  023fb	e8 00 00 00 00	 call	 __security_check_cookie
  02400	48 81 c4 18 05
	00 00		 add	 rsp, 1304		; 00000518H
  02407	5f		 pop	 rdi
  02408	5e		 pop	 rsi
  02409	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\convto64.c
_TEXT	SEGMENT
i$ = 80
size$ = 84
rc$ = 88
tv201 = 92
tv72 = 96
tv141 = 100
tv145 = 104
tv225 = 112
tmppos$ = 120
tv166 = 128
tv207 = 136
tv230 = 144
tv249 = 152
trkblk$ = 176
ifd$ = 184
iL2$ = 192
ofd$ = 200
oL2$ = 208
process_L2_tab PROC

; 775  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@process_L2:

; 776  :     int  rc, i, size;                   /* Work variables            */
; 777  :     S64  tmppos;                        /* Work: lseek return code   */
; 778  : 
; 779  :     /* Swap input L2 table if needed before processing */
; 780  :     SWAP_CCKD64_L2TAB( iL2 );

  00019	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  00020	85 c0		 test	 eax, eax
  00022	74 0e		 je	 SHORT $LN11@process_L2
  00024	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR iL2$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_l2
$LN11@process_L2:
  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 e1		 jne	 SHORT $LN4@process_L2

; 781  : 
; 782  :     /* For each L2 table entry... */
; 783  :     for (i=0; i < 256; i++)

  00038	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00040	eb 0a		 jmp	 SHORT $LN7@process_L2
$LN5@process_L2:
  00042	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00046	ff c0		 inc	 eax
  00048	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN7@process_L2:
  0004c	81 7c 24 50 00
	01 00 00	 cmp	 DWORD PTR i$[rsp], 256	; 00000100H
  00054	0f 8d d1 04 00
	00		 jge	 $LN6@process_L2
$LN10@process_L2:

; 784  :     {
; 785  :         EXTGUIMSG( "TRK=%d\n", trkblk+i );

  0005a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00061	83 38 00	 cmp	 DWORD PTR [rax], 0
  00064	74 35		 je	 SHORT $LN12@process_L2
  00066	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0006a	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR trkblk$[rsp]
  00071	03 c8		 add	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 60	 mov	 DWORD PTR tv72[rsp], eax
  00079	b9 02 00 00 00	 mov	 ecx, 2
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00084	8b 4c 24 60	 mov	 ecx, DWORD PTR tv72[rsp]
  00088	44 8b c1	 mov	 r8d, ecx
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169213
  00092	48 8b c8	 mov	 rcx, rax
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN12@process_L2:
  0009b	33 c0		 xor	 eax, eax
  0009d	85 c0		 test	 eax, eax
  0009f	75 b9		 jne	 SHORT $LN10@process_L2

; 786  : 
; 787  :         oL2[i].L2_len  = iL2[i].L2_len;

  000a1	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000a6	48 6b c0 10	 imul	 rax, rax, 16
  000aa	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000af	48 6b c9 10	 imul	 rcx, rcx, 16
  000b3	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR oL2$[rsp]
  000bb	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR iL2$[rsp]
  000c3	41 0f b7 44 00
	08		 movzx	 eax, WORD PTR [r8+rax+8]
  000c9	66 89 44 0a 08	 mov	 WORD PTR [rdx+rcx+8], ax

; 788  :         oL2[i].L2_size = iL2[i].L2_size;

  000ce	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000d3	48 6b c0 10	 imul	 rax, rax, 16
  000d7	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000dc	48 6b c9 10	 imul	 rcx, rcx, 16
  000e0	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR oL2$[rsp]
  000e8	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR iL2$[rsp]
  000f0	41 0f b7 44 00
	0a		 movzx	 eax, WORD PTR [r8+rax+10]
  000f6	66 89 44 0a 0a	 mov	 WORD PTR [rdx+rcx+10], ax

; 789  : 
; 790  :         /* Skip copying tracks that don't exist */
; 791  :         if (0
; 792  :             || iL2[i].L2_trkoff == 0
; 793  :             || iL2[i].L2_trkoff == ULLONG_MAX

  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 30		 jne	 SHORT $LN14@process_L2
  00101	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00106	48 6b c0 10	 imul	 rax, rax, 16
  0010a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR iL2$[rsp]
  00112	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00117	74 18		 je	 SHORT $LN14@process_L2
  00119	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0011e	48 6b c0 10	 imul	 rax, rax, 16
  00122	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR iL2$[rsp]
  0012a	48 83 3c 01 ff	 cmp	 QWORD PTR [rcx+rax], -1
  0012f	75 05		 jne	 SHORT $LN13@process_L2
$LN14@process_L2:

; 794  :         )
; 795  :             continue; /* (no track data to copy) */

  00131	e9 0c ff ff ff	 jmp	 $LN5@process_L2
$LN13@process_L2:

; 796  : 
; 797  :         /* Report every track/blkgrp copied if requested... */
; 798  :         if (verbose && !quiet)

  00136	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR verbose
  0013d	85 c0		 test	 eax, eax
  0013f	0f 84 a0 00 00
	00		 je	 $LN15@process_L2
  00145	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR quiet
  0014c	85 c0		 test	 eax, eax
  0014e	0f 85 91 00 00
	00		 jne	 $LN15@process_L2

; 799  :             // "Copying %s %d data..."
; 800  :             WRMSG( HHC02956, "I", fba ? "blkgrp" : "track", trkblk+i );

  00154	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  0015b	85 c0		 test	 eax, eax
  0015d	74 0e		 je	 SHORT $LN21@process_L2
  0015f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169217
  00166	48 89 44 24 68	 mov	 QWORD PTR tv145[rsp], rax
  0016b	eb 0c		 jmp	 SHORT $LN22@process_L2
$LN21@process_L2:
  0016d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169218
  00174	48 89 44 24 68	 mov	 QWORD PTR tv145[rsp], rax
$LN22@process_L2:
  00179	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0017d	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR trkblk$[rsp]
  00184	03 c8		 add	 ecx, eax
  00186	8b c1		 mov	 eax, ecx
  00188	89 44 24 64	 mov	 DWORD PTR tv141[rsp], eax
  0018c	b9 01 00 00 00	 mov	 ecx, 1
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00197	8b 4c 24 64	 mov	 ecx, DWORD PTR tv141[rsp]
  0019b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0019f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv145[rsp]
  001a4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169219
  001b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169220
  001bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169221
  001d3	ba 20 03 00 00	 mov	 edx, 800		; 00000320H
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169222
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@process_L2:

; 801  : 
; 802  :         tracks_copied++;    /* Count tracks copied */

  001e5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR tracks_copied
  001eb	ff c0		 inc	 eax
  001ed	89 05 00 00 00
	00		 mov	 DWORD PTR tracks_copied, eax

; 803  : 
; 804  :         /* Seek to where this track's data resides */
; 805  :         if ((tmppos = lseek( ifd, iL2[i].L2_trkoff, SEEK_SET )) < 0)

  001f3	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  001f8	48 6b c0 10	 imul	 rax, rax, 16
  001fc	45 33 c0	 xor	 r8d, r8d
  001ff	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR iL2$[rsp]
  00207	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0020b	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR ifd$[rsp]
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00218	48 89 44 24 78	 mov	 QWORD PTR tmppos$[rsp], rax
  0021d	48 83 7c 24 78
	00		 cmp	 QWORD PTR tmppos$[rsp], 0
  00223	0f 8d 80 00 00
	00		 jge	 $LN16@process_L2

; 806  :         {
; 807  :             // "Error in function %s: %s"
; 808  :             FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0022f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00237	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  0023f	b9 02 00 00 00	 mov	 ecx, 2
  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv166[rsp]
  00252	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169224
  0025e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169225
  0026a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0026f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169226
  00276	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0027b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00280	41 b9 03 00 00
	00		 mov	 r9d, 3
  00286	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169227
  0028d	ba 28 03 00 00	 mov	 edx, 808		; 00000328H
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169228
  00299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 809  :             return -1;

  0029f	b8 ff ff ff ff	 mov	 eax, -1
  002a4	e9 84 02 00 00	 jmp	 $LN1@process_L2
$LN16@process_L2:

; 810  :         }
; 811  : 
; 812  :         /* Read this track's data */
; 813  :         size = (U32) max( iL2[i].L2_len, iL2[i].L2_size );

  002a9	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  002ae	48 6b c0 10	 imul	 rax, rax, 16
  002b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR iL2$[rsp]
  002ba	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  002bf	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  002c4	48 6b c9 10	 imul	 rcx, rcx, 16
  002c8	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR iL2$[rsp]
  002d0	0f b7 4c 0a 0a	 movzx	 ecx, WORD PTR [rdx+rcx+10]
  002d5	3b c1		 cmp	 eax, ecx
  002d7	7e 1c		 jle	 SHORT $LN23@process_L2
  002d9	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  002de	48 6b c0 10	 imul	 rax, rax, 16
  002e2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR iL2$[rsp]
  002ea	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  002ef	89 44 24 5c	 mov	 DWORD PTR tv201[rsp], eax
  002f3	eb 1a		 jmp	 SHORT $LN24@process_L2
$LN23@process_L2:
  002f5	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  002fa	48 6b c0 10	 imul	 rax, rax, 16
  002fe	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR iL2$[rsp]
  00306	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  0030b	89 44 24 5c	 mov	 DWORD PTR tv201[rsp], eax
$LN24@process_L2:
  0030f	8b 44 24 5c	 mov	 eax, DWORD PTR tv201[rsp]
  00313	89 44 24 54	 mov	 DWORD PTR size$[rsp], eax

; 814  : 
; 815  :         if ((rc = read( ifd, trkbuf, size )) < size)

  00317	44 8b 44 24 54	 mov	 r8d, DWORD PTR size$[rsp]
  0031c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:trkbuf
  00323	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR ifd$[rsp]
  0032a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00330	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  00334	8b 44 24 54	 mov	 eax, DWORD PTR size$[rsp]
  00338	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  0033c	0f 8d 80 00 00
	00		 jge	 $LN17@process_L2

; 816  :         {
; 817  :             // "Error in function %s: %s"
; 818  :             FWRMSG( stderr, HHC02958, "E", "read()", strerror( errno ));

  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00348	8b 08		 mov	 ecx, DWORD PTR [rax]
  0034a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00350	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv207[rsp], rax
  00358	b9 02 00 00 00	 mov	 ecx, 2
  0035d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00363	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv207[rsp]
  0036b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00370	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169230
  00377	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0037c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169231
  00383	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00388	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169232
  0038f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00394	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00399	41 b9 03 00 00
	00		 mov	 r9d, 3
  0039f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169233
  003a6	ba 32 03 00 00	 mov	 edx, 818		; 00000332H
  003ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169234
  003b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 819  :             return -1;

  003b8	b8 ff ff ff ff	 mov	 eax, -1
  003bd	e9 6b 01 00 00	 jmp	 $LN1@process_L2
$LN17@process_L2:

; 820  :         }
; 821  : 
; 822  :         /* Retrieve the current output file position */
; 823  :         if ((off_t)(oL2[i].L2_trkoff = lseek( ofd, 0, SEEK_CUR )) < 0)

  003c2	41 b8 01 00 00
	00		 mov	 r8d, 1
  003c8	33 d2		 xor	 edx, edx
  003ca	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR ofd$[rsp]
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  003d7	48 89 44 24 70	 mov	 QWORD PTR tv225[rsp], rax
  003dc	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  003e1	48 6b c0 10	 imul	 rax, rax, 16
  003e5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR oL2$[rsp]
  003ed	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv225[rsp]
  003f2	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  003f6	48 83 7c 24 70
	00		 cmp	 QWORD PTR tv225[rsp], 0
  003fc	0f 8d 80 00 00
	00		 jge	 $LN18@process_L2

; 824  :         {
; 825  :             // "Error in function %s: %s"
; 826  :             FWRMSG( stderr, HHC02958, "E", "lseek()", strerror( errno ));

  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00408	8b 08		 mov	 ecx, DWORD PTR [rax]
  0040a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00410	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv230[rsp], rax
  00418	b9 02 00 00 00	 mov	 ecx, 2
  0041d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00423	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv230[rsp]
  0042b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169236
  00437	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0043c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169237
  00443	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00448	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169238
  0044f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00454	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00459	41 b9 03 00 00
	00		 mov	 r9d, 3
  0045f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169239
  00466	ba 3a 03 00 00	 mov	 edx, 826		; 0000033aH
  0046b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169240
  00472	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 827  :             return -1;

  00478	b8 ff ff ff ff	 mov	 eax, -1
  0047d	e9 ab 00 00 00	 jmp	 $LN1@process_L2
$LN18@process_L2:

; 828  :         }
; 829  : 
; 830  :         /* Write the track data to the output file */
; 831  :         if ((rc = write( ofd, trkbuf, size )) < size )

  00482	44 8b 44 24 54	 mov	 r8d, DWORD PTR size$[rsp]
  00487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:trkbuf
  0048e	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR ofd$[rsp]
  00495	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0049b	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  0049f	8b 44 24 54	 mov	 eax, DWORD PTR size$[rsp]
  004a3	39 44 24 58	 cmp	 DWORD PTR rc$[rsp], eax
  004a7	7d 7d		 jge	 SHORT $LN19@process_L2

; 832  :         {
; 833  :             // "Error in function %s: %s"
; 834  :             FWRMSG( stderr, HHC02958, "E", "write()", strerror( errno ));

  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004af	8b 08		 mov	 ecx, DWORD PTR [rax]
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004b7	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  004bf	b9 02 00 00 00	 mov	 ecx, 2
  004c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ca	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv249[rsp]
  004d2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169242
  004de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169243
  004ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169244
  004f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00500	41 b9 03 00 00
	00		 mov	 r9d, 3
  00506	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169245
  0050d	ba 42 03 00 00	 mov	 edx, 834		; 00000342H
  00512	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169246
  00519	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 835  :             return -1;

  0051f	b8 ff ff ff ff	 mov	 eax, -1
  00524	eb 07		 jmp	 SHORT $LN1@process_L2
$LN19@process_L2:

; 836  :         }
; 837  :     }

  00526	e9 17 fb ff ff	 jmp	 $LN5@process_L2
$LN6@process_L2:

; 838  : 
; 839  :     return 0;

  0052b	33 c0		 xor	 eax, eax
$LN1@process_L2:

; 840  : }

  0052d	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00534	c3		 ret	 0
process_L2_tab ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\convto64.c
_TEXT	SEGMENT
running_on_big_endian_system$ = 32
tv80 = 36
tv82 = 40
icdevhdr$ = 64
are_swaps_needed PROC

; 197  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 198  :     bool  running_on_big_endian_system  = are_big_endian();

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_are_big_endian
  0000f	88 44 24 20	 mov	 BYTE PTR running_on_big_endian_system$[rsp], al

; 199  : 
; 200  :     return

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 4a		 jne	 SHORT $LN4@are_swaps_
  00019	33 c0		 xor	 eax, eax
  0001b	83 f8 01	 cmp	 eax, 1
  0001e	74 19		 je	 SHORT $LN3@are_swaps_
  00020	0f b6 44 24 20	 movzx	 eax, BYTE PTR running_on_big_endian_system$[rsp]
  00025	85 c0		 test	 eax, eax
  00027	74 10		 je	 SHORT $LN3@are_swaps_
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR icdevhdr$[rsp]
  0002e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00032	83 e0 02	 and	 eax, 2
  00035	85 c0		 test	 eax, eax
  00037	74 2a		 je	 SHORT $LN4@are_swaps_
$LN3@are_swaps_:
  00039	33 c0		 xor	 eax, eax
  0003b	83 f8 01	 cmp	 eax, 1
  0003e	74 19		 je	 SHORT $LN5@are_swaps_
  00040	0f b6 44 24 20	 movzx	 eax, BYTE PTR running_on_big_endian_system$[rsp]
  00045	85 c0		 test	 eax, eax
  00047	75 10		 jne	 SHORT $LN5@are_swaps_
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR icdevhdr$[rsp]
  0004e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00052	83 e0 02	 and	 eax, 2
  00055	85 c0		 test	 eax, eax
  00057	75 0a		 jne	 SHORT $LN4@are_swaps_
$LN5@are_swaps_:
  00059	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
  00061	eb 08		 jmp	 SHORT $LN6@are_swaps_
$LN4@are_swaps_:
  00063	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
$LN6@are_swaps_:
  0006b	83 7c 24 24 00	 cmp	 DWORD PTR tv80[rsp], 0
  00070	75 0a		 jne	 SHORT $LN7@are_swaps_
  00072	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  0007a	eb 08		 jmp	 SHORT $LN8@are_swaps_
$LN7@are_swaps_:
  0007c	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
$LN8@are_swaps_:
  00084	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv82[rsp]

; 201  :     (0
; 202  :         || (1
; 203  :             && running_on_big_endian_system
; 204  :             && !(icdevhdr->cdh_opts & CCKD_OPT_BIGEND)
; 205  :            )
; 206  :         || (1
; 207  :             && !running_on_big_endian_system
; 208  :             && (icdevhdr->cdh_opts & CCKD_OPT_BIGEND)
; 209  :            )
; 210  :     );
; 211  : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
are_swaps_needed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\convto64.c
_TEXT	SEGMENT
n$1 = 0
i$2 = 4
L2tabs_to_64 PROC

; 173  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 174  :     if (!cckd64)

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  0000b	85 c0		 test	 eax, eax
  0000d	0f 85 2c 01 00
	00		 jne	 $LN8@L2tabs_to_

; 175  :     {
; 176  :         int  n, i;
; 177  :         for (n=0; n < num_L1tab; ++n)

  00013	c7 04 24 00 00
	00 00		 mov	 DWORD PTR n$1[rsp], 0
  0001a	eb 08		 jmp	 SHORT $LN4@L2tabs_to_
$LN2@L2tabs_to_:
  0001c	8b 04 24	 mov	 eax, DWORD PTR n$1[rsp]
  0001f	ff c0		 inc	 eax
  00021	89 04 24	 mov	 DWORD PTR n$1[rsp], eax
$LN4@L2tabs_to_:
  00024	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_L1tab
  0002a	39 04 24	 cmp	 DWORD PTR n$1[rsp], eax
  0002d	0f 8d 0c 01 00
	00		 jge	 $LN3@L2tabs_to_

; 178  :         {
; 179  :             for (i=0; i < 256; ++i)

  00033	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0003b	eb 0a		 jmp	 SHORT $LN7@L2tabs_to_
$LN5@L2tabs_to_:
  0003d	8b 44 24 04	 mov	 eax, DWORD PTR i$2[rsp]
  00041	ff c0		 inc	 eax
  00043	89 44 24 04	 mov	 DWORD PTR i$2[rsp], eax
$LN7@L2tabs_to_:
  00047	81 7c 24 04 00
	01 00 00	 cmp	 DWORD PTR i$2[rsp], 256	; 00000100H
  0004f	0f 8d e5 00 00
	00		 jge	 $LN6@L2tabs_to_

; 180  :             {
; 181  :                 if (iL2tab32[(n*256)+i].L2_trkoff == CCKD_MAXSIZE)

  00055	69 04 24 00 01
	00 00		 imul	 eax, DWORD PTR n$1[rsp], 256 ; 00000100H
  0005c	03 44 24 04	 add	 eax, DWORD PTR i$2[rsp]
  00060	48 98		 cdqe
  00062	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL2tab32
  00069	83 3c c1 ff	 cmp	 DWORD PTR [rcx+rax*8], -1 ; ffffffffH
  0006d	75 22		 jne	 SHORT $LN9@L2tabs_to_

; 182  :                     iL2tab[(n*256)+i].L2_trkoff = CCKD64_MAXSIZE;

  0006f	69 04 24 00 01
	00 00		 imul	 eax, DWORD PTR n$1[rsp], 256 ; 00000100H
  00076	03 44 24 04	 add	 eax, DWORD PTR i$2[rsp]
  0007a	48 98		 cdqe
  0007c	48 6b c0 10	 imul	 rax, rax, 16
  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iL2tab
  00087	48 c7 04 01 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax], -1
  0008f	eb 34		 jmp	 SHORT $LN10@L2tabs_to_
$LN9@L2tabs_to_:

; 183  :                 else
; 184  :                     iL2tab[(n*256)+i].L2_trkoff = iL2tab32[(n*256)+i].L2_trkoff;

  00091	69 04 24 00 01
	00 00		 imul	 eax, DWORD PTR n$1[rsp], 256 ; 00000100H
  00098	03 44 24 04	 add	 eax, DWORD PTR i$2[rsp]
  0009c	48 98		 cdqe
  0009e	69 0c 24 00 01
	00 00		 imul	 ecx, DWORD PTR n$1[rsp], 256 ; 00000100H
  000a5	03 4c 24 04	 add	 ecx, DWORD PTR i$2[rsp]
  000a9	48 63 c9	 movsxd	 rcx, ecx
  000ac	48 6b c9 10	 imul	 rcx, rcx, 16
  000b0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR iL2tab32
  000b7	8b 04 c2	 mov	 eax, DWORD PTR [rdx+rax*8]
  000ba	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR iL2tab
  000c1	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
$LN10@L2tabs_to_:

; 185  : 
; 186  :                 iL2tab[(n*256)+i].L2_len  = iL2tab32[(n*256)+i].L2_len;

  000c5	69 04 24 00 01
	00 00		 imul	 eax, DWORD PTR n$1[rsp], 256 ; 00000100H
  000cc	03 44 24 04	 add	 eax, DWORD PTR i$2[rsp]
  000d0	48 98		 cdqe
  000d2	69 0c 24 00 01
	00 00		 imul	 ecx, DWORD PTR n$1[rsp], 256 ; 00000100H
  000d9	03 4c 24 04	 add	 ecx, DWORD PTR i$2[rsp]
  000dd	48 63 c9	 movsxd	 rcx, ecx
  000e0	48 6b c9 10	 imul	 rcx, rcx, 16
  000e4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR iL2tab
  000eb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR iL2tab32
  000f2	41 0f b7 44 c0
	04		 movzx	 eax, WORD PTR [r8+rax*8+4]
  000f8	66 89 44 0a 08	 mov	 WORD PTR [rdx+rcx+8], ax

; 187  :                 iL2tab[(n*256)+i].L2_size = iL2tab32[(n*256)+i].L2_size;

  000fd	69 04 24 00 01
	00 00		 imul	 eax, DWORD PTR n$1[rsp], 256 ; 00000100H
  00104	03 44 24 04	 add	 eax, DWORD PTR i$2[rsp]
  00108	48 98		 cdqe
  0010a	69 0c 24 00 01
	00 00		 imul	 ecx, DWORD PTR n$1[rsp], 256 ; 00000100H
  00111	03 4c 24 04	 add	 ecx, DWORD PTR i$2[rsp]
  00115	48 63 c9	 movsxd	 rcx, ecx
  00118	48 6b c9 10	 imul	 rcx, rcx, 16
  0011c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR iL2tab
  00123	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR iL2tab32
  0012a	41 0f b7 44 c0
	06		 movzx	 eax, WORD PTR [r8+rax*8+6]
  00130	66 89 44 0a 0a	 mov	 WORD PTR [rdx+rcx+10], ax

; 188  :             }

  00135	e9 03 ff ff ff	 jmp	 $LN5@L2tabs_to_
$LN6@L2tabs_to_:

; 189  :         }

  0013a	e9 dd fe ff ff	 jmp	 $LN2@L2tabs_to_
$LN3@L2tabs_to_:
$LN8@L2tabs_to_:

; 190  :     }
; 191  : }

  0013f	48 83 c4 18	 add	 rsp, 24
  00143	c3		 ret	 0
L2tabs_to_64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\convto64.c
_TEXT	SEGMENT
i$1 = 0
L32$2 = 8
L64$3 = 16
L1tab_to_64 PROC

; 156  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 157  :     if (!cckd64)

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  0000b	85 c0		 test	 eax, eax
  0000d	75 71		 jne	 SHORT $LN5@L1tab_to_6

; 158  :     {
; 159  :         CCKD_L1ENT*    L32  = iL1tab32;     // input 32

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR iL1tab32
  00016	48 89 44 24 08	 mov	 QWORD PTR L32$2[rsp], rax

; 160  :         CCKD64_L1ENT*  L64  = iL1tab;       // input 64

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR iL1tab
  00022	48 89 44 24 10	 mov	 QWORD PTR L64$3[rsp], rax

; 161  : 
; 162  :         S32  i;
; 163  :         for (i=0; i < num_L1tab; ++i)

  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$1[rsp], 0
  0002e	eb 08		 jmp	 SHORT $LN4@L1tab_to_6
$LN2@L1tab_to_6:
  00030	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	ff c0		 inc	 eax
  00035	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@L1tab_to_6:
  00038	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_L1tab
  0003e	39 04 24	 cmp	 DWORD PTR i$1[rsp], eax
  00041	7d 3d		 jge	 SHORT $LN3@L1tab_to_6

; 164  :         {
; 165  :             if (L32[i] == CCKD_MAXSIZE)

  00043	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00047	48 8b 4c 24 08	 mov	 rcx, QWORD PTR L32$2[rsp]
  0004c	83 3c 81 ff	 cmp	 DWORD PTR [rcx+rax*4], -1 ; ffffffffH
  00050	75 13		 jne	 SHORT $LN6@L1tab_to_6

; 166  :                 L64[i] = CCKD64_MAXSIZE;

  00052	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00056	48 8b 4c 24 10	 mov	 rcx, QWORD PTR L64$3[rsp]
  0005b	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1
  00063	eb 19		 jmp	 SHORT $LN7@L1tab_to_6
$LN6@L1tab_to_6:

; 167  :             else
; 168  :                 L64[i] = L32[i];

  00065	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00069	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0006d	48 8b 54 24 08	 mov	 rdx, QWORD PTR L32$2[rsp]
  00072	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00075	48 8b 54 24 10	 mov	 rdx, QWORD PTR L64$3[rsp]
  0007a	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN7@L1tab_to_6:

; 169  :         }

  0007e	eb b0		 jmp	 SHORT $LN2@L1tab_to_6
$LN3@L1tab_to_6:
$LN5@L1tab_to_6:

; 170  :     }
; 171  : }

  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	c3		 ret	 0
L1tab_to_64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\convto64.c
_TEXT	SEGMENT
cdevhdr_to_64 PROC

; 131  : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi

; 132  :     if (!cckd64)

  00003	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  0000a	85 c0		 test	 eax, eax
  0000c	0f 85 d0 00 00
	00		 jne	 $LN2@cdevhdr_to

; 133  :     {
; 134  :         memcpy( icdevhdr.cdh_vrm,  icdevhdr32.cdh_vrm,  sizeof( icdevhdr.cdh_vrm  ));

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:icdevhdr
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:icdevhdr32
  00020	48 8b f8	 mov	 rdi, rax
  00023	48 8b f1	 mov	 rsi, rcx
  00026	b9 03 00 00 00	 mov	 ecx, 3
  0002b	f3 a4		 rep movsb

; 135  :         memcpy( icdevhdr.cdh_cyls, icdevhdr32.cdh_cyls, sizeof( icdevhdr.cdh_cyls ));

  0002d	8b 05 28 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+40
  00033	89 05 0c 00 00
	00		 mov	 DWORD PTR icdevhdr+12, eax

; 136  : 
; 137  :         icdevhdr.num_L1tab    = icdevhdr32.num_L1tab;

  00039	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+4
  0003f	89 05 04 00 00
	00		 mov	 DWORD PTR icdevhdr+4, eax

; 138  :         icdevhdr.num_L2tab    = icdevhdr32.num_L2tab;

  00045	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+8
  0004b	89 05 08 00 00
	00		 mov	 DWORD PTR icdevhdr+8, eax

; 139  : 
; 140  :         icdevhdr.cdh_opts     = icdevhdr32.cdh_opts;

  00051	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR icdevhdr32+3
  00058	88 05 03 00 00
	00		 mov	 BYTE PTR icdevhdr+3, al

; 141  :         icdevhdr.cdh_size     = icdevhdr32.cdh_size;

  0005e	8b 05 0c 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+12
  00064	48 89 05 10 00
	00 00		 mov	 QWORD PTR icdevhdr+16, rax

; 142  :         icdevhdr.cdh_used     = icdevhdr32.cdh_used;

  0006b	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+16
  00071	48 89 05 18 00
	00 00		 mov	 QWORD PTR icdevhdr+24, rax

; 143  :         icdevhdr.cdh_nullfmt  = icdevhdr32.cdh_nullfmt;

  00078	0f b6 05 2c 00
	00 00		 movzx	 eax, BYTE PTR icdevhdr32+44
  0007f	88 05 48 00 00
	00		 mov	 BYTE PTR icdevhdr+72, al

; 144  : 
; 145  :         icdevhdr.free_off     = icdevhdr32.free_off;

  00085	8b 05 14 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+20
  0008b	48 89 05 20 00
	00 00		 mov	 QWORD PTR icdevhdr+32, rax

; 146  :         icdevhdr.free_total   = icdevhdr32.free_total;

  00092	8b 05 18 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+24
  00098	48 89 05 28 00
	00 00		 mov	 QWORD PTR icdevhdr+40, rax

; 147  :         icdevhdr.free_largest = icdevhdr32.free_largest;

  0009f	8b 05 1c 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+28
  000a5	48 89 05 30 00
	00 00		 mov	 QWORD PTR icdevhdr+48, rax

; 148  :         icdevhdr.free_num     = icdevhdr32.free_num;

  000ac	48 63 05 20 00
	00 00		 movsxd	 rax, DWORD PTR icdevhdr32+32
  000b3	48 89 05 38 00
	00 00		 mov	 QWORD PTR icdevhdr+56, rax

; 149  :         icdevhdr.free_imbed   = icdevhdr32.free_imbed;

  000ba	8b 05 24 00 00
	00		 mov	 eax, DWORD PTR icdevhdr32+36
  000c0	48 89 05 40 00
	00 00		 mov	 QWORD PTR icdevhdr+64, rax

; 150  : 
; 151  :         icdevhdr.cmp_algo     = icdevhdr32.cmp_algo;

  000c7	0f b6 05 2d 00
	00 00		 movzx	 eax, BYTE PTR icdevhdr32+45
  000ce	88 05 49 00 00
	00		 mov	 BYTE PTR icdevhdr+73, al

; 152  :         icdevhdr.cmp_parm     = icdevhdr32.cmp_parm;

  000d4	0f b7 05 2e 00
	00 00		 movzx	 eax, WORD PTR icdevhdr32+46
  000db	66 89 05 4a 00
	00 00		 mov	 WORD PTR icdevhdr+74, ax
$LN2@cdevhdr_to:

; 153  :     }
; 154  : }

  000e2	5f		 pop	 rdi
  000e3	5e		 pop	 rsi
  000e4	c3		 ret	 0
cdevhdr_to_64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\convto64.c
_TEXT	SEGMENT
buffsize$1 = 64
rc$2 = 68
chunksize$3 = 72
msgbuf$4 = 80
vargs$5 = 88
pgm$ = 112
msgfmt$ = 120
syntax	PROC

; 84   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 85   :     // HHC02950:
; 86   :     //
; 87   :     //    Usage: %s [-r] [-c] [-q] [-v] infile outfile
; 88   :     //      infile    input file
; 89   :     //      outfile   output file
; 90   :     //    options:
; 91   :     //      -r     Replace output file
; 92   :     //      -c     Write contiguous L2 tables
; 93   :     //      -q     Minimal progress messages
; 94   :     //      -v     Report every track copied
; 95   : 
; 96   :     if (msgfmt)

  00018	48 83 7c 24 78
	00		 cmp	 QWORD PTR msgfmt$[rsp], 0
  0001e	0f 84 11 01 00
	00		 je	 $LN5@syntax

; 97   :     {
; 98   :         const int  chunksize  = 128;

  00024	c7 44 24 48 80
	00 00 00	 mov	 DWORD PTR chunksize$3[rsp], 128 ; 00000080H

; 99   :         int        rc         = -1;

  0002c	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR rc$2[rsp], -1

; 100  :         int        buffsize   =  0;

  00034	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR buffsize$1[rsp], 0

; 101  :         char*      msgbuf     = NULL;

  0003c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR msgbuf$4[rsp], 0
$LN9@syntax:
$LN4@syntax:

; 102  :         va_list    vargs;
; 103  : 
; 104  :         do
; 105  :         {
; 106  :             if (msgbuf) free( msgbuf );

  00045	48 83 7c 24 50
	00		 cmp	 QWORD PTR msgbuf$4[rsp], 0
  0004b	74 0b		 je	 SHORT $LN6@syntax
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR msgbuf$4[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@syntax:

; 107  :             if (!(msgbuf = calloc( 1, buffsize += chunksize )))

  00058	8b 44 24 48	 mov	 eax, DWORD PTR chunksize$3[rsp]
  0005c	8b 4c 24 40	 mov	 ecx, DWORD PTR buffsize$1[rsp]
  00060	03 c8		 add	 ecx, eax
  00062	8b c1		 mov	 eax, ecx
  00064	89 44 24 40	 mov	 DWORD PTR buffsize$1[rsp], eax
  00068	48 63 44 24 40	 movsxd	 rax, DWORD PTR buffsize$1[rsp]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	b9 01 00 00 00	 mov	 ecx, 1
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0007b	48 89 44 24 50	 mov	 QWORD PTR msgbuf$4[rsp], rax
  00080	48 83 7c 24 50
	00		 cmp	 QWORD PTR msgbuf$4[rsp], 0
  00086	75 01		 jne	 SHORT $LN7@syntax

; 108  :                 BREAK_INTO_DEBUGGER();

  00088	cc		 int	 3
$LN7@syntax:

; 109  : 
; 110  :             va_end(   vargs );

  00089	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR vargs$5[rsp], 0

; 111  :             va_start( vargs, msgfmt );

  00092	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR msgfmt$[rsp+8]
  0009a	48 89 44 24 58	 mov	 QWORD PTR vargs$5[rsp], rax

; 112  : 
; 113  :             rc = vsnprintf( msgbuf, buffsize, msgfmt, vargs );

  0009f	48 63 44 24 40	 movsxd	 rax, DWORD PTR buffsize$1[rsp]
  000a4	4c 8b 4c 24 58	 mov	 r9, QWORD PTR vargs$5[rsp]
  000a9	4c 8b 44 24 78	 mov	 r8, QWORD PTR msgfmt$[rsp]
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR msgbuf$4[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf
  000bc	89 44 24 44	 mov	 DWORD PTR rc$2[rsp], eax

; 114  :         }
; 115  :         while (rc < 0 || rc >= buffsize);

  000c0	83 7c 24 44 00	 cmp	 DWORD PTR rc$2[rsp], 0
  000c5	0f 8c 7a ff ff
	ff		 jl	 $LN4@syntax
  000cb	8b 44 24 40	 mov	 eax, DWORD PTR buffsize$1[rsp]
  000cf	39 44 24 44	 cmp	 DWORD PTR rc$2[rsp], eax
  000d3	0f 8d 6c ff ff
	ff		 jge	 $LN9@syntax

; 116  : 
; 117  :         // "Syntax error: %s"
; 118  :         FWRMSG( stderr, HHC02959, "E", msgbuf );

  000d9	b9 02 00 00 00	 mov	 ecx, 2
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR msgbuf$4[rsp]
  000e9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168687
  000f5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168688
  00101	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00106	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00111	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168689
  00118	ba 76 00 00 00	 mov	 edx, 118		; 00000076H
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168690
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 119  :         free( msgbuf );

  0012a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR msgbuf$4[rsp]
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@syntax:

; 120  :     }
; 121  : 
; 122  :     // "Usage: %s [-r] [-c] [-q] [-v] infile outfile"
; 123  :     WRMSG( HHC02950, "I", pgm );

  00135	b9 01 00 00 00	 mov	 ecx, 1
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00140	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pgm$[rsp]
  00145	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168691
  00151	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168692
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168693
  00174	ba 7b 00 00 00	 mov	 edx, 123		; 0000007bH
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168694
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 124  :     return -1;

  00186	b8 ff ff ff ff	 mov	 eax, -1

; 125  : }

  0018b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018f	c3		 ret	 0
syntax	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
