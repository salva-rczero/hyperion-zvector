; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	ptp_device_hndinfo
_DATA	SEGMENT
ptp_device_hndinfo DQ FLAT:ptp_init
	DQ	FLAT:ptp_execute_ccw
	DQ	FLAT:ptp_close
	DQ	FLAT:ptp_query
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:ptp_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:ptp_immed_commands
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG171144 DB	'dev', 00H
$SG171145 DB	'mtu', 00H
ptp_immed_commands DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
$SG171146 DB	'debug', 00H
	ORG $+2
$SG171147 DB	'inet', 00H
	ORG $+3
$SG171148 DB	'inet6', 00H
	ORG $+2
$SG171149 DB	'mac', 00H
$SG171150 DB	'kbuff', 00H
	ORG $+2
$SG171151 DB	'ibuff', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VTAM_ebcdic DB	0e5H
	DB	0e3H
	DB	0c1H
	DB	0d4H
	ORG $+4
?XorConstant@?1??gen_csv_sid@@9@9 DD 0404100H		; `gen_csv_sid'::`2'::XorConstant
	DD	00H
	DD	04000H
	DD	0404101H
	DD	0404001H
	DD	04101H
	DD	01H
	DD	04000H
	DD	0100H
	DD	0404100H
	DD	0404101H
	DD	0100H
	DD	0400101H
	DD	0404001H
	DD	0400000H
	DD	01H
	DD	0101H
	DD	0400100H
	DD	0400100H
	DD	04100H
	DD	04100H
	DD	0404000H
	DD	0404000H
	DD	0400101H
	DD	04001H
	DD	0400001H
	DD	0400001H
	DD	04001H
	DD	00H
	DD	0101H
	DD	04101H
	DD	0400000H
	DD	04000H
	DD	0404101H
	DD	01H
	DD	0404000H
	DD	0404100H
	DD	0400000H
	DD	0400000H
	DD	0100H
	DD	0404001H
	DD	04000H
	DD	04100H
	DD	0400001H
	DD	0100H
	DD	01H
	DD	0400101H
	DD	04101H
	DD	0404101H
	DD	04001H
	DD	0404000H
	DD	0400101H
	DD	0400001H
	DD	0101H
	DD	04101H
	DD	0404100H
	DD	0101H
	DD	0400100H
	DD	0400100H
	DD	00H
	DD	04001H
	DD	04100H
	DD	00H
	DD	0404001H
	DD	020042008H
	DD	020002000H
	DD	02000H
	DD	042008H
	DD	040000H
	DD	08H
	DD	020040008H
	DD	020002008H
	DD	020000008H
	DD	020042008H
	DD	020042000H
	DD	020000000H
	DD	020002000H
	DD	040000H
	DD	08H
	DD	020040008H
	DD	042000H
	DD	040008H
	DD	020002008H
	DD	00H
	DD	020000000H
	DD	02000H
	DD	042008H
	DD	020040000H
	DD	040008H
	DD	020000008H
	DD	00H
	DD	042000H
	DD	02008H
	DD	020042000H
	DD	020040000H
	DD	02008H
	DD	00H
	DD	042008H
	DD	020040008H
	DD	040000H
	DD	020002008H
	DD	020040000H
	DD	020042000H
	DD	02000H
	DD	020040000H
	DD	020002000H
	DD	08H
	DD	020042008H
	DD	042008H
	DD	08H
	DD	02000H
	DD	020000000H
	DD	02008H
	DD	020042000H
	DD	040000H
	DD	020000008H
	DD	040008H
	DD	020002008H
	DD	020000008H
	DD	040008H
	DD	042000H
	DD	00H
	DD	020002000H
	DD	02008H
	DD	020000000H
	DD	020040008H
	DD	020042008H
	DD	042000H
	DD	082H
	DD	02008080H
	DD	00H
	DD	02008002H
	DD	02000080H
	DD	00H
	DD	08082H
	DD	02000080H
	DD	08002H
	DD	02000002H
	DD	02000002H
	DD	08000H
	DD	02008082H
	DD	08002H
	DD	02008000H
	DD	082H
	DD	02000000H
	DD	02H
	DD	02008080H
	DD	080H
	DD	08080H
	DD	02008000H
	DD	02008002H
	DD	08082H
	DD	02000082H
	DD	08080H
	DD	08000H
	DD	02000082H
	DD	02H
	DD	02008082H
	DD	080H
	DD	02000000H
	DD	02008080H
	DD	02000000H
	DD	08002H
	DD	082H
	DD	08000H
	DD	02008080H
	DD	02000080H
	DD	00H
	DD	080H
	DD	08002H
	DD	02008082H
	DD	02000080H
	DD	02000002H
	DD	080H
	DD	00H
	DD	02008002H
	DD	02000082H
	DD	08000H
	DD	02000000H
	DD	02008082H
	DD	02H
	DD	08082H
	DD	08080H
	DD	02000002H
	DD	02008000H
	DD	02000082H
	DD	082H
	DD	02008000H
	DD	08082H
	DD	02H
	DD	02008002H
	DD	08080H
	DD	040200800H
	DD	040000820H
	DD	040000820H
	DD	020H
	DD	0200820H
	DD	040200020H
	DD	040200000H
	DD	040000800H
	DD	00H
	DD	0200800H
	DD	0200800H
	DD	040200820H
	DD	040000020H
	DD	00H
	DD	0200020H
	DD	040200000H
	DD	040000000H
	DD	0800H
	DD	0200000H
	DD	040200800H
	DD	020H
	DD	0200000H
	DD	040000800H
	DD	0820H
	DD	040200020H
	DD	040000000H
	DD	0820H
	DD	0200020H
	DD	0800H
	DD	0200820H
	DD	040200820H
	DD	040000020H
	DD	0200020H
	DD	040200000H
	DD	0200800H
	DD	040200820H
	DD	040000020H
	DD	00H
	DD	00H
	DD	0200800H
	DD	0820H
	DD	0200020H
	DD	040200020H
	DD	040000000H
	DD	040200800H
	DD	040000820H
	DD	040000820H
	DD	020H
	DD	040200820H
	DD	040000020H
	DD	040000000H
	DD	0800H
	DD	040200000H
	DD	040000800H
	DD	0200820H
	DD	040200020H
	DD	040000800H
	DD	0820H
	DD	0200000H
	DD	040200800H
	DD	020H
	DD	0200000H
	DD	0800H
	DD	0200820H
	DD	040H
	DD	0820040H
	DD	0820000H
	DD	010800040H
	DD	020000H
	DD	040H
	DD	010000000H
	DD	0820000H
	DD	010020040H
	DD	020000H
	DD	0800040H
	DD	010020040H
	DD	010800040H
	DD	010820000H
	DD	020040H
	DD	010000000H
	DD	0800000H
	DD	010020000H
	DD	010020000H
	DD	00H
	DD	010000040H
	DD	010820040H
	DD	010820040H
	DD	0800040H
	DD	010820000H
	DD	010000040H
	DD	00H
	DD	010800000H
	DD	0820040H
	DD	0800000H
	DD	010800000H
	DD	020040H
	DD	020000H
	DD	010800040H
	DD	040H
	DD	0800000H
	DD	010000000H
	DD	0820000H
	DD	010800040H
	DD	010020040H
	DD	0800040H
	DD	010000000H
	DD	010820000H
	DD	0820040H
	DD	010020040H
	DD	040H
	DD	0800000H
	DD	010820000H
	DD	010820040H
	DD	020040H
	DD	010800000H
	DD	010820040H
	DD	0820000H
	DD	00H
	DD	010020000H
	DD	010800000H
	DD	020040H
	DD	0800040H
	DD	010000040H
	DD	020000H
	DD	00H
	DD	010020000H
	DD	0820040H
	DD	010000040H
	DD	08000004H
	DD	08100000H
	DD	01000H
	DD	08101004H
	DD	08100000H
	DD	04H
	DD	08101004H
	DD	0100000H
	DD	08001000H
	DD	0101004H
	DD	0100000H
	DD	08000004H
	DD	0100004H
	DD	08001000H
	DD	08000000H
	DD	01004H
	DD	00H
	DD	0100004H
	DD	08001004H
	DD	01000H
	DD	0101000H
	DD	08001004H
	DD	04H
	DD	08100004H
	DD	08100004H
	DD	00H
	DD	0101004H
	DD	08101000H
	DD	01004H
	DD	0101000H
	DD	08101000H
	DD	08000000H
	DD	08001000H
	DD	04H
	DD	08100004H
	DD	0101000H
	DD	08101004H
	DD	0100000H
	DD	01004H
	DD	08000004H
	DD	0100000H
	DD	08001000H
	DD	08000000H
	DD	01004H
	DD	08000004H
	DD	08101004H
	DD	0101000H
	DD	08100000H
	DD	0101004H
	DD	08101000H
	DD	00H
	DD	08100004H
	DD	04H
	DD	01000H
	DD	08100000H
	DD	0101004H
	DD	01000H
	DD	0100004H
	DD	08001004H
	DD	00H
	DD	08101000H
	DD	08000000H
	DD	0100004H
	DD	08001004H
	DD	080000H
	DD	081080000H
	DD	081000200H
	DD	00H
	DD	0200H
	DD	081000200H
	DD	080080200H
	DD	01080200H
	DD	081080200H
	DD	080000H
	DD	00H
	DD	081000000H
	DD	080000000H
	DD	01000000H
	DD	081080000H
	DD	080000200H
	DD	01000200H
	DD	080080200H
	DD	080080000H
	DD	01000200H
	DD	081000000H
	DD	01080000H
	DD	01080200H
	DD	080080000H
	DD	01080000H
	DD	0200H
	DD	080000200H
	DD	081080200H
	DD	080200H
	DD	080000000H
	DD	01000000H
	DD	080200H
	DD	01000000H
	DD	080200H
	DD	080000H
	DD	081000200H
	DD	081000200H
	DD	081080000H
	DD	081080000H
	DD	080000000H
	DD	080080000H
	DD	01000000H
	DD	01000200H
	DD	080000H
	DD	01080200H
	DD	080000200H
	DD	080080200H
	DD	01080200H
	DD	080000200H
	DD	081000000H
	DD	081080200H
	DD	01080000H
	DD	080200H
	DD	00H
	DD	080000000H
	DD	081080200H
	DD	00H
	DD	080080200H
	DD	01080000H
	DD	0200H
	DD	081000000H
	DD	01000200H
	DD	0200H
	DD	080080000H
	DD	04000410H
	DD	0400H
	DD	010000H
	DD	04010410H
	DD	04000000H
	DD	04000410H
	DD	010H
	DD	04000000H
	DD	010010H
	DD	04010000H
	DD	04010410H
	DD	010400H
	DD	04010400H
	DD	010410H
	DD	0400H
	DD	010H
	DD	04010000H
	DD	04000010H
	DD	04000400H
	DD	0410H
	DD	010400H
	DD	010010H
	DD	04010010H
	DD	04010400H
	DD	0410H
	DD	00H
	DD	00H
	DD	04010010H
	DD	04000010H
	DD	04000400H
	DD	010410H
	DD	010000H
	DD	010410H
	DD	010000H
	DD	04010400H
	DD	0400H
	DD	010H
	DD	04010010H
	DD	0400H
	DD	010410H
	DD	04000400H
	DD	010H
	DD	04000010H
	DD	04010000H
	DD	04010010H
	DD	04000000H
	DD	010000H
	DD	04000410H
	DD	00H
	DD	04010410H
	DD	010010H
	DD	04000010H
	DD	04010000H
	DD	04000400H
	DD	04000410H
	DD	00H
	DD	04010410H
	DD	010400H
	DD	010400H
	DD	0410H
	DD	0410H
	DD	010010H
	DD	04000000H
	DD	04010400H
?OrConstant@?1??gen_csv_sid@@9@9 DD 080000000H		; `gen_csv_sid'::`2'::OrConstant
	DD	040000000H
	DD	020000000H
	DD	010000000H
	DD	08000000H
	DD	04000000H
	DD	0800000H
	DD	0400000H
	DD	0200000H
	DD	0100000H
	DD	080000H
	DD	040000H
	DD	08000H
	DD	04000H
	DD	02000H
	DD	01000H
	DD	0800H
	DD	0400H
	DD	080H
	DD	040H
	DD	020H
	DD	010H
	DD	08H
	DD	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_f3_noswap
PUBLIC	store_f3_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_resolve_symbols_ep
PUBLIC	hdl_register_symbols_ep
PUBLIC	hdl_define_devtypes_ep
PUBLIC	__real@4070000000000000
PUBLIC	__real@40e0000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_htonl:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_getpid:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_timed_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_join_thread:PROC
EXTRN	__imp_hthread_detach_thread:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_gettimeofday:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_sleep:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_inet_aton:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_inet_ntop:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_etod_clock:PROC
EXTRN	tt32_read:PROC
EXTRN	tt32_write:PROC
EXTRN	tt32_close:PROC
EXTRN	tt32_ioctl:PROC
EXTRN	display_tt32_stats:PROC
EXTRN	enable_tt32_debug_tracing:PROC
EXTRN	__imp_init_sysblk_netdev:PROC
EXTRN	__imp_group_device:PROC
EXTRN	__imp_getopt_long:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	TUNTAP_CreateInterface:PROC
EXTRN	TUNTAP_SetIPAddr:PROC
EXTRN	TUNTAP_SetDestAddr:PROC
EXTRN	TUNTAP_SetNetMask:PROC
EXTRN	TUNTAP_SetIPAddr6:PROC
EXTRN	TUNTAP_SetMTU:PROC
EXTRN	TUNTAP_SetMACAddr:PROC
EXTRN	TUNTAP_SetFlags:PROC
EXTRN	ParseMAC:PROC
EXTRN	net_data_trace:PROC
EXTRN	resolve_host:PROC
EXTRN	__imp_mpc_point_pus:PROC
EXTRN	__imp_mpc_display_description:PROC
EXTRN	__imp_mpc_display_rrh:PROC
EXTRN	__imp_mpc_display_rrh_and_puk:PROC
EXTRN	__imp_mpc_display_rrh_and_pix:PROC
EXTRN	__imp_mpc_display_ptp_th_etc:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_optind:DWORD
EXTRN	__imp_optarg:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
TokenLock DQ	01H DUP (?)
TokenLockInitialized DD 01H DUP (?)
$SG170362 DB	01H DUP (?)
	ALIGN	4

$SG170367 DB	01H DUP (?)
	ALIGN	4

$SG170370 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_f3_noswap DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$fetch_f3_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$store_f3_noswap DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$store_f3_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$SetSIDInfo DD imagerel SetSIDInfo
	DD	imagerel SetSIDInfo+269
	DD	imagerel $unwind$SetSIDInfo
$pdata$ptp_init DD imagerel ptp_init
	DD	imagerel ptp_init+5108
	DD	imagerel $unwind$ptp_init
$pdata$ptp_execute_ccw DD imagerel ptp_execute_ccw
	DD	imagerel ptp_execute_ccw+1784
	DD	imagerel $unwind$ptp_execute_ccw
$pdata$ptp_close DD imagerel ptp_close
	DD	imagerel ptp_close+139
	DD	imagerel $unwind$ptp_close
$pdata$ptp_query DD imagerel ptp_query
	DD	imagerel ptp_query+1221
	DD	imagerel $unwind$ptp_query
$pdata$ptp_write DD imagerel ptp_write
	DD	imagerel ptp_write+1768
	DD	imagerel $unwind$ptp_write
$pdata$write_th DD imagerel write_th
	DD	imagerel write_th+840
	DD	imagerel $unwind$write_th
$pdata$write_rrh_8108 DD imagerel write_rrh_8108
	DD	imagerel write_rrh_8108+3142
	DD	imagerel $unwind$write_rrh_8108
$pdata$ptp_halt_or_clear DD imagerel ptp_halt_or_clear
	DD	imagerel ptp_halt_or_clear+157
	DD	imagerel $unwind$ptp_halt_or_clear
$pdata$ptp_read DD imagerel ptp_read
	DD	imagerel ptp_read+1122
	DD	imagerel $unwind$ptp_read
$pdata$read_read_buffer DD imagerel read_read_buffer
	DD	imagerel read_read_buffer+1908
	DD	imagerel $unwind$read_read_buffer
$pdata$read_chain_buffer DD imagerel read_chain_buffer
	DD	imagerel read_chain_buffer+1221
	DD	imagerel $unwind$read_chain_buffer
$pdata$ptp_read_thread DD imagerel ptp_read_thread
	DD	imagerel ptp_read_thread+4030
	DD	imagerel $unwind$ptp_read_thread
$pdata$add_buffer_to_chain_and_signal_event DD imagerel add_buffer_to_chain_and_signal_event
	DD	imagerel add_buffer_to_chain_and_signal_event+289
	DD	imagerel $unwind$add_buffer_to_chain_and_signal_event
$pdata$add_buffer_to_chain DD imagerel add_buffer_to_chain
	DD	imagerel add_buffer_to_chain+201
	DD	imagerel $unwind$add_buffer_to_chain
$pdata$remove_buffer_from_chain DD imagerel remove_buffer_from_chain
	DD	imagerel remove_buffer_from_chain+175
	DD	imagerel $unwind$remove_buffer_from_chain
$pdata$remove_and_free_any_buffers_on_chain DD imagerel remove_and_free_any_buffers_on_chain
	DD	imagerel remove_and_free_any_buffers_on_chain+160
	DD	imagerel $unwind$remove_and_free_any_buffers_on_chain
$pdata$alloc_ptp_buffer DD imagerel alloc_ptp_buffer
	DD	imagerel alloc_ptp_buffer+372
	DD	imagerel $unwind$alloc_ptp_buffer
$pdata$alloc_storage DD imagerel alloc_storage
	DD	imagerel alloc_storage+352
	DD	imagerel $unwind$alloc_storage
$pdata$parse_conf_stmt DD imagerel parse_conf_stmt
	DD	imagerel parse_conf_stmt+8073
	DD	imagerel $unwind$parse_conf_stmt
$pdata$get_preconfigured_value DD imagerel get_preconfigured_value
	DD	imagerel get_preconfigured_value+191
	DD	imagerel $unwind$get_preconfigured_value
$pdata$check_specified_value DD imagerel check_specified_value
	DD	imagerel check_specified_value+1170
	DD	imagerel $unwind$check_specified_value
$pdata$raise_unsol_int DD imagerel raise_unsol_int
	DD	imagerel raise_unsol_int+607
	DD	imagerel $unwind$raise_unsol_int
$pdata$ptp_unsol_int_thread DD imagerel ptp_unsol_int_thread
	DD	imagerel ptp_unsol_int_thread+1017
	DD	imagerel $unwind$ptp_unsol_int_thread
$pdata$ptp_get_tod_clock DD imagerel ptp_get_tod_clock
	DD	imagerel ptp_get_tod_clock+256
	DD	imagerel $unwind$ptp_get_tod_clock
$pdata$get_subarea_address DD imagerel get_subarea_address
	DD	imagerel get_subarea_address+345
	DD	imagerel $unwind$get_subarea_address
$pdata$write_hx0_01 DD imagerel write_hx0_01
	DD	imagerel write_hx0_01+1626
	DD	imagerel $unwind$write_hx0_01
$pdata$write_hx0_00 DD imagerel write_hx0_00
	DD	imagerel write_hx0_00+183
	DD	imagerel $unwind$write_hx0_00
$pdata$write_hx2 DD imagerel write_hx2
	DD	imagerel write_hx2+2686
	DD	imagerel $unwind$write_hx2
$pdata$point_CSVcv DD imagerel point_CSVcv
	DD	imagerel point_CSVcv+148
	DD	imagerel $unwind$point_CSVcv
$pdata$write_rrh_417E DD imagerel write_rrh_417E
	DD	imagerel write_rrh_417E+4576
	DD	imagerel $unwind$write_rrh_417E
$pdata$build_417E_cm_enable DD imagerel build_417E_cm_enable
	DD	imagerel build_417E_cm_enable+1697
	DD	imagerel $unwind$build_417E_cm_enable
$pdata$build_417E_cm_setup DD imagerel build_417E_cm_setup
	DD	imagerel build_417E_cm_setup+1168
	DD	imagerel $unwind$build_417E_cm_setup
$pdata$build_417E_cm_confirm DD imagerel build_417E_cm_confirm
	DD	imagerel build_417E_cm_confirm+1168
	DD	imagerel $unwind$build_417E_cm_confirm
$pdata$build_417E_ulp_enable DD imagerel build_417E_ulp_enable
	DD	imagerel build_417E_ulp_enable+1378
	DD	imagerel $unwind$build_417E_ulp_enable
$pdata$build_417E_ulp_setup DD imagerel build_417E_ulp_setup
	DD	imagerel build_417E_ulp_setup+1445
	DD	imagerel $unwind$build_417E_ulp_setup
$pdata$build_417E_ulp_confirm DD imagerel build_417E_ulp_confirm
	DD	imagerel build_417E_ulp_confirm+1445
	DD	imagerel $unwind$build_417E_ulp_confirm
$pdata$build_417E_dm_act DD imagerel build_417E_dm_act
	DD	imagerel build_417E_dm_act+808
	DD	imagerel $unwind$build_417E_dm_act
$pdata$write_rrh_C17E DD imagerel write_rrh_C17E
	DD	imagerel write_rrh_C17E+488
	DD	imagerel $unwind$write_rrh_C17E
$pdata$write_rrh_C108 DD imagerel write_rrh_C108
	DD	imagerel write_rrh_C108+8440
	DD	imagerel $unwind$write_rrh_C108
$pdata$build_C108_will_you_start_4 DD imagerel build_C108_will_you_start_4
	DD	imagerel build_C108_will_you_start_4+657
	DD	imagerel $unwind$build_C108_will_you_start_4
$pdata$build_C108_will_you_start_6 DD imagerel build_C108_will_you_start_6
	DD	imagerel build_C108_will_you_start_6+657
	DD	imagerel $unwind$build_C108_will_you_start_6
$pdata$build_C108_i_will_start_4 DD imagerel build_C108_i_will_start_4
	DD	imagerel build_C108_i_will_start_4+655
	DD	imagerel $unwind$build_C108_i_will_start_4
$pdata$build_C108_i_will_start_6 DD imagerel build_C108_i_will_start_6
	DD	imagerel build_C108_i_will_start_6+655
	DD	imagerel $unwind$build_C108_i_will_start_6
$pdata$build_C108_my_address_4 DD imagerel build_C108_my_address_4
	DD	imagerel build_C108_my_address_4+676
	DD	imagerel $unwind$build_C108_my_address_4
$pdata$build_C108_my_address_6 DD imagerel build_C108_my_address_6
	DD	imagerel build_C108_my_address_6+733
	DD	imagerel $unwind$build_C108_my_address_6
$pdata$build_C108_your_address_4 DD imagerel build_C108_your_address_4
	DD	imagerel build_C108_your_address_4+674
	DD	imagerel $unwind$build_C108_your_address_4
$pdata$build_C108_your_address_6 DD imagerel build_C108_your_address_6
	DD	imagerel build_C108_your_address_6+687
	DD	imagerel $unwind$build_C108_your_address_6
$pdata$build_C108_will_you_stop_4 DD imagerel build_C108_will_you_stop_4
	DD	imagerel build_C108_will_you_stop_4+657
	DD	imagerel $unwind$build_C108_will_you_stop_4
$pdata$build_C108_will_you_stop_6 DD imagerel build_C108_will_you_stop_6
	DD	imagerel build_C108_will_you_stop_6+657
	DD	imagerel $unwind$build_C108_will_you_stop_6
$pdata$build_C108_i_will_stop_4 DD imagerel build_C108_i_will_stop_4
	DD	imagerel build_C108_i_will_stop_4+619
	DD	imagerel $unwind$build_C108_i_will_stop_4
$pdata$build_C108_i_will_stop_6 DD imagerel build_C108_i_will_stop_6
	DD	imagerel build_C108_i_will_stop_6+619
	DD	imagerel $unwind$build_C108_i_will_stop_6
$pdata$build_8108_icmpv6_packets DD imagerel build_8108_icmpv6_packets
	DD	imagerel build_8108_icmpv6_packets+4518
	DD	imagerel $unwind$build_8108_icmpv6_packets
$pdata$gen_csv_sid DD imagerel gen_csv_sid
	DD	imagerel gen_csv_sid+40748
	DD	imagerel $unwind$gen_csv_sid
$pdata$shift_left_dbl DD imagerel shift_left_dbl
	DD	imagerel shift_left_dbl+119
	DD	imagerel $unwind$shift_left_dbl
$pdata$shift_right_dbl DD imagerel shift_right_dbl
	DD	imagerel shift_right_dbl+119
	DD	imagerel $unwind$shift_right_dbl
$pdata$calculate_icmpv6_checksum DD imagerel calculate_icmpv6_checksum
	DD	imagerel calculate_icmpv6_checksum+610
	DD	imagerel $unwind$calculate_icmpv6_checksum
$pdata$hdl_check_depends_ep DD imagerel $LN19
	DD	imagerel $LN19+194
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_register_symbols_ep DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$hdl_register_symbols_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
;	COMDAT __real@40e0000000000000
CONST	SEGMENT
__real@40e0000000000000 DQ 040e0000000000000r	; 32768
CONST	ENDS
;	COMDAT __real@4070000000000000
CONST	SEGMENT
__real@4070000000000000 DQ 04070000000000000r	; 256
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
uTokenIssuerRm DD 011001H
uTokenCmFilter DD 011002H
uTokenCmConnection DD 011003H
uTokenUlpFilter DD 011004H
uTokenUlpConnection DD 011005H
$SG170099 DB	'ctc_ptp.c:360', 00H
	ORG $+2
$SG170100 DB	'&TokenLock', 00H
	ORG $+1
$SG170126 DB	'TUN', 00H
$SG170106 DB	'ctc_ptp.c:460', 00H
	ORG $+2
$SG170107 DB	'&pPTPBLK->ReadBufferLock', 00H
	ORG $+3
$SG170127 DB	'I', 00H
	ORG $+2
$SG170108 DB	'ctc_ptp.c:461', 00H
	ORG $+2
$SG170109 DB	'&pPTPBLK->ReadEventLock', 00H
$SG170110 DB	'ctc_ptp.c:462', 00H
	ORG $+2
$SG170111 DB	'ctc_ptp.c:463', 00H
	ORG $+2
$SG170112 DB	'&pPTPBLK->UnsolListLock', 00H
$SG170113 DB	'ctc_ptp.c:464', 00H
	ORG $+2
$SG170114 DB	'&pPTPBLK->UpdateLock', 00H
	ORG $+3
$SG170115 DB	'ctc_ptp.c:466', 00H
	ORG $+2
$SG170116 DB	'&pPTPATHre->ChainLock', 00H
	ORG $+2
$SG170117 DB	'ctc_ptp.c:467', 00H
	ORG $+2
$SG170118 DB	'&pPTPATHre->UnsolEventLock', 00H
	ORG $+1
$SG170134 DB	'W', 00H
	ORG $+2
$SG170119 DB	'ctc_ptp.c:468', 00H
	ORG $+2
$SG170120 DB	'ctc_ptp.c:470', 00H
	ORG $+2
$SG170121 DB	'&pPTPATHwr->ChainLock', 00H
	ORG $+2
$SG170122 DB	'ctc_ptp.c:471', 00H
	ORG $+2
$SG170123 DB	'&pPTPATHwr->UnsolEventLock', 00H
	ORG $+1
$SG170140 DB	'W', 00H
	ORG $+2
$SG170124 DB	'ctc_ptp.c:472', 00H
	ORG $+2
$SG170128 DB	'HHC00901%s %1d:%04X %s: Interface %s, type %s opened', 0aH
	DB	00H
	ORG $+2
$SG170129 DB	'ptp_init', 00H
	ORG $+3
$SG170221 DB	'E', 00H
	ORG $+2
$SG170130 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170235 DB	'D', 00H
	ORG $+2
$SG170133 DB	'TT32SDEVBUFF', 00H
	ORG $+3
$SG170135 DB	'HHC00902%s %1d:%04X %s: ioctl %s failed for device %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170240 DB	'D', 00H
	ORG $+2
$SG170136 DB	'ptp_init', 00H
	ORG $+3
$SG170245 DB	'D', 00H
	ORG $+2
$SG170137 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170288 DB	'D', 00H
	ORG $+2
$SG170139 DB	'TT32SIOBUFF', 00H
$SG170306 DB	'D', 00H
	ORG $+2
$SG170141 DB	'HHC00902%s %1d:%04X %s: ioctl %s failed for device %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170344 DB	'.', 00H
	ORG $+2
$SG170142 DB	'ptp_init', 00H
	ORG $+3
$SG170349 DB	'-', 00H
	ORG $+2
$SG170143 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170352 DB	'-', 00H
	ORG $+2
$SG170145 DB	'ptp_init', 00H
	ORG $+3
$SG170355 DB	'-', 00H
	ORG $+2
$SG170146 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170147 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170149 DB	'ptp_init', 00H
	ORG $+3
$SG170358 DB	'-', 00H
	ORG $+2
$SG170150 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170218 DB	'%s %4.4X ReadThread', 00H
	ORG $+4
$SG170151 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170155 DB	'ptp_init', 00H
	ORG $+3
$SG170361 DB	' -d', 00H
$SG170156 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170219 DB	'ctc_ptp.c:577', 00H
	ORG $+2
$SG170222 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG170157 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170159 DB	'ptp_init', 00H
	ORG $+3
$SG170366 DB	' -d', 00H
$SG170160 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170236 DB	'HHC03952%s %1d:%04X PTP: MAC: %s', 0aH, 00H
	ORG $+6
$SG170161 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170164 DB	'ptp_init', 00H
	ORG $+3
$SG170369 DB	' -d', 00H
$SG170165 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170241 DB	'HHC03953%s %1d:%04X PTP: IPv4: Drive %s/%s (%s): Guest %'
	DB	's', 0aH, 00H
	ORG $+5
$SG170246 DB	'HHC03954%s %1d:%04X PTP: IPv6: Drive %s/%s %s/%s: Guest '
	DB	'%s', 0aH, 00H
$SG170338 DB	'CTCA', 00H
	ORG $+7
$SG170166 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170168 DB	'ptp_init', 00H
	ORG $+3
$SG170403 DB	'D', 00H
	ORG $+2
$SG170169 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170290 DB	'ptp_execute_ccw', 00H
$SG170408 DB	'D', 00H
	ORG $+6
$SG170170 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170173 DB	'ptp_init', 00H
	ORG $+3
$SG170416 DB	'D', 00H
	ORG $+2
$SG170174 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170307 DB	'HHC03993%s %1d:%04X %s: Status %02X: Residual %08X: More'
	DB	' %02X', 0aH, 00H
	ORG $+1
$SG170308 DB	'ptp_execute_ccw', 00H
$SG170412 DB	'data', 00H
	ORG $+3
$SG170175 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170177 DB	'ptp_init', 00H
	ORG $+3
$SG170426 DB	'W', 00H
	ORG $+2
$SG170178 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170318 DB	'ctc_ptp.c:863', 00H
	ORG $+2
$SG170346 DB	'*Uninitialized', 00H
	ORG $+1
$SG170436 DB	'data', 00H
	ORG $+3
$SG170179 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170183 DB	'ptp_init', 00H
	ORG $+3
$SG170432 DB	'I', 00H
	ORG $+2
$SG170184 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170319 DB	'ctc_ptp.c:865', 00H
	ORG $+2
$SG170363 DB	'%s %s/%s %s/%s (%s)%s IO[%llu]', 00H
	ORG $+1
$SG170491 DB	'RRH', 00H
	ORG $+4
$SG170185 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170187 DB	'ptp_init', 00H
	ORG $+3
$SG170492 DB	'W', 00H
	ORG $+2
$SG170188 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170554 DB	' IPv4', 00H
	ORG $+6
$SG170189 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170192 DB	'ptp_init', 00H
	ORG $+3
$SG170557 DB	' IPv6', 00H
	ORG $+2
$SG170558 DB	'W', 00H
	ORG $+2
$SG170193 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170194 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170196 DB	'ptp_init', 00H
	ORG $+3
$SG170563 DB	'I', 00H
	ORG $+2
$SG170197 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170560 DB	'write_rrh_8108', 00H
	ORG $+1
$SG170567 DB	'data', 00H
	ORG $+3
$SG170198 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170201 DB	'ptp_init', 00H
	ORG $+3
$SG170576 DB	'W', 00H
	ORG $+2
$SG170202 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170565 DB	'write_rrh_8108', 00H
	ORG $+1
$SG170585 DB	'data', 00H
	ORG $+3
$SG170203 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170205 DB	'ptp_init', 00H
	ORG $+3
$SG170581 DB	'I', 00H
	ORG $+2
$SG170206 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170578 DB	'write_rrh_8108', 00H
	ORG $+1
$SG170596 DB	'data', 00H
	ORG $+3
$SG170207 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170210 DB	'ptp_init', 00H
	ORG $+3
$SG170587 DB	'W', 00H
	ORG $+2
$SG170211 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170583 DB	'write_rrh_8108', 00H
	ORG $+1
$SG170607 DB	'packet', 00H
	ORG $+1
$SG170212 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170214 DB	'ptp_init', 00H
	ORG $+3
$SG170592 DB	'I', 00H
	ORG $+2
$SG170215 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170589 DB	'write_rrh_8108', 00H
	ORG $+1
$SG170667 DB	'HHC00904%s %1d:%04X %s: Halt or clear recognized', 0aH, 00H
	ORG $+6
$SG170216 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170223 DB	'ptp_init', 00H
	ORG $+3
$SG170603 DB	'D', 00H
	ORG $+2
$SG170224 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170609 DB	'E', 00H
	ORG $+2
$SG170226 DB	'ptp_init', 00H
	ORG $+3
$SG170666 DB	'I', 00H
	ORG $+2
$SG170227 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170594 DB	'write_rrh_8108', 00H
	ORG $+1
$SG170748 DB	'read_read_buffer', 00H
	ORG $+7
$SG170228 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170230 DB	'ptp_init', 00H
	ORG $+3
$SG170746 DB	'D', 00H
	ORG $+2
$SG170231 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170605 DB	'write_rrh_8108', 00H
	ORG $+1
$SG170753 DB	'read_read_buffer', 00H
	ORG $+7
$SG170232 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170237 DB	'ptp_init', 00H
	ORG $+3
$SG170751 DB	'D', 00H
	ORG $+2
$SG170238 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170756 DB	'D', 00H
	ORG $+2
$SG170242 DB	'ptp_init', 00H
	ORG $+3
$SG170794 DB	'D', 00H
	ORG $+2
$SG170243 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170799 DB	'D', 00H
	ORG $+2
$SG170247 DB	'ptp_init', 00H
	ORG $+3
$SG170804 DB	'D', 00H
	ORG $+2
$SG170248 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170610 DB	'HHC00911%s %1d:%04X %s: Error writing to device %s: %d %'
	DB	's', 0aH, 00H
	ORG $+5
$SG170611 DB	'write_rrh_8108', 00H
	ORG $+1
$SG170758 DB	'read_read_buffer', 00H
	ORG $+7
$SG170289 DB	'HHC03992%s %1d:%04X %s: Code %02X: Flags %02X: Count %08'
	DB	'X: Chained %02X: PrevCode %02X: CCWseq %d', 0aH, 00H
	ORG $+1
$SG170892 DB	'E', 00H
	ORG $+2
$SG170291 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170903 DB	'W', 00H
	ORG $+2
$SG170309 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170908 DB	'I', 00H
	ORG $+2
$SG170368 DB	'%s %s/%s (%s)%s IO[%llu]', 00H
	ORG $+3
$SG170899 DB	' IPv4', 00H
	ORG $+2
$SG170920 DB	'W', 00H
	ORG $+2
$SG170371 DB	'%s %s/%s (%s)%s IO[%llu]', 00H
	ORG $+7
$SG170404 DB	'HHC00981%s %1d:%04X %s: Accept data of size %d bytes fro'
	DB	'm guest', 0aH, 00H
	ORG $+3
$SG170902 DB	' IPv6', 00H
	ORG $+2
$SG170925 DB	'I', 00H
	ORG $+2
$SG170405 DB	'ptp_write', 00H
	ORG $+2
$SG170941 DB	'W', 00H
	ORG $+2
$SG170406 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170409 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170410 DB	'ptp_write', 00H
	ORG $+2
$SG170946 DB	'I', 00H
	ORG $+2
$SG170411 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170417 DB	'HHC00981%s %1d:%04X %s: Accept data of size %d bytes fro'
	DB	'm guest', 0aH, 00H
	ORG $+3
$SG170953 DB	'W', 00H
	ORG $+2
$SG170418 DB	'ptp_write', 00H
	ORG $+2
$SG170958 DB	'I', 00H
	ORG $+2
$SG170419 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170619 DB	'ctc_ptp.c:1500', 00H
	ORG $+1
$SG170760 DB	'data', 00H
	ORG $+3
$SG170427 DB	'HHC03931%s %1d:%04X PTP: Accept data of size %d bytes co'
	DB	'ntains unknown data', 0aH, 00H
	ORG $+3
$SG170428 DB	'ptp_write', 00H
	ORG $+2
$SG170967 DB	'D', 00H
	ORG $+2
$SG170429 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170433 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170434 DB	'ptp_write', 00H
	ORG $+2
$SG170971 DB	'packet', 00H
	ORG $+1
$SG171050 DB	'E', 00H
	ORG $+2
$SG170435 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171065 DB	'E', 00H
	ORG $+2
$SG170493 DB	'HHC03936%s %1d:%04X PTP: Accept data contains unknown %s'
	DB	0aH, 00H
	ORG $+2
$SG171138 DB	'5', 00H
	ORG $+2
$SG170494 DB	'write_th', 00H
	ORG $+3
$SG171140 DB	'32', 00H
	ORG $+1
$SG170495 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170621 DB	'ctc_ptp.c:1505', 00H
	ORG $+1
$SG170796 DB	'read_chain_buffer', 00H
	ORG $+6
$SG170559 DB	'HHC03933%s %1d:%04X PTP: Accept data for device %s conta'
	DB	'ins IP packet with unknown IP version, data dropped', 0aH, 00H
	ORG $+3
$SG170561 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170564 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170566 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170577 DB	'HHC03934%s %1d:%04X PTP: Accept data for device %s conta'
	DB	'ins incomplete IP packet, data dropped', 0aH, 00H
$SG170579 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170582 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170584 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170588 DB	'HHC03935%s %1d:%04X PTP: Accept data for device %s conta'
	DB	'ins IP packet larger than MTU, data dropped', 0aH, 00H
	ORG $+3
$SG170590 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170622 DB	'ctc_ptp.c:1508', 00H
	ORG $+1
$SG170801 DB	'read_chain_buffer', 00H
	ORG $+6
$SG170593 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170595 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170604 DB	'HHC00910%s %1d:%04X %s: Send%s packet of size %d bytes t'
	DB	'o device %s', 0aH, 00H
	ORG $+3
$SG170606 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171142 DB	'128', 00H
$SG170612 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171143 DB	'64', 00H
	ORG $+1
$SG170656 DB	'ctc_ptp.c:1567', 00H
	ORG $+1
$SG170658 DB	'ctc_ptp.c:1577', 00H
	ORG $+1
$SG170659 DB	'ctc_ptp.c:1582', 00H
	ORG $+1
$SG170660 DB	'ctc_ptp.c:1592', 00H
	ORG $+1
$SG170661 DB	'ctc_ptp.c:1598', 00H
	ORG $+1
$SG170663 DB	'ctc_ptp.c:1609', 00H
	ORG $+1
$SG170668 DB	'ptp_read', 00H
	ORG $+3
$SG171158 DB	'E', 00H
	ORG $+2
$SG170669 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170806 DB	'read_chain_buffer', 00H
	ORG $+6
$SG170747 DB	'HHC00982%s %1d:%04X %s: Present data of size %d bytes to'
	DB	' guest', 0aH, 00H
$SG170749 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170752 DB	'HHC00982%s %1d:%04X %s: Present data of size %d bytes to'
	DB	' guest', 0aH, 00H
$SG170754 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170757 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170759 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170795 DB	'HHC00982%s %1d:%04X %s: Present data of size %d bytes to'
	DB	' guest', 0aH, 00H
$SG170797 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170800 DB	'HHC00982%s %1d:%04X %s: Present data of size %d bytes to'
	DB	' guest', 0aH, 00H
$SG170802 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170805 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170807 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG170808 DB	'data', 00H
	ORG $+3
$SG171164 DB	'E', 00H
	ORG $+2
$SG170881 DB	'ptp_read_thread', 00H
$SG170882 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170885 DB	'ptp_read_thread', 00H
$SG170912 DB	'data', 00H
	ORG $+3
$SG170883 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170886 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170893 DB	'HHC00912%s %1d:%04X %s: Error reading from device %s: %d'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG170894 DB	'ptp_read_thread', 00H
$SG170929 DB	'data', 00H
	ORG $+3
$SG170887 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170895 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170905 DB	'ptp_read_thread', 00H
$SG170950 DB	'data', 00H
	ORG $+3
$SG170904 DB	'HHC03921%s %1d:%04X PTP: Packet of size %d bytes from de'
	DB	'vice %s has an unknown IP version, packet dropped', 0aH, 00H
	ORG $+1
$SG171172 DB	'E', 00H
	ORG $+2
$SG170906 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170909 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170910 DB	'ptp_read_thread', 00H
$SG170911 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170921 DB	'HHC03922%s %1d:%04X PTP: Packet of size %d bytes from de'
	DB	'vice %s is not equal to the packet length of %d bytes, packet'
	DB	' dropped', 0aH, 00H
	ORG $+1
$SG170922 DB	'ptp_read_thread', 00H
$SG170923 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170926 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170927 DB	'ptp_read_thread', 00H
$SG170928 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171182 DB	'W', 00H
	ORG $+2
$SG170930 DB	'ctc_ptp.c:2179', 00H
	ORG $+1
$SG170934 DB	'ctc_ptp.c:2187', 00H
	ORG $+1
$SG170936 DB	'ctc_ptp.c:2196', 00H
	ORG $+1
$SG170938 DB	'ctc_ptp.c:2206', 00H
	ORG $+1
$SG170940 DB	'ctc_ptp.c:2215', 00H
	ORG $+1
$SG170942 DB	'HHC03923%s %1d:%04X PTP: Packet of size %d bytes from de'
	DB	'vice %s is larger than the guests actual MTU of %d bytes, pac'
	DB	'ket dropped', 0aH, 00H
	ORG $+2
$SG171192 DB	'E', 00H
	ORG $+2
$SG170943 DB	'ptp_read_thread', 00H
$SG170944 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170948 DB	'ptp_read_thread', 00H
$SG170962 DB	'data', 00H
	ORG $+3
$SG170947 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170949 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171200 DB	'E', 00H
	ORG $+2
$SG170952 DB	'ctc_ptp.c:2237', 00H
	ORG $+1
$SG170954 DB	'HHC03924%s %1d:%04X PTP: Packet of size %d bytes from de'
	DB	'vice %s is too large for read buffer area of %d bytes, packet'
	DB	' dropped', 0aH, 00H
	ORG $+1
$SG170955 DB	'ptp_read_thread', 00H
$SG170956 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170959 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170960 DB	'ptp_read_thread', 00H
$SG170961 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171208 DB	'E', 00H
	ORG $+2
$SG170965 DB	'ctc_ptp.c:2261', 00H
	ORG $+1
$SG170968 DB	'HHC00913%s %1d:%04X %s: Receive%s packet of size %d byte'
	DB	's from device %s', 0aH, 00H
	ORG $+2
$SG171213 DB	'E', 00H
	ORG $+2
$SG170969 DB	'ptp_read_thread', 00H
$SG170970 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171220 DB	'E', 00H
	ORG $+2
$SG170972 DB	'ctc_ptp.c:2295', 00H
	ORG $+1
$SG170973 DB	'ctc_ptp.c:2298', 00H
	ORG $+1
$SG170974 DB	'ctc_ptp.c:2299', 00H
	ORG $+1
$SG170975 DB	'ctc_ptp.c:2300', 00H
	ORG $+1
$SG170977 DB	'ptp_read_thread', 00H
$SG170978 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170979 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170981 DB	'ptp_read_thread', 00H
$SG170982 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG170995 DB	'ctc_ptp.c:2337', 00H
	ORG $+1
$SG171051 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+6
$SG170983 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170998 DB	'ctc_ptp.c:2354', 00H
	ORG $+1
$SG170999 DB	'ctc_ptp.c:2357', 00H
	ORG $+1
$SG171000 DB	'ctc_ptp.c:2358', 00H
	ORG $+1
$SG171001 DB	'ctc_ptp.c:2359', 00H
	ORG $+1
$SG171011 DB	'ctc_ptp.c:2377', 00H
	ORG $+1
$SG171014 DB	'ctc_ptp.c:2394', 00H
	ORG $+1
$SG171021 DB	'ctc_ptp.c:2409', 00H
	ORG $+1
$SG171024 DB	'ctc_ptp.c:2429', 00H
	ORG $+1
$SG171036 DB	'ctc_ptp.c:2444', 00H
	ORG $+1
$SG171037 DB	'ctc_ptp.c:2460', 00H
	ORG $+1
$SG171049 DB	'malloc(%n)', 00H
	ORG $+1
$SG171227 DB	'E', 00H
	ORG $+2
$SG171052 DB	'alloc_ptp_buffer', 00H
	ORG $+3
$SG171242 DB	'E', 00H
	ORG $+2
$SG171053 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171250 DB	'I', 00H
	ORG $+2
$SG171064 DB	'malloc(%n)', 00H
	ORG $+1
$SG171255 DB	'E', 00H
	ORG $+2
$SG171066 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG171260 DB	'E', 00H
	ORG $+2
$SG171067 DB	'alloc_storage', 00H
	ORG $+2
$SG171068 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171139 DB	'1500', 00H
	ORG $+7
?options@?3??parse_conf_stmt@@9@9 DQ FLAT:$SG171144	; `parse_conf_stmt'::`4'::options
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06eH
	ORG $+4
	DQ	FLAT:$SG171145
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	074H
	ORG $+4
	DQ	FLAT:$SG171146
	DD	02H
	ORG $+4
	DQ	0000000000000000H
	DD	064H
	ORG $+4
	DQ	FLAT:$SG171147
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	034H
	ORG $+4
	DQ	FLAT:$SG171148
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	036H
	ORG $+4
	DQ	FLAT:$SG171149
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06dH
	ORG $+4
	DQ	FLAT:$SG171150
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06bH
	ORG $+4
	DQ	FLAT:$SG171151
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	069H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
$SG171141 DB	'255.255.255.255', 00H
$SG171152 DB	'n:t:d::46m:k:i:', 00H
$SG171157 DB	'adapter address', 00H
$SG171159 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171267 DB	'E', 00H
	ORG $+2
$SG171160 DB	'parse_conf_stmt', 00H
$SG171161 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171275 DB	'E', 00H
	ORG $+2
$SG171163 DB	'device name', 00H
$SG171286 DB	'E', 00H
	ORG $+2
$SG171165 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171293 DB	'E', 00H
	ORG $+2
$SG171166 DB	'parse_conf_stmt', 00H
$SG171167 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171302 DB	'E', 00H
	ORG $+2
$SG171171 DB	'MTU size', 00H
	ORG $+3
$SG171309 DB	'E', 00H
	ORG $+2
$SG171173 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171331 DB	'E', 00H
	ORG $+2
$SG171174 DB	'parse_conf_stmt', 00H
$SG171175 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171348 DB	'E', 00H
	ORG $+2
$SG171181 DB	'debug mask', 00H
	ORG $+1
$SG171353 DB	'E', 00H
	ORG $+2
$SG171183 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171360 DB	'E', 00H
	ORG $+2
$SG171184 DB	'parse_conf_stmt', 00H
$SG171185 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171365 DB	'W', 00H
	ORG $+2
$SG171191 DB	'MAC address', 00H
$SG171393 DB	'E', 00H
	ORG $+2
$SG171193 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171400 DB	'E', 00H
	ORG $+2
$SG171194 DB	'parse_conf_stmt', 00H
$SG171195 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171430 DB	'D', 00H
	ORG $+2
$SG171199 DB	'kernel buffer size', 00H
	ORG $+1
$SG171494 DB	'I', 00H
	ORG $+2
$SG171201 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171499 DB	'I', 00H
	ORG $+2
$SG171202 DB	'parse_conf_stmt', 00H
$SG171203 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171487 DB	'In HX0', 00H
	ORG $+1
$SG171504 DB	'I', 00H
	ORG $+2
$SG171207 DB	'dll i/o buffer size', 00H
$SG171626 DB	'W', 00H
	ORG $+2
$SG171209 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171637 DB	'I', 00H
	ORG $+2
$SG171210 DB	'parse_conf_stmt', 00H
$SG171211 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171214 DB	'HHC00918%s %1d:%04X %s: Option %s unknown or specified i'
	DB	'ncorrectly', 0aH, 00H
$SG171641 DB	'I', 00H
	ORG $+2
$SG171215 DB	'parse_conf_stmt', 00H
$SG171216 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171540 DB	'In HX0', 00H
	ORG $+1
$SG171738 DB	'W', 00H
	ORG $+2
$SG171221 DB	'HHC00915%s %1d:%04X %s: Incorrect number of parameters', 0aH
	DB	00H
$SG171222 DB	'parse_conf_stmt', 00H
$SG171223 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171620 DB	'In HX2', 00H
	ORG $+1
$SG171745 DB	'W', 00H
	ORG $+2
$SG171226 DB	'IP address', 00H
	ORG $+1
$SG171756 DB	'W', 00H
	ORG $+2
$SG171228 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171766 DB	'W', 00H
	ORG $+2
$SG171229 DB	'parse_conf_stmt', 00H
$SG171230 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171736 DB	'PUS_01', 00H
	ORG $+1
$SG171782 DB	'W', 00H
	ORG $+2
$SG171241 DB	'IP address', 00H
	ORG $+1
$SG171789 DB	'W', 00H
	ORG $+2
$SG171243 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171800 DB	'W', 00H
	ORG $+2
$SG171244 DB	'parse_conf_stmt', 00H
$SG171245 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171743 DB	'PUS_02', 00H
	ORG $+1
$SG171810 DB	'W', 00H
	ORG $+2
$SG171249 DB	'Prefix size specification moved from guest to drive', 00H
$SG171824 DB	'I', 00H
	ORG $+2
$SG171251 DB	'HHC03991%s %1d:%04X %s: %s', 0aH, 00H
$SG171829 DB	'I', 00H
	ORG $+2
$SG171252 DB	'parse_conf_stmt', 00H
$SG171253 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171754 DB	'PUS_04', 00H
	ORG $+1
$SG171834 DB	'I', 00H
	ORG $+2
$SG171254 DB	'IP address', 00H
	ORG $+1
$SG171839 DB	'PUK', 00H
$SG171256 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG171840 DB	'W', 00H
	ORG $+2
$SG171257 DB	'parse_conf_stmt', 00H
$SG171258 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171764 DB	'PUS_08', 00H
	ORG $+1
$SG172163 DB	'PUK', 00H
$SG171259 DB	'IP address', 00H
	ORG $+1
$SG172164 DB	'W', 00H
	ORG $+2
$SG171261 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG172258 DB	'I', 00H
	ORG $+2
$SG171262 DB	'parse_conf_stmt', 00H
$SG171263 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171780 DB	'PUS_01', 00H
	ORG $+1
$SG172266 DB	'I', 00H
	ORG $+2
$SG171266 DB	'IP address', 00H
	ORG $+1
$SG172272 DB	'I', 00H
	ORG $+2
$SG171268 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG172287 DB	'E', 00H
	ORG $+2
$SG171269 DB	'parse_conf_stmt', 00H
$SG171270 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171787 DB	'PUS_02', 00H
	ORG $+1
$SG172295 DB	'E', 00H
	ORG $+2
$SG171274 DB	'IP address', 00H
	ORG $+1
$SG172302 DB	'I', 00H
	ORG $+2
$SG171276 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG172319 DB	'E', 00H
	ORG $+2
$SG171277 DB	'parse_conf_stmt', 00H
$SG171278 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171798 DB	'PUS_04', 00H
	ORG $+1
$SG172327 DB	'W', 00H
	ORG $+2
$SG171285 DB	'prefix size', 00H
$SG172336 DB	'I', 00H
	ORG $+2
$SG171287 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG172342 DB	'I', 00H
	ORG $+2
$SG171288 DB	'parse_conf_stmt', 00H
$SG171289 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG171808 DB	'PUS_08', 00H
	ORG $+1
$SG172351 DB	'I', 00H
	ORG $+2
$SG171292 DB	'prefix size', 00H
$SG172362 DB	'I', 00H
	ORG $+2
$SG171294 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG172368 DB	'I', 00H
	ORG $+2
$SG171295 DB	'parse_conf_stmt', 00H
$SG171296 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG172388 DB	'I', 00H
	ORG $+2
$SG171301 DB	'prefix size', 00H
$SG172397 DB	'I', 00H
	ORG $+2
$SG171303 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG172403 DB	'I', 00H
	ORG $+2
$SG171304 DB	'parse_conf_stmt', 00H
$SG171305 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG172408 DB	'PIX', 00H
$SG171308 DB	'prefix size', 00H
$SG172409 DB	'W', 00H
	ORG $+2
$SG171310 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG173040 DB	'PTP', 00H
$SG171311 DB	'parse_conf_stmt', 00H
$SG171312 DB	'ctc_ptp.c', 00H
	ORG $+2
$SG173014 DB	'DEVBLK', 00H
	ORG $+5
$SG171325 DB	'%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X', 00H
$SG171369 DB	'1280', 00H
	ORG $+7
$SG171332 DB	'HHC03965%s %id:%04X %s: Preconfigured interface %s does '
	DB	'not exist or is not accessible by Hercules', 0aH, 00H
	ORG $+4
$SG171333 DB	'get_preconfigured_value', 00H
$SG171334 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171349 DB	'HHC03901%s %1d:%04X PTP: Guest and driver IP addresses a'
	DB	're the same', 0aH, 00H
	ORG $+3
$SG171350 DB	'check_specified_value', 00H
	ORG $+2
$SG171351 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171354 DB	'HHC03901%s %1d:%04X PTP: Guest and driver IP addresses a'
	DB	're the same', 0aH, 00H
	ORG $+3
$SG171355 DB	'check_specified_value', 00H
	ORG $+2
$SG171356 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171361 DB	'HHC03902%s %1d:%04X PTP: Inet6 not supported', 0aH, 00H
	ORG $+2
$SG171362 DB	'check_specified_value', 00H
	ORG $+2
$SG171363 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171367 DB	'check_specified_value', 00H
	ORG $+2
$SG171366 DB	'HHC03918%s %1d:%04X PTP: MTU changed from size %d bytes '
	DB	'to size %d bytes', 0aH, 00H
	ORG $+6
$SG171368 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171387 DB	'ctc_ptp.c:3784', 00H
	ORG $+1
$SG171389 DB	'ctc_ptp.c:3795', 00H
	ORG $+1
$SG171392 DB	'No storage available!', 00H
	ORG $+2
$SG171394 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG171395 DB	'raise_unsol_int', 00H
$SG171396 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171397 DB	'%s %4.4X UnsolIntThread', 00H
$SG171398 DB	'ctc_ptp.c:3821', 00H
	ORG $+1
$SG171401 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG171402 DB	'raise_unsol_int', 00H
$SG171403 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171426 DB	'ctc_ptp.c:3874', 00H
	ORG $+1
$SG171427 DB	'ctc_ptp.c:3879', 00H
	ORG $+1
$SG171428 DB	'ctc_ptp.c:3882', 00H
	ORG $+1
$SG171431 DB	'HHC03994%s %1d:%04X %s: Status %02X', 0aH, 00H
	ORG $+3
$SG171432 DB	'ptp_unsol_int_thread', 00H
	ORG $+3
$SG171433 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171436 DB	'ctc_ptp.c:3919', 00H
	ORG $+1
$SG171437 DB	'ctc_ptp.c:3924', 00H
	ORG $+1
$SG171438 DB	'ctc_ptp.c:3927', 00H
	ORG $+1
$SG171440 DB	'ctc_ptp.c:3937', 00H
	ORG $+1
$SG171441 DB	'ctc_ptp.c:3944', 00H
	ORG $+1
$SG171448 DB	'ctc_ptp.c:3962', 00H
	ORG $+1
$SG171449 DB	'ctc_ptp.c:3968', 00H
	ORG $+1
$SG171458 DB	'ctc_ptp.c:3998', 00H
	ORG $+1
$SG171459 DB	'ctc_ptp.c:4002', 00H
	ORG $+1
$SG171490 DB	'ctc_ptp.c:4060', 00H
	ORG $+1
$SG171495 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG171496 DB	'write_hx0_01', 00H
	ORG $+3
$SG171497 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171501 DB	'write_hx0_01', 00H
	ORG $+3
$SG171508 DB	'ctc_ptp.c:4099', 00H
	ORG $+1
$SG171661 DB	'Out HX0', 00H
$SG171500 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG171502 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171506 DB	'write_hx0_01', 00H
	ORG $+3
$SG171509 DB	'ctc_ptp.c:4116', 00H
	ORG $+1
$SG171662 DB	'Out HX2', 00H
$SG171505 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG171507 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171512 DB	'ctc_ptp.c:4149', 00H
	ORG $+1
$SG171624 DB	'ctc_ptp.c:4289', 00H
	ORG $+1
$SG171737 DB	'PUK (CM_ENABLE)', 00H
$SG171765 DB	'PUK (CM_CONFIRM)', 00H
	ORG $+7
$SG171627 DB	'HHC03917%s %1d:%04X PTP: Guest read and write paths mis-'
	DB	'configured', 0aH, 00H
	ORG $+4
$SG171628 DB	'write_hx2', 00H
	ORG $+6
$SG171629 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171632 DB	'ctc_ptp.c:4316', 00H
	ORG $+1
$SG171636 DB	'ctc_ptp.c:4376', 00H
	ORG $+1
$SG171744 DB	'PUK (CM_ENABLE)', 00H
$SG171781 DB	'PUK (ULP_ENABLE)', 00H
	ORG $+7
$SG171638 DB	'HHC03910%s %1d:%04X PTP: Hercules has maximum read lengt'
	DB	'h of size %d bytes and actual MTU of size %d bytes', 0aH, 00H
	ORG $+4
$SG171639 DB	'write_hx2', 00H
	ORG $+6
$SG171640 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171642 DB	'HHC03911%s %1d:%04X PTP: Guest has maximum read length o'
	DB	'f size %d bytes and actual MTU of size %d bytes', 0aH, 00H
	ORG $+7
$SG171643 DB	'write_hx2', 00H
	ORG $+6
$SG171644 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171645 DB	'ctc_ptp.c:4411', 00H
	ORG $+1
$SG171734 DB	'In RRH 0x417E (Issuer) PUK 0x4102 (CM_ENABLE)', 00H
	ORG $+2
$SG171739 DB	'HHC03937%s %1d:%04X PTP: Accept data contains %s that do'
	DB	'es not contain expected %s', 0aH, 00H
	ORG $+4
$SG171740 DB	'write_rrh_417E', 00H
	ORG $+1
$SG171741 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171747 DB	'write_rrh_417E', 00H
	ORG $+1
$SG171775 DB	'In RRH 0x417E (Issuer) PUK 0x4105 (CM_TAKEDOWN)', 00H
$SG171788 DB	'PUK (ULP_ENABLE)', 00H
	ORG $+7
$SG171746 DB	'HHC03937%s %1d:%04X PTP: Accept data contains %s that do'
	DB	'es not contain expected %s', 0aH, 00H
	ORG $+4
$SG171748 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171752 DB	'In RRH 0x417E (Issuer) PUK 0x4104 (CM_SETUP)', 00H
	ORG $+3
$SG171755 DB	'PUK (CM_SETUP)', 00H
	ORG $+1
$SG171799 DB	'PUK (ULP_SETUP)', 00H
$SG171809 DB	'PUK (ULP_CONFIRM)', 00H
	ORG $+6
$SG171757 DB	'HHC03937%s %1d:%04X PTP: Accept data contains %s that do'
	DB	'es not contain expected %s', 0aH, 00H
	ORG $+4
$SG171758 DB	'write_rrh_417E', 00H
	ORG $+1
$SG171759 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171762 DB	'In RRH 0x417E (Issuer) PUK 0x4106 (CM_CONFIRM)', 00H
	ORG $+1
$SG171806 DB	'In RRH 0x417E (CmComm) PUK 0x4106 (ULP_CONFIRM)', 00H
$SG171822 DB	'In RRH 0x417E (CmComm) PUK 0x4105 (ULP_TAKEDOWN)', 00H
	ORG $+7
$SG171767 DB	'HHC03937%s %1d:%04X PTP: Accept data contains %s that do'
	DB	'es not contain expected %s', 0aH, 00H
	ORG $+4
$SG171768 DB	'write_rrh_417E', 00H
	ORG $+1
$SG171769 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171772 DB	'In RRH 0x417E (Issuer) PUK 0x4103 (CM_DISABLE)', 00H
	ORG $+1
$SG171778 DB	'In RRH 0x417E (CmComm) PUK 0x4102 (ULP_ENABLE)', 00H
	ORG $+1
$SG171819 DB	'In RRH 0x417E (CmComm) PUK 0x4103 (ULP_DISABLE)', 00H
$SG172102 DB	'Out RRH 0x417E (CmComm) PUK 0x4106 (ULP_CONFIRM)', 00H
	ORG $+7
$SG171783 DB	'HHC03937%s %1d:%04X PTP: Accept data contains %s that do'
	DB	'es not contain expected %s', 0aH, 00H
	ORG $+4
$SG171784 DB	'write_rrh_417E', 00H
	ORG $+1
$SG171785 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171791 DB	'write_rrh_417E', 00H
	ORG $+1
$SG171967 DB	'Out RRH 0x417E (Issuer) PUK 0x4106 (CM_CONFIRM)', 00H
$SG172161 DB	'In RRH 0xC17E (Issuer)', 00H
	ORG $+1
$SG171790 DB	'HHC03937%s %1d:%04X PTP: Accept data contains %s that do'
	DB	'es not contain expected %s', 0aH, 00H
	ORG $+4
$SG171792 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171796 DB	'In RRH 0x417E (CmComm) PUK 0x4104 (ULP_SETUP)', 00H
	ORG $+2
$SG171802 DB	'write_rrh_417E', 00H
	ORG $+1
$SG172020 DB	'Out RRH 0x417E (CmComm) PUK 0x4102 (ULP_ENABLE)', 00H
$SG172279 DB	'In RRH 0xC108 (UlpComm) My address IPv4', 00H
$SG171801 DB	'HHC03937%s %1d:%04X PTP: Accept data contains %s that do'
	DB	'es not contain expected %s', 0aH, 00H
	ORG $+4
$SG171803 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171812 DB	'write_rrh_417E', 00H
	ORG $+1
$SG172296 DB	'HHC03913%s %1d:%04X PTP: Guest has IP address %s', 0aH, 00H
	ORG $+6
$SG171811 DB	'HHC03937%s %1d:%04X PTP: Accept data contains %s that do'
	DB	'es not contain expected %s', 0aH, 00H
	ORG $+4
$SG171813 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171816 DB	'In RRH 0x417E (CmComm) PUK 0x4360 (DM_ACT)', 00H
	ORG $+5
$SG171826 DB	'write_rrh_417E', 00H
	ORG $+1
$SG172308 DB	'In RRH 0xC108 (UlpComm) My address IPv6', 00H
$SG171825 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG171827 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171831 DB	'write_rrh_417E', 00H
	ORG $+1
$SG172328 DB	'HHC03914%s %1d:%04X PTP: Guest has IP address %s', 0aH, 00H
	ORG $+6
$SG171830 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG171832 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171836 DB	'write_rrh_417E', 00H
	ORG $+1
$SG172859 DB	'Out RRH 0x8108 (UlpComm) Group membership report', 00H
	ORG $+7
$SG171835 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG171837 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171841 DB	'HHC03936%s %1d:%04X PTP: Accept data contains unknown %s'
	DB	0aH, 00H
	ORG $+6
$SG171842 DB	'write_rrh_417E', 00H
	ORG $+1
$SG171843 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG171893 DB	'Out RRH 0x417E (Issuer) PUK 0x4102 (CM_ENABLE)', 00H
	ORG $+1
$SG171930 DB	'Out RRH 0x417E (Issuer) PUK 0x4104 (CM_SETUP)', 00H
	ORG $+2
$SG172061 DB	'Out RRH 0x417E (CmComm) PUK 0x4104 (ULP_SETUP)', 00H
	ORG $+1
$SG172135 DB	'Out RRH 0x417E (CmComm) PUK 0x4360 (DM_ACT)', 00H
	ORG $+4
$SG172165 DB	'HHC03936%s %1d:%04X PTP: Accept data contains unknown %s'
	DB	0aH, 00H
	ORG $+6
$SG172166 DB	'write_rrh_C17E', 00H
	ORG $+1
$SG172167 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172241 DB	'In RRH 0xC108 (UlpComm) Will you start IPv4?', 00H
	ORG $+3
$SG172248 DB	'In RRH 0xC108 (UlpComm) Will you start IPv6?', 00H
	ORG $+3
$SG172256 DB	'In RRH 0xC108 (UlpComm) I will start IPv4', 00H
	ORG $+6
$SG172260 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172862 DB	'Out RRH 0x8108 (UlpComm) Group membership report', 00H
	ORG $+7
$SG172259 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172261 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172264 DB	'In RRH 0xC108 (UlpComm) I will start IPv6', 00H
	ORG $+6
$SG172268 DB	'write_rrh_C108', 00H
	ORG $+1
$SG173016 DB	'SDL 4.2', 00H
$SG172267 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172269 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172274 DB	'write_rrh_C108', 00H
	ORG $+1
$SG173017 DB	'SYSBLK', 00H
	ORG $+1
$SG172273 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172275 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172288 DB	'HHC03912%s %1d:%04X PTP: Guest has the driver IP address'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG172289 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172290 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172297 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172298 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172304 DB	'write_rrh_C108', 00H
	ORG $+1
$SG173020 DB	'REGS', 00H
	ORG $+3
$SG172303 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172305 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172320 DB	'HHC03912%s %1d:%04X PTP: Guest has the driver IP address'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG172321 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172322 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172329 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172330 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172338 DB	'write_rrh_C108', 00H
	ORG $+1
$SG173034 DB	'debug_tt32_stats', 00H
	ORG $+7
$SG172337 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172339 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172344 DB	'write_rrh_C108', 00H
	ORG $+1
$SG173035 DB	'debug_tt32_tracing', 00H
	ORG $+5
$SG172343 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172345 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172349 DB	'In RRH 0xC108 (UlpComm) Your address IPv4', 00H
	ORG $+6
$SG172353 DB	'write_rrh_C108', 00H
	ORG $+9
$SG172352 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172354 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172357 DB	'In RRH 0xC108 (UlpComm) Your address IPv6', 00H
	ORG $+14
$SG172363 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172364 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172365 DB	'ctc_ptp.c', 00H
	ORG $+14
$SG172369 DB	'HHC03915%s %1d:%04X PTP: Connection active to guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+5
$SG172370 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172371 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172375 DB	'In RRH 0xC108 (UlpComm) Will you stop IPv4?', 00H
	ORG $+4
$SG172380 DB	'In RRH 0xC108 (UlpComm) Will you stop IPv6?', 00H
	ORG $+4
$SG172385 DB	'In RRH 0xC108 (UlpComm) I will stop IPv4', 00H
	ORG $+15
$SG172389 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG172390 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172391 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172394 DB	'In RRH 0xC108 (UlpComm) I will stop IPv6', 00H
	ORG $+15
$SG172398 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG172399 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172400 DB	'ctc_ptp.c', 00H
	ORG $+14
$SG172404 DB	'HHC03916%s %1d:%04X PTP: Connection cleared to guest IP '
	DB	'address %s', 0aH, 00H
	ORG $+4
$SG172405 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172406 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172410 DB	'HHC03936%s %1d:%04X PTP: Accept data contains unknown %s'
	DB	0aH, 00H
	ORG $+6
$SG172411 DB	'write_rrh_C108', 00H
	ORG $+1
$SG172412 DB	'ctc_ptp.c', 00H
	ORG $+6
$SG172439 DB	'Out RRH 0xC108 (UlpComm) Will you start IPv4?', 00H
	ORG $+2
$SG172466 DB	'Out RRH 0xC108 (UlpComm) Will you start IPv6?', 00H
	ORG $+2
$SG172497 DB	'Out RRH 0xC108 (UlpComm) I will start IPv4', 00H
	ORG $+5
$SG172528 DB	'Out RRH 0xC108 (UlpComm) I will start IPv6', 00H
	ORG $+5
$SG172555 DB	'Out RRH 0xC108 (UlpComm) My address IPv4', 00H
	ORG $+7
$SG172586 DB	'Out RRH 0xC108 (UlpComm) My address IPv6', 00H
	ORG $+7
$SG172617 DB	'Out RRH 0xC108 (UlpComm) Your address IPv4', 00H
	ORG $+5
$SG172648 DB	'Out RRH 0xC108 (UlpComm) Your address IPv6', 00H
	ORG $+5
$SG172675 DB	'Out RRH 0xC108 (UlpComm) Will you stop IPv4?', 00H
	ORG $+3
$SG172702 DB	'Out RRH 0xC108 (UlpComm) Will you stop IPv6?', 00H
	ORG $+3
$SG172731 DB	'Out RRH 0xC108 (UlpComm) I will stop IPv4', 00H
	ORG $+6
$SG172760 DB	'Out RRH 0xC108 (UlpComm) I will stop IPv6', 00H
	ORG $+6
$SG172850 DB	'Out RRH 0x8108 (UlpComm) Neighbor advertisment', 00H
	ORG $+1
$SG172853 DB	'Out RRH 0x8108 (UlpComm) Router solicitation', 00H
	ORG $+3
$SG172856 DB	'Out RRH 0x8108 (UlpComm) Neighbor advertisment', 00H
	ORG $+1
$SG173010 DB	'SDL 4.60', 00H
	ORG $+7
$SG173011 DB	'HERCULES', 00H
	ORG $+7
$SG173013 DB	'SDL 4.00', 00H
	ORG $+7
$SG173019 DB	'SDL 4.00', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:calculate_icmpv6_checksum
	DD	022H
	DD	024bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:gen_csv_sid
	DD	020H
	DD	09f14H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:write_rrh_C108
	DD	022H
	DD	020aeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_417E_ulp_confirm
	DD	01dH
	DD	058bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_417E_ulp_setup
	DD	01dH
	DD	058bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_417E_cm_confirm
	DD	01bH
	DD	0478H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_417E_cm_setup
	DD	01bH
	DD	0478H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_417E_cm_enable
	DD	025H
	DD	0689H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:get_subarea_address
	DD	015H
	DD	0145H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ptp_get_tod_clock
	DD	015H
	DD	0ecH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ptp_unsol_int_thread
	DD	016H
	DD	03e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:raise_unsol_int
	DD	01fH
	DD	0247H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:check_specified_value
	DD	01dH
	DD	0478H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:parse_conf_stmt
	DD	02dH
	DD	01f07H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:alloc_storage
	DD	01bH
	DD	0147H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:alloc_ptp_buffer
	DD	01bH
	DD	015bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ptp_read_thread
	DD	018H
	DD	0fa4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ptp_read
	DD	025H
	DD	0449H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:write_rrh_8108
	DD	022H
	DD	0c2cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ptp_query
	DD	025H
	DD	04adH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ptp_init
	DD	020H
	DD	013dbH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$store_f3_noswap DD 020b01H
	DD	0600a700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_f3_noswap DD 030b01H
	DD	07007220bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$SetSIDInfo DD 021a01H
	DD	07016121aH
$unwind$ptp_init DD 032819H
	DD	0340116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0198H
$unwind$ptp_execute_ccw DD 041c01H
	DD	01b011cH
	DD	060147015H
$unwind$ptp_close DD 010901H
	DD	08209H
$unwind$ptp_query DD 022d19H
	DD	03b011bH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
$unwind$ptp_write DD 021a01H
	DD	01b011aH
$unwind$write_th DD 021a01H
	DD	013011aH
$unwind$write_rrh_8108 DD 042a19H
	DD	0310118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$ptp_halt_or_clear DD 010901H
	DD	06209H
$unwind$ptp_read DD 032d19H
	DD	016011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$read_read_buffer DD 041c01H
	DD	019011cH
	DD	060147015H
$unwind$read_chain_buffer DD 041c01H
	DD	017011cH
	DD	060147015H
$unwind$ptp_read_thread DD 042019H
	DD	035010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$add_buffer_to_chain_and_signal_event DD 010e01H
	DD	0620eH
$unwind$add_buffer_to_chain DD 010e01H
	DD	0420eH
$unwind$remove_buffer_from_chain DD 010901H
	DD	06209H
$unwind$remove_and_free_any_buffers_on_chain DD 010901H
	DD	06209H
$unwind$alloc_ptp_buffer DD 032319H
	DD	0180111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$alloc_storage DD 032319H
	DD	0180111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$parse_conf_stmt DD 043519H
	DD	04910123H
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	02470H
$unwind$get_preconfigured_value DD 010e01H
	DD	0e20eH
$unwind$check_specified_value DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$raise_unsol_int DD 022719H
	DD	0130115H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$ptp_unsol_int_thread DD 021e19H
	DD	01b010cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$ptp_get_tod_clock DD 031a19H
	DD	07007c20bH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$get_subarea_address DD 031a19H
	DD	07007e20bH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$write_hx0_01 DD 031b01H
	DD	012011bH
	DD	07014H
$unwind$write_hx0_00 DD 011701H
	DD	06217H
$unwind$write_hx2 DD 031b01H
	DD	024011bH
	DD	07014H
$unwind$point_CSVcv DD 010e01H
	DD	0420eH
$unwind$write_rrh_417E DD 021601H
	DD	0290116H
$unwind$build_417E_cm_enable DD 022d19H
	DD	015011bH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$build_417E_cm_setup DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$build_417E_cm_confirm DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$build_417E_ulp_enable DD 041d01H
	DD	013011dH
	DD	060157016H
$unwind$build_417E_ulp_setup DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$build_417E_ulp_confirm DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$build_417E_dm_act DD 021101H
	DD	0110111H
$unwind$write_rrh_C17E DD 021601H
	DD	0130116H
$unwind$write_rrh_C108 DD 042a19H
	DD	03d0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	01d8H
$unwind$build_C108_will_you_start_4 DD 010901H
	DD	0e209H
$unwind$build_C108_will_you_start_6 DD 010901H
	DD	0e209H
$unwind$build_C108_i_will_start_4 DD 011401H
	DD	0e214H
$unwind$build_C108_i_will_start_6 DD 011401H
	DD	0e214H
$unwind$build_C108_my_address_4 DD 010901H
	DD	0e209H
$unwind$build_C108_my_address_6 DD 030f01H
	DD	0700be20fH
	DD	0600aH
$unwind$build_C108_your_address_4 DD 011401H
	DD	0e214H
$unwind$build_C108_your_address_6 DD 031601H
	DD	07012e216H
	DD	06011H
$unwind$build_C108_will_you_stop_4 DD 010901H
	DD	0e209H
$unwind$build_C108_will_you_stop_6 DD 010901H
	DD	0e209H
$unwind$build_C108_i_will_stop_4 DD 010e01H
	DD	0e20eH
$unwind$build_C108_i_will_stop_6 DD 010e01H
	DD	0e20eH
$unwind$build_8108_icmpv6_packets DD 040e01H
	DD	013010eH
	DD	060067007H
$unwind$gen_csv_sid DD 022819H
	DD	0290116H
	DD	imagerel __GSHandlerCheck
	DD	0138H
$unwind$shift_left_dbl DD 011301H
	DD	02213H
$unwind$shift_right_dbl DD 011301H
	DD	02213H
$unwind$calculate_icmpv6_checksum DD 042719H
	DD	0110118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_register_symbols_ep DD 010901H
	DD	04209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 9662 : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 9663 : {
; 9664 :     HDL_DEVICE( PTP, ptp_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ptp_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173040
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 9665 : }
; 9666 : END_DEVICE_SECTION

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
regsym$ = 48
hdl_register_symbols_ep PROC

; 9645 : HDL_REGISTER_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 9646 : {
; 9647 :     //              Hercules's          Our
; 9648 :     //              registered          overriding
; 9649 :     //              entry-point         entry-point
; 9650 :     //              name                value
; 9651 : 
; 9652 :   #if defined( OPTION_W32_CTCI )
; 9653 :     HDL_REGISTER ( debug_tt32_stats,   display_tt32_stats        );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:display_tt32_stats
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173034
  00017	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 9654 :     HDL_REGISTER ( debug_tt32_tracing, enable_tt32_debug_tracing );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enable_tt32_debug_tracing
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173035
  00029	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 9655 :   #else
; 9656 :     UNREFERENCED( regsym );     // (HDL_REGISTER_SECTION parameter)
; 9657 :   #endif
; 9658 : }
; 9659 : END_REGISTER_SECTION

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
hdl_register_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
getsym$ = 8
hdl_resolve_symbols_ep PROC

; 9631 : HDL_RESOLVER_SECTION;

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@hdl_resolv:

; 9632 : {
; 9633 :    #if defined( WIN32 ) && !defined( _MSVC_ ) && !defined( HDL_USE_LIBTOOL )
; 9634 :      #undef sysblk
; 9635 :      HDL_RESOLVE_SYMPTR( psysblk, sysblk );
; 9636 :      HDL_RESOLVE( etod_clock );
; 9637 :      HDL_RESOLVE( device_attention );
; 9638 :    #else
; 9639 :      UNREFERENCED( getsym );    // (HDL_RESOLVER_SECTION parameter)

  00005	33 c0		 xor	 eax, eax
  00007	85 c0		 test	 eax, eax
  00009	75 fa		 jne	 SHORT $LN4@hdl_resolv

; 9640 :    #endif
; 9641 : }
; 9642 : END_RESOLVER_SECTION

  0000b	c3		 ret	 0
hdl_resolve_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 9621 : HDL_DEPENDENCY_SECTION;

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 9622 : {
; 9623 :      HDL_DEPENDENCY( HERCULES );

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173010
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173011
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN14@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN14@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 9624 :      HDL_DEPENDENCY( DEVBLK );

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173013
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173014
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN15@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN15@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 9625 :      HDL_DEPENDENCY( SYSBLK );

  00065	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173016
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173017
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN16@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN16@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_
$LN13@hdl_check_:

; 9626 :      HDL_DEPENDENCY( REGS );

  0008f	41 b8 80 60 01
	00		 mov	 r8d, 90240		; 00016080H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173019
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173020
  000a3	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 08		 je	 SHORT $LN17@hdl_check_
  000ab	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN17@hdl_check_:
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 d6		 jne	 SHORT $LN13@hdl_check_

; 9627 : }
; 9628 : END_DEPENDENCY_SECTION

  000b9	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uChecksum$ = 32
i$ = 36
uTwobytes$ = 40
j$ = 44
uHighhalf$ = 48
pBytePtr$ = 56
$T1 = 64
bPseudoHeader$ = 72
__$ArrayPad$ = 112
pIP6FRM$ = 160
pIcmpHdr$ = 168
iIcmpLen$ = 176
calculate_icmpv6_checksum PROC

; 9541 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 9542 :     BYTE*      pBytePtr;
; 9543 :     int        i,j;
; 9544 :     U16        uTwobytes;            // Two bytes of data
; 9545 :     U32        uHighhalf;            // High-order half of the checksum
; 9546 :     U32        uChecksum;            // The checksum
; 9547 :     BYTE       bPseudoHeader[40];    //  0-15  Source address
; 9548 :                                      // 16-31  Destination address
; 9549 :                                      // 32-35  Upper-layer packet length
; 9550 :                                      // 36-38  zero
; 9551 :                                      //   39   Next Header (i.e. 58 (0x3a))
; 9552 : 
; 9553 : 
; 9554 :     // Clear the checksum in the ICMP header before calculating the checksum.
; 9555 :     STORE_HW( pIcmpHdr+2, 0x0000 );

  00027	33 c9		 xor	 ecx, ecx
  00029	e8 00 00 00 00	 call	 _byteswap_ushort
  0002e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00036	48 83 c1 02	 add	 rcx, 2
  0003a	0f b7 d0	 movzx	 edx, ax
  0003d	e8 00 00 00 00	 call	 store_hw_noswap

; 9556 : 
; 9557 :     // Construct the Psuedo-Header for the checksum calcuation.
; 9558 :     memcpy( bPseudoHeader+0, pIP6FRM->bSrcAddr, 16 );

  00042	48 8d 44 24 48	 lea	 rax, QWORD PTR bPseudoHeader$[rsp]
  00047	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pIP6FRM$[rsp]
  0004f	48 8b f8	 mov	 rdi, rax
  00052	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  00056	b9 10 00 00 00	 mov	 ecx, 16
  0005b	f3 a4		 rep movsb

; 9559 :     memcpy( bPseudoHeader+16, pIP6FRM->bDstAddr, 16 );

  0005d	48 8d 44 24 58	 lea	 rax, QWORD PTR bPseudoHeader$[rsp+16]
  00062	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pIP6FRM$[rsp]
  0006a	48 8b f8	 mov	 rdi, rax
  0006d	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00071	b9 10 00 00 00	 mov	 ecx, 16
  00076	f3 a4		 rep movsb

; 9560 :     STORE_FW( bPseudoHeader+32, iIcmpLen );

  00078	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR iIcmpLen$[rsp]
  0007f	e8 00 00 00 00	 call	 _byteswap_ulong
  00084	48 8d 4c 24 68	 lea	 rcx, QWORD PTR bPseudoHeader$[rsp+32]
  00089	8b d0		 mov	 edx, eax
  0008b	e8 00 00 00 00	 call	 store_fw_noswap

; 9561 :     for( i = 36; i <= 38; i++ )

  00090	c7 44 24 24 24
	00 00 00	 mov	 DWORD PTR i$[rsp], 36	; 00000024H
  00098	eb 0a		 jmp	 SHORT $LN4@calculate_
$LN2@calculate_:
  0009a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0009e	ff c0		 inc	 eax
  000a0	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@calculate_:
  000a4	83 7c 24 24 26	 cmp	 DWORD PTR i$[rsp], 38	; 00000026H
  000a9	7f 25		 jg	 SHORT $LN3@calculate_

; 9562 :         bPseudoHeader[i] = 0x00;

  000ab	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000b0	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  000b5	48 83 7c 24 40
	28		 cmp	 QWORD PTR $T1[rsp], 40	; 00000028H
  000bb	73 02		 jae	 SHORT $LN12@calculate_
  000bd	eb 05		 jmp	 SHORT $LN13@calculate_
$LN12@calculate_:
  000bf	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN13@calculate_:
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]
  000c9	c6 44 04 48 00	 mov	 BYTE PTR bPseudoHeader$[rsp+rax], 0
  000ce	eb ca		 jmp	 SHORT $LN2@calculate_
$LN3@calculate_:

; 9563 :     bPseudoHeader[39] = 0x3A;

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	48 6b c0 27	 imul	 rax, rax, 39		; 00000027H
  000d9	c6 44 04 48 3a	 mov	 BYTE PTR bPseudoHeader$[rsp+rax], 58 ; 0000003aH

; 9564 : 
; 9565 :     // Calculate the checksum.
; 9566 :     uChecksum = 0;

  000de	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR uChecksum$[rsp], 0

; 9567 :     for( i = 0; i <= 38; i += 2 )

  000e6	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ee	eb 0b		 jmp	 SHORT $LN7@calculate_
$LN5@calculate_:
  000f0	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000f4	83 c0 02	 add	 eax, 2
  000f7	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@calculate_:
  000fb	83 7c 24 24 26	 cmp	 DWORD PTR i$[rsp], 38	; 00000026H
  00100	7f 32		 jg	 SHORT $LN6@calculate_

; 9568 :     {
; 9569 :         FETCH_HW( uTwobytes, bPseudoHeader+i );

  00102	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00107	48 8d 44 04 48	 lea	 rax, QWORD PTR bPseudoHeader$[rsp+rax]
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00114	0f b7 c8	 movzx	 ecx, ax
  00117	e8 00 00 00 00	 call	 _byteswap_ushort
  0011c	66 89 44 24 28	 mov	 WORD PTR uTwobytes$[rsp], ax

; 9570 :         uChecksum += uTwobytes;

  00121	0f b7 44 24 28	 movzx	 eax, WORD PTR uTwobytes$[rsp]
  00126	8b 4c 24 20	 mov	 ecx, DWORD PTR uChecksum$[rsp]
  0012a	03 c8		 add	 ecx, eax
  0012c	8b c1		 mov	 eax, ecx
  0012e	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 9571 :     }

  00132	eb bc		 jmp	 SHORT $LN5@calculate_
$LN6@calculate_:

; 9572 :     pBytePtr = pIcmpHdr;                   // Point to the ICMPv6 header.

  00134	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pIcmpHdr$[rsp]
  0013c	48 89 44 24 38	 mov	 QWORD PTR pBytePtr$[rsp], rax

; 9573 :     j = iIcmpLen;                          // Get the length of the

  00141	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR iIcmpLen$[rsp]
  00148	89 44 24 2c	 mov	 DWORD PTR j$[rsp], eax

; 9574 :     j++;                                   // ICMPv6 packet rounded up

  0014c	8b 44 24 2c	 mov	 eax, DWORD PTR j$[rsp]
  00150	ff c0		 inc	 eax
  00152	89 44 24 2c	 mov	 DWORD PTR j$[rsp], eax

; 9575 :     j &= 0xFFFFFFFE;                       // to the next multiple of two.

  00156	8b 44 24 2c	 mov	 eax, DWORD PTR j$[rsp]
  0015a	83 e0 fe	 and	 eax, -2			; fffffffeH
  0015d	89 44 24 2c	 mov	 DWORD PTR j$[rsp], eax

; 9576 :     for( i = 0; i <= j - 2; i += 2 )

  00161	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00169	eb 0b		 jmp	 SHORT $LN10@calculate_
$LN8@calculate_:
  0016b	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0016f	83 c0 02	 add	 eax, 2
  00172	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN10@calculate_:
  00176	8b 44 24 2c	 mov	 eax, DWORD PTR j$[rsp]
  0017a	83 e8 02	 sub	 eax, 2
  0017d	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00181	7f 38		 jg	 SHORT $LN9@calculate_

; 9577 :     {
; 9578 :         FETCH_HW( uTwobytes, pBytePtr );

  00183	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pBytePtr$[rsp]
  00188	e8 00 00 00 00	 call	 fetch_hw_noswap
  0018d	0f b7 c8	 movzx	 ecx, ax
  00190	e8 00 00 00 00	 call	 _byteswap_ushort
  00195	66 89 44 24 28	 mov	 WORD PTR uTwobytes$[rsp], ax

; 9579 :         uChecksum += uTwobytes;

  0019a	0f b7 44 24 28	 movzx	 eax, WORD PTR uTwobytes$[rsp]
  0019f	8b 4c 24 20	 mov	 ecx, DWORD PTR uChecksum$[rsp]
  001a3	03 c8		 add	 ecx, eax
  001a5	8b c1		 mov	 eax, ecx
  001a7	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 9580 :         pBytePtr += 2;

  001ab	48 8b 44 24 38	 mov	 rax, QWORD PTR pBytePtr$[rsp]
  001b0	48 83 c0 02	 add	 rax, 2
  001b4	48 89 44 24 38	 mov	 QWORD PTR pBytePtr$[rsp], rax

; 9581 :     }

  001b9	eb b0		 jmp	 SHORT $LN8@calculate_
$LN9@calculate_:

; 9582 :     uHighhalf = uChecksum >> 16;           // Get the high-order half

  001bb	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  001bf	c1 e8 10	 shr	 eax, 16
  001c2	89 44 24 30	 mov	 DWORD PTR uHighhalf$[rsp], eax

; 9583 :                                            // of the checksum value.
; 9584 :     uChecksum &= 0x0000FFFF;               // Get the low-order half.

  001c6	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  001ca	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001cf	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 9585 :     uChecksum += uHighhalf;                // Add the high-order half

  001d3	8b 44 24 30	 mov	 eax, DWORD PTR uHighhalf$[rsp]
  001d7	8b 4c 24 20	 mov	 ecx, DWORD PTR uChecksum$[rsp]
  001db	03 c8		 add	 ecx, eax
  001dd	8b c1		 mov	 eax, ecx
  001df	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 9586 :                                            // to the low-order half.
; 9587 :     uHighhalf = uChecksum >> 16;           // Get the high-order half

  001e3	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  001e7	c1 e8 10	 shr	 eax, 16
  001ea	89 44 24 30	 mov	 DWORD PTR uHighhalf$[rsp], eax

; 9588 :                                            // of the checksum value again.
; 9589 :     uChecksum &= 0x0000FFFF;               // Get the low-order half.

  001ee	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  001f2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001f7	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 9590 :     uChecksum += uHighhalf;                // Add the high-order half

  001fb	8b 44 24 30	 mov	 eax, DWORD PTR uHighhalf$[rsp]
  001ff	8b 4c 24 20	 mov	 ecx, DWORD PTR uChecksum$[rsp]
  00203	03 c8		 add	 ecx, eax
  00205	8b c1		 mov	 eax, ecx
  00207	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 9591 :                                            // to the low-order half again
; 9592 :                                            // to include any carry.
; 9593 :     uChecksum ^= 0xFFFFFFFF;               // Complement the bits.

  0020b	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  0020f	83 f0 ff	 xor	 eax, -1			; ffffffffH
  00212	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 9594 :     uChecksum &= 0x0000FFFF;               // Get a clean checksum.

  00216	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  0021a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0021f	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 9595 :     uTwobytes = uChecksum;                 // Copy to a two-byte value.

  00223	0f b7 44 24 20	 movzx	 eax, WORD PTR uChecksum$[rsp]
  00228	66 89 44 24 28	 mov	 WORD PTR uTwobytes$[rsp], ax

; 9596 : 
; 9597 :     // Set the checksum in the ICMP header.
; 9598 :     STORE_HW( pIcmpHdr+2, uTwobytes );

  0022d	0f b7 4c 24 28	 movzx	 ecx, WORD PTR uTwobytes$[rsp]
  00232	e8 00 00 00 00	 call	 _byteswap_ushort
  00237	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  0023f	48 83 c1 02	 add	 rcx, 2
  00243	0f b7 d0	 movzx	 edx, ax
  00246	e8 00 00 00 00	 call	 store_hw_noswap
$LN11@calculate_:

; 9599 : 
; 9600 :     return;
; 9601 : }   /* End function  calculate_icmpv6_checksum() */

  0024b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00250	48 33 cc	 xor	 rcx, rsp
  00253	e8 00 00 00 00	 call	 __security_check_cookie
  00258	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0025f	5f		 pop	 rdi
  00260	5e		 pop	 rsi
  00261	c3		 ret	 0
calculate_icmpv6_checksum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
dw$ = 0
even$ = 32
odd$ = 40
number$ = 48
shift_right_dbl PROC

; 9499 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 9500 :     U64     dw;
; 9501 : 
; 9502 :     dw = *even;              // Combine the two

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR even$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9503 :     dw <<= 32;               // U32 values into

  0001e	48 8b 04 24	 mov	 rax, QWORD PTR dw$[rsp]
  00022	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00026	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9504 :     dw |= *odd;              // one U64 value

  0002a	48 8b 44 24 28	 mov	 rax, QWORD PTR odd$[rsp]
  0002f	8b 00		 mov	 eax, DWORD PTR [rax]
  00031	48 8b 0c 24	 mov	 rcx, QWORD PTR dw$[rsp]
  00035	48 0b c8	 or	 rcx, rax
  00038	48 8b c1	 mov	 rax, rcx
  0003b	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9505 : 
; 9506 :     dw >>= number;           // Shift right the appropriate number

  0003f	48 63 44 24 30	 movsxd	 rax, DWORD PTR number$[rsp]
  00044	0f b6 c8	 movzx	 ecx, al
  00047	48 8b 04 24	 mov	 rax, QWORD PTR dw$[rsp]
  0004b	48 d3 e8	 shr	 rax, cl
  0004e	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9507 : 
; 9508 :     *odd = (U32)dw;          // Separate the U64

  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR odd$[rsp]
  00057	8b 0c 24	 mov	 ecx, DWORD PTR dw$[rsp]
  0005a	89 08		 mov	 DWORD PTR [rax], ecx

; 9509 :     dw >>= 32;               // value into

  0005c	48 8b 04 24	 mov	 rax, QWORD PTR dw$[rsp]
  00060	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00064	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9510 :     *even = (U32)dw;         // two U32 values.

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR even$[rsp]
  0006d	8b 0c 24	 mov	 ecx, DWORD PTR dw$[rsp]
  00070	89 08		 mov	 DWORD PTR [rax], ecx

; 9511 : 
; 9512 :     return;
; 9513 : }   /* End function  shift_right_dbl() */

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
shift_right_dbl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
dw$ = 0
even$ = 32
odd$ = 40
number$ = 48
shift_left_dbl PROC

; 9482 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 9483 :     U64     dw;
; 9484 : 
; 9485 :     dw = *even;              // Combine the two

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR even$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9486 :     dw <<= 32;               // U32 values into

  0001e	48 8b 04 24	 mov	 rax, QWORD PTR dw$[rsp]
  00022	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00026	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9487 :     dw |= *odd;              // one U64 value

  0002a	48 8b 44 24 28	 mov	 rax, QWORD PTR odd$[rsp]
  0002f	8b 00		 mov	 eax, DWORD PTR [rax]
  00031	48 8b 0c 24	 mov	 rcx, QWORD PTR dw$[rsp]
  00035	48 0b c8	 or	 rcx, rax
  00038	48 8b c1	 mov	 rax, rcx
  0003b	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9488 : 
; 9489 :     dw <<= number;           // Shift left the appropriate number

  0003f	48 63 44 24 30	 movsxd	 rax, DWORD PTR number$[rsp]
  00044	0f b6 c8	 movzx	 ecx, al
  00047	48 8b 04 24	 mov	 rax, QWORD PTR dw$[rsp]
  0004b	48 d3 e0	 shl	 rax, cl
  0004e	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9490 : 
; 9491 :     *odd = (U32)dw;          // Separate the U64

  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR odd$[rsp]
  00057	8b 0c 24	 mov	 ecx, DWORD PTR dw$[rsp]
  0005a	89 08		 mov	 DWORD PTR [rax], ecx

; 9492 :     dw >>= 32;               // value into

  0005c	48 8b 04 24	 mov	 rax, QWORD PTR dw$[rsp]
  00060	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00064	48 89 04 24	 mov	 QWORD PTR dw$[rsp], rax

; 9493 :     *even = (U32)dw;         // two U32 values.

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR even$[rsp]
  0006d	8b 0c 24	 mov	 ecx, DWORD PTR dw$[rsp]
  00070	89 08		 mov	 DWORD PTR [rax], ecx

; 9494 : 
; 9495 :     return;
; 9496 : }   /* End function  shift_left_dbl() */

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
shift_left_dbl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
i$ = 32
j$ = 36
XorResult$ = 40
tv5913 = 48
tv5925 = 56
tv5937 = 64
tv5949 = 72
tv6025 = 80
tv6037 = 88
tv6049 = 96
tv6061 = 104
OrResult$ = 112
wv$ = 240
XorClocks$ = 304
__$ArrayPad$ = 312
pClock1$ = 336
pClock2$ = 344
pToken$ = 352
gen_csv_sid PROC

; 8306 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 8307 : 
; 8308 :     static const U32 XorConstant[512] =
; 8309 :                              { 0x00404100, 0x00000000, 0x00004000, 0x00404101,
; 8310 :                                0x00404001, 0x00004101, 0x00000001, 0x00004000,
; 8311 :                                0x00000100, 0x00404100, 0x00404101, 0x00000100,
; 8312 :                                0x00400101, 0x00404001, 0x00400000, 0x00000001,
; 8313 :                                0x00000101, 0x00400100, 0x00400100, 0x00004100,
; 8314 :                                0x00004100, 0x00404000, 0x00404000, 0x00400101,
; 8315 :                                0x00004001, 0x00400001, 0x00400001, 0x00004001,
; 8316 :                                0x00000000, 0x00000101, 0x00004101, 0x00400000,
; 8317 :                                0x00004000, 0x00404101, 0x00000001, 0x00404000,
; 8318 :                                0x00404100, 0x00400000, 0x00400000, 0x00000100,
; 8319 :                                0x00404001, 0x00004000, 0x00004100, 0x00400001,
; 8320 :                                0x00000100, 0x00000001, 0x00400101, 0x00004101,
; 8321 :                                0x00404101, 0x00004001, 0x00404000, 0x00400101,
; 8322 :                                0x00400001, 0x00000101, 0x00004101, 0x00404100,
; 8323 :                                0x00000101, 0x00400100, 0x00400100, 0x00000000,
; 8324 :                                0x00004001, 0x00004100, 0x00000000, 0x00404001,
; 8325 :                                0x20042008, 0x20002000, 0x00002000, 0x00042008,
; 8326 :                                0x00040000, 0x00000008, 0x20040008, 0x20002008,
; 8327 :                                0x20000008, 0x20042008, 0x20042000, 0x20000000,
; 8328 :                                0x20002000, 0x00040000, 0x00000008, 0x20040008,
; 8329 :                                0x00042000, 0x00040008, 0x20002008, 0x00000000,
; 8330 :                                0x20000000, 0x00002000, 0x00042008, 0x20040000,
; 8331 :                                0x00040008, 0x20000008, 0x00000000, 0x00042000,
; 8332 :                                0x00002008, 0x20042000, 0x20040000, 0x00002008,
; 8333 :                                0x00000000, 0x00042008, 0x20040008, 0x00040000,
; 8334 :                                0x20002008, 0x20040000, 0x20042000, 0x00002000,
; 8335 :                                0x20040000, 0x20002000, 0x00000008, 0x20042008,
; 8336 :                                0x00042008, 0x00000008, 0x00002000, 0x20000000,
; 8337 :                                0x00002008, 0x20042000, 0x00040000, 0x20000008,
; 8338 :                                0x00040008, 0x20002008, 0x20000008, 0x00040008,
; 8339 :                                0x00042000, 0x00000000, 0x20002000, 0x00002008,
; 8340 :                                0x20000000, 0x20040008, 0x20042008, 0x00042000,
; 8341 :                                0x00000082, 0x02008080, 0x00000000, 0x02008002,
; 8342 :                                0x02000080, 0x00000000, 0x00008082, 0x02000080,
; 8343 :                                0x00008002, 0x02000002, 0x02000002, 0x00008000,
; 8344 :                                0x02008082, 0x00008002, 0x02008000, 0x00000082,
; 8345 :                                0x02000000, 0x00000002, 0x02008080, 0x00000080,
; 8346 :                                0x00008080, 0x02008000, 0x02008002, 0x00008082,
; 8347 :                                0x02000082, 0x00008080, 0x00008000, 0x02000082,
; 8348 :                                0x00000002, 0x02008082, 0x00000080, 0x02000000,
; 8349 :                                0x02008080, 0x02000000, 0x00008002, 0x00000082,
; 8350 :                                0x00008000, 0x02008080, 0x02000080, 0x00000000,
; 8351 :                                0x00000080, 0x00008002, 0x02008082, 0x02000080,
; 8352 :                                0x02000002, 0x00000080, 0x00000000, 0x02008002,
; 8353 :                                0x02000082, 0x00008000, 0x02000000, 0x02008082,
; 8354 :                                0x00000002, 0x00008082, 0x00008080, 0x02000002,
; 8355 :                                0x02008000, 0x02000082, 0x00000082, 0x02008000,
; 8356 :                                0x00008082, 0x00000002, 0x02008002, 0x00008080,
; 8357 :                                0x40200800, 0x40000820, 0x40000820, 0x00000020,
; 8358 :                                0x00200820, 0x40200020, 0x40200000, 0x40000800,
; 8359 :                                0x00000000, 0x00200800, 0x00200800, 0x40200820,
; 8360 :                                0x40000020, 0x00000000, 0x00200020, 0x40200000,
; 8361 :                                0x40000000, 0x00000800, 0x00200000, 0x40200800,
; 8362 :                                0x00000020, 0x00200000, 0x40000800, 0x00000820,
; 8363 :                                0x40200020, 0x40000000, 0x00000820, 0x00200020,
; 8364 :                                0x00000800, 0x00200820, 0x40200820, 0x40000020,
; 8365 :                                0x00200020, 0x40200000, 0x00200800, 0x40200820,
; 8366 :                                0x40000020, 0x00000000, 0x00000000, 0x00200800,
; 8367 :                                0x00000820, 0x00200020, 0x40200020, 0x40000000,
; 8368 :                                0x40200800, 0x40000820, 0x40000820, 0x00000020,
; 8369 :                                0x40200820, 0x40000020, 0x40000000, 0x00000800,
; 8370 :                                0x40200000, 0x40000800, 0x00200820, 0x40200020,
; 8371 :                                0x40000800, 0x00000820, 0x00200000, 0x40200800,
; 8372 :                                0x00000020, 0x00200000, 0x00000800, 0x00200820,
; 8373 :                                0x00000040, 0x00820040, 0x00820000, 0x10800040,
; 8374 :                                0x00020000, 0x00000040, 0x10000000, 0x00820000,
; 8375 :                                0x10020040, 0x00020000, 0x00800040, 0x10020040,
; 8376 :                                0x10800040, 0x10820000, 0x00020040, 0x10000000,
; 8377 :                                0x00800000, 0x10020000, 0x10020000, 0x00000000,
; 8378 :                                0x10000040, 0x10820040, 0x10820040, 0x00800040,
; 8379 :                                0x10820000, 0x10000040, 0x00000000, 0x10800000,
; 8380 :                                0x00820040, 0x00800000, 0x10800000, 0x00020040,
; 8381 :                                0x00020000, 0x10800040, 0x00000040, 0x00800000,
; 8382 :                                0x10000000, 0x00820000, 0x10800040, 0x10020040,
; 8383 :                                0x00800040, 0x10000000, 0x10820000, 0x00820040,
; 8384 :                                0x10020040, 0x00000040, 0x00800000, 0x10820000,
; 8385 :                                0x10820040, 0x00020040, 0x10800000, 0x10820040,
; 8386 :                                0x00820000, 0x00000000, 0x10020000, 0x10800000,
; 8387 :                                0x00020040, 0x00800040, 0x10000040, 0x00020000,
; 8388 :                                0x00000000, 0x10020000, 0x00820040, 0x10000040,
; 8389 :                                0x08000004, 0x08100000, 0x00001000, 0x08101004,
; 8390 :                                0x08100000, 0x00000004, 0x08101004, 0x00100000,
; 8391 :                                0x08001000, 0x00101004, 0x00100000, 0x08000004,
; 8392 :                                0x00100004, 0x08001000, 0x08000000, 0x00001004,
; 8393 :                                0x00000000, 0x00100004, 0x08001004, 0x00001000,
; 8394 :                                0x00101000, 0x08001004, 0x00000004, 0x08100004,
; 8395 :                                0x08100004, 0x00000000, 0x00101004, 0x08101000,
; 8396 :                                0x00001004, 0x00101000, 0x08101000, 0x08000000,
; 8397 :                                0x08001000, 0x00000004, 0x08100004, 0x00101000,
; 8398 :                                0x08101004, 0x00100000, 0x00001004, 0x08000004,
; 8399 :                                0x00100000, 0x08001000, 0x08000000, 0x00001004,
; 8400 :                                0x08000004, 0x08101004, 0x00101000, 0x08100000,
; 8401 :                                0x00101004, 0x08101000, 0x00000000, 0x08100004,
; 8402 :                                0x00000004, 0x00001000, 0x08100000, 0x00101004,
; 8403 :                                0x00001000, 0x00100004, 0x08001004, 0x00000000,
; 8404 :                                0x08101000, 0x08000000, 0x00100004, 0x08001004,
; 8405 :                                0x00080000, 0x81080000, 0x81000200, 0x00000000,
; 8406 :                                0x00000200, 0x81000200, 0x80080200, 0x01080200,
; 8407 :                                0x81080200, 0x00080000, 0x00000000, 0x81000000,
; 8408 :                                0x80000000, 0x01000000, 0x81080000, 0x80000200,
; 8409 :                                0x01000200, 0x80080200, 0x80080000, 0x01000200,
; 8410 :                                0x81000000, 0x01080000, 0x01080200, 0x80080000,
; 8411 :                                0x01080000, 0x00000200, 0x80000200, 0x81080200,
; 8412 :                                0x00080200, 0x80000000, 0x01000000, 0x00080200,
; 8413 :                                0x01000000, 0x00080200, 0x00080000, 0x81000200,
; 8414 :                                0x81000200, 0x81080000, 0x81080000, 0x80000000,
; 8415 :                                0x80080000, 0x01000000, 0x01000200, 0x00080000,
; 8416 :                                0x01080200, 0x80000200, 0x80080200, 0x01080200,
; 8417 :                                0x80000200, 0x81000000, 0x81080200, 0x01080000,
; 8418 :                                0x00080200, 0x00000000, 0x80000000, 0x81080200,
; 8419 :                                0x00000000, 0x80080200, 0x01080000, 0x00000200,
; 8420 :                                0x81000000, 0x01000200, 0x00000200, 0x80080000,
; 8421 :                                0x04000410, 0x00000400, 0x00010000, 0x04010410,
; 8422 :                                0x04000000, 0x04000410, 0x00000010, 0x04000000,
; 8423 :                                0x00010010, 0x04010000, 0x04010410, 0x00010400,
; 8424 :                                0x04010400, 0x00010410, 0x00000400, 0x00000010,
; 8425 :                                0x04010000, 0x04000010, 0x04000400, 0x00000410,
; 8426 :                                0x00010400, 0x00010010, 0x04010010, 0x04010400,
; 8427 :                                0x00000410, 0x00000000, 0x00000000, 0x04010010,
; 8428 :                                0x04000010, 0x04000400, 0x00010410, 0x00010000,
; 8429 :                                0x00010410, 0x00010000, 0x04010400, 0x00000400,
; 8430 :                                0x00000010, 0x04010010, 0x00000400, 0x00010410,
; 8431 :                                0x04000400, 0x00000010, 0x04000010, 0x04010000,
; 8432 :                                0x04010010, 0x04000000, 0x00010000, 0x04000410,
; 8433 :                                0x00000000, 0x04010410, 0x00010010, 0x04000010,
; 8434 :                                0x04010000, 0x04000400, 0x04000410, 0x00000000,
; 8435 :                                0x04010410, 0x00010400, 0x00010400, 0x00000410,
; 8436 :                                0x00000410, 0x00010010, 0x04000000, 0x04010400 };
; 8437 : 
; 8438 :     static const U32 OrConstant[24] =
; 8439 :                              { 0x80000000, 0x40000000, 0x20000000, 0x10000000,
; 8440 :                                0x08000000, 0x04000000, 0x00800000, 0x00400000,
; 8441 :                                0x00200000, 0x00100000, 0x00080000, 0x00040000,
; 8442 :                                0x00008000, 0x00004000, 0x00002000, 0x00001000,
; 8443 :                                0x00000800, 0x00000400, 0x00000080, 0x00000040,
; 8444 :                                0x00000020, 0x00000010, 0x00000008, 0x00000004 };
; 8445 : 
; 8446 :     BYTE  XorClocks[8];
; 8447 :     U32   XorResult[2];
; 8448 :     U32   OrResult[32];
; 8449 :     U32   wv[16];              // Work Values
; 8450 :     int   i, j;
; 8451 : 
; 8452 : 
; 8453 :     // Xor together the two input clock values.
; 8454 :     for( i = 0; i <= 7; i++ )

  00028	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00030	eb 0a		 jmp	 SHORT $LN4@gen_csv_si
$LN2@gen_csv_si:
  00032	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00036	ff c0		 inc	 eax
  00038	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@gen_csv_si:
  0003c	83 7c 24 20 07	 cmp	 DWORD PTR i$[rsp], 7
  00041	7f 32		 jg	 SHORT $LN3@gen_csv_si

; 8455 :         XorClocks[i] = pClock2[i] ^ pClock1[i];

  00043	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00048	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR pClock2$[rsp]
  00050	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00054	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00059	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR pClock1$[rsp]
  00061	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00065	33 c1		 xor	 eax, ecx
  00067	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0006c	88 84 0c 30 01
	00 00		 mov	 BYTE PTR XorClocks$[rsp+rcx], al
  00073	eb bd		 jmp	 SHORT $LN2@gen_csv_si
$LN3@gen_csv_si:

; 8456 : 
; 8457 :     // Process the input pClock1 value. The first 7 bits of each of the 8 bytes
; 8458 :     // of the value are tested and, if the bit is on, several OrConstant[] values
; 8459 :     // are or'ed into several OrRresult[] values. Before that however, ensure the
; 8460 :     // OrRresult[] values contain nothing.
; 8461 :     for( i = 0; i <= 31; i++ )

  00075	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007d	eb 0a		 jmp	 SHORT $LN7@gen_csv_si
$LN5@gen_csv_si:
  0007f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00083	ff c0		 inc	 eax
  00085	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@gen_csv_si:
  00089	83 7c 24 20 1f	 cmp	 DWORD PTR i$[rsp], 31
  0008e	7f 0f		 jg	 SHORT $LN6@gen_csv_si

; 8462 :         OrResult[i] = 0;

  00090	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00095	c7 44 84 70 00
	00 00 00	 mov	 DWORD PTR OrResult$[rsp+rax*4], 0
  0009d	eb e0		 jmp	 SHORT $LN5@gen_csv_si
$LN6@gen_csv_si:

; 8463 : 
; 8464 :     // Process the STCK value.
; 8465 :     if ((pClock1[0] & 0x80 ) == 0x80)

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  000b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b4	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000b9	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000be	0f 85 92 02 00
	00		 jne	 $LN11@gen_csv_si

; 8466 :     {
; 8467 :         OrResult[0]  |= OrConstant[11];

  000c4	b8 04 00 00 00	 mov	 eax, 4
  000c9	48 6b c0 00	 imul	 rax, rax, 0
  000cd	b9 04 00 00 00	 mov	 ecx, 4
  000d2	48 6b c9 0b	 imul	 rcx, rcx, 11
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  000dd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  000e0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  000e4	0b c1		 or	 eax, ecx
  000e6	b9 04 00 00 00	 mov	 ecx, 4
  000eb	48 6b c9 00	 imul	 rcx, rcx, 0
  000ef	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8468 :         OrResult[4]  |= OrConstant[2];

  000f3	b8 04 00 00 00	 mov	 eax, 4
  000f8	48 6b c0 04	 imul	 rax, rax, 4
  000fc	b9 04 00 00 00	 mov	 ecx, 4
  00101	48 6b c9 02	 imul	 rcx, rcx, 2
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0010c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0010f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00113	0b c1		 or	 eax, ecx
  00115	b9 04 00 00 00	 mov	 ecx, 4
  0011a	48 6b c9 04	 imul	 rcx, rcx, 4
  0011e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8469 :         OrResult[7]  |= OrConstant[10];

  00122	b8 04 00 00 00	 mov	 eax, 4
  00127	48 6b c0 07	 imul	 rax, rax, 7
  0012b	b9 04 00 00 00	 mov	 ecx, 4
  00130	48 6b c9 0a	 imul	 rcx, rcx, 10
  00134	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0013b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0013e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00142	0b c1		 or	 eax, ecx
  00144	b9 04 00 00 00	 mov	 ecx, 4
  00149	48 6b c9 07	 imul	 rcx, rcx, 7
  0014d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8470 :         OrResult[9]  |= OrConstant[2];

  00151	b8 04 00 00 00	 mov	 eax, 4
  00156	48 6b c0 09	 imul	 rax, rax, 9
  0015a	b9 04 00 00 00	 mov	 ecx, 4
  0015f	48 6b c9 02	 imul	 rcx, rcx, 2
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0016a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0016d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00171	0b c1		 or	 eax, ecx
  00173	b9 04 00 00 00	 mov	 ecx, 4
  00178	48 6b c9 09	 imul	 rcx, rcx, 9
  0017c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8471 :         OrResult[10] |= OrConstant[1];

  00180	b8 04 00 00 00	 mov	 eax, 4
  00185	48 6b c0 0a	 imul	 rax, rax, 10
  00189	b9 04 00 00 00	 mov	 ecx, 4
  0018e	48 6b c9 01	 imul	 rcx, rcx, 1
  00192	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00199	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0019c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  001a0	0b c1		 or	 eax, ecx
  001a2	b9 04 00 00 00	 mov	 ecx, 4
  001a7	48 6b c9 0a	 imul	 rcx, rcx, 10
  001ab	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8472 :         OrResult[12] |= OrConstant[7];

  001af	b8 04 00 00 00	 mov	 eax, 4
  001b4	48 6b c0 0c	 imul	 rax, rax, 12
  001b8	b9 04 00 00 00	 mov	 ecx, 4
  001bd	48 6b c9 07	 imul	 rcx, rcx, 7
  001c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  001c8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  001cb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  001cf	0b c1		 or	 eax, ecx
  001d1	b9 04 00 00 00	 mov	 ecx, 4
  001d6	48 6b c9 0c	 imul	 rcx, rcx, 12
  001da	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8473 :         OrResult[15] |= OrConstant[4];

  001de	b8 04 00 00 00	 mov	 eax, 4
  001e3	48 6b c0 0f	 imul	 rax, rax, 15
  001e7	b9 04 00 00 00	 mov	 ecx, 4
  001ec	48 6b c9 04	 imul	 rcx, rcx, 4
  001f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  001f7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  001fa	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  001fe	0b c1		 or	 eax, ecx
  00200	b9 04 00 00 00	 mov	 ecx, 4
  00205	48 6b c9 0f	 imul	 rcx, rcx, 15
  00209	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8474 :         OrResult[18] |= OrConstant[3];

  0020d	b8 04 00 00 00	 mov	 eax, 4
  00212	48 6b c0 12	 imul	 rax, rax, 18
  00216	b9 04 00 00 00	 mov	 ecx, 4
  0021b	48 6b c9 03	 imul	 rcx, rcx, 3
  0021f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00226	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00229	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0022d	0b c1		 or	 eax, ecx
  0022f	b9 04 00 00 00	 mov	 ecx, 4
  00234	48 6b c9 12	 imul	 rcx, rcx, 18
  00238	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8475 :         OrResult[20] |= OrConstant[10];

  0023c	b8 04 00 00 00	 mov	 eax, 4
  00241	48 6b c0 14	 imul	 rax, rax, 20
  00245	b9 04 00 00 00	 mov	 ecx, 4
  0024a	48 6b c9 0a	 imul	 rcx, rcx, 10
  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00255	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00258	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0025c	0b c1		 or	 eax, ecx
  0025e	b9 04 00 00 00	 mov	 ecx, 4
  00263	48 6b c9 14	 imul	 rcx, rcx, 20
  00267	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8476 :         OrResult[23] |= OrConstant[1];

  0026b	b8 04 00 00 00	 mov	 eax, 4
  00270	48 6b c0 17	 imul	 rax, rax, 23
  00274	b9 04 00 00 00	 mov	 ecx, 4
  00279	48 6b c9 01	 imul	 rcx, rcx, 1
  0027d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00284	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00287	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0028b	0b c1		 or	 eax, ecx
  0028d	b9 04 00 00 00	 mov	 ecx, 4
  00292	48 6b c9 17	 imul	 rcx, rcx, 23
  00296	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8477 :         OrResult[25] |= OrConstant[11];

  0029a	b8 04 00 00 00	 mov	 eax, 4
  0029f	48 6b c0 19	 imul	 rax, rax, 25
  002a3	b9 04 00 00 00	 mov	 ecx, 4
  002a8	48 6b c9 0b	 imul	 rcx, rcx, 11
  002ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  002b3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  002b6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  002ba	0b c1		 or	 eax, ecx
  002bc	b9 04 00 00 00	 mov	 ecx, 4
  002c1	48 6b c9 19	 imul	 rcx, rcx, 25
  002c5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8478 :         OrResult[26] |= OrConstant[9];

  002c9	b8 04 00 00 00	 mov	 eax, 4
  002ce	48 6b c0 1a	 imul	 rax, rax, 26
  002d2	b9 04 00 00 00	 mov	 ecx, 4
  002d7	48 6b c9 09	 imul	 rcx, rcx, 9
  002db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  002e2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  002e5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  002e9	0b c1		 or	 eax, ecx
  002eb	b9 04 00 00 00	 mov	 ecx, 4
  002f0	48 6b c9 1a	 imul	 rcx, rcx, 26
  002f4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8479 :         OrResult[29] |= OrConstant[3];

  002f8	b8 04 00 00 00	 mov	 eax, 4
  002fd	48 6b c0 1d	 imul	 rax, rax, 29
  00301	b9 04 00 00 00	 mov	 ecx, 4
  00306	48 6b c9 03	 imul	 rcx, rcx, 3
  0030a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00311	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00314	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00318	0b c1		 or	 eax, ecx
  0031a	b9 04 00 00 00	 mov	 ecx, 4
  0031f	48 6b c9 1d	 imul	 rcx, rcx, 29
  00323	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8480 :         OrResult[31] |= OrConstant[7];

  00327	b8 04 00 00 00	 mov	 eax, 4
  0032c	48 6b c0 1f	 imul	 rax, rax, 31
  00330	b9 04 00 00 00	 mov	 ecx, 4
  00335	48 6b c9 07	 imul	 rcx, rcx, 7
  00339	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00340	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00343	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00347	0b c1		 or	 eax, ecx
  00349	b9 04 00 00 00	 mov	 ecx, 4
  0034e	48 6b c9 1f	 imul	 rcx, rcx, 31
  00352	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN11@gen_csv_si:

; 8481 :     }
; 8482 :     if ((pClock1[0] & 0x40 ) == 0x40)

  00356	b8 01 00 00 00	 mov	 eax, 1
  0035b	48 6b c0 00	 imul	 rax, rax, 0
  0035f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  00367	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036b	83 e0 40	 and	 eax, 64			; 00000040H
  0036e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00371	0f 85 c1 02 00
	00		 jne	 $LN12@gen_csv_si

; 8483 :     {
; 8484 :         OrResult[1]  |= OrConstant[6];

  00377	b8 04 00 00 00	 mov	 eax, 4
  0037c	48 6b c0 01	 imul	 rax, rax, 1
  00380	b9 04 00 00 00	 mov	 ecx, 4
  00385	48 6b c9 06	 imul	 rcx, rcx, 6
  00389	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00390	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00393	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00397	0b c1		 or	 eax, ecx
  00399	b9 04 00 00 00	 mov	 ecx, 4
  0039e	48 6b c9 01	 imul	 rcx, rcx, 1
  003a2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8485 :         OrResult[2]  |= OrConstant[1];

  003a6	b8 04 00 00 00	 mov	 eax, 4
  003ab	48 6b c0 02	 imul	 rax, rax, 2
  003af	b9 04 00 00 00	 mov	 ecx, 4
  003b4	48 6b c9 01	 imul	 rcx, rcx, 1
  003b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  003bf	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  003c2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  003c6	0b c1		 or	 eax, ecx
  003c8	b9 04 00 00 00	 mov	 ecx, 4
  003cd	48 6b c9 02	 imul	 rcx, rcx, 2
  003d1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8486 :         OrResult[4]  |= OrConstant[7];

  003d5	b8 04 00 00 00	 mov	 eax, 4
  003da	48 6b c0 04	 imul	 rax, rax, 4
  003de	b9 04 00 00 00	 mov	 ecx, 4
  003e3	48 6b c9 07	 imul	 rcx, rcx, 7
  003e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  003ee	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  003f1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  003f5	0b c1		 or	 eax, ecx
  003f7	b9 04 00 00 00	 mov	 ecx, 4
  003fc	48 6b c9 04	 imul	 rcx, rcx, 4
  00400	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8487 :         OrResult[7]  |= OrConstant[4];

  00404	b8 04 00 00 00	 mov	 eax, 4
  00409	48 6b c0 07	 imul	 rax, rax, 7
  0040d	b9 04 00 00 00	 mov	 ecx, 4
  00412	48 6b c9 04	 imul	 rcx, rcx, 4
  00416	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0041d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00420	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00424	0b c1		 or	 eax, ecx
  00426	b9 04 00 00 00	 mov	 ecx, 4
  0042b	48 6b c9 07	 imul	 rcx, rcx, 7
  0042f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8488 :         OrResult[8]  |= OrConstant[6];

  00433	b8 04 00 00 00	 mov	 eax, 4
  00438	48 6b c0 08	 imul	 rax, rax, 8
  0043c	b9 04 00 00 00	 mov	 ecx, 4
  00441	48 6b c9 06	 imul	 rcx, rcx, 6
  00445	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0044c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0044f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00453	0b c1		 or	 eax, ecx
  00455	b9 04 00 00 00	 mov	 ecx, 4
  0045a	48 6b c9 08	 imul	 rcx, rcx, 8
  0045e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8489 :         OrResult[13] |= OrConstant[8];

  00462	b8 04 00 00 00	 mov	 eax, 4
  00467	48 6b c0 0d	 imul	 rax, rax, 13
  0046b	b9 04 00 00 00	 mov	 ecx, 4
  00470	48 6b c9 08	 imul	 rcx, rcx, 8
  00474	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0047b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0047e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00482	0b c1		 or	 eax, ecx
  00484	b9 04 00 00 00	 mov	 ecx, 4
  00489	48 6b c9 0d	 imul	 rcx, rcx, 13
  0048d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8490 :         OrResult[14] |= OrConstant[4];

  00491	b8 04 00 00 00	 mov	 eax, 4
  00496	48 6b c0 0e	 imul	 rax, rax, 14
  0049a	b9 04 00 00 00	 mov	 ecx, 4
  0049f	48 6b c9 04	 imul	 rcx, rcx, 4
  004a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  004aa	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  004ad	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  004b1	0b c1		 or	 eax, ecx
  004b3	b9 04 00 00 00	 mov	 ecx, 4
  004b8	48 6b c9 0e	 imul	 rcx, rcx, 14
  004bc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8491 :         OrResult[17] |= OrConstant[11];

  004c0	b8 04 00 00 00	 mov	 eax, 4
  004c5	48 6b c0 11	 imul	 rax, rax, 17
  004c9	b9 04 00 00 00	 mov	 ecx, 4
  004ce	48 6b c9 0b	 imul	 rcx, rcx, 11
  004d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  004d9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  004dc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  004e0	0b c1		 or	 eax, ecx
  004e2	b9 04 00 00 00	 mov	 ecx, 4
  004e7	48 6b c9 11	 imul	 rcx, rcx, 17
  004eb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8492 :         OrResult[18] |= OrConstant[9];

  004ef	b8 04 00 00 00	 mov	 eax, 4
  004f4	48 6b c0 12	 imul	 rax, rax, 18
  004f8	b9 04 00 00 00	 mov	 ecx, 4
  004fd	48 6b c9 09	 imul	 rcx, rcx, 9
  00501	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00508	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0050b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0050f	0b c1		 or	 eax, ecx
  00511	b9 04 00 00 00	 mov	 ecx, 4
  00516	48 6b c9 12	 imul	 rcx, rcx, 18
  0051a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8493 :         OrResult[21] |= OrConstant[3];

  0051e	b8 04 00 00 00	 mov	 eax, 4
  00523	48 6b c0 15	 imul	 rax, rax, 21
  00527	b9 04 00 00 00	 mov	 ecx, 4
  0052c	48 6b c9 03	 imul	 rcx, rcx, 3
  00530	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00537	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0053a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0053e	0b c1		 or	 eax, ecx
  00540	b9 04 00 00 00	 mov	 ecx, 4
  00545	48 6b c9 15	 imul	 rcx, rcx, 21
  00549	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8494 :         OrResult[22] |= OrConstant[11];

  0054d	b8 04 00 00 00	 mov	 eax, 4
  00552	48 6b c0 16	 imul	 rax, rax, 22
  00556	b9 04 00 00 00	 mov	 ecx, 4
  0055b	48 6b c9 0b	 imul	 rcx, rcx, 11
  0055f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00566	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00569	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0056d	0b c1		 or	 eax, ecx
  0056f	b9 04 00 00 00	 mov	 ecx, 4
  00574	48 6b c9 16	 imul	 rcx, rcx, 22
  00578	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8495 :         OrResult[25] |= OrConstant[5];

  0057c	b8 04 00 00 00	 mov	 eax, 4
  00581	48 6b c0 19	 imul	 rax, rax, 25
  00585	b9 04 00 00 00	 mov	 ecx, 4
  0058a	48 6b c9 05	 imul	 rcx, rcx, 5
  0058e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00595	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00598	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0059c	0b c1		 or	 eax, ecx
  0059e	b9 04 00 00 00	 mov	 ecx, 4
  005a3	48 6b c9 19	 imul	 rcx, rcx, 25
  005a7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8496 :         OrResult[26] |= OrConstant[8];

  005ab	b8 04 00 00 00	 mov	 eax, 4
  005b0	48 6b c0 1a	 imul	 rax, rax, 26
  005b4	b9 04 00 00 00	 mov	 ecx, 4
  005b9	48 6b c9 08	 imul	 rcx, rcx, 8
  005bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  005c4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  005c7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  005cb	0b c1		 or	 eax, ecx
  005cd	b9 04 00 00 00	 mov	 ecx, 4
  005d2	48 6b c9 1a	 imul	 rcx, rcx, 26
  005d6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8497 :         OrResult[28] |= OrConstant[0];

  005da	b8 04 00 00 00	 mov	 eax, 4
  005df	48 6b c0 1c	 imul	 rax, rax, 28
  005e3	b9 04 00 00 00	 mov	 ecx, 4
  005e8	48 6b c9 00	 imul	 rcx, rcx, 0
  005ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  005f3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  005f6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  005fa	0b c1		 or	 eax, ecx
  005fc	b9 04 00 00 00	 mov	 ecx, 4
  00601	48 6b c9 1c	 imul	 rcx, rcx, 28
  00605	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8498 :         OrResult[31] |= OrConstant[2];

  00609	b8 04 00 00 00	 mov	 eax, 4
  0060e	48 6b c0 1f	 imul	 rax, rax, 31
  00612	b9 04 00 00 00	 mov	 ecx, 4
  00617	48 6b c9 02	 imul	 rcx, rcx, 2
  0061b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00622	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00625	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00629	0b c1		 or	 eax, ecx
  0062b	b9 04 00 00 00	 mov	 ecx, 4
  00630	48 6b c9 1f	 imul	 rcx, rcx, 31
  00634	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN12@gen_csv_si:

; 8499 :     }
; 8500 :     if ((pClock1[0] & 0x20 ) == 0x20)

  00638	b8 01 00 00 00	 mov	 eax, 1
  0063d	48 6b c0 00	 imul	 rax, rax, 0
  00641	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  00649	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0064d	83 e0 20	 and	 eax, 32			; 00000020H
  00650	83 f8 20	 cmp	 eax, 32			; 00000020H
  00653	0f 85 34 02 00
	00		 jne	 $LN13@gen_csv_si

; 8501 :     {
; 8502 :         OrResult[0]  |= OrConstant[3];

  00659	b8 04 00 00 00	 mov	 eax, 4
  0065e	48 6b c0 00	 imul	 rax, rax, 0
  00662	b9 04 00 00 00	 mov	 ecx, 4
  00667	48 6b c9 03	 imul	 rcx, rcx, 3
  0066b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00672	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00675	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00679	0b c1		 or	 eax, ecx
  0067b	b9 04 00 00 00	 mov	 ecx, 4
  00680	48 6b c9 00	 imul	 rcx, rcx, 0
  00684	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8503 :         OrResult[5]  |= OrConstant[8];

  00688	b8 04 00 00 00	 mov	 eax, 4
  0068d	48 6b c0 05	 imul	 rax, rax, 5
  00691	b9 04 00 00 00	 mov	 ecx, 4
  00696	48 6b c9 08	 imul	 rcx, rcx, 8
  0069a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  006a1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  006a4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  006a8	0b c1		 or	 eax, ecx
  006aa	b9 04 00 00 00	 mov	 ecx, 4
  006af	48 6b c9 05	 imul	 rcx, rcx, 5
  006b3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8504 :         OrResult[6]  |= OrConstant[4];

  006b7	b8 04 00 00 00	 mov	 eax, 4
  006bc	48 6b c0 06	 imul	 rax, rax, 6
  006c0	b9 04 00 00 00	 mov	 ecx, 4
  006c5	48 6b c9 04	 imul	 rcx, rcx, 4
  006c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  006d0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  006d3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  006d7	0b c1		 or	 eax, ecx
  006d9	b9 04 00 00 00	 mov	 ecx, 4
  006de	48 6b c9 06	 imul	 rcx, rcx, 6
  006e2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8505 :         OrResult[9]  |= OrConstant[0];

  006e6	b8 04 00 00 00	 mov	 eax, 4
  006eb	48 6b c0 09	 imul	 rax, rax, 9
  006ef	b9 04 00 00 00	 mov	 ecx, 4
  006f4	48 6b c9 00	 imul	 rcx, rcx, 0
  006f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  006ff	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00702	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00706	0b c1		 or	 eax, ecx
  00708	b9 04 00 00 00	 mov	 ecx, 4
  0070d	48 6b c9 09	 imul	 rcx, rcx, 9
  00711	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8506 :         OrResult[10] |= OrConstant[5];

  00715	b8 04 00 00 00	 mov	 eax, 4
  0071a	48 6b c0 0a	 imul	 rax, rax, 10
  0071e	b9 04 00 00 00	 mov	 ecx, 4
  00723	48 6b c9 05	 imul	 rcx, rcx, 5
  00727	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0072e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00731	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00735	0b c1		 or	 eax, ecx
  00737	b9 04 00 00 00	 mov	 ecx, 4
  0073c	48 6b c9 0a	 imul	 rcx, rcx, 10
  00740	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8507 :         OrResult[13] |= OrConstant[7];

  00744	b8 04 00 00 00	 mov	 eax, 4
  00749	48 6b c0 0d	 imul	 rax, rax, 13
  0074d	b9 04 00 00 00	 mov	 ecx, 4
  00752	48 6b c9 07	 imul	 rcx, rcx, 7
  00756	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0075d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00760	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00764	0b c1		 or	 eax, ecx
  00766	b9 04 00 00 00	 mov	 ecx, 4
  0076b	48 6b c9 0d	 imul	 rcx, rcx, 13
  0076f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8508 :         OrResult[17] |= OrConstant[5];

  00773	b8 04 00 00 00	 mov	 eax, 4
  00778	48 6b c0 11	 imul	 rax, rax, 17
  0077c	b9 04 00 00 00	 mov	 ecx, 4
  00781	48 6b c9 05	 imul	 rcx, rcx, 5
  00785	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0078c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0078f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00793	0b c1		 or	 eax, ecx
  00795	b9 04 00 00 00	 mov	 ecx, 4
  0079a	48 6b c9 11	 imul	 rcx, rcx, 17
  0079e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8509 :         OrResult[18] |= OrConstant[8];

  007a2	b8 04 00 00 00	 mov	 eax, 4
  007a7	48 6b c0 12	 imul	 rax, rax, 18
  007ab	b9 04 00 00 00	 mov	 ecx, 4
  007b0	48 6b c9 08	 imul	 rcx, rcx, 8
  007b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  007bb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  007be	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  007c2	0b c1		 or	 eax, ecx
  007c4	b9 04 00 00 00	 mov	 ecx, 4
  007c9	48 6b c9 12	 imul	 rcx, rcx, 18
  007cd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8510 :         OrResult[20] |= OrConstant[0];

  007d1	b8 04 00 00 00	 mov	 eax, 4
  007d6	48 6b c0 14	 imul	 rax, rax, 20
  007da	b9 04 00 00 00	 mov	 ecx, 4
  007df	48 6b c9 00	 imul	 rcx, rcx, 0
  007e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  007ea	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  007ed	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  007f1	0b c1		 or	 eax, ecx
  007f3	b9 04 00 00 00	 mov	 ecx, 4
  007f8	48 6b c9 14	 imul	 rcx, rcx, 20
  007fc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8511 :         OrResult[23] |= OrConstant[6];

  00800	b8 04 00 00 00	 mov	 eax, 4
  00805	48 6b c0 17	 imul	 rax, rax, 23
  00809	b9 04 00 00 00	 mov	 ecx, 4
  0080e	48 6b c9 06	 imul	 rcx, rcx, 6
  00812	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00819	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0081c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00820	0b c1		 or	 eax, ecx
  00822	b9 04 00 00 00	 mov	 ecx, 4
  00827	48 6b c9 17	 imul	 rcx, rcx, 23
  0082b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8512 :         OrResult[27] |= OrConstant[9];

  0082f	b8 04 00 00 00	 mov	 eax, 4
  00834	48 6b c0 1b	 imul	 rax, rax, 27
  00838	b9 04 00 00 00	 mov	 ecx, 4
  0083d	48 6b c9 09	 imul	 rcx, rcx, 9
  00841	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00848	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0084b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0084f	0b c1		 or	 eax, ecx
  00851	b9 04 00 00 00	 mov	 ecx, 4
  00856	48 6b c9 1b	 imul	 rcx, rcx, 27
  0085a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8513 :         OrResult[30] |= OrConstant[6];

  0085e	b8 04 00 00 00	 mov	 eax, 4
  00863	48 6b c0 1e	 imul	 rax, rax, 30
  00867	b9 04 00 00 00	 mov	 ecx, 4
  0086c	48 6b c9 06	 imul	 rcx, rcx, 6
  00870	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00877	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0087a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0087e	0b c1		 or	 eax, ecx
  00880	b9 04 00 00 00	 mov	 ecx, 4
  00885	48 6b c9 1e	 imul	 rcx, rcx, 30
  00889	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN13@gen_csv_si:

; 8514 :     }
; 8515 :     if ((pClock1[0] & 0x10 ) == 0x10)

  0088d	b8 01 00 00 00	 mov	 eax, 1
  00892	48 6b c0 00	 imul	 rax, rax, 0
  00896	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0089e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008a2	83 e0 10	 and	 eax, 16
  008a5	83 f8 10	 cmp	 eax, 16
  008a8	0f 85 92 02 00
	00		 jne	 $LN14@gen_csv_si

; 8516 :     {
; 8517 :         OrResult[0]  |= OrConstant[21];

  008ae	b8 04 00 00 00	 mov	 eax, 4
  008b3	48 6b c0 00	 imul	 rax, rax, 0
  008b7	b9 04 00 00 00	 mov	 ecx, 4
  008bc	48 6b c9 15	 imul	 rcx, rcx, 21
  008c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  008c7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  008ca	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  008ce	0b c1		 or	 eax, ecx
  008d0	b9 04 00 00 00	 mov	 ecx, 4
  008d5	48 6b c9 00	 imul	 rcx, rcx, 0
  008d9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8518 :         OrResult[3]  |= OrConstant[22];

  008dd	b8 04 00 00 00	 mov	 eax, 4
  008e2	48 6b c0 03	 imul	 rax, rax, 3
  008e6	b9 04 00 00 00	 mov	 ecx, 4
  008eb	48 6b c9 16	 imul	 rcx, rcx, 22
  008ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  008f6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  008f9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  008fd	0b c1		 or	 eax, ecx
  008ff	b9 04 00 00 00	 mov	 ecx, 4
  00904	48 6b c9 03	 imul	 rcx, rcx, 3
  00908	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8519 :         OrResult[4]  |= OrConstant[14];

  0090c	b8 04 00 00 00	 mov	 eax, 4
  00911	48 6b c0 04	 imul	 rax, rax, 4
  00915	b9 04 00 00 00	 mov	 ecx, 4
  0091a	48 6b c9 0e	 imul	 rcx, rcx, 14
  0091e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00925	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00928	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0092c	0b c1		 or	 eax, ecx
  0092e	b9 04 00 00 00	 mov	 ecx, 4
  00933	48 6b c9 04	 imul	 rcx, rcx, 4
  00937	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8520 :         OrResult[7]  |= OrConstant[16];

  0093b	b8 04 00 00 00	 mov	 eax, 4
  00940	48 6b c0 07	 imul	 rax, rax, 7
  00944	b9 04 00 00 00	 mov	 ecx, 4
  00949	48 6b c9 10	 imul	 rcx, rcx, 16
  0094d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00954	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00957	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0095b	0b c1		 or	 eax, ecx
  0095d	b9 04 00 00 00	 mov	 ecx, 4
  00962	48 6b c9 07	 imul	 rcx, rcx, 7
  00966	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8521 :         OrResult[10] |= OrConstant[15];

  0096a	b8 04 00 00 00	 mov	 eax, 4
  0096f	48 6b c0 0a	 imul	 rax, rax, 10
  00973	b9 04 00 00 00	 mov	 ecx, 4
  00978	48 6b c9 0f	 imul	 rcx, rcx, 15
  0097c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00983	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00986	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0098a	0b c1		 or	 eax, ecx
  0098c	b9 04 00 00 00	 mov	 ecx, 4
  00991	48 6b c9 0a	 imul	 rcx, rcx, 10
  00995	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8522 :         OrResult[12] |= OrConstant[20];

  00999	b8 04 00 00 00	 mov	 eax, 4
  0099e	48 6b c0 0c	 imul	 rax, rax, 12
  009a2	b9 04 00 00 00	 mov	 ecx, 4
  009a7	48 6b c9 14	 imul	 rcx, rcx, 20
  009ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  009b2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  009b5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  009b9	0b c1		 or	 eax, ecx
  009bb	b9 04 00 00 00	 mov	 ecx, 4
  009c0	48 6b c9 0c	 imul	 rcx, rcx, 12
  009c4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8523 :         OrResult[14] |= OrConstant[12];

  009c8	b8 04 00 00 00	 mov	 eax, 4
  009cd	48 6b c0 0e	 imul	 rax, rax, 14
  009d1	b9 04 00 00 00	 mov	 ecx, 4
  009d6	48 6b c9 0c	 imul	 rcx, rcx, 12
  009da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  009e1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  009e4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  009e8	0b c1		 or	 eax, ecx
  009ea	b9 04 00 00 00	 mov	 ecx, 4
  009ef	48 6b c9 0e	 imul	 rcx, rcx, 14
  009f3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8524 :         OrResult[17] |= OrConstant[19];

  009f7	b8 04 00 00 00	 mov	 eax, 4
  009fc	48 6b c0 11	 imul	 rax, rax, 17
  00a00	b9 04 00 00 00	 mov	 ecx, 4
  00a05	48 6b c9 13	 imul	 rcx, rcx, 19
  00a09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00a10	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00a13	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00a17	0b c1		 or	 eax, ecx
  00a19	b9 04 00 00 00	 mov	 ecx, 4
  00a1e	48 6b c9 11	 imul	 rcx, rcx, 17
  00a22	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8525 :         OrResult[18] |= OrConstant[18];

  00a26	b8 04 00 00 00	 mov	 eax, 4
  00a2b	48 6b c0 12	 imul	 rax, rax, 18
  00a2f	b9 04 00 00 00	 mov	 ecx, 4
  00a34	48 6b c9 12	 imul	 rcx, rcx, 18
  00a38	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00a3f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00a42	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00a46	0b c1		 or	 eax, ecx
  00a48	b9 04 00 00 00	 mov	 ecx, 4
  00a4d	48 6b c9 12	 imul	 rcx, rcx, 18
  00a51	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8526 :         OrResult[21] |= OrConstant[18];

  00a55	b8 04 00 00 00	 mov	 eax, 4
  00a5a	48 6b c0 15	 imul	 rax, rax, 21
  00a5e	b9 04 00 00 00	 mov	 ecx, 4
  00a63	48 6b c9 12	 imul	 rcx, rcx, 18
  00a67	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00a6e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00a71	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00a75	0b c1		 or	 eax, ecx
  00a77	b9 04 00 00 00	 mov	 ecx, 4
  00a7c	48 6b c9 15	 imul	 rcx, rcx, 21
  00a80	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8527 :         OrResult[23] |= OrConstant[17];

  00a84	b8 04 00 00 00	 mov	 eax, 4
  00a89	48 6b c0 17	 imul	 rax, rax, 23
  00a8d	b9 04 00 00 00	 mov	 ecx, 4
  00a92	48 6b c9 11	 imul	 rcx, rcx, 17
  00a96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00a9d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00aa0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00aa4	0b c1		 or	 eax, ecx
  00aa6	b9 04 00 00 00	 mov	 ecx, 4
  00aab	48 6b c9 17	 imul	 rcx, rcx, 23
  00aaf	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8528 :         OrResult[25] |= OrConstant[20];

  00ab3	b8 04 00 00 00	 mov	 eax, 4
  00ab8	48 6b c0 19	 imul	 rax, rax, 25
  00abc	b9 04 00 00 00	 mov	 ecx, 4
  00ac1	48 6b c9 14	 imul	 rcx, rcx, 20
  00ac5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00acc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00acf	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00ad3	0b c1		 or	 eax, ecx
  00ad5	b9 04 00 00 00	 mov	 ecx, 4
  00ada	48 6b c9 19	 imul	 rcx, rcx, 25
  00ade	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8529 :         OrResult[26] |= OrConstant[13];

  00ae2	b8 04 00 00 00	 mov	 eax, 4
  00ae7	48 6b c0 1a	 imul	 rax, rax, 26
  00aeb	b9 04 00 00 00	 mov	 ecx, 4
  00af0	48 6b c9 0d	 imul	 rcx, rcx, 13
  00af4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00afb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00afe	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00b02	0b c1		 or	 eax, ecx
  00b04	b9 04 00 00 00	 mov	 ecx, 4
  00b09	48 6b c9 1a	 imul	 rcx, rcx, 26
  00b0d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8530 :         OrResult[30] |= OrConstant[17];

  00b11	b8 04 00 00 00	 mov	 eax, 4
  00b16	48 6b c0 1e	 imul	 rax, rax, 30
  00b1a	b9 04 00 00 00	 mov	 ecx, 4
  00b1f	48 6b c9 11	 imul	 rcx, rcx, 17
  00b23	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00b2a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00b2d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00b31	0b c1		 or	 eax, ecx
  00b33	b9 04 00 00 00	 mov	 ecx, 4
  00b38	48 6b c9 1e	 imul	 rcx, rcx, 30
  00b3c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN14@gen_csv_si:

; 8531 :     }
; 8532 :     if ((pClock1[0] & 0x08 ) == 0x08)

  00b40	b8 01 00 00 00	 mov	 eax, 1
  00b45	48 6b c0 00	 imul	 rax, rax, 0
  00b49	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  00b51	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b55	83 e0 08	 and	 eax, 8
  00b58	83 f8 08	 cmp	 eax, 8
  00b5b	0f 85 92 02 00
	00		 jne	 $LN15@gen_csv_si

; 8533 :     {
; 8534 :         OrResult[0]  |= OrConstant[13];

  00b61	b8 04 00 00 00	 mov	 eax, 4
  00b66	48 6b c0 00	 imul	 rax, rax, 0
  00b6a	b9 04 00 00 00	 mov	 ecx, 4
  00b6f	48 6b c9 0d	 imul	 rcx, rcx, 13
  00b73	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00b7a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00b7d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00b81	0b c1		 or	 eax, ecx
  00b83	b9 04 00 00 00	 mov	 ecx, 4
  00b88	48 6b c9 00	 imul	 rcx, rcx, 0
  00b8c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8535 :         OrResult[2]  |= OrConstant[23];

  00b90	b8 04 00 00 00	 mov	 eax, 4
  00b95	48 6b c0 02	 imul	 rax, rax, 2
  00b99	b9 04 00 00 00	 mov	 ecx, 4
  00b9e	48 6b c9 17	 imul	 rcx, rcx, 23
  00ba2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00ba9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00bac	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00bb0	0b c1		 or	 eax, ecx
  00bb2	b9 04 00 00 00	 mov	 ecx, 4
  00bb7	48 6b c9 02	 imul	 rcx, rcx, 2
  00bbb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8536 :         OrResult[4]  |= OrConstant[17];

  00bbf	b8 04 00 00 00	 mov	 eax, 4
  00bc4	48 6b c0 04	 imul	 rax, rax, 4
  00bc8	b9 04 00 00 00	 mov	 ecx, 4
  00bcd	48 6b c9 11	 imul	 rcx, rcx, 17
  00bd1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00bd8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00bdb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00bdf	0b c1		 or	 eax, ecx
  00be1	b9 04 00 00 00	 mov	 ecx, 4
  00be6	48 6b c9 04	 imul	 rcx, rcx, 4
  00bea	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8537 :         OrResult[7]  |= OrConstant[22];

  00bee	b8 04 00 00 00	 mov	 eax, 4
  00bf3	48 6b c0 07	 imul	 rax, rax, 7
  00bf7	b9 04 00 00 00	 mov	 ecx, 4
  00bfc	48 6b c9 16	 imul	 rcx, rcx, 22
  00c00	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00c07	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00c0a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00c0e	0b c1		 or	 eax, ecx
  00c10	b9 04 00 00 00	 mov	 ecx, 4
  00c15	48 6b c9 07	 imul	 rcx, rcx, 7
  00c19	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8538 :         OrResult[8]  |= OrConstant[14];

  00c1d	b8 04 00 00 00	 mov	 eax, 4
  00c22	48 6b c0 08	 imul	 rax, rax, 8
  00c26	b9 04 00 00 00	 mov	 ecx, 4
  00c2b	48 6b c9 0e	 imul	 rcx, rcx, 14
  00c2f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00c36	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00c39	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00c3d	0b c1		 or	 eax, ecx
  00c3f	b9 04 00 00 00	 mov	 ecx, 4
  00c44	48 6b c9 08	 imul	 rcx, rcx, 8
  00c48	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8539 :         OrResult[11] |= OrConstant[16];

  00c4c	b8 04 00 00 00	 mov	 eax, 4
  00c51	48 6b c0 0b	 imul	 rax, rax, 11
  00c55	b9 04 00 00 00	 mov	 ecx, 4
  00c5a	48 6b c9 10	 imul	 rcx, rcx, 16
  00c5e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00c65	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00c68	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00c6c	0b c1		 or	 eax, ecx
  00c6e	b9 04 00 00 00	 mov	 ecx, 4
  00c73	48 6b c9 0b	 imul	 rcx, rcx, 11
  00c77	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8540 :         OrResult[14] |= OrConstant[15];

  00c7b	b8 04 00 00 00	 mov	 eax, 4
  00c80	48 6b c0 0e	 imul	 rax, rax, 14
  00c84	b9 04 00 00 00	 mov	 ecx, 4
  00c89	48 6b c9 0f	 imul	 rcx, rcx, 15
  00c8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00c94	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00c97	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00c9b	0b c1		 or	 eax, ecx
  00c9d	b9 04 00 00 00	 mov	 ecx, 4
  00ca2	48 6b c9 0e	 imul	 rcx, rcx, 14
  00ca6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8541 :         OrResult[19] |= OrConstant[13];

  00caa	b8 04 00 00 00	 mov	 eax, 4
  00caf	48 6b c0 13	 imul	 rax, rax, 19
  00cb3	b9 04 00 00 00	 mov	 ecx, 4
  00cb8	48 6b c9 0d	 imul	 rcx, rcx, 13
  00cbc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00cc3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00cc6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00cca	0b c1		 or	 eax, ecx
  00ccc	b9 04 00 00 00	 mov	 ecx, 4
  00cd1	48 6b c9 13	 imul	 rcx, rcx, 19
  00cd5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8542 :         OrResult[21] |= OrConstant[19];

  00cd9	b8 04 00 00 00	 mov	 eax, 4
  00cde	48 6b c0 15	 imul	 rax, rax, 21
  00ce2	b9 04 00 00 00	 mov	 ecx, 4
  00ce7	48 6b c9 13	 imul	 rcx, rcx, 19
  00ceb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00cf2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00cf5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00cf9	0b c1		 or	 eax, ecx
  00cfb	b9 04 00 00 00	 mov	 ecx, 4
  00d00	48 6b c9 15	 imul	 rcx, rcx, 21
  00d04	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8543 :         OrResult[22] |= OrConstant[18];

  00d08	b8 04 00 00 00	 mov	 eax, 4
  00d0d	48 6b c0 16	 imul	 rax, rax, 22
  00d11	b9 04 00 00 00	 mov	 ecx, 4
  00d16	48 6b c9 12	 imul	 rcx, rcx, 18
  00d1a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00d21	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00d24	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00d28	0b c1		 or	 eax, ecx
  00d2a	b9 04 00 00 00	 mov	 ecx, 4
  00d2f	48 6b c9 16	 imul	 rcx, rcx, 22
  00d33	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8544 :         OrResult[25] |= OrConstant[18];

  00d37	b8 04 00 00 00	 mov	 eax, 4
  00d3c	48 6b c0 19	 imul	 rax, rax, 25
  00d40	b9 04 00 00 00	 mov	 ecx, 4
  00d45	48 6b c9 12	 imul	 rcx, rcx, 18
  00d49	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00d50	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00d53	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00d57	0b c1		 or	 eax, ecx
  00d59	b9 04 00 00 00	 mov	 ecx, 4
  00d5e	48 6b c9 19	 imul	 rcx, rcx, 25
  00d62	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8545 :         OrResult[27] |= OrConstant[17];

  00d66	b8 04 00 00 00	 mov	 eax, 4
  00d6b	48 6b c0 1b	 imul	 rax, rax, 27
  00d6f	b9 04 00 00 00	 mov	 ecx, 4
  00d74	48 6b c9 11	 imul	 rcx, rcx, 17
  00d78	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00d7f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00d82	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00d86	0b c1		 or	 eax, ecx
  00d88	b9 04 00 00 00	 mov	 ecx, 4
  00d8d	48 6b c9 1b	 imul	 rcx, rcx, 27
  00d91	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8546 :         OrResult[29] |= OrConstant[20];

  00d95	b8 04 00 00 00	 mov	 eax, 4
  00d9a	48 6b c0 1d	 imul	 rax, rax, 29
  00d9e	b9 04 00 00 00	 mov	 ecx, 4
  00da3	48 6b c9 14	 imul	 rcx, rcx, 20
  00da7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00dae	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00db1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00db5	0b c1		 or	 eax, ecx
  00db7	b9 04 00 00 00	 mov	 ecx, 4
  00dbc	48 6b c9 1d	 imul	 rcx, rcx, 29
  00dc0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8547 :         OrResult[31] |= OrConstant[14];

  00dc4	b8 04 00 00 00	 mov	 eax, 4
  00dc9	48 6b c0 1f	 imul	 rax, rax, 31
  00dcd	b9 04 00 00 00	 mov	 ecx, 4
  00dd2	48 6b c9 0e	 imul	 rcx, rcx, 14
  00dd6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00ddd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00de0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00de4	0b c1		 or	 eax, ecx
  00de6	b9 04 00 00 00	 mov	 ecx, 4
  00deb	48 6b c9 1f	 imul	 rcx, rcx, 31
  00def	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN15@gen_csv_si:

; 8548 :     }
; 8549 :     if ((pClock1[0] & 0x04 ) == 0x04)

  00df3	b8 01 00 00 00	 mov	 eax, 1
  00df8	48 6b c0 00	 imul	 rax, rax, 0
  00dfc	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  00e04	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e08	83 e0 04	 and	 eax, 4
  00e0b	83 f8 04	 cmp	 eax, 4
  00e0e	0f 85 92 02 00
	00		 jne	 $LN16@gen_csv_si

; 8550 :     {
; 8551 :         OrResult[0]  |= OrConstant[18];

  00e14	b8 04 00 00 00	 mov	 eax, 4
  00e19	48 6b c0 00	 imul	 rax, rax, 0
  00e1d	b9 04 00 00 00	 mov	 ecx, 4
  00e22	48 6b c9 12	 imul	 rcx, rcx, 18
  00e26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00e2d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00e30	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00e34	0b c1		 or	 eax, ecx
  00e36	b9 04 00 00 00	 mov	 ecx, 4
  00e3b	48 6b c9 00	 imul	 rcx, rcx, 0
  00e3f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8552 :         OrResult[3]  |= OrConstant[15];

  00e43	b8 04 00 00 00	 mov	 eax, 4
  00e48	48 6b c0 03	 imul	 rax, rax, 3
  00e4c	b9 04 00 00 00	 mov	 ecx, 4
  00e51	48 6b c9 0f	 imul	 rcx, rcx, 15
  00e55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00e5c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00e5f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00e63	0b c1		 or	 eax, ecx
  00e65	b9 04 00 00 00	 mov	 ecx, 4
  00e6a	48 6b c9 03	 imul	 rcx, rcx, 3
  00e6e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8553 :         OrResult[4]  |= OrConstant[16];

  00e72	b8 04 00 00 00	 mov	 eax, 4
  00e77	48 6b c0 04	 imul	 rax, rax, 4
  00e7b	b9 04 00 00 00	 mov	 ecx, 4
  00e80	48 6b c9 10	 imul	 rcx, rcx, 16
  00e84	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00e8b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00e8e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00e92	0b c1		 or	 eax, ecx
  00e94	b9 04 00 00 00	 mov	 ecx, 4
  00e99	48 6b c9 04	 imul	 rcx, rcx, 4
  00e9d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8554 :         OrResult[6]  |= OrConstant[19];

  00ea1	b8 04 00 00 00	 mov	 eax, 4
  00ea6	48 6b c0 06	 imul	 rax, rax, 6
  00eaa	b9 04 00 00 00	 mov	 ecx, 4
  00eaf	48 6b c9 13	 imul	 rcx, rcx, 19
  00eb3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00eba	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00ebd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00ec1	0b c1		 or	 eax, ecx
  00ec3	b9 04 00 00 00	 mov	 ecx, 4
  00ec8	48 6b c9 06	 imul	 rcx, rcx, 6
  00ecc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8555 :         OrResult[9]  |= OrConstant[14];

  00ed0	b8 04 00 00 00	 mov	 eax, 4
  00ed5	48 6b c0 09	 imul	 rax, rax, 9
  00ed9	b9 04 00 00 00	 mov	 ecx, 4
  00ede	48 6b c9 0e	 imul	 rcx, rcx, 14
  00ee2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00ee9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00eec	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00ef0	0b c1		 or	 eax, ecx
  00ef2	b9 04 00 00 00	 mov	 ecx, 4
  00ef7	48 6b c9 09	 imul	 rcx, rcx, 9
  00efb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8556 :         OrResult[10] |= OrConstant[23];

  00eff	b8 04 00 00 00	 mov	 eax, 4
  00f04	48 6b c0 0a	 imul	 rax, rax, 10
  00f08	b9 04 00 00 00	 mov	 ecx, 4
  00f0d	48 6b c9 17	 imul	 rcx, rcx, 23
  00f11	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00f18	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00f1b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00f1f	0b c1		 or	 eax, ecx
  00f21	b9 04 00 00 00	 mov	 ecx, 4
  00f26	48 6b c9 0a	 imul	 rcx, rcx, 10
  00f2a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8557 :         OrResult[12] |= OrConstant[17];

  00f2e	b8 04 00 00 00	 mov	 eax, 4
  00f33	48 6b c0 0c	 imul	 rax, rax, 12
  00f37	b9 04 00 00 00	 mov	 ecx, 4
  00f3c	48 6b c9 11	 imul	 rcx, rcx, 17
  00f40	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00f47	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00f4a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00f4e	0b c1		 or	 eax, ecx
  00f50	b9 04 00 00 00	 mov	 ecx, 4
  00f55	48 6b c9 0c	 imul	 rcx, rcx, 12
  00f59	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8558 :         OrResult[15] |= OrConstant[22];

  00f5d	b8 04 00 00 00	 mov	 eax, 4
  00f62	48 6b c0 0f	 imul	 rax, rax, 15
  00f66	b9 04 00 00 00	 mov	 ecx, 4
  00f6b	48 6b c9 16	 imul	 rcx, rcx, 22
  00f6f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00f76	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00f79	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00f7d	0b c1		 or	 eax, ecx
  00f7f	b9 04 00 00 00	 mov	 ecx, 4
  00f84	48 6b c9 0f	 imul	 rcx, rcx, 15
  00f88	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8559 :         OrResult[17] |= OrConstant[12];

  00f8c	b8 04 00 00 00	 mov	 eax, 4
  00f91	48 6b c0 11	 imul	 rax, rax, 17
  00f95	b9 04 00 00 00	 mov	 ecx, 4
  00f9a	48 6b c9 0c	 imul	 rcx, rcx, 12
  00f9e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00fa5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00fa8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00fac	0b c1		 or	 eax, ecx
  00fae	b9 04 00 00 00	 mov	 ecx, 4
  00fb3	48 6b c9 11	 imul	 rcx, rcx, 17
  00fb7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8560 :         OrResult[19] |= OrConstant[23];

  00fbb	b8 04 00 00 00	 mov	 eax, 4
  00fc0	48 6b c0 13	 imul	 rax, rax, 19
  00fc4	b9 04 00 00 00	 mov	 ecx, 4
  00fc9	48 6b c9 17	 imul	 rcx, rcx, 23
  00fcd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  00fd4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00fd7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  00fdb	0b c1		 or	 eax, ecx
  00fdd	b9 04 00 00 00	 mov	 ecx, 4
  00fe2	48 6b c9 13	 imul	 rcx, rcx, 19
  00fe6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8561 :         OrResult[20] |= OrConstant[22];

  00fea	b8 04 00 00 00	 mov	 eax, 4
  00fef	48 6b c0 14	 imul	 rax, rax, 20
  00ff3	b9 04 00 00 00	 mov	 ecx, 4
  00ff8	48 6b c9 16	 imul	 rcx, rcx, 22
  00ffc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01003	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01006	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0100a	0b c1		 or	 eax, ecx
  0100c	b9 04 00 00 00	 mov	 ecx, 4
  01011	48 6b c9 14	 imul	 rcx, rcx, 20
  01015	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8562 :         OrResult[23] |= OrConstant[21];

  01019	b8 04 00 00 00	 mov	 eax, 4
  0101e	48 6b c0 17	 imul	 rax, rax, 23
  01022	b9 04 00 00 00	 mov	 ecx, 4
  01027	48 6b c9 15	 imul	 rcx, rcx, 21
  0102b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01032	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01035	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01039	0b c1		 or	 eax, ecx
  0103b	b9 04 00 00 00	 mov	 ecx, 4
  01040	48 6b c9 17	 imul	 rcx, rcx, 23
  01044	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8563 :         OrResult[27] |= OrConstant[13];

  01048	b8 04 00 00 00	 mov	 eax, 4
  0104d	48 6b c0 1b	 imul	 rax, rax, 27
  01051	b9 04 00 00 00	 mov	 ecx, 4
  01056	48 6b c9 0d	 imul	 rcx, rcx, 13
  0105a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01061	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01064	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01068	0b c1		 or	 eax, ecx
  0106a	b9 04 00 00 00	 mov	 ecx, 4
  0106f	48 6b c9 1b	 imul	 rcx, rcx, 27
  01073	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8564 :         OrResult[29] |= OrConstant[19];

  01077	b8 04 00 00 00	 mov	 eax, 4
  0107c	48 6b c0 1d	 imul	 rax, rax, 29
  01080	b9 04 00 00 00	 mov	 ecx, 4
  01085	48 6b c9 13	 imul	 rcx, rcx, 19
  01089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01090	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01093	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01097	0b c1		 or	 eax, ecx
  01099	b9 04 00 00 00	 mov	 ecx, 4
  0109e	48 6b c9 1d	 imul	 rcx, rcx, 29
  010a2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN16@gen_csv_si:

; 8565 :     }
; 8566 :     if ((pClock1[0] & 0x02 ) == 0x02)

  010a6	b8 01 00 00 00	 mov	 eax, 1
  010ab	48 6b c0 00	 imul	 rax, rax, 0
  010af	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  010b7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010bb	83 e0 02	 and	 eax, 2
  010be	83 f8 02	 cmp	 eax, 2
  010c1	0f 85 63 02 00
	00		 jne	 $LN17@gen_csv_si

; 8567 :     {
; 8568 :         OrResult[1]  |= OrConstant[21];

  010c7	b8 04 00 00 00	 mov	 eax, 4
  010cc	48 6b c0 01	 imul	 rax, rax, 1
  010d0	b9 04 00 00 00	 mov	 ecx, 4
  010d5	48 6b c9 15	 imul	 rcx, rcx, 21
  010d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  010e0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  010e3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  010e7	0b c1		 or	 eax, ecx
  010e9	b9 04 00 00 00	 mov	 ecx, 4
  010ee	48 6b c9 01	 imul	 rcx, rcx, 1
  010f2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8569 :         OrResult[2]  |= OrConstant[15];

  010f6	b8 04 00 00 00	 mov	 eax, 4
  010fb	48 6b c0 02	 imul	 rax, rax, 2
  010ff	b9 04 00 00 00	 mov	 ecx, 4
  01104	48 6b c9 0f	 imul	 rcx, rcx, 15
  01108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0110f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01112	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01116	0b c1		 or	 eax, ecx
  01118	b9 04 00 00 00	 mov	 ecx, 4
  0111d	48 6b c9 02	 imul	 rcx, rcx, 2
  01121	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8570 :         OrResult[4]  |= OrConstant[20];

  01125	b8 04 00 00 00	 mov	 eax, 4
  0112a	48 6b c0 04	 imul	 rax, rax, 4
  0112e	b9 04 00 00 00	 mov	 ecx, 4
  01133	48 6b c9 14	 imul	 rcx, rcx, 20
  01137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0113e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01141	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01145	0b c1		 or	 eax, ecx
  01147	b9 04 00 00 00	 mov	 ecx, 4
  0114c	48 6b c9 04	 imul	 rcx, rcx, 4
  01150	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8571 :         OrResult[6]  |= OrConstant[12];

  01154	b8 04 00 00 00	 mov	 eax, 4
  01159	48 6b c0 06	 imul	 rax, rax, 6
  0115d	b9 04 00 00 00	 mov	 ecx, 4
  01162	48 6b c9 0c	 imul	 rcx, rcx, 12
  01166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0116d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01170	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01174	0b c1		 or	 eax, ecx
  01176	b9 04 00 00 00	 mov	 ecx, 4
  0117b	48 6b c9 06	 imul	 rcx, rcx, 6
  0117f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8572 :         OrResult[11] |= OrConstant[15];

  01183	b8 04 00 00 00	 mov	 eax, 4
  01188	48 6b c0 0b	 imul	 rax, rax, 11
  0118c	b9 04 00 00 00	 mov	 ecx, 4
  01191	48 6b c9 0f	 imul	 rcx, rcx, 15
  01195	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0119c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0119f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  011a3	0b c1		 or	 eax, ecx
  011a5	b9 04 00 00 00	 mov	 ecx, 4
  011aa	48 6b c9 0b	 imul	 rcx, rcx, 11
  011ae	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8573 :         OrResult[12] |= OrConstant[16];

  011b2	b8 04 00 00 00	 mov	 eax, 4
  011b7	48 6b c0 0c	 imul	 rax, rax, 12
  011bb	b9 04 00 00 00	 mov	 ecx, 4
  011c0	48 6b c9 10	 imul	 rcx, rcx, 16
  011c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  011cb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  011ce	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  011d2	0b c1		 or	 eax, ecx
  011d4	b9 04 00 00 00	 mov	 ecx, 4
  011d9	48 6b c9 0c	 imul	 rcx, rcx, 12
  011dd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8574 :         OrResult[14] |= OrConstant[19];

  011e1	b8 04 00 00 00	 mov	 eax, 4
  011e6	48 6b c0 0e	 imul	 rax, rax, 14
  011ea	b9 04 00 00 00	 mov	 ecx, 4
  011ef	48 6b c9 13	 imul	 rcx, rcx, 19
  011f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  011fa	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  011fd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01201	0b c1		 or	 eax, ecx
  01203	b9 04 00 00 00	 mov	 ecx, 4
  01208	48 6b c9 0e	 imul	 rcx, rcx, 14
  0120c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8575 :         OrResult[17] |= OrConstant[20];

  01210	b8 04 00 00 00	 mov	 eax, 4
  01215	48 6b c0 11	 imul	 rax, rax, 17
  01219	b9 04 00 00 00	 mov	 ecx, 4
  0121e	48 6b c9 14	 imul	 rcx, rcx, 20
  01222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01229	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0122c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01230	0b c1		 or	 eax, ecx
  01232	b9 04 00 00 00	 mov	 ecx, 4
  01237	48 6b c9 11	 imul	 rcx, rcx, 17
  0123b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8576 :         OrResult[18] |= OrConstant[13];

  0123f	b8 04 00 00 00	 mov	 eax, 4
  01244	48 6b c0 12	 imul	 rax, rax, 18
  01248	b9 04 00 00 00	 mov	 ecx, 4
  0124d	48 6b c9 0d	 imul	 rcx, rcx, 13
  01251	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01258	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0125b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0125f	0b c1		 or	 eax, ecx
  01261	b9 04 00 00 00	 mov	 ecx, 4
  01266	48 6b c9 12	 imul	 rcx, rcx, 18
  0126a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8577 :         OrResult[22] |= OrConstant[21];

  0126e	b8 04 00 00 00	 mov	 eax, 4
  01273	48 6b c0 16	 imul	 rax, rax, 22
  01277	b9 04 00 00 00	 mov	 ecx, 4
  0127c	48 6b c9 15	 imul	 rcx, rcx, 21
  01280	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01287	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0128a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0128e	0b c1		 or	 eax, ecx
  01290	b9 04 00 00 00	 mov	 ecx, 4
  01295	48 6b c9 16	 imul	 rcx, rcx, 22
  01299	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8578 :         OrResult[25] |= OrConstant[12];

  0129d	b8 04 00 00 00	 mov	 eax, 4
  012a2	48 6b c0 19	 imul	 rax, rax, 25
  012a6	b9 04 00 00 00	 mov	 ecx, 4
  012ab	48 6b c9 0c	 imul	 rcx, rcx, 12
  012af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  012b6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  012b9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  012bd	0b c1		 or	 eax, ecx
  012bf	b9 04 00 00 00	 mov	 ecx, 4
  012c4	48 6b c9 19	 imul	 rcx, rcx, 25
  012c8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8579 :         OrResult[27] |= OrConstant[23];

  012cc	b8 04 00 00 00	 mov	 eax, 4
  012d1	48 6b c0 1b	 imul	 rax, rax, 27
  012d5	b9 04 00 00 00	 mov	 ecx, 4
  012da	48 6b c9 17	 imul	 rcx, rcx, 23
  012de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  012e5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  012e8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  012ec	0b c1		 or	 eax, ecx
  012ee	b9 04 00 00 00	 mov	 ecx, 4
  012f3	48 6b c9 1b	 imul	 rcx, rcx, 27
  012f7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8580 :         OrResult[28] |= OrConstant[22];

  012fb	b8 04 00 00 00	 mov	 eax, 4
  01300	48 6b c0 1c	 imul	 rax, rax, 28
  01304	b9 04 00 00 00	 mov	 ecx, 4
  01309	48 6b c9 16	 imul	 rcx, rcx, 22
  0130d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01314	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01317	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0131b	0b c1		 or	 eax, ecx
  0131d	b9 04 00 00 00	 mov	 ecx, 4
  01322	48 6b c9 1c	 imul	 rcx, rcx, 28
  01326	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN17@gen_csv_si:

; 8581 :     }
; 8582 :     if ((pClock1[1] & 0x80 ) == 0x80)

  0132a	b8 01 00 00 00	 mov	 eax, 1
  0132f	48 6b c0 01	 imul	 rax, rax, 1
  01333	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0133b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0133f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01344	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  01349	0f 85 92 02 00
	00		 jne	 $LN18@gen_csv_si

; 8583 :     {
; 8584 :         OrResult[1]  |= OrConstant[7];

  0134f	b8 04 00 00 00	 mov	 eax, 4
  01354	48 6b c0 01	 imul	 rax, rax, 1
  01358	b9 04 00 00 00	 mov	 ecx, 4
  0135d	48 6b c9 07	 imul	 rcx, rcx, 7
  01361	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01368	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0136b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0136f	0b c1		 or	 eax, ecx
  01371	b9 04 00 00 00	 mov	 ecx, 4
  01376	48 6b c9 01	 imul	 rcx, rcx, 1
  0137a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8585 :         OrResult[2]  |= OrConstant[11];

  0137e	b8 04 00 00 00	 mov	 eax, 4
  01383	48 6b c0 02	 imul	 rax, rax, 2
  01387	b9 04 00 00 00	 mov	 ecx, 4
  0138c	48 6b c9 0b	 imul	 rcx, rcx, 11
  01390	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01397	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0139a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0139e	0b c1		 or	 eax, ecx
  013a0	b9 04 00 00 00	 mov	 ecx, 4
  013a5	48 6b c9 02	 imul	 rcx, rcx, 2
  013a9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8586 :         OrResult[5]  |= OrConstant[5];

  013ad	b8 04 00 00 00	 mov	 eax, 4
  013b2	48 6b c0 05	 imul	 rax, rax, 5
  013b6	b9 04 00 00 00	 mov	 ecx, 4
  013bb	48 6b c9 05	 imul	 rcx, rcx, 5
  013bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  013c6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  013c9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  013cd	0b c1		 or	 eax, ecx
  013cf	b9 04 00 00 00	 mov	 ecx, 4
  013d4	48 6b c9 05	 imul	 rcx, rcx, 5
  013d8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8587 :         OrResult[6]  |= OrConstant[8];

  013dc	b8 04 00 00 00	 mov	 eax, 4
  013e1	48 6b c0 06	 imul	 rax, rax, 6
  013e5	b9 04 00 00 00	 mov	 ecx, 4
  013ea	48 6b c9 08	 imul	 rcx, rcx, 8
  013ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  013f5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  013f8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  013fc	0b c1		 or	 eax, ecx
  013fe	b9 04 00 00 00	 mov	 ecx, 4
  01403	48 6b c9 06	 imul	 rcx, rcx, 6
  01407	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8588 :         OrResult[8]  |= OrConstant[0];

  0140b	b8 04 00 00 00	 mov	 eax, 4
  01410	48 6b c0 08	 imul	 rax, rax, 8
  01414	b9 04 00 00 00	 mov	 ecx, 4
  01419	48 6b c9 00	 imul	 rcx, rcx, 0
  0141d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01424	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01427	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0142b	0b c1		 or	 eax, ecx
  0142d	b9 04 00 00 00	 mov	 ecx, 4
  01432	48 6b c9 08	 imul	 rcx, rcx, 8
  01436	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8589 :         OrResult[11] |= OrConstant[6];

  0143a	b8 04 00 00 00	 mov	 eax, 4
  0143f	48 6b c0 0b	 imul	 rax, rax, 11
  01443	b9 04 00 00 00	 mov	 ecx, 4
  01448	48 6b c9 06	 imul	 rcx, rcx, 6
  0144c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01453	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01456	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0145a	0b c1		 or	 eax, ecx
  0145c	b9 04 00 00 00	 mov	 ecx, 4
  01461	48 6b c9 0b	 imul	 rcx, rcx, 11
  01465	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8590 :         OrResult[15] |= OrConstant[9];

  01469	b8 04 00 00 00	 mov	 eax, 4
  0146e	48 6b c0 0f	 imul	 rax, rax, 15
  01472	b9 04 00 00 00	 mov	 ecx, 4
  01477	48 6b c9 09	 imul	 rcx, rcx, 9
  0147b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01482	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01485	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01489	0b c1		 or	 eax, ecx
  0148b	b9 04 00 00 00	 mov	 ecx, 4
  01490	48 6b c9 0f	 imul	 rcx, rcx, 15
  01494	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8591 :         OrResult[17] |= OrConstant[4];

  01498	b8 04 00 00 00	 mov	 eax, 4
  0149d	48 6b c0 11	 imul	 rax, rax, 17
  014a1	b9 04 00 00 00	 mov	 ecx, 4
  014a6	48 6b c9 04	 imul	 rcx, rcx, 4
  014aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  014b1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  014b4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  014b8	0b c1		 or	 eax, ecx
  014ba	b9 04 00 00 00	 mov	 ecx, 4
  014bf	48 6b c9 11	 imul	 rcx, rcx, 17
  014c3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8592 :         OrResult[18] |= OrConstant[6];

  014c7	b8 04 00 00 00	 mov	 eax, 4
  014cc	48 6b c0 12	 imul	 rax, rax, 18
  014d0	b9 04 00 00 00	 mov	 ecx, 4
  014d5	48 6b c9 06	 imul	 rcx, rcx, 6
  014d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  014e0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  014e3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  014e7	0b c1		 or	 eax, ecx
  014e9	b9 04 00 00 00	 mov	 ecx, 4
  014ee	48 6b c9 12	 imul	 rcx, rcx, 18
  014f2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8593 :         OrResult[23] |= OrConstant[8];

  014f6	b8 04 00 00 00	 mov	 eax, 4
  014fb	48 6b c0 17	 imul	 rax, rax, 23
  014ff	b9 04 00 00 00	 mov	 ecx, 4
  01504	48 6b c9 08	 imul	 rcx, rcx, 8
  01508	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0150f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01512	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01516	0b c1		 or	 eax, ecx
  01518	b9 04 00 00 00	 mov	 ecx, 4
  0151d	48 6b c9 17	 imul	 rcx, rcx, 23
  01521	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8594 :         OrResult[24] |= OrConstant[4];

  01525	b8 04 00 00 00	 mov	 eax, 4
  0152a	48 6b c0 18	 imul	 rax, rax, 24
  0152e	b9 04 00 00 00	 mov	 ecx, 4
  01533	48 6b c9 04	 imul	 rcx, rcx, 4
  01537	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0153e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01541	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01545	0b c1		 or	 eax, ecx
  01547	b9 04 00 00 00	 mov	 ecx, 4
  0154c	48 6b c9 18	 imul	 rcx, rcx, 24
  01550	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8595 :         OrResult[27] |= OrConstant[0];

  01554	b8 04 00 00 00	 mov	 eax, 4
  01559	48 6b c0 1b	 imul	 rax, rax, 27
  0155d	b9 04 00 00 00	 mov	 ecx, 4
  01562	48 6b c9 00	 imul	 rcx, rcx, 0
  01566	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0156d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01570	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01574	0b c1		 or	 eax, ecx
  01576	b9 04 00 00 00	 mov	 ecx, 4
  0157b	48 6b c9 1b	 imul	 rcx, rcx, 27
  0157f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8596 :         OrResult[28] |= OrConstant[5];

  01583	b8 04 00 00 00	 mov	 eax, 4
  01588	48 6b c0 1c	 imul	 rax, rax, 28
  0158c	b9 04 00 00 00	 mov	 ecx, 4
  01591	48 6b c9 05	 imul	 rcx, rcx, 5
  01595	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0159c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0159f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  015a3	0b c1		 or	 eax, ecx
  015a5	b9 04 00 00 00	 mov	 ecx, 4
  015aa	48 6b c9 1c	 imul	 rcx, rcx, 28
  015ae	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8597 :         OrResult[31] |= OrConstant[3];

  015b2	b8 04 00 00 00	 mov	 eax, 4
  015b7	48 6b c0 1f	 imul	 rax, rax, 31
  015bb	b9 04 00 00 00	 mov	 ecx, 4
  015c0	48 6b c9 03	 imul	 rcx, rcx, 3
  015c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  015cb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  015ce	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  015d2	0b c1		 or	 eax, ecx
  015d4	b9 04 00 00 00	 mov	 ecx, 4
  015d9	48 6b c9 1f	 imul	 rcx, rcx, 31
  015dd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN18@gen_csv_si:

; 8598 :     }
; 8599 :     if ((pClock1[1] & 0x40 ) == 0x40)

  015e1	b8 01 00 00 00	 mov	 eax, 1
  015e6	48 6b c0 01	 imul	 rax, rax, 1
  015ea	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  015f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  015f6	83 e0 40	 and	 eax, 64			; 00000040H
  015f9	83 f8 40	 cmp	 eax, 64			; 00000040H
  015fc	0f 85 63 02 00
	00		 jne	 $LN19@gen_csv_si

; 8600 :     {
; 8601 :         OrResult[1]  |= OrConstant[2];

  01602	b8 04 00 00 00	 mov	 eax, 4
  01607	48 6b c0 01	 imul	 rax, rax, 1
  0160b	b9 04 00 00 00	 mov	 ecx, 4
  01610	48 6b c9 02	 imul	 rcx, rcx, 2
  01614	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0161b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0161e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01622	0b c1		 or	 eax, ecx
  01624	b9 04 00 00 00	 mov	 ecx, 4
  01629	48 6b c9 01	 imul	 rcx, rcx, 1
  0162d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8602 :         OrResult[3]  |= OrConstant[6];

  01631	b8 04 00 00 00	 mov	 eax, 4
  01636	48 6b c0 03	 imul	 rax, rax, 3
  0163a	b9 04 00 00 00	 mov	 ecx, 4
  0163f	48 6b c9 06	 imul	 rcx, rcx, 6
  01643	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0164a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0164d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01651	0b c1		 or	 eax, ecx
  01653	b9 04 00 00 00	 mov	 ecx, 4
  01658	48 6b c9 03	 imul	 rcx, rcx, 3
  0165c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8603 :         OrResult[7]  |= OrConstant[9];

  01660	b8 04 00 00 00	 mov	 eax, 4
  01665	48 6b c0 07	 imul	 rax, rax, 7
  01669	b9 04 00 00 00	 mov	 ecx, 4
  0166e	48 6b c9 09	 imul	 rcx, rcx, 9
  01672	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01679	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0167c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01680	0b c1		 or	 eax, ecx
  01682	b9 04 00 00 00	 mov	 ecx, 4
  01687	48 6b c9 07	 imul	 rcx, rcx, 7
  0168b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8604 :         OrResult[10] |= OrConstant[3];

  0168f	b8 04 00 00 00	 mov	 eax, 4
  01694	48 6b c0 0a	 imul	 rax, rax, 10
  01698	b9 04 00 00 00	 mov	 ecx, 4
  0169d	48 6b c9 03	 imul	 rcx, rcx, 3
  016a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  016a8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  016ab	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  016af	0b c1		 or	 eax, ecx
  016b1	b9 04 00 00 00	 mov	 ecx, 4
  016b6	48 6b c9 0a	 imul	 rcx, rcx, 10
  016ba	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8605 :         OrResult[12] |= OrConstant[10];

  016be	b8 04 00 00 00	 mov	 eax, 4
  016c3	48 6b c0 0c	 imul	 rax, rax, 12
  016c7	b9 04 00 00 00	 mov	 ecx, 4
  016cc	48 6b c9 0a	 imul	 rcx, rcx, 10
  016d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  016d7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  016da	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  016de	0b c1		 or	 eax, ecx
  016e0	b9 04 00 00 00	 mov	 ecx, 4
  016e5	48 6b c9 0c	 imul	 rcx, rcx, 12
  016e9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8606 :         OrResult[15] |= OrConstant[1];

  016ed	b8 04 00 00 00	 mov	 eax, 4
  016f2	48 6b c0 0f	 imul	 rax, rax, 15
  016f6	b9 04 00 00 00	 mov	 ecx, 4
  016fb	48 6b c9 01	 imul	 rcx, rcx, 1
  016ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01706	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01709	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0170d	0b c1		 or	 eax, ecx
  0170f	b9 04 00 00 00	 mov	 ecx, 4
  01714	48 6b c9 0f	 imul	 rcx, rcx, 15
  01718	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8607 :         OrResult[16] |= OrConstant[4];

  0171c	b8 04 00 00 00	 mov	 eax, 4
  01721	48 6b c0 10	 imul	 rax, rax, 16
  01725	b9 04 00 00 00	 mov	 ecx, 4
  0172a	48 6b c9 04	 imul	 rcx, rcx, 4
  0172e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01735	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01738	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0173c	0b c1		 or	 eax, ecx
  0173e	b9 04 00 00 00	 mov	 ecx, 4
  01743	48 6b c9 10	 imul	 rcx, rcx, 16
  01747	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8608 :         OrResult[19] |= OrConstant[0];

  0174b	b8 04 00 00 00	 mov	 eax, 4
  01750	48 6b c0 13	 imul	 rax, rax, 19
  01754	b9 04 00 00 00	 mov	 ecx, 4
  01759	48 6b c9 00	 imul	 rcx, rcx, 0
  0175d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01764	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01767	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0176b	0b c1		 or	 eax, ecx
  0176d	b9 04 00 00 00	 mov	 ecx, 4
  01772	48 6b c9 13	 imul	 rcx, rcx, 19
  01776	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8609 :         OrResult[20] |= OrConstant[5];

  0177a	b8 04 00 00 00	 mov	 eax, 4
  0177f	48 6b c0 14	 imul	 rax, rax, 20
  01783	b9 04 00 00 00	 mov	 ecx, 4
  01788	48 6b c9 05	 imul	 rcx, rcx, 5
  0178c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01793	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01796	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0179a	0b c1		 or	 eax, ecx
  0179c	b9 04 00 00 00	 mov	 ecx, 4
  017a1	48 6b c9 14	 imul	 rcx, rcx, 20
  017a5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8610 :         OrResult[23] |= OrConstant[7];

  017a9	b8 04 00 00 00	 mov	 eax, 4
  017ae	48 6b c0 17	 imul	 rax, rax, 23
  017b2	b9 04 00 00 00	 mov	 ecx, 4
  017b7	48 6b c9 07	 imul	 rcx, rcx, 7
  017bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  017c2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  017c5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  017c9	0b c1		 or	 eax, ecx
  017cb	b9 04 00 00 00	 mov	 ecx, 4
  017d0	48 6b c9 17	 imul	 rcx, rcx, 23
  017d4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8611 :         OrResult[26] |= OrConstant[2];

  017d8	b8 04 00 00 00	 mov	 eax, 4
  017dd	48 6b c0 1a	 imul	 rax, rax, 26
  017e1	b9 04 00 00 00	 mov	 ecx, 4
  017e6	48 6b c9 02	 imul	 rcx, rcx, 2
  017ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  017f1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  017f4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  017f8	0b c1		 or	 eax, ecx
  017fa	b9 04 00 00 00	 mov	 ecx, 4
  017ff	48 6b c9 1a	 imul	 rcx, rcx, 26
  01803	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8612 :         OrResult[29] |= OrConstant[10];

  01807	b8 04 00 00 00	 mov	 eax, 4
  0180c	48 6b c0 1d	 imul	 rax, rax, 29
  01810	b9 04 00 00 00	 mov	 ecx, 4
  01815	48 6b c9 0a	 imul	 rcx, rcx, 10
  01819	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01820	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01823	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01827	0b c1		 or	 eax, ecx
  01829	b9 04 00 00 00	 mov	 ecx, 4
  0182e	48 6b c9 1d	 imul	 rcx, rcx, 29
  01832	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8613 :         OrResult[30] |= OrConstant[0];

  01836	b8 04 00 00 00	 mov	 eax, 4
  0183b	48 6b c0 1e	 imul	 rax, rax, 30
  0183f	b9 04 00 00 00	 mov	 ecx, 4
  01844	48 6b c9 00	 imul	 rcx, rcx, 0
  01848	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0184f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01852	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01856	0b c1		 or	 eax, ecx
  01858	b9 04 00 00 00	 mov	 ecx, 4
  0185d	48 6b c9 1e	 imul	 rcx, rcx, 30
  01861	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN19@gen_csv_si:

; 8614 :     }
; 8615 :     if ((pClock1[1] & 0x20 ) == 0x20)

  01865	b8 01 00 00 00	 mov	 eax, 1
  0186a	48 6b c0 01	 imul	 rax, rax, 1
  0186e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  01876	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0187a	83 e0 20	 and	 eax, 32			; 00000020H
  0187d	83 f8 20	 cmp	 eax, 32			; 00000020H
  01880	0f 85 92 02 00
	00		 jne	 $LN20@gen_csv_si

; 8616 :     {
; 8617 :         OrResult[0]  |= OrConstant[6];

  01886	b8 04 00 00 00	 mov	 eax, 4
  0188b	48 6b c0 00	 imul	 rax, rax, 0
  0188f	b9 04 00 00 00	 mov	 ecx, 4
  01894	48 6b c9 06	 imul	 rcx, rcx, 6
  01898	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0189f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  018a2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  018a6	0b c1		 or	 eax, ecx
  018a8	b9 04 00 00 00	 mov	 ecx, 4
  018ad	48 6b c9 00	 imul	 rcx, rcx, 0
  018b1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8618 :         OrResult[2]  |= OrConstant[3];

  018b5	b8 04 00 00 00	 mov	 eax, 4
  018ba	48 6b c0 02	 imul	 rax, rax, 2
  018be	b9 04 00 00 00	 mov	 ecx, 4
  018c3	48 6b c9 03	 imul	 rcx, rcx, 3
  018c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  018ce	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  018d1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  018d5	0b c1		 or	 eax, ecx
  018d7	b9 04 00 00 00	 mov	 ecx, 4
  018dc	48 6b c9 02	 imul	 rcx, rcx, 2
  018e0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8619 :         OrResult[4]  |= OrConstant[10];

  018e4	b8 04 00 00 00	 mov	 eax, 4
  018e9	48 6b c0 04	 imul	 rax, rax, 4
  018ed	b9 04 00 00 00	 mov	 ecx, 4
  018f2	48 6b c9 0a	 imul	 rcx, rcx, 10
  018f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  018fd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01900	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01904	0b c1		 or	 eax, ecx
  01906	b9 04 00 00 00	 mov	 ecx, 4
  0190b	48 6b c9 04	 imul	 rcx, rcx, 4
  0190f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8620 :         OrResult[7]  |= OrConstant[1];

  01913	b8 04 00 00 00	 mov	 eax, 4
  01918	48 6b c0 07	 imul	 rax, rax, 7
  0191c	b9 04 00 00 00	 mov	 ecx, 4
  01921	48 6b c9 01	 imul	 rcx, rcx, 1
  01925	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0192c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0192f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01933	0b c1		 or	 eax, ecx
  01935	b9 04 00 00 00	 mov	 ecx, 4
  0193a	48 6b c9 07	 imul	 rcx, rcx, 7
  0193e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8621 :         OrResult[9]  |= OrConstant[11];

  01942	b8 04 00 00 00	 mov	 eax, 4
  01947	48 6b c0 09	 imul	 rax, rax, 9
  0194b	b9 04 00 00 00	 mov	 ecx, 4
  01950	48 6b c9 0b	 imul	 rcx, rcx, 11
  01954	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0195b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0195e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01962	0b c1		 or	 eax, ecx
  01964	b9 04 00 00 00	 mov	 ecx, 4
  01969	48 6b c9 09	 imul	 rcx, rcx, 9
  0196d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8622 :         OrResult[10] |= OrConstant[9];

  01971	b8 04 00 00 00	 mov	 eax, 4
  01976	48 6b c0 0a	 imul	 rax, rax, 10
  0197a	b9 04 00 00 00	 mov	 ecx, 4
  0197f	48 6b c9 09	 imul	 rcx, rcx, 9
  01983	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0198a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0198d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01991	0b c1		 or	 eax, ecx
  01993	b9 04 00 00 00	 mov	 ecx, 4
  01998	48 6b c9 0a	 imul	 rcx, rcx, 10
  0199c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8623 :         OrResult[13] |= OrConstant[3];

  019a0	b8 04 00 00 00	 mov	 eax, 4
  019a5	48 6b c0 0d	 imul	 rax, rax, 13
  019a9	b9 04 00 00 00	 mov	 ecx, 4
  019ae	48 6b c9 03	 imul	 rcx, rcx, 3
  019b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  019b9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  019bc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  019c0	0b c1		 or	 eax, ecx
  019c2	b9 04 00 00 00	 mov	 ecx, 4
  019c7	48 6b c9 0d	 imul	 rcx, rcx, 13
  019cb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8624 :         OrResult[14] |= OrConstant[11];

  019cf	b8 04 00 00 00	 mov	 eax, 4
  019d4	48 6b c0 0e	 imul	 rax, rax, 14
  019d8	b9 04 00 00 00	 mov	 ecx, 4
  019dd	48 6b c9 0b	 imul	 rcx, rcx, 11
  019e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  019e8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  019eb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  019ef	0b c1		 or	 eax, ecx
  019f1	b9 04 00 00 00	 mov	 ecx, 4
  019f6	48 6b c9 0e	 imul	 rcx, rcx, 14
  019fa	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8625 :         OrResult[18] |= OrConstant[2];

  019fe	b8 04 00 00 00	 mov	 eax, 4
  01a03	48 6b c0 12	 imul	 rax, rax, 18
  01a07	b9 04 00 00 00	 mov	 ecx, 4
  01a0c	48 6b c9 02	 imul	 rcx, rcx, 2
  01a10	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01a17	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01a1a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01a1e	0b c1		 or	 eax, ecx
  01a20	b9 04 00 00 00	 mov	 ecx, 4
  01a25	48 6b c9 12	 imul	 rcx, rcx, 18
  01a29	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8626 :         OrResult[21] |= OrConstant[10];

  01a2d	b8 04 00 00 00	 mov	 eax, 4
  01a32	48 6b c0 15	 imul	 rax, rax, 21
  01a36	b9 04 00 00 00	 mov	 ecx, 4
  01a3b	48 6b c9 0a	 imul	 rcx, rcx, 10
  01a3f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01a46	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01a49	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01a4d	0b c1		 or	 eax, ecx
  01a4f	b9 04 00 00 00	 mov	 ecx, 4
  01a54	48 6b c9 15	 imul	 rcx, rcx, 21
  01a58	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8627 :         OrResult[23] |= OrConstant[2];

  01a5c	b8 04 00 00 00	 mov	 eax, 4
  01a61	48 6b c0 17	 imul	 rax, rax, 23
  01a65	b9 04 00 00 00	 mov	 ecx, 4
  01a6a	48 6b c9 02	 imul	 rcx, rcx, 2
  01a6e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01a75	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01a78	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01a7c	0b c1		 or	 eax, ecx
  01a7e	b9 04 00 00 00	 mov	 ecx, 4
  01a83	48 6b c9 17	 imul	 rcx, rcx, 23
  01a87	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8628 :         OrResult[24] |= OrConstant[1];

  01a8b	b8 04 00 00 00	 mov	 eax, 4
  01a90	48 6b c0 18	 imul	 rax, rax, 24
  01a94	b9 04 00 00 00	 mov	 ecx, 4
  01a99	48 6b c9 01	 imul	 rcx, rcx, 1
  01a9d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01aa4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01aa7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01aab	0b c1		 or	 eax, ecx
  01aad	b9 04 00 00 00	 mov	 ecx, 4
  01ab2	48 6b c9 18	 imul	 rcx, rcx, 24
  01ab6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8629 :         OrResult[26] |= OrConstant[7];

  01aba	b8 04 00 00 00	 mov	 eax, 4
  01abf	48 6b c0 1a	 imul	 rax, rax, 26
  01ac3	b9 04 00 00 00	 mov	 ecx, 4
  01ac8	48 6b c9 07	 imul	 rcx, rcx, 7
  01acc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01ad3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01ad6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01ada	0b c1		 or	 eax, ecx
  01adc	b9 04 00 00 00	 mov	 ecx, 4
  01ae1	48 6b c9 1a	 imul	 rcx, rcx, 26
  01ae5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8630 :         OrResult[29] |= OrConstant[4];

  01ae9	b8 04 00 00 00	 mov	 eax, 4
  01aee	48 6b c0 1d	 imul	 rax, rax, 29
  01af2	b9 04 00 00 00	 mov	 ecx, 4
  01af7	48 6b c9 04	 imul	 rcx, rcx, 4
  01afb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01b02	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01b05	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01b09	0b c1		 or	 eax, ecx
  01b0b	b9 04 00 00 00	 mov	 ecx, 4
  01b10	48 6b c9 1d	 imul	 rcx, rcx, 29
  01b14	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN20@gen_csv_si:

; 8631 :     }
; 8632 :     if ((pClock1[1] & 0x10 ) == 0x10)

  01b18	b8 01 00 00 00	 mov	 eax, 1
  01b1d	48 6b c0 01	 imul	 rax, rax, 1
  01b21	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  01b29	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01b2d	83 e0 10	 and	 eax, 16
  01b30	83 f8 10	 cmp	 eax, 16
  01b33	0f 85 63 02 00
	00		 jne	 $LN21@gen_csv_si

; 8633 :     {
; 8634 :         OrResult[0]  |= OrConstant[17];

  01b39	b8 04 00 00 00	 mov	 eax, 4
  01b3e	48 6b c0 00	 imul	 rax, rax, 0
  01b42	b9 04 00 00 00	 mov	 ecx, 4
  01b47	48 6b c9 11	 imul	 rcx, rcx, 17
  01b4b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01b52	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01b55	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01b59	0b c1		 or	 eax, ecx
  01b5b	b9 04 00 00 00	 mov	 ecx, 4
  01b60	48 6b c9 00	 imul	 rcx, rcx, 0
  01b64	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8635 :         OrResult[2]  |= OrConstant[21];

  01b68	b8 04 00 00 00	 mov	 eax, 4
  01b6d	48 6b c0 02	 imul	 rax, rax, 2
  01b71	b9 04 00 00 00	 mov	 ecx, 4
  01b76	48 6b c9 15	 imul	 rcx, rcx, 21
  01b7a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01b81	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01b84	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01b88	0b c1		 or	 eax, ecx
  01b8a	b9 04 00 00 00	 mov	 ecx, 4
  01b8f	48 6b c9 02	 imul	 rcx, rcx, 2
  01b93	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8636 :         OrResult[5]  |= OrConstant[12];

  01b97	b8 04 00 00 00	 mov	 eax, 4
  01b9c	48 6b c0 05	 imul	 rax, rax, 5
  01ba0	b9 04 00 00 00	 mov	 ecx, 4
  01ba5	48 6b c9 0c	 imul	 rcx, rcx, 12
  01ba9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01bb0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01bb3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01bb7	0b c1		 or	 eax, ecx
  01bb9	b9 04 00 00 00	 mov	 ecx, 4
  01bbe	48 6b c9 05	 imul	 rcx, rcx, 5
  01bc2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8637 :         OrResult[7]  |= OrConstant[23];

  01bc6	b8 04 00 00 00	 mov	 eax, 4
  01bcb	48 6b c0 07	 imul	 rax, rax, 7
  01bcf	b9 04 00 00 00	 mov	 ecx, 4
  01bd4	48 6b c9 17	 imul	 rcx, rcx, 23
  01bd8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01bdf	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01be2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01be6	0b c1		 or	 eax, ecx
  01be8	b9 04 00 00 00	 mov	 ecx, 4
  01bed	48 6b c9 07	 imul	 rcx, rcx, 7
  01bf1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8638 :         OrResult[8]  |= OrConstant[22];

  01bf5	b8 04 00 00 00	 mov	 eax, 4
  01bfa	48 6b c0 08	 imul	 rax, rax, 8
  01bfe	b9 04 00 00 00	 mov	 ecx, 4
  01c03	48 6b c9 16	 imul	 rcx, rcx, 22
  01c07	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01c0e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01c11	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01c15	0b c1		 or	 eax, ecx
  01c17	b9 04 00 00 00	 mov	 ecx, 4
  01c1c	48 6b c9 08	 imul	 rcx, rcx, 8
  01c20	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8639 :         OrResult[11] |= OrConstant[21];

  01c24	b8 04 00 00 00	 mov	 eax, 4
  01c29	48 6b c0 0b	 imul	 rax, rax, 11
  01c2d	b9 04 00 00 00	 mov	 ecx, 4
  01c32	48 6b c9 15	 imul	 rcx, rcx, 21
  01c36	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01c3d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01c40	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01c44	0b c1		 or	 eax, ecx
  01c46	b9 04 00 00 00	 mov	 ecx, 4
  01c4b	48 6b c9 0b	 imul	 rcx, rcx, 11
  01c4f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8640 :         OrResult[15] |= OrConstant[13];

  01c53	b8 04 00 00 00	 mov	 eax, 4
  01c58	48 6b c0 0f	 imul	 rax, rax, 15
  01c5c	b9 04 00 00 00	 mov	 ecx, 4
  01c61	48 6b c9 0d	 imul	 rcx, rcx, 13
  01c65	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01c6c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01c6f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01c73	0b c1		 or	 eax, ecx
  01c75	b9 04 00 00 00	 mov	 ecx, 4
  01c7a	48 6b c9 0f	 imul	 rcx, rcx, 15
  01c7e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8641 :         OrResult[16] |= OrConstant[12];

  01c82	b8 04 00 00 00	 mov	 eax, 4
  01c87	48 6b c0 10	 imul	 rax, rax, 16
  01c8b	b9 04 00 00 00	 mov	 ecx, 4
  01c90	48 6b c9 0c	 imul	 rcx, rcx, 12
  01c94	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01c9b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01c9e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01ca2	0b c1		 or	 eax, ecx
  01ca4	b9 04 00 00 00	 mov	 ecx, 4
  01ca9	48 6b c9 10	 imul	 rcx, rcx, 16
  01cad	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8642 :         OrResult[21] |= OrConstant[15];

  01cb1	b8 04 00 00 00	 mov	 eax, 4
  01cb6	48 6b c0 15	 imul	 rax, rax, 21
  01cba	b9 04 00 00 00	 mov	 ecx, 4
  01cbf	48 6b c9 0f	 imul	 rcx, rcx, 15
  01cc3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01cca	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01ccd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01cd1	0b c1		 or	 eax, ecx
  01cd3	b9 04 00 00 00	 mov	 ecx, 4
  01cd8	48 6b c9 15	 imul	 rcx, rcx, 21
  01cdc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8643 :         OrResult[22] |= OrConstant[16];

  01ce0	b8 04 00 00 00	 mov	 eax, 4
  01ce5	48 6b c0 16	 imul	 rax, rax, 22
  01ce9	b9 04 00 00 00	 mov	 ecx, 4
  01cee	48 6b c9 10	 imul	 rcx, rcx, 16
  01cf2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01cf9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01cfc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01d00	0b c1		 or	 eax, ecx
  01d02	b9 04 00 00 00	 mov	 ecx, 4
  01d07	48 6b c9 16	 imul	 rcx, rcx, 22
  01d0b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8644 :         OrResult[24] |= OrConstant[19];

  01d0f	b8 04 00 00 00	 mov	 eax, 4
  01d14	48 6b c0 18	 imul	 rax, rax, 24
  01d18	b9 04 00 00 00	 mov	 ecx, 4
  01d1d	48 6b c9 13	 imul	 rcx, rcx, 19
  01d21	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01d28	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01d2b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01d2f	0b c1		 or	 eax, ecx
  01d31	b9 04 00 00 00	 mov	 ecx, 4
  01d36	48 6b c9 18	 imul	 rcx, rcx, 24
  01d3a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8645 :         OrResult[27] |= OrConstant[14];

  01d3e	b8 04 00 00 00	 mov	 eax, 4
  01d43	48 6b c0 1b	 imul	 rax, rax, 27
  01d47	b9 04 00 00 00	 mov	 ecx, 4
  01d4c	48 6b c9 0e	 imul	 rcx, rcx, 14
  01d50	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01d57	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01d5a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01d5e	0b c1		 or	 eax, ecx
  01d60	b9 04 00 00 00	 mov	 ecx, 4
  01d65	48 6b c9 1b	 imul	 rcx, rcx, 27
  01d69	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8646 :         OrResult[28] |= OrConstant[23];

  01d6d	b8 04 00 00 00	 mov	 eax, 4
  01d72	48 6b c0 1c	 imul	 rax, rax, 28
  01d76	b9 04 00 00 00	 mov	 ecx, 4
  01d7b	48 6b c9 17	 imul	 rcx, rcx, 23
  01d7f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01d86	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01d89	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01d8d	0b c1		 or	 eax, ecx
  01d8f	b9 04 00 00 00	 mov	 ecx, 4
  01d94	48 6b c9 1c	 imul	 rcx, rcx, 28
  01d98	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN21@gen_csv_si:

; 8647 :     }
; 8648 :     if ((pClock1[1] & 0x08 ) == 0x08)

  01d9c	b8 01 00 00 00	 mov	 eax, 1
  01da1	48 6b c0 01	 imul	 rax, rax, 1
  01da5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  01dad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01db1	83 e0 08	 and	 eax, 8
  01db4	83 f8 08	 cmp	 eax, 8
  01db7	0f 85 92 02 00
	00		 jne	 $LN22@gen_csv_si

; 8649 :     {
; 8650 :         OrResult[1]  |= OrConstant[14];

  01dbd	b8 04 00 00 00	 mov	 eax, 4
  01dc2	48 6b c0 01	 imul	 rax, rax, 1
  01dc6	b9 04 00 00 00	 mov	 ecx, 4
  01dcb	48 6b c9 0e	 imul	 rcx, rcx, 14
  01dcf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01dd6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01dd9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01ddd	0b c1		 or	 eax, ecx
  01ddf	b9 04 00 00 00	 mov	 ecx, 4
  01de4	48 6b c9 01	 imul	 rcx, rcx, 1
  01de8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8651 :         OrResult[2]  |= OrConstant[13];

  01dec	b8 04 00 00 00	 mov	 eax, 4
  01df1	48 6b c0 02	 imul	 rax, rax, 2
  01df5	b9 04 00 00 00	 mov	 ecx, 4
  01dfa	48 6b c9 0d	 imul	 rcx, rcx, 13
  01dfe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01e05	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01e08	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01e0c	0b c1		 or	 eax, ecx
  01e0e	b9 04 00 00 00	 mov	 ecx, 4
  01e13	48 6b c9 02	 imul	 rcx, rcx, 2
  01e17	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8652 :         OrResult[6]  |= OrConstant[21];

  01e1b	b8 04 00 00 00	 mov	 eax, 4
  01e20	48 6b c0 06	 imul	 rax, rax, 6
  01e24	b9 04 00 00 00	 mov	 ecx, 4
  01e29	48 6b c9 15	 imul	 rcx, rcx, 21
  01e2d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01e34	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01e37	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01e3b	0b c1		 or	 eax, ecx
  01e3d	b9 04 00 00 00	 mov	 ecx, 4
  01e42	48 6b c9 06	 imul	 rcx, rcx, 6
  01e46	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8653 :         OrResult[9]  |= OrConstant[12];

  01e4a	b8 04 00 00 00	 mov	 eax, 4
  01e4f	48 6b c0 09	 imul	 rax, rax, 9
  01e53	b9 04 00 00 00	 mov	 ecx, 4
  01e58	48 6b c9 0c	 imul	 rcx, rcx, 12
  01e5c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01e63	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01e66	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01e6a	0b c1		 or	 eax, ecx
  01e6c	b9 04 00 00 00	 mov	 ecx, 4
  01e71	48 6b c9 09	 imul	 rcx, rcx, 9
  01e75	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8654 :         OrResult[11] |= OrConstant[23];

  01e79	b8 04 00 00 00	 mov	 eax, 4
  01e7e	48 6b c0 0b	 imul	 rax, rax, 11
  01e82	b9 04 00 00 00	 mov	 ecx, 4
  01e87	48 6b c9 17	 imul	 rcx, rcx, 23
  01e8b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01e92	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01e95	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01e99	0b c1		 or	 eax, ecx
  01e9b	b9 04 00 00 00	 mov	 ecx, 4
  01ea0	48 6b c9 0b	 imul	 rcx, rcx, 11
  01ea4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8655 :         OrResult[12] |= OrConstant[22];

  01ea8	b8 04 00 00 00	 mov	 eax, 4
  01ead	48 6b c0 0c	 imul	 rax, rax, 12
  01eb1	b9 04 00 00 00	 mov	 ecx, 4
  01eb6	48 6b c9 16	 imul	 rcx, rcx, 22
  01eba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01ec1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01ec4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01ec8	0b c1		 or	 eax, ecx
  01eca	b9 04 00 00 00	 mov	 ecx, 4
  01ecf	48 6b c9 0c	 imul	 rcx, rcx, 12
  01ed3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8656 :         OrResult[15] |= OrConstant[21];

  01ed7	b8 04 00 00 00	 mov	 eax, 4
  01edc	48 6b c0 0f	 imul	 rax, rax, 15
  01ee0	b9 04 00 00 00	 mov	 ecx, 4
  01ee5	48 6b c9 15	 imul	 rcx, rcx, 21
  01ee9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01ef0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01ef3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01ef7	0b c1		 or	 eax, ecx
  01ef9	b9 04 00 00 00	 mov	 ecx, 4
  01efe	48 6b c9 0f	 imul	 rcx, rcx, 15
  01f02	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8657 :         OrResult[16] |= OrConstant[15];

  01f06	b8 04 00 00 00	 mov	 eax, 4
  01f0b	48 6b c0 10	 imul	 rax, rax, 16
  01f0f	b9 04 00 00 00	 mov	 ecx, 4
  01f14	48 6b c9 0f	 imul	 rcx, rcx, 15
  01f18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01f1f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01f22	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01f26	0b c1		 or	 eax, ecx
  01f28	b9 04 00 00 00	 mov	 ecx, 4
  01f2d	48 6b c9 10	 imul	 rcx, rcx, 16
  01f31	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8658 :         OrResult[18] |= OrConstant[20];

  01f35	b8 04 00 00 00	 mov	 eax, 4
  01f3a	48 6b c0 12	 imul	 rax, rax, 18
  01f3e	b9 04 00 00 00	 mov	 ecx, 4
  01f43	48 6b c9 14	 imul	 rcx, rcx, 20
  01f47	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01f4e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01f51	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01f55	0b c1		 or	 eax, ecx
  01f57	b9 04 00 00 00	 mov	 ecx, 4
  01f5c	48 6b c9 12	 imul	 rcx, rcx, 18
  01f60	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8659 :         OrResult[20] |= OrConstant[12];

  01f64	b8 04 00 00 00	 mov	 eax, 4
  01f69	48 6b c0 14	 imul	 rax, rax, 20
  01f6d	b9 04 00 00 00	 mov	 ecx, 4
  01f72	48 6b c9 0c	 imul	 rcx, rcx, 12
  01f76	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01f7d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01f80	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01f84	0b c1		 or	 eax, ecx
  01f86	b9 04 00 00 00	 mov	 ecx, 4
  01f8b	48 6b c9 14	 imul	 rcx, rcx, 20
  01f8f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8660 :         OrResult[25] |= OrConstant[15];

  01f93	b8 04 00 00 00	 mov	 eax, 4
  01f98	48 6b c0 19	 imul	 rax, rax, 25
  01f9c	b9 04 00 00 00	 mov	 ecx, 4
  01fa1	48 6b c9 0f	 imul	 rcx, rcx, 15
  01fa5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01fac	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01faf	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01fb3	0b c1		 or	 eax, ecx
  01fb5	b9 04 00 00 00	 mov	 ecx, 4
  01fba	48 6b c9 19	 imul	 rcx, rcx, 25
  01fbe	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8661 :         OrResult[26] |= OrConstant[16];

  01fc2	b8 04 00 00 00	 mov	 eax, 4
  01fc7	48 6b c0 1a	 imul	 rax, rax, 26
  01fcb	b9 04 00 00 00	 mov	 ecx, 4
  01fd0	48 6b c9 10	 imul	 rcx, rcx, 16
  01fd4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  01fdb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  01fde	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  01fe2	0b c1		 or	 eax, ecx
  01fe4	b9 04 00 00 00	 mov	 ecx, 4
  01fe9	48 6b c9 1a	 imul	 rcx, rcx, 26
  01fed	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8662 :         OrResult[28] |= OrConstant[19];

  01ff1	b8 04 00 00 00	 mov	 eax, 4
  01ff6	48 6b c0 1c	 imul	 rax, rax, 28
  01ffa	b9 04 00 00 00	 mov	 ecx, 4
  01fff	48 6b c9 13	 imul	 rcx, rcx, 19
  02003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0200a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0200d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02011	0b c1		 or	 eax, ecx
  02013	b9 04 00 00 00	 mov	 ecx, 4
  02018	48 6b c9 1c	 imul	 rcx, rcx, 28
  0201c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8663 :         OrResult[31] |= OrConstant[20];

  02020	b8 04 00 00 00	 mov	 eax, 4
  02025	48 6b c0 1f	 imul	 rax, rax, 31
  02029	b9 04 00 00 00	 mov	 ecx, 4
  0202e	48 6b c9 14	 imul	 rcx, rcx, 20
  02032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02039	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0203c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02040	0b c1		 or	 eax, ecx
  02042	b9 04 00 00 00	 mov	 ecx, 4
  02047	48 6b c9 1f	 imul	 rcx, rcx, 31
  0204b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN22@gen_csv_si:

; 8664 :     }
; 8665 :     if ((pClock1[1] & 0x04 ) == 0x04)

  0204f	b8 01 00 00 00	 mov	 eax, 1
  02054	48 6b c0 01	 imul	 rax, rax, 1
  02058	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  02060	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02064	83 e0 04	 and	 eax, 4
  02067	83 f8 04	 cmp	 eax, 4
  0206a	0f 85 63 02 00
	00		 jne	 $LN23@gen_csv_si

; 8666 :     {
; 8667 :         OrResult[2]  |= OrConstant[18];

  02070	b8 04 00 00 00	 mov	 eax, 4
  02075	48 6b c0 02	 imul	 rax, rax, 2
  02079	b9 04 00 00 00	 mov	 ecx, 4
  0207e	48 6b c9 12	 imul	 rcx, rcx, 18
  02082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02089	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0208c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02090	0b c1		 or	 eax, ecx
  02092	b9 04 00 00 00	 mov	 ecx, 4
  02097	48 6b c9 02	 imul	 rcx, rcx, 2
  0209b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8668 :         OrResult[5]  |= OrConstant[18];

  0209f	b8 04 00 00 00	 mov	 eax, 4
  020a4	48 6b c0 05	 imul	 rax, rax, 5
  020a8	b9 04 00 00 00	 mov	 ecx, 4
  020ad	48 6b c9 12	 imul	 rcx, rcx, 18
  020b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  020b8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  020bb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  020bf	0b c1		 or	 eax, ecx
  020c1	b9 04 00 00 00	 mov	 ecx, 4
  020c6	48 6b c9 05	 imul	 rcx, rcx, 5
  020ca	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8669 :         OrResult[7]  |= OrConstant[17];

  020ce	b8 04 00 00 00	 mov	 eax, 4
  020d3	48 6b c0 07	 imul	 rax, rax, 7
  020d7	b9 04 00 00 00	 mov	 ecx, 4
  020dc	48 6b c9 11	 imul	 rcx, rcx, 17
  020e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  020e7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  020ea	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  020ee	0b c1		 or	 eax, ecx
  020f0	b9 04 00 00 00	 mov	 ecx, 4
  020f5	48 6b c9 07	 imul	 rcx, rcx, 7
  020f9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8670 :         OrResult[9]  |= OrConstant[20];

  020fd	b8 04 00 00 00	 mov	 eax, 4
  02102	48 6b c0 09	 imul	 rax, rax, 9
  02106	b9 04 00 00 00	 mov	 ecx, 4
  0210b	48 6b c9 14	 imul	 rcx, rcx, 20
  0210f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02116	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02119	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0211d	0b c1		 or	 eax, ecx
  0211f	b9 04 00 00 00	 mov	 ecx, 4
  02124	48 6b c9 09	 imul	 rcx, rcx, 9
  02128	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8671 :         OrResult[10] |= OrConstant[13];

  0212c	b8 04 00 00 00	 mov	 eax, 4
  02131	48 6b c0 0a	 imul	 rax, rax, 10
  02135	b9 04 00 00 00	 mov	 ecx, 4
  0213a	48 6b c9 0d	 imul	 rcx, rcx, 13
  0213e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02145	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02148	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0214c	0b c1		 or	 eax, ecx
  0214e	b9 04 00 00 00	 mov	 ecx, 4
  02153	48 6b c9 0a	 imul	 rcx, rcx, 10
  02157	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8672 :         OrResult[14] |= OrConstant[21];

  0215b	b8 04 00 00 00	 mov	 eax, 4
  02160	48 6b c0 0e	 imul	 rax, rax, 14
  02164	b9 04 00 00 00	 mov	 ecx, 4
  02169	48 6b c9 15	 imul	 rcx, rcx, 21
  0216d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02174	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02177	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0217b	0b c1		 or	 eax, ecx
  0217d	b9 04 00 00 00	 mov	 ecx, 4
  02182	48 6b c9 0e	 imul	 rcx, rcx, 14
  02186	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8673 :         OrResult[17] |= OrConstant[22];

  0218a	b8 04 00 00 00	 mov	 eax, 4
  0218f	48 6b c0 11	 imul	 rax, rax, 17
  02193	b9 04 00 00 00	 mov	 ecx, 4
  02198	48 6b c9 16	 imul	 rcx, rcx, 22
  0219c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  021a3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  021a6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  021aa	0b c1		 or	 eax, ecx
  021ac	b9 04 00 00 00	 mov	 ecx, 4
  021b1	48 6b c9 11	 imul	 rcx, rcx, 17
  021b5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8674 :         OrResult[18] |= OrConstant[14];

  021b9	b8 04 00 00 00	 mov	 eax, 4
  021be	48 6b c0 12	 imul	 rax, rax, 18
  021c2	b9 04 00 00 00	 mov	 ecx, 4
  021c7	48 6b c9 0e	 imul	 rcx, rcx, 14
  021cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  021d2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  021d5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  021d9	0b c1		 or	 eax, ecx
  021db	b9 04 00 00 00	 mov	 ecx, 4
  021e0	48 6b c9 12	 imul	 rcx, rcx, 18
  021e4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8675 :         OrResult[21] |= OrConstant[16];

  021e8	b8 04 00 00 00	 mov	 eax, 4
  021ed	48 6b c0 15	 imul	 rax, rax, 21
  021f1	b9 04 00 00 00	 mov	 ecx, 4
  021f6	48 6b c9 10	 imul	 rcx, rcx, 16
  021fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02201	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02204	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02208	0b c1		 or	 eax, ecx
  0220a	b9 04 00 00 00	 mov	 ecx, 4
  0220f	48 6b c9 15	 imul	 rcx, rcx, 21
  02213	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8676 :         OrResult[24] |= OrConstant[15];

  02217	b8 04 00 00 00	 mov	 eax, 4
  0221c	48 6b c0 18	 imul	 rax, rax, 24
  02220	b9 04 00 00 00	 mov	 ecx, 4
  02225	48 6b c9 0f	 imul	 rcx, rcx, 15
  02229	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02230	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02233	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02237	0b c1		 or	 eax, ecx
  02239	b9 04 00 00 00	 mov	 ecx, 4
  0223e	48 6b c9 18	 imul	 rcx, rcx, 24
  02242	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8677 :         OrResult[26] |= OrConstant[20];

  02246	b8 04 00 00 00	 mov	 eax, 4
  0224b	48 6b c0 1a	 imul	 rax, rax, 26
  0224f	b9 04 00 00 00	 mov	 ecx, 4
  02254	48 6b c9 14	 imul	 rcx, rcx, 20
  02258	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0225f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02262	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02266	0b c1		 or	 eax, ecx
  02268	b9 04 00 00 00	 mov	 ecx, 4
  0226d	48 6b c9 1a	 imul	 rcx, rcx, 26
  02271	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8678 :         OrResult[28] |= OrConstant[12];

  02275	b8 04 00 00 00	 mov	 eax, 4
  0227a	48 6b c0 1c	 imul	 rax, rax, 28
  0227e	b9 04 00 00 00	 mov	 ecx, 4
  02283	48 6b c9 0c	 imul	 rcx, rcx, 12
  02287	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0228e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02291	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02295	0b c1		 or	 eax, ecx
  02297	b9 04 00 00 00	 mov	 ecx, 4
  0229c	48 6b c9 1c	 imul	 rcx, rcx, 28
  022a0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8679 :         OrResult[31] |= OrConstant[19];

  022a4	b8 04 00 00 00	 mov	 eax, 4
  022a9	48 6b c0 1f	 imul	 rax, rax, 31
  022ad	b9 04 00 00 00	 mov	 ecx, 4
  022b2	48 6b c9 13	 imul	 rcx, rcx, 19
  022b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  022bd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  022c0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  022c4	0b c1		 or	 eax, ecx
  022c6	b9 04 00 00 00	 mov	 ecx, 4
  022cb	48 6b c9 1f	 imul	 rcx, rcx, 31
  022cf	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN23@gen_csv_si:

; 8680 :     }
; 8681 :     if ((pClock1[1] & 0x02 ) == 0x02)

  022d3	b8 01 00 00 00	 mov	 eax, 1
  022d8	48 6b c0 01	 imul	 rax, rax, 1
  022dc	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  022e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  022e8	83 e0 02	 and	 eax, 2
  022eb	83 f8 02	 cmp	 eax, 2
  022ee	0f 85 92 02 00
	00		 jne	 $LN24@gen_csv_si

; 8682 :     {
; 8683 :         OrResult[3]  |= OrConstant[21];

  022f4	b8 04 00 00 00	 mov	 eax, 4
  022f9	48 6b c0 03	 imul	 rax, rax, 3
  022fd	b9 04 00 00 00	 mov	 ecx, 4
  02302	48 6b c9 15	 imul	 rcx, rcx, 21
  02306	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0230d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02310	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02314	0b c1		 or	 eax, ecx
  02316	b9 04 00 00 00	 mov	 ecx, 4
  0231b	48 6b c9 03	 imul	 rcx, rcx, 3
  0231f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8684 :         OrResult[7]  |= OrConstant[13];

  02323	b8 04 00 00 00	 mov	 eax, 4
  02328	48 6b c0 07	 imul	 rax, rax, 7
  0232c	b9 04 00 00 00	 mov	 ecx, 4
  02331	48 6b c9 0d	 imul	 rcx, rcx, 13
  02335	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0233c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0233f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02343	0b c1		 or	 eax, ecx
  02345	b9 04 00 00 00	 mov	 ecx, 4
  0234a	48 6b c9 07	 imul	 rcx, rcx, 7
  0234e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8685 :         OrResult[9]  |= OrConstant[19];

  02352	b8 04 00 00 00	 mov	 eax, 4
  02357	48 6b c0 09	 imul	 rax, rax, 9
  0235b	b9 04 00 00 00	 mov	 ecx, 4
  02360	48 6b c9 13	 imul	 rcx, rcx, 19
  02364	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0236b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0236e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02372	0b c1		 or	 eax, ecx
  02374	b9 04 00 00 00	 mov	 ecx, 4
  02379	48 6b c9 09	 imul	 rcx, rcx, 9
  0237d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8686 :         OrResult[10] |= OrConstant[18];

  02381	b8 04 00 00 00	 mov	 eax, 4
  02386	48 6b c0 0a	 imul	 rax, rax, 10
  0238a	b9 04 00 00 00	 mov	 ecx, 4
  0238f	48 6b c9 12	 imul	 rcx, rcx, 18
  02393	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0239a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0239d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  023a1	0b c1		 or	 eax, ecx
  023a3	b9 04 00 00 00	 mov	 ecx, 4
  023a8	48 6b c9 0a	 imul	 rcx, rcx, 10
  023ac	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8687 :         OrResult[13] |= OrConstant[18];

  023b0	b8 04 00 00 00	 mov	 eax, 4
  023b5	48 6b c0 0d	 imul	 rax, rax, 13
  023b9	b9 04 00 00 00	 mov	 ecx, 4
  023be	48 6b c9 12	 imul	 rcx, rcx, 18
  023c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  023c9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  023cc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  023d0	0b c1		 or	 eax, ecx
  023d2	b9 04 00 00 00	 mov	 ecx, 4
  023d7	48 6b c9 0d	 imul	 rcx, rcx, 13
  023db	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8688 :         OrResult[15] |= OrConstant[17];

  023df	b8 04 00 00 00	 mov	 eax, 4
  023e4	48 6b c0 0f	 imul	 rax, rax, 15
  023e8	b9 04 00 00 00	 mov	 ecx, 4
  023ed	48 6b c9 11	 imul	 rcx, rcx, 17
  023f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  023f8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  023fb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  023ff	0b c1		 or	 eax, ecx
  02401	b9 04 00 00 00	 mov	 ecx, 4
  02406	48 6b c9 0f	 imul	 rcx, rcx, 15
  0240a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8689 :         OrResult[16] |= OrConstant[19];

  0240e	b8 04 00 00 00	 mov	 eax, 4
  02413	48 6b c0 10	 imul	 rax, rax, 16
  02417	b9 04 00 00 00	 mov	 ecx, 4
  0241c	48 6b c9 13	 imul	 rcx, rcx, 19
  02420	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02427	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0242a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0242e	0b c1		 or	 eax, ecx
  02430	b9 04 00 00 00	 mov	 ecx, 4
  02435	48 6b c9 10	 imul	 rcx, rcx, 16
  02439	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8690 :         OrResult[19] |= OrConstant[14];

  0243d	b8 04 00 00 00	 mov	 eax, 4
  02442	48 6b c0 13	 imul	 rax, rax, 19
  02446	b9 04 00 00 00	 mov	 ecx, 4
  0244b	48 6b c9 0e	 imul	 rcx, rcx, 14
  0244f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02456	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02459	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0245d	0b c1		 or	 eax, ecx
  0245f	b9 04 00 00 00	 mov	 ecx, 4
  02464	48 6b c9 13	 imul	 rcx, rcx, 19
  02468	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8691 :         OrResult[20] |= OrConstant[23];

  0246c	b8 04 00 00 00	 mov	 eax, 4
  02471	48 6b c0 14	 imul	 rax, rax, 20
  02475	b9 04 00 00 00	 mov	 ecx, 4
  0247a	48 6b c9 17	 imul	 rcx, rcx, 23
  0247e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02485	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02488	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0248c	0b c1		 or	 eax, ecx
  0248e	b9 04 00 00 00	 mov	 ecx, 4
  02493	48 6b c9 14	 imul	 rcx, rcx, 20
  02497	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8692 :         OrResult[22] |= OrConstant[17];

  0249b	b8 04 00 00 00	 mov	 eax, 4
  024a0	48 6b c0 16	 imul	 rax, rax, 22
  024a4	b9 04 00 00 00	 mov	 ecx, 4
  024a9	48 6b c9 11	 imul	 rcx, rcx, 17
  024ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  024b4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  024b7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  024bb	0b c1		 or	 eax, ecx
  024bd	b9 04 00 00 00	 mov	 ecx, 4
  024c2	48 6b c9 16	 imul	 rcx, rcx, 22
  024c6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8693 :         OrResult[25] |= OrConstant[22];

  024ca	b8 04 00 00 00	 mov	 eax, 4
  024cf	48 6b c0 19	 imul	 rax, rax, 25
  024d3	b9 04 00 00 00	 mov	 ecx, 4
  024d8	48 6b c9 16	 imul	 rcx, rcx, 22
  024dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  024e3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  024e6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  024ea	0b c1		 or	 eax, ecx
  024ec	b9 04 00 00 00	 mov	 ecx, 4
  024f1	48 6b c9 19	 imul	 rcx, rcx, 25
  024f5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8694 :         OrResult[26] |= OrConstant[14];

  024f9	b8 04 00 00 00	 mov	 eax, 4
  024fe	48 6b c0 1a	 imul	 rax, rax, 26
  02502	b9 04 00 00 00	 mov	 ecx, 4
  02507	48 6b c9 0e	 imul	 rcx, rcx, 14
  0250b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02512	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02515	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02519	0b c1		 or	 eax, ecx
  0251b	b9 04 00 00 00	 mov	 ecx, 4
  02520	48 6b c9 1a	 imul	 rcx, rcx, 26
  02524	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8695 :         OrResult[29] |= OrConstant[16];

  02528	b8 04 00 00 00	 mov	 eax, 4
  0252d	48 6b c0 1d	 imul	 rax, rax, 29
  02531	b9 04 00 00 00	 mov	 ecx, 4
  02536	48 6b c9 10	 imul	 rcx, rcx, 16
  0253a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02541	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02544	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02548	0b c1		 or	 eax, ecx
  0254a	b9 04 00 00 00	 mov	 ecx, 4
  0254f	48 6b c9 1d	 imul	 rcx, rcx, 29
  02553	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8696 :         OrResult[30] |= OrConstant[22];

  02557	b8 04 00 00 00	 mov	 eax, 4
  0255c	48 6b c0 1e	 imul	 rax, rax, 30
  02560	b9 04 00 00 00	 mov	 ecx, 4
  02565	48 6b c9 16	 imul	 rcx, rcx, 22
  02569	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02570	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02573	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02577	0b c1		 or	 eax, ecx
  02579	b9 04 00 00 00	 mov	 ecx, 4
  0257e	48 6b c9 1e	 imul	 rcx, rcx, 30
  02582	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN24@gen_csv_si:

; 8697 :     }
; 8698 :     if ((pClock1[2] & 0x80 ) == 0x80)

  02586	b8 01 00 00 00	 mov	 eax, 1
  0258b	48 6b c0 02	 imul	 rax, rax, 2
  0258f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  02597	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0259b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  025a0	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  025a5	0f 85 92 02 00
	00		 jne	 $LN25@gen_csv_si

; 8699 :     {
; 8700 :         OrResult[1]  |= OrConstant[3];

  025ab	b8 04 00 00 00	 mov	 eax, 4
  025b0	48 6b c0 01	 imul	 rax, rax, 1
  025b4	b9 04 00 00 00	 mov	 ecx, 4
  025b9	48 6b c9 03	 imul	 rcx, rcx, 3
  025bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  025c4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  025c7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  025cb	0b c1		 or	 eax, ecx
  025cd	b9 04 00 00 00	 mov	 ecx, 4
  025d2	48 6b c9 01	 imul	 rcx, rcx, 1
  025d6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8701 :         OrResult[3]  |= OrConstant[7];

  025da	b8 04 00 00 00	 mov	 eax, 4
  025df	48 6b c0 03	 imul	 rax, rax, 3
  025e3	b9 04 00 00 00	 mov	 ecx, 4
  025e8	48 6b c9 07	 imul	 rcx, rcx, 7
  025ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  025f3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  025f6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  025fa	0b c1		 or	 eax, ecx
  025fc	b9 04 00 00 00	 mov	 ecx, 4
  02601	48 6b c9 03	 imul	 rcx, rcx, 3
  02605	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8702 :         OrResult[6]  |= OrConstant[2];

  02609	b8 04 00 00 00	 mov	 eax, 4
  0260e	48 6b c0 06	 imul	 rax, rax, 6
  02612	b9 04 00 00 00	 mov	 ecx, 4
  02617	48 6b c9 02	 imul	 rcx, rcx, 2
  0261b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02622	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02625	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02629	0b c1		 or	 eax, ecx
  0262b	b9 04 00 00 00	 mov	 ecx, 4
  02630	48 6b c9 06	 imul	 rcx, rcx, 6
  02634	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8703 :         OrResult[9]  |= OrConstant[10];

  02638	b8 04 00 00 00	 mov	 eax, 4
  0263d	48 6b c0 09	 imul	 rax, rax, 9
  02641	b9 04 00 00 00	 mov	 ecx, 4
  02646	48 6b c9 0a	 imul	 rcx, rcx, 10
  0264a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02651	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02654	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02658	0b c1		 or	 eax, ecx
  0265a	b9 04 00 00 00	 mov	 ecx, 4
  0265f	48 6b c9 09	 imul	 rcx, rcx, 9
  02663	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8704 :         OrResult[11] |= OrConstant[2];

  02667	b8 04 00 00 00	 mov	 eax, 4
  0266c	48 6b c0 0b	 imul	 rax, rax, 11
  02670	b9 04 00 00 00	 mov	 ecx, 4
  02675	48 6b c9 02	 imul	 rcx, rcx, 2
  02679	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02680	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02683	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02687	0b c1		 or	 eax, ecx
  02689	b9 04 00 00 00	 mov	 ecx, 4
  0268e	48 6b c9 0b	 imul	 rcx, rcx, 11
  02692	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8705 :         OrResult[12] |= OrConstant[1];

  02696	b8 04 00 00 00	 mov	 eax, 4
  0269b	48 6b c0 0c	 imul	 rax, rax, 12
  0269f	b9 04 00 00 00	 mov	 ecx, 4
  026a4	48 6b c9 01	 imul	 rcx, rcx, 1
  026a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  026af	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  026b2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  026b6	0b c1		 or	 eax, ecx
  026b8	b9 04 00 00 00	 mov	 ecx, 4
  026bd	48 6b c9 0c	 imul	 rcx, rcx, 12
  026c1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8706 :         OrResult[14] |= OrConstant[7];

  026c5	b8 04 00 00 00	 mov	 eax, 4
  026ca	48 6b c0 0e	 imul	 rax, rax, 14
  026ce	b9 04 00 00 00	 mov	 ecx, 4
  026d3	48 6b c9 07	 imul	 rcx, rcx, 7
  026d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  026de	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  026e1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  026e5	0b c1		 or	 eax, ecx
  026e7	b9 04 00 00 00	 mov	 ecx, 4
  026ec	48 6b c9 0e	 imul	 rcx, rcx, 14
  026f0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8707 :         OrResult[17] |= OrConstant[9];

  026f4	b8 04 00 00 00	 mov	 eax, 4
  026f9	48 6b c0 11	 imul	 rax, rax, 17
  026fd	b9 04 00 00 00	 mov	 ecx, 4
  02702	48 6b c9 09	 imul	 rcx, rcx, 9
  02706	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0270d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02710	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02714	0b c1		 or	 eax, ecx
  02716	b9 04 00 00 00	 mov	 ecx, 4
  0271b	48 6b c9 11	 imul	 rcx, rcx, 17
  0271f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8708 :         OrResult[20] |= OrConstant[3];

  02723	b8 04 00 00 00	 mov	 eax, 4
  02728	48 6b c0 14	 imul	 rax, rax, 20
  0272c	b9 04 00 00 00	 mov	 ecx, 4
  02731	48 6b c9 03	 imul	 rcx, rcx, 3
  02735	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0273c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0273f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02743	0b c1		 or	 eax, ecx
  02745	b9 04 00 00 00	 mov	 ecx, 4
  0274a	48 6b c9 14	 imul	 rcx, rcx, 20
  0274e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8709 :         OrResult[22] |= OrConstant[10];

  02752	b8 04 00 00 00	 mov	 eax, 4
  02757	48 6b c0 16	 imul	 rax, rax, 22
  0275b	b9 04 00 00 00	 mov	 ecx, 4
  02760	48 6b c9 0a	 imul	 rcx, rcx, 10
  02764	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0276b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0276e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02772	0b c1		 or	 eax, ecx
  02774	b9 04 00 00 00	 mov	 ecx, 4
  02779	48 6b c9 16	 imul	 rcx, rcx, 22
  0277d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8710 :         OrResult[25] |= OrConstant[1];

  02781	b8 04 00 00 00	 mov	 eax, 4
  02786	48 6b c0 19	 imul	 rax, rax, 25
  0278a	b9 04 00 00 00	 mov	 ecx, 4
  0278f	48 6b c9 01	 imul	 rcx, rcx, 1
  02793	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0279a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0279d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  027a1	0b c1		 or	 eax, ecx
  027a3	b9 04 00 00 00	 mov	 ecx, 4
  027a8	48 6b c9 19	 imul	 rcx, rcx, 25
  027ac	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8711 :         OrResult[27] |= OrConstant[11];

  027b0	b8 04 00 00 00	 mov	 eax, 4
  027b5	48 6b c0 1b	 imul	 rax, rax, 27
  027b9	b9 04 00 00 00	 mov	 ecx, 4
  027be	48 6b c9 0b	 imul	 rcx, rcx, 11
  027c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  027c9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  027cc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  027d0	0b c1		 or	 eax, ecx
  027d2	b9 04 00 00 00	 mov	 ecx, 4
  027d7	48 6b c9 1b	 imul	 rcx, rcx, 27
  027db	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8712 :         OrResult[28] |= OrConstant[9];

  027df	b8 04 00 00 00	 mov	 eax, 4
  027e4	48 6b c0 1c	 imul	 rax, rax, 28
  027e8	b9 04 00 00 00	 mov	 ecx, 4
  027ed	48 6b c9 09	 imul	 rcx, rcx, 9
  027f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  027f8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  027fb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  027ff	0b c1		 or	 eax, ecx
  02801	b9 04 00 00 00	 mov	 ecx, 4
  02806	48 6b c9 1c	 imul	 rcx, rcx, 28
  0280a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8713 :         OrResult[30] |= OrConstant[5];

  0280e	b8 04 00 00 00	 mov	 eax, 4
  02813	48 6b c0 1e	 imul	 rax, rax, 30
  02817	b9 04 00 00 00	 mov	 ecx, 4
  0281c	48 6b c9 05	 imul	 rcx, rcx, 5
  02820	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02827	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0282a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0282e	0b c1		 or	 eax, ecx
  02830	b9 04 00 00 00	 mov	 ecx, 4
  02835	48 6b c9 1e	 imul	 rcx, rcx, 30
  02839	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN25@gen_csv_si:

; 8714 :     }
; 8715 :     if ((pClock1[2] & 0x40 ) == 0x40)

  0283d	b8 01 00 00 00	 mov	 eax, 1
  02842	48 6b c0 02	 imul	 rax, rax, 2
  02846	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0284e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02852	83 e0 40	 and	 eax, 64			; 00000040H
  02855	83 f8 40	 cmp	 eax, 64			; 00000040H
  02858	0f 85 c1 02 00
	00		 jne	 $LN26@gen_csv_si

; 8716 :     {
; 8717 :         OrResult[0]  |= OrConstant[0];

  0285e	b8 04 00 00 00	 mov	 eax, 4
  02863	48 6b c0 00	 imul	 rax, rax, 0
  02867	b9 04 00 00 00	 mov	 ecx, 4
  0286c	48 6b c9 00	 imul	 rcx, rcx, 0
  02870	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02877	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0287a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0287e	0b c1		 or	 eax, ecx
  02880	b9 04 00 00 00	 mov	 ecx, 4
  02885	48 6b c9 00	 imul	 rcx, rcx, 0
  02889	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8718 :         OrResult[3]  |= OrConstant[2];

  0288d	b8 04 00 00 00	 mov	 eax, 4
  02892	48 6b c0 03	 imul	 rax, rax, 3
  02896	b9 04 00 00 00	 mov	 ecx, 4
  0289b	48 6b c9 02	 imul	 rcx, rcx, 2
  0289f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  028a6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  028a9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  028ad	0b c1		 or	 eax, ecx
  028af	b9 04 00 00 00	 mov	 ecx, 4
  028b4	48 6b c9 03	 imul	 rcx, rcx, 3
  028b8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8719 :         OrResult[4]  |= OrConstant[1];

  028bc	b8 04 00 00 00	 mov	 eax, 4
  028c1	48 6b c0 04	 imul	 rax, rax, 4
  028c5	b9 04 00 00 00	 mov	 ecx, 4
  028ca	48 6b c9 01	 imul	 rcx, rcx, 1
  028ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  028d5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  028d8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  028dc	0b c1		 or	 eax, ecx
  028de	b9 04 00 00 00	 mov	 ecx, 4
  028e3	48 6b c9 04	 imul	 rcx, rcx, 4
  028e7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8720 :         OrResult[6]  |= OrConstant[7];

  028eb	b8 04 00 00 00	 mov	 eax, 4
  028f0	48 6b c0 06	 imul	 rax, rax, 6
  028f4	b9 04 00 00 00	 mov	 ecx, 4
  028f9	48 6b c9 07	 imul	 rcx, rcx, 7
  028fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02904	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02907	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0290b	0b c1		 or	 eax, ecx
  0290d	b9 04 00 00 00	 mov	 ecx, 4
  02912	48 6b c9 06	 imul	 rcx, rcx, 6
  02916	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8721 :         OrResult[9]  |= OrConstant[4];

  0291a	b8 04 00 00 00	 mov	 eax, 4
  0291f	48 6b c0 09	 imul	 rax, rax, 9
  02923	b9 04 00 00 00	 mov	 ecx, 4
  02928	48 6b c9 04	 imul	 rcx, rcx, 4
  0292c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02933	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02936	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0293a	0b c1		 or	 eax, ecx
  0293c	b9 04 00 00 00	 mov	 ecx, 4
  02941	48 6b c9 09	 imul	 rcx, rcx, 9
  02945	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8722 :         OrResult[10] |= OrConstant[6];

  02949	b8 04 00 00 00	 mov	 eax, 4
  0294e	48 6b c0 0a	 imul	 rax, rax, 10
  02952	b9 04 00 00 00	 mov	 ecx, 4
  02957	48 6b c9 06	 imul	 rcx, rcx, 6
  0295b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02962	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02965	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02969	0b c1		 or	 eax, ecx
  0296b	b9 04 00 00 00	 mov	 ecx, 4
  02970	48 6b c9 0a	 imul	 rcx, rcx, 10
  02974	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8723 :         OrResult[15] |= OrConstant[8];

  02978	b8 04 00 00 00	 mov	 eax, 4
  0297d	48 6b c0 0f	 imul	 rax, rax, 15
  02981	b9 04 00 00 00	 mov	 ecx, 4
  02986	48 6b c9 08	 imul	 rcx, rcx, 8
  0298a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02991	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02994	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02998	0b c1		 or	 eax, ecx
  0299a	b9 04 00 00 00	 mov	 ecx, 4
  0299f	48 6b c9 0f	 imul	 rcx, rcx, 15
  029a3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8724 :         OrResult[17] |= OrConstant[1];

  029a7	b8 04 00 00 00	 mov	 eax, 4
  029ac	48 6b c0 11	 imul	 rax, rax, 17
  029b0	b9 04 00 00 00	 mov	 ecx, 4
  029b5	48 6b c9 01	 imul	 rcx, rcx, 1
  029b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  029c0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  029c3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  029c7	0b c1		 or	 eax, ecx
  029c9	b9 04 00 00 00	 mov	 ecx, 4
  029ce	48 6b c9 11	 imul	 rcx, rcx, 17
  029d2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8725 :         OrResult[19] |= OrConstant[11];

  029d6	b8 04 00 00 00	 mov	 eax, 4
  029db	48 6b c0 13	 imul	 rax, rax, 19
  029df	b9 04 00 00 00	 mov	 ecx, 4
  029e4	48 6b c9 0b	 imul	 rcx, rcx, 11
  029e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  029ef	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  029f2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  029f6	0b c1		 or	 eax, ecx
  029f8	b9 04 00 00 00	 mov	 ecx, 4
  029fd	48 6b c9 13	 imul	 rcx, rcx, 19
  02a01	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8726 :         OrResult[20] |= OrConstant[9];

  02a05	b8 04 00 00 00	 mov	 eax, 4
  02a0a	48 6b c0 14	 imul	 rax, rax, 20
  02a0e	b9 04 00 00 00	 mov	 ecx, 4
  02a13	48 6b c9 09	 imul	 rcx, rcx, 9
  02a17	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02a1e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02a21	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02a25	0b c1		 or	 eax, ecx
  02a27	b9 04 00 00 00	 mov	 ecx, 4
  02a2c	48 6b c9 14	 imul	 rcx, rcx, 20
  02a30	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8727 :         OrResult[23] |= OrConstant[3];

  02a34	b8 04 00 00 00	 mov	 eax, 4
  02a39	48 6b c0 17	 imul	 rax, rax, 23
  02a3d	b9 04 00 00 00	 mov	 ecx, 4
  02a42	48 6b c9 03	 imul	 rcx, rcx, 3
  02a46	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02a4d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02a50	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02a54	0b c1		 or	 eax, ecx
  02a56	b9 04 00 00 00	 mov	 ecx, 4
  02a5b	48 6b c9 17	 imul	 rcx, rcx, 23
  02a5f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8728 :         OrResult[24] |= OrConstant[11];

  02a63	b8 04 00 00 00	 mov	 eax, 4
  02a68	48 6b c0 18	 imul	 rax, rax, 24
  02a6c	b9 04 00 00 00	 mov	 ecx, 4
  02a71	48 6b c9 0b	 imul	 rcx, rcx, 11
  02a75	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02a7c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02a7f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02a83	0b c1		 or	 eax, ecx
  02a85	b9 04 00 00 00	 mov	 ecx, 4
  02a8a	48 6b c9 18	 imul	 rcx, rcx, 24
  02a8e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8729 :         OrResult[27] |= OrConstant[5];

  02a92	b8 04 00 00 00	 mov	 eax, 4
  02a97	48 6b c0 1b	 imul	 rax, rax, 27
  02a9b	b9 04 00 00 00	 mov	 ecx, 4
  02aa0	48 6b c9 05	 imul	 rcx, rcx, 5
  02aa4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02aab	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02aae	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02ab2	0b c1		 or	 eax, ecx
  02ab4	b9 04 00 00 00	 mov	 ecx, 4
  02ab9	48 6b c9 1b	 imul	 rcx, rcx, 27
  02abd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8730 :         OrResult[28] |= OrConstant[8];

  02ac1	b8 04 00 00 00	 mov	 eax, 4
  02ac6	48 6b c0 1c	 imul	 rax, rax, 28
  02aca	b9 04 00 00 00	 mov	 ecx, 4
  02acf	48 6b c9 08	 imul	 rcx, rcx, 8
  02ad3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02ada	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02add	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02ae1	0b c1		 or	 eax, ecx
  02ae3	b9 04 00 00 00	 mov	 ecx, 4
  02ae8	48 6b c9 1c	 imul	 rcx, rcx, 28
  02aec	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8731 :         OrResult[31] |= OrConstant[10];

  02af0	b8 04 00 00 00	 mov	 eax, 4
  02af5	48 6b c0 1f	 imul	 rax, rax, 31
  02af9	b9 04 00 00 00	 mov	 ecx, 4
  02afe	48 6b c9 0a	 imul	 rcx, rcx, 10
  02b02	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02b09	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02b0c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02b10	0b c1		 or	 eax, ecx
  02b12	b9 04 00 00 00	 mov	 ecx, 4
  02b17	48 6b c9 1f	 imul	 rcx, rcx, 31
  02b1b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN26@gen_csv_si:

; 8732 :     }
; 8733 :     if ((pClock1[2] & 0x20 ) == 0x20)

  02b1f	b8 01 00 00 00	 mov	 eax, 1
  02b24	48 6b c0 02	 imul	 rax, rax, 2
  02b28	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  02b30	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02b34	83 e0 20	 and	 eax, 32			; 00000020H
  02b37	83 f8 20	 cmp	 eax, 32			; 00000020H
  02b3a	0f 85 63 02 00
	00		 jne	 $LN27@gen_csv_si

; 8734 :     {
; 8735 :         OrResult[2]  |= OrConstant[6];

  02b40	b8 04 00 00 00	 mov	 eax, 4
  02b45	48 6b c0 02	 imul	 rax, rax, 2
  02b49	b9 04 00 00 00	 mov	 ecx, 4
  02b4e	48 6b c9 06	 imul	 rcx, rcx, 6
  02b52	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02b59	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02b5c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02b60	0b c1		 or	 eax, ecx
  02b62	b9 04 00 00 00	 mov	 ecx, 4
  02b67	48 6b c9 02	 imul	 rcx, rcx, 2
  02b6b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8736 :         OrResult[7]  |= OrConstant[8];

  02b6f	b8 04 00 00 00	 mov	 eax, 4
  02b74	48 6b c0 07	 imul	 rax, rax, 7
  02b78	b9 04 00 00 00	 mov	 ecx, 4
  02b7d	48 6b c9 08	 imul	 rcx, rcx, 8
  02b81	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02b88	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02b8b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02b8f	0b c1		 or	 eax, ecx
  02b91	b9 04 00 00 00	 mov	 ecx, 4
  02b96	48 6b c9 07	 imul	 rcx, rcx, 7
  02b9a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8737 :         OrResult[8]  |= OrConstant[4];

  02b9e	b8 04 00 00 00	 mov	 eax, 4
  02ba3	48 6b c0 08	 imul	 rax, rax, 8
  02ba7	b9 04 00 00 00	 mov	 ecx, 4
  02bac	48 6b c9 04	 imul	 rcx, rcx, 4
  02bb0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02bb7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02bba	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02bbe	0b c1		 or	 eax, ecx
  02bc0	b9 04 00 00 00	 mov	 ecx, 4
  02bc5	48 6b c9 08	 imul	 rcx, rcx, 8
  02bc9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8738 :         OrResult[11] |= OrConstant[0];

  02bcd	b8 04 00 00 00	 mov	 eax, 4
  02bd2	48 6b c0 0b	 imul	 rax, rax, 11
  02bd6	b9 04 00 00 00	 mov	 ecx, 4
  02bdb	48 6b c9 00	 imul	 rcx, rcx, 0
  02bdf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02be6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02be9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02bed	0b c1		 or	 eax, ecx
  02bef	b9 04 00 00 00	 mov	 ecx, 4
  02bf4	48 6b c9 0b	 imul	 rcx, rcx, 11
  02bf8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8739 :         OrResult[12] |= OrConstant[5];

  02bfc	b8 04 00 00 00	 mov	 eax, 4
  02c01	48 6b c0 0c	 imul	 rax, rax, 12
  02c05	b9 04 00 00 00	 mov	 ecx, 4
  02c0a	48 6b c9 05	 imul	 rcx, rcx, 5
  02c0e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02c15	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02c18	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02c1c	0b c1		 or	 eax, ecx
  02c1e	b9 04 00 00 00	 mov	 ecx, 4
  02c23	48 6b c9 0c	 imul	 rcx, rcx, 12
  02c27	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8740 :         OrResult[15] |= OrConstant[7];

  02c2b	b8 04 00 00 00	 mov	 eax, 4
  02c30	48 6b c0 0f	 imul	 rax, rax, 15
  02c34	b9 04 00 00 00	 mov	 ecx, 4
  02c39	48 6b c9 07	 imul	 rcx, rcx, 7
  02c3d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02c44	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02c47	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02c4b	0b c1		 or	 eax, ecx
  02c4d	b9 04 00 00 00	 mov	 ecx, 4
  02c52	48 6b c9 0f	 imul	 rcx, rcx, 15
  02c56	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8741 :         OrResult[16] |= OrConstant[11];

  02c5a	b8 04 00 00 00	 mov	 eax, 4
  02c5f	48 6b c0 10	 imul	 rax, rax, 16
  02c63	b9 04 00 00 00	 mov	 ecx, 4
  02c68	48 6b c9 0b	 imul	 rcx, rcx, 11
  02c6c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02c73	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02c76	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02c7a	0b c1		 or	 eax, ecx
  02c7c	b9 04 00 00 00	 mov	 ecx, 4
  02c81	48 6b c9 10	 imul	 rcx, rcx, 16
  02c85	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8742 :         OrResult[19] |= OrConstant[5];

  02c89	b8 04 00 00 00	 mov	 eax, 4
  02c8e	48 6b c0 13	 imul	 rax, rax, 19
  02c92	b9 04 00 00 00	 mov	 ecx, 4
  02c97	48 6b c9 05	 imul	 rcx, rcx, 5
  02c9b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02ca2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02ca5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02ca9	0b c1		 or	 eax, ecx
  02cab	b9 04 00 00 00	 mov	 ecx, 4
  02cb0	48 6b c9 13	 imul	 rcx, rcx, 19
  02cb4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8743 :         OrResult[20] |= OrConstant[8];

  02cb8	b8 04 00 00 00	 mov	 eax, 4
  02cbd	48 6b c0 14	 imul	 rax, rax, 20
  02cc1	b9 04 00 00 00	 mov	 ecx, 4
  02cc6	48 6b c9 08	 imul	 rcx, rcx, 8
  02cca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02cd1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02cd4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02cd8	0b c1		 or	 eax, ecx
  02cda	b9 04 00 00 00	 mov	 ecx, 4
  02cdf	48 6b c9 14	 imul	 rcx, rcx, 20
  02ce3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8744 :         OrResult[22] |= OrConstant[0];

  02ce7	b8 04 00 00 00	 mov	 eax, 4
  02cec	48 6b c0 16	 imul	 rax, rax, 22
  02cf0	b9 04 00 00 00	 mov	 ecx, 4
  02cf5	48 6b c9 00	 imul	 rcx, rcx, 0
  02cf9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02d00	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02d03	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02d07	0b c1		 or	 eax, ecx
  02d09	b9 04 00 00 00	 mov	 ecx, 4
  02d0e	48 6b c9 16	 imul	 rcx, rcx, 22
  02d12	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8745 :         OrResult[25] |= OrConstant[6];

  02d16	b8 04 00 00 00	 mov	 eax, 4
  02d1b	48 6b c0 19	 imul	 rax, rax, 25
  02d1f	b9 04 00 00 00	 mov	 ecx, 4
  02d24	48 6b c9 06	 imul	 rcx, rcx, 6
  02d28	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02d2f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02d32	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02d36	0b c1		 or	 eax, ecx
  02d38	b9 04 00 00 00	 mov	 ecx, 4
  02d3d	48 6b c9 19	 imul	 rcx, rcx, 25
  02d41	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8746 :         OrResult[29] |= OrConstant[9];

  02d45	b8 04 00 00 00	 mov	 eax, 4
  02d4a	48 6b c0 1d	 imul	 rax, rax, 29
  02d4e	b9 04 00 00 00	 mov	 ecx, 4
  02d53	48 6b c9 09	 imul	 rcx, rcx, 9
  02d57	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02d5e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02d61	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02d65	0b c1		 or	 eax, ecx
  02d67	b9 04 00 00 00	 mov	 ecx, 4
  02d6c	48 6b c9 1d	 imul	 rcx, rcx, 29
  02d70	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8747 :         OrResult[31] |= OrConstant[4];

  02d74	b8 04 00 00 00	 mov	 eax, 4
  02d79	48 6b c0 1f	 imul	 rax, rax, 31
  02d7d	b9 04 00 00 00	 mov	 ecx, 4
  02d82	48 6b c9 04	 imul	 rcx, rcx, 4
  02d86	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02d8d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02d90	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02d94	0b c1		 or	 eax, ecx
  02d96	b9 04 00 00 00	 mov	 ecx, 4
  02d9b	48 6b c9 1f	 imul	 rcx, rcx, 31
  02d9f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN27@gen_csv_si:

; 8748 :     }
; 8749 :     if ((pClock1[2] & 0x10 ) == 0x10)

  02da3	b8 01 00 00 00	 mov	 eax, 1
  02da8	48 6b c0 02	 imul	 rax, rax, 2
  02dac	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  02db4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02db8	83 e0 10	 and	 eax, 16
  02dbb	83 f8 10	 cmp	 eax, 16
  02dbe	0f 85 92 02 00
	00		 jne	 $LN28@gen_csv_si

; 8750 :     {
; 8751 :         OrResult[2]  |= OrConstant[17];

  02dc4	b8 04 00 00 00	 mov	 eax, 4
  02dc9	48 6b c0 02	 imul	 rax, rax, 2
  02dcd	b9 04 00 00 00	 mov	 ecx, 4
  02dd2	48 6b c9 11	 imul	 rcx, rcx, 17
  02dd6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02ddd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02de0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02de4	0b c1		 or	 eax, ecx
  02de6	b9 04 00 00 00	 mov	 ecx, 4
  02deb	48 6b c9 02	 imul	 rcx, rcx, 2
  02def	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8752 :         OrResult[5]  |= OrConstant[22];

  02df3	b8 04 00 00 00	 mov	 eax, 4
  02df8	48 6b c0 05	 imul	 rax, rax, 5
  02dfc	b9 04 00 00 00	 mov	 ecx, 4
  02e01	48 6b c9 16	 imul	 rcx, rcx, 22
  02e05	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02e0c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02e0f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02e13	0b c1		 or	 eax, ecx
  02e15	b9 04 00 00 00	 mov	 ecx, 4
  02e1a	48 6b c9 05	 imul	 rcx, rcx, 5
  02e1e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8753 :         OrResult[6]  |= OrConstant[14];

  02e22	b8 04 00 00 00	 mov	 eax, 4
  02e27	48 6b c0 06	 imul	 rax, rax, 6
  02e2b	b9 04 00 00 00	 mov	 ecx, 4
  02e30	48 6b c9 0e	 imul	 rcx, rcx, 14
  02e34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02e3b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02e3e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02e42	0b c1		 or	 eax, ecx
  02e44	b9 04 00 00 00	 mov	 ecx, 4
  02e49	48 6b c9 06	 imul	 rcx, rcx, 6
  02e4d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8754 :         OrResult[9]  |= OrConstant[16];

  02e51	b8 04 00 00 00	 mov	 eax, 4
  02e56	48 6b c0 09	 imul	 rax, rax, 9
  02e5a	b9 04 00 00 00	 mov	 ecx, 4
  02e5f	48 6b c9 10	 imul	 rcx, rcx, 16
  02e63	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02e6a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02e6d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02e71	0b c1		 or	 eax, ecx
  02e73	b9 04 00 00 00	 mov	 ecx, 4
  02e78	48 6b c9 09	 imul	 rcx, rcx, 9
  02e7c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8755 :         OrResult[12] |= OrConstant[15];

  02e80	b8 04 00 00 00	 mov	 eax, 4
  02e85	48 6b c0 0c	 imul	 rax, rax, 12
  02e89	b9 04 00 00 00	 mov	 ecx, 4
  02e8e	48 6b c9 0f	 imul	 rcx, rcx, 15
  02e92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02e99	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02e9c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02ea0	0b c1		 or	 eax, ecx
  02ea2	b9 04 00 00 00	 mov	 ecx, 4
  02ea7	48 6b c9 0c	 imul	 rcx, rcx, 12
  02eab	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8756 :         OrResult[14] |= OrConstant[20];

  02eaf	b8 04 00 00 00	 mov	 eax, 4
  02eb4	48 6b c0 0e	 imul	 rax, rax, 14
  02eb8	b9 04 00 00 00	 mov	 ecx, 4
  02ebd	48 6b c9 14	 imul	 rcx, rcx, 20
  02ec1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02ec8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02ecb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02ecf	0b c1		 or	 eax, ecx
  02ed1	b9 04 00 00 00	 mov	 ecx, 4
  02ed6	48 6b c9 0e	 imul	 rcx, rcx, 14
  02eda	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8757 :         OrResult[17] |= OrConstant[13];

  02ede	b8 04 00 00 00	 mov	 eax, 4
  02ee3	48 6b c0 11	 imul	 rax, rax, 17
  02ee7	b9 04 00 00 00	 mov	 ecx, 4
  02eec	48 6b c9 0d	 imul	 rcx, rcx, 13
  02ef0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02ef7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02efa	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02efe	0b c1		 or	 eax, ecx
  02f00	b9 04 00 00 00	 mov	 ecx, 4
  02f05	48 6b c9 11	 imul	 rcx, rcx, 17
  02f09	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8758 :         OrResult[19] |= OrConstant[19];

  02f0d	b8 04 00 00 00	 mov	 eax, 4
  02f12	48 6b c0 13	 imul	 rax, rax, 19
  02f16	b9 04 00 00 00	 mov	 ecx, 4
  02f1b	48 6b c9 13	 imul	 rcx, rcx, 19
  02f1f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02f26	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02f29	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02f2d	0b c1		 or	 eax, ecx
  02f2f	b9 04 00 00 00	 mov	 ecx, 4
  02f34	48 6b c9 13	 imul	 rcx, rcx, 19
  02f38	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8759 :         OrResult[20] |= OrConstant[18];

  02f3c	b8 04 00 00 00	 mov	 eax, 4
  02f41	48 6b c0 14	 imul	 rax, rax, 20
  02f45	b9 04 00 00 00	 mov	 ecx, 4
  02f4a	48 6b c9 12	 imul	 rcx, rcx, 18
  02f4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02f55	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02f58	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02f5c	0b c1		 or	 eax, ecx
  02f5e	b9 04 00 00 00	 mov	 ecx, 4
  02f63	48 6b c9 14	 imul	 rcx, rcx, 20
  02f67	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8760 :         OrResult[23] |= OrConstant[18];

  02f6b	b8 04 00 00 00	 mov	 eax, 4
  02f70	48 6b c0 17	 imul	 rax, rax, 23
  02f74	b9 04 00 00 00	 mov	 ecx, 4
  02f79	48 6b c9 12	 imul	 rcx, rcx, 18
  02f7d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02f84	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02f87	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02f8b	0b c1		 or	 eax, ecx
  02f8d	b9 04 00 00 00	 mov	 ecx, 4
  02f92	48 6b c9 17	 imul	 rcx, rcx, 23
  02f96	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8761 :         OrResult[25] |= OrConstant[17];

  02f9a	b8 04 00 00 00	 mov	 eax, 4
  02f9f	48 6b c0 19	 imul	 rax, rax, 25
  02fa3	b9 04 00 00 00	 mov	 ecx, 4
  02fa8	48 6b c9 11	 imul	 rcx, rcx, 17
  02fac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02fb3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02fb6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02fba	0b c1		 or	 eax, ecx
  02fbc	b9 04 00 00 00	 mov	 ecx, 4
  02fc1	48 6b c9 19	 imul	 rcx, rcx, 25
  02fc5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8762 :         OrResult[27] |= OrConstant[20];

  02fc9	b8 04 00 00 00	 mov	 eax, 4
  02fce	48 6b c0 1b	 imul	 rax, rax, 27
  02fd2	b9 04 00 00 00	 mov	 ecx, 4
  02fd7	48 6b c9 14	 imul	 rcx, rcx, 20
  02fdb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  02fe2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  02fe5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  02fe9	0b c1		 or	 eax, ecx
  02feb	b9 04 00 00 00	 mov	 ecx, 4
  02ff0	48 6b c9 1b	 imul	 rcx, rcx, 27
  02ff4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8763 :         OrResult[28] |= OrConstant[13];

  02ff8	b8 04 00 00 00	 mov	 eax, 4
  02ffd	48 6b c0 1c	 imul	 rax, rax, 28
  03001	b9 04 00 00 00	 mov	 ecx, 4
  03006	48 6b c9 0d	 imul	 rcx, rcx, 13
  0300a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03011	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03014	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03018	0b c1		 or	 eax, ecx
  0301a	b9 04 00 00 00	 mov	 ecx, 4
  0301f	48 6b c9 1c	 imul	 rcx, rcx, 28
  03023	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8764 :         OrResult[30] |= OrConstant[23];

  03027	b8 04 00 00 00	 mov	 eax, 4
  0302c	48 6b c0 1e	 imul	 rax, rax, 30
  03030	b9 04 00 00 00	 mov	 ecx, 4
  03035	48 6b c9 17	 imul	 rcx, rcx, 23
  03039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03040	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03043	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03047	0b c1		 or	 eax, ecx
  03049	b9 04 00 00 00	 mov	 ecx, 4
  0304e	48 6b c9 1e	 imul	 rcx, rcx, 30
  03052	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN28@gen_csv_si:

; 8765 :     }
; 8766 :     if ((pClock1[2] & 0x08 ) == 0x08)

  03056	b8 01 00 00 00	 mov	 eax, 1
  0305b	48 6b c0 02	 imul	 rax, rax, 2
  0305f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  03067	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0306b	83 e0 08	 and	 eax, 8
  0306e	83 f8 08	 cmp	 eax, 8
  03071	0f 85 92 02 00
	00		 jne	 $LN29@gen_csv_si

; 8767 :     {
; 8768 :         OrResult[1]  |= OrConstant[20];

  03077	b8 04 00 00 00	 mov	 eax, 4
  0307c	48 6b c0 01	 imul	 rax, rax, 1
  03080	b9 04 00 00 00	 mov	 ecx, 4
  03085	48 6b c9 14	 imul	 rcx, rcx, 20
  03089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03090	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03093	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03097	0b c1		 or	 eax, ecx
  03099	b9 04 00 00 00	 mov	 ecx, 4
  0309e	48 6b c9 01	 imul	 rcx, rcx, 1
  030a2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8769 :         OrResult[3]  |= OrConstant[14];

  030a6	b8 04 00 00 00	 mov	 eax, 4
  030ab	48 6b c0 03	 imul	 rax, rax, 3
  030af	b9 04 00 00 00	 mov	 ecx, 4
  030b4	48 6b c9 0e	 imul	 rcx, rcx, 14
  030b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  030bf	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  030c2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  030c6	0b c1		 or	 eax, ecx
  030c8	b9 04 00 00 00	 mov	 ecx, 4
  030cd	48 6b c9 03	 imul	 rcx, rcx, 3
  030d1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8770 :         OrResult[4]  |= OrConstant[23];

  030d5	b8 04 00 00 00	 mov	 eax, 4
  030da	48 6b c0 04	 imul	 rax, rax, 4
  030de	b9 04 00 00 00	 mov	 ecx, 4
  030e3	48 6b c9 17	 imul	 rcx, rcx, 23
  030e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  030ee	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  030f1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  030f5	0b c1		 or	 eax, ecx
  030f7	b9 04 00 00 00	 mov	 ecx, 4
  030fc	48 6b c9 04	 imul	 rcx, rcx, 4
  03100	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8771 :         OrResult[6]  |= OrConstant[17];

  03104	b8 04 00 00 00	 mov	 eax, 4
  03109	48 6b c0 06	 imul	 rax, rax, 6
  0310d	b9 04 00 00 00	 mov	 ecx, 4
  03112	48 6b c9 11	 imul	 rcx, rcx, 17
  03116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0311d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03120	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03124	0b c1		 or	 eax, ecx
  03126	b9 04 00 00 00	 mov	 ecx, 4
  0312b	48 6b c9 06	 imul	 rcx, rcx, 6
  0312f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8772 :         OrResult[9]  |= OrConstant[22];

  03133	b8 04 00 00 00	 mov	 eax, 4
  03138	48 6b c0 09	 imul	 rax, rax, 9
  0313c	b9 04 00 00 00	 mov	 ecx, 4
  03141	48 6b c9 16	 imul	 rcx, rcx, 22
  03145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0314c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0314f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03153	0b c1		 or	 eax, ecx
  03155	b9 04 00 00 00	 mov	 ecx, 4
  0315a	48 6b c9 09	 imul	 rcx, rcx, 9
  0315e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8773 :         OrResult[10] |= OrConstant[14];

  03162	b8 04 00 00 00	 mov	 eax, 4
  03167	48 6b c0 0a	 imul	 rax, rax, 10
  0316b	b9 04 00 00 00	 mov	 ecx, 4
  03170	48 6b c9 0e	 imul	 rcx, rcx, 14
  03174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0317b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0317e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03182	0b c1		 or	 eax, ecx
  03184	b9 04 00 00 00	 mov	 ecx, 4
  03189	48 6b c9 0a	 imul	 rcx, rcx, 10
  0318d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8774 :         OrResult[13] |= OrConstant[16];

  03191	b8 04 00 00 00	 mov	 eax, 4
  03196	48 6b c0 0d	 imul	 rax, rax, 13
  0319a	b9 04 00 00 00	 mov	 ecx, 4
  0319f	48 6b c9 10	 imul	 rcx, rcx, 16
  031a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  031aa	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  031ad	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  031b1	0b c1		 or	 eax, ecx
  031b3	b9 04 00 00 00	 mov	 ecx, 4
  031b8	48 6b c9 0d	 imul	 rcx, rcx, 13
  031bc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8775 :         OrResult[17] |= OrConstant[21];

  031c0	b8 04 00 00 00	 mov	 eax, 4
  031c5	48 6b c0 11	 imul	 rax, rax, 17
  031c9	b9 04 00 00 00	 mov	 ecx, 4
  031ce	48 6b c9 15	 imul	 rcx, rcx, 21
  031d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  031d9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  031dc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  031e0	0b c1		 or	 eax, ecx
  031e2	b9 04 00 00 00	 mov	 ecx, 4
  031e7	48 6b c9 11	 imul	 rcx, rcx, 17
  031eb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8776 :         OrResult[21] |= OrConstant[13];

  031ef	b8 04 00 00 00	 mov	 eax, 4
  031f4	48 6b c0 15	 imul	 rax, rax, 21
  031f8	b9 04 00 00 00	 mov	 ecx, 4
  031fd	48 6b c9 0d	 imul	 rcx, rcx, 13
  03201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03208	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0320b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0320f	0b c1		 or	 eax, ecx
  03211	b9 04 00 00 00	 mov	 ecx, 4
  03216	48 6b c9 15	 imul	 rcx, rcx, 21
  0321a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8777 :         OrResult[23] |= OrConstant[19];

  0321e	b8 04 00 00 00	 mov	 eax, 4
  03223	48 6b c0 17	 imul	 rax, rax, 23
  03227	b9 04 00 00 00	 mov	 ecx, 4
  0322c	48 6b c9 13	 imul	 rcx, rcx, 19
  03230	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03237	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0323a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0323e	0b c1		 or	 eax, ecx
  03240	b9 04 00 00 00	 mov	 ecx, 4
  03245	48 6b c9 17	 imul	 rcx, rcx, 23
  03249	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8778 :         OrResult[24] |= OrConstant[18];

  0324d	b8 04 00 00 00	 mov	 eax, 4
  03252	48 6b c0 18	 imul	 rax, rax, 24
  03256	b9 04 00 00 00	 mov	 ecx, 4
  0325b	48 6b c9 12	 imul	 rcx, rcx, 18
  0325f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03266	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03269	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0326d	0b c1		 or	 eax, ecx
  0326f	b9 04 00 00 00	 mov	 ecx, 4
  03274	48 6b c9 18	 imul	 rcx, rcx, 24
  03278	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8779 :         OrResult[27] |= OrConstant[18];

  0327c	b8 04 00 00 00	 mov	 eax, 4
  03281	48 6b c0 1b	 imul	 rax, rax, 27
  03285	b9 04 00 00 00	 mov	 ecx, 4
  0328a	48 6b c9 12	 imul	 rcx, rcx, 18
  0328e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03295	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03298	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0329c	0b c1		 or	 eax, ecx
  0329e	b9 04 00 00 00	 mov	 ecx, 4
  032a3	48 6b c9 1b	 imul	 rcx, rcx, 27
  032a7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8780 :         OrResult[29] |= OrConstant[17];

  032ab	b8 04 00 00 00	 mov	 eax, 4
  032b0	48 6b c0 1d	 imul	 rax, rax, 29
  032b4	b9 04 00 00 00	 mov	 ecx, 4
  032b9	48 6b c9 11	 imul	 rcx, rcx, 17
  032bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  032c4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  032c7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  032cb	0b c1		 or	 eax, ecx
  032cd	b9 04 00 00 00	 mov	 ecx, 4
  032d2	48 6b c9 1d	 imul	 rcx, rcx, 29
  032d6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8781 :         OrResult[30] |= OrConstant[19];

  032da	b8 04 00 00 00	 mov	 eax, 4
  032df	48 6b c0 1e	 imul	 rax, rax, 30
  032e3	b9 04 00 00 00	 mov	 ecx, 4
  032e8	48 6b c9 13	 imul	 rcx, rcx, 19
  032ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  032f3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  032f6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  032fa	0b c1		 or	 eax, ecx
  032fc	b9 04 00 00 00	 mov	 ecx, 4
  03301	48 6b c9 1e	 imul	 rcx, rcx, 30
  03305	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN29@gen_csv_si:

; 8782 :     }
; 8783 :     if ((pClock1[2] & 0x04 ) == 0x04)

  03309	b8 01 00 00 00	 mov	 eax, 1
  0330e	48 6b c0 02	 imul	 rax, rax, 2
  03312	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0331a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0331e	83 e0 04	 and	 eax, 4
  03321	83 f8 04	 cmp	 eax, 4
  03324	0f 85 92 02 00
	00		 jne	 $LN30@gen_csv_si

; 8784 :     {
; 8785 :         OrResult[1]  |= OrConstant[19];

  0332a	b8 04 00 00 00	 mov	 eax, 4
  0332f	48 6b c0 01	 imul	 rax, rax, 1
  03333	b9 04 00 00 00	 mov	 ecx, 4
  03338	48 6b c9 13	 imul	 rcx, rcx, 19
  0333c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03343	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03346	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0334a	0b c1		 or	 eax, ecx
  0334c	b9 04 00 00 00	 mov	 ecx, 4
  03351	48 6b c9 01	 imul	 rcx, rcx, 1
  03355	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8786 :         OrResult[5]  |= OrConstant[15];

  03359	b8 04 00 00 00	 mov	 eax, 4
  0335e	48 6b c0 05	 imul	 rax, rax, 5
  03362	b9 04 00 00 00	 mov	 ecx, 4
  03367	48 6b c9 0f	 imul	 rcx, rcx, 15
  0336b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03372	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03375	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03379	0b c1		 or	 eax, ecx
  0337b	b9 04 00 00 00	 mov	 ecx, 4
  03380	48 6b c9 05	 imul	 rcx, rcx, 5
  03384	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8787 :         OrResult[6]  |= OrConstant[16];

  03388	b8 04 00 00 00	 mov	 eax, 4
  0338d	48 6b c0 06	 imul	 rax, rax, 6
  03391	b9 04 00 00 00	 mov	 ecx, 4
  03396	48 6b c9 10	 imul	 rcx, rcx, 16
  0339a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  033a1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  033a4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  033a8	0b c1		 or	 eax, ecx
  033aa	b9 04 00 00 00	 mov	 ecx, 4
  033af	48 6b c9 06	 imul	 rcx, rcx, 6
  033b3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8788 :         OrResult[8]  |= OrConstant[19];

  033b7	b8 04 00 00 00	 mov	 eax, 4
  033bc	48 6b c0 08	 imul	 rax, rax, 8
  033c0	b9 04 00 00 00	 mov	 ecx, 4
  033c5	48 6b c9 13	 imul	 rcx, rcx, 19
  033c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  033d0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  033d3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  033d7	0b c1		 or	 eax, ecx
  033d9	b9 04 00 00 00	 mov	 ecx, 4
  033de	48 6b c9 08	 imul	 rcx, rcx, 8
  033e2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8789 :         OrResult[11] |= OrConstant[14];

  033e6	b8 04 00 00 00	 mov	 eax, 4
  033eb	48 6b c0 0b	 imul	 rax, rax, 11
  033ef	b9 04 00 00 00	 mov	 ecx, 4
  033f4	48 6b c9 0e	 imul	 rcx, rcx, 14
  033f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  033ff	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03402	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03406	0b c1		 or	 eax, ecx
  03408	b9 04 00 00 00	 mov	 ecx, 4
  0340d	48 6b c9 0b	 imul	 rcx, rcx, 11
  03411	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8790 :         OrResult[12] |= OrConstant[23];

  03415	b8 04 00 00 00	 mov	 eax, 4
  0341a	48 6b c0 0c	 imul	 rax, rax, 12
  0341e	b9 04 00 00 00	 mov	 ecx, 4
  03423	48 6b c9 17	 imul	 rcx, rcx, 23
  03427	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0342e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03431	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03435	0b c1		 or	 eax, ecx
  03437	b9 04 00 00 00	 mov	 ecx, 4
  0343c	48 6b c9 0c	 imul	 rcx, rcx, 12
  03440	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8791 :         OrResult[14] |= OrConstant[17];

  03444	b8 04 00 00 00	 mov	 eax, 4
  03449	48 6b c0 0e	 imul	 rax, rax, 14
  0344d	b9 04 00 00 00	 mov	 ecx, 4
  03452	48 6b c9 11	 imul	 rcx, rcx, 17
  03456	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0345d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03460	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03464	0b c1		 or	 eax, ecx
  03466	b9 04 00 00 00	 mov	 ecx, 4
  0346b	48 6b c9 0e	 imul	 rcx, rcx, 14
  0346f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8792 :         OrResult[16] |= OrConstant[21];

  03473	b8 04 00 00 00	 mov	 eax, 4
  03478	48 6b c0 10	 imul	 rax, rax, 16
  0347c	b9 04 00 00 00	 mov	 ecx, 4
  03481	48 6b c9 15	 imul	 rcx, rcx, 21
  03485	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0348c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0348f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03493	0b c1		 or	 eax, ecx
  03495	b9 04 00 00 00	 mov	 ecx, 4
  0349a	48 6b c9 10	 imul	 rcx, rcx, 16
  0349e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8793 :         OrResult[19] |= OrConstant[12];

  034a2	b8 04 00 00 00	 mov	 eax, 4
  034a7	48 6b c0 13	 imul	 rax, rax, 19
  034ab	b9 04 00 00 00	 mov	 ecx, 4
  034b0	48 6b c9 0c	 imul	 rcx, rcx, 12
  034b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  034bb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  034be	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  034c2	0b c1		 or	 eax, ecx
  034c4	b9 04 00 00 00	 mov	 ecx, 4
  034c9	48 6b c9 13	 imul	 rcx, rcx, 19
  034cd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8794 :         OrResult[21] |= OrConstant[23];

  034d1	b8 04 00 00 00	 mov	 eax, 4
  034d6	48 6b c0 15	 imul	 rax, rax, 21
  034da	b9 04 00 00 00	 mov	 ecx, 4
  034df	48 6b c9 17	 imul	 rcx, rcx, 23
  034e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  034ea	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  034ed	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  034f1	0b c1		 or	 eax, ecx
  034f3	b9 04 00 00 00	 mov	 ecx, 4
  034f8	48 6b c9 15	 imul	 rcx, rcx, 21
  034fc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8795 :         OrResult[22] |= OrConstant[22];

  03500	b8 04 00 00 00	 mov	 eax, 4
  03505	48 6b c0 16	 imul	 rax, rax, 22
  03509	b9 04 00 00 00	 mov	 ecx, 4
  0350e	48 6b c9 16	 imul	 rcx, rcx, 22
  03512	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03519	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0351c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03520	0b c1		 or	 eax, ecx
  03522	b9 04 00 00 00	 mov	 ecx, 4
  03527	48 6b c9 16	 imul	 rcx, rcx, 22
  0352b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8796 :         OrResult[25] |= OrConstant[21];

  0352f	b8 04 00 00 00	 mov	 eax, 4
  03534	48 6b c0 19	 imul	 rax, rax, 25
  03538	b9 04 00 00 00	 mov	 ecx, 4
  0353d	48 6b c9 15	 imul	 rcx, rcx, 21
  03541	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03548	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0354b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0354f	0b c1		 or	 eax, ecx
  03551	b9 04 00 00 00	 mov	 ecx, 4
  03556	48 6b c9 19	 imul	 rcx, rcx, 25
  0355a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8797 :         OrResult[29] |= OrConstant[13];

  0355e	b8 04 00 00 00	 mov	 eax, 4
  03563	48 6b c0 1d	 imul	 rax, rax, 29
  03567	b9 04 00 00 00	 mov	 ecx, 4
  0356c	48 6b c9 0d	 imul	 rcx, rcx, 13
  03570	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03577	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0357a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0357e	0b c1		 or	 eax, ecx
  03580	b9 04 00 00 00	 mov	 ecx, 4
  03585	48 6b c9 1d	 imul	 rcx, rcx, 29
  03589	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8798 :         OrResult[30] |= OrConstant[12];

  0358d	b8 04 00 00 00	 mov	 eax, 4
  03592	48 6b c0 1e	 imul	 rax, rax, 30
  03596	b9 04 00 00 00	 mov	 ecx, 4
  0359b	48 6b c9 0c	 imul	 rcx, rcx, 12
  0359f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  035a6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  035a9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  035ad	0b c1		 or	 eax, ecx
  035af	b9 04 00 00 00	 mov	 ecx, 4
  035b4	48 6b c9 1e	 imul	 rcx, rcx, 30
  035b8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN30@gen_csv_si:

; 8799 :     }
; 8800 :     if ((pClock1[2] & 0x02 ) == 0x02)

  035bc	b8 01 00 00 00	 mov	 eax, 1
  035c1	48 6b c0 02	 imul	 rax, rax, 2
  035c5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  035cd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  035d1	83 e0 02	 and	 eax, 2
  035d4	83 f8 02	 cmp	 eax, 2
  035d7	0f 85 63 02 00
	00		 jne	 $LN31@gen_csv_si

; 8801 :     {
; 8802 :         OrResult[0]  |= OrConstant[22];

  035dd	b8 04 00 00 00	 mov	 eax, 4
  035e2	48 6b c0 00	 imul	 rax, rax, 0
  035e6	b9 04 00 00 00	 mov	 ecx, 4
  035eb	48 6b c9 16	 imul	 rcx, rcx, 22
  035ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  035f6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  035f9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  035fd	0b c1		 or	 eax, ecx
  035ff	b9 04 00 00 00	 mov	 ecx, 4
  03604	48 6b c9 00	 imul	 rcx, rcx, 0
  03608	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8803 :         OrResult[4]  |= OrConstant[15];

  0360c	b8 04 00 00 00	 mov	 eax, 4
  03611	48 6b c0 04	 imul	 rax, rax, 4
  03615	b9 04 00 00 00	 mov	 ecx, 4
  0361a	48 6b c9 0f	 imul	 rcx, rcx, 15
  0361e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03625	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03628	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0362c	0b c1		 or	 eax, ecx
  0362e	b9 04 00 00 00	 mov	 ecx, 4
  03633	48 6b c9 04	 imul	 rcx, rcx, 4
  03637	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8804 :         OrResult[6]  |= OrConstant[20];

  0363b	b8 04 00 00 00	 mov	 eax, 4
  03640	48 6b c0 06	 imul	 rax, rax, 6
  03644	b9 04 00 00 00	 mov	 ecx, 4
  03649	48 6b c9 14	 imul	 rcx, rcx, 20
  0364d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03654	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03657	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0365b	0b c1		 or	 eax, ecx
  0365d	b9 04 00 00 00	 mov	 ecx, 4
  03662	48 6b c9 06	 imul	 rcx, rcx, 6
  03666	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8805 :         OrResult[8]  |= OrConstant[12];

  0366a	b8 04 00 00 00	 mov	 eax, 4
  0366f	48 6b c0 08	 imul	 rax, rax, 8
  03673	b9 04 00 00 00	 mov	 ecx, 4
  03678	48 6b c9 0c	 imul	 rcx, rcx, 12
  0367c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03683	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03686	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0368a	0b c1		 or	 eax, ecx
  0368c	b9 04 00 00 00	 mov	 ecx, 4
  03691	48 6b c9 08	 imul	 rcx, rcx, 8
  03695	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8806 :         OrResult[13] |= OrConstant[15];

  03699	b8 04 00 00 00	 mov	 eax, 4
  0369e	48 6b c0 0d	 imul	 rax, rax, 13
  036a2	b9 04 00 00 00	 mov	 ecx, 4
  036a7	48 6b c9 0f	 imul	 rcx, rcx, 15
  036ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  036b2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  036b5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  036b9	0b c1		 or	 eax, ecx
  036bb	b9 04 00 00 00	 mov	 ecx, 4
  036c0	48 6b c9 0d	 imul	 rcx, rcx, 13
  036c4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8807 :         OrResult[14] |= OrConstant[16];

  036c8	b8 04 00 00 00	 mov	 eax, 4
  036cd	48 6b c0 0e	 imul	 rax, rax, 14
  036d1	b9 04 00 00 00	 mov	 ecx, 4
  036d6	48 6b c9 10	 imul	 rcx, rcx, 16
  036da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  036e1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  036e4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  036e8	0b c1		 or	 eax, ecx
  036ea	b9 04 00 00 00	 mov	 ecx, 4
  036ef	48 6b c9 0e	 imul	 rcx, rcx, 14
  036f3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8808 :         OrResult[17] |= OrConstant[17];

  036f7	b8 04 00 00 00	 mov	 eax, 4
  036fc	48 6b c0 11	 imul	 rax, rax, 17
  03700	b9 04 00 00 00	 mov	 ecx, 4
  03705	48 6b c9 11	 imul	 rcx, rcx, 17
  03709	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03710	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03713	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03717	0b c1		 or	 eax, ecx
  03719	b9 04 00 00 00	 mov	 ecx, 4
  0371e	48 6b c9 11	 imul	 rcx, rcx, 17
  03722	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8809 :         OrResult[19] |= OrConstant[20];

  03726	b8 04 00 00 00	 mov	 eax, 4
  0372b	48 6b c0 13	 imul	 rax, rax, 19
  0372f	b9 04 00 00 00	 mov	 ecx, 4
  03734	48 6b c9 14	 imul	 rcx, rcx, 20
  03738	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0373f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03742	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03746	0b c1		 or	 eax, ecx
  03748	b9 04 00 00 00	 mov	 ecx, 4
  0374d	48 6b c9 13	 imul	 rcx, rcx, 19
  03751	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8810 :         OrResult[20] |= OrConstant[13];

  03755	b8 04 00 00 00	 mov	 eax, 4
  0375a	48 6b c0 14	 imul	 rax, rax, 20
  0375e	b9 04 00 00 00	 mov	 ecx, 4
  03763	48 6b c9 0d	 imul	 rcx, rcx, 13
  03767	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0376e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03771	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03775	0b c1		 or	 eax, ecx
  03777	b9 04 00 00 00	 mov	 ecx, 4
  0377c	48 6b c9 14	 imul	 rcx, rcx, 20
  03780	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8811 :         OrResult[24] |= OrConstant[21];

  03784	b8 04 00 00 00	 mov	 eax, 4
  03789	48 6b c0 18	 imul	 rax, rax, 24
  0378d	b9 04 00 00 00	 mov	 ecx, 4
  03792	48 6b c9 15	 imul	 rcx, rcx, 21
  03796	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0379d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  037a0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  037a4	0b c1		 or	 eax, ecx
  037a6	b9 04 00 00 00	 mov	 ecx, 4
  037ab	48 6b c9 18	 imul	 rcx, rcx, 24
  037af	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8812 :         OrResult[27] |= OrConstant[12];

  037b3	b8 04 00 00 00	 mov	 eax, 4
  037b8	48 6b c0 1b	 imul	 rax, rax, 27
  037bc	b9 04 00 00 00	 mov	 ecx, 4
  037c1	48 6b c9 0c	 imul	 rcx, rcx, 12
  037c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  037cc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  037cf	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  037d3	0b c1		 or	 eax, ecx
  037d5	b9 04 00 00 00	 mov	 ecx, 4
  037da	48 6b c9 1b	 imul	 rcx, rcx, 27
  037de	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8813 :         OrResult[29] |= OrConstant[23];

  037e2	b8 04 00 00 00	 mov	 eax, 4
  037e7	48 6b c0 1d	 imul	 rax, rax, 29
  037eb	b9 04 00 00 00	 mov	 ecx, 4
  037f0	48 6b c9 17	 imul	 rcx, rcx, 23
  037f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  037fb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  037fe	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03802	0b c1		 or	 eax, ecx
  03804	b9 04 00 00 00	 mov	 ecx, 4
  03809	48 6b c9 1d	 imul	 rcx, rcx, 29
  0380d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8814 :         OrResult[31] |= OrConstant[16];

  03811	b8 04 00 00 00	 mov	 eax, 4
  03816	48 6b c0 1f	 imul	 rax, rax, 31
  0381a	b9 04 00 00 00	 mov	 ecx, 4
  0381f	48 6b c9 10	 imul	 rcx, rcx, 16
  03823	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0382a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0382d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03831	0b c1		 or	 eax, ecx
  03833	b9 04 00 00 00	 mov	 ecx, 4
  03838	48 6b c9 1f	 imul	 rcx, rcx, 31
  0383c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN31@gen_csv_si:

; 8815 :     }
; 8816 :     if ((pClock1[3] & 0x80 ) == 0x80)

  03840	b8 01 00 00 00	 mov	 eax, 1
  03845	48 6b c0 03	 imul	 rax, rax, 3
  03849	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  03851	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03855	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0385a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0385f	0f 85 92 02 00
	00		 jne	 $LN32@gen_csv_si

; 8817 :     {
; 8818 :         OrResult[0]  |= OrConstant[5];

  03865	b8 04 00 00 00	 mov	 eax, 4
  0386a	48 6b c0 00	 imul	 rax, rax, 0
  0386e	b9 04 00 00 00	 mov	 ecx, 4
  03873	48 6b c9 05	 imul	 rcx, rcx, 5
  03877	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0387e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03881	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03885	0b c1		 or	 eax, ecx
  03887	b9 04 00 00 00	 mov	 ecx, 4
  0388c	48 6b c9 00	 imul	 rcx, rcx, 0
  03890	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8819 :         OrResult[3]  |= OrConstant[3];

  03894	b8 04 00 00 00	 mov	 eax, 4
  03899	48 6b c0 03	 imul	 rax, rax, 3
  0389d	b9 04 00 00 00	 mov	 ecx, 4
  038a2	48 6b c9 03	 imul	 rcx, rcx, 3
  038a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  038ad	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  038b0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  038b4	0b c1		 or	 eax, ecx
  038b6	b9 04 00 00 00	 mov	 ecx, 4
  038bb	48 6b c9 03	 imul	 rcx, rcx, 3
  038bf	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8820 :         OrResult[4]  |= OrConstant[11];

  038c3	b8 04 00 00 00	 mov	 eax, 4
  038c8	48 6b c0 04	 imul	 rax, rax, 4
  038cc	b9 04 00 00 00	 mov	 ecx, 4
  038d1	48 6b c9 0b	 imul	 rcx, rcx, 11
  038d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  038dc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  038df	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  038e3	0b c1		 or	 eax, ecx
  038e5	b9 04 00 00 00	 mov	 ecx, 4
  038ea	48 6b c9 04	 imul	 rcx, rcx, 4
  038ee	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8821 :         OrResult[7]  |= OrConstant[5];

  038f2	b8 04 00 00 00	 mov	 eax, 4
  038f7	48 6b c0 07	 imul	 rax, rax, 7
  038fb	b9 04 00 00 00	 mov	 ecx, 4
  03900	48 6b c9 05	 imul	 rcx, rcx, 5
  03904	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0390b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0390e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03912	0b c1		 or	 eax, ecx
  03914	b9 04 00 00 00	 mov	 ecx, 4
  03919	48 6b c9 07	 imul	 rcx, rcx, 7
  0391d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8822 :         OrResult[8]  |= OrConstant[8];

  03921	b8 04 00 00 00	 mov	 eax, 4
  03926	48 6b c0 08	 imul	 rax, rax, 8
  0392a	b9 04 00 00 00	 mov	 ecx, 4
  0392f	48 6b c9 08	 imul	 rcx, rcx, 8
  03933	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0393a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0393d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03941	0b c1		 or	 eax, ecx
  03943	b9 04 00 00 00	 mov	 ecx, 4
  03948	48 6b c9 08	 imul	 rcx, rcx, 8
  0394c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8823 :         OrResult[10] |= OrConstant[0];

  03950	b8 04 00 00 00	 mov	 eax, 4
  03955	48 6b c0 0a	 imul	 rax, rax, 10
  03959	b9 04 00 00 00	 mov	 ecx, 4
  0395e	48 6b c9 00	 imul	 rcx, rcx, 0
  03962	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03969	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0396c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03970	0b c1		 or	 eax, ecx
  03972	b9 04 00 00 00	 mov	 ecx, 4
  03977	48 6b c9 0a	 imul	 rcx, rcx, 10
  0397b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8824 :         OrResult[13] |= OrConstant[6];

  0397f	b8 04 00 00 00	 mov	 eax, 4
  03984	48 6b c0 0d	 imul	 rax, rax, 13
  03988	b9 04 00 00 00	 mov	 ecx, 4
  0398d	48 6b c9 06	 imul	 rcx, rcx, 6
  03991	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03998	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0399b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0399f	0b c1		 or	 eax, ecx
  039a1	b9 04 00 00 00	 mov	 ecx, 4
  039a6	48 6b c9 0d	 imul	 rcx, rcx, 13
  039aa	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8825 :         OrResult[16] |= OrConstant[7];

  039ae	b8 04 00 00 00	 mov	 eax, 4
  039b3	48 6b c0 10	 imul	 rax, rax, 16
  039b7	b9 04 00 00 00	 mov	 ecx, 4
  039bc	48 6b c9 07	 imul	 rcx, rcx, 7
  039c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  039c7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  039ca	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  039ce	0b c1		 or	 eax, ecx
  039d0	b9 04 00 00 00	 mov	 ecx, 4
  039d5	48 6b c9 10	 imul	 rcx, rcx, 16
  039d9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8826 :         OrResult[19] |= OrConstant[4];

  039dd	b8 04 00 00 00	 mov	 eax, 4
  039e2	48 6b c0 13	 imul	 rax, rax, 19
  039e6	b9 04 00 00 00	 mov	 ecx, 4
  039eb	48 6b c9 04	 imul	 rcx, rcx, 4
  039ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  039f6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  039f9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  039fd	0b c1		 or	 eax, ecx
  039ff	b9 04 00 00 00	 mov	 ecx, 4
  03a04	48 6b c9 13	 imul	 rcx, rcx, 19
  03a08	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8827 :         OrResult[20] |= OrConstant[6];

  03a0c	b8 04 00 00 00	 mov	 eax, 4
  03a11	48 6b c0 14	 imul	 rax, rax, 20
  03a15	b9 04 00 00 00	 mov	 ecx, 4
  03a1a	48 6b c9 06	 imul	 rcx, rcx, 6
  03a1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03a25	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03a28	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03a2c	0b c1		 or	 eax, ecx
  03a2e	b9 04 00 00 00	 mov	 ecx, 4
  03a33	48 6b c9 14	 imul	 rcx, rcx, 20
  03a37	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8828 :         OrResult[25] |= OrConstant[8];

  03a3b	b8 04 00 00 00	 mov	 eax, 4
  03a40	48 6b c0 19	 imul	 rax, rax, 25
  03a44	b9 04 00 00 00	 mov	 ecx, 4
  03a49	48 6b c9 08	 imul	 rcx, rcx, 8
  03a4d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03a54	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03a57	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03a5b	0b c1		 or	 eax, ecx
  03a5d	b9 04 00 00 00	 mov	 ecx, 4
  03a62	48 6b c9 19	 imul	 rcx, rcx, 25
  03a66	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8829 :         OrResult[26] |= OrConstant[4];

  03a6a	b8 04 00 00 00	 mov	 eax, 4
  03a6f	48 6b c0 1a	 imul	 rax, rax, 26
  03a73	b9 04 00 00 00	 mov	 ecx, 4
  03a78	48 6b c9 04	 imul	 rcx, rcx, 4
  03a7c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03a83	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03a86	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03a8a	0b c1		 or	 eax, ecx
  03a8c	b9 04 00 00 00	 mov	 ecx, 4
  03a91	48 6b c9 1a	 imul	 rcx, rcx, 26
  03a95	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8830 :         OrResult[29] |= OrConstant[0];

  03a99	b8 04 00 00 00	 mov	 eax, 4
  03a9e	48 6b c0 1d	 imul	 rax, rax, 29
  03aa2	b9 04 00 00 00	 mov	 ecx, 4
  03aa7	48 6b c9 00	 imul	 rcx, rcx, 0
  03aab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03ab2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03ab5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03ab9	0b c1		 or	 eax, ecx
  03abb	b9 04 00 00 00	 mov	 ecx, 4
  03ac0	48 6b c9 1d	 imul	 rcx, rcx, 29
  03ac4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8831 :         OrResult[30] |= OrConstant[9];

  03ac8	b8 04 00 00 00	 mov	 eax, 4
  03acd	48 6b c0 1e	 imul	 rax, rax, 30
  03ad1	b9 04 00 00 00	 mov	 ecx, 4
  03ad6	48 6b c9 09	 imul	 rcx, rcx, 9
  03ada	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03ae1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03ae4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03ae8	0b c1		 or	 eax, ecx
  03aea	b9 04 00 00 00	 mov	 ecx, 4
  03aef	48 6b c9 1e	 imul	 rcx, rcx, 30
  03af3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN32@gen_csv_si:

; 8832 :     }
; 8833 :     if ((pClock1[3] & 0x40 ) == 0x40)

  03af7	b8 01 00 00 00	 mov	 eax, 1
  03afc	48 6b c0 03	 imul	 rax, rax, 3
  03b00	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  03b08	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03b0c	83 e0 40	 and	 eax, 64			; 00000040H
  03b0f	83 f8 40	 cmp	 eax, 64			; 00000040H
  03b12	0f 85 63 02 00
	00		 jne	 $LN33@gen_csv_si

; 8834 :     {
; 8835 :         OrResult[1]  |= OrConstant[10];

  03b18	b8 04 00 00 00	 mov	 eax, 4
  03b1d	48 6b c0 01	 imul	 rax, rax, 1
  03b21	b9 04 00 00 00	 mov	 ecx, 4
  03b26	48 6b c9 0a	 imul	 rcx, rcx, 10
  03b2a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03b31	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03b34	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03b38	0b c1		 or	 eax, ecx
  03b3a	b9 04 00 00 00	 mov	 ecx, 4
  03b3f	48 6b c9 01	 imul	 rcx, rcx, 1
  03b43	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8836 :         OrResult[2]  |= OrConstant[0];

  03b47	b8 04 00 00 00	 mov	 eax, 4
  03b4c	48 6b c0 02	 imul	 rax, rax, 2
  03b50	b9 04 00 00 00	 mov	 ecx, 4
  03b55	48 6b c9 00	 imul	 rcx, rcx, 0
  03b59	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03b60	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03b63	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03b67	0b c1		 or	 eax, ecx
  03b69	b9 04 00 00 00	 mov	 ecx, 4
  03b6e	48 6b c9 02	 imul	 rcx, rcx, 2
  03b72	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8837 :         OrResult[5]  |= OrConstant[6];

  03b76	b8 04 00 00 00	 mov	 eax, 4
  03b7b	48 6b c0 05	 imul	 rax, rax, 5
  03b7f	b9 04 00 00 00	 mov	 ecx, 4
  03b84	48 6b c9 06	 imul	 rcx, rcx, 6
  03b88	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03b8f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03b92	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03b96	0b c1		 or	 eax, ecx
  03b98	b9 04 00 00 00	 mov	 ecx, 4
  03b9d	48 6b c9 05	 imul	 rcx, rcx, 5
  03ba1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8838 :         OrResult[9]  |= OrConstant[9];

  03ba5	b8 04 00 00 00	 mov	 eax, 4
  03baa	48 6b c0 09	 imul	 rax, rax, 9
  03bae	b9 04 00 00 00	 mov	 ecx, 4
  03bb3	48 6b c9 09	 imul	 rcx, rcx, 9
  03bb7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03bbe	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03bc1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03bc5	0b c1		 or	 eax, ecx
  03bc7	b9 04 00 00 00	 mov	 ecx, 4
  03bcc	48 6b c9 09	 imul	 rcx, rcx, 9
  03bd0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8839 :         OrResult[12] |= OrConstant[3];

  03bd4	b8 04 00 00 00	 mov	 eax, 4
  03bd9	48 6b c0 0c	 imul	 rax, rax, 12
  03bdd	b9 04 00 00 00	 mov	 ecx, 4
  03be2	48 6b c9 03	 imul	 rcx, rcx, 3
  03be6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03bed	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03bf0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03bf4	0b c1		 or	 eax, ecx
  03bf6	b9 04 00 00 00	 mov	 ecx, 4
  03bfb	48 6b c9 0c	 imul	 rcx, rcx, 12
  03bff	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8840 :         OrResult[14] |= OrConstant[10];

  03c03	b8 04 00 00 00	 mov	 eax, 4
  03c08	48 6b c0 0e	 imul	 rax, rax, 14
  03c0c	b9 04 00 00 00	 mov	 ecx, 4
  03c11	48 6b c9 0a	 imul	 rcx, rcx, 10
  03c15	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03c1c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03c1f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03c23	0b c1		 or	 eax, ecx
  03c25	b9 04 00 00 00	 mov	 ecx, 4
  03c2a	48 6b c9 0e	 imul	 rcx, rcx, 14
  03c2e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8841 :         OrResult[17] |= OrConstant[8];

  03c32	b8 04 00 00 00	 mov	 eax, 4
  03c37	48 6b c0 11	 imul	 rax, rax, 17
  03c3b	b9 04 00 00 00	 mov	 ecx, 4
  03c40	48 6b c9 08	 imul	 rcx, rcx, 8
  03c44	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03c4b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03c4e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03c52	0b c1		 or	 eax, ecx
  03c54	b9 04 00 00 00	 mov	 ecx, 4
  03c59	48 6b c9 11	 imul	 rcx, rcx, 17
  03c5d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8842 :         OrResult[18] |= OrConstant[4];

  03c61	b8 04 00 00 00	 mov	 eax, 4
  03c66	48 6b c0 12	 imul	 rax, rax, 18
  03c6a	b9 04 00 00 00	 mov	 ecx, 4
  03c6f	48 6b c9 04	 imul	 rcx, rcx, 4
  03c73	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03c7a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03c7d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03c81	0b c1		 or	 eax, ecx
  03c83	b9 04 00 00 00	 mov	 ecx, 4
  03c88	48 6b c9 12	 imul	 rcx, rcx, 18
  03c8c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8843 :         OrResult[21] |= OrConstant[0];

  03c90	b8 04 00 00 00	 mov	 eax, 4
  03c95	48 6b c0 15	 imul	 rax, rax, 21
  03c99	b9 04 00 00 00	 mov	 ecx, 4
  03c9e	48 6b c9 00	 imul	 rcx, rcx, 0
  03ca2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03ca9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03cac	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03cb0	0b c1		 or	 eax, ecx
  03cb2	b9 04 00 00 00	 mov	 ecx, 4
  03cb7	48 6b c9 15	 imul	 rcx, rcx, 21
  03cbb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8844 :         OrResult[22] |= OrConstant[5];

  03cbf	b8 04 00 00 00	 mov	 eax, 4
  03cc4	48 6b c0 16	 imul	 rax, rax, 22
  03cc8	b9 04 00 00 00	 mov	 ecx, 4
  03ccd	48 6b c9 05	 imul	 rcx, rcx, 5
  03cd1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03cd8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03cdb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03cdf	0b c1		 or	 eax, ecx
  03ce1	b9 04 00 00 00	 mov	 ecx, 4
  03ce6	48 6b c9 16	 imul	 rcx, rcx, 22
  03cea	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8845 :         OrResult[25] |= OrConstant[7];

  03cee	b8 04 00 00 00	 mov	 eax, 4
  03cf3	48 6b c0 19	 imul	 rax, rax, 25
  03cf7	b9 04 00 00 00	 mov	 ecx, 4
  03cfc	48 6b c9 07	 imul	 rcx, rcx, 7
  03d00	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03d07	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03d0a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03d0e	0b c1		 or	 eax, ecx
  03d10	b9 04 00 00 00	 mov	 ecx, 4
  03d15	48 6b c9 19	 imul	 rcx, rcx, 25
  03d19	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8846 :         OrResult[28] |= OrConstant[2];

  03d1d	b8 04 00 00 00	 mov	 eax, 4
  03d22	48 6b c0 1c	 imul	 rax, rax, 28
  03d26	b9 04 00 00 00	 mov	 ecx, 4
  03d2b	48 6b c9 02	 imul	 rcx, rcx, 2
  03d2f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03d36	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03d39	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03d3d	0b c1		 or	 eax, ecx
  03d3f	b9 04 00 00 00	 mov	 ecx, 4
  03d44	48 6b c9 1c	 imul	 rcx, rcx, 28
  03d48	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8847 :         OrResult[30] |= OrConstant[8];

  03d4c	b8 04 00 00 00	 mov	 eax, 4
  03d51	48 6b c0 1e	 imul	 rax, rax, 30
  03d55	b9 04 00 00 00	 mov	 ecx, 4
  03d5a	48 6b c9 08	 imul	 rcx, rcx, 8
  03d5e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03d65	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03d68	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03d6c	0b c1		 or	 eax, ecx
  03d6e	b9 04 00 00 00	 mov	 ecx, 4
  03d73	48 6b c9 1e	 imul	 rcx, rcx, 30
  03d77	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN33@gen_csv_si:

; 8848 :     }
; 8849 :     if ((pClock1[3] & 0x20 ) == 0x20)

  03d7b	b8 01 00 00 00	 mov	 eax, 1
  03d80	48 6b c0 03	 imul	 rax, rax, 3
  03d84	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  03d8c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03d90	83 e0 20	 and	 eax, 32			; 00000020H
  03d93	83 f8 20	 cmp	 eax, 32			; 00000020H
  03d96	0f 85 92 02 00
	00		 jne	 $LN34@gen_csv_si

; 8850 :     {
; 8851 :         OrResult[1]  |= OrConstant[4];

  03d9c	b8 04 00 00 00	 mov	 eax, 4
  03da1	48 6b c0 01	 imul	 rax, rax, 1
  03da5	b9 04 00 00 00	 mov	 ecx, 4
  03daa	48 6b c9 04	 imul	 rcx, rcx, 4
  03dae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03db5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03db8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03dbc	0b c1		 or	 eax, ecx
  03dbe	b9 04 00 00 00	 mov	 ecx, 4
  03dc3	48 6b c9 01	 imul	 rcx, rcx, 1
  03dc7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8852 :         OrResult[4]  |= OrConstant[3];

  03dcb	b8 04 00 00 00	 mov	 eax, 4
  03dd0	48 6b c0 04	 imul	 rax, rax, 4
  03dd4	b9 04 00 00 00	 mov	 ecx, 4
  03dd9	48 6b c9 03	 imul	 rcx, rcx, 3
  03ddd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03de4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03de7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03deb	0b c1		 or	 eax, ecx
  03ded	b9 04 00 00 00	 mov	 ecx, 4
  03df2	48 6b c9 04	 imul	 rcx, rcx, 4
  03df6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8853 :         OrResult[6]  |= OrConstant[10];

  03dfa	b8 04 00 00 00	 mov	 eax, 4
  03dff	48 6b c0 06	 imul	 rax, rax, 6
  03e03	b9 04 00 00 00	 mov	 ecx, 4
  03e08	48 6b c9 0a	 imul	 rcx, rcx, 10
  03e0c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03e13	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03e16	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03e1a	0b c1		 or	 eax, ecx
  03e1c	b9 04 00 00 00	 mov	 ecx, 4
  03e21	48 6b c9 06	 imul	 rcx, rcx, 6
  03e25	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8854 :         OrResult[9]  |= OrConstant[1];

  03e29	b8 04 00 00 00	 mov	 eax, 4
  03e2e	48 6b c0 09	 imul	 rax, rax, 9
  03e32	b9 04 00 00 00	 mov	 ecx, 4
  03e37	48 6b c9 01	 imul	 rcx, rcx, 1
  03e3b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03e42	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03e45	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03e49	0b c1		 or	 eax, ecx
  03e4b	b9 04 00 00 00	 mov	 ecx, 4
  03e50	48 6b c9 09	 imul	 rcx, rcx, 9
  03e54	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8855 :         OrResult[11] |= OrConstant[11];

  03e58	b8 04 00 00 00	 mov	 eax, 4
  03e5d	48 6b c0 0b	 imul	 rax, rax, 11
  03e61	b9 04 00 00 00	 mov	 ecx, 4
  03e66	48 6b c9 0b	 imul	 rcx, rcx, 11
  03e6a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03e71	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03e74	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03e78	0b c1		 or	 eax, ecx
  03e7a	b9 04 00 00 00	 mov	 ecx, 4
  03e7f	48 6b c9 0b	 imul	 rcx, rcx, 11
  03e83	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8856 :         OrResult[12] |= OrConstant[9];

  03e87	b8 04 00 00 00	 mov	 eax, 4
  03e8c	48 6b c0 0c	 imul	 rax, rax, 12
  03e90	b9 04 00 00 00	 mov	 ecx, 4
  03e95	48 6b c9 09	 imul	 rcx, rcx, 9
  03e99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03ea0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03ea3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03ea7	0b c1		 or	 eax, ecx
  03ea9	b9 04 00 00 00	 mov	 ecx, 4
  03eae	48 6b c9 0c	 imul	 rcx, rcx, 12
  03eb2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8857 :         OrResult[15] |= OrConstant[3];

  03eb6	b8 04 00 00 00	 mov	 eax, 4
  03ebb	48 6b c0 0f	 imul	 rax, rax, 15
  03ebf	b9 04 00 00 00	 mov	 ecx, 4
  03ec4	48 6b c9 03	 imul	 rcx, rcx, 3
  03ec8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03ecf	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03ed2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03ed6	0b c1		 or	 eax, ecx
  03ed8	b9 04 00 00 00	 mov	 ecx, 4
  03edd	48 6b c9 0f	 imul	 rcx, rcx, 15
  03ee1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8858 :         OrResult[17] |= OrConstant[7];

  03ee5	b8 04 00 00 00	 mov	 eax, 4
  03eea	48 6b c0 11	 imul	 rax, rax, 17
  03eee	b9 04 00 00 00	 mov	 ecx, 4
  03ef3	48 6b c9 07	 imul	 rcx, rcx, 7
  03ef7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03efe	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03f01	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03f05	0b c1		 or	 eax, ecx
  03f07	b9 04 00 00 00	 mov	 ecx, 4
  03f0c	48 6b c9 11	 imul	 rcx, rcx, 17
  03f10	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8859 :         OrResult[20] |= OrConstant[2];

  03f14	b8 04 00 00 00	 mov	 eax, 4
  03f19	48 6b c0 14	 imul	 rax, rax, 20
  03f1d	b9 04 00 00 00	 mov	 ecx, 4
  03f22	48 6b c9 02	 imul	 rcx, rcx, 2
  03f26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03f2d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03f30	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03f34	0b c1		 or	 eax, ecx
  03f36	b9 04 00 00 00	 mov	 ecx, 4
  03f3b	48 6b c9 14	 imul	 rcx, rcx, 20
  03f3f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8860 :         OrResult[23] |= OrConstant[10];

  03f43	b8 04 00 00 00	 mov	 eax, 4
  03f48	48 6b c0 17	 imul	 rax, rax, 23
  03f4c	b9 04 00 00 00	 mov	 ecx, 4
  03f51	48 6b c9 0a	 imul	 rcx, rcx, 10
  03f55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03f5c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03f5f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03f63	0b c1		 or	 eax, ecx
  03f65	b9 04 00 00 00	 mov	 ecx, 4
  03f6a	48 6b c9 17	 imul	 rcx, rcx, 23
  03f6e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8861 :         OrResult[25] |= OrConstant[2];

  03f72	b8 04 00 00 00	 mov	 eax, 4
  03f77	48 6b c0 19	 imul	 rax, rax, 25
  03f7b	b9 04 00 00 00	 mov	 ecx, 4
  03f80	48 6b c9 02	 imul	 rcx, rcx, 2
  03f84	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03f8b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03f8e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03f92	0b c1		 or	 eax, ecx
  03f94	b9 04 00 00 00	 mov	 ecx, 4
  03f99	48 6b c9 19	 imul	 rcx, rcx, 25
  03f9d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8862 :         OrResult[26] |= OrConstant[1];

  03fa1	b8 04 00 00 00	 mov	 eax, 4
  03fa6	48 6b c0 1a	 imul	 rax, rax, 26
  03faa	b9 04 00 00 00	 mov	 ecx, 4
  03faf	48 6b c9 01	 imul	 rcx, rcx, 1
  03fb3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03fba	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03fbd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03fc1	0b c1		 or	 eax, ecx
  03fc3	b9 04 00 00 00	 mov	 ecx, 4
  03fc8	48 6b c9 1a	 imul	 rcx, rcx, 26
  03fcc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8863 :         OrResult[28] |= OrConstant[7];

  03fd0	b8 04 00 00 00	 mov	 eax, 4
  03fd5	48 6b c0 1c	 imul	 rax, rax, 28
  03fd9	b9 04 00 00 00	 mov	 ecx, 4
  03fde	48 6b c9 07	 imul	 rcx, rcx, 7
  03fe2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  03fe9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  03fec	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  03ff0	0b c1		 or	 eax, ecx
  03ff2	b9 04 00 00 00	 mov	 ecx, 4
  03ff7	48 6b c9 1c	 imul	 rcx, rcx, 28
  03ffb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8864 :         OrResult[31] |= OrConstant[9];

  03fff	b8 04 00 00 00	 mov	 eax, 4
  04004	48 6b c0 1f	 imul	 rax, rax, 31
  04008	b9 04 00 00 00	 mov	 ecx, 4
  0400d	48 6b c9 09	 imul	 rcx, rcx, 9
  04011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04018	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0401b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0401f	0b c1		 or	 eax, ecx
  04021	b9 04 00 00 00	 mov	 ecx, 4
  04026	48 6b c9 1f	 imul	 rcx, rcx, 31
  0402a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN34@gen_csv_si:

; 8865 :     }
; 8866 :     if ((pClock1[3] & 0x10 ) == 0x10)

  0402e	b8 01 00 00 00	 mov	 eax, 1
  04033	48 6b c0 03	 imul	 rax, rax, 3
  04037	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0403f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  04043	83 e0 10	 and	 eax, 16
  04046	83 f8 10	 cmp	 eax, 16
  04049	0f 85 63 02 00
	00		 jne	 $LN35@gen_csv_si

; 8867 :     {
; 8868 :         OrResult[0]  |= OrConstant[23];

  0404f	b8 04 00 00 00	 mov	 eax, 4
  04054	48 6b c0 00	 imul	 rax, rax, 0
  04058	b9 04 00 00 00	 mov	 ecx, 4
  0405d	48 6b c9 17	 imul	 rcx, rcx, 23
  04061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04068	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0406b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0406f	0b c1		 or	 eax, ecx
  04071	b9 04 00 00 00	 mov	 ecx, 4
  04076	48 6b c9 00	 imul	 rcx, rcx, 0
  0407a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8869 :         OrResult[4]  |= OrConstant[21];

  0407e	b8 04 00 00 00	 mov	 eax, 4
  04083	48 6b c0 04	 imul	 rax, rax, 4
  04087	b9 04 00 00 00	 mov	 ecx, 4
  0408c	48 6b c9 15	 imul	 rcx, rcx, 21
  04090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04097	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0409a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0409e	0b c1		 or	 eax, ecx
  040a0	b9 04 00 00 00	 mov	 ecx, 4
  040a5	48 6b c9 04	 imul	 rcx, rcx, 4
  040a9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8870 :         OrResult[7]  |= OrConstant[12];

  040ad	b8 04 00 00 00	 mov	 eax, 4
  040b2	48 6b c0 07	 imul	 rax, rax, 7
  040b6	b9 04 00 00 00	 mov	 ecx, 4
  040bb	48 6b c9 0c	 imul	 rcx, rcx, 12
  040bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  040c6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  040c9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  040cd	0b c1		 or	 eax, ecx
  040cf	b9 04 00 00 00	 mov	 ecx, 4
  040d4	48 6b c9 07	 imul	 rcx, rcx, 7
  040d8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8871 :         OrResult[9]  |= OrConstant[23];

  040dc	b8 04 00 00 00	 mov	 eax, 4
  040e1	48 6b c0 09	 imul	 rax, rax, 9
  040e5	b9 04 00 00 00	 mov	 ecx, 4
  040ea	48 6b c9 17	 imul	 rcx, rcx, 23
  040ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  040f5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  040f8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  040fc	0b c1		 or	 eax, ecx
  040fe	b9 04 00 00 00	 mov	 ecx, 4
  04103	48 6b c9 09	 imul	 rcx, rcx, 9
  04107	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8872 :         OrResult[10] |= OrConstant[22];

  0410b	b8 04 00 00 00	 mov	 eax, 4
  04110	48 6b c0 0a	 imul	 rax, rax, 10
  04114	b9 04 00 00 00	 mov	 ecx, 4
  04119	48 6b c9 16	 imul	 rcx, rcx, 22
  0411d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04124	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04127	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0412b	0b c1		 or	 eax, ecx
  0412d	b9 04 00 00 00	 mov	 ecx, 4
  04132	48 6b c9 0a	 imul	 rcx, rcx, 10
  04136	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8873 :         OrResult[13] |= OrConstant[21];

  0413a	b8 04 00 00 00	 mov	 eax, 4
  0413f	48 6b c0 0d	 imul	 rax, rax, 13
  04143	b9 04 00 00 00	 mov	 ecx, 4
  04148	48 6b c9 15	 imul	 rcx, rcx, 21
  0414c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04153	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04156	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0415a	0b c1		 or	 eax, ecx
  0415c	b9 04 00 00 00	 mov	 ecx, 4
  04161	48 6b c9 0d	 imul	 rcx, rcx, 13
  04165	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8874 :         OrResult[16] |= OrConstant[20];

  04169	b8 04 00 00 00	 mov	 eax, 4
  0416e	48 6b c0 10	 imul	 rax, rax, 16
  04172	b9 04 00 00 00	 mov	 ecx, 4
  04177	48 6b c9 14	 imul	 rcx, rcx, 20
  0417b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04182	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04185	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04189	0b c1		 or	 eax, ecx
  0418b	b9 04 00 00 00	 mov	 ecx, 4
  04190	48 6b c9 10	 imul	 rcx, rcx, 16
  04194	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8875 :         OrResult[18] |= OrConstant[12];

  04198	b8 04 00 00 00	 mov	 eax, 4
  0419d	48 6b c0 12	 imul	 rax, rax, 18
  041a1	b9 04 00 00 00	 mov	 ecx, 4
  041a6	48 6b c9 0c	 imul	 rcx, rcx, 12
  041aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  041b1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  041b4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  041b8	0b c1		 or	 eax, ecx
  041ba	b9 04 00 00 00	 mov	 ecx, 4
  041bf	48 6b c9 12	 imul	 rcx, rcx, 18
  041c3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8876 :         OrResult[23] |= OrConstant[15];

  041c7	b8 04 00 00 00	 mov	 eax, 4
  041cc	48 6b c0 17	 imul	 rax, rax, 23
  041d0	b9 04 00 00 00	 mov	 ecx, 4
  041d5	48 6b c9 0f	 imul	 rcx, rcx, 15
  041d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  041e0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  041e3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  041e7	0b c1		 or	 eax, ecx
  041e9	b9 04 00 00 00	 mov	 ecx, 4
  041ee	48 6b c9 17	 imul	 rcx, rcx, 23
  041f2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8877 :         OrResult[24] |= OrConstant[16];

  041f6	b8 04 00 00 00	 mov	 eax, 4
  041fb	48 6b c0 18	 imul	 rax, rax, 24
  041ff	b9 04 00 00 00	 mov	 ecx, 4
  04204	48 6b c9 10	 imul	 rcx, rcx, 16
  04208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0420f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04212	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04216	0b c1		 or	 eax, ecx
  04218	b9 04 00 00 00	 mov	 ecx, 4
  0421d	48 6b c9 18	 imul	 rcx, rcx, 24
  04221	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8878 :         OrResult[26] |= OrConstant[19];

  04225	b8 04 00 00 00	 mov	 eax, 4
  0422a	48 6b c0 1a	 imul	 rax, rax, 26
  0422e	b9 04 00 00 00	 mov	 ecx, 4
  04233	48 6b c9 13	 imul	 rcx, rcx, 19
  04237	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0423e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04241	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04245	0b c1		 or	 eax, ecx
  04247	b9 04 00 00 00	 mov	 ecx, 4
  0424c	48 6b c9 1a	 imul	 rcx, rcx, 26
  04250	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8879 :         OrResult[29] |= OrConstant[14];

  04254	b8 04 00 00 00	 mov	 eax, 4
  04259	48 6b c0 1d	 imul	 rax, rax, 29
  0425d	b9 04 00 00 00	 mov	 ecx, 4
  04262	48 6b c9 0e	 imul	 rcx, rcx, 14
  04266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0426d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04270	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04274	0b c1		 or	 eax, ecx
  04276	b9 04 00 00 00	 mov	 ecx, 4
  0427b	48 6b c9 1d	 imul	 rcx, rcx, 29
  0427f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8880 :         OrResult[30] |= OrConstant[13];

  04283	b8 04 00 00 00	 mov	 eax, 4
  04288	48 6b c0 1e	 imul	 rax, rax, 30
  0428c	b9 04 00 00 00	 mov	 ecx, 4
  04291	48 6b c9 0d	 imul	 rcx, rcx, 13
  04295	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0429c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0429f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  042a3	0b c1		 or	 eax, ecx
  042a5	b9 04 00 00 00	 mov	 ecx, 4
  042aa	48 6b c9 1e	 imul	 rcx, rcx, 30
  042ae	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN35@gen_csv_si:

; 8881 :     }
; 8882 :     if ((pClock1[3] & 0x08 ) == 0x08)

  042b2	b8 01 00 00 00	 mov	 eax, 1
  042b7	48 6b c0 03	 imul	 rax, rax, 3
  042bb	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  042c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  042c7	83 e0 08	 and	 eax, 8
  042ca	83 f8 08	 cmp	 eax, 8
  042cd	0f 85 63 02 00
	00		 jne	 $LN36@gen_csv_si

; 8883 :     {
; 8884 :         OrResult[0]  |= OrConstant[19];

  042d3	b8 04 00 00 00	 mov	 eax, 4
  042d8	48 6b c0 00	 imul	 rax, rax, 0
  042dc	b9 04 00 00 00	 mov	 ecx, 4
  042e1	48 6b c9 13	 imul	 rcx, rcx, 19
  042e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  042ec	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  042ef	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  042f3	0b c1		 or	 eax, ecx
  042f5	b9 04 00 00 00	 mov	 ecx, 4
  042fa	48 6b c9 00	 imul	 rcx, rcx, 0
  042fe	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8885 :         OrResult[3]  |= OrConstant[20];

  04302	b8 04 00 00 00	 mov	 eax, 4
  04307	48 6b c0 03	 imul	 rax, rax, 3
  0430b	b9 04 00 00 00	 mov	 ecx, 4
  04310	48 6b c9 14	 imul	 rcx, rcx, 20
  04314	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0431b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0431e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04322	0b c1		 or	 eax, ecx
  04324	b9 04 00 00 00	 mov	 ecx, 4
  04329	48 6b c9 03	 imul	 rcx, rcx, 3
  0432d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8886 :         OrResult[4]  |= OrConstant[13];

  04331	b8 04 00 00 00	 mov	 eax, 4
  04336	48 6b c0 04	 imul	 rax, rax, 4
  0433a	b9 04 00 00 00	 mov	 ecx, 4
  0433f	48 6b c9 0d	 imul	 rcx, rcx, 13
  04343	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0434a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0434d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04351	0b c1		 or	 eax, ecx
  04353	b9 04 00 00 00	 mov	 ecx, 4
  04358	48 6b c9 04	 imul	 rcx, rcx, 4
  0435c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8887 :         OrResult[8]  |= OrConstant[21];

  04360	b8 04 00 00 00	 mov	 eax, 4
  04365	48 6b c0 08	 imul	 rax, rax, 8
  04369	b9 04 00 00 00	 mov	 ecx, 4
  0436e	48 6b c9 15	 imul	 rcx, rcx, 21
  04372	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04379	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0437c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04380	0b c1		 or	 eax, ecx
  04382	b9 04 00 00 00	 mov	 ecx, 4
  04387	48 6b c9 08	 imul	 rcx, rcx, 8
  0438b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8888 :         OrResult[11] |= OrConstant[12];

  0438f	b8 04 00 00 00	 mov	 eax, 4
  04394	48 6b c0 0b	 imul	 rax, rax, 11
  04398	b9 04 00 00 00	 mov	 ecx, 4
  0439d	48 6b c9 0c	 imul	 rcx, rcx, 12
  043a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  043a8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  043ab	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  043af	0b c1		 or	 eax, ecx
  043b1	b9 04 00 00 00	 mov	 ecx, 4
  043b6	48 6b c9 0b	 imul	 rcx, rcx, 11
  043ba	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8889 :         OrResult[13] |= OrConstant[23];

  043be	b8 04 00 00 00	 mov	 eax, 4
  043c3	48 6b c0 0d	 imul	 rax, rax, 13
  043c7	b9 04 00 00 00	 mov	 ecx, 4
  043cc	48 6b c9 17	 imul	 rcx, rcx, 23
  043d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  043d7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  043da	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  043de	0b c1		 or	 eax, ecx
  043e0	b9 04 00 00 00	 mov	 ecx, 4
  043e5	48 6b c9 0d	 imul	 rcx, rcx, 13
  043e9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8890 :         OrResult[14] |= OrConstant[22];

  043ed	b8 04 00 00 00	 mov	 eax, 4
  043f2	48 6b c0 0e	 imul	 rax, rax, 14
  043f6	b9 04 00 00 00	 mov	 ecx, 4
  043fb	48 6b c9 16	 imul	 rcx, rcx, 22
  043ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04406	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04409	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0440d	0b c1		 or	 eax, ecx
  0440f	b9 04 00 00 00	 mov	 ecx, 4
  04414	48 6b c9 0e	 imul	 rcx, rcx, 14
  04418	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8891 :         OrResult[18] |= OrConstant[15];

  0441c	b8 04 00 00 00	 mov	 eax, 4
  04421	48 6b c0 12	 imul	 rax, rax, 18
  04425	b9 04 00 00 00	 mov	 ecx, 4
  0442a	48 6b c9 0f	 imul	 rcx, rcx, 15
  0442e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04435	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04438	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0443c	0b c1		 or	 eax, ecx
  0443e	b9 04 00 00 00	 mov	 ecx, 4
  04443	48 6b c9 12	 imul	 rcx, rcx, 18
  04447	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8892 :         OrResult[20] |= OrConstant[20];

  0444b	b8 04 00 00 00	 mov	 eax, 4
  04450	48 6b c0 14	 imul	 rax, rax, 20
  04454	b9 04 00 00 00	 mov	 ecx, 4
  04459	48 6b c9 14	 imul	 rcx, rcx, 20
  0445d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04464	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04467	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0446b	0b c1		 or	 eax, ecx
  0446d	b9 04 00 00 00	 mov	 ecx, 4
  04472	48 6b c9 14	 imul	 rcx, rcx, 20
  04476	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8893 :         OrResult[22] |= OrConstant[12];

  0447a	b8 04 00 00 00	 mov	 eax, 4
  0447f	48 6b c0 16	 imul	 rax, rax, 22
  04483	b9 04 00 00 00	 mov	 ecx, 4
  04488	48 6b c9 0c	 imul	 rcx, rcx, 12
  0448c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04493	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04496	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0449a	0b c1		 or	 eax, ecx
  0449c	b9 04 00 00 00	 mov	 ecx, 4
  044a1	48 6b c9 16	 imul	 rcx, rcx, 22
  044a5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8894 :         OrResult[27] |= OrConstant[15];

  044a9	b8 04 00 00 00	 mov	 eax, 4
  044ae	48 6b c0 1b	 imul	 rax, rax, 27
  044b2	b9 04 00 00 00	 mov	 ecx, 4
  044b7	48 6b c9 0f	 imul	 rcx, rcx, 15
  044bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  044c2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  044c5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  044c9	0b c1		 or	 eax, ecx
  044cb	b9 04 00 00 00	 mov	 ecx, 4
  044d0	48 6b c9 1b	 imul	 rcx, rcx, 27
  044d4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8895 :         OrResult[28] |= OrConstant[16];

  044d8	b8 04 00 00 00	 mov	 eax, 4
  044dd	48 6b c0 1c	 imul	 rax, rax, 28
  044e1	b9 04 00 00 00	 mov	 ecx, 4
  044e6	48 6b c9 10	 imul	 rcx, rcx, 16
  044ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  044f1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  044f4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  044f8	0b c1		 or	 eax, ecx
  044fa	b9 04 00 00 00	 mov	 ecx, 4
  044ff	48 6b c9 1c	 imul	 rcx, rcx, 28
  04503	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8896 :         OrResult[31] |= OrConstant[17];

  04507	b8 04 00 00 00	 mov	 eax, 4
  0450c	48 6b c0 1f	 imul	 rax, rax, 31
  04510	b9 04 00 00 00	 mov	 ecx, 4
  04515	48 6b c9 11	 imul	 rcx, rcx, 17
  04519	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04520	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04523	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04527	0b c1		 or	 eax, ecx
  04529	b9 04 00 00 00	 mov	 ecx, 4
  0452e	48 6b c9 1f	 imul	 rcx, rcx, 31
  04532	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN36@gen_csv_si:

; 8897 :     }
; 8898 :     if ((pClock1[3] & 0x04 ) == 0x04)

  04536	b8 01 00 00 00	 mov	 eax, 1
  0453b	48 6b c0 03	 imul	 rax, rax, 3
  0453f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  04547	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0454b	83 e0 04	 and	 eax, 4
  0454e	83 f8 04	 cmp	 eax, 4
  04551	0f 85 92 02 00
	00		 jne	 $LN37@gen_csv_si

; 8899 :     {
; 8900 :         OrResult[0]  |= OrConstant[12];

  04557	b8 04 00 00 00	 mov	 eax, 4
  0455c	48 6b c0 00	 imul	 rax, rax, 0
  04560	b9 04 00 00 00	 mov	 ecx, 4
  04565	48 6b c9 0c	 imul	 rcx, rcx, 12
  04569	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04570	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04573	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04577	0b c1		 or	 eax, ecx
  04579	b9 04 00 00 00	 mov	 ecx, 4
  0457e	48 6b c9 00	 imul	 rcx, rcx, 0
  04582	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8901 :         OrResult[3]  |= OrConstant[19];

  04586	b8 04 00 00 00	 mov	 eax, 4
  0458b	48 6b c0 03	 imul	 rax, rax, 3
  0458f	b9 04 00 00 00	 mov	 ecx, 4
  04594	48 6b c9 13	 imul	 rcx, rcx, 19
  04598	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0459f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  045a2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  045a6	0b c1		 or	 eax, ecx
  045a8	b9 04 00 00 00	 mov	 ecx, 4
  045ad	48 6b c9 03	 imul	 rcx, rcx, 3
  045b1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8902 :         OrResult[4]  |= OrConstant[18];

  045b5	b8 04 00 00 00	 mov	 eax, 4
  045ba	48 6b c0 04	 imul	 rax, rax, 4
  045be	b9 04 00 00 00	 mov	 ecx, 4
  045c3	48 6b c9 12	 imul	 rcx, rcx, 18
  045c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  045ce	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  045d1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  045d5	0b c1		 or	 eax, ecx
  045d7	b9 04 00 00 00	 mov	 ecx, 4
  045dc	48 6b c9 04	 imul	 rcx, rcx, 4
  045e0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8903 :         OrResult[7]  |= OrConstant[18];

  045e4	b8 04 00 00 00	 mov	 eax, 4
  045e9	48 6b c0 07	 imul	 rax, rax, 7
  045ed	b9 04 00 00 00	 mov	 ecx, 4
  045f2	48 6b c9 12	 imul	 rcx, rcx, 18
  045f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  045fd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04600	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04604	0b c1		 or	 eax, ecx
  04606	b9 04 00 00 00	 mov	 ecx, 4
  0460b	48 6b c9 07	 imul	 rcx, rcx, 7
  0460f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8904 :         OrResult[9]  |= OrConstant[17];

  04613	b8 04 00 00 00	 mov	 eax, 4
  04618	48 6b c0 09	 imul	 rax, rax, 9
  0461c	b9 04 00 00 00	 mov	 ecx, 4
  04621	48 6b c9 11	 imul	 rcx, rcx, 17
  04625	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0462c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0462f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04633	0b c1		 or	 eax, ecx
  04635	b9 04 00 00 00	 mov	 ecx, 4
  0463a	48 6b c9 09	 imul	 rcx, rcx, 9
  0463e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8905 :         OrResult[11] |= OrConstant[20];

  04642	b8 04 00 00 00	 mov	 eax, 4
  04647	48 6b c0 0b	 imul	 rax, rax, 11
  0464b	b9 04 00 00 00	 mov	 ecx, 4
  04650	48 6b c9 14	 imul	 rcx, rcx, 20
  04654	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0465b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0465e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04662	0b c1		 or	 eax, ecx
  04664	b9 04 00 00 00	 mov	 ecx, 4
  04669	48 6b c9 0b	 imul	 rcx, rcx, 11
  0466d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8906 :         OrResult[12] |= OrConstant[13];

  04671	b8 04 00 00 00	 mov	 eax, 4
  04676	48 6b c0 0c	 imul	 rax, rax, 12
  0467a	b9 04 00 00 00	 mov	 ecx, 4
  0467f	48 6b c9 0d	 imul	 rcx, rcx, 13
  04683	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0468a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0468d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04691	0b c1		 or	 eax, ecx
  04693	b9 04 00 00 00	 mov	 ecx, 4
  04698	48 6b c9 0c	 imul	 rcx, rcx, 12
  0469c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8907 :         OrResult[16] |= OrConstant[17];

  046a0	b8 04 00 00 00	 mov	 eax, 4
  046a5	48 6b c0 10	 imul	 rax, rax, 16
  046a9	b9 04 00 00 00	 mov	 ecx, 4
  046ae	48 6b c9 11	 imul	 rcx, rcx, 17
  046b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  046b9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  046bc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  046c0	0b c1		 or	 eax, ecx
  046c2	b9 04 00 00 00	 mov	 ecx, 4
  046c7	48 6b c9 10	 imul	 rcx, rcx, 16
  046cb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8908 :         OrResult[19] |= OrConstant[22];

  046cf	b8 04 00 00 00	 mov	 eax, 4
  046d4	48 6b c0 13	 imul	 rax, rax, 19
  046d8	b9 04 00 00 00	 mov	 ecx, 4
  046dd	48 6b c9 16	 imul	 rcx, rcx, 22
  046e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  046e8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  046eb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  046ef	0b c1		 or	 eax, ecx
  046f1	b9 04 00 00 00	 mov	 ecx, 4
  046f6	48 6b c9 13	 imul	 rcx, rcx, 19
  046fa	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8909 :         OrResult[20] |= OrConstant[14];

  046fe	b8 04 00 00 00	 mov	 eax, 4
  04703	48 6b c0 14	 imul	 rax, rax, 20
  04707	b9 04 00 00 00	 mov	 ecx, 4
  0470c	48 6b c9 0e	 imul	 rcx, rcx, 14
  04710	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04717	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0471a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0471e	0b c1		 or	 eax, ecx
  04720	b9 04 00 00 00	 mov	 ecx, 4
  04725	48 6b c9 14	 imul	 rcx, rcx, 20
  04729	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8910 :         OrResult[23] |= OrConstant[16];

  0472d	b8 04 00 00 00	 mov	 eax, 4
  04732	48 6b c0 17	 imul	 rax, rax, 23
  04736	b9 04 00 00 00	 mov	 ecx, 4
  0473b	48 6b c9 10	 imul	 rcx, rcx, 16
  0473f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04746	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04749	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0474d	0b c1		 or	 eax, ecx
  0474f	b9 04 00 00 00	 mov	 ecx, 4
  04754	48 6b c9 17	 imul	 rcx, rcx, 23
  04758	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8911 :         OrResult[26] |= OrConstant[15];

  0475c	b8 04 00 00 00	 mov	 eax, 4
  04761	48 6b c0 1a	 imul	 rax, rax, 26
  04765	b9 04 00 00 00	 mov	 ecx, 4
  0476a	48 6b c9 0f	 imul	 rcx, rcx, 15
  0476e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04775	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04778	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0477c	0b c1		 or	 eax, ecx
  0477e	b9 04 00 00 00	 mov	 ecx, 4
  04783	48 6b c9 1a	 imul	 rcx, rcx, 26
  04787	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8912 :         OrResult[28] |= OrConstant[20];

  0478b	b8 04 00 00 00	 mov	 eax, 4
  04790	48 6b c0 1c	 imul	 rax, rax, 28
  04794	b9 04 00 00 00	 mov	 ecx, 4
  04799	48 6b c9 14	 imul	 rcx, rcx, 20
  0479d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  047a4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  047a7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  047ab	0b c1		 or	 eax, ecx
  047ad	b9 04 00 00 00	 mov	 ecx, 4
  047b2	48 6b c9 1c	 imul	 rcx, rcx, 28
  047b6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8913 :         OrResult[31] |= OrConstant[13];

  047ba	b8 04 00 00 00	 mov	 eax, 4
  047bf	48 6b c0 1f	 imul	 rax, rax, 31
  047c3	b9 04 00 00 00	 mov	 ecx, 4
  047c8	48 6b c9 0d	 imul	 rcx, rcx, 13
  047cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  047d3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  047d6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  047da	0b c1		 or	 eax, ecx
  047dc	b9 04 00 00 00	 mov	 ecx, 4
  047e1	48 6b c9 1f	 imul	 rcx, rcx, 31
  047e5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN37@gen_csv_si:

; 8914 :     }
; 8915 :     if ((pClock1[3] & 0x02 ) == 0x02)

  047e9	b8 01 00 00 00	 mov	 eax, 1
  047ee	48 6b c0 03	 imul	 rax, rax, 3
  047f2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  047fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  047fe	83 e0 02	 and	 eax, 2
  04801	83 f8 02	 cmp	 eax, 2
  04804	0f 85 c1 02 00
	00		 jne	 $LN38@gen_csv_si

; 8916 :     {
; 8917 :         OrResult[1]  |= OrConstant[16];

  0480a	b8 04 00 00 00	 mov	 eax, 4
  0480f	48 6b c0 01	 imul	 rax, rax, 1
  04813	b9 04 00 00 00	 mov	 ecx, 4
  04818	48 6b c9 10	 imul	 rcx, rcx, 16
  0481c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04823	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04826	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0482a	0b c1		 or	 eax, ecx
  0482c	b9 04 00 00 00	 mov	 ecx, 4
  04831	48 6b c9 01	 imul	 rcx, rcx, 1
  04835	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8918 :         OrResult[2]  |= OrConstant[22];

  04839	b8 04 00 00 00	 mov	 eax, 4
  0483e	48 6b c0 02	 imul	 rax, rax, 2
  04842	b9 04 00 00 00	 mov	 ecx, 4
  04847	48 6b c9 16	 imul	 rcx, rcx, 22
  0484b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04852	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04855	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04859	0b c1		 or	 eax, ecx
  0485b	b9 04 00 00 00	 mov	 ecx, 4
  04860	48 6b c9 02	 imul	 rcx, rcx, 2
  04864	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8919 :         OrResult[5]  |= OrConstant[21];

  04868	b8 04 00 00 00	 mov	 eax, 4
  0486d	48 6b c0 05	 imul	 rax, rax, 5
  04871	b9 04 00 00 00	 mov	 ecx, 4
  04876	48 6b c9 15	 imul	 rcx, rcx, 21
  0487a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04881	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04884	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04888	0b c1		 or	 eax, ecx
  0488a	b9 04 00 00 00	 mov	 ecx, 4
  0488f	48 6b c9 05	 imul	 rcx, rcx, 5
  04893	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8920 :         OrResult[9]  |= OrConstant[13];

  04897	b8 04 00 00 00	 mov	 eax, 4
  0489c	48 6b c0 09	 imul	 rax, rax, 9
  048a0	b9 04 00 00 00	 mov	 ecx, 4
  048a5	48 6b c9 0d	 imul	 rcx, rcx, 13
  048a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  048b0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  048b3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  048b7	0b c1		 or	 eax, ecx
  048b9	b9 04 00 00 00	 mov	 ecx, 4
  048be	48 6b c9 09	 imul	 rcx, rcx, 9
  048c2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8921 :         OrResult[11] |= OrConstant[19];

  048c6	b8 04 00 00 00	 mov	 eax, 4
  048cb	48 6b c0 0b	 imul	 rax, rax, 11
  048cf	b9 04 00 00 00	 mov	 ecx, 4
  048d4	48 6b c9 13	 imul	 rcx, rcx, 19
  048d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  048df	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  048e2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  048e6	0b c1		 or	 eax, ecx
  048e8	b9 04 00 00 00	 mov	 ecx, 4
  048ed	48 6b c9 0b	 imul	 rcx, rcx, 11
  048f1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8922 :         OrResult[12] |= OrConstant[18];

  048f5	b8 04 00 00 00	 mov	 eax, 4
  048fa	48 6b c0 0c	 imul	 rax, rax, 12
  048fe	b9 04 00 00 00	 mov	 ecx, 4
  04903	48 6b c9 12	 imul	 rcx, rcx, 18
  04907	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0490e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04911	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04915	0b c1		 or	 eax, ecx
  04917	b9 04 00 00 00	 mov	 ecx, 4
  0491c	48 6b c9 0c	 imul	 rcx, rcx, 12
  04920	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8923 :         OrResult[15] |= OrConstant[18];

  04924	b8 04 00 00 00	 mov	 eax, 4
  04929	48 6b c0 0f	 imul	 rax, rax, 15
  0492d	b9 04 00 00 00	 mov	 ecx, 4
  04932	48 6b c9 12	 imul	 rcx, rcx, 18
  04936	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0493d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04940	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04944	0b c1		 or	 eax, ecx
  04946	b9 04 00 00 00	 mov	 ecx, 4
  0494b	48 6b c9 0f	 imul	 rcx, rcx, 15
  0494f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8924 :         OrResult[16] |= OrConstant[16];

  04953	b8 04 00 00 00	 mov	 eax, 4
  04958	48 6b c0 10	 imul	 rax, rax, 16
  0495c	b9 04 00 00 00	 mov	 ecx, 4
  04961	48 6b c9 10	 imul	 rcx, rcx, 16
  04965	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0496c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0496f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04973	0b c1		 or	 eax, ecx
  04975	b9 04 00 00 00	 mov	 ecx, 4
  0497a	48 6b c9 10	 imul	 rcx, rcx, 16
  0497e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8925 :         OrResult[18] |= OrConstant[19];

  04982	b8 04 00 00 00	 mov	 eax, 4
  04987	48 6b c0 12	 imul	 rax, rax, 18
  0498b	b9 04 00 00 00	 mov	 ecx, 4
  04990	48 6b c9 13	 imul	 rcx, rcx, 19
  04994	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0499b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0499e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  049a2	0b c1		 or	 eax, ecx
  049a4	b9 04 00 00 00	 mov	 ecx, 4
  049a9	48 6b c9 12	 imul	 rcx, rcx, 18
  049ad	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8926 :         OrResult[21] |= OrConstant[14];

  049b1	b8 04 00 00 00	 mov	 eax, 4
  049b6	48 6b c0 15	 imul	 rax, rax, 21
  049ba	b9 04 00 00 00	 mov	 ecx, 4
  049bf	48 6b c9 0e	 imul	 rcx, rcx, 14
  049c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  049ca	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  049cd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  049d1	0b c1		 or	 eax, ecx
  049d3	b9 04 00 00 00	 mov	 ecx, 4
  049d8	48 6b c9 15	 imul	 rcx, rcx, 21
  049dc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8927 :         OrResult[22] |= OrConstant[23];

  049e0	b8 04 00 00 00	 mov	 eax, 4
  049e5	48 6b c0 16	 imul	 rax, rax, 22
  049e9	b9 04 00 00 00	 mov	 ecx, 4
  049ee	48 6b c9 17	 imul	 rcx, rcx, 23
  049f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  049f9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  049fc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04a00	0b c1		 or	 eax, ecx
  04a02	b9 04 00 00 00	 mov	 ecx, 4
  04a07	48 6b c9 16	 imul	 rcx, rcx, 22
  04a0b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8928 :         OrResult[24] |= OrConstant[17];

  04a0f	b8 04 00 00 00	 mov	 eax, 4
  04a14	48 6b c0 18	 imul	 rax, rax, 24
  04a18	b9 04 00 00 00	 mov	 ecx, 4
  04a1d	48 6b c9 11	 imul	 rcx, rcx, 17
  04a21	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04a28	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04a2b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04a2f	0b c1		 or	 eax, ecx
  04a31	b9 04 00 00 00	 mov	 ecx, 4
  04a36	48 6b c9 18	 imul	 rcx, rcx, 24
  04a3a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8929 :         OrResult[27] |= OrConstant[22];

  04a3e	b8 04 00 00 00	 mov	 eax, 4
  04a43	48 6b c0 1b	 imul	 rax, rax, 27
  04a47	b9 04 00 00 00	 mov	 ecx, 4
  04a4c	48 6b c9 16	 imul	 rcx, rcx, 22
  04a50	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04a57	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04a5a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04a5e	0b c1		 or	 eax, ecx
  04a60	b9 04 00 00 00	 mov	 ecx, 4
  04a65	48 6b c9 1b	 imul	 rcx, rcx, 27
  04a69	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8930 :         OrResult[28] |= OrConstant[14];

  04a6d	b8 04 00 00 00	 mov	 eax, 4
  04a72	48 6b c0 1c	 imul	 rax, rax, 28
  04a76	b9 04 00 00 00	 mov	 ecx, 4
  04a7b	48 6b c9 0e	 imul	 rcx, rcx, 14
  04a7f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04a86	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04a89	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04a8d	0b c1		 or	 eax, ecx
  04a8f	b9 04 00 00 00	 mov	 ecx, 4
  04a94	48 6b c9 1c	 imul	 rcx, rcx, 28
  04a98	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8931 :         OrResult[31] |= OrConstant[23];

  04a9c	b8 04 00 00 00	 mov	 eax, 4
  04aa1	48 6b c0 1f	 imul	 rax, rax, 31
  04aa5	b9 04 00 00 00	 mov	 ecx, 4
  04aaa	48 6b c9 17	 imul	 rcx, rcx, 23
  04aae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04ab5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04ab8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04abc	0b c1		 or	 eax, ecx
  04abe	b9 04 00 00 00	 mov	 ecx, 4
  04ac3	48 6b c9 1f	 imul	 rcx, rcx, 31
  04ac7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN38@gen_csv_si:

; 8932 :     }
; 8933 :     if ((pClock1[4] & 0x80 ) == 0x80)

  04acb	b8 01 00 00 00	 mov	 eax, 1
  04ad0	48 6b c0 04	 imul	 rax, rax, 4
  04ad4	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  04adc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  04ae0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  04ae5	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  04aea	0f 85 63 02 00
	00		 jne	 $LN39@gen_csv_si

; 8934 :     {
; 8935 :         OrResult[0]  |= OrConstant[9];

  04af0	b8 04 00 00 00	 mov	 eax, 4
  04af5	48 6b c0 00	 imul	 rax, rax, 0
  04af9	b9 04 00 00 00	 mov	 ecx, 4
  04afe	48 6b c9 09	 imul	 rcx, rcx, 9
  04b02	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04b09	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04b0c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04b10	0b c1		 or	 eax, ecx
  04b12	b9 04 00 00 00	 mov	 ecx, 4
  04b17	48 6b c9 00	 imul	 rcx, rcx, 0
  04b1b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8936 :         OrResult[2]  |= OrConstant[5];

  04b1f	b8 04 00 00 00	 mov	 eax, 4
  04b24	48 6b c0 02	 imul	 rax, rax, 2
  04b28	b9 04 00 00 00	 mov	 ecx, 4
  04b2d	48 6b c9 05	 imul	 rcx, rcx, 5
  04b31	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04b38	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04b3b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04b3f	0b c1		 or	 eax, ecx
  04b41	b9 04 00 00 00	 mov	 ecx, 4
  04b46	48 6b c9 02	 imul	 rcx, rcx, 2
  04b4a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8937 :         OrResult[5]  |= OrConstant[7];

  04b4e	b8 04 00 00 00	 mov	 eax, 4
  04b53	48 6b c0 05	 imul	 rax, rax, 5
  04b57	b9 04 00 00 00	 mov	 ecx, 4
  04b5c	48 6b c9 07	 imul	 rcx, rcx, 7
  04b60	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04b67	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04b6a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04b6e	0b c1		 or	 eax, ecx
  04b70	b9 04 00 00 00	 mov	 ecx, 4
  04b75	48 6b c9 05	 imul	 rcx, rcx, 5
  04b79	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8938 :         OrResult[8]  |= OrConstant[2];

  04b7d	b8 04 00 00 00	 mov	 eax, 4
  04b82	48 6b c0 08	 imul	 rax, rax, 8
  04b86	b9 04 00 00 00	 mov	 ecx, 4
  04b8b	48 6b c9 02	 imul	 rcx, rcx, 2
  04b8f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04b96	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04b99	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04b9d	0b c1		 or	 eax, ecx
  04b9f	b9 04 00 00 00	 mov	 ecx, 4
  04ba4	48 6b c9 08	 imul	 rcx, rcx, 8
  04ba8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8939 :         OrResult[11] |= OrConstant[10];

  04bac	b8 04 00 00 00	 mov	 eax, 4
  04bb1	48 6b c0 0b	 imul	 rax, rax, 11
  04bb5	b9 04 00 00 00	 mov	 ecx, 4
  04bba	48 6b c9 0a	 imul	 rcx, rcx, 10
  04bbe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04bc5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04bc8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04bcc	0b c1		 or	 eax, ecx
  04bce	b9 04 00 00 00	 mov	 ecx, 4
  04bd3	48 6b c9 0b	 imul	 rcx, rcx, 11
  04bd7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8940 :         OrResult[13] |= OrConstant[2];

  04bdb	b8 04 00 00 00	 mov	 eax, 4
  04be0	48 6b c0 0d	 imul	 rax, rax, 13
  04be4	b9 04 00 00 00	 mov	 ecx, 4
  04be9	48 6b c9 02	 imul	 rcx, rcx, 2
  04bed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04bf4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04bf7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04bfb	0b c1		 or	 eax, ecx
  04bfd	b9 04 00 00 00	 mov	 ecx, 4
  04c02	48 6b c9 0d	 imul	 rcx, rcx, 13
  04c06	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8941 :         OrResult[14] |= OrConstant[1];

  04c0a	b8 04 00 00 00	 mov	 eax, 4
  04c0f	48 6b c0 0e	 imul	 rax, rax, 14
  04c13	b9 04 00 00 00	 mov	 ecx, 4
  04c18	48 6b c9 01	 imul	 rcx, rcx, 1
  04c1c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04c23	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04c26	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04c2a	0b c1		 or	 eax, ecx
  04c2c	b9 04 00 00 00	 mov	 ecx, 4
  04c31	48 6b c9 0e	 imul	 rcx, rcx, 14
  04c35	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8942 :         OrResult[19] |= OrConstant[9];

  04c39	b8 04 00 00 00	 mov	 eax, 4
  04c3e	48 6b c0 13	 imul	 rax, rax, 19
  04c42	b9 04 00 00 00	 mov	 ecx, 4
  04c47	48 6b c9 09	 imul	 rcx, rcx, 9
  04c4b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04c52	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04c55	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04c59	0b c1		 or	 eax, ecx
  04c5b	b9 04 00 00 00	 mov	 ecx, 4
  04c60	48 6b c9 13	 imul	 rcx, rcx, 19
  04c64	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8943 :         OrResult[22] |= OrConstant[3];

  04c68	b8 04 00 00 00	 mov	 eax, 4
  04c6d	48 6b c0 16	 imul	 rax, rax, 22
  04c71	b9 04 00 00 00	 mov	 ecx, 4
  04c76	48 6b c9 03	 imul	 rcx, rcx, 3
  04c7a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04c81	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04c84	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04c88	0b c1		 or	 eax, ecx
  04c8a	b9 04 00 00 00	 mov	 ecx, 4
  04c8f	48 6b c9 16	 imul	 rcx, rcx, 22
  04c93	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8944 :         OrResult[24] |= OrConstant[10];

  04c97	b8 04 00 00 00	 mov	 eax, 4
  04c9c	48 6b c0 18	 imul	 rax, rax, 24
  04ca0	b9 04 00 00 00	 mov	 ecx, 4
  04ca5	48 6b c9 0a	 imul	 rcx, rcx, 10
  04ca9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04cb0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04cb3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04cb7	0b c1		 or	 eax, ecx
  04cb9	b9 04 00 00 00	 mov	 ecx, 4
  04cbe	48 6b c9 18	 imul	 rcx, rcx, 24
  04cc2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8945 :         OrResult[27] |= OrConstant[1];

  04cc6	b8 04 00 00 00	 mov	 eax, 4
  04ccb	48 6b c0 1b	 imul	 rax, rax, 27
  04ccf	b9 04 00 00 00	 mov	 ecx, 4
  04cd4	48 6b c9 01	 imul	 rcx, rcx, 1
  04cd8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04cdf	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04ce2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04ce6	0b c1		 or	 eax, ecx
  04ce8	b9 04 00 00 00	 mov	 ecx, 4
  04ced	48 6b c9 1b	 imul	 rcx, rcx, 27
  04cf1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8946 :         OrResult[29] |= OrConstant[11];

  04cf5	b8 04 00 00 00	 mov	 eax, 4
  04cfa	48 6b c0 1d	 imul	 rax, rax, 29
  04cfe	b9 04 00 00 00	 mov	 ecx, 4
  04d03	48 6b c9 0b	 imul	 rcx, rcx, 11
  04d07	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04d0e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04d11	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04d15	0b c1		 or	 eax, ecx
  04d17	b9 04 00 00 00	 mov	 ecx, 4
  04d1c	48 6b c9 1d	 imul	 rcx, rcx, 29
  04d20	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8947 :         OrResult[31] |= OrConstant[0];

  04d24	b8 04 00 00 00	 mov	 eax, 4
  04d29	48 6b c0 1f	 imul	 rax, rax, 31
  04d2d	b9 04 00 00 00	 mov	 ecx, 4
  04d32	48 6b c9 00	 imul	 rcx, rcx, 0
  04d36	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04d3d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04d40	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04d44	0b c1		 or	 eax, ecx
  04d46	b9 04 00 00 00	 mov	 ecx, 4
  04d4b	48 6b c9 1f	 imul	 rcx, rcx, 31
  04d4f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN39@gen_csv_si:

; 8948 :     }
; 8949 :     if ((pClock1[4] & 0x40 ) == 0x40)

  04d53	b8 01 00 00 00	 mov	 eax, 1
  04d58	48 6b c0 04	 imul	 rax, rax, 4
  04d5c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  04d64	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  04d68	83 e0 40	 and	 eax, 64			; 00000040H
  04d6b	83 f8 40	 cmp	 eax, 64			; 00000040H
  04d6e	0f 85 c1 02 00
	00		 jne	 $LN40@gen_csv_si

; 8950 :     {
; 8951 :         OrResult[0]  |= OrConstant[8];

  04d74	b8 04 00 00 00	 mov	 eax, 4
  04d79	48 6b c0 00	 imul	 rax, rax, 0
  04d7d	b9 04 00 00 00	 mov	 ecx, 4
  04d82	48 6b c9 08	 imul	 rcx, rcx, 8
  04d86	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04d8d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04d90	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04d94	0b c1		 or	 eax, ecx
  04d96	b9 04 00 00 00	 mov	 ecx, 4
  04d9b	48 6b c9 00	 imul	 rcx, rcx, 0
  04d9f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8952 :         OrResult[3]  |= OrConstant[10];

  04da3	b8 04 00 00 00	 mov	 eax, 4
  04da8	48 6b c0 03	 imul	 rax, rax, 3
  04dac	b9 04 00 00 00	 mov	 ecx, 4
  04db1	48 6b c9 0a	 imul	 rcx, rcx, 10
  04db5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04dbc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04dbf	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04dc3	0b c1		 or	 eax, ecx
  04dc5	b9 04 00 00 00	 mov	 ecx, 4
  04dca	48 6b c9 03	 imul	 rcx, rcx, 3
  04dce	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8953 :         OrResult[5]  |= OrConstant[2];

  04dd2	b8 04 00 00 00	 mov	 eax, 4
  04dd7	48 6b c0 05	 imul	 rax, rax, 5
  04ddb	b9 04 00 00 00	 mov	 ecx, 4
  04de0	48 6b c9 02	 imul	 rcx, rcx, 2
  04de4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04deb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04dee	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04df2	0b c1		 or	 eax, ecx
  04df4	b9 04 00 00 00	 mov	 ecx, 4
  04df9	48 6b c9 05	 imul	 rcx, rcx, 5
  04dfd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8954 :         OrResult[6]  |= OrConstant[1];

  04e01	b8 04 00 00 00	 mov	 eax, 4
  04e06	48 6b c0 06	 imul	 rax, rax, 6
  04e0a	b9 04 00 00 00	 mov	 ecx, 4
  04e0f	48 6b c9 01	 imul	 rcx, rcx, 1
  04e13	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04e1a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04e1d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04e21	0b c1		 or	 eax, ecx
  04e23	b9 04 00 00 00	 mov	 ecx, 4
  04e28	48 6b c9 06	 imul	 rcx, rcx, 6
  04e2c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8955 :         OrResult[8]  |= OrConstant[7];

  04e30	b8 04 00 00 00	 mov	 eax, 4
  04e35	48 6b c0 08	 imul	 rax, rax, 8
  04e39	b9 04 00 00 00	 mov	 ecx, 4
  04e3e	48 6b c9 07	 imul	 rcx, rcx, 7
  04e42	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04e49	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04e4c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04e50	0b c1		 or	 eax, ecx
  04e52	b9 04 00 00 00	 mov	 ecx, 4
  04e57	48 6b c9 08	 imul	 rcx, rcx, 8
  04e5b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8956 :         OrResult[11] |= OrConstant[4];

  04e5f	b8 04 00 00 00	 mov	 eax, 4
  04e64	48 6b c0 0b	 imul	 rax, rax, 11
  04e68	b9 04 00 00 00	 mov	 ecx, 4
  04e6d	48 6b c9 04	 imul	 rcx, rcx, 4
  04e71	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04e78	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04e7b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04e7f	0b c1		 or	 eax, ecx
  04e81	b9 04 00 00 00	 mov	 ecx, 4
  04e86	48 6b c9 0b	 imul	 rcx, rcx, 11
  04e8a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8957 :         OrResult[12] |= OrConstant[6];

  04e8e	b8 04 00 00 00	 mov	 eax, 4
  04e93	48 6b c0 0c	 imul	 rax, rax, 12
  04e97	b9 04 00 00 00	 mov	 ecx, 4
  04e9c	48 6b c9 06	 imul	 rcx, rcx, 6
  04ea0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04ea7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04eaa	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04eae	0b c1		 or	 eax, ecx
  04eb0	b9 04 00 00 00	 mov	 ecx, 4
  04eb5	48 6b c9 0c	 imul	 rcx, rcx, 12
  04eb9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8958 :         OrResult[16] |= OrConstant[10];

  04ebd	b8 04 00 00 00	 mov	 eax, 4
  04ec2	48 6b c0 10	 imul	 rax, rax, 16
  04ec6	b9 04 00 00 00	 mov	 ecx, 4
  04ecb	48 6b c9 0a	 imul	 rcx, rcx, 10
  04ecf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04ed6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04ed9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04edd	0b c1		 or	 eax, ecx
  04edf	b9 04 00 00 00	 mov	 ecx, 4
  04ee4	48 6b c9 10	 imul	 rcx, rcx, 16
  04ee8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8959 :         OrResult[19] |= OrConstant[1];

  04eec	b8 04 00 00 00	 mov	 eax, 4
  04ef1	48 6b c0 13	 imul	 rax, rax, 19
  04ef5	b9 04 00 00 00	 mov	 ecx, 4
  04efa	48 6b c9 01	 imul	 rcx, rcx, 1
  04efe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04f05	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04f08	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04f0c	0b c1		 or	 eax, ecx
  04f0e	b9 04 00 00 00	 mov	 ecx, 4
  04f13	48 6b c9 13	 imul	 rcx, rcx, 19
  04f17	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8960 :         OrResult[21] |= OrConstant[11];

  04f1b	b8 04 00 00 00	 mov	 eax, 4
  04f20	48 6b c0 15	 imul	 rax, rax, 21
  04f24	b9 04 00 00 00	 mov	 ecx, 4
  04f29	48 6b c9 0b	 imul	 rcx, rcx, 11
  04f2d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04f34	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04f37	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04f3b	0b c1		 or	 eax, ecx
  04f3d	b9 04 00 00 00	 mov	 ecx, 4
  04f42	48 6b c9 15	 imul	 rcx, rcx, 21
  04f46	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8961 :         OrResult[22] |= OrConstant[9];

  04f4a	b8 04 00 00 00	 mov	 eax, 4
  04f4f	48 6b c0 16	 imul	 rax, rax, 22
  04f53	b9 04 00 00 00	 mov	 ecx, 4
  04f58	48 6b c9 09	 imul	 rcx, rcx, 9
  04f5c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04f63	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04f66	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04f6a	0b c1		 or	 eax, ecx
  04f6c	b9 04 00 00 00	 mov	 ecx, 4
  04f71	48 6b c9 16	 imul	 rcx, rcx, 22
  04f75	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8962 :         OrResult[25] |= OrConstant[3];

  04f79	b8 04 00 00 00	 mov	 eax, 4
  04f7e	48 6b c0 19	 imul	 rax, rax, 25
  04f82	b9 04 00 00 00	 mov	 ecx, 4
  04f87	48 6b c9 03	 imul	 rcx, rcx, 3
  04f8b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04f92	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04f95	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04f99	0b c1		 or	 eax, ecx
  04f9b	b9 04 00 00 00	 mov	 ecx, 4
  04fa0	48 6b c9 19	 imul	 rcx, rcx, 25
  04fa4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8963 :         OrResult[26] |= OrConstant[11];

  04fa8	b8 04 00 00 00	 mov	 eax, 4
  04fad	48 6b c0 1a	 imul	 rax, rax, 26
  04fb1	b9 04 00 00 00	 mov	 ecx, 4
  04fb6	48 6b c9 0b	 imul	 rcx, rcx, 11
  04fba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04fc1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04fc4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04fc8	0b c1		 or	 eax, ecx
  04fca	b9 04 00 00 00	 mov	 ecx, 4
  04fcf	48 6b c9 1a	 imul	 rcx, rcx, 26
  04fd3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8964 :         OrResult[29] |= OrConstant[5];

  04fd7	b8 04 00 00 00	 mov	 eax, 4
  04fdc	48 6b c0 1d	 imul	 rax, rax, 29
  04fe0	b9 04 00 00 00	 mov	 ecx, 4
  04fe5	48 6b c9 05	 imul	 rcx, rcx, 5
  04fe9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  04ff0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  04ff3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  04ff7	0b c1		 or	 eax, ecx
  04ff9	b9 04 00 00 00	 mov	 ecx, 4
  04ffe	48 6b c9 1d	 imul	 rcx, rcx, 29
  05002	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8965 :         OrResult[30] |= OrConstant[2];

  05006	b8 04 00 00 00	 mov	 eax, 4
  0500b	48 6b c0 1e	 imul	 rax, rax, 30
  0500f	b9 04 00 00 00	 mov	 ecx, 4
  05014	48 6b c9 02	 imul	 rcx, rcx, 2
  05018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0501f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05022	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05026	0b c1		 or	 eax, ecx
  05028	b9 04 00 00 00	 mov	 ecx, 4
  0502d	48 6b c9 1e	 imul	 rcx, rcx, 30
  05031	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN40@gen_csv_si:

; 8966 :     }
; 8967 :     if ((pClock1[4] & 0x20 ) == 0x20)

  05035	b8 01 00 00 00	 mov	 eax, 1
  0503a	48 6b c0 04	 imul	 rax, rax, 4
  0503e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  05046	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0504a	83 e0 20	 and	 eax, 32			; 00000020H
  0504d	83 f8 20	 cmp	 eax, 32			; 00000020H
  05050	0f 85 92 02 00
	00		 jne	 $LN41@gen_csv_si

; 8968 :     {
; 8969 :         OrResult[1]  |= OrConstant[9];

  05056	b8 04 00 00 00	 mov	 eax, 4
  0505b	48 6b c0 01	 imul	 rax, rax, 1
  0505f	b9 04 00 00 00	 mov	 ecx, 4
  05064	48 6b c9 09	 imul	 rcx, rcx, 9
  05068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0506f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05072	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05076	0b c1		 or	 eax, ecx
  05078	b9 04 00 00 00	 mov	 ecx, 4
  0507d	48 6b c9 01	 imul	 rcx, rcx, 1
  05081	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8970 :         OrResult[3]  |= OrConstant[4];

  05085	b8 04 00 00 00	 mov	 eax, 4
  0508a	48 6b c0 03	 imul	 rax, rax, 3
  0508e	b9 04 00 00 00	 mov	 ecx, 4
  05093	48 6b c9 04	 imul	 rcx, rcx, 4
  05097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0509e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  050a1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  050a5	0b c1		 or	 eax, ecx
  050a7	b9 04 00 00 00	 mov	 ecx, 4
  050ac	48 6b c9 03	 imul	 rcx, rcx, 3
  050b0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8971 :         OrResult[4]  |= OrConstant[6];

  050b4	b8 04 00 00 00	 mov	 eax, 4
  050b9	48 6b c0 04	 imul	 rax, rax, 4
  050bd	b9 04 00 00 00	 mov	 ecx, 4
  050c2	48 6b c9 06	 imul	 rcx, rcx, 6
  050c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  050cd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  050d0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  050d4	0b c1		 or	 eax, ecx
  050d6	b9 04 00 00 00	 mov	 ecx, 4
  050db	48 6b c9 04	 imul	 rcx, rcx, 4
  050df	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8972 :         OrResult[9]  |= OrConstant[8];

  050e3	b8 04 00 00 00	 mov	 eax, 4
  050e8	48 6b c0 09	 imul	 rax, rax, 9
  050ec	b9 04 00 00 00	 mov	 ecx, 4
  050f1	48 6b c9 08	 imul	 rcx, rcx, 8
  050f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  050fc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  050ff	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05103	0b c1		 or	 eax, ecx
  05105	b9 04 00 00 00	 mov	 ecx, 4
  0510a	48 6b c9 09	 imul	 rcx, rcx, 9
  0510e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8973 :         OrResult[10] |= OrConstant[4];

  05112	b8 04 00 00 00	 mov	 eax, 4
  05117	48 6b c0 0a	 imul	 rax, rax, 10
  0511b	b9 04 00 00 00	 mov	 ecx, 4
  05120	48 6b c9 04	 imul	 rcx, rcx, 4
  05124	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0512b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0512e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05132	0b c1		 or	 eax, ecx
  05134	b9 04 00 00 00	 mov	 ecx, 4
  05139	48 6b c9 0a	 imul	 rcx, rcx, 10
  0513d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8974 :         OrResult[13] |= OrConstant[0];

  05141	b8 04 00 00 00	 mov	 eax, 4
  05146	48 6b c0 0d	 imul	 rax, rax, 13
  0514a	b9 04 00 00 00	 mov	 ecx, 4
  0514f	48 6b c9 00	 imul	 rcx, rcx, 0
  05153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0515a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0515d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05161	0b c1		 or	 eax, ecx
  05163	b9 04 00 00 00	 mov	 ecx, 4
  05168	48 6b c9 0d	 imul	 rcx, rcx, 13
  0516c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8975 :         OrResult[14] |= OrConstant[5];

  05170	b8 04 00 00 00	 mov	 eax, 4
  05175	48 6b c0 0e	 imul	 rax, rax, 14
  05179	b9 04 00 00 00	 mov	 ecx, 4
  0517e	48 6b c9 05	 imul	 rcx, rcx, 5
  05182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05189	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0518c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05190	0b c1		 or	 eax, ecx
  05192	b9 04 00 00 00	 mov	 ecx, 4
  05197	48 6b c9 0e	 imul	 rcx, rcx, 14
  0519b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8976 :         OrResult[17] |= OrConstant[3];

  0519f	b8 04 00 00 00	 mov	 eax, 4
  051a4	48 6b c0 11	 imul	 rax, rax, 17
  051a8	b9 04 00 00 00	 mov	 ecx, 4
  051ad	48 6b c9 03	 imul	 rcx, rcx, 3
  051b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  051b8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  051bb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  051bf	0b c1		 or	 eax, ecx
  051c1	b9 04 00 00 00	 mov	 ecx, 4
  051c6	48 6b c9 11	 imul	 rcx, rcx, 17
  051ca	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8977 :         OrResult[18] |= OrConstant[11];

  051ce	b8 04 00 00 00	 mov	 eax, 4
  051d3	48 6b c0 12	 imul	 rax, rax, 18
  051d7	b9 04 00 00 00	 mov	 ecx, 4
  051dc	48 6b c9 0b	 imul	 rcx, rcx, 11
  051e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  051e7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  051ea	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  051ee	0b c1		 or	 eax, ecx
  051f0	b9 04 00 00 00	 mov	 ecx, 4
  051f5	48 6b c9 12	 imul	 rcx, rcx, 18
  051f9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8978 :         OrResult[21] |= OrConstant[5];

  051fd	b8 04 00 00 00	 mov	 eax, 4
  05202	48 6b c0 15	 imul	 rax, rax, 21
  05206	b9 04 00 00 00	 mov	 ecx, 4
  0520b	48 6b c9 05	 imul	 rcx, rcx, 5
  0520f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05216	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05219	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0521d	0b c1		 or	 eax, ecx
  0521f	b9 04 00 00 00	 mov	 ecx, 4
  05224	48 6b c9 15	 imul	 rcx, rcx, 21
  05228	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8979 :         OrResult[22] |= OrConstant[8];

  0522c	b8 04 00 00 00	 mov	 eax, 4
  05231	48 6b c0 16	 imul	 rax, rax, 22
  05235	b9 04 00 00 00	 mov	 ecx, 4
  0523a	48 6b c9 08	 imul	 rcx, rcx, 8
  0523e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05245	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05248	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0524c	0b c1		 or	 eax, ecx
  0524e	b9 04 00 00 00	 mov	 ecx, 4
  05253	48 6b c9 16	 imul	 rcx, rcx, 22
  05257	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8980 :         OrResult[24] |= OrConstant[0];

  0525b	b8 04 00 00 00	 mov	 eax, 4
  05260	48 6b c0 18	 imul	 rax, rax, 24
  05264	b9 04 00 00 00	 mov	 ecx, 4
  05269	48 6b c9 00	 imul	 rcx, rcx, 0
  0526d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05274	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05277	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0527b	0b c1		 or	 eax, ecx
  0527d	b9 04 00 00 00	 mov	 ecx, 4
  05282	48 6b c9 18	 imul	 rcx, rcx, 24
  05286	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8981 :         OrResult[27] |= OrConstant[6];

  0528a	b8 04 00 00 00	 mov	 eax, 4
  0528f	48 6b c0 1b	 imul	 rax, rax, 27
  05293	b9 04 00 00 00	 mov	 ecx, 4
  05298	48 6b c9 06	 imul	 rcx, rcx, 6
  0529c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  052a3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  052a6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  052aa	0b c1		 or	 eax, ecx
  052ac	b9 04 00 00 00	 mov	 ecx, 4
  052b1	48 6b c9 1b	 imul	 rcx, rcx, 27
  052b5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8982 :         OrResult[30] |= OrConstant[7];

  052b9	b8 04 00 00 00	 mov	 eax, 4
  052be	48 6b c0 1e	 imul	 rax, rax, 30
  052c2	b9 04 00 00 00	 mov	 ecx, 4
  052c7	48 6b c9 07	 imul	 rcx, rcx, 7
  052cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  052d2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  052d5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  052d9	0b c1		 or	 eax, ecx
  052db	b9 04 00 00 00	 mov	 ecx, 4
  052e0	48 6b c9 1e	 imul	 rcx, rcx, 30
  052e4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN41@gen_csv_si:

; 8983 :     }
; 8984 :     if ((pClock1[4] & 0x10 ) == 0x10)

  052e8	b8 01 00 00 00	 mov	 eax, 1
  052ed	48 6b c0 04	 imul	 rax, rax, 4
  052f1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  052f9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  052fd	83 e0 10	 and	 eax, 16
  05300	83 f8 10	 cmp	 eax, 16
  05303	0f 85 63 02 00
	00		 jne	 $LN42@gen_csv_si

; 8985 :     {
; 8986 :         OrResult[1]  |= OrConstant[1];

  05309	b8 04 00 00 00	 mov	 eax, 4
  0530e	48 6b c0 01	 imul	 rax, rax, 1
  05312	b9 04 00 00 00	 mov	 ecx, 4
  05317	48 6b c9 01	 imul	 rcx, rcx, 1
  0531b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05322	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05325	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05329	0b c1		 or	 eax, ecx
  0532b	b9 04 00 00 00	 mov	 ecx, 4
  05330	48 6b c9 01	 imul	 rcx, rcx, 1
  05334	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8987 :         OrResult[2]  |= OrConstant[4];

  05338	b8 04 00 00 00	 mov	 eax, 4
  0533d	48 6b c0 02	 imul	 rax, rax, 2
  05341	b9 04 00 00 00	 mov	 ecx, 4
  05346	48 6b c9 04	 imul	 rcx, rcx, 4
  0534a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05351	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05354	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05358	0b c1		 or	 eax, ecx
  0535a	b9 04 00 00 00	 mov	 ecx, 4
  0535f	48 6b c9 02	 imul	 rcx, rcx, 2
  05363	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8988 :         OrResult[5]  |= OrConstant[0];

  05367	b8 04 00 00 00	 mov	 eax, 4
  0536c	48 6b c0 05	 imul	 rax, rax, 5
  05370	b9 04 00 00 00	 mov	 ecx, 4
  05375	48 6b c9 00	 imul	 rcx, rcx, 0
  05379	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05380	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05383	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05387	0b c1		 or	 eax, ecx
  05389	b9 04 00 00 00	 mov	 ecx, 4
  0538e	48 6b c9 05	 imul	 rcx, rcx, 5
  05392	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8989 :         OrResult[6]  |= OrConstant[5];

  05396	b8 04 00 00 00	 mov	 eax, 4
  0539b	48 6b c0 06	 imul	 rax, rax, 6
  0539f	b9 04 00 00 00	 mov	 ecx, 4
  053a4	48 6b c9 05	 imul	 rcx, rcx, 5
  053a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  053af	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  053b2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  053b6	0b c1		 or	 eax, ecx
  053b8	b9 04 00 00 00	 mov	 ecx, 4
  053bd	48 6b c9 06	 imul	 rcx, rcx, 6
  053c1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8990 :         OrResult[9]  |= OrConstant[7];

  053c5	b8 04 00 00 00	 mov	 eax, 4
  053ca	48 6b c0 09	 imul	 rax, rax, 9
  053ce	b9 04 00 00 00	 mov	 ecx, 4
  053d3	48 6b c9 07	 imul	 rcx, rcx, 7
  053d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  053de	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  053e1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  053e5	0b c1		 or	 eax, ecx
  053e7	b9 04 00 00 00	 mov	 ecx, 4
  053ec	48 6b c9 09	 imul	 rcx, rcx, 9
  053f0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8991 :         OrResult[12] |= OrConstant[2];

  053f4	b8 04 00 00 00	 mov	 eax, 4
  053f9	48 6b c0 0c	 imul	 rax, rax, 12
  053fd	b9 04 00 00 00	 mov	 ecx, 4
  05402	48 6b c9 02	 imul	 rcx, rcx, 2
  05406	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0540d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05410	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05414	0b c1		 or	 eax, ecx
  05416	b9 04 00 00 00	 mov	 ecx, 4
  0541b	48 6b c9 0c	 imul	 rcx, rcx, 12
  0541f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8992 :         OrResult[15] |= OrConstant[10];

  05423	b8 04 00 00 00	 mov	 eax, 4
  05428	48 6b c0 0f	 imul	 rax, rax, 15
  0542c	b9 04 00 00 00	 mov	 ecx, 4
  05431	48 6b c9 0a	 imul	 rcx, rcx, 10
  05435	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0543c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0543f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05443	0b c1		 or	 eax, ecx
  05445	b9 04 00 00 00	 mov	 ecx, 4
  0544a	48 6b c9 0f	 imul	 rcx, rcx, 15
  0544e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8993 :         OrResult[16] |= OrConstant[0];

  05452	b8 04 00 00 00	 mov	 eax, 4
  05457	48 6b c0 10	 imul	 rax, rax, 16
  0545b	b9 04 00 00 00	 mov	 ecx, 4
  05460	48 6b c9 00	 imul	 rcx, rcx, 0
  05464	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0546b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0546e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05472	0b c1		 or	 eax, ecx
  05474	b9 04 00 00 00	 mov	 ecx, 4
  05479	48 6b c9 10	 imul	 rcx, rcx, 16
  0547d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8994 :         OrResult[19] |= OrConstant[6];

  05481	b8 04 00 00 00	 mov	 eax, 4
  05486	48 6b c0 13	 imul	 rax, rax, 19
  0548a	b9 04 00 00 00	 mov	 ecx, 4
  0548f	48 6b c9 06	 imul	 rcx, rcx, 6
  05493	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0549a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0549d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  054a1	0b c1		 or	 eax, ecx
  054a3	b9 04 00 00 00	 mov	 ecx, 4
  054a8	48 6b c9 13	 imul	 rcx, rcx, 19
  054ac	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8995 :         OrResult[23] |= OrConstant[9];

  054b0	b8 04 00 00 00	 mov	 eax, 4
  054b5	48 6b c0 17	 imul	 rax, rax, 23
  054b9	b9 04 00 00 00	 mov	 ecx, 4
  054be	48 6b c9 09	 imul	 rcx, rcx, 9
  054c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  054c9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  054cc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  054d0	0b c1		 or	 eax, ecx
  054d2	b9 04 00 00 00	 mov	 ecx, 4
  054d7	48 6b c9 17	 imul	 rcx, rcx, 23
  054db	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8996 :         OrResult[26] |= OrConstant[3];

  054df	b8 04 00 00 00	 mov	 eax, 4
  054e4	48 6b c0 1a	 imul	 rax, rax, 26
  054e8	b9 04 00 00 00	 mov	 ecx, 4
  054ed	48 6b c9 03	 imul	 rcx, rcx, 3
  054f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  054f8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  054fb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  054ff	0b c1		 or	 eax, ecx
  05501	b9 04 00 00 00	 mov	 ecx, 4
  05506	48 6b c9 1a	 imul	 rcx, rcx, 26
  0550a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8997 :         OrResult[28] |= OrConstant[10];

  0550e	b8 04 00 00 00	 mov	 eax, 4
  05513	48 6b c0 1c	 imul	 rax, rax, 28
  05517	b9 04 00 00 00	 mov	 ecx, 4
  0551c	48 6b c9 0a	 imul	 rcx, rcx, 10
  05520	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05527	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0552a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0552e	0b c1		 or	 eax, ecx
  05530	b9 04 00 00 00	 mov	 ecx, 4
  05535	48 6b c9 1c	 imul	 rcx, rcx, 28
  05539	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 8998 :         OrResult[31] |= OrConstant[8];

  0553d	b8 04 00 00 00	 mov	 eax, 4
  05542	48 6b c0 1f	 imul	 rax, rax, 31
  05546	b9 04 00 00 00	 mov	 ecx, 4
  0554b	48 6b c9 08	 imul	 rcx, rcx, 8
  0554f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05556	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05559	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0555d	0b c1		 or	 eax, ecx
  0555f	b9 04 00 00 00	 mov	 ecx, 4
  05564	48 6b c9 1f	 imul	 rcx, rcx, 31
  05568	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN42@gen_csv_si:

; 8999 :     }
; 9000 :     if ((pClock1[4] & 0x08 ) == 0x08)

  0556c	b8 01 00 00 00	 mov	 eax, 1
  05571	48 6b c0 04	 imul	 rax, rax, 4
  05575	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0557d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  05581	83 e0 08	 and	 eax, 8
  05584	83 f8 08	 cmp	 eax, 8
  05587	0f 85 c1 02 00
	00		 jne	 $LN43@gen_csv_si

; 9001 :     {
; 9002 :         OrResult[1]  |= OrConstant[17];

  0558d	b8 04 00 00 00	 mov	 eax, 4
  05592	48 6b c0 01	 imul	 rax, rax, 1
  05596	b9 04 00 00 00	 mov	 ecx, 4
  0559b	48 6b c9 11	 imul	 rcx, rcx, 17
  0559f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  055a6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  055a9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  055ad	0b c1		 or	 eax, ecx
  055af	b9 04 00 00 00	 mov	 ecx, 4
  055b4	48 6b c9 01	 imul	 rcx, rcx, 1
  055b8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9003 :         OrResult[2]  |= OrConstant[19];

  055bc	b8 04 00 00 00	 mov	 eax, 4
  055c1	48 6b c0 02	 imul	 rax, rax, 2
  055c5	b9 04 00 00 00	 mov	 ecx, 4
  055ca	48 6b c9 13	 imul	 rcx, rcx, 19
  055ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  055d5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  055d8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  055dc	0b c1		 or	 eax, ecx
  055de	b9 04 00 00 00	 mov	 ecx, 4
  055e3	48 6b c9 02	 imul	 rcx, rcx, 2
  055e7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9004 :         OrResult[5]  |= OrConstant[14];

  055eb	b8 04 00 00 00	 mov	 eax, 4
  055f0	48 6b c0 05	 imul	 rax, rax, 5
  055f4	b9 04 00 00 00	 mov	 ecx, 4
  055f9	48 6b c9 0e	 imul	 rcx, rcx, 14
  055fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05604	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05607	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0560b	0b c1		 or	 eax, ecx
  0560d	b9 04 00 00 00	 mov	 ecx, 4
  05612	48 6b c9 05	 imul	 rcx, rcx, 5
  05616	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9005 :         OrResult[6]  |= OrConstant[23];

  0561a	b8 04 00 00 00	 mov	 eax, 4
  0561f	48 6b c0 06	 imul	 rax, rax, 6
  05623	b9 04 00 00 00	 mov	 ecx, 4
  05628	48 6b c9 17	 imul	 rcx, rcx, 23
  0562c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05633	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05636	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0563a	0b c1		 or	 eax, ecx
  0563c	b9 04 00 00 00	 mov	 ecx, 4
  05641	48 6b c9 06	 imul	 rcx, rcx, 6
  05645	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9006 :         OrResult[8]  |= OrConstant[17];

  05649	b8 04 00 00 00	 mov	 eax, 4
  0564e	48 6b c0 08	 imul	 rax, rax, 8
  05652	b9 04 00 00 00	 mov	 ecx, 4
  05657	48 6b c9 11	 imul	 rcx, rcx, 17
  0565b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05662	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05665	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05669	0b c1		 or	 eax, ecx
  0566b	b9 04 00 00 00	 mov	 ecx, 4
  05670	48 6b c9 08	 imul	 rcx, rcx, 8
  05674	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9007 :         OrResult[11] |= OrConstant[22];

  05678	b8 04 00 00 00	 mov	 eax, 4
  0567d	48 6b c0 0b	 imul	 rax, rax, 11
  05681	b9 04 00 00 00	 mov	 ecx, 4
  05686	48 6b c9 16	 imul	 rcx, rcx, 22
  0568a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05691	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05694	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05698	0b c1		 or	 eax, ecx
  0569a	b9 04 00 00 00	 mov	 ecx, 4
  0569f	48 6b c9 0b	 imul	 rcx, rcx, 11
  056a3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9008 :         OrResult[12] |= OrConstant[14];

  056a7	b8 04 00 00 00	 mov	 eax, 4
  056ac	48 6b c0 0c	 imul	 rax, rax, 12
  056b0	b9 04 00 00 00	 mov	 ecx, 4
  056b5	48 6b c9 0e	 imul	 rcx, rcx, 14
  056b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  056c0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  056c3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  056c7	0b c1		 or	 eax, ecx
  056c9	b9 04 00 00 00	 mov	 ecx, 4
  056ce	48 6b c9 0c	 imul	 rcx, rcx, 12
  056d2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9009 :         OrResult[15] |= OrConstant[16];

  056d6	b8 04 00 00 00	 mov	 eax, 4
  056db	48 6b c0 0f	 imul	 rax, rax, 15
  056df	b9 04 00 00 00	 mov	 ecx, 4
  056e4	48 6b c9 10	 imul	 rcx, rcx, 16
  056e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  056ef	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  056f2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  056f6	0b c1		 or	 eax, ecx
  056f8	b9 04 00 00 00	 mov	 ecx, 4
  056fd	48 6b c9 0f	 imul	 rcx, rcx, 15
  05701	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9010 :         OrResult[16] |= OrConstant[22];

  05705	b8 04 00 00 00	 mov	 eax, 4
  0570a	48 6b c0 10	 imul	 rax, rax, 16
  0570e	b9 04 00 00 00	 mov	 ecx, 4
  05713	48 6b c9 16	 imul	 rcx, rcx, 22
  05717	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0571e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05721	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05725	0b c1		 or	 eax, ecx
  05727	b9 04 00 00 00	 mov	 ecx, 4
  0572c	48 6b c9 10	 imul	 rcx, rcx, 16
  05730	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9011 :         OrResult[19] |= OrConstant[21];

  05734	b8 04 00 00 00	 mov	 eax, 4
  05739	48 6b c0 13	 imul	 rax, rax, 19
  0573d	b9 04 00 00 00	 mov	 ecx, 4
  05742	48 6b c9 15	 imul	 rcx, rcx, 21
  05746	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0574d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05750	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05754	0b c1		 or	 eax, ecx
  05756	b9 04 00 00 00	 mov	 ecx, 4
  0575b	48 6b c9 13	 imul	 rcx, rcx, 19
  0575f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9012 :         OrResult[23] |= OrConstant[13];

  05763	b8 04 00 00 00	 mov	 eax, 4
  05768	48 6b c0 17	 imul	 rax, rax, 23
  0576c	b9 04 00 00 00	 mov	 ecx, 4
  05771	48 6b c9 0d	 imul	 rcx, rcx, 13
  05775	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0577c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0577f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05783	0b c1		 or	 eax, ecx
  05785	b9 04 00 00 00	 mov	 ecx, 4
  0578a	48 6b c9 17	 imul	 rcx, rcx, 23
  0578e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9013 :         OrResult[25] |= OrConstant[19];

  05792	b8 04 00 00 00	 mov	 eax, 4
  05797	48 6b c0 19	 imul	 rax, rax, 25
  0579b	b9 04 00 00 00	 mov	 ecx, 4
  057a0	48 6b c9 13	 imul	 rcx, rcx, 19
  057a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  057ab	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  057ae	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  057b2	0b c1		 or	 eax, ecx
  057b4	b9 04 00 00 00	 mov	 ecx, 4
  057b9	48 6b c9 19	 imul	 rcx, rcx, 25
  057bd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9014 :         OrResult[26] |= OrConstant[18];

  057c1	b8 04 00 00 00	 mov	 eax, 4
  057c6	48 6b c0 1a	 imul	 rax, rax, 26
  057ca	b9 04 00 00 00	 mov	 ecx, 4
  057cf	48 6b c9 12	 imul	 rcx, rcx, 18
  057d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  057da	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  057dd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  057e1	0b c1		 or	 eax, ecx
  057e3	b9 04 00 00 00	 mov	 ecx, 4
  057e8	48 6b c9 1a	 imul	 rcx, rcx, 26
  057ec	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9015 :         OrResult[29] |= OrConstant[18];

  057f0	b8 04 00 00 00	 mov	 eax, 4
  057f5	48 6b c0 1d	 imul	 rax, rax, 29
  057f9	b9 04 00 00 00	 mov	 ecx, 4
  057fe	48 6b c9 12	 imul	 rcx, rcx, 18
  05802	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05809	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0580c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05810	0b c1		 or	 eax, ecx
  05812	b9 04 00 00 00	 mov	 ecx, 4
  05817	48 6b c9 1d	 imul	 rcx, rcx, 29
  0581b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9016 :         OrResult[30] |= OrConstant[16];

  0581f	b8 04 00 00 00	 mov	 eax, 4
  05824	48 6b c0 1e	 imul	 rax, rax, 30
  05828	b9 04 00 00 00	 mov	 ecx, 4
  0582d	48 6b c9 10	 imul	 rcx, rcx, 16
  05831	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05838	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0583b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0583f	0b c1		 or	 eax, ecx
  05841	b9 04 00 00 00	 mov	 ecx, 4
  05846	48 6b c9 1e	 imul	 rcx, rcx, 30
  0584a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN43@gen_csv_si:

; 9017 :     }
; 9018 :     if ((pClock1[4] & 0x04 ) == 0x04)

  0584e	b8 01 00 00 00	 mov	 eax, 1
  05853	48 6b c0 04	 imul	 rax, rax, 4
  05857	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0585f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  05863	83 e0 04	 and	 eax, 4
  05866	83 f8 04	 cmp	 eax, 4
  05869	0f 85 63 02 00
	00		 jne	 $LN44@gen_csv_si

; 9019 :     {
; 9020 :         OrResult[1]  |= OrConstant[13];

  0586f	b8 04 00 00 00	 mov	 eax, 4
  05874	48 6b c0 01	 imul	 rax, rax, 1
  05878	b9 04 00 00 00	 mov	 ecx, 4
  0587d	48 6b c9 0d	 imul	 rcx, rcx, 13
  05881	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05888	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0588b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0588f	0b c1		 or	 eax, ecx
  05891	b9 04 00 00 00	 mov	 ecx, 4
  05896	48 6b c9 01	 imul	 rcx, rcx, 1
  0589a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9021 :         OrResult[2]  |= OrConstant[12];

  0589e	b8 04 00 00 00	 mov	 eax, 4
  058a3	48 6b c0 02	 imul	 rax, rax, 2
  058a7	b9 04 00 00 00	 mov	 ecx, 4
  058ac	48 6b c9 0c	 imul	 rcx, rcx, 12
  058b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  058b7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  058ba	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  058be	0b c1		 or	 eax, ecx
  058c0	b9 04 00 00 00	 mov	 ecx, 4
  058c5	48 6b c9 02	 imul	 rcx, rcx, 2
  058c9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9022 :         OrResult[7]  |= OrConstant[15];

  058cd	b8 04 00 00 00	 mov	 eax, 4
  058d2	48 6b c0 07	 imul	 rax, rax, 7
  058d6	b9 04 00 00 00	 mov	 ecx, 4
  058db	48 6b c9 0f	 imul	 rcx, rcx, 15
  058df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  058e6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  058e9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  058ed	0b c1		 or	 eax, ecx
  058ef	b9 04 00 00 00	 mov	 ecx, 4
  058f4	48 6b c9 07	 imul	 rcx, rcx, 7
  058f8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9023 :         OrResult[8]  |= OrConstant[16];

  058fc	b8 04 00 00 00	 mov	 eax, 4
  05901	48 6b c0 08	 imul	 rax, rax, 8
  05905	b9 04 00 00 00	 mov	 ecx, 4
  0590a	48 6b c9 10	 imul	 rcx, rcx, 16
  0590e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05915	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05918	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0591c	0b c1		 or	 eax, ecx
  0591e	b9 04 00 00 00	 mov	 ecx, 4
  05923	48 6b c9 08	 imul	 rcx, rcx, 8
  05927	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9024 :         OrResult[10] |= OrConstant[19];

  0592b	b8 04 00 00 00	 mov	 eax, 4
  05930	48 6b c0 0a	 imul	 rax, rax, 10
  05934	b9 04 00 00 00	 mov	 ecx, 4
  05939	48 6b c9 13	 imul	 rcx, rcx, 19
  0593d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05944	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05947	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0594b	0b c1		 or	 eax, ecx
  0594d	b9 04 00 00 00	 mov	 ecx, 4
  05952	48 6b c9 0a	 imul	 rcx, rcx, 10
  05956	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9025 :         OrResult[13] |= OrConstant[14];

  0595a	b8 04 00 00 00	 mov	 eax, 4
  0595f	48 6b c0 0d	 imul	 rax, rax, 13
  05963	b9 04 00 00 00	 mov	 ecx, 4
  05968	48 6b c9 0e	 imul	 rcx, rcx, 14
  0596c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05973	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05976	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0597a	0b c1		 or	 eax, ecx
  0597c	b9 04 00 00 00	 mov	 ecx, 4
  05981	48 6b c9 0d	 imul	 rcx, rcx, 13
  05985	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9026 :         OrResult[14] |= OrConstant[23];

  05989	b8 04 00 00 00	 mov	 eax, 4
  0598e	48 6b c0 0e	 imul	 rax, rax, 14
  05992	b9 04 00 00 00	 mov	 ecx, 4
  05997	48 6b c9 17	 imul	 rcx, rcx, 23
  0599b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  059a2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  059a5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  059a9	0b c1		 or	 eax, ecx
  059ab	b9 04 00 00 00	 mov	 ecx, 4
  059b0	48 6b c9 0e	 imul	 rcx, rcx, 14
  059b4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9027 :         OrResult[18] |= OrConstant[21];

  059b8	b8 04 00 00 00	 mov	 eax, 4
  059bd	48 6b c0 12	 imul	 rax, rax, 18
  059c1	b9 04 00 00 00	 mov	 ecx, 4
  059c6	48 6b c9 15	 imul	 rcx, rcx, 21
  059ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  059d1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  059d4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  059d8	0b c1		 or	 eax, ecx
  059da	b9 04 00 00 00	 mov	 ecx, 4
  059df	48 6b c9 12	 imul	 rcx, rcx, 18
  059e3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9028 :         OrResult[21] |= OrConstant[12];

  059e7	b8 04 00 00 00	 mov	 eax, 4
  059ec	48 6b c0 15	 imul	 rax, rax, 21
  059f0	b9 04 00 00 00	 mov	 ecx, 4
  059f5	48 6b c9 0c	 imul	 rcx, rcx, 12
  059f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05a00	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05a03	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05a07	0b c1		 or	 eax, ecx
  05a09	b9 04 00 00 00	 mov	 ecx, 4
  05a0e	48 6b c9 15	 imul	 rcx, rcx, 21
  05a12	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9029 :         OrResult[23] |= OrConstant[23];

  05a16	b8 04 00 00 00	 mov	 eax, 4
  05a1b	48 6b c0 17	 imul	 rax, rax, 23
  05a1f	b9 04 00 00 00	 mov	 ecx, 4
  05a24	48 6b c9 17	 imul	 rcx, rcx, 23
  05a28	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05a2f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05a32	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05a36	0b c1		 or	 eax, ecx
  05a38	b9 04 00 00 00	 mov	 ecx, 4
  05a3d	48 6b c9 17	 imul	 rcx, rcx, 23
  05a41	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9030 :         OrResult[24] |= OrConstant[22];

  05a45	b8 04 00 00 00	 mov	 eax, 4
  05a4a	48 6b c0 18	 imul	 rax, rax, 24
  05a4e	b9 04 00 00 00	 mov	 ecx, 4
  05a53	48 6b c9 16	 imul	 rcx, rcx, 22
  05a57	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05a5e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05a61	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05a65	0b c1		 or	 eax, ecx
  05a67	b9 04 00 00 00	 mov	 ecx, 4
  05a6c	48 6b c9 18	 imul	 rcx, rcx, 24
  05a70	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9031 :         OrResult[27] |= OrConstant[21];

  05a74	b8 04 00 00 00	 mov	 eax, 4
  05a79	48 6b c0 1b	 imul	 rax, rax, 27
  05a7d	b9 04 00 00 00	 mov	 ecx, 4
  05a82	48 6b c9 15	 imul	 rcx, rcx, 21
  05a86	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05a8d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05a90	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05a94	0b c1		 or	 eax, ecx
  05a96	b9 04 00 00 00	 mov	 ecx, 4
  05a9b	48 6b c9 1b	 imul	 rcx, rcx, 27
  05a9f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9032 :         OrResult[30] |= OrConstant[20];

  05aa3	b8 04 00 00 00	 mov	 eax, 4
  05aa8	48 6b c0 1e	 imul	 rax, rax, 30
  05aac	b9 04 00 00 00	 mov	 ecx, 4
  05ab1	48 6b c9 14	 imul	 rcx, rcx, 20
  05ab5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05abc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05abf	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05ac3	0b c1		 or	 eax, ecx
  05ac5	b9 04 00 00 00	 mov	 ecx, 4
  05aca	48 6b c9 1e	 imul	 rcx, rcx, 30
  05ace	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN44@gen_csv_si:

; 9033 :     }
; 9034 :     if ((pClock1[4] & 0x02 ) == 0x02)

  05ad2	b8 01 00 00 00	 mov	 eax, 1
  05ad7	48 6b c0 04	 imul	 rax, rax, 4
  05adb	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  05ae3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  05ae7	83 e0 02	 and	 eax, 2
  05aea	83 f8 02	 cmp	 eax, 2
  05aed	0f 85 63 02 00
	00		 jne	 $LN45@gen_csv_si

; 9035 :     {
; 9036 :         OrResult[1]  |= OrConstant[23];

  05af3	b8 04 00 00 00	 mov	 eax, 4
  05af8	48 6b c0 01	 imul	 rax, rax, 1
  05afc	b9 04 00 00 00	 mov	 ecx, 4
  05b01	48 6b c9 17	 imul	 rcx, rcx, 23
  05b05	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05b0c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05b0f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05b13	0b c1		 or	 eax, ecx
  05b15	b9 04 00 00 00	 mov	 ecx, 4
  05b1a	48 6b c9 01	 imul	 rcx, rcx, 1
  05b1e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9037 :         OrResult[3]  |= OrConstant[16];

  05b22	b8 04 00 00 00	 mov	 eax, 4
  05b27	48 6b c0 03	 imul	 rax, rax, 3
  05b2b	b9 04 00 00 00	 mov	 ecx, 4
  05b30	48 6b c9 10	 imul	 rcx, rcx, 16
  05b34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05b3b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05b3e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05b42	0b c1		 or	 eax, ecx
  05b44	b9 04 00 00 00	 mov	 ecx, 4
  05b49	48 6b c9 03	 imul	 rcx, rcx, 3
  05b4d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9038 :         OrResult[6]  |= OrConstant[15];

  05b51	b8 04 00 00 00	 mov	 eax, 4
  05b56	48 6b c0 06	 imul	 rax, rax, 6
  05b5a	b9 04 00 00 00	 mov	 ecx, 4
  05b5f	48 6b c9 0f	 imul	 rcx, rcx, 15
  05b63	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05b6a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05b6d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05b71	0b c1		 or	 eax, ecx
  05b73	b9 04 00 00 00	 mov	 ecx, 4
  05b78	48 6b c9 06	 imul	 rcx, rcx, 6
  05b7c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9039 :         OrResult[8]  |= OrConstant[20];

  05b80	b8 04 00 00 00	 mov	 eax, 4
  05b85	48 6b c0 08	 imul	 rax, rax, 8
  05b89	b9 04 00 00 00	 mov	 ecx, 4
  05b8e	48 6b c9 14	 imul	 rcx, rcx, 20
  05b92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05b99	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05b9c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05ba0	0b c1		 or	 eax, ecx
  05ba2	b9 04 00 00 00	 mov	 ecx, 4
  05ba7	48 6b c9 08	 imul	 rcx, rcx, 8
  05bab	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9040 :         OrResult[10] |= OrConstant[12];

  05baf	b8 04 00 00 00	 mov	 eax, 4
  05bb4	48 6b c0 0a	 imul	 rax, rax, 10
  05bb8	b9 04 00 00 00	 mov	 ecx, 4
  05bbd	48 6b c9 0c	 imul	 rcx, rcx, 12
  05bc1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05bc8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05bcb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05bcf	0b c1		 or	 eax, ecx
  05bd1	b9 04 00 00 00	 mov	 ecx, 4
  05bd6	48 6b c9 0a	 imul	 rcx, rcx, 10
  05bda	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9041 :         OrResult[15] |= OrConstant[15];

  05bde	b8 04 00 00 00	 mov	 eax, 4
  05be3	48 6b c0 0f	 imul	 rax, rax, 15
  05be7	b9 04 00 00 00	 mov	 ecx, 4
  05bec	48 6b c9 0f	 imul	 rcx, rcx, 15
  05bf0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05bf7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05bfa	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05bfe	0b c1		 or	 eax, ecx
  05c00	b9 04 00 00 00	 mov	 ecx, 4
  05c05	48 6b c9 0f	 imul	 rcx, rcx, 15
  05c09	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9042 :         OrResult[17] |= OrConstant[18];

  05c0d	b8 04 00 00 00	 mov	 eax, 4
  05c12	48 6b c0 11	 imul	 rax, rax, 17
  05c16	b9 04 00 00 00	 mov	 ecx, 4
  05c1b	48 6b c9 12	 imul	 rcx, rcx, 18
  05c1f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05c26	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05c29	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05c2d	0b c1		 or	 eax, ecx
  05c2f	b9 04 00 00 00	 mov	 ecx, 4
  05c34	48 6b c9 11	 imul	 rcx, rcx, 17
  05c38	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9043 :         OrResult[19] |= OrConstant[17];

  05c3c	b8 04 00 00 00	 mov	 eax, 4
  05c41	48 6b c0 13	 imul	 rax, rax, 19
  05c45	b9 04 00 00 00	 mov	 ecx, 4
  05c4a	48 6b c9 11	 imul	 rcx, rcx, 17
  05c4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05c55	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05c58	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05c5c	0b c1		 or	 eax, ecx
  05c5e	b9 04 00 00 00	 mov	 ecx, 4
  05c63	48 6b c9 13	 imul	 rcx, rcx, 19
  05c67	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9044 :         OrResult[21] |= OrConstant[20];

  05c6b	b8 04 00 00 00	 mov	 eax, 4
  05c70	48 6b c0 15	 imul	 rax, rax, 21
  05c74	b9 04 00 00 00	 mov	 ecx, 4
  05c79	48 6b c9 14	 imul	 rcx, rcx, 20
  05c7d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05c84	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05c87	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05c8b	0b c1		 or	 eax, ecx
  05c8d	b9 04 00 00 00	 mov	 ecx, 4
  05c92	48 6b c9 15	 imul	 rcx, rcx, 21
  05c96	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9045 :         OrResult[22] |= OrConstant[13];

  05c9a	b8 04 00 00 00	 mov	 eax, 4
  05c9f	48 6b c0 16	 imul	 rax, rax, 22
  05ca3	b9 04 00 00 00	 mov	 ecx, 4
  05ca8	48 6b c9 0d	 imul	 rcx, rcx, 13
  05cac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05cb3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05cb6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05cba	0b c1		 or	 eax, ecx
  05cbc	b9 04 00 00 00	 mov	 ecx, 4
  05cc1	48 6b c9 16	 imul	 rcx, rcx, 22
  05cc5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9046 :         OrResult[26] |= OrConstant[21];

  05cc9	b8 04 00 00 00	 mov	 eax, 4
  05cce	48 6b c0 1a	 imul	 rax, rax, 26
  05cd2	b9 04 00 00 00	 mov	 ecx, 4
  05cd7	48 6b c9 15	 imul	 rcx, rcx, 21
  05cdb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05ce2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05ce5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05ce9	0b c1		 or	 eax, ecx
  05ceb	b9 04 00 00 00	 mov	 ecx, 4
  05cf0	48 6b c9 1a	 imul	 rcx, rcx, 26
  05cf4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9047 :         OrResult[29] |= OrConstant[12];

  05cf8	b8 04 00 00 00	 mov	 eax, 4
  05cfd	48 6b c0 1d	 imul	 rax, rax, 29
  05d01	b9 04 00 00 00	 mov	 ecx, 4
  05d06	48 6b c9 0c	 imul	 rcx, rcx, 12
  05d0a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05d11	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05d14	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05d18	0b c1		 or	 eax, ecx
  05d1a	b9 04 00 00 00	 mov	 ecx, 4
  05d1f	48 6b c9 1d	 imul	 rcx, rcx, 29
  05d23	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9048 :         OrResult[30] |= OrConstant[14];

  05d27	b8 04 00 00 00	 mov	 eax, 4
  05d2c	48 6b c0 1e	 imul	 rax, rax, 30
  05d30	b9 04 00 00 00	 mov	 ecx, 4
  05d35	48 6b c9 0e	 imul	 rcx, rcx, 14
  05d39	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05d40	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05d43	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05d47	0b c1		 or	 eax, ecx
  05d49	b9 04 00 00 00	 mov	 ecx, 4
  05d4e	48 6b c9 1e	 imul	 rcx, rcx, 30
  05d52	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN45@gen_csv_si:

; 9049 :     }
; 9050 :     if ((pClock1[5] & 0x80 ) == 0x80)

  05d56	b8 01 00 00 00	 mov	 eax, 1
  05d5b	48 6b c0 05	 imul	 rax, rax, 5
  05d5f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  05d67	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  05d6b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  05d70	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  05d75	0f 85 c1 02 00
	00		 jne	 $LN46@gen_csv_si

; 9051 :     {
; 9052 :         OrResult[1]  |= OrConstant[0];

  05d7b	b8 04 00 00 00	 mov	 eax, 4
  05d80	48 6b c0 01	 imul	 rax, rax, 1
  05d84	b9 04 00 00 00	 mov	 ecx, 4
  05d89	48 6b c9 00	 imul	 rcx, rcx, 0
  05d8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05d94	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05d97	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05d9b	0b c1		 or	 eax, ecx
  05d9d	b9 04 00 00 00	 mov	 ecx, 4
  05da2	48 6b c9 01	 imul	 rcx, rcx, 1
  05da6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9053 :         OrResult[2]  |= OrConstant[9];

  05daa	b8 04 00 00 00	 mov	 eax, 4
  05daf	48 6b c0 02	 imul	 rax, rax, 2
  05db3	b9 04 00 00 00	 mov	 ecx, 4
  05db8	48 6b c9 09	 imul	 rcx, rcx, 9
  05dbc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05dc3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05dc6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05dca	0b c1		 or	 eax, ecx
  05dcc	b9 04 00 00 00	 mov	 ecx, 4
  05dd1	48 6b c9 02	 imul	 rcx, rcx, 2
  05dd5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9054 :         OrResult[5]  |= OrConstant[3];

  05dd9	b8 04 00 00 00	 mov	 eax, 4
  05dde	48 6b c0 05	 imul	 rax, rax, 5
  05de2	b9 04 00 00 00	 mov	 ecx, 4
  05de7	48 6b c9 03	 imul	 rcx, rcx, 3
  05deb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05df2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05df5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05df9	0b c1		 or	 eax, ecx
  05dfb	b9 04 00 00 00	 mov	 ecx, 4
  05e00	48 6b c9 05	 imul	 rcx, rcx, 5
  05e04	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9055 :         OrResult[6]  |= OrConstant[11];

  05e08	b8 04 00 00 00	 mov	 eax, 4
  05e0d	48 6b c0 06	 imul	 rax, rax, 6
  05e11	b9 04 00 00 00	 mov	 ecx, 4
  05e16	48 6b c9 0b	 imul	 rcx, rcx, 11
  05e1a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05e21	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05e24	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05e28	0b c1		 or	 eax, ecx
  05e2a	b9 04 00 00 00	 mov	 ecx, 4
  05e2f	48 6b c9 06	 imul	 rcx, rcx, 6
  05e33	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9056 :         OrResult[9]  |= OrConstant[5];

  05e37	b8 04 00 00 00	 mov	 eax, 4
  05e3c	48 6b c0 09	 imul	 rax, rax, 9
  05e40	b9 04 00 00 00	 mov	 ecx, 4
  05e45	48 6b c9 05	 imul	 rcx, rcx, 5
  05e49	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05e50	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05e53	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05e57	0b c1		 or	 eax, ecx
  05e59	b9 04 00 00 00	 mov	 ecx, 4
  05e5e	48 6b c9 09	 imul	 rcx, rcx, 9
  05e62	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9057 :         OrResult[10] |= OrConstant[8];

  05e66	b8 04 00 00 00	 mov	 eax, 4
  05e6b	48 6b c0 0a	 imul	 rax, rax, 10
  05e6f	b9 04 00 00 00	 mov	 ecx, 4
  05e74	48 6b c9 08	 imul	 rcx, rcx, 8
  05e78	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05e7f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05e82	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05e86	0b c1		 or	 eax, ecx
  05e88	b9 04 00 00 00	 mov	 ecx, 4
  05e8d	48 6b c9 0a	 imul	 rcx, rcx, 10
  05e91	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9058 :         OrResult[12] |= OrConstant[0];

  05e95	b8 04 00 00 00	 mov	 eax, 4
  05e9a	48 6b c0 0c	 imul	 rax, rax, 12
  05e9e	b9 04 00 00 00	 mov	 ecx, 4
  05ea3	48 6b c9 00	 imul	 rcx, rcx, 0
  05ea7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05eae	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05eb1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05eb5	0b c1		 or	 eax, ecx
  05eb7	b9 04 00 00 00	 mov	 ecx, 4
  05ebc	48 6b c9 0c	 imul	 rcx, rcx, 12
  05ec0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9059 :         OrResult[15] |= OrConstant[6];

  05ec4	b8 04 00 00 00	 mov	 eax, 4
  05ec9	48 6b c0 0f	 imul	 rax, rax, 15
  05ecd	b9 04 00 00 00	 mov	 ecx, 4
  05ed2	48 6b c9 06	 imul	 rcx, rcx, 6
  05ed6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05edd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05ee0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05ee4	0b c1		 or	 eax, ecx
  05ee6	b9 04 00 00 00	 mov	 ecx, 4
  05eeb	48 6b c9 0f	 imul	 rcx, rcx, 15
  05eef	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9060 :         OrResult[16] |= OrConstant[1];

  05ef3	b8 04 00 00 00	 mov	 eax, 4
  05ef8	48 6b c0 10	 imul	 rax, rax, 16
  05efc	b9 04 00 00 00	 mov	 ecx, 4
  05f01	48 6b c9 01	 imul	 rcx, rcx, 1
  05f05	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05f0c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05f0f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05f13	0b c1		 or	 eax, ecx
  05f15	b9 04 00 00 00	 mov	 ecx, 4
  05f1a	48 6b c9 10	 imul	 rcx, rcx, 16
  05f1e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9061 :         OrResult[18] |= OrConstant[7];

  05f22	b8 04 00 00 00	 mov	 eax, 4
  05f27	48 6b c0 12	 imul	 rax, rax, 18
  05f2b	b9 04 00 00 00	 mov	 ecx, 4
  05f30	48 6b c9 07	 imul	 rcx, rcx, 7
  05f34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05f3b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05f3e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05f42	0b c1		 or	 eax, ecx
  05f44	b9 04 00 00 00	 mov	 ecx, 4
  05f49	48 6b c9 12	 imul	 rcx, rcx, 18
  05f4d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9062 :         OrResult[21] |= OrConstant[4];

  05f51	b8 04 00 00 00	 mov	 eax, 4
  05f56	48 6b c0 15	 imul	 rax, rax, 21
  05f5a	b9 04 00 00 00	 mov	 ecx, 4
  05f5f	48 6b c9 04	 imul	 rcx, rcx, 4
  05f63	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05f6a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05f6d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05f71	0b c1		 or	 eax, ecx
  05f73	b9 04 00 00 00	 mov	 ecx, 4
  05f78	48 6b c9 15	 imul	 rcx, rcx, 21
  05f7c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9063 :         OrResult[22] |= OrConstant[6];

  05f80	b8 04 00 00 00	 mov	 eax, 4
  05f85	48 6b c0 16	 imul	 rax, rax, 22
  05f89	b9 04 00 00 00	 mov	 ecx, 4
  05f8e	48 6b c9 06	 imul	 rcx, rcx, 6
  05f92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05f99	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05f9c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05fa0	0b c1		 or	 eax, ecx
  05fa2	b9 04 00 00 00	 mov	 ecx, 4
  05fa7	48 6b c9 16	 imul	 rcx, rcx, 22
  05fab	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9064 :         OrResult[27] |= OrConstant[8];

  05faf	b8 04 00 00 00	 mov	 eax, 4
  05fb4	48 6b c0 1b	 imul	 rax, rax, 27
  05fb8	b9 04 00 00 00	 mov	 ecx, 4
  05fbd	48 6b c9 08	 imul	 rcx, rcx, 8
  05fc1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05fc8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05fcb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05fcf	0b c1		 or	 eax, ecx
  05fd1	b9 04 00 00 00	 mov	 ecx, 4
  05fd6	48 6b c9 1b	 imul	 rcx, rcx, 27
  05fda	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9065 :         OrResult[28] |= OrConstant[4];

  05fde	b8 04 00 00 00	 mov	 eax, 4
  05fe3	48 6b c0 1c	 imul	 rax, rax, 28
  05fe7	b9 04 00 00 00	 mov	 ecx, 4
  05fec	48 6b c9 04	 imul	 rcx, rcx, 4
  05ff0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  05ff7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  05ffa	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  05ffe	0b c1		 or	 eax, ecx
  06000	b9 04 00 00 00	 mov	 ecx, 4
  06005	48 6b c9 1c	 imul	 rcx, rcx, 28
  06009	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9066 :         OrResult[31] |= OrConstant[11];

  0600d	b8 04 00 00 00	 mov	 eax, 4
  06012	48 6b c0 1f	 imul	 rax, rax, 31
  06016	b9 04 00 00 00	 mov	 ecx, 4
  0601b	48 6b c9 0b	 imul	 rcx, rcx, 11
  0601f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06026	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06029	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0602d	0b c1		 or	 eax, ecx
  0602f	b9 04 00 00 00	 mov	 ecx, 4
  06034	48 6b c9 1f	 imul	 rcx, rcx, 31
  06038	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN46@gen_csv_si:

; 9067 :     }
; 9068 :     if ((pClock1[5] & 0x40 ) == 0x40)

  0603c	b8 01 00 00 00	 mov	 eax, 1
  06041	48 6b c0 05	 imul	 rax, rax, 5
  06045	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0604d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  06051	83 e0 40	 and	 eax, 64			; 00000040H
  06054	83 f8 40	 cmp	 eax, 64			; 00000040H
  06057	0f 85 34 02 00
	00		 jne	 $LN47@gen_csv_si

; 9069 :     {
; 9070 :         OrResult[0]  |= OrConstant[2];

  0605d	b8 04 00 00 00	 mov	 eax, 4
  06062	48 6b c0 00	 imul	 rax, rax, 0
  06066	b9 04 00 00 00	 mov	 ecx, 4
  0606b	48 6b c9 02	 imul	 rcx, rcx, 2
  0606f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06076	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06079	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0607d	0b c1		 or	 eax, ecx
  0607f	b9 04 00 00 00	 mov	 ecx, 4
  06084	48 6b c9 00	 imul	 rcx, rcx, 0
  06088	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9071 :         OrResult[2]  |= OrConstant[8];

  0608c	b8 04 00 00 00	 mov	 eax, 4
  06091	48 6b c0 02	 imul	 rax, rax, 2
  06095	b9 04 00 00 00	 mov	 ecx, 4
  0609a	48 6b c9 08	 imul	 rcx, rcx, 8
  0609e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  060a5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  060a8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  060ac	0b c1		 or	 eax, ecx
  060ae	b9 04 00 00 00	 mov	 ecx, 4
  060b3	48 6b c9 02	 imul	 rcx, rcx, 2
  060b7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9072 :         OrResult[4]  |= OrConstant[0];

  060bb	b8 04 00 00 00	 mov	 eax, 4
  060c0	48 6b c0 04	 imul	 rax, rax, 4
  060c4	b9 04 00 00 00	 mov	 ecx, 4
  060c9	48 6b c9 00	 imul	 rcx, rcx, 0
  060cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  060d4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  060d7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  060db	0b c1		 or	 eax, ecx
  060dd	b9 04 00 00 00	 mov	 ecx, 4
  060e2	48 6b c9 04	 imul	 rcx, rcx, 4
  060e6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9073 :         OrResult[7]  |= OrConstant[6];

  060ea	b8 04 00 00 00	 mov	 eax, 4
  060ef	48 6b c0 07	 imul	 rax, rax, 7
  060f3	b9 04 00 00 00	 mov	 ecx, 4
  060f8	48 6b c9 06	 imul	 rcx, rcx, 6
  060fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06103	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06106	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0610a	0b c1		 or	 eax, ecx
  0610c	b9 04 00 00 00	 mov	 ecx, 4
  06111	48 6b c9 07	 imul	 rcx, rcx, 7
  06115	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9074 :         OrResult[11] |= OrConstant[9];

  06119	b8 04 00 00 00	 mov	 eax, 4
  0611e	48 6b c0 0b	 imul	 rax, rax, 11
  06122	b9 04 00 00 00	 mov	 ecx, 4
  06127	48 6b c9 09	 imul	 rcx, rcx, 9
  0612b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06132	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06135	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06139	0b c1		 or	 eax, ecx
  0613b	b9 04 00 00 00	 mov	 ecx, 4
  06140	48 6b c9 0b	 imul	 rcx, rcx, 11
  06144	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9075 :         OrResult[14] |= OrConstant[3];

  06148	b8 04 00 00 00	 mov	 eax, 4
  0614d	48 6b c0 0e	 imul	 rax, rax, 14
  06151	b9 04 00 00 00	 mov	 ecx, 4
  06156	48 6b c9 03	 imul	 rcx, rcx, 3
  0615a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06161	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06164	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06168	0b c1		 or	 eax, ecx
  0616a	b9 04 00 00 00	 mov	 ecx, 4
  0616f	48 6b c9 0e	 imul	 rcx, rcx, 14
  06173	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9076 :         OrResult[19] |= OrConstant[8];

  06177	b8 04 00 00 00	 mov	 eax, 4
  0617c	48 6b c0 13	 imul	 rax, rax, 19
  06180	b9 04 00 00 00	 mov	 ecx, 4
  06185	48 6b c9 08	 imul	 rcx, rcx, 8
  06189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06190	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06193	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06197	0b c1		 or	 eax, ecx
  06199	b9 04 00 00 00	 mov	 ecx, 4
  0619e	48 6b c9 13	 imul	 rcx, rcx, 19
  061a2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9077 :         OrResult[20] |= OrConstant[4];

  061a6	b8 04 00 00 00	 mov	 eax, 4
  061ab	48 6b c0 14	 imul	 rax, rax, 20
  061af	b9 04 00 00 00	 mov	 ecx, 4
  061b4	48 6b c9 04	 imul	 rcx, rcx, 4
  061b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  061bf	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  061c2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  061c6	0b c1		 or	 eax, ecx
  061c8	b9 04 00 00 00	 mov	 ecx, 4
  061cd	48 6b c9 14	 imul	 rcx, rcx, 20
  061d1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9078 :         OrResult[23] |= OrConstant[0];

  061d5	b8 04 00 00 00	 mov	 eax, 4
  061da	48 6b c0 17	 imul	 rax, rax, 23
  061de	b9 04 00 00 00	 mov	 ecx, 4
  061e3	48 6b c9 00	 imul	 rcx, rcx, 0
  061e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  061ee	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  061f1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  061f5	0b c1		 or	 eax, ecx
  061f7	b9 04 00 00 00	 mov	 ecx, 4
  061fc	48 6b c9 17	 imul	 rcx, rcx, 23
  06200	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9079 :         OrResult[24] |= OrConstant[5];

  06204	b8 04 00 00 00	 mov	 eax, 4
  06209	48 6b c0 18	 imul	 rax, rax, 24
  0620d	b9 04 00 00 00	 mov	 ecx, 4
  06212	48 6b c9 05	 imul	 rcx, rcx, 5
  06216	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0621d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06220	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06224	0b c1		 or	 eax, ecx
  06226	b9 04 00 00 00	 mov	 ecx, 4
  0622b	48 6b c9 18	 imul	 rcx, rcx, 24
  0622f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9080 :         OrResult[27] |= OrConstant[7];

  06233	b8 04 00 00 00	 mov	 eax, 4
  06238	48 6b c0 1b	 imul	 rax, rax, 27
  0623c	b9 04 00 00 00	 mov	 ecx, 4
  06241	48 6b c9 07	 imul	 rcx, rcx, 7
  06245	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0624c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0624f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06253	0b c1		 or	 eax, ecx
  06255	b9 04 00 00 00	 mov	 ecx, 4
  0625a	48 6b c9 1b	 imul	 rcx, rcx, 27
  0625e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9081 :         OrResult[31] |= OrConstant[5];

  06262	b8 04 00 00 00	 mov	 eax, 4
  06267	48 6b c0 1f	 imul	 rax, rax, 31
  0626b	b9 04 00 00 00	 mov	 ecx, 4
  06270	48 6b c9 05	 imul	 rcx, rcx, 5
  06274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0627b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0627e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06282	0b c1		 or	 eax, ecx
  06284	b9 04 00 00 00	 mov	 ecx, 4
  06289	48 6b c9 1f	 imul	 rcx, rcx, 31
  0628d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN47@gen_csv_si:

; 9082 :     }
; 9083 :     if ((pClock1[5] & 0x20 ) == 0x20)

  06291	b8 01 00 00 00	 mov	 eax, 1
  06296	48 6b c0 05	 imul	 rax, rax, 5
  0629a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  062a2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  062a6	83 e0 20	 and	 eax, 32			; 00000020H
  062a9	83 f8 20	 cmp	 eax, 32			; 00000020H
  062ac	0f 85 63 02 00
	00		 jne	 $LN48@gen_csv_si

; 9084 :     {
; 9085 :         OrResult[0]  |= OrConstant[7];

  062b2	b8 04 00 00 00	 mov	 eax, 4
  062b7	48 6b c0 00	 imul	 rax, rax, 0
  062bb	b9 04 00 00 00	 mov	 ecx, 4
  062c0	48 6b c9 07	 imul	 rcx, rcx, 7
  062c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  062cb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  062ce	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  062d2	0b c1		 or	 eax, ecx
  062d4	b9 04 00 00 00	 mov	 ecx, 4
  062d9	48 6b c9 00	 imul	 rcx, rcx, 0
  062dd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9086 :         OrResult[3]  |= OrConstant[9];

  062e1	b8 04 00 00 00	 mov	 eax, 4
  062e6	48 6b c0 03	 imul	 rax, rax, 3
  062ea	b9 04 00 00 00	 mov	 ecx, 4
  062ef	48 6b c9 09	 imul	 rcx, rcx, 9
  062f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  062fa	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  062fd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06301	0b c1		 or	 eax, ecx
  06303	b9 04 00 00 00	 mov	 ecx, 4
  06308	48 6b c9 03	 imul	 rcx, rcx, 3
  0630c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9087 :         OrResult[6]  |= OrConstant[3];

  06310	b8 04 00 00 00	 mov	 eax, 4
  06315	48 6b c0 06	 imul	 rax, rax, 6
  06319	b9 04 00 00 00	 mov	 ecx, 4
  0631e	48 6b c9 03	 imul	 rcx, rcx, 3
  06322	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06329	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0632c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06330	0b c1		 or	 eax, ecx
  06332	b9 04 00 00 00	 mov	 ecx, 4
  06337	48 6b c9 06	 imul	 rcx, rcx, 6
  0633b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9088 :         OrResult[8]  |= OrConstant[10];

  0633f	b8 04 00 00 00	 mov	 eax, 4
  06344	48 6b c0 08	 imul	 rax, rax, 8
  06348	b9 04 00 00 00	 mov	 ecx, 4
  0634d	48 6b c9 0a	 imul	 rcx, rcx, 10
  06351	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06358	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0635b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0635f	0b c1		 or	 eax, ecx
  06361	b9 04 00 00 00	 mov	 ecx, 4
  06366	48 6b c9 08	 imul	 rcx, rcx, 8
  0636a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9089 :         OrResult[11] |= OrConstant[1];

  0636e	b8 04 00 00 00	 mov	 eax, 4
  06373	48 6b c0 0b	 imul	 rax, rax, 11
  06377	b9 04 00 00 00	 mov	 ecx, 4
  0637c	48 6b c9 01	 imul	 rcx, rcx, 1
  06380	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06387	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0638a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0638e	0b c1		 or	 eax, ecx
  06390	b9 04 00 00 00	 mov	 ecx, 4
  06395	48 6b c9 0b	 imul	 rcx, rcx, 11
  06399	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9090 :         OrResult[13] |= OrConstant[11];

  0639d	b8 04 00 00 00	 mov	 eax, 4
  063a2	48 6b c0 0d	 imul	 rax, rax, 13
  063a6	b9 04 00 00 00	 mov	 ecx, 4
  063ab	48 6b c9 0b	 imul	 rcx, rcx, 11
  063af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  063b6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  063b9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  063bd	0b c1		 or	 eax, ecx
  063bf	b9 04 00 00 00	 mov	 ecx, 4
  063c4	48 6b c9 0d	 imul	 rcx, rcx, 13
  063c8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9091 :         OrResult[14] |= OrConstant[9];

  063cc	b8 04 00 00 00	 mov	 eax, 4
  063d1	48 6b c0 0e	 imul	 rax, rax, 14
  063d5	b9 04 00 00 00	 mov	 ecx, 4
  063da	48 6b c9 09	 imul	 rcx, rcx, 9
  063de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  063e5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  063e8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  063ec	0b c1		 or	 eax, ecx
  063ee	b9 04 00 00 00	 mov	 ecx, 4
  063f3	48 6b c9 0e	 imul	 rcx, rcx, 14
  063f7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9092 :         OrResult[16] |= OrConstant[5];

  063fb	b8 04 00 00 00	 mov	 eax, 4
  06400	48 6b c0 10	 imul	 rax, rax, 16
  06404	b9 04 00 00 00	 mov	 ecx, 4
  06409	48 6b c9 05	 imul	 rcx, rcx, 5
  0640d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06414	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06417	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0641b	0b c1		 or	 eax, ecx
  0641d	b9 04 00 00 00	 mov	 ecx, 4
  06422	48 6b c9 10	 imul	 rcx, rcx, 16
  06426	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9093 :         OrResult[19] |= OrConstant[7];

  0642a	b8 04 00 00 00	 mov	 eax, 4
  0642f	48 6b c0 13	 imul	 rax, rax, 19
  06433	b9 04 00 00 00	 mov	 ecx, 4
  06438	48 6b c9 07	 imul	 rcx, rcx, 7
  0643c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06443	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06446	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0644a	0b c1		 or	 eax, ecx
  0644c	b9 04 00 00 00	 mov	 ecx, 4
  06451	48 6b c9 13	 imul	 rcx, rcx, 19
  06455	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9094 :         OrResult[22] |= OrConstant[2];

  06459	b8 04 00 00 00	 mov	 eax, 4
  0645e	48 6b c0 16	 imul	 rax, rax, 22
  06462	b9 04 00 00 00	 mov	 ecx, 4
  06467	48 6b c9 02	 imul	 rcx, rcx, 2
  0646b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06472	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06475	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06479	0b c1		 or	 eax, ecx
  0647b	b9 04 00 00 00	 mov	 ecx, 4
  06480	48 6b c9 16	 imul	 rcx, rcx, 22
  06484	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9095 :         OrResult[25] |= OrConstant[10];

  06488	b8 04 00 00 00	 mov	 eax, 4
  0648d	48 6b c0 19	 imul	 rax, rax, 25
  06491	b9 04 00 00 00	 mov	 ecx, 4
  06496	48 6b c9 0a	 imul	 rcx, rcx, 10
  0649a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  064a1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  064a4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  064a8	0b c1		 or	 eax, ecx
  064aa	b9 04 00 00 00	 mov	 ecx, 4
  064af	48 6b c9 19	 imul	 rcx, rcx, 25
  064b3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9096 :         OrResult[27] |= OrConstant[2];

  064b7	b8 04 00 00 00	 mov	 eax, 4
  064bc	48 6b c0 1b	 imul	 rax, rax, 27
  064c0	b9 04 00 00 00	 mov	 ecx, 4
  064c5	48 6b c9 02	 imul	 rcx, rcx, 2
  064c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  064d0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  064d3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  064d7	0b c1		 or	 eax, ecx
  064d9	b9 04 00 00 00	 mov	 ecx, 4
  064de	48 6b c9 1b	 imul	 rcx, rcx, 27
  064e2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9097 :         OrResult[28] |= OrConstant[1];

  064e6	b8 04 00 00 00	 mov	 eax, 4
  064eb	48 6b c0 1c	 imul	 rax, rax, 28
  064ef	b9 04 00 00 00	 mov	 ecx, 4
  064f4	48 6b c9 01	 imul	 rcx, rcx, 1
  064f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  064ff	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06502	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06506	0b c1		 or	 eax, ecx
  06508	b9 04 00 00 00	 mov	 ecx, 4
  0650d	48 6b c9 1c	 imul	 rcx, rcx, 28
  06511	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN48@gen_csv_si:

; 9098 :     }
; 9099 :     if ((pClock1[5] & 0x10 ) == 0x10)

  06515	b8 01 00 00 00	 mov	 eax, 1
  0651a	48 6b c0 05	 imul	 rax, rax, 5
  0651e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  06526	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0652a	83 e0 10	 and	 eax, 16
  0652d	83 f8 10	 cmp	 eax, 16
  06530	0f 85 c1 02 00
	00		 jne	 $LN49@gen_csv_si

; 9100 :     {
; 9101 :         OrResult[1]  |= OrConstant[8];

  06536	b8 04 00 00 00	 mov	 eax, 4
  0653b	48 6b c0 01	 imul	 rax, rax, 1
  0653f	b9 04 00 00 00	 mov	 ecx, 4
  06544	48 6b c9 08	 imul	 rcx, rcx, 8
  06548	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0654f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06552	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06556	0b c1		 or	 eax, ecx
  06558	b9 04 00 00 00	 mov	 ecx, 4
  0655d	48 6b c9 01	 imul	 rcx, rcx, 1
  06561	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9102 :         OrResult[3]  |= OrConstant[1];

  06565	b8 04 00 00 00	 mov	 eax, 4
  0656a	48 6b c0 03	 imul	 rax, rax, 3
  0656e	b9 04 00 00 00	 mov	 ecx, 4
  06573	48 6b c9 01	 imul	 rcx, rcx, 1
  06577	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0657e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06581	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06585	0b c1		 or	 eax, ecx
  06587	b9 04 00 00 00	 mov	 ecx, 4
  0658c	48 6b c9 03	 imul	 rcx, rcx, 3
  06590	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9103 :         OrResult[5]  |= OrConstant[11];

  06594	b8 04 00 00 00	 mov	 eax, 4
  06599	48 6b c0 05	 imul	 rax, rax, 5
  0659d	b9 04 00 00 00	 mov	 ecx, 4
  065a2	48 6b c9 0b	 imul	 rcx, rcx, 11
  065a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  065ad	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  065b0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  065b4	0b c1		 or	 eax, ecx
  065b6	b9 04 00 00 00	 mov	 ecx, 4
  065bb	48 6b c9 05	 imul	 rcx, rcx, 5
  065bf	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9104 :         OrResult[6]  |= OrConstant[9];

  065c3	b8 04 00 00 00	 mov	 eax, 4
  065c8	48 6b c0 06	 imul	 rax, rax, 6
  065cc	b9 04 00 00 00	 mov	 ecx, 4
  065d1	48 6b c9 09	 imul	 rcx, rcx, 9
  065d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  065dc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  065df	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  065e3	0b c1		 or	 eax, ecx
  065e5	b9 04 00 00 00	 mov	 ecx, 4
  065ea	48 6b c9 06	 imul	 rcx, rcx, 6
  065ee	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9105 :         OrResult[9]  |= OrConstant[3];

  065f2	b8 04 00 00 00	 mov	 eax, 4
  065f7	48 6b c0 09	 imul	 rax, rax, 9
  065fb	b9 04 00 00 00	 mov	 ecx, 4
  06600	48 6b c9 03	 imul	 rcx, rcx, 3
  06604	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0660b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0660e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06612	0b c1		 or	 eax, ecx
  06614	b9 04 00 00 00	 mov	 ecx, 4
  06619	48 6b c9 09	 imul	 rcx, rcx, 9
  0661d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9106 :         OrResult[10] |= OrConstant[11];

  06621	b8 04 00 00 00	 mov	 eax, 4
  06626	48 6b c0 0a	 imul	 rax, rax, 10
  0662a	b9 04 00 00 00	 mov	 ecx, 4
  0662f	48 6b c9 0b	 imul	 rcx, rcx, 11
  06633	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0663a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0663d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06641	0b c1		 or	 eax, ecx
  06643	b9 04 00 00 00	 mov	 ecx, 4
  06648	48 6b c9 0a	 imul	 rcx, rcx, 10
  0664c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9107 :         OrResult[13] |= OrConstant[5];

  06650	b8 04 00 00 00	 mov	 eax, 4
  06655	48 6b c0 0d	 imul	 rax, rax, 13
  06659	b9 04 00 00 00	 mov	 ecx, 4
  0665e	48 6b c9 05	 imul	 rcx, rcx, 5
  06662	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06669	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0666c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06670	0b c1		 or	 eax, ecx
  06672	b9 04 00 00 00	 mov	 ecx, 4
  06677	48 6b c9 0d	 imul	 rcx, rcx, 13
  0667b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9108 :         OrResult[14] |= OrConstant[8];

  0667f	b8 04 00 00 00	 mov	 eax, 4
  06684	48 6b c0 0e	 imul	 rax, rax, 14
  06688	b9 04 00 00 00	 mov	 ecx, 4
  0668d	48 6b c9 08	 imul	 rcx, rcx, 8
  06691	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06698	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0669b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0669f	0b c1		 or	 eax, ecx
  066a1	b9 04 00 00 00	 mov	 ecx, 4
  066a6	48 6b c9 0e	 imul	 rcx, rcx, 14
  066aa	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9109 :         OrResult[17] |= OrConstant[10];

  066ae	b8 04 00 00 00	 mov	 eax, 4
  066b3	48 6b c0 11	 imul	 rax, rax, 17
  066b7	b9 04 00 00 00	 mov	 ecx, 4
  066bc	48 6b c9 0a	 imul	 rcx, rcx, 10
  066c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  066c7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  066ca	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  066ce	0b c1		 or	 eax, ecx
  066d0	b9 04 00 00 00	 mov	 ecx, 4
  066d5	48 6b c9 11	 imul	 rcx, rcx, 17
  066d9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9110 :         OrResult[19] |= OrConstant[2];

  066dd	b8 04 00 00 00	 mov	 eax, 4
  066e2	48 6b c0 13	 imul	 rax, rax, 19
  066e6	b9 04 00 00 00	 mov	 ecx, 4
  066eb	48 6b c9 02	 imul	 rcx, rcx, 2
  066ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  066f6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  066f9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  066fd	0b c1		 or	 eax, ecx
  066ff	b9 04 00 00 00	 mov	 ecx, 4
  06704	48 6b c9 13	 imul	 rcx, rcx, 19
  06708	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9111 :         OrResult[20] |= OrConstant[1];

  0670c	b8 04 00 00 00	 mov	 eax, 4
  06711	48 6b c0 14	 imul	 rax, rax, 20
  06715	b9 04 00 00 00	 mov	 ecx, 4
  0671a	48 6b c9 01	 imul	 rcx, rcx, 1
  0671e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06725	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06728	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0672c	0b c1		 or	 eax, ecx
  0672e	b9 04 00 00 00	 mov	 ecx, 4
  06733	48 6b c9 14	 imul	 rcx, rcx, 20
  06737	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9112 :         OrResult[22] |= OrConstant[7];

  0673b	b8 04 00 00 00	 mov	 eax, 4
  06740	48 6b c0 16	 imul	 rax, rax, 22
  06744	b9 04 00 00 00	 mov	 ecx, 4
  06749	48 6b c9 07	 imul	 rcx, rcx, 7
  0674d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06754	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06757	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0675b	0b c1		 or	 eax, ecx
  0675d	b9 04 00 00 00	 mov	 ecx, 4
  06762	48 6b c9 16	 imul	 rcx, rcx, 22
  06766	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9113 :         OrResult[25] |= OrConstant[4];

  0676a	b8 04 00 00 00	 mov	 eax, 4
  0676f	48 6b c0 19	 imul	 rax, rax, 25
  06773	b9 04 00 00 00	 mov	 ecx, 4
  06778	48 6b c9 04	 imul	 rcx, rcx, 4
  0677c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06783	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06786	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0678a	0b c1		 or	 eax, ecx
  0678c	b9 04 00 00 00	 mov	 ecx, 4
  06791	48 6b c9 19	 imul	 rcx, rcx, 25
  06795	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9114 :         OrResult[26] |= OrConstant[6];

  06799	b8 04 00 00 00	 mov	 eax, 4
  0679e	48 6b c0 1a	 imul	 rax, rax, 26
  067a2	b9 04 00 00 00	 mov	 ecx, 4
  067a7	48 6b c9 06	 imul	 rcx, rcx, 6
  067ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  067b2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  067b5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  067b9	0b c1		 or	 eax, ecx
  067bb	b9 04 00 00 00	 mov	 ecx, 4
  067c0	48 6b c9 1a	 imul	 rcx, rcx, 26
  067c4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9115 :         OrResult[30] |= OrConstant[10];

  067c8	b8 04 00 00 00	 mov	 eax, 4
  067cd	48 6b c0 1e	 imul	 rax, rax, 30
  067d1	b9 04 00 00 00	 mov	 ecx, 4
  067d6	48 6b c9 0a	 imul	 rcx, rcx, 10
  067da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  067e1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  067e4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  067e8	0b c1		 or	 eax, ecx
  067ea	b9 04 00 00 00	 mov	 ecx, 4
  067ef	48 6b c9 1e	 imul	 rcx, rcx, 30
  067f3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN49@gen_csv_si:

; 9116 :     }
; 9117 :     if ((pClock1[5] & 0x08 ) == 0x08)

  067f7	b8 01 00 00 00	 mov	 eax, 1
  067fc	48 6b c0 05	 imul	 rax, rax, 5
  06800	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  06808	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0680c	83 e0 08	 and	 eax, 8
  0680f	83 f8 08	 cmp	 eax, 8
  06812	0f 85 63 02 00
	00		 jne	 $LN50@gen_csv_si

; 9118 :     {
; 9119 :         OrResult[0]  |= OrConstant[16];

  06818	b8 04 00 00 00	 mov	 eax, 4
  0681d	48 6b c0 00	 imul	 rax, rax, 0
  06821	b9 04 00 00 00	 mov	 ecx, 4
  06826	48 6b c9 10	 imul	 rcx, rcx, 16
  0682a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06831	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06834	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06838	0b c1		 or	 eax, ecx
  0683a	b9 04 00 00 00	 mov	 ecx, 4
  0683f	48 6b c9 00	 imul	 rcx, rcx, 0
  06843	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9120 :         OrResult[3]  |= OrConstant[17];

  06847	b8 04 00 00 00	 mov	 eax, 4
  0684c	48 6b c0 03	 imul	 rax, rax, 3
  06850	b9 04 00 00 00	 mov	 ecx, 4
  06855	48 6b c9 11	 imul	 rcx, rcx, 17
  06859	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06860	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06863	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06867	0b c1		 or	 eax, ecx
  06869	b9 04 00 00 00	 mov	 ecx, 4
  0686e	48 6b c9 03	 imul	 rcx, rcx, 3
  06872	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9121 :         OrResult[5]  |= OrConstant[20];

  06876	b8 04 00 00 00	 mov	 eax, 4
  0687b	48 6b c0 05	 imul	 rax, rax, 5
  0687f	b9 04 00 00 00	 mov	 ecx, 4
  06884	48 6b c9 14	 imul	 rcx, rcx, 20
  06888	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0688f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06892	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06896	0b c1		 or	 eax, ecx
  06898	b9 04 00 00 00	 mov	 ecx, 4
  0689d	48 6b c9 05	 imul	 rcx, rcx, 5
  068a1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9122 :         OrResult[6]  |= OrConstant[13];

  068a5	b8 04 00 00 00	 mov	 eax, 4
  068aa	48 6b c0 06	 imul	 rax, rax, 6
  068ae	b9 04 00 00 00	 mov	 ecx, 4
  068b3	48 6b c9 0d	 imul	 rcx, rcx, 13
  068b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  068be	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  068c1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  068c5	0b c1		 or	 eax, ecx
  068c7	b9 04 00 00 00	 mov	 ecx, 4
  068cc	48 6b c9 06	 imul	 rcx, rcx, 6
  068d0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9123 :         OrResult[10] |= OrConstant[21];

  068d4	b8 04 00 00 00	 mov	 eax, 4
  068d9	48 6b c0 0a	 imul	 rax, rax, 10
  068dd	b9 04 00 00 00	 mov	 ecx, 4
  068e2	48 6b c9 15	 imul	 rcx, rcx, 21
  068e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  068ed	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  068f0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  068f4	0b c1		 or	 eax, ecx
  068f6	b9 04 00 00 00	 mov	 ecx, 4
  068fb	48 6b c9 0a	 imul	 rcx, rcx, 10
  068ff	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9124 :         OrResult[13] |= OrConstant[12];

  06903	b8 04 00 00 00	 mov	 eax, 4
  06908	48 6b c0 0d	 imul	 rax, rax, 13
  0690c	b9 04 00 00 00	 mov	 ecx, 4
  06911	48 6b c9 0c	 imul	 rcx, rcx, 12
  06915	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0691c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0691f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06923	0b c1		 or	 eax, ecx
  06925	b9 04 00 00 00	 mov	 ecx, 4
  0692a	48 6b c9 0d	 imul	 rcx, rcx, 13
  0692e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9125 :         OrResult[15] |= OrConstant[23];

  06932	b8 04 00 00 00	 mov	 eax, 4
  06937	48 6b c0 0f	 imul	 rax, rax, 15
  0693b	b9 04 00 00 00	 mov	 ecx, 4
  06940	48 6b c9 17	 imul	 rcx, rcx, 23
  06944	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0694b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0694e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06952	0b c1		 or	 eax, ecx
  06954	b9 04 00 00 00	 mov	 ecx, 4
  06959	48 6b c9 0f	 imul	 rcx, rcx, 15
  0695d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9126 :         OrResult[17] |= OrConstant[16];

  06961	b8 04 00 00 00	 mov	 eax, 4
  06966	48 6b c0 11	 imul	 rax, rax, 17
  0696a	b9 04 00 00 00	 mov	 ecx, 4
  0696f	48 6b c9 10	 imul	 rcx, rcx, 16
  06973	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0697a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0697d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06981	0b c1		 or	 eax, ecx
  06983	b9 04 00 00 00	 mov	 ecx, 4
  06988	48 6b c9 11	 imul	 rcx, rcx, 17
  0698c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9127 :         OrResult[20] |= OrConstant[15];

  06990	b8 04 00 00 00	 mov	 eax, 4
  06995	48 6b c0 14	 imul	 rax, rax, 20
  06999	b9 04 00 00 00	 mov	 ecx, 4
  0699e	48 6b c9 0f	 imul	 rcx, rcx, 15
  069a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  069a9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  069ac	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  069b0	0b c1		 or	 eax, ecx
  069b2	b9 04 00 00 00	 mov	 ecx, 4
  069b7	48 6b c9 14	 imul	 rcx, rcx, 20
  069bb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9128 :         OrResult[22] |= OrConstant[20];

  069bf	b8 04 00 00 00	 mov	 eax, 4
  069c4	48 6b c0 16	 imul	 rax, rax, 22
  069c8	b9 04 00 00 00	 mov	 ecx, 4
  069cd	48 6b c9 14	 imul	 rcx, rcx, 20
  069d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  069d8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  069db	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  069df	0b c1		 or	 eax, ecx
  069e1	b9 04 00 00 00	 mov	 ecx, 4
  069e6	48 6b c9 16	 imul	 rcx, rcx, 22
  069ea	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9129 :         OrResult[24] |= OrConstant[12];

  069ee	b8 04 00 00 00	 mov	 eax, 4
  069f3	48 6b c0 18	 imul	 rax, rax, 24
  069f7	b9 04 00 00 00	 mov	 ecx, 4
  069fc	48 6b c9 0c	 imul	 rcx, rcx, 12
  06a00	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06a07	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06a0a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06a0e	0b c1		 or	 eax, ecx
  06a10	b9 04 00 00 00	 mov	 ecx, 4
  06a15	48 6b c9 18	 imul	 rcx, rcx, 24
  06a19	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9130 :         OrResult[29] |= OrConstant[15];

  06a1d	b8 04 00 00 00	 mov	 eax, 4
  06a22	48 6b c0 1d	 imul	 rax, rax, 29
  06a26	b9 04 00 00 00	 mov	 ecx, 4
  06a2b	48 6b c9 0f	 imul	 rcx, rcx, 15
  06a2f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06a36	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06a39	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06a3d	0b c1		 or	 eax, ecx
  06a3f	b9 04 00 00 00	 mov	 ecx, 4
  06a44	48 6b c9 1d	 imul	 rcx, rcx, 29
  06a48	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9131 :         OrResult[31] |= OrConstant[18];

  06a4c	b8 04 00 00 00	 mov	 eax, 4
  06a51	48 6b c0 1f	 imul	 rax, rax, 31
  06a55	b9 04 00 00 00	 mov	 ecx, 4
  06a5a	48 6b c9 12	 imul	 rcx, rcx, 18
  06a5e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06a65	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06a68	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06a6c	0b c1		 or	 eax, ecx
  06a6e	b9 04 00 00 00	 mov	 ecx, 4
  06a73	48 6b c9 1f	 imul	 rcx, rcx, 31
  06a77	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN50@gen_csv_si:

; 9132 :     }
; 9133 :     if ((pClock1[5] & 0x04 ) == 0x04)

  06a7b	b8 01 00 00 00	 mov	 eax, 1
  06a80	48 6b c0 05	 imul	 rax, rax, 5
  06a84	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  06a8c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  06a90	83 e0 04	 and	 eax, 4
  06a93	83 f8 04	 cmp	 eax, 4
  06a96	0f 85 92 02 00
	00		 jne	 $LN51@gen_csv_si

; 9134 :     {
; 9135 :         OrResult[0]  |= OrConstant[20];

  06a9c	b8 04 00 00 00	 mov	 eax, 4
  06aa1	48 6b c0 00	 imul	 rax, rax, 0
  06aa5	b9 04 00 00 00	 mov	 ecx, 4
  06aaa	48 6b c9 14	 imul	 rcx, rcx, 20
  06aae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06ab5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06ab8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06abc	0b c1		 or	 eax, ecx
  06abe	b9 04 00 00 00	 mov	 ecx, 4
  06ac3	48 6b c9 00	 imul	 rcx, rcx, 0
  06ac7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9136 :         OrResult[3]  |= OrConstant[13];

  06acb	b8 04 00 00 00	 mov	 eax, 4
  06ad0	48 6b c0 03	 imul	 rax, rax, 3
  06ad4	b9 04 00 00 00	 mov	 ecx, 4
  06ad9	48 6b c9 0d	 imul	 rcx, rcx, 13
  06add	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06ae4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06ae7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06aeb	0b c1		 or	 eax, ecx
  06aed	b9 04 00 00 00	 mov	 ecx, 4
  06af2	48 6b c9 03	 imul	 rcx, rcx, 3
  06af6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9137 :         OrResult[5]  |= OrConstant[19];

  06afa	b8 04 00 00 00	 mov	 eax, 4
  06aff	48 6b c0 05	 imul	 rax, rax, 5
  06b03	b9 04 00 00 00	 mov	 ecx, 4
  06b08	48 6b c9 13	 imul	 rcx, rcx, 19
  06b0c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06b13	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06b16	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06b1a	0b c1		 or	 eax, ecx
  06b1c	b9 04 00 00 00	 mov	 ecx, 4
  06b21	48 6b c9 05	 imul	 rcx, rcx, 5
  06b25	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9138 :         OrResult[6]  |= OrConstant[18];

  06b29	b8 04 00 00 00	 mov	 eax, 4
  06b2e	48 6b c0 06	 imul	 rax, rax, 6
  06b32	b9 04 00 00 00	 mov	 ecx, 4
  06b37	48 6b c9 12	 imul	 rcx, rcx, 18
  06b3b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06b42	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06b45	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06b49	0b c1		 or	 eax, ecx
  06b4b	b9 04 00 00 00	 mov	 ecx, 4
  06b50	48 6b c9 06	 imul	 rcx, rcx, 6
  06b54	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9139 :         OrResult[9]  |= OrConstant[18];

  06b58	b8 04 00 00 00	 mov	 eax, 4
  06b5d	48 6b c0 09	 imul	 rax, rax, 9
  06b61	b9 04 00 00 00	 mov	 ecx, 4
  06b66	48 6b c9 12	 imul	 rcx, rcx, 18
  06b6a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06b71	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06b74	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06b78	0b c1		 or	 eax, ecx
  06b7a	b9 04 00 00 00	 mov	 ecx, 4
  06b7f	48 6b c9 09	 imul	 rcx, rcx, 9
  06b83	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9140 :         OrResult[11] |= OrConstant[17];

  06b87	b8 04 00 00 00	 mov	 eax, 4
  06b8c	48 6b c0 0b	 imul	 rax, rax, 11
  06b90	b9 04 00 00 00	 mov	 ecx, 4
  06b95	48 6b c9 11	 imul	 rcx, rcx, 17
  06b99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06ba0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06ba3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06ba7	0b c1		 or	 eax, ecx
  06ba9	b9 04 00 00 00	 mov	 ecx, 4
  06bae	48 6b c9 0b	 imul	 rcx, rcx, 11
  06bb2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9141 :         OrResult[13] |= OrConstant[20];

  06bb6	b8 04 00 00 00	 mov	 eax, 4
  06bbb	48 6b c0 0d	 imul	 rax, rax, 13
  06bbf	b9 04 00 00 00	 mov	 ecx, 4
  06bc4	48 6b c9 14	 imul	 rcx, rcx, 20
  06bc8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06bcf	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06bd2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06bd6	0b c1		 or	 eax, ecx
  06bd8	b9 04 00 00 00	 mov	 ecx, 4
  06bdd	48 6b c9 0d	 imul	 rcx, rcx, 13
  06be1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9142 :         OrResult[14] |= OrConstant[13];

  06be5	b8 04 00 00 00	 mov	 eax, 4
  06bea	48 6b c0 0e	 imul	 rax, rax, 14
  06bee	b9 04 00 00 00	 mov	 ecx, 4
  06bf3	48 6b c9 0d	 imul	 rcx, rcx, 13
  06bf7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06bfe	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06c01	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06c05	0b c1		 or	 eax, ecx
  06c07	b9 04 00 00 00	 mov	 ecx, 4
  06c0c	48 6b c9 0e	 imul	 rcx, rcx, 14
  06c10	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9143 :         OrResult[16] |= OrConstant[23];

  06c14	b8 04 00 00 00	 mov	 eax, 4
  06c19	48 6b c0 10	 imul	 rax, rax, 16
  06c1d	b9 04 00 00 00	 mov	 ecx, 4
  06c22	48 6b c9 17	 imul	 rcx, rcx, 23
  06c26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06c2d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06c30	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06c34	0b c1		 or	 eax, ecx
  06c36	b9 04 00 00 00	 mov	 ecx, 4
  06c3b	48 6b c9 10	 imul	 rcx, rcx, 16
  06c3f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9144 :         OrResult[18] |= OrConstant[17];

  06c43	b8 04 00 00 00	 mov	 eax, 4
  06c48	48 6b c0 12	 imul	 rax, rax, 18
  06c4c	b9 04 00 00 00	 mov	 ecx, 4
  06c51	48 6b c9 11	 imul	 rcx, rcx, 17
  06c55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06c5c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06c5f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06c63	0b c1		 or	 eax, ecx
  06c65	b9 04 00 00 00	 mov	 ecx, 4
  06c6a	48 6b c9 12	 imul	 rcx, rcx, 18
  06c6e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9145 :         OrResult[21] |= OrConstant[22];

  06c72	b8 04 00 00 00	 mov	 eax, 4
  06c77	48 6b c0 15	 imul	 rax, rax, 21
  06c7b	b9 04 00 00 00	 mov	 ecx, 4
  06c80	48 6b c9 16	 imul	 rcx, rcx, 22
  06c84	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06c8b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06c8e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06c92	0b c1		 or	 eax, ecx
  06c94	b9 04 00 00 00	 mov	 ecx, 4
  06c99	48 6b c9 15	 imul	 rcx, rcx, 21
  06c9d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9146 :         OrResult[22] |= OrConstant[14];

  06ca1	b8 04 00 00 00	 mov	 eax, 4
  06ca6	48 6b c0 16	 imul	 rax, rax, 22
  06caa	b9 04 00 00 00	 mov	 ecx, 4
  06caf	48 6b c9 0e	 imul	 rcx, rcx, 14
  06cb3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06cba	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06cbd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06cc1	0b c1		 or	 eax, ecx
  06cc3	b9 04 00 00 00	 mov	 ecx, 4
  06cc8	48 6b c9 16	 imul	 rcx, rcx, 22
  06ccc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9147 :         OrResult[25] |= OrConstant[16];

  06cd0	b8 04 00 00 00	 mov	 eax, 4
  06cd5	48 6b c0 19	 imul	 rax, rax, 25
  06cd9	b9 04 00 00 00	 mov	 ecx, 4
  06cde	48 6b c9 10	 imul	 rcx, rcx, 16
  06ce2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06ce9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06cec	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06cf0	0b c1		 or	 eax, ecx
  06cf2	b9 04 00 00 00	 mov	 ecx, 4
  06cf7	48 6b c9 19	 imul	 rcx, rcx, 25
  06cfb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9148 :         OrResult[28] |= OrConstant[15];

  06cff	b8 04 00 00 00	 mov	 eax, 4
  06d04	48 6b c0 1c	 imul	 rax, rax, 28
  06d08	b9 04 00 00 00	 mov	 ecx, 4
  06d0d	48 6b c9 0f	 imul	 rcx, rcx, 15
  06d11	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06d18	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06d1b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06d1f	0b c1		 or	 eax, ecx
  06d21	b9 04 00 00 00	 mov	 ecx, 4
  06d26	48 6b c9 1c	 imul	 rcx, rcx, 28
  06d2a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN51@gen_csv_si:

; 9149 :     }
; 9150 :     if ((pClock1[5] & 0x02 ) == 0x02)

  06d2e	b8 01 00 00 00	 mov	 eax, 1
  06d33	48 6b c0 05	 imul	 rax, rax, 5
  06d37	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  06d3f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  06d43	83 e0 02	 and	 eax, 2
  06d46	83 f8 02	 cmp	 eax, 2
  06d49	0f 85 c1 02 00
	00		 jne	 $LN52@gen_csv_si

; 9151 :     {
; 9152 :         OrResult[0]  |= OrConstant[14];

  06d4f	b8 04 00 00 00	 mov	 eax, 4
  06d54	48 6b c0 00	 imul	 rax, rax, 0
  06d58	b9 04 00 00 00	 mov	 ecx, 4
  06d5d	48 6b c9 0e	 imul	 rcx, rcx, 14
  06d61	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06d68	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06d6b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06d6f	0b c1		 or	 eax, ecx
  06d71	b9 04 00 00 00	 mov	 ecx, 4
  06d76	48 6b c9 00	 imul	 rcx, rcx, 0
  06d7a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9153 :         OrResult[3]  |= OrConstant[23];

  06d7e	b8 04 00 00 00	 mov	 eax, 4
  06d83	48 6b c0 03	 imul	 rax, rax, 3
  06d87	b9 04 00 00 00	 mov	 ecx, 4
  06d8c	48 6b c9 17	 imul	 rcx, rcx, 23
  06d90	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06d97	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06d9a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06d9e	0b c1		 or	 eax, ecx
  06da0	b9 04 00 00 00	 mov	 ecx, 4
  06da5	48 6b c9 03	 imul	 rcx, rcx, 3
  06da9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9154 :         OrResult[4]  |= OrConstant[22];

  06dad	b8 04 00 00 00	 mov	 eax, 4
  06db2	48 6b c0 04	 imul	 rax, rax, 4
  06db6	b9 04 00 00 00	 mov	 ecx, 4
  06dbb	48 6b c9 16	 imul	 rcx, rcx, 22
  06dbf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06dc6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06dc9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06dcd	0b c1		 or	 eax, ecx
  06dcf	b9 04 00 00 00	 mov	 ecx, 4
  06dd4	48 6b c9 04	 imul	 rcx, rcx, 4
  06dd8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9155 :         OrResult[7]  |= OrConstant[21];

  06ddc	b8 04 00 00 00	 mov	 eax, 4
  06de1	48 6b c0 07	 imul	 rax, rax, 7
  06de5	b9 04 00 00 00	 mov	 ecx, 4
  06dea	48 6b c9 15	 imul	 rcx, rcx, 21
  06dee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06df5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06df8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06dfc	0b c1		 or	 eax, ecx
  06dfe	b9 04 00 00 00	 mov	 ecx, 4
  06e03	48 6b c9 07	 imul	 rcx, rcx, 7
  06e07	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9156 :         OrResult[11] |= OrConstant[13];

  06e0b	b8 04 00 00 00	 mov	 eax, 4
  06e10	48 6b c0 0b	 imul	 rax, rax, 11
  06e14	b9 04 00 00 00	 mov	 ecx, 4
  06e19	48 6b c9 0d	 imul	 rcx, rcx, 13
  06e1d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06e24	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06e27	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06e2b	0b c1		 or	 eax, ecx
  06e2d	b9 04 00 00 00	 mov	 ecx, 4
  06e32	48 6b c9 0b	 imul	 rcx, rcx, 11
  06e36	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9157 :         OrResult[13] |= OrConstant[19];

  06e3a	b8 04 00 00 00	 mov	 eax, 4
  06e3f	48 6b c0 0d	 imul	 rax, rax, 13
  06e43	b9 04 00 00 00	 mov	 ecx, 4
  06e48	48 6b c9 13	 imul	 rcx, rcx, 19
  06e4c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06e53	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06e56	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06e5a	0b c1		 or	 eax, ecx
  06e5c	b9 04 00 00 00	 mov	 ecx, 4
  06e61	48 6b c9 0d	 imul	 rcx, rcx, 13
  06e65	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9158 :         OrResult[14] |= OrConstant[18];

  06e69	b8 04 00 00 00	 mov	 eax, 4
  06e6e	48 6b c0 0e	 imul	 rax, rax, 14
  06e72	b9 04 00 00 00	 mov	 ecx, 4
  06e77	48 6b c9 12	 imul	 rcx, rcx, 18
  06e7b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06e82	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06e85	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06e89	0b c1		 or	 eax, ecx
  06e8b	b9 04 00 00 00	 mov	 ecx, 4
  06e90	48 6b c9 0e	 imul	 rcx, rcx, 14
  06e94	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9159 :         OrResult[17] |= OrConstant[15];

  06e98	b8 04 00 00 00	 mov	 eax, 4
  06e9d	48 6b c0 11	 imul	 rax, rax, 17
  06ea1	b9 04 00 00 00	 mov	 ecx, 4
  06ea6	48 6b c9 0f	 imul	 rcx, rcx, 15
  06eaa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06eb1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06eb4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06eb8	0b c1		 or	 eax, ecx
  06eba	b9 04 00 00 00	 mov	 ecx, 4
  06ebf	48 6b c9 11	 imul	 rcx, rcx, 17
  06ec3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9160 :         OrResult[18] |= OrConstant[16];

  06ec7	b8 04 00 00 00	 mov	 eax, 4
  06ecc	48 6b c0 12	 imul	 rax, rax, 18
  06ed0	b9 04 00 00 00	 mov	 ecx, 4
  06ed5	48 6b c9 10	 imul	 rcx, rcx, 16
  06ed9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06ee0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06ee3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06ee7	0b c1		 or	 eax, ecx
  06ee9	b9 04 00 00 00	 mov	 ecx, 4
  06eee	48 6b c9 12	 imul	 rcx, rcx, 18
  06ef2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9161 :         OrResult[20] |= OrConstant[19];

  06ef6	b8 04 00 00 00	 mov	 eax, 4
  06efb	48 6b c0 14	 imul	 rax, rax, 20
  06eff	b9 04 00 00 00	 mov	 ecx, 4
  06f04	48 6b c9 13	 imul	 rcx, rcx, 19
  06f08	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06f0f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06f12	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06f16	0b c1		 or	 eax, ecx
  06f18	b9 04 00 00 00	 mov	 ecx, 4
  06f1d	48 6b c9 14	 imul	 rcx, rcx, 20
  06f21	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9162 :         OrResult[23] |= OrConstant[14];

  06f25	b8 04 00 00 00	 mov	 eax, 4
  06f2a	48 6b c0 17	 imul	 rax, rax, 23
  06f2e	b9 04 00 00 00	 mov	 ecx, 4
  06f33	48 6b c9 0e	 imul	 rcx, rcx, 14
  06f37	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06f3e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06f41	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06f45	0b c1		 or	 eax, ecx
  06f47	b9 04 00 00 00	 mov	 ecx, 4
  06f4c	48 6b c9 17	 imul	 rcx, rcx, 23
  06f50	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9163 :         OrResult[24] |= OrConstant[23];

  06f54	b8 04 00 00 00	 mov	 eax, 4
  06f59	48 6b c0 18	 imul	 rax, rax, 24
  06f5d	b9 04 00 00 00	 mov	 ecx, 4
  06f62	48 6b c9 17	 imul	 rcx, rcx, 23
  06f66	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06f6d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06f70	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06f74	0b c1		 or	 eax, ecx
  06f76	b9 04 00 00 00	 mov	 ecx, 4
  06f7b	48 6b c9 18	 imul	 rcx, rcx, 24
  06f7f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9164 :         OrResult[26] |= OrConstant[17];

  06f83	b8 04 00 00 00	 mov	 eax, 4
  06f88	48 6b c0 1a	 imul	 rax, rax, 26
  06f8c	b9 04 00 00 00	 mov	 ecx, 4
  06f91	48 6b c9 11	 imul	 rcx, rcx, 17
  06f95	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06f9c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06f9f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06fa3	0b c1		 or	 eax, ecx
  06fa5	b9 04 00 00 00	 mov	 ecx, 4
  06faa	48 6b c9 1a	 imul	 rcx, rcx, 26
  06fae	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9165 :         OrResult[29] |= OrConstant[22];

  06fb2	b8 04 00 00 00	 mov	 eax, 4
  06fb7	48 6b c0 1d	 imul	 rax, rax, 29
  06fbb	b9 04 00 00 00	 mov	 ecx, 4
  06fc0	48 6b c9 16	 imul	 rcx, rcx, 22
  06fc4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06fcb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06fce	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  06fd2	0b c1		 or	 eax, ecx
  06fd4	b9 04 00 00 00	 mov	 ecx, 4
  06fd9	48 6b c9 1d	 imul	 rcx, rcx, 29
  06fdd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9166 :         OrResult[31] |= OrConstant[12];

  06fe1	b8 04 00 00 00	 mov	 eax, 4
  06fe6	48 6b c0 1f	 imul	 rax, rax, 31
  06fea	b9 04 00 00 00	 mov	 ecx, 4
  06fef	48 6b c9 0c	 imul	 rcx, rcx, 12
  06ff3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  06ffa	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  06ffd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07001	0b c1		 or	 eax, ecx
  07003	b9 04 00 00 00	 mov	 ecx, 4
  07008	48 6b c9 1f	 imul	 rcx, rcx, 31
  0700c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN52@gen_csv_si:

; 9167 :     }
; 9168 :     if ((pClock1[6] & 0x80 ) == 0x80)

  07010	b8 01 00 00 00	 mov	 eax, 1
  07015	48 6b c0 06	 imul	 rax, rax, 6
  07019	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  07021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07025	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0702a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0702f	0f 85 63 02 00
	00		 jne	 $LN53@gen_csv_si

; 9169 :     {
; 9170 :         OrResult[1]  |= OrConstant[11];

  07035	b8 04 00 00 00	 mov	 eax, 4
  0703a	48 6b c0 01	 imul	 rax, rax, 1
  0703e	b9 04 00 00 00	 mov	 ecx, 4
  07043	48 6b c9 0b	 imul	 rcx, rcx, 11
  07047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0704e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07051	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07055	0b c1		 or	 eax, ecx
  07057	b9 04 00 00 00	 mov	 ecx, 4
  0705c	48 6b c9 01	 imul	 rcx, rcx, 1
  07060	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9171 :         OrResult[3]  |= OrConstant[0];

  07064	b8 04 00 00 00	 mov	 eax, 4
  07069	48 6b c0 03	 imul	 rax, rax, 3
  0706d	b9 04 00 00 00	 mov	 ecx, 4
  07072	48 6b c9 00	 imul	 rcx, rcx, 0
  07076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0707d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07080	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07084	0b c1		 or	 eax, ecx
  07086	b9 04 00 00 00	 mov	 ecx, 4
  0708b	48 6b c9 03	 imul	 rcx, rcx, 3
  0708f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9172 :         OrResult[4]  |= OrConstant[5];

  07093	b8 04 00 00 00	 mov	 eax, 4
  07098	48 6b c0 04	 imul	 rax, rax, 4
  0709c	b9 04 00 00 00	 mov	 ecx, 4
  070a1	48 6b c9 05	 imul	 rcx, rcx, 5
  070a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  070ac	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  070af	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  070b3	0b c1		 or	 eax, ecx
  070b5	b9 04 00 00 00	 mov	 ecx, 4
  070ba	48 6b c9 04	 imul	 rcx, rcx, 4
  070be	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9173 :         OrResult[7]  |= OrConstant[7];

  070c2	b8 04 00 00 00	 mov	 eax, 4
  070c7	48 6b c0 07	 imul	 rax, rax, 7
  070cb	b9 04 00 00 00	 mov	 ecx, 4
  070d0	48 6b c9 07	 imul	 rcx, rcx, 7
  070d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  070db	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  070de	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  070e2	0b c1		 or	 eax, ecx
  070e4	b9 04 00 00 00	 mov	 ecx, 4
  070e9	48 6b c9 07	 imul	 rcx, rcx, 7
  070ed	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9174 :         OrResult[10] |= OrConstant[2];

  070f1	b8 04 00 00 00	 mov	 eax, 4
  070f6	48 6b c0 0a	 imul	 rax, rax, 10
  070fa	b9 04 00 00 00	 mov	 ecx, 4
  070ff	48 6b c9 02	 imul	 rcx, rcx, 2
  07103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0710a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0710d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07111	0b c1		 or	 eax, ecx
  07113	b9 04 00 00 00	 mov	 ecx, 4
  07118	48 6b c9 0a	 imul	 rcx, rcx, 10
  0711c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9175 :         OrResult[13] |= OrConstant[10];

  07120	b8 04 00 00 00	 mov	 eax, 4
  07125	48 6b c0 0d	 imul	 rax, rax, 13
  07129	b9 04 00 00 00	 mov	 ecx, 4
  0712e	48 6b c9 0a	 imul	 rcx, rcx, 10
  07132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07139	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0713c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07140	0b c1		 or	 eax, ecx
  07142	b9 04 00 00 00	 mov	 ecx, 4
  07147	48 6b c9 0d	 imul	 rcx, rcx, 13
  0714b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9176 :         OrResult[15] |= OrConstant[2];

  0714f	b8 04 00 00 00	 mov	 eax, 4
  07154	48 6b c0 0f	 imul	 rax, rax, 15
  07158	b9 04 00 00 00	 mov	 ecx, 4
  0715d	48 6b c9 02	 imul	 rcx, rcx, 2
  07161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07168	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0716b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0716f	0b c1		 or	 eax, ecx
  07171	b9 04 00 00 00	 mov	 ecx, 4
  07176	48 6b c9 0f	 imul	 rcx, rcx, 15
  0717a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9177 :         OrResult[17] |= OrConstant[6];

  0717e	b8 04 00 00 00	 mov	 eax, 4
  07183	48 6b c0 11	 imul	 rax, rax, 17
  07187	b9 04 00 00 00	 mov	 ecx, 4
  0718c	48 6b c9 06	 imul	 rcx, rcx, 6
  07190	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07197	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0719a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0719e	0b c1		 or	 eax, ecx
  071a0	b9 04 00 00 00	 mov	 ecx, 4
  071a5	48 6b c9 11	 imul	 rcx, rcx, 17
  071a9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9178 :         OrResult[21] |= OrConstant[9];

  071ad	b8 04 00 00 00	 mov	 eax, 4
  071b2	48 6b c0 15	 imul	 rax, rax, 21
  071b6	b9 04 00 00 00	 mov	 ecx, 4
  071bb	48 6b c9 09	 imul	 rcx, rcx, 9
  071bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  071c6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  071c9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  071cd	0b c1		 or	 eax, ecx
  071cf	b9 04 00 00 00	 mov	 ecx, 4
  071d4	48 6b c9 15	 imul	 rcx, rcx, 21
  071d8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9179 :         OrResult[24] |= OrConstant[3];

  071dc	b8 04 00 00 00	 mov	 eax, 4
  071e1	48 6b c0 18	 imul	 rax, rax, 24
  071e5	b9 04 00 00 00	 mov	 ecx, 4
  071ea	48 6b c9 03	 imul	 rcx, rcx, 3
  071ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  071f5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  071f8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  071fc	0b c1		 or	 eax, ecx
  071fe	b9 04 00 00 00	 mov	 ecx, 4
  07203	48 6b c9 18	 imul	 rcx, rcx, 24
  07207	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9180 :         OrResult[26] |= OrConstant[10];

  0720b	b8 04 00 00 00	 mov	 eax, 4
  07210	48 6b c0 1a	 imul	 rax, rax, 26
  07214	b9 04 00 00 00	 mov	 ecx, 4
  07219	48 6b c9 0a	 imul	 rcx, rcx, 10
  0721d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07224	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07227	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0722b	0b c1		 or	 eax, ecx
  0722d	b9 04 00 00 00	 mov	 ecx, 4
  07232	48 6b c9 1a	 imul	 rcx, rcx, 26
  07236	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9181 :         OrResult[29] |= OrConstant[1];

  0723a	b8 04 00 00 00	 mov	 eax, 4
  0723f	48 6b c0 1d	 imul	 rax, rax, 29
  07243	b9 04 00 00 00	 mov	 ecx, 4
  07248	48 6b c9 01	 imul	 rcx, rcx, 1
  0724c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07253	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07256	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0725a	0b c1		 or	 eax, ecx
  0725c	b9 04 00 00 00	 mov	 ecx, 4
  07261	48 6b c9 1d	 imul	 rcx, rcx, 29
  07265	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9182 :         OrResult[30] |= OrConstant[4];

  07269	b8 04 00 00 00	 mov	 eax, 4
  0726e	48 6b c0 1e	 imul	 rax, rax, 30
  07272	b9 04 00 00 00	 mov	 ecx, 4
  07277	48 6b c9 04	 imul	 rcx, rcx, 4
  0727b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07282	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07285	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07289	0b c1		 or	 eax, ecx
  0728b	b9 04 00 00 00	 mov	 ecx, 4
  07290	48 6b c9 1e	 imul	 rcx, rcx, 30
  07294	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN53@gen_csv_si:

; 9183 :     }
; 9184 :     if ((pClock1[6] & 0x40 ) == 0x40)

  07298	b8 01 00 00 00	 mov	 eax, 1
  0729d	48 6b c0 06	 imul	 rax, rax, 6
  072a1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  072a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  072ad	83 e0 40	 and	 eax, 64			; 00000040H
  072b0	83 f8 40	 cmp	 eax, 64			; 00000040H
  072b3	0f 85 c1 02 00
	00		 jne	 $LN54@gen_csv_si

; 9185 :     {
; 9186 :         OrResult[1]  |= OrConstant[5];

  072b9	b8 04 00 00 00	 mov	 eax, 4
  072be	48 6b c0 01	 imul	 rax, rax, 1
  072c2	b9 04 00 00 00	 mov	 ecx, 4
  072c7	48 6b c9 05	 imul	 rcx, rcx, 5
  072cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  072d2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  072d5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  072d9	0b c1		 or	 eax, ecx
  072db	b9 04 00 00 00	 mov	 ecx, 4
  072e0	48 6b c9 01	 imul	 rcx, rcx, 1
  072e4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9187 :         OrResult[2]  |= OrConstant[2];

  072e8	b8 04 00 00 00	 mov	 eax, 4
  072ed	48 6b c0 02	 imul	 rax, rax, 2
  072f1	b9 04 00 00 00	 mov	 ecx, 4
  072f6	48 6b c9 02	 imul	 rcx, rcx, 2
  072fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07301	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07304	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07308	0b c1		 or	 eax, ecx
  0730a	b9 04 00 00 00	 mov	 ecx, 4
  0730f	48 6b c9 02	 imul	 rcx, rcx, 2
  07313	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9188 :         OrResult[5]  |= OrConstant[10];

  07317	b8 04 00 00 00	 mov	 eax, 4
  0731c	48 6b c0 05	 imul	 rax, rax, 5
  07320	b9 04 00 00 00	 mov	 ecx, 4
  07325	48 6b c9 0a	 imul	 rcx, rcx, 10
  07329	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07330	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07333	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07337	0b c1		 or	 eax, ecx
  07339	b9 04 00 00 00	 mov	 ecx, 4
  0733e	48 6b c9 05	 imul	 rcx, rcx, 5
  07342	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9189 :         OrResult[7]  |= OrConstant[2];

  07346	b8 04 00 00 00	 mov	 eax, 4
  0734b	48 6b c0 07	 imul	 rax, rax, 7
  0734f	b9 04 00 00 00	 mov	 ecx, 4
  07354	48 6b c9 02	 imul	 rcx, rcx, 2
  07358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0735f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07362	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07366	0b c1		 or	 eax, ecx
  07368	b9 04 00 00 00	 mov	 ecx, 4
  0736d	48 6b c9 07	 imul	 rcx, rcx, 7
  07371	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9190 :         OrResult[8]  |= OrConstant[1];

  07375	b8 04 00 00 00	 mov	 eax, 4
  0737a	48 6b c0 08	 imul	 rax, rax, 8
  0737e	b9 04 00 00 00	 mov	 ecx, 4
  07383	48 6b c9 01	 imul	 rcx, rcx, 1
  07387	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0738e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07391	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07395	0b c1		 or	 eax, ecx
  07397	b9 04 00 00 00	 mov	 ecx, 4
  0739c	48 6b c9 08	 imul	 rcx, rcx, 8
  073a0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9191 :         OrResult[10] |= OrConstant[7];

  073a4	b8 04 00 00 00	 mov	 eax, 4
  073a9	48 6b c0 0a	 imul	 rax, rax, 10
  073ad	b9 04 00 00 00	 mov	 ecx, 4
  073b2	48 6b c9 07	 imul	 rcx, rcx, 7
  073b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  073bd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  073c0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  073c4	0b c1		 or	 eax, ecx
  073c6	b9 04 00 00 00	 mov	 ecx, 4
  073cb	48 6b c9 0a	 imul	 rcx, rcx, 10
  073cf	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9192 :         OrResult[13] |= OrConstant[4];

  073d3	b8 04 00 00 00	 mov	 eax, 4
  073d8	48 6b c0 0d	 imul	 rax, rax, 13
  073dc	b9 04 00 00 00	 mov	 ecx, 4
  073e1	48 6b c9 04	 imul	 rcx, rcx, 4
  073e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  073ec	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  073ef	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  073f3	0b c1		 or	 eax, ecx
  073f5	b9 04 00 00 00	 mov	 ecx, 4
  073fa	48 6b c9 0d	 imul	 rcx, rcx, 13
  073fe	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9193 :         OrResult[14] |= OrConstant[6];

  07402	b8 04 00 00 00	 mov	 eax, 4
  07407	48 6b c0 0e	 imul	 rax, rax, 14
  0740b	b9 04 00 00 00	 mov	 ecx, 4
  07410	48 6b c9 06	 imul	 rcx, rcx, 6
  07414	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0741b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0741e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07422	0b c1		 or	 eax, ecx
  07424	b9 04 00 00 00	 mov	 ecx, 4
  07429	48 6b c9 0e	 imul	 rcx, rcx, 14
  0742d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9194 :         OrResult[16] |= OrConstant[3];

  07431	b8 04 00 00 00	 mov	 eax, 4
  07436	48 6b c0 10	 imul	 rax, rax, 16
  0743a	b9 04 00 00 00	 mov	 ecx, 4
  0743f	48 6b c9 03	 imul	 rcx, rcx, 3
  07443	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0744a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0744d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07451	0b c1		 or	 eax, ecx
  07453	b9 04 00 00 00	 mov	 ecx, 4
  07458	48 6b c9 10	 imul	 rcx, rcx, 16
  0745c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9195 :         OrResult[18] |= OrConstant[10];

  07460	b8 04 00 00 00	 mov	 eax, 4
  07465	48 6b c0 12	 imul	 rax, rax, 18
  07469	b9 04 00 00 00	 mov	 ecx, 4
  0746e	48 6b c9 0a	 imul	 rcx, rcx, 10
  07472	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07479	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0747c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07480	0b c1		 or	 eax, ecx
  07482	b9 04 00 00 00	 mov	 ecx, 4
  07487	48 6b c9 12	 imul	 rcx, rcx, 18
  0748b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9196 :         OrResult[21] |= OrConstant[1];

  0748f	b8 04 00 00 00	 mov	 eax, 4
  07494	48 6b c0 15	 imul	 rax, rax, 21
  07498	b9 04 00 00 00	 mov	 ecx, 4
  0749d	48 6b c9 01	 imul	 rcx, rcx, 1
  074a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  074a8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  074ab	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  074af	0b c1		 or	 eax, ecx
  074b1	b9 04 00 00 00	 mov	 ecx, 4
  074b6	48 6b c9 15	 imul	 rcx, rcx, 21
  074ba	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9197 :         OrResult[23] |= OrConstant[11];

  074be	b8 04 00 00 00	 mov	 eax, 4
  074c3	48 6b c0 17	 imul	 rax, rax, 23
  074c7	b9 04 00 00 00	 mov	 ecx, 4
  074cc	48 6b c9 0b	 imul	 rcx, rcx, 11
  074d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  074d7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  074da	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  074de	0b c1		 or	 eax, ecx
  074e0	b9 04 00 00 00	 mov	 ecx, 4
  074e5	48 6b c9 17	 imul	 rcx, rcx, 23
  074e9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9198 :         OrResult[24] |= OrConstant[9];

  074ed	b8 04 00 00 00	 mov	 eax, 4
  074f2	48 6b c0 18	 imul	 rax, rax, 24
  074f6	b9 04 00 00 00	 mov	 ecx, 4
  074fb	48 6b c9 09	 imul	 rcx, rcx, 9
  074ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07506	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07509	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0750d	0b c1		 or	 eax, ecx
  0750f	b9 04 00 00 00	 mov	 ecx, 4
  07514	48 6b c9 18	 imul	 rcx, rcx, 24
  07518	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9199 :         OrResult[27] |= OrConstant[3];

  0751c	b8 04 00 00 00	 mov	 eax, 4
  07521	48 6b c0 1b	 imul	 rax, rax, 27
  07525	b9 04 00 00 00	 mov	 ecx, 4
  0752a	48 6b c9 03	 imul	 rcx, rcx, 3
  0752e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07535	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07538	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0753c	0b c1		 or	 eax, ecx
  0753e	b9 04 00 00 00	 mov	 ecx, 4
  07543	48 6b c9 1b	 imul	 rcx, rcx, 27
  07547	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9200 :         OrResult[28] |= OrConstant[11];

  0754b	b8 04 00 00 00	 mov	 eax, 4
  07550	48 6b c0 1c	 imul	 rax, rax, 28
  07554	b9 04 00 00 00	 mov	 ecx, 4
  07559	48 6b c9 0b	 imul	 rcx, rcx, 11
  0755d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07564	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07567	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0756b	0b c1		 or	 eax, ecx
  0756d	b9 04 00 00 00	 mov	 ecx, 4
  07572	48 6b c9 1c	 imul	 rcx, rcx, 28
  07576	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN54@gen_csv_si:

; 9201 :     }
; 9202 :     if ((pClock1[6] & 0x20 ) == 0x20)

  0757a	b8 01 00 00 00	 mov	 eax, 1
  0757f	48 6b c0 06	 imul	 rax, rax, 6
  07583	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0758b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0758f	83 e0 20	 and	 eax, 32			; 00000020H
  07592	83 f8 20	 cmp	 eax, 32			; 00000020H
  07595	0f 85 92 02 00
	00		 jne	 $LN55@gen_csv_si

; 9203 :     {
; 9204 :         OrResult[2]  |= OrConstant[7];

  0759b	b8 04 00 00 00	 mov	 eax, 4
  075a0	48 6b c0 02	 imul	 rax, rax, 2
  075a4	b9 04 00 00 00	 mov	 ecx, 4
  075a9	48 6b c9 07	 imul	 rcx, rcx, 7
  075ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  075b4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  075b7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  075bb	0b c1		 or	 eax, ecx
  075bd	b9 04 00 00 00	 mov	 ecx, 4
  075c2	48 6b c9 02	 imul	 rcx, rcx, 2
  075c6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9205 :         OrResult[5]  |= OrConstant[4];

  075ca	b8 04 00 00 00	 mov	 eax, 4
  075cf	48 6b c0 05	 imul	 rax, rax, 5
  075d3	b9 04 00 00 00	 mov	 ecx, 4
  075d8	48 6b c9 04	 imul	 rcx, rcx, 4
  075dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  075e3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  075e6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  075ea	0b c1		 or	 eax, ecx
  075ec	b9 04 00 00 00	 mov	 ecx, 4
  075f1	48 6b c9 05	 imul	 rcx, rcx, 5
  075f5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9206 :         OrResult[6]  |= OrConstant[6];

  075f9	b8 04 00 00 00	 mov	 eax, 4
  075fe	48 6b c0 06	 imul	 rax, rax, 6
  07602	b9 04 00 00 00	 mov	 ecx, 4
  07607	48 6b c9 06	 imul	 rcx, rcx, 6
  0760b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07612	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07615	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07619	0b c1		 or	 eax, ecx
  0761b	b9 04 00 00 00	 mov	 ecx, 4
  07620	48 6b c9 06	 imul	 rcx, rcx, 6
  07624	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9207 :         OrResult[11] |= OrConstant[8];

  07628	b8 04 00 00 00	 mov	 eax, 4
  0762d	48 6b c0 0b	 imul	 rax, rax, 11
  07631	b9 04 00 00 00	 mov	 ecx, 4
  07636	48 6b c9 08	 imul	 rcx, rcx, 8
  0763a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07641	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07644	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07648	0b c1		 or	 eax, ecx
  0764a	b9 04 00 00 00	 mov	 ecx, 4
  0764f	48 6b c9 0b	 imul	 rcx, rcx, 11
  07653	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9208 :         OrResult[12] |= OrConstant[4];

  07657	b8 04 00 00 00	 mov	 eax, 4
  0765c	48 6b c0 0c	 imul	 rax, rax, 12
  07660	b9 04 00 00 00	 mov	 ecx, 4
  07665	48 6b c9 04	 imul	 rcx, rcx, 4
  07669	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07670	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07673	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07677	0b c1		 or	 eax, ecx
  07679	b9 04 00 00 00	 mov	 ecx, 4
  0767e	48 6b c9 0c	 imul	 rcx, rcx, 12
  07682	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9209 :         OrResult[15] |= OrConstant[0];

  07686	b8 04 00 00 00	 mov	 eax, 4
  0768b	48 6b c0 0f	 imul	 rax, rax, 15
  0768f	b9 04 00 00 00	 mov	 ecx, 4
  07694	48 6b c9 00	 imul	 rcx, rcx, 0
  07698	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0769f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  076a2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  076a6	0b c1		 or	 eax, ecx
  076a8	b9 04 00 00 00	 mov	 ecx, 4
  076ad	48 6b c9 0f	 imul	 rcx, rcx, 15
  076b1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9210 :         OrResult[16] |= OrConstant[9];

  076b5	b8 04 00 00 00	 mov	 eax, 4
  076ba	48 6b c0 10	 imul	 rax, rax, 16
  076be	b9 04 00 00 00	 mov	 ecx, 4
  076c3	48 6b c9 09	 imul	 rcx, rcx, 9
  076c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  076ce	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  076d1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  076d5	0b c1		 or	 eax, ecx
  076d7	b9 04 00 00 00	 mov	 ecx, 4
  076dc	48 6b c9 10	 imul	 rcx, rcx, 16
  076e0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9211 :         OrResult[19] |= OrConstant[3];

  076e4	b8 04 00 00 00	 mov	 eax, 4
  076e9	48 6b c0 13	 imul	 rax, rax, 19
  076ed	b9 04 00 00 00	 mov	 ecx, 4
  076f2	48 6b c9 03	 imul	 rcx, rcx, 3
  076f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  076fd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07700	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07704	0b c1		 or	 eax, ecx
  07706	b9 04 00 00 00	 mov	 ecx, 4
  0770b	48 6b c9 13	 imul	 rcx, rcx, 19
  0770f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9212 :         OrResult[20] |= OrConstant[11];

  07713	b8 04 00 00 00	 mov	 eax, 4
  07718	48 6b c0 14	 imul	 rax, rax, 20
  0771c	b9 04 00 00 00	 mov	 ecx, 4
  07721	48 6b c9 0b	 imul	 rcx, rcx, 11
  07725	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0772c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0772f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07733	0b c1		 or	 eax, ecx
  07735	b9 04 00 00 00	 mov	 ecx, 4
  0773a	48 6b c9 14	 imul	 rcx, rcx, 20
  0773e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9213 :         OrResult[23] |= OrConstant[5];

  07742	b8 04 00 00 00	 mov	 eax, 4
  07747	48 6b c0 17	 imul	 rax, rax, 23
  0774b	b9 04 00 00 00	 mov	 ecx, 4
  07750	48 6b c9 05	 imul	 rcx, rcx, 5
  07754	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0775b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0775e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07762	0b c1		 or	 eax, ecx
  07764	b9 04 00 00 00	 mov	 ecx, 4
  07769	48 6b c9 17	 imul	 rcx, rcx, 23
  0776d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9214 :         OrResult[24] |= OrConstant[8];

  07771	b8 04 00 00 00	 mov	 eax, 4
  07776	48 6b c0 18	 imul	 rax, rax, 24
  0777a	b9 04 00 00 00	 mov	 ecx, 4
  0777f	48 6b c9 08	 imul	 rcx, rcx, 8
  07783	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0778a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0778d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07791	0b c1		 or	 eax, ecx
  07793	b9 04 00 00 00	 mov	 ecx, 4
  07798	48 6b c9 18	 imul	 rcx, rcx, 24
  0779c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9215 :         OrResult[26] |= OrConstant[0];

  077a0	b8 04 00 00 00	 mov	 eax, 4
  077a5	48 6b c0 1a	 imul	 rax, rax, 26
  077a9	b9 04 00 00 00	 mov	 ecx, 4
  077ae	48 6b c9 00	 imul	 rcx, rcx, 0
  077b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  077b9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  077bc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  077c0	0b c1		 or	 eax, ecx
  077c2	b9 04 00 00 00	 mov	 ecx, 4
  077c7	48 6b c9 1a	 imul	 rcx, rcx, 26
  077cb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9216 :         OrResult[29] |= OrConstant[6];

  077cf	b8 04 00 00 00	 mov	 eax, 4
  077d4	48 6b c0 1d	 imul	 rax, rax, 29
  077d8	b9 04 00 00 00	 mov	 ecx, 4
  077dd	48 6b c9 06	 imul	 rcx, rcx, 6
  077e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  077e8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  077eb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  077ef	0b c1		 or	 eax, ecx
  077f1	b9 04 00 00 00	 mov	 ecx, 4
  077f6	48 6b c9 1d	 imul	 rcx, rcx, 29
  077fa	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9217 :         OrResult[30] |= OrConstant[1];

  077fe	b8 04 00 00 00	 mov	 eax, 4
  07803	48 6b c0 1e	 imul	 rax, rax, 30
  07807	b9 04 00 00 00	 mov	 ecx, 4
  0780c	48 6b c9 01	 imul	 rcx, rcx, 1
  07810	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07817	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0781a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0781e	0b c1		 or	 eax, ecx
  07820	b9 04 00 00 00	 mov	 ecx, 4
  07825	48 6b c9 1e	 imul	 rcx, rcx, 30
  07829	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN55@gen_csv_si:

; 9218 :     }
; 9219 :     if ((pClock1[6] & 0x10 ) == 0x10)

  0782d	b8 01 00 00 00	 mov	 eax, 1
  07832	48 6b c0 06	 imul	 rax, rax, 6
  07836	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0783e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07842	83 e0 10	 and	 eax, 16
  07845	83 f8 10	 cmp	 eax, 16
  07848	0f 85 34 02 00
	00		 jne	 $LN56@gen_csv_si

; 9220 :     {
; 9221 :         OrResult[0]  |= OrConstant[10];

  0784e	b8 04 00 00 00	 mov	 eax, 4
  07853	48 6b c0 00	 imul	 rax, rax, 0
  07857	b9 04 00 00 00	 mov	 ecx, 4
  0785c	48 6b c9 0a	 imul	 rcx, rcx, 10
  07860	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07867	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0786a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0786e	0b c1		 or	 eax, ecx
  07870	b9 04 00 00 00	 mov	 ecx, 4
  07875	48 6b c9 00	 imul	 rcx, rcx, 0
  07879	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9222 :         OrResult[3]  |= OrConstant[8];

  0787d	b8 04 00 00 00	 mov	 eax, 4
  07882	48 6b c0 03	 imul	 rax, rax, 3
  07886	b9 04 00 00 00	 mov	 ecx, 4
  0788b	48 6b c9 08	 imul	 rcx, rcx, 8
  0788f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07896	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07899	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0789d	0b c1		 or	 eax, ecx
  0789f	b9 04 00 00 00	 mov	 ecx, 4
  078a4	48 6b c9 03	 imul	 rcx, rcx, 3
  078a8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9223 :         OrResult[4]  |= OrConstant[4];

  078ac	b8 04 00 00 00	 mov	 eax, 4
  078b1	48 6b c0 04	 imul	 rax, rax, 4
  078b5	b9 04 00 00 00	 mov	 ecx, 4
  078ba	48 6b c9 04	 imul	 rcx, rcx, 4
  078be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  078c5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  078c8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  078cc	0b c1		 or	 eax, ecx
  078ce	b9 04 00 00 00	 mov	 ecx, 4
  078d3	48 6b c9 04	 imul	 rcx, rcx, 4
  078d7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9224 :         OrResult[7]  |= OrConstant[0];

  078db	b8 04 00 00 00	 mov	 eax, 4
  078e0	48 6b c0 07	 imul	 rax, rax, 7
  078e4	b9 04 00 00 00	 mov	 ecx, 4
  078e9	48 6b c9 00	 imul	 rcx, rcx, 0
  078ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  078f4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  078f7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  078fb	0b c1		 or	 eax, ecx
  078fd	b9 04 00 00 00	 mov	 ecx, 4
  07902	48 6b c9 07	 imul	 rcx, rcx, 7
  07906	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9225 :         OrResult[8]  |= OrConstant[5];

  0790a	b8 04 00 00 00	 mov	 eax, 4
  0790f	48 6b c0 08	 imul	 rax, rax, 8
  07913	b9 04 00 00 00	 mov	 ecx, 4
  07918	48 6b c9 05	 imul	 rcx, rcx, 5
  0791c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07923	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07926	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0792a	0b c1		 or	 eax, ecx
  0792c	b9 04 00 00 00	 mov	 ecx, 4
  07931	48 6b c9 08	 imul	 rcx, rcx, 8
  07935	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9226 :         OrResult[11] |= OrConstant[7];

  07939	b8 04 00 00 00	 mov	 eax, 4
  0793e	48 6b c0 0b	 imul	 rax, rax, 11
  07942	b9 04 00 00 00	 mov	 ecx, 4
  07947	48 6b c9 07	 imul	 rcx, rcx, 7
  0794b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07952	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07955	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07959	0b c1		 or	 eax, ecx
  0795b	b9 04 00 00 00	 mov	 ecx, 4
  07960	48 6b c9 0b	 imul	 rcx, rcx, 11
  07964	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9227 :         OrResult[14] |= OrConstant[2];

  07968	b8 04 00 00 00	 mov	 eax, 4
  0796d	48 6b c0 0e	 imul	 rax, rax, 14
  07971	b9 04 00 00 00	 mov	 ecx, 4
  07976	48 6b c9 02	 imul	 rcx, rcx, 2
  0797a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07981	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07984	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07988	0b c1		 or	 eax, ecx
  0798a	b9 04 00 00 00	 mov	 ecx, 4
  0798f	48 6b c9 0e	 imul	 rcx, rcx, 14
  07993	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9228 :         OrResult[16] |= OrConstant[8];

  07997	b8 04 00 00 00	 mov	 eax, 4
  0799c	48 6b c0 10	 imul	 rax, rax, 16
  079a0	b9 04 00 00 00	 mov	 ecx, 4
  079a5	48 6b c9 08	 imul	 rcx, rcx, 8
  079a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  079b0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  079b3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  079b7	0b c1		 or	 eax, ecx
  079b9	b9 04 00 00 00	 mov	 ecx, 4
  079be	48 6b c9 10	 imul	 rcx, rcx, 16
  079c2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9229 :         OrResult[18] |= OrConstant[0];

  079c6	b8 04 00 00 00	 mov	 eax, 4
  079cb	48 6b c0 12	 imul	 rax, rax, 18
  079cf	b9 04 00 00 00	 mov	 ecx, 4
  079d4	48 6b c9 00	 imul	 rcx, rcx, 0
  079d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  079df	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  079e2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  079e6	0b c1		 or	 eax, ecx
  079e8	b9 04 00 00 00	 mov	 ecx, 4
  079ed	48 6b c9 12	 imul	 rcx, rcx, 18
  079f1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9230 :         OrResult[21] |= OrConstant[6];

  079f5	b8 04 00 00 00	 mov	 eax, 4
  079fa	48 6b c0 15	 imul	 rax, rax, 21
  079fe	b9 04 00 00 00	 mov	 ecx, 4
  07a03	48 6b c9 06	 imul	 rcx, rcx, 6
  07a07	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07a0e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07a11	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07a15	0b c1		 or	 eax, ecx
  07a17	b9 04 00 00 00	 mov	 ecx, 4
  07a1c	48 6b c9 15	 imul	 rcx, rcx, 21
  07a20	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9231 :         OrResult[25] |= OrConstant[9];

  07a24	b8 04 00 00 00	 mov	 eax, 4
  07a29	48 6b c0 19	 imul	 rax, rax, 25
  07a2d	b9 04 00 00 00	 mov	 ecx, 4
  07a32	48 6b c9 09	 imul	 rcx, rcx, 9
  07a36	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07a3d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07a40	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07a44	0b c1		 or	 eax, ecx
  07a46	b9 04 00 00 00	 mov	 ecx, 4
  07a4b	48 6b c9 19	 imul	 rcx, rcx, 25
  07a4f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9232 :         OrResult[28] |= OrConstant[3];

  07a53	b8 04 00 00 00	 mov	 eax, 4
  07a58	48 6b c0 1c	 imul	 rax, rax, 28
  07a5c	b9 04 00 00 00	 mov	 ecx, 4
  07a61	48 6b c9 03	 imul	 rcx, rcx, 3
  07a65	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07a6c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07a6f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07a73	0b c1		 or	 eax, ecx
  07a75	b9 04 00 00 00	 mov	 ecx, 4
  07a7a	48 6b c9 1c	 imul	 rcx, rcx, 28
  07a7e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN56@gen_csv_si:

; 9233 :     }
; 9234 :     if ((pClock1[6] & 0x08 ) == 0x08)

  07a82	b8 01 00 00 00	 mov	 eax, 1
  07a87	48 6b c0 06	 imul	 rax, rax, 6
  07a8b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  07a93	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07a97	83 e0 08	 and	 eax, 8
  07a9a	83 f8 08	 cmp	 eax, 8
  07a9d	0f 85 c1 02 00
	00		 jne	 $LN57@gen_csv_si

; 9235 :     {
; 9236 :         OrResult[1]  |= OrConstant[18];

  07aa3	b8 04 00 00 00	 mov	 eax, 4
  07aa8	48 6b c0 01	 imul	 rax, rax, 1
  07aac	b9 04 00 00 00	 mov	 ecx, 4
  07ab1	48 6b c9 12	 imul	 rcx, rcx, 18
  07ab5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07abc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07abf	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07ac3	0b c1		 or	 eax, ecx
  07ac5	b9 04 00 00 00	 mov	 ecx, 4
  07aca	48 6b c9 01	 imul	 rcx, rcx, 1
  07ace	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9237 :         OrResult[2]  |= OrConstant[16];

  07ad2	b8 04 00 00 00	 mov	 eax, 4
  07ad7	48 6b c0 02	 imul	 rax, rax, 2
  07adb	b9 04 00 00 00	 mov	 ecx, 4
  07ae0	48 6b c9 10	 imul	 rcx, rcx, 16
  07ae4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07aeb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07aee	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07af2	0b c1		 or	 eax, ecx
  07af4	b9 04 00 00 00	 mov	 ecx, 4
  07af9	48 6b c9 02	 imul	 rcx, rcx, 2
  07afd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9238 :         OrResult[4]  |= OrConstant[19];

  07b01	b8 04 00 00 00	 mov	 eax, 4
  07b06	48 6b c0 04	 imul	 rax, rax, 4
  07b0a	b9 04 00 00 00	 mov	 ecx, 4
  07b0f	48 6b c9 13	 imul	 rcx, rcx, 19
  07b13	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07b1a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07b1d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07b21	0b c1		 or	 eax, ecx
  07b23	b9 04 00 00 00	 mov	 ecx, 4
  07b28	48 6b c9 04	 imul	 rcx, rcx, 4
  07b2c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9239 :         OrResult[7]  |= OrConstant[14];

  07b30	b8 04 00 00 00	 mov	 eax, 4
  07b35	48 6b c0 07	 imul	 rax, rax, 7
  07b39	b9 04 00 00 00	 mov	 ecx, 4
  07b3e	48 6b c9 0e	 imul	 rcx, rcx, 14
  07b42	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07b49	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07b4c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07b50	0b c1		 or	 eax, ecx
  07b52	b9 04 00 00 00	 mov	 ecx, 4
  07b57	48 6b c9 07	 imul	 rcx, rcx, 7
  07b5b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9240 :         OrResult[8]  |= OrConstant[23];

  07b5f	b8 04 00 00 00	 mov	 eax, 4
  07b64	48 6b c0 08	 imul	 rax, rax, 8
  07b68	b9 04 00 00 00	 mov	 ecx, 4
  07b6d	48 6b c9 17	 imul	 rcx, rcx, 23
  07b71	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07b78	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07b7b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07b7f	0b c1		 or	 eax, ecx
  07b81	b9 04 00 00 00	 mov	 ecx, 4
  07b86	48 6b c9 08	 imul	 rcx, rcx, 8
  07b8a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9241 :         OrResult[10] |= OrConstant[17];

  07b8e	b8 04 00 00 00	 mov	 eax, 4
  07b93	48 6b c0 0a	 imul	 rax, rax, 10
  07b97	b9 04 00 00 00	 mov	 ecx, 4
  07b9c	48 6b c9 11	 imul	 rcx, rcx, 17
  07ba0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07ba7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07baa	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07bae	0b c1		 or	 eax, ecx
  07bb0	b9 04 00 00 00	 mov	 ecx, 4
  07bb5	48 6b c9 0a	 imul	 rcx, rcx, 10
  07bb9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9242 :         OrResult[13] |= OrConstant[22];

  07bbd	b8 04 00 00 00	 mov	 eax, 4
  07bc2	48 6b c0 0d	 imul	 rax, rax, 13
  07bc6	b9 04 00 00 00	 mov	 ecx, 4
  07bcb	48 6b c9 16	 imul	 rcx, rcx, 22
  07bcf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07bd6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07bd9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07bdd	0b c1		 or	 eax, ecx
  07bdf	b9 04 00 00 00	 mov	 ecx, 4
  07be4	48 6b c9 0d	 imul	 rcx, rcx, 13
  07be8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9243 :         OrResult[14] |= OrConstant[14];

  07bec	b8 04 00 00 00	 mov	 eax, 4
  07bf1	48 6b c0 0e	 imul	 rax, rax, 14
  07bf5	b9 04 00 00 00	 mov	 ecx, 4
  07bfa	48 6b c9 0e	 imul	 rcx, rcx, 14
  07bfe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07c05	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07c08	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07c0c	0b c1		 or	 eax, ecx
  07c0e	b9 04 00 00 00	 mov	 ecx, 4
  07c13	48 6b c9 0e	 imul	 rcx, rcx, 14
  07c17	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9244 :         OrResult[17] |= OrConstant[23];

  07c1b	b8 04 00 00 00	 mov	 eax, 4
  07c20	48 6b c0 11	 imul	 rax, rax, 17
  07c24	b9 04 00 00 00	 mov	 ecx, 4
  07c29	48 6b c9 17	 imul	 rcx, rcx, 23
  07c2d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07c34	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07c37	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07c3b	0b c1		 or	 eax, ecx
  07c3d	b9 04 00 00 00	 mov	 ecx, 4
  07c42	48 6b c9 11	 imul	 rcx, rcx, 17
  07c46	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9245 :         OrResult[18] |= OrConstant[22];

  07c4a	b8 04 00 00 00	 mov	 eax, 4
  07c4f	48 6b c0 12	 imul	 rax, rax, 18
  07c53	b9 04 00 00 00	 mov	 ecx, 4
  07c58	48 6b c9 16	 imul	 rcx, rcx, 22
  07c5c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07c63	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07c66	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07c6a	0b c1		 or	 eax, ecx
  07c6c	b9 04 00 00 00	 mov	 ecx, 4
  07c71	48 6b c9 12	 imul	 rcx, rcx, 18
  07c75	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9246 :         OrResult[21] |= OrConstant[21];

  07c79	b8 04 00 00 00	 mov	 eax, 4
  07c7e	48 6b c0 15	 imul	 rax, rax, 21
  07c82	b9 04 00 00 00	 mov	 ecx, 4
  07c87	48 6b c9 15	 imul	 rcx, rcx, 21
  07c8b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07c92	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07c95	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07c99	0b c1		 or	 eax, ecx
  07c9b	b9 04 00 00 00	 mov	 ecx, 4
  07ca0	48 6b c9 15	 imul	 rcx, rcx, 21
  07ca4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9247 :         OrResult[25] |= OrConstant[13];

  07ca8	b8 04 00 00 00	 mov	 eax, 4
  07cad	48 6b c0 19	 imul	 rax, rax, 25
  07cb1	b9 04 00 00 00	 mov	 ecx, 4
  07cb6	48 6b c9 0d	 imul	 rcx, rcx, 13
  07cba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07cc1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07cc4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07cc8	0b c1		 or	 eax, ecx
  07cca	b9 04 00 00 00	 mov	 ecx, 4
  07ccf	48 6b c9 19	 imul	 rcx, rcx, 25
  07cd3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9248 :         OrResult[27] |= OrConstant[19];

  07cd7	b8 04 00 00 00	 mov	 eax, 4
  07cdc	48 6b c0 1b	 imul	 rax, rax, 27
  07ce0	b9 04 00 00 00	 mov	 ecx, 4
  07ce5	48 6b c9 13	 imul	 rcx, rcx, 19
  07ce9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07cf0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07cf3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07cf7	0b c1		 or	 eax, ecx
  07cf9	b9 04 00 00 00	 mov	 ecx, 4
  07cfe	48 6b c9 1b	 imul	 rcx, rcx, 27
  07d02	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9249 :         OrResult[28] |= OrConstant[18];

  07d06	b8 04 00 00 00	 mov	 eax, 4
  07d0b	48 6b c0 1c	 imul	 rax, rax, 28
  07d0f	b9 04 00 00 00	 mov	 ecx, 4
  07d14	48 6b c9 12	 imul	 rcx, rcx, 18
  07d18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07d1f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07d22	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07d26	0b c1		 or	 eax, ecx
  07d28	b9 04 00 00 00	 mov	 ecx, 4
  07d2d	48 6b c9 1c	 imul	 rcx, rcx, 28
  07d31	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9250 :         OrResult[31] |= OrConstant[15];

  07d35	b8 04 00 00 00	 mov	 eax, 4
  07d3a	48 6b c0 1f	 imul	 rax, rax, 31
  07d3e	b9 04 00 00 00	 mov	 ecx, 4
  07d43	48 6b c9 0f	 imul	 rcx, rcx, 15
  07d47	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07d4e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07d51	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07d55	0b c1		 or	 eax, ecx
  07d57	b9 04 00 00 00	 mov	 ecx, 4
  07d5c	48 6b c9 1f	 imul	 rcx, rcx, 31
  07d60	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN57@gen_csv_si:

; 9251 :     }
; 9252 :     if ((pClock1[6] & 0x04 ) == 0x04)

  07d64	b8 01 00 00 00	 mov	 eax, 1
  07d69	48 6b c0 06	 imul	 rax, rax, 6
  07d6d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  07d75	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07d79	83 e0 04	 and	 eax, 4
  07d7c	83 f8 04	 cmp	 eax, 4
  07d7f	0f 85 63 02 00
	00		 jne	 $LN58@gen_csv_si

; 9253 :     {
; 9254 :         OrResult[2]  |= OrConstant[20];

  07d85	b8 04 00 00 00	 mov	 eax, 4
  07d8a	48 6b c0 02	 imul	 rax, rax, 2
  07d8e	b9 04 00 00 00	 mov	 ecx, 4
  07d93	48 6b c9 14	 imul	 rcx, rcx, 20
  07d97	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07d9e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07da1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07da5	0b c1		 or	 eax, ecx
  07da7	b9 04 00 00 00	 mov	 ecx, 4
  07dac	48 6b c9 02	 imul	 rcx, rcx, 2
  07db0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9255 :         OrResult[4]  |= OrConstant[12];

  07db4	b8 04 00 00 00	 mov	 eax, 4
  07db9	48 6b c0 04	 imul	 rax, rax, 4
  07dbd	b9 04 00 00 00	 mov	 ecx, 4
  07dc2	48 6b c9 0c	 imul	 rcx, rcx, 12
  07dc6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07dcd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07dd0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07dd4	0b c1		 or	 eax, ecx
  07dd6	b9 04 00 00 00	 mov	 ecx, 4
  07ddb	48 6b c9 04	 imul	 rcx, rcx, 4
  07ddf	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9256 :         OrResult[9]  |= OrConstant[15];

  07de3	b8 04 00 00 00	 mov	 eax, 4
  07de8	48 6b c0 09	 imul	 rax, rax, 9
  07dec	b9 04 00 00 00	 mov	 ecx, 4
  07df1	48 6b c9 0f	 imul	 rcx, rcx, 15
  07df5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07dfc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07dff	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07e03	0b c1		 or	 eax, ecx
  07e05	b9 04 00 00 00	 mov	 ecx, 4
  07e0a	48 6b c9 09	 imul	 rcx, rcx, 9
  07e0e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9257 :         OrResult[10] |= OrConstant[16];

  07e12	b8 04 00 00 00	 mov	 eax, 4
  07e17	48 6b c0 0a	 imul	 rax, rax, 10
  07e1b	b9 04 00 00 00	 mov	 ecx, 4
  07e20	48 6b c9 10	 imul	 rcx, rcx, 16
  07e24	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07e2b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07e2e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07e32	0b c1		 or	 eax, ecx
  07e34	b9 04 00 00 00	 mov	 ecx, 4
  07e39	48 6b c9 0a	 imul	 rcx, rcx, 10
  07e3d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9258 :         OrResult[12] |= OrConstant[19];

  07e41	b8 04 00 00 00	 mov	 eax, 4
  07e46	48 6b c0 0c	 imul	 rax, rax, 12
  07e4a	b9 04 00 00 00	 mov	 ecx, 4
  07e4f	48 6b c9 13	 imul	 rcx, rcx, 19
  07e53	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07e5a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07e5d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07e61	0b c1		 or	 eax, ecx
  07e63	b9 04 00 00 00	 mov	 ecx, 4
  07e68	48 6b c9 0c	 imul	 rcx, rcx, 12
  07e6c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9259 :         OrResult[15] |= OrConstant[14];

  07e70	b8 04 00 00 00	 mov	 eax, 4
  07e75	48 6b c0 0f	 imul	 rax, rax, 15
  07e79	b9 04 00 00 00	 mov	 ecx, 4
  07e7e	48 6b c9 0e	 imul	 rcx, rcx, 14
  07e82	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07e89	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07e8c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07e90	0b c1		 or	 eax, ecx
  07e92	b9 04 00 00 00	 mov	 ecx, 4
  07e97	48 6b c9 0f	 imul	 rcx, rcx, 15
  07e9b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9260 :         OrResult[16] |= OrConstant[13];

  07e9f	b8 04 00 00 00	 mov	 eax, 4
  07ea4	48 6b c0 10	 imul	 rax, rax, 16
  07ea8	b9 04 00 00 00	 mov	 ecx, 4
  07ead	48 6b c9 0d	 imul	 rcx, rcx, 13
  07eb1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07eb8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07ebb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07ebf	0b c1		 or	 eax, ecx
  07ec1	b9 04 00 00 00	 mov	 ecx, 4
  07ec6	48 6b c9 10	 imul	 rcx, rcx, 16
  07eca	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9261 :         OrResult[20] |= OrConstant[21];

  07ece	b8 04 00 00 00	 mov	 eax, 4
  07ed3	48 6b c0 14	 imul	 rax, rax, 20
  07ed7	b9 04 00 00 00	 mov	 ecx, 4
  07edc	48 6b c9 15	 imul	 rcx, rcx, 21
  07ee0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07ee7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07eea	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07eee	0b c1		 or	 eax, ecx
  07ef0	b9 04 00 00 00	 mov	 ecx, 4
  07ef5	48 6b c9 14	 imul	 rcx, rcx, 20
  07ef9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9262 :         OrResult[23] |= OrConstant[12];

  07efd	b8 04 00 00 00	 mov	 eax, 4
  07f02	48 6b c0 17	 imul	 rax, rax, 23
  07f06	b9 04 00 00 00	 mov	 ecx, 4
  07f0b	48 6b c9 0c	 imul	 rcx, rcx, 12
  07f0f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07f16	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07f19	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07f1d	0b c1		 or	 eax, ecx
  07f1f	b9 04 00 00 00	 mov	 ecx, 4
  07f24	48 6b c9 17	 imul	 rcx, rcx, 23
  07f28	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9263 :         OrResult[25] |= OrConstant[23];

  07f2c	b8 04 00 00 00	 mov	 eax, 4
  07f31	48 6b c0 19	 imul	 rax, rax, 25
  07f35	b9 04 00 00 00	 mov	 ecx, 4
  07f3a	48 6b c9 17	 imul	 rcx, rcx, 23
  07f3e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07f45	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07f48	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07f4c	0b c1		 or	 eax, ecx
  07f4e	b9 04 00 00 00	 mov	 ecx, 4
  07f53	48 6b c9 19	 imul	 rcx, rcx, 25
  07f57	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9264 :         OrResult[26] |= OrConstant[22];

  07f5b	b8 04 00 00 00	 mov	 eax, 4
  07f60	48 6b c0 1a	 imul	 rax, rax, 26
  07f64	b9 04 00 00 00	 mov	 ecx, 4
  07f69	48 6b c9 16	 imul	 rcx, rcx, 22
  07f6d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07f74	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07f77	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07f7b	0b c1		 or	 eax, ecx
  07f7d	b9 04 00 00 00	 mov	 ecx, 4
  07f82	48 6b c9 1a	 imul	 rcx, rcx, 26
  07f86	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9265 :         OrResult[29] |= OrConstant[21];

  07f8a	b8 04 00 00 00	 mov	 eax, 4
  07f8f	48 6b c0 1d	 imul	 rax, rax, 29
  07f93	b9 04 00 00 00	 mov	 ecx, 4
  07f98	48 6b c9 15	 imul	 rcx, rcx, 21
  07f9c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07fa3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07fa6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07faa	0b c1		 or	 eax, ecx
  07fac	b9 04 00 00 00	 mov	 ecx, 4
  07fb1	48 6b c9 1d	 imul	 rcx, rcx, 29
  07fb5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9266 :         OrResult[30] |= OrConstant[15];

  07fb9	b8 04 00 00 00	 mov	 eax, 4
  07fbe	48 6b c0 1e	 imul	 rax, rax, 30
  07fc2	b9 04 00 00 00	 mov	 ecx, 4
  07fc7	48 6b c9 0f	 imul	 rcx, rcx, 15
  07fcb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  07fd2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  07fd5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  07fd9	0b c1		 or	 eax, ecx
  07fdb	b9 04 00 00 00	 mov	 ecx, 4
  07fe0	48 6b c9 1e	 imul	 rcx, rcx, 30
  07fe4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN58@gen_csv_si:

; 9267 :     }
; 9268 :     if ((pClock1[6] & 0x02 ) == 0x02)

  07fe8	b8 01 00 00 00	 mov	 eax, 1
  07fed	48 6b c0 06	 imul	 rax, rax, 6
  07ff1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  07ff9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07ffd	83 e0 02	 and	 eax, 2
  08000	83 f8 02	 cmp	 eax, 2
  08003	0f 85 63 02 00
	00		 jne	 $LN59@gen_csv_si

; 9269 :     {
; 9270 :         OrResult[1]  |= OrConstant[12];

  08009	b8 04 00 00 00	 mov	 eax, 4
  0800e	48 6b c0 01	 imul	 rax, rax, 1
  08012	b9 04 00 00 00	 mov	 ecx, 4
  08017	48 6b c9 0c	 imul	 rcx, rcx, 12
  0801b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08022	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08025	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08029	0b c1		 or	 eax, ecx
  0802b	b9 04 00 00 00	 mov	 ecx, 4
  08030	48 6b c9 01	 imul	 rcx, rcx, 1
  08034	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9271 :         OrResult[2]  |= OrConstant[14];

  08038	b8 04 00 00 00	 mov	 eax, 4
  0803d	48 6b c0 02	 imul	 rax, rax, 2
  08041	b9 04 00 00 00	 mov	 ecx, 4
  08046	48 6b c9 0e	 imul	 rcx, rcx, 14
  0804a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08051	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08054	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08058	0b c1		 or	 eax, ecx
  0805a	b9 04 00 00 00	 mov	 ecx, 4
  0805f	48 6b c9 02	 imul	 rcx, rcx, 2
  08063	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9272 :         OrResult[5]  |= OrConstant[16];

  08067	b8 04 00 00 00	 mov	 eax, 4
  0806c	48 6b c0 05	 imul	 rax, rax, 5
  08070	b9 04 00 00 00	 mov	 ecx, 4
  08075	48 6b c9 10	 imul	 rcx, rcx, 16
  08079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08080	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08083	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08087	0b c1		 or	 eax, ecx
  08089	b9 04 00 00 00	 mov	 ecx, 4
  0808e	48 6b c9 05	 imul	 rcx, rcx, 5
  08092	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9273 :         OrResult[8]  |= OrConstant[15];

  08096	b8 04 00 00 00	 mov	 eax, 4
  0809b	48 6b c0 08	 imul	 rax, rax, 8
  0809f	b9 04 00 00 00	 mov	 ecx, 4
  080a4	48 6b c9 0f	 imul	 rcx, rcx, 15
  080a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  080af	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  080b2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  080b6	0b c1		 or	 eax, ecx
  080b8	b9 04 00 00 00	 mov	 ecx, 4
  080bd	48 6b c9 08	 imul	 rcx, rcx, 8
  080c1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9274 :         OrResult[10] |= OrConstant[20];

  080c5	b8 04 00 00 00	 mov	 eax, 4
  080ca	48 6b c0 0a	 imul	 rax, rax, 10
  080ce	b9 04 00 00 00	 mov	 ecx, 4
  080d3	48 6b c9 14	 imul	 rcx, rcx, 20
  080d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  080de	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  080e1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  080e5	0b c1		 or	 eax, ecx
  080e7	b9 04 00 00 00	 mov	 ecx, 4
  080ec	48 6b c9 0a	 imul	 rcx, rcx, 10
  080f0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9275 :         OrResult[12] |= OrConstant[12];

  080f4	b8 04 00 00 00	 mov	 eax, 4
  080f9	48 6b c0 0c	 imul	 rax, rax, 12
  080fd	b9 04 00 00 00	 mov	 ecx, 4
  08102	48 6b c9 0c	 imul	 rcx, rcx, 12
  08106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0810d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08110	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08114	0b c1		 or	 eax, ecx
  08116	b9 04 00 00 00	 mov	 ecx, 4
  0811b	48 6b c9 0c	 imul	 rcx, rcx, 12
  0811f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9276 :         OrResult[16] |= OrConstant[18];

  08123	b8 04 00 00 00	 mov	 eax, 4
  08128	48 6b c0 10	 imul	 rax, rax, 16
  0812c	b9 04 00 00 00	 mov	 ecx, 4
  08131	48 6b c9 12	 imul	 rcx, rcx, 18
  08135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0813c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0813f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08143	0b c1		 or	 eax, ecx
  08145	b9 04 00 00 00	 mov	 ecx, 4
  0814a	48 6b c9 10	 imul	 rcx, rcx, 16
  0814e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9277 :         OrResult[19] |= OrConstant[18];

  08152	b8 04 00 00 00	 mov	 eax, 4
  08157	48 6b c0 13	 imul	 rax, rax, 19
  0815b	b9 04 00 00 00	 mov	 ecx, 4
  08160	48 6b c9 12	 imul	 rcx, rcx, 18
  08164	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0816b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0816e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08172	0b c1		 or	 eax, ecx
  08174	b9 04 00 00 00	 mov	 ecx, 4
  08179	48 6b c9 13	 imul	 rcx, rcx, 19
  0817d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9278 :         OrResult[21] |= OrConstant[17];

  08181	b8 04 00 00 00	 mov	 eax, 4
  08186	48 6b c0 15	 imul	 rax, rax, 21
  0818a	b9 04 00 00 00	 mov	 ecx, 4
  0818f	48 6b c9 11	 imul	 rcx, rcx, 17
  08193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0819a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0819d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  081a1	0b c1		 or	 eax, ecx
  081a3	b9 04 00 00 00	 mov	 ecx, 4
  081a8	48 6b c9 15	 imul	 rcx, rcx, 21
  081ac	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9279 :         OrResult[23] |= OrConstant[20];

  081b0	b8 04 00 00 00	 mov	 eax, 4
  081b5	48 6b c0 17	 imul	 rax, rax, 23
  081b9	b9 04 00 00 00	 mov	 ecx, 4
  081be	48 6b c9 14	 imul	 rcx, rcx, 20
  081c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  081c9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  081cc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  081d0	0b c1		 or	 eax, ecx
  081d2	b9 04 00 00 00	 mov	 ecx, 4
  081d7	48 6b c9 17	 imul	 rcx, rcx, 23
  081db	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9280 :         OrResult[24] |= OrConstant[13];

  081df	b8 04 00 00 00	 mov	 eax, 4
  081e4	48 6b c0 18	 imul	 rax, rax, 24
  081e8	b9 04 00 00 00	 mov	 ecx, 4
  081ed	48 6b c9 0d	 imul	 rcx, rcx, 13
  081f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  081f8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  081fb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  081ff	0b c1		 or	 eax, ecx
  08201	b9 04 00 00 00	 mov	 ecx, 4
  08206	48 6b c9 18	 imul	 rcx, rcx, 24
  0820a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9281 :         OrResult[28] |= OrConstant[21];

  0820e	b8 04 00 00 00	 mov	 eax, 4
  08213	48 6b c0 1c	 imul	 rax, rax, 28
  08217	b9 04 00 00 00	 mov	 ecx, 4
  0821c	48 6b c9 15	 imul	 rcx, rcx, 21
  08220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08227	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0822a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0822e	0b c1		 or	 eax, ecx
  08230	b9 04 00 00 00	 mov	 ecx, 4
  08235	48 6b c9 1c	 imul	 rcx, rcx, 28
  08239	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9282 :         OrResult[31] |= OrConstant[22];

  0823d	b8 04 00 00 00	 mov	 eax, 4
  08242	48 6b c0 1f	 imul	 rax, rax, 31
  08246	b9 04 00 00 00	 mov	 ecx, 4
  0824b	48 6b c9 16	 imul	 rcx, rcx, 22
  0824f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08256	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08259	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0825d	0b c1		 or	 eax, ecx
  0825f	b9 04 00 00 00	 mov	 ecx, 4
  08264	48 6b c9 1f	 imul	 rcx, rcx, 31
  08268	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN59@gen_csv_si:

; 9283 :     }
; 9284 :     if ((pClock1[7] & 0x80 ) == 0x80)

  0826c	b8 01 00 00 00	 mov	 eax, 1
  08271	48 6b c0 07	 imul	 rax, rax, 7
  08275	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  0827d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08281	25 80 00 00 00	 and	 eax, 128		; 00000080H
  08286	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0828b	0f 85 c1 02 00
	00		 jne	 $LN60@gen_csv_si

; 9285 :     {
; 9286 :         OrResult[0]  |= OrConstant[4];

  08291	b8 04 00 00 00	 mov	 eax, 4
  08296	48 6b c0 00	 imul	 rax, rax, 0
  0829a	b9 04 00 00 00	 mov	 ecx, 4
  0829f	48 6b c9 04	 imul	 rcx, rcx, 4
  082a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  082aa	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  082ad	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  082b1	0b c1		 or	 eax, ecx
  082b3	b9 04 00 00 00	 mov	 ecx, 4
  082b8	48 6b c9 00	 imul	 rcx, rcx, 0
  082bc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9287 :         OrResult[3]  |= OrConstant[11];

  082c0	b8 04 00 00 00	 mov	 eax, 4
  082c5	48 6b c0 03	 imul	 rax, rax, 3
  082c9	b9 04 00 00 00	 mov	 ecx, 4
  082ce	48 6b c9 0b	 imul	 rcx, rcx, 11
  082d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  082d9	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  082dc	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  082e0	0b c1		 or	 eax, ecx
  082e2	b9 04 00 00 00	 mov	 ecx, 4
  082e7	48 6b c9 03	 imul	 rcx, rcx, 3
  082eb	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9288 :         OrResult[4]  |= OrConstant[9];

  082ef	b8 04 00 00 00	 mov	 eax, 4
  082f4	48 6b c0 04	 imul	 rax, rax, 4
  082f8	b9 04 00 00 00	 mov	 ecx, 4
  082fd	48 6b c9 09	 imul	 rcx, rcx, 9
  08301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08308	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0830b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0830f	0b c1		 or	 eax, ecx
  08311	b9 04 00 00 00	 mov	 ecx, 4
  08316	48 6b c9 04	 imul	 rcx, rcx, 4
  0831a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9289 :         OrResult[7]  |= OrConstant[3];

  0831e	b8 04 00 00 00	 mov	 eax, 4
  08323	48 6b c0 07	 imul	 rax, rax, 7
  08327	b9 04 00 00 00	 mov	 ecx, 4
  0832c	48 6b c9 03	 imul	 rcx, rcx, 3
  08330	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08337	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0833a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0833e	0b c1		 or	 eax, ecx
  08340	b9 04 00 00 00	 mov	 ecx, 4
  08345	48 6b c9 07	 imul	 rcx, rcx, 7
  08349	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9290 :         OrResult[8]  |= OrConstant[11];

  0834d	b8 04 00 00 00	 mov	 eax, 4
  08352	48 6b c0 08	 imul	 rax, rax, 8
  08356	b9 04 00 00 00	 mov	 ecx, 4
  0835b	48 6b c9 0b	 imul	 rcx, rcx, 11
  0835f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08366	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08369	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0836d	0b c1		 or	 eax, ecx
  0836f	b9 04 00 00 00	 mov	 ecx, 4
  08374	48 6b c9 08	 imul	 rcx, rcx, 8
  08378	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9291 :         OrResult[11] |= OrConstant[5];

  0837c	b8 04 00 00 00	 mov	 eax, 4
  08381	48 6b c0 0b	 imul	 rax, rax, 11
  08385	b9 04 00 00 00	 mov	 ecx, 4
  0838a	48 6b c9 05	 imul	 rcx, rcx, 5
  0838e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08395	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08398	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0839c	0b c1		 or	 eax, ecx
  0839e	b9 04 00 00 00	 mov	 ecx, 4
  083a3	48 6b c9 0b	 imul	 rcx, rcx, 11
  083a7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9292 :         OrResult[12] |= OrConstant[8];

  083ab	b8 04 00 00 00	 mov	 eax, 4
  083b0	48 6b c0 0c	 imul	 rax, rax, 12
  083b4	b9 04 00 00 00	 mov	 ecx, 4
  083b9	48 6b c9 08	 imul	 rcx, rcx, 8
  083bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  083c4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  083c7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  083cb	0b c1		 or	 eax, ecx
  083cd	b9 04 00 00 00	 mov	 ecx, 4
  083d2	48 6b c9 0c	 imul	 rcx, rcx, 12
  083d6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9293 :         OrResult[14] |= OrConstant[0];

  083da	b8 04 00 00 00	 mov	 eax, 4
  083df	48 6b c0 0e	 imul	 rax, rax, 14
  083e3	b9 04 00 00 00	 mov	 ecx, 4
  083e8	48 6b c9 00	 imul	 rcx, rcx, 0
  083ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  083f3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  083f6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  083fa	0b c1		 or	 eax, ecx
  083fc	b9 04 00 00 00	 mov	 ecx, 4
  08401	48 6b c9 0e	 imul	 rcx, rcx, 14
  08405	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9294 :         OrResult[17] |= OrConstant[2];

  08409	b8 04 00 00 00	 mov	 eax, 4
  0840e	48 6b c0 11	 imul	 rax, rax, 17
  08412	b9 04 00 00 00	 mov	 ecx, 4
  08417	48 6b c9 02	 imul	 rcx, rcx, 2
  0841b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08422	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08425	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08429	0b c1		 or	 eax, ecx
  0842b	b9 04 00 00 00	 mov	 ecx, 4
  08430	48 6b c9 11	 imul	 rcx, rcx, 17
  08434	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9295 :         OrResult[18] |= OrConstant[1];

  08438	b8 04 00 00 00	 mov	 eax, 4
  0843d	48 6b c0 12	 imul	 rax, rax, 18
  08441	b9 04 00 00 00	 mov	 ecx, 4
  08446	48 6b c9 01	 imul	 rcx, rcx, 1
  0844a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08451	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08454	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08458	0b c1		 or	 eax, ecx
  0845a	b9 04 00 00 00	 mov	 ecx, 4
  0845f	48 6b c9 12	 imul	 rcx, rcx, 18
  08463	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9296 :         OrResult[20] |= OrConstant[7];

  08467	b8 04 00 00 00	 mov	 eax, 4
  0846c	48 6b c0 14	 imul	 rax, rax, 20
  08470	b9 04 00 00 00	 mov	 ecx, 4
  08475	48 6b c9 07	 imul	 rcx, rcx, 7
  08479	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08480	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08483	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08487	0b c1		 or	 eax, ecx
  08489	b9 04 00 00 00	 mov	 ecx, 4
  0848e	48 6b c9 14	 imul	 rcx, rcx, 20
  08492	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9297 :         OrResult[23] |= OrConstant[4];

  08496	b8 04 00 00 00	 mov	 eax, 4
  0849b	48 6b c0 17	 imul	 rax, rax, 23
  0849f	b9 04 00 00 00	 mov	 ecx, 4
  084a4	48 6b c9 04	 imul	 rcx, rcx, 4
  084a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  084af	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  084b2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  084b6	0b c1		 or	 eax, ecx
  084b8	b9 04 00 00 00	 mov	 ecx, 4
  084bd	48 6b c9 17	 imul	 rcx, rcx, 23
  084c1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9298 :         OrResult[24] |= OrConstant[6];

  084c5	b8 04 00 00 00	 mov	 eax, 4
  084ca	48 6b c0 18	 imul	 rax, rax, 24
  084ce	b9 04 00 00 00	 mov	 ecx, 4
  084d3	48 6b c9 06	 imul	 rcx, rcx, 6
  084d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  084de	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  084e1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  084e5	0b c1		 or	 eax, ecx
  084e7	b9 04 00 00 00	 mov	 ecx, 4
  084ec	48 6b c9 18	 imul	 rcx, rcx, 24
  084f0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9299 :         OrResult[29] |= OrConstant[8];

  084f4	b8 04 00 00 00	 mov	 eax, 4
  084f9	48 6b c0 1d	 imul	 rax, rax, 29
  084fd	b9 04 00 00 00	 mov	 ecx, 4
  08502	48 6b c9 08	 imul	 rcx, rcx, 8
  08506	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0850d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08510	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08514	0b c1		 or	 eax, ecx
  08516	b9 04 00 00 00	 mov	 ecx, 4
  0851b	48 6b c9 1d	 imul	 rcx, rcx, 29
  0851f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9300 :         OrResult[31] |= OrConstant[1];

  08523	b8 04 00 00 00	 mov	 eax, 4
  08528	48 6b c0 1f	 imul	 rax, rax, 31
  0852c	b9 04 00 00 00	 mov	 ecx, 4
  08531	48 6b c9 01	 imul	 rcx, rcx, 1
  08535	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0853c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0853f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08543	0b c1		 or	 eax, ecx
  08545	b9 04 00 00 00	 mov	 ecx, 4
  0854a	48 6b c9 1f	 imul	 rcx, rcx, 31
  0854e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN60@gen_csv_si:

; 9301 :     }
; 9302 :     if ((pClock1[7] & 0x40 ) == 0x40)

  08552	b8 01 00 00 00	 mov	 eax, 1
  08557	48 6b c0 07	 imul	 rax, rax, 7
  0855b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  08563	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08567	83 e0 40	 and	 eax, 64			; 00000040H
  0856a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0856d	0f 85 34 02 00
	00		 jne	 $LN61@gen_csv_si

; 9303 :     {
; 9304 :         OrResult[3]  |= OrConstant[5];

  08573	b8 04 00 00 00	 mov	 eax, 4
  08578	48 6b c0 03	 imul	 rax, rax, 3
  0857c	b9 04 00 00 00	 mov	 ecx, 4
  08581	48 6b c9 05	 imul	 rcx, rcx, 5
  08585	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0858c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0858f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08593	0b c1		 or	 eax, ecx
  08595	b9 04 00 00 00	 mov	 ecx, 4
  0859a	48 6b c9 03	 imul	 rcx, rcx, 3
  0859e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9305 :         OrResult[4]  |= OrConstant[8];

  085a2	b8 04 00 00 00	 mov	 eax, 4
  085a7	48 6b c0 04	 imul	 rax, rax, 4
  085ab	b9 04 00 00 00	 mov	 ecx, 4
  085b0	48 6b c9 08	 imul	 rcx, rcx, 8
  085b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  085bb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  085be	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  085c2	0b c1		 or	 eax, ecx
  085c4	b9 04 00 00 00	 mov	 ecx, 4
  085c9	48 6b c9 04	 imul	 rcx, rcx, 4
  085cd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9306 :         OrResult[6]  |= OrConstant[0];

  085d1	b8 04 00 00 00	 mov	 eax, 4
  085d6	48 6b c0 06	 imul	 rax, rax, 6
  085da	b9 04 00 00 00	 mov	 ecx, 4
  085df	48 6b c9 00	 imul	 rcx, rcx, 0
  085e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  085ea	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  085ed	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  085f1	0b c1		 or	 eax, ecx
  085f3	b9 04 00 00 00	 mov	 ecx, 4
  085f8	48 6b c9 06	 imul	 rcx, rcx, 6
  085fc	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9307 :         OrResult[9]  |= OrConstant[6];

  08600	b8 04 00 00 00	 mov	 eax, 4
  08605	48 6b c0 09	 imul	 rax, rax, 9
  08609	b9 04 00 00 00	 mov	 ecx, 4
  0860e	48 6b c9 06	 imul	 rcx, rcx, 6
  08612	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08619	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0861c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08620	0b c1		 or	 eax, ecx
  08622	b9 04 00 00 00	 mov	 ecx, 4
  08627	48 6b c9 09	 imul	 rcx, rcx, 9
  0862b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9308 :         OrResult[13] |= OrConstant[9];

  0862f	b8 04 00 00 00	 mov	 eax, 4
  08634	48 6b c0 0d	 imul	 rax, rax, 13
  08638	b9 04 00 00 00	 mov	 ecx, 4
  0863d	48 6b c9 09	 imul	 rcx, rcx, 9
  08641	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08648	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0864b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0864f	0b c1		 or	 eax, ecx
  08651	b9 04 00 00 00	 mov	 ecx, 4
  08656	48 6b c9 0d	 imul	 rcx, rcx, 13
  0865a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9309 :         OrResult[16] |= OrConstant[6];

  0865e	b8 04 00 00 00	 mov	 eax, 4
  08663	48 6b c0 10	 imul	 rax, rax, 16
  08667	b9 04 00 00 00	 mov	 ecx, 4
  0866c	48 6b c9 06	 imul	 rcx, rcx, 6
  08670	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08677	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0867a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0867e	0b c1		 or	 eax, ecx
  08680	b9 04 00 00 00	 mov	 ecx, 4
  08685	48 6b c9 10	 imul	 rcx, rcx, 16
  08689	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9310 :         OrResult[21] |= OrConstant[8];

  0868d	b8 04 00 00 00	 mov	 eax, 4
  08692	48 6b c0 15	 imul	 rax, rax, 21
  08696	b9 04 00 00 00	 mov	 ecx, 4
  0869b	48 6b c9 08	 imul	 rcx, rcx, 8
  0869f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  086a6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  086a9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  086ad	0b c1		 or	 eax, ecx
  086af	b9 04 00 00 00	 mov	 ecx, 4
  086b4	48 6b c9 15	 imul	 rcx, rcx, 21
  086b8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9311 :         OrResult[22] |= OrConstant[4];

  086bc	b8 04 00 00 00	 mov	 eax, 4
  086c1	48 6b c0 16	 imul	 rax, rax, 22
  086c5	b9 04 00 00 00	 mov	 ecx, 4
  086ca	48 6b c9 04	 imul	 rcx, rcx, 4
  086ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  086d5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  086d8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  086dc	0b c1		 or	 eax, ecx
  086de	b9 04 00 00 00	 mov	 ecx, 4
  086e3	48 6b c9 16	 imul	 rcx, rcx, 22
  086e7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9312 :         OrResult[25] |= OrConstant[0];

  086eb	b8 04 00 00 00	 mov	 eax, 4
  086f0	48 6b c0 19	 imul	 rax, rax, 25
  086f4	b9 04 00 00 00	 mov	 ecx, 4
  086f9	48 6b c9 00	 imul	 rcx, rcx, 0
  086fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08704	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08707	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0870b	0b c1		 or	 eax, ecx
  0870d	b9 04 00 00 00	 mov	 ecx, 4
  08712	48 6b c9 19	 imul	 rcx, rcx, 25
  08716	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9313 :         OrResult[26] |= OrConstant[5];

  0871a	b8 04 00 00 00	 mov	 eax, 4
  0871f	48 6b c0 1a	 imul	 rax, rax, 26
  08723	b9 04 00 00 00	 mov	 ecx, 4
  08728	48 6b c9 05	 imul	 rcx, rcx, 5
  0872c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08733	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08736	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0873a	0b c1		 or	 eax, ecx
  0873c	b9 04 00 00 00	 mov	 ecx, 4
  08741	48 6b c9 1a	 imul	 rcx, rcx, 26
  08745	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9314 :         OrResult[29] |= OrConstant[7];

  08749	b8 04 00 00 00	 mov	 eax, 4
  0874e	48 6b c0 1d	 imul	 rax, rax, 29
  08752	b9 04 00 00 00	 mov	 ecx, 4
  08757	48 6b c9 07	 imul	 rcx, rcx, 7
  0875b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08762	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08765	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08769	0b c1		 or	 eax, ecx
  0876b	b9 04 00 00 00	 mov	 ecx, 4
  08770	48 6b c9 1d	 imul	 rcx, rcx, 29
  08774	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9315 :         OrResult[30] |= OrConstant[11];

  08778	b8 04 00 00 00	 mov	 eax, 4
  0877d	48 6b c0 1e	 imul	 rax, rax, 30
  08781	b9 04 00 00 00	 mov	 ecx, 4
  08786	48 6b c9 0b	 imul	 rcx, rcx, 11
  0878a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08791	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08794	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08798	0b c1		 or	 eax, ecx
  0879a	b9 04 00 00 00	 mov	 ecx, 4
  0879f	48 6b c9 1e	 imul	 rcx, rcx, 30
  087a3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN61@gen_csv_si:

; 9316 :     }
; 9317 :     if ((pClock1[7] & 0x20 ) == 0x20)

  087a7	b8 01 00 00 00	 mov	 eax, 1
  087ac	48 6b c0 07	 imul	 rax, rax, 7
  087b0	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  087b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  087bc	83 e0 20	 and	 eax, 32			; 00000020H
  087bf	83 f8 20	 cmp	 eax, 32			; 00000020H
  087c2	0f 85 63 02 00
	00		 jne	 $LN62@gen_csv_si

; 9318 :     {
; 9319 :         OrResult[0]  |= OrConstant[1];

  087c8	b8 04 00 00 00	 mov	 eax, 4
  087cd	48 6b c0 00	 imul	 rax, rax, 0
  087d1	b9 04 00 00 00	 mov	 ecx, 4
  087d6	48 6b c9 01	 imul	 rcx, rcx, 1
  087da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  087e1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  087e4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  087e8	0b c1		 or	 eax, ecx
  087ea	b9 04 00 00 00	 mov	 ecx, 4
  087ef	48 6b c9 00	 imul	 rcx, rcx, 0
  087f3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9320 :         OrResult[5]  |= OrConstant[9];

  087f7	b8 04 00 00 00	 mov	 eax, 4
  087fc	48 6b c0 05	 imul	 rax, rax, 5
  08800	b9 04 00 00 00	 mov	 ecx, 4
  08805	48 6b c9 09	 imul	 rcx, rcx, 9
  08809	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08810	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08813	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08817	0b c1		 or	 eax, ecx
  08819	b9 04 00 00 00	 mov	 ecx, 4
  0881e	48 6b c9 05	 imul	 rcx, rcx, 5
  08822	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9321 :         OrResult[8]  |= OrConstant[3];

  08826	b8 04 00 00 00	 mov	 eax, 4
  0882b	48 6b c0 08	 imul	 rax, rax, 8
  0882f	b9 04 00 00 00	 mov	 ecx, 4
  08834	48 6b c9 03	 imul	 rcx, rcx, 3
  08838	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0883f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08842	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08846	0b c1		 or	 eax, ecx
  08848	b9 04 00 00 00	 mov	 ecx, 4
  0884d	48 6b c9 08	 imul	 rcx, rcx, 8
  08851	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9322 :         OrResult[10] |= OrConstant[10];

  08855	b8 04 00 00 00	 mov	 eax, 4
  0885a	48 6b c0 0a	 imul	 rax, rax, 10
  0885e	b9 04 00 00 00	 mov	 ecx, 4
  08863	48 6b c9 0a	 imul	 rcx, rcx, 10
  08867	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0886e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08871	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08875	0b c1		 or	 eax, ecx
  08877	b9 04 00 00 00	 mov	 ecx, 4
  0887c	48 6b c9 0a	 imul	 rcx, rcx, 10
  08880	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9323 :         OrResult[13] |= OrConstant[1];

  08884	b8 04 00 00 00	 mov	 eax, 4
  08889	48 6b c0 0d	 imul	 rax, rax, 13
  0888d	b9 04 00 00 00	 mov	 ecx, 4
  08892	48 6b c9 01	 imul	 rcx, rcx, 1
  08896	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0889d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  088a0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  088a4	0b c1		 or	 eax, ecx
  088a6	b9 04 00 00 00	 mov	 ecx, 4
  088ab	48 6b c9 0d	 imul	 rcx, rcx, 13
  088af	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9324 :         OrResult[15] |= OrConstant[11];

  088b3	b8 04 00 00 00	 mov	 eax, 4
  088b8	48 6b c0 0f	 imul	 rax, rax, 15
  088bc	b9 04 00 00 00	 mov	 ecx, 4
  088c1	48 6b c9 0b	 imul	 rcx, rcx, 11
  088c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  088cc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  088cf	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  088d3	0b c1		 or	 eax, ecx
  088d5	b9 04 00 00 00	 mov	 ecx, 4
  088da	48 6b c9 0f	 imul	 rcx, rcx, 15
  088de	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9325 :         OrResult[17] |= OrConstant[0];

  088e2	b8 04 00 00 00	 mov	 eax, 4
  088e7	48 6b c0 11	 imul	 rax, rax, 17
  088eb	b9 04 00 00 00	 mov	 ecx, 4
  088f0	48 6b c9 00	 imul	 rcx, rcx, 0
  088f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  088fb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  088fe	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08902	0b c1		 or	 eax, ecx
  08904	b9 04 00 00 00	 mov	 ecx, 4
  08909	48 6b c9 11	 imul	 rcx, rcx, 17
  0890d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9326 :         OrResult[18] |= OrConstant[5];

  08911	b8 04 00 00 00	 mov	 eax, 4
  08916	48 6b c0 12	 imul	 rax, rax, 18
  0891a	b9 04 00 00 00	 mov	 ecx, 4
  0891f	48 6b c9 05	 imul	 rcx, rcx, 5
  08923	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0892a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0892d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08931	0b c1		 or	 eax, ecx
  08933	b9 04 00 00 00	 mov	 ecx, 4
  08938	48 6b c9 12	 imul	 rcx, rcx, 18
  0893c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9327 :         OrResult[21] |= OrConstant[7];

  08940	b8 04 00 00 00	 mov	 eax, 4
  08945	48 6b c0 15	 imul	 rax, rax, 21
  08949	b9 04 00 00 00	 mov	 ecx, 4
  0894e	48 6b c9 07	 imul	 rcx, rcx, 7
  08952	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08959	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0895c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08960	0b c1		 or	 eax, ecx
  08962	b9 04 00 00 00	 mov	 ecx, 4
  08967	48 6b c9 15	 imul	 rcx, rcx, 21
  0896b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9328 :         OrResult[24] |= OrConstant[2];

  0896f	b8 04 00 00 00	 mov	 eax, 4
  08974	48 6b c0 18	 imul	 rax, rax, 24
  08978	b9 04 00 00 00	 mov	 ecx, 4
  0897d	48 6b c9 02	 imul	 rcx, rcx, 2
  08981	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08988	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0898b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0898f	0b c1		 or	 eax, ecx
  08991	b9 04 00 00 00	 mov	 ecx, 4
  08996	48 6b c9 18	 imul	 rcx, rcx, 24
  0899a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9329 :         OrResult[27] |= OrConstant[10];

  0899e	b8 04 00 00 00	 mov	 eax, 4
  089a3	48 6b c0 1b	 imul	 rax, rax, 27
  089a7	b9 04 00 00 00	 mov	 ecx, 4
  089ac	48 6b c9 0a	 imul	 rcx, rcx, 10
  089b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  089b7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  089ba	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  089be	0b c1		 or	 eax, ecx
  089c0	b9 04 00 00 00	 mov	 ecx, 4
  089c5	48 6b c9 1b	 imul	 rcx, rcx, 27
  089c9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9330 :         OrResult[29] |= OrConstant[2];

  089cd	b8 04 00 00 00	 mov	 eax, 4
  089d2	48 6b c0 1d	 imul	 rax, rax, 29
  089d6	b9 04 00 00 00	 mov	 ecx, 4
  089db	48 6b c9 02	 imul	 rcx, rcx, 2
  089df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  089e6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  089e9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  089ed	0b c1		 or	 eax, ecx
  089ef	b9 04 00 00 00	 mov	 ecx, 4
  089f4	48 6b c9 1d	 imul	 rcx, rcx, 29
  089f8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9331 :         OrResult[31] |= OrConstant[6];

  089fc	b8 04 00 00 00	 mov	 eax, 4
  08a01	48 6b c0 1f	 imul	 rax, rax, 31
  08a05	b9 04 00 00 00	 mov	 ecx, 4
  08a0a	48 6b c9 06	 imul	 rcx, rcx, 6
  08a0e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08a15	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08a18	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08a1c	0b c1		 or	 eax, ecx
  08a1e	b9 04 00 00 00	 mov	 ecx, 4
  08a23	48 6b c9 1f	 imul	 rcx, rcx, 31
  08a27	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN62@gen_csv_si:

; 9332 :     }
; 9333 :     if ((pClock1[7] & 0x10 ) == 0x10)

  08a2b	b8 01 00 00 00	 mov	 eax, 1
  08a30	48 6b c0 07	 imul	 rax, rax, 7
  08a34	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  08a3c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08a40	83 e0 10	 and	 eax, 16
  08a43	83 f8 10	 cmp	 eax, 16
  08a46	0f 85 c1 02 00
	00		 jne	 $LN63@gen_csv_si

; 9334 :     {
; 9335 :         OrResult[2]  |= OrConstant[10];

  08a4c	b8 04 00 00 00	 mov	 eax, 4
  08a51	48 6b c0 02	 imul	 rax, rax, 2
  08a55	b9 04 00 00 00	 mov	 ecx, 4
  08a5a	48 6b c9 0a	 imul	 rcx, rcx, 10
  08a5e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08a65	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08a68	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08a6c	0b c1		 or	 eax, ecx
  08a6e	b9 04 00 00 00	 mov	 ecx, 4
  08a73	48 6b c9 02	 imul	 rcx, rcx, 2
  08a77	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9336 :         OrResult[5]  |= OrConstant[1];

  08a7b	b8 04 00 00 00	 mov	 eax, 4
  08a80	48 6b c0 05	 imul	 rax, rax, 5
  08a84	b9 04 00 00 00	 mov	 ecx, 4
  08a89	48 6b c9 01	 imul	 rcx, rcx, 1
  08a8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08a94	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08a97	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08a9b	0b c1		 or	 eax, ecx
  08a9d	b9 04 00 00 00	 mov	 ecx, 4
  08aa2	48 6b c9 05	 imul	 rcx, rcx, 5
  08aa6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9337 :         OrResult[7]  |= OrConstant[11];

  08aaa	b8 04 00 00 00	 mov	 eax, 4
  08aaf	48 6b c0 07	 imul	 rax, rax, 7
  08ab3	b9 04 00 00 00	 mov	 ecx, 4
  08ab8	48 6b c9 0b	 imul	 rcx, rcx, 11
  08abc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08ac3	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08ac6	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08aca	0b c1		 or	 eax, ecx
  08acc	b9 04 00 00 00	 mov	 ecx, 4
  08ad1	48 6b c9 07	 imul	 rcx, rcx, 7
  08ad5	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9338 :         OrResult[8]  |= OrConstant[9];

  08ad9	b8 04 00 00 00	 mov	 eax, 4
  08ade	48 6b c0 08	 imul	 rax, rax, 8
  08ae2	b9 04 00 00 00	 mov	 ecx, 4
  08ae7	48 6b c9 09	 imul	 rcx, rcx, 9
  08aeb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08af2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08af5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08af9	0b c1		 or	 eax, ecx
  08afb	b9 04 00 00 00	 mov	 ecx, 4
  08b00	48 6b c9 08	 imul	 rcx, rcx, 8
  08b04	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9339 :         OrResult[11] |= OrConstant[3];

  08b08	b8 04 00 00 00	 mov	 eax, 4
  08b0d	48 6b c0 0b	 imul	 rax, rax, 11
  08b11	b9 04 00 00 00	 mov	 ecx, 4
  08b16	48 6b c9 03	 imul	 rcx, rcx, 3
  08b1a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08b21	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08b24	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08b28	0b c1		 or	 eax, ecx
  08b2a	b9 04 00 00 00	 mov	 ecx, 4
  08b2f	48 6b c9 0b	 imul	 rcx, rcx, 11
  08b33	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9340 :         OrResult[12] |= OrConstant[11];

  08b37	b8 04 00 00 00	 mov	 eax, 4
  08b3c	48 6b c0 0c	 imul	 rax, rax, 12
  08b40	b9 04 00 00 00	 mov	 ecx, 4
  08b45	48 6b c9 0b	 imul	 rcx, rcx, 11
  08b49	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08b50	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08b53	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08b57	0b c1		 or	 eax, ecx
  08b59	b9 04 00 00 00	 mov	 ecx, 4
  08b5e	48 6b c9 0c	 imul	 rcx, rcx, 12
  08b62	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9341 :         OrResult[15] |= OrConstant[5];

  08b66	b8 04 00 00 00	 mov	 eax, 4
  08b6b	48 6b c0 0f	 imul	 rax, rax, 15
  08b6f	b9 04 00 00 00	 mov	 ecx, 4
  08b74	48 6b c9 05	 imul	 rcx, rcx, 5
  08b78	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08b7f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08b82	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08b86	0b c1		 or	 eax, ecx
  08b88	b9 04 00 00 00	 mov	 ecx, 4
  08b8d	48 6b c9 0f	 imul	 rcx, rcx, 15
  08b91	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9342 :         OrResult[16] |= OrConstant[2];

  08b95	b8 04 00 00 00	 mov	 eax, 4
  08b9a	48 6b c0 10	 imul	 rax, rax, 16
  08b9e	b9 04 00 00 00	 mov	 ecx, 4
  08ba3	48 6b c9 02	 imul	 rcx, rcx, 2
  08ba7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08bae	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08bb1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08bb5	0b c1		 or	 eax, ecx
  08bb7	b9 04 00 00 00	 mov	 ecx, 4
  08bbc	48 6b c9 10	 imul	 rcx, rcx, 16
  08bc0	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9343 :         OrResult[19] |= OrConstant[10];

  08bc4	b8 04 00 00 00	 mov	 eax, 4
  08bc9	48 6b c0 13	 imul	 rax, rax, 19
  08bcd	b9 04 00 00 00	 mov	 ecx, 4
  08bd2	48 6b c9 0a	 imul	 rcx, rcx, 10
  08bd6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08bdd	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08be0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08be4	0b c1		 or	 eax, ecx
  08be6	b9 04 00 00 00	 mov	 ecx, 4
  08beb	48 6b c9 13	 imul	 rcx, rcx, 19
  08bef	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9344 :         OrResult[21] |= OrConstant[2];

  08bf3	b8 04 00 00 00	 mov	 eax, 4
  08bf8	48 6b c0 15	 imul	 rax, rax, 21
  08bfc	b9 04 00 00 00	 mov	 ecx, 4
  08c01	48 6b c9 02	 imul	 rcx, rcx, 2
  08c05	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08c0c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08c0f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08c13	0b c1		 or	 eax, ecx
  08c15	b9 04 00 00 00	 mov	 ecx, 4
  08c1a	48 6b c9 15	 imul	 rcx, rcx, 21
  08c1e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9345 :         OrResult[22] |= OrConstant[1];

  08c22	b8 04 00 00 00	 mov	 eax, 4
  08c27	48 6b c0 16	 imul	 rax, rax, 22
  08c2b	b9 04 00 00 00	 mov	 ecx, 4
  08c30	48 6b c9 01	 imul	 rcx, rcx, 1
  08c34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08c3b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08c3e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08c42	0b c1		 or	 eax, ecx
  08c44	b9 04 00 00 00	 mov	 ecx, 4
  08c49	48 6b c9 16	 imul	 rcx, rcx, 22
  08c4d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9346 :         OrResult[24] |= OrConstant[7];

  08c51	b8 04 00 00 00	 mov	 eax, 4
  08c56	48 6b c0 18	 imul	 rax, rax, 24
  08c5a	b9 04 00 00 00	 mov	 ecx, 4
  08c5f	48 6b c9 07	 imul	 rcx, rcx, 7
  08c63	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08c6a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08c6d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08c71	0b c1		 or	 eax, ecx
  08c73	b9 04 00 00 00	 mov	 ecx, 4
  08c78	48 6b c9 18	 imul	 rcx, rcx, 24
  08c7c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9347 :         OrResult[27] |= OrConstant[4];

  08c80	b8 04 00 00 00	 mov	 eax, 4
  08c85	48 6b c0 1b	 imul	 rax, rax, 27
  08c89	b9 04 00 00 00	 mov	 ecx, 4
  08c8e	48 6b c9 04	 imul	 rcx, rcx, 4
  08c92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08c99	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08c9c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08ca0	0b c1		 or	 eax, ecx
  08ca2	b9 04 00 00 00	 mov	 ecx, 4
  08ca7	48 6b c9 1b	 imul	 rcx, rcx, 27
  08cab	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9348 :         OrResult[28] |= OrConstant[6];

  08caf	b8 04 00 00 00	 mov	 eax, 4
  08cb4	48 6b c0 1c	 imul	 rax, rax, 28
  08cb8	b9 04 00 00 00	 mov	 ecx, 4
  08cbd	48 6b c9 06	 imul	 rcx, rcx, 6
  08cc1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08cc8	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08ccb	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08ccf	0b c1		 or	 eax, ecx
  08cd1	b9 04 00 00 00	 mov	 ecx, 4
  08cd6	48 6b c9 1c	 imul	 rcx, rcx, 28
  08cda	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9349 :         OrResult[30] |= OrConstant[3];

  08cde	b8 04 00 00 00	 mov	 eax, 4
  08ce3	48 6b c0 1e	 imul	 rax, rax, 30
  08ce7	b9 04 00 00 00	 mov	 ecx, 4
  08cec	48 6b c9 03	 imul	 rcx, rcx, 3
  08cf0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08cf7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08cfa	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08cfe	0b c1		 or	 eax, ecx
  08d00	b9 04 00 00 00	 mov	 ecx, 4
  08d05	48 6b c9 1e	 imul	 rcx, rcx, 30
  08d09	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN63@gen_csv_si:

; 9350 :     }
; 9351 :     if ((pClock1[7] & 0x08 ) == 0x08)

  08d0d	b8 01 00 00 00	 mov	 eax, 1
  08d12	48 6b c0 07	 imul	 rax, rax, 7
  08d16	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  08d1e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08d22	83 e0 08	 and	 eax, 8
  08d25	83 f8 08	 cmp	 eax, 8
  08d28	0f 85 63 02 00
	00		 jne	 $LN64@gen_csv_si

; 9352 :     {
; 9353 :         OrResult[1]  |= OrConstant[15];

  08d2e	b8 04 00 00 00	 mov	 eax, 4
  08d33	48 6b c0 01	 imul	 rax, rax, 1
  08d37	b9 04 00 00 00	 mov	 ecx, 4
  08d3c	48 6b c9 0f	 imul	 rcx, rcx, 15
  08d40	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08d47	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08d4a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08d4e	0b c1		 or	 eax, ecx
  08d50	b9 04 00 00 00	 mov	 ecx, 4
  08d55	48 6b c9 01	 imul	 rcx, rcx, 1
  08d59	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9354 :         OrResult[3]  |= OrConstant[18];

  08d5d	b8 04 00 00 00	 mov	 eax, 4
  08d62	48 6b c0 03	 imul	 rax, rax, 3
  08d66	b9 04 00 00 00	 mov	 ecx, 4
  08d6b	48 6b c9 12	 imul	 rcx, rcx, 18
  08d6f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08d76	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08d79	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08d7d	0b c1		 or	 eax, ecx
  08d7f	b9 04 00 00 00	 mov	 ecx, 4
  08d84	48 6b c9 03	 imul	 rcx, rcx, 3
  08d88	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9355 :         OrResult[5]  |= OrConstant[17];

  08d8c	b8 04 00 00 00	 mov	 eax, 4
  08d91	48 6b c0 05	 imul	 rax, rax, 5
  08d95	b9 04 00 00 00	 mov	 ecx, 4
  08d9a	48 6b c9 11	 imul	 rcx, rcx, 17
  08d9e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08da5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08da8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08dac	0b c1		 or	 eax, ecx
  08dae	b9 04 00 00 00	 mov	 ecx, 4
  08db3	48 6b c9 05	 imul	 rcx, rcx, 5
  08db7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9356 :         OrResult[7]  |= OrConstant[20];

  08dbb	b8 04 00 00 00	 mov	 eax, 4
  08dc0	48 6b c0 07	 imul	 rax, rax, 7
  08dc4	b9 04 00 00 00	 mov	 ecx, 4
  08dc9	48 6b c9 14	 imul	 rcx, rcx, 20
  08dcd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08dd4	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08dd7	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08ddb	0b c1		 or	 eax, ecx
  08ddd	b9 04 00 00 00	 mov	 ecx, 4
  08de2	48 6b c9 07	 imul	 rcx, rcx, 7
  08de6	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9357 :         OrResult[8]  |= OrConstant[13];

  08dea	b8 04 00 00 00	 mov	 eax, 4
  08def	48 6b c0 08	 imul	 rax, rax, 8
  08df3	b9 04 00 00 00	 mov	 ecx, 4
  08df8	48 6b c9 0d	 imul	 rcx, rcx, 13
  08dfc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08e03	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08e06	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08e0a	0b c1		 or	 eax, ecx
  08e0c	b9 04 00 00 00	 mov	 ecx, 4
  08e11	48 6b c9 08	 imul	 rcx, rcx, 8
  08e15	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9358 :         OrResult[12] |= OrConstant[21];

  08e19	b8 04 00 00 00	 mov	 eax, 4
  08e1e	48 6b c0 0c	 imul	 rax, rax, 12
  08e22	b9 04 00 00 00	 mov	 ecx, 4
  08e27	48 6b c9 15	 imul	 rcx, rcx, 21
  08e2b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08e32	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08e35	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08e39	0b c1		 or	 eax, ecx
  08e3b	b9 04 00 00 00	 mov	 ecx, 4
  08e40	48 6b c9 0c	 imul	 rcx, rcx, 12
  08e44	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9359 :         OrResult[15] |= OrConstant[12];

  08e48	b8 04 00 00 00	 mov	 eax, 4
  08e4d	48 6b c0 0f	 imul	 rax, rax, 15
  08e51	b9 04 00 00 00	 mov	 ecx, 4
  08e56	48 6b c9 0c	 imul	 rcx, rcx, 12
  08e5a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08e61	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08e64	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08e68	0b c1		 or	 eax, ecx
  08e6a	b9 04 00 00 00	 mov	 ecx, 4
  08e6f	48 6b c9 0f	 imul	 rcx, rcx, 15
  08e73	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9360 :         OrResult[16] |= OrConstant[14];

  08e77	b8 04 00 00 00	 mov	 eax, 4
  08e7c	48 6b c0 10	 imul	 rax, rax, 16
  08e80	b9 04 00 00 00	 mov	 ecx, 4
  08e85	48 6b c9 0e	 imul	 rcx, rcx, 14
  08e89	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08e90	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08e93	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08e97	0b c1		 or	 eax, ecx
  08e99	b9 04 00 00 00	 mov	 ecx, 4
  08e9e	48 6b c9 10	 imul	 rcx, rcx, 16
  08ea2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9361 :         OrResult[19] |= OrConstant[16];

  08ea6	b8 04 00 00 00	 mov	 eax, 4
  08eab	48 6b c0 13	 imul	 rax, rax, 19
  08eaf	b9 04 00 00 00	 mov	 ecx, 4
  08eb4	48 6b c9 10	 imul	 rcx, rcx, 16
  08eb8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08ebf	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08ec2	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08ec6	0b c1		 or	 eax, ecx
  08ec8	b9 04 00 00 00	 mov	 ecx, 4
  08ecd	48 6b c9 13	 imul	 rcx, rcx, 19
  08ed1	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9362 :         OrResult[22] |= OrConstant[15];

  08ed5	b8 04 00 00 00	 mov	 eax, 4
  08eda	48 6b c0 16	 imul	 rax, rax, 22
  08ede	b9 04 00 00 00	 mov	 ecx, 4
  08ee3	48 6b c9 0f	 imul	 rcx, rcx, 15
  08ee7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08eee	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08ef1	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08ef5	0b c1		 or	 eax, ecx
  08ef7	b9 04 00 00 00	 mov	 ecx, 4
  08efc	48 6b c9 16	 imul	 rcx, rcx, 22
  08f00	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9363 :         OrResult[24] |= OrConstant[20];

  08f04	b8 04 00 00 00	 mov	 eax, 4
  08f09	48 6b c0 18	 imul	 rax, rax, 24
  08f0d	b9 04 00 00 00	 mov	 ecx, 4
  08f12	48 6b c9 14	 imul	 rcx, rcx, 20
  08f16	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08f1d	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08f20	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08f24	0b c1		 or	 eax, ecx
  08f26	b9 04 00 00 00	 mov	 ecx, 4
  08f2b	48 6b c9 18	 imul	 rcx, rcx, 24
  08f2f	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9364 :         OrResult[26] |= OrConstant[12];

  08f33	b8 04 00 00 00	 mov	 eax, 4
  08f38	48 6b c0 1a	 imul	 rax, rax, 26
  08f3c	b9 04 00 00 00	 mov	 ecx, 4
  08f41	48 6b c9 0c	 imul	 rcx, rcx, 12
  08f45	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08f4c	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08f4f	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08f53	0b c1		 or	 eax, ecx
  08f55	b9 04 00 00 00	 mov	 ecx, 4
  08f5a	48 6b c9 1a	 imul	 rcx, rcx, 26
  08f5e	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9365 :         OrResult[30] |= OrConstant[18];

  08f62	b8 04 00 00 00	 mov	 eax, 4
  08f67	48 6b c0 1e	 imul	 rax, rax, 30
  08f6b	b9 04 00 00 00	 mov	 ecx, 4
  08f70	48 6b c9 12	 imul	 rcx, rcx, 18
  08f74	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08f7b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08f7e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08f82	0b c1		 or	 eax, ecx
  08f84	b9 04 00 00 00	 mov	 ecx, 4
  08f89	48 6b c9 1e	 imul	 rcx, rcx, 30
  08f8d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN64@gen_csv_si:

; 9366 :     }
; 9367 :     if ((pClock1[7] & 0x04 ) == 0x04)

  08f91	b8 01 00 00 00	 mov	 eax, 1
  08f96	48 6b c0 07	 imul	 rax, rax, 7
  08f9a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  08fa2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08fa6	83 e0 04	 and	 eax, 4
  08fa9	83 f8 04	 cmp	 eax, 4
  08fac	0f 85 92 02 00
	00		 jne	 $LN65@gen_csv_si

; 9368 :     {
; 9369 :         OrResult[0]  |= OrConstant[15];

  08fb2	b8 04 00 00 00	 mov	 eax, 4
  08fb7	48 6b c0 00	 imul	 rax, rax, 0
  08fbb	b9 04 00 00 00	 mov	 ecx, 4
  08fc0	48 6b c9 0f	 imul	 rcx, rcx, 15
  08fc4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08fcb	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08fce	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  08fd2	0b c1		 or	 eax, ecx
  08fd4	b9 04 00 00 00	 mov	 ecx, 4
  08fd9	48 6b c9 00	 imul	 rcx, rcx, 0
  08fdd	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9370 :         OrResult[5]  |= OrConstant[13];

  08fe1	b8 04 00 00 00	 mov	 eax, 4
  08fe6	48 6b c0 05	 imul	 rax, rax, 5
  08fea	b9 04 00 00 00	 mov	 ecx, 4
  08fef	48 6b c9 0d	 imul	 rcx, rcx, 13
  08ff3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  08ffa	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  08ffd	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09001	0b c1		 or	 eax, ecx
  09003	b9 04 00 00 00	 mov	 ecx, 4
  09008	48 6b c9 05	 imul	 rcx, rcx, 5
  0900c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9371 :         OrResult[7]  |= OrConstant[19];

  09010	b8 04 00 00 00	 mov	 eax, 4
  09015	48 6b c0 07	 imul	 rax, rax, 7
  09019	b9 04 00 00 00	 mov	 ecx, 4
  0901e	48 6b c9 13	 imul	 rcx, rcx, 19
  09022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09029	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0902c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09030	0b c1		 or	 eax, ecx
  09032	b9 04 00 00 00	 mov	 ecx, 4
  09037	48 6b c9 07	 imul	 rcx, rcx, 7
  0903b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9372 :         OrResult[8]  |= OrConstant[18];

  0903f	b8 04 00 00 00	 mov	 eax, 4
  09044	48 6b c0 08	 imul	 rax, rax, 8
  09048	b9 04 00 00 00	 mov	 ecx, 4
  0904d	48 6b c9 12	 imul	 rcx, rcx, 18
  09051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09058	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0905b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0905f	0b c1		 or	 eax, ecx
  09061	b9 04 00 00 00	 mov	 ecx, 4
  09066	48 6b c9 08	 imul	 rcx, rcx, 8
  0906a	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9373 :         OrResult[11] |= OrConstant[18];

  0906e	b8 04 00 00 00	 mov	 eax, 4
  09073	48 6b c0 0b	 imul	 rax, rax, 11
  09077	b9 04 00 00 00	 mov	 ecx, 4
  0907c	48 6b c9 12	 imul	 rcx, rcx, 18
  09080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09087	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0908a	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0908e	0b c1		 or	 eax, ecx
  09090	b9 04 00 00 00	 mov	 ecx, 4
  09095	48 6b c9 0b	 imul	 rcx, rcx, 11
  09099	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9374 :         OrResult[13] |= OrConstant[17];

  0909d	b8 04 00 00 00	 mov	 eax, 4
  090a2	48 6b c0 0d	 imul	 rax, rax, 13
  090a6	b9 04 00 00 00	 mov	 ecx, 4
  090ab	48 6b c9 11	 imul	 rcx, rcx, 17
  090af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  090b6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  090b9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  090bd	0b c1		 or	 eax, ecx
  090bf	b9 04 00 00 00	 mov	 ecx, 4
  090c4	48 6b c9 0d	 imul	 rcx, rcx, 13
  090c8	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9375 :         OrResult[15] |= OrConstant[20];

  090cc	b8 04 00 00 00	 mov	 eax, 4
  090d1	48 6b c0 0f	 imul	 rax, rax, 15
  090d5	b9 04 00 00 00	 mov	 ecx, 4
  090da	48 6b c9 14	 imul	 rcx, rcx, 20
  090de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  090e5	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  090e8	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  090ec	0b c1		 or	 eax, ecx
  090ee	b9 04 00 00 00	 mov	 ecx, 4
  090f3	48 6b c9 0f	 imul	 rcx, rcx, 15
  090f7	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9376 :         OrResult[17] |= OrConstant[14];

  090fb	b8 04 00 00 00	 mov	 eax, 4
  09100	48 6b c0 11	 imul	 rax, rax, 17
  09104	b9 04 00 00 00	 mov	 ecx, 4
  09109	48 6b c9 0e	 imul	 rcx, rcx, 14
  0910d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09114	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09117	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0911b	0b c1		 or	 eax, ecx
  0911d	b9 04 00 00 00	 mov	 ecx, 4
  09122	48 6b c9 11	 imul	 rcx, rcx, 17
  09126	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9377 :         OrResult[18] |= OrConstant[23];

  0912a	b8 04 00 00 00	 mov	 eax, 4
  0912f	48 6b c0 12	 imul	 rax, rax, 18
  09133	b9 04 00 00 00	 mov	 ecx, 4
  09138	48 6b c9 17	 imul	 rcx, rcx, 23
  0913c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09143	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09146	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0914a	0b c1		 or	 eax, ecx
  0914c	b9 04 00 00 00	 mov	 ecx, 4
  09151	48 6b c9 12	 imul	 rcx, rcx, 18
  09155	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9378 :         OrResult[20] |= OrConstant[17];

  09159	b8 04 00 00 00	 mov	 eax, 4
  0915e	48 6b c0 14	 imul	 rax, rax, 20
  09162	b9 04 00 00 00	 mov	 ecx, 4
  09167	48 6b c9 11	 imul	 rcx, rcx, 17
  0916b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09172	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09175	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09179	0b c1		 or	 eax, ecx
  0917b	b9 04 00 00 00	 mov	 ecx, 4
  09180	48 6b c9 14	 imul	 rcx, rcx, 20
  09184	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9379 :         OrResult[23] |= OrConstant[22];

  09188	b8 04 00 00 00	 mov	 eax, 4
  0918d	48 6b c0 17	 imul	 rax, rax, 23
  09191	b9 04 00 00 00	 mov	 ecx, 4
  09196	48 6b c9 16	 imul	 rcx, rcx, 22
  0919a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  091a1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  091a4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  091a8	0b c1		 or	 eax, ecx
  091aa	b9 04 00 00 00	 mov	 ecx, 4
  091af	48 6b c9 17	 imul	 rcx, rcx, 23
  091b3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9380 :         OrResult[24] |= OrConstant[14];

  091b7	b8 04 00 00 00	 mov	 eax, 4
  091bc	48 6b c0 18	 imul	 rax, rax, 24
  091c0	b9 04 00 00 00	 mov	 ecx, 4
  091c5	48 6b c9 0e	 imul	 rcx, rcx, 14
  091c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  091d0	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  091d3	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  091d7	0b c1		 or	 eax, ecx
  091d9	b9 04 00 00 00	 mov	 ecx, 4
  091de	48 6b c9 18	 imul	 rcx, rcx, 24
  091e2	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9381 :         OrResult[27] |= OrConstant[16];

  091e6	b8 04 00 00 00	 mov	 eax, 4
  091eb	48 6b c0 1b	 imul	 rax, rax, 27
  091ef	b9 04 00 00 00	 mov	 ecx, 4
  091f4	48 6b c9 10	 imul	 rcx, rcx, 16
  091f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  091ff	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09202	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09206	0b c1		 or	 eax, ecx
  09208	b9 04 00 00 00	 mov	 ecx, 4
  0920d	48 6b c9 1b	 imul	 rcx, rcx, 27
  09211	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9382 :         OrResult[31] |= OrConstant[21];

  09215	b8 04 00 00 00	 mov	 eax, 4
  0921a	48 6b c0 1f	 imul	 rax, rax, 31
  0921e	b9 04 00 00 00	 mov	 ecx, 4
  09223	48 6b c9 15	 imul	 rcx, rcx, 21
  09227	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0922e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09231	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09235	0b c1		 or	 eax, ecx
  09237	b9 04 00 00 00	 mov	 ecx, 4
  0923c	48 6b c9 1f	 imul	 rcx, rcx, 31
  09240	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN65@gen_csv_si:

; 9383 :     }
; 9384 :     if ((pClock1[7] & 0x02 ) == 0x02)

  09244	b8 01 00 00 00	 mov	 eax, 1
  09249	48 6b c0 07	 imul	 rax, rax, 7
  0924d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pClock1$[rsp]
  09255	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  09259	83 e0 02	 and	 eax, 2
  0925c	83 f8 02	 cmp	 eax, 2
  0925f	0f 85 92 02 00
	00		 jne	 $LN66@gen_csv_si

; 9385 :     {
; 9386 :         OrResult[1]  |= OrConstant[22];

  09265	b8 04 00 00 00	 mov	 eax, 4
  0926a	48 6b c0 01	 imul	 rax, rax, 1
  0926e	b9 04 00 00 00	 mov	 ecx, 4
  09273	48 6b c9 16	 imul	 rcx, rcx, 22
  09277	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0927e	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09281	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09285	0b c1		 or	 eax, ecx
  09287	b9 04 00 00 00	 mov	 ecx, 4
  0928c	48 6b c9 01	 imul	 rcx, rcx, 1
  09290	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9387 :         OrResult[3]  |= OrConstant[12];

  09294	b8 04 00 00 00	 mov	 eax, 4
  09299	48 6b c0 03	 imul	 rax, rax, 3
  0929d	b9 04 00 00 00	 mov	 ecx, 4
  092a2	48 6b c9 0c	 imul	 rcx, rcx, 12
  092a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  092ad	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  092b0	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  092b4	0b c1		 or	 eax, ecx
  092b6	b9 04 00 00 00	 mov	 ecx, 4
  092bb	48 6b c9 03	 imul	 rcx, rcx, 3
  092bf	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9388 :         OrResult[5]  |= OrConstant[23];

  092c3	b8 04 00 00 00	 mov	 eax, 4
  092c8	48 6b c0 05	 imul	 rax, rax, 5
  092cc	b9 04 00 00 00	 mov	 ecx, 4
  092d1	48 6b c9 17	 imul	 rcx, rcx, 23
  092d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  092dc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  092df	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  092e3	0b c1		 or	 eax, ecx
  092e5	b9 04 00 00 00	 mov	 ecx, 4
  092ea	48 6b c9 05	 imul	 rcx, rcx, 5
  092ee	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9389 :         OrResult[6]  |= OrConstant[22];

  092f2	b8 04 00 00 00	 mov	 eax, 4
  092f7	48 6b c0 06	 imul	 rax, rax, 6
  092fb	b9 04 00 00 00	 mov	 ecx, 4
  09300	48 6b c9 16	 imul	 rcx, rcx, 22
  09304	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0930b	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0930e	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09312	0b c1		 or	 eax, ecx
  09314	b9 04 00 00 00	 mov	 ecx, 4
  09319	48 6b c9 06	 imul	 rcx, rcx, 6
  0931d	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9390 :         OrResult[9]  |= OrConstant[21];

  09321	b8 04 00 00 00	 mov	 eax, 4
  09326	48 6b c0 09	 imul	 rax, rax, 9
  0932a	b9 04 00 00 00	 mov	 ecx, 4
  0932f	48 6b c9 15	 imul	 rcx, rcx, 21
  09333	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  0933a	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0933d	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09341	0b c1		 or	 eax, ecx
  09343	b9 04 00 00 00	 mov	 ecx, 4
  09348	48 6b c9 09	 imul	 rcx, rcx, 9
  0934c	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9391 :         OrResult[13] |= OrConstant[13];

  09350	b8 04 00 00 00	 mov	 eax, 4
  09355	48 6b c0 0d	 imul	 rax, rax, 13
  09359	b9 04 00 00 00	 mov	 ecx, 4
  0935e	48 6b c9 0d	 imul	 rcx, rcx, 13
  09362	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09369	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0936c	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  09370	0b c1		 or	 eax, ecx
  09372	b9 04 00 00 00	 mov	 ecx, 4
  09377	48 6b c9 0d	 imul	 rcx, rcx, 13
  0937b	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9392 :         OrResult[15] |= OrConstant[19];

  0937f	b8 04 00 00 00	 mov	 eax, 4
  09384	48 6b c0 0f	 imul	 rax, rax, 15
  09388	b9 04 00 00 00	 mov	 ecx, 4
  0938d	48 6b c9 13	 imul	 rcx, rcx, 19
  09391	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09398	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  0939b	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0939f	0b c1		 or	 eax, ecx
  093a1	b9 04 00 00 00	 mov	 ecx, 4
  093a6	48 6b c9 0f	 imul	 rcx, rcx, 15
  093aa	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9393 :         OrResult[19] |= OrConstant[15];

  093ae	b8 04 00 00 00	 mov	 eax, 4
  093b3	48 6b c0 13	 imul	 rax, rax, 19
  093b7	b9 04 00 00 00	 mov	 ecx, 4
  093bc	48 6b c9 0f	 imul	 rcx, rcx, 15
  093c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  093c7	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  093ca	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  093ce	0b c1		 or	 eax, ecx
  093d0	b9 04 00 00 00	 mov	 ecx, 4
  093d5	48 6b c9 13	 imul	 rcx, rcx, 19
  093d9	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9394 :         OrResult[20] |= OrConstant[16];

  093dd	b8 04 00 00 00	 mov	 eax, 4
  093e2	48 6b c0 14	 imul	 rax, rax, 20
  093e6	b9 04 00 00 00	 mov	 ecx, 4
  093eb	48 6b c9 10	 imul	 rcx, rcx, 16
  093ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  093f6	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  093f9	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  093fd	0b c1		 or	 eax, ecx
  093ff	b9 04 00 00 00	 mov	 ecx, 4
  09404	48 6b c9 14	 imul	 rcx, rcx, 20
  09408	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9395 :         OrResult[22] |= OrConstant[19];

  0940c	b8 04 00 00 00	 mov	 eax, 4
  09411	48 6b c0 16	 imul	 rax, rax, 22
  09415	b9 04 00 00 00	 mov	 ecx, 4
  0941a	48 6b c9 13	 imul	 rcx, rcx, 19
  0941e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09425	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09428	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0942c	0b c1		 or	 eax, ecx
  0942e	b9 04 00 00 00	 mov	 ecx, 4
  09433	48 6b c9 16	 imul	 rcx, rcx, 22
  09437	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9396 :         OrResult[25] |= OrConstant[14];

  0943b	b8 04 00 00 00	 mov	 eax, 4
  09440	48 6b c0 19	 imul	 rax, rax, 25
  09444	b9 04 00 00 00	 mov	 ecx, 4
  09449	48 6b c9 0e	 imul	 rcx, rcx, 14
  0944d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09454	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09457	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0945b	0b c1		 or	 eax, ecx
  0945d	b9 04 00 00 00	 mov	 ecx, 4
  09462	48 6b c9 19	 imul	 rcx, rcx, 25
  09466	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9397 :         OrResult[26] |= OrConstant[23];

  0946a	b8 04 00 00 00	 mov	 eax, 4
  0946f	48 6b c0 1a	 imul	 rax, rax, 26
  09473	b9 04 00 00 00	 mov	 ecx, 4
  09478	48 6b c9 17	 imul	 rcx, rcx, 23
  0947c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  09483	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  09486	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  0948a	0b c1		 or	 eax, ecx
  0948c	b9 04 00 00 00	 mov	 ecx, 4
  09491	48 6b c9 1a	 imul	 rcx, rcx, 26
  09495	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9398 :         OrResult[28] |= OrConstant[17];

  09499	b8 04 00 00 00	 mov	 eax, 4
  0949e	48 6b c0 1c	 imul	 rax, rax, 28
  094a2	b9 04 00 00 00	 mov	 ecx, 4
  094a7	48 6b c9 11	 imul	 rcx, rcx, 17
  094ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  094b2	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  094b5	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  094b9	0b c1		 or	 eax, ecx
  094bb	b9 04 00 00 00	 mov	 ecx, 4
  094c0	48 6b c9 1c	 imul	 rcx, rcx, 28
  094c4	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax

; 9399 :         OrResult[30] |= OrConstant[21];

  094c8	b8 04 00 00 00	 mov	 eax, 4
  094cd	48 6b c0 1e	 imul	 rax, rax, 30
  094d1	b9 04 00 00 00	 mov	 ecx, 4
  094d6	48 6b c9 15	 imul	 rcx, rcx, 21
  094da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?OrConstant@?1??gen_csv_sid@@9@9
  094e1	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  094e4	8b 44 04 70	 mov	 eax, DWORD PTR OrResult$[rsp+rax]
  094e8	0b c1		 or	 eax, ecx
  094ea	b9 04 00 00 00	 mov	 ecx, 4
  094ef	48 6b c9 1e	 imul	 rcx, rcx, 30
  094f3	89 44 0c 70	 mov	 DWORD PTR OrResult$[rsp+rcx], eax
$LN66@gen_csv_si:

; 9400 :     }
; 9401 : 
; 9402 :     // Process the 32 OrResult[] values and the XorClocks value
; 9403 :     // to produce 2 XorResult[] values.
; 9404 :     FETCH_FW( wv[3], XorClocks+0 );

  094f7	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR XorClocks$[rsp]
  094ff	e8 00 00 00 00	 call	 fetch_fw_noswap
  09504	8b c8		 mov	 ecx, eax
  09506	e8 00 00 00 00	 call	 _byteswap_ulong
  0950b	b9 04 00 00 00	 mov	 ecx, 4
  09510	48 6b c9 03	 imul	 rcx, rcx, 3
  09514	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9405 :     FETCH_FW( wv[4], XorClocks+4 );

  0951b	48 8d 84 24 34
	01 00 00	 lea	 rax, QWORD PTR XorClocks$[rsp+4]
  09523	48 8b c8	 mov	 rcx, rax
  09526	e8 00 00 00 00	 call	 fetch_fw_noswap
  0952b	8b c8		 mov	 ecx, eax
  0952d	e8 00 00 00 00	 call	 _byteswap_ulong
  09532	b9 04 00 00 00	 mov	 ecx, 4
  09537	48 6b c9 04	 imul	 rcx, rcx, 4
  0953b	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9406 :     j = 30;                              // Index to last two OrResult[] values.

  09542	c7 44 24 24 1e
	00 00 00	 mov	 DWORD PTR j$[rsp], 30

; 9407 :     wv[0] = 252;                         // 252 = 0x000000fc

  0954a	b8 04 00 00 00	 mov	 eax, 4
  0954f	48 6b c0 00	 imul	 rax, rax, 0
  09553	c7 84 04 f0 00
	00 00 fc 00 00
	00		 mov	 DWORD PTR wv$[rsp+rax], 252 ; 000000fcH

; 9408 :     wv[9] = 16;                          //  16 = 0x00000010

  0955e	b8 04 00 00 00	 mov	 eax, 4
  09563	48 6b c0 09	 imul	 rax, rax, 9
  09567	c7 84 04 f0 00
	00 00 10 00 00
	00		 mov	 DWORD PTR wv$[rsp+rax], 16

; 9409 :     wv[2] = wv[3];

  09572	b8 04 00 00 00	 mov	 eax, 4
  09577	48 6b c0 03	 imul	 rax, rax, 3
  0957b	b9 04 00 00 00	 mov	 ecx, 4
  09580	48 6b c9 02	 imul	 rcx, rcx, 2
  09584	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  0958b	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9410 :     wv[5] = wv[4];

  09592	b8 04 00 00 00	 mov	 eax, 4
  09597	48 6b c0 04	 imul	 rax, rax, 4
  0959b	b9 04 00 00 00	 mov	 ecx, 4
  095a0	48 6b c9 05	 imul	 rcx, rcx, 5
  095a4	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  095ab	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9411 :     shift_right_dbl( &wv[2], &wv[3], 1 );

  095b2	b8 04 00 00 00	 mov	 eax, 4
  095b7	48 6b c0 03	 imul	 rax, rax, 3
  095bb	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  095c3	b9 04 00 00 00	 mov	 ecx, 4
  095c8	48 6b c9 02	 imul	 rcx, rcx, 2
  095cc	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  095d4	41 b8 01 00 00
	00		 mov	 r8d, 1
  095da	48 8b d0	 mov	 rdx, rax
  095dd	e8 00 00 00 00	 call	 shift_right_dbl

; 9412 :     shift_right_dbl( &wv[4], &wv[5], 1 );

  095e2	b8 04 00 00 00	 mov	 eax, 4
  095e7	48 6b c0 05	 imul	 rax, rax, 5
  095eb	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  095f3	b9 04 00 00 00	 mov	 ecx, 4
  095f8	48 6b c9 04	 imul	 rcx, rcx, 4
  095fc	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  09604	41 b8 01 00 00
	00		 mov	 r8d, 1
  0960a	48 8b d0	 mov	 rdx, rax
  0960d	e8 00 00 00 00	 call	 shift_right_dbl

; 9413 : 
; 9414 :     for( i = 0; i <= 15; i++ )

  09612	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0961a	eb 0a		 jmp	 SHORT $LN10@gen_csv_si
$LN8@gen_csv_si:
  0961c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  09620	ff c0		 inc	 eax
  09622	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@gen_csv_si:
  09626	83 7c 24 20 0f	 cmp	 DWORD PTR i$[rsp], 15
  0962b	0f 8f 83 07 00
	00		 jg	 $LN9@gen_csv_si

; 9415 :     {
; 9416 :         wv[2] = wv[5];

  09631	b8 04 00 00 00	 mov	 eax, 4
  09636	48 6b c0 05	 imul	 rax, rax, 5
  0963a	b9 04 00 00 00	 mov	 ecx, 4
  0963f	48 6b c9 02	 imul	 rcx, rcx, 2
  09643	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  0964a	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9417 :         wv[6] = wv[5];

  09651	b8 04 00 00 00	 mov	 eax, 4
  09656	48 6b c0 05	 imul	 rax, rax, 5
  0965a	b9 04 00 00 00	 mov	 ecx, 4
  0965f	48 6b c9 06	 imul	 rcx, rcx, 6
  09663	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  0966a	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9418 :         wv[7] = wv[5];

  09671	b8 04 00 00 00	 mov	 eax, 4
  09676	48 6b c0 05	 imul	 rax, rax, 5
  0967a	b9 04 00 00 00	 mov	 ecx, 4
  0967f	48 6b c9 07	 imul	 rcx, rcx, 7
  09683	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  0968a	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9419 :         shift_right_dbl( &wv[6], &wv[7], 28 );

  09691	b8 04 00 00 00	 mov	 eax, 4
  09696	48 6b c0 07	 imul	 rax, rax, 7
  0969a	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  096a2	b9 04 00 00 00	 mov	 ecx, 4
  096a7	48 6b c9 06	 imul	 rcx, rcx, 6
  096ab	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  096b3	41 b8 1c 00 00
	00		 mov	 r8d, 28
  096b9	48 8b d0	 mov	 rdx, rax
  096bc	e8 00 00 00 00	 call	 shift_right_dbl

; 9420 :         wv[5] ^= OrResult[j];

  096c1	b8 04 00 00 00	 mov	 eax, 4
  096c6	48 6b c0 05	 imul	 rax, rax, 5
  096ca	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  096cf	8b 4c 8c 70	 mov	 ecx, DWORD PTR OrResult$[rsp+rcx*4]
  096d3	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  096da	33 c1		 xor	 eax, ecx
  096dc	b9 04 00 00 00	 mov	 ecx, 4
  096e1	48 6b c9 05	 imul	 rcx, rcx, 5
  096e5	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9421 :         wv[7] ^= OrResult[j + 1];

  096ec	b8 04 00 00 00	 mov	 eax, 4
  096f1	48 6b c0 07	 imul	 rax, rax, 7
  096f5	8b 4c 24 24	 mov	 ecx, DWORD PTR j$[rsp]
  096f9	ff c1		 inc	 ecx
  096fb	48 63 c9	 movsxd	 rcx, ecx
  096fe	8b 4c 8c 70	 mov	 ecx, DWORD PTR OrResult$[rsp+rcx*4]
  09702	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09709	33 c1		 xor	 eax, ecx
  0970b	b9 04 00 00 00	 mov	 ecx, 4
  09710	48 6b c9 07	 imul	 rcx, rcx, 7
  09714	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9422 :         shift_left_dbl( &wv[4], &wv[5], 8 );

  0971b	b8 04 00 00 00	 mov	 eax, 4
  09720	48 6b c0 05	 imul	 rax, rax, 5
  09724	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  0972c	b9 04 00 00 00	 mov	 ecx, 4
  09731	48 6b c9 04	 imul	 rcx, rcx, 4
  09735	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  0973d	41 b8 08 00 00
	00		 mov	 r8d, 8
  09743	48 8b d0	 mov	 rdx, rax
  09746	e8 00 00 00 00	 call	 shift_left_dbl

; 9423 :         shift_left_dbl( &wv[6], &wv[7], 8 );

  0974b	b8 04 00 00 00	 mov	 eax, 4
  09750	48 6b c0 07	 imul	 rax, rax, 7
  09754	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  0975c	b9 04 00 00 00	 mov	 ecx, 4
  09761	48 6b c9 06	 imul	 rcx, rcx, 6
  09765	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  0976d	41 b8 08 00 00
	00		 mov	 r8d, 8
  09773	48 8b d0	 mov	 rdx, rax
  09776	e8 00 00 00 00	 call	 shift_left_dbl

; 9424 :         wv[1] = wv[4];

  0977b	b8 04 00 00 00	 mov	 eax, 4
  09780	48 6b c0 04	 imul	 rax, rax, 4
  09784	b9 04 00 00 00	 mov	 ecx, 4
  09789	48 6b c9 01	 imul	 rcx, rcx, 1
  0978d	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09794	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9425 :         wv[14] = wv[6];

  0979b	b8 04 00 00 00	 mov	 eax, 4
  097a0	48 6b c0 06	 imul	 rax, rax, 6
  097a4	b9 04 00 00 00	 mov	 ecx, 4
  097a9	48 6b c9 0e	 imul	 rcx, rcx, 14
  097ad	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  097b4	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9426 :         shift_left_dbl( &wv[4], &wv[5], 8 );

  097bb	b8 04 00 00 00	 mov	 eax, 4
  097c0	48 6b c0 05	 imul	 rax, rax, 5
  097c4	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  097cc	b9 04 00 00 00	 mov	 ecx, 4
  097d1	48 6b c9 04	 imul	 rcx, rcx, 4
  097d5	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  097dd	41 b8 08 00 00
	00		 mov	 r8d, 8
  097e3	48 8b d0	 mov	 rdx, rax
  097e6	e8 00 00 00 00	 call	 shift_left_dbl

; 9427 :         shift_left_dbl( &wv[6], &wv[7], 8 );

  097eb	b8 04 00 00 00	 mov	 eax, 4
  097f0	48 6b c0 07	 imul	 rax, rax, 7
  097f4	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  097fc	b9 04 00 00 00	 mov	 ecx, 4
  09801	48 6b c9 06	 imul	 rcx, rcx, 6
  09805	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  0980d	41 b8 08 00 00
	00		 mov	 r8d, 8
  09813	48 8b d0	 mov	 rdx, rax
  09816	e8 00 00 00 00	 call	 shift_left_dbl

; 9428 :         wv[1] &= wv[0];

  0981b	b8 04 00 00 00	 mov	 eax, 4
  09820	48 6b c0 01	 imul	 rax, rax, 1
  09824	b9 04 00 00 00	 mov	 ecx, 4
  09829	48 6b c9 00	 imul	 rcx, rcx, 0
  0982d	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09834	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  0983b	23 c1		 and	 eax, ecx
  0983d	b9 04 00 00 00	 mov	 ecx, 4
  09842	48 6b c9 01	 imul	 rcx, rcx, 1
  09846	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9429 :         wv[14] &= wv[0];

  0984d	b8 04 00 00 00	 mov	 eax, 4
  09852	48 6b c0 0e	 imul	 rax, rax, 14
  09856	b9 04 00 00 00	 mov	 ecx, 4
  0985b	48 6b c9 00	 imul	 rcx, rcx, 0
  0985f	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09866	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  0986d	23 c1		 and	 eax, ecx
  0986f	b9 04 00 00 00	 mov	 ecx, 4
  09874	48 6b c9 0e	 imul	 rcx, rcx, 14
  09878	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9430 :         wv[4] &= wv[0];

  0987f	b8 04 00 00 00	 mov	 eax, 4
  09884	48 6b c0 04	 imul	 rax, rax, 4
  09888	b9 04 00 00 00	 mov	 ecx, 4
  0988d	48 6b c9 00	 imul	 rcx, rcx, 0
  09891	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09898	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  0989f	23 c1		 and	 eax, ecx
  098a1	b9 04 00 00 00	 mov	 ecx, 4
  098a6	48 6b c9 04	 imul	 rcx, rcx, 4
  098aa	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9431 :         wv[6] &= wv[0];

  098b1	b8 04 00 00 00	 mov	 eax, 4
  098b6	48 6b c0 06	 imul	 rax, rax, 6
  098ba	b9 04 00 00 00	 mov	 ecx, 4
  098bf	48 6b c9 00	 imul	 rcx, rcx, 0
  098c3	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  098ca	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  098d1	23 c1		 and	 eax, ecx
  098d3	b9 04 00 00 00	 mov	 ecx, 4
  098d8	48 6b c9 06	 imul	 rcx, rcx, 6
  098dc	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9432 :         wv[3] ^= XorConstant[0 + ( wv[1] / 4)];

  098e3	b8 04 00 00 00	 mov	 eax, 4
  098e8	48 6b c0 03	 imul	 rax, rax, 3
  098ec	48 89 44 24 30	 mov	 QWORD PTR tv5913[rsp], rax
  098f1	b9 04 00 00 00	 mov	 ecx, 4
  098f6	48 6b c9 01	 imul	 rcx, rcx, 1
  098fa	33 d2		 xor	 edx, edx
  098fc	8b 84 0c f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rcx]
  09903	b9 04 00 00 00	 mov	 ecx, 4
  09908	f7 f1		 div	 ecx
  0990a	8b c0		 mov	 eax, eax
  0990c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?XorConstant@?1??gen_csv_sid@@9@9
  09913	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  09916	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv5913[rsp]
  0991b	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09922	33 c8		 xor	 ecx, eax
  09924	8b c1		 mov	 eax, ecx
  09926	b9 04 00 00 00	 mov	 ecx, 4
  0992b	48 6b c9 03	 imul	 rcx, rcx, 3
  0992f	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9433 :         wv[3] ^= XorConstant[64 + ( wv[14] / 4)];

  09936	b8 04 00 00 00	 mov	 eax, 4
  0993b	48 6b c0 03	 imul	 rax, rax, 3
  0993f	48 89 44 24 38	 mov	 QWORD PTR tv5925[rsp], rax
  09944	b9 04 00 00 00	 mov	 ecx, 4
  09949	48 6b c9 0e	 imul	 rcx, rcx, 14
  0994d	33 d2		 xor	 edx, edx
  0994f	8b 84 0c f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rcx]
  09956	b9 04 00 00 00	 mov	 ecx, 4
  0995b	f7 f1		 div	 ecx
  0995d	83 c0 40	 add	 eax, 64			; 00000040H
  09960	8b c0		 mov	 eax, eax
  09962	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?XorConstant@?1??gen_csv_sid@@9@9
  09969	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0996c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv5925[rsp]
  09971	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09978	33 c8		 xor	 ecx, eax
  0997a	8b c1		 mov	 eax, ecx
  0997c	b9 04 00 00 00	 mov	 ecx, 4
  09981	48 6b c9 03	 imul	 rcx, rcx, 3
  09985	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9434 :         wv[3] ^= XorConstant[128 + ( wv[4] / 4 )];

  0998c	b8 04 00 00 00	 mov	 eax, 4
  09991	48 6b c0 03	 imul	 rax, rax, 3
  09995	48 89 44 24 40	 mov	 QWORD PTR tv5937[rsp], rax
  0999a	b9 04 00 00 00	 mov	 ecx, 4
  0999f	48 6b c9 04	 imul	 rcx, rcx, 4
  099a3	33 d2		 xor	 edx, edx
  099a5	8b 84 0c f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rcx]
  099ac	b9 04 00 00 00	 mov	 ecx, 4
  099b1	f7 f1		 div	 ecx
  099b3	05 80 00 00 00	 add	 eax, 128		; 00000080H
  099b8	8b c0		 mov	 eax, eax
  099ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?XorConstant@?1??gen_csv_sid@@9@9
  099c1	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  099c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv5937[rsp]
  099c9	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  099d0	33 c8		 xor	 ecx, eax
  099d2	8b c1		 mov	 eax, ecx
  099d4	b9 04 00 00 00	 mov	 ecx, 4
  099d9	48 6b c9 03	 imul	 rcx, rcx, 3
  099dd	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9435 :         wv[3] ^= XorConstant[192 + ( wv[6] / 4 )];

  099e4	b8 04 00 00 00	 mov	 eax, 4
  099e9	48 6b c0 03	 imul	 rax, rax, 3
  099ed	48 89 44 24 48	 mov	 QWORD PTR tv5949[rsp], rax
  099f2	b9 04 00 00 00	 mov	 ecx, 4
  099f7	48 6b c9 06	 imul	 rcx, rcx, 6
  099fb	33 d2		 xor	 edx, edx
  099fd	8b 84 0c f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rcx]
  09a04	b9 04 00 00 00	 mov	 ecx, 4
  09a09	f7 f1		 div	 ecx
  09a0b	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  09a10	8b c0		 mov	 eax, eax
  09a12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?XorConstant@?1??gen_csv_sid@@9@9
  09a19	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  09a1c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv5949[rsp]
  09a21	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09a28	33 c8		 xor	 ecx, eax
  09a2a	8b c1		 mov	 eax, ecx
  09a2c	b9 04 00 00 00	 mov	 ecx, 4
  09a31	48 6b c9 03	 imul	 rcx, rcx, 3
  09a35	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9436 :         shift_left_dbl( &wv[4], &wv[5], 8 );

  09a3c	b8 04 00 00 00	 mov	 eax, 4
  09a41	48 6b c0 05	 imul	 rax, rax, 5
  09a45	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  09a4d	b9 04 00 00 00	 mov	 ecx, 4
  09a52	48 6b c9 04	 imul	 rcx, rcx, 4
  09a56	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  09a5e	41 b8 08 00 00
	00		 mov	 r8d, 8
  09a64	48 8b d0	 mov	 rdx, rax
  09a67	e8 00 00 00 00	 call	 shift_left_dbl

; 9437 :         shift_left_dbl( &wv[6], &wv[7], 8 );

  09a6c	b8 04 00 00 00	 mov	 eax, 4
  09a71	48 6b c0 07	 imul	 rax, rax, 7
  09a75	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  09a7d	b9 04 00 00 00	 mov	 ecx, 4
  09a82	48 6b c9 06	 imul	 rcx, rcx, 6
  09a86	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  09a8e	41 b8 08 00 00
	00		 mov	 r8d, 8
  09a94	48 8b d0	 mov	 rdx, rax
  09a97	e8 00 00 00 00	 call	 shift_left_dbl

; 9438 :         wv[1] = wv[4];

  09a9c	b8 04 00 00 00	 mov	 eax, 4
  09aa1	48 6b c0 04	 imul	 rax, rax, 4
  09aa5	b9 04 00 00 00	 mov	 ecx, 4
  09aaa	48 6b c9 01	 imul	 rcx, rcx, 1
  09aae	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09ab5	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9439 :         wv[14] = wv[6];

  09abc	b8 04 00 00 00	 mov	 eax, 4
  09ac1	48 6b c0 06	 imul	 rax, rax, 6
  09ac5	b9 04 00 00 00	 mov	 ecx, 4
  09aca	48 6b c9 0e	 imul	 rcx, rcx, 14
  09ace	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09ad5	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9440 :         shift_left_dbl( &wv[4], &wv[5], 8 );

  09adc	b8 04 00 00 00	 mov	 eax, 4
  09ae1	48 6b c0 05	 imul	 rax, rax, 5
  09ae5	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  09aed	b9 04 00 00 00	 mov	 ecx, 4
  09af2	48 6b c9 04	 imul	 rcx, rcx, 4
  09af6	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  09afe	41 b8 08 00 00
	00		 mov	 r8d, 8
  09b04	48 8b d0	 mov	 rdx, rax
  09b07	e8 00 00 00 00	 call	 shift_left_dbl

; 9441 :         shift_left_dbl( &wv[6], &wv[7], 8 );

  09b0c	b8 04 00 00 00	 mov	 eax, 4
  09b11	48 6b c0 07	 imul	 rax, rax, 7
  09b15	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  09b1d	b9 04 00 00 00	 mov	 ecx, 4
  09b22	48 6b c9 06	 imul	 rcx, rcx, 6
  09b26	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  09b2e	41 b8 08 00 00
	00		 mov	 r8d, 8
  09b34	48 8b d0	 mov	 rdx, rax
  09b37	e8 00 00 00 00	 call	 shift_left_dbl

; 9442 :         wv[1] &= wv[0];

  09b3c	b8 04 00 00 00	 mov	 eax, 4
  09b41	48 6b c0 01	 imul	 rax, rax, 1
  09b45	b9 04 00 00 00	 mov	 ecx, 4
  09b4a	48 6b c9 00	 imul	 rcx, rcx, 0
  09b4e	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09b55	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09b5c	23 c1		 and	 eax, ecx
  09b5e	b9 04 00 00 00	 mov	 ecx, 4
  09b63	48 6b c9 01	 imul	 rcx, rcx, 1
  09b67	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9443 :         wv[14] &= wv[0];

  09b6e	b8 04 00 00 00	 mov	 eax, 4
  09b73	48 6b c0 0e	 imul	 rax, rax, 14
  09b77	b9 04 00 00 00	 mov	 ecx, 4
  09b7c	48 6b c9 00	 imul	 rcx, rcx, 0
  09b80	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09b87	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09b8e	23 c1		 and	 eax, ecx
  09b90	b9 04 00 00 00	 mov	 ecx, 4
  09b95	48 6b c9 0e	 imul	 rcx, rcx, 14
  09b99	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9444 :         wv[4] &= wv[0];

  09ba0	b8 04 00 00 00	 mov	 eax, 4
  09ba5	48 6b c0 04	 imul	 rax, rax, 4
  09ba9	b9 04 00 00 00	 mov	 ecx, 4
  09bae	48 6b c9 00	 imul	 rcx, rcx, 0
  09bb2	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09bb9	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09bc0	23 c1		 and	 eax, ecx
  09bc2	b9 04 00 00 00	 mov	 ecx, 4
  09bc7	48 6b c9 04	 imul	 rcx, rcx, 4
  09bcb	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9445 :         wv[6] &= wv[0];

  09bd2	b8 04 00 00 00	 mov	 eax, 4
  09bd7	48 6b c0 06	 imul	 rax, rax, 6
  09bdb	b9 04 00 00 00	 mov	 ecx, 4
  09be0	48 6b c9 00	 imul	 rcx, rcx, 0
  09be4	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09beb	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09bf2	23 c1		 and	 eax, ecx
  09bf4	b9 04 00 00 00	 mov	 ecx, 4
  09bf9	48 6b c9 06	 imul	 rcx, rcx, 6
  09bfd	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9446 :         wv[3] ^= XorConstant[256 + ( wv[1] / 4 )];

  09c04	b8 04 00 00 00	 mov	 eax, 4
  09c09	48 6b c0 03	 imul	 rax, rax, 3
  09c0d	48 89 44 24 50	 mov	 QWORD PTR tv6025[rsp], rax
  09c12	b9 04 00 00 00	 mov	 ecx, 4
  09c17	48 6b c9 01	 imul	 rcx, rcx, 1
  09c1b	33 d2		 xor	 edx, edx
  09c1d	8b 84 0c f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rcx]
  09c24	b9 04 00 00 00	 mov	 ecx, 4
  09c29	f7 f1		 div	 ecx
  09c2b	05 00 01 00 00	 add	 eax, 256		; 00000100H
  09c30	8b c0		 mov	 eax, eax
  09c32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?XorConstant@?1??gen_csv_sid@@9@9
  09c39	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  09c3c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv6025[rsp]
  09c41	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09c48	33 c8		 xor	 ecx, eax
  09c4a	8b c1		 mov	 eax, ecx
  09c4c	b9 04 00 00 00	 mov	 ecx, 4
  09c51	48 6b c9 03	 imul	 rcx, rcx, 3
  09c55	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9447 :         wv[3] ^= XorConstant[320 + ( wv[14] / 4 )];

  09c5c	b8 04 00 00 00	 mov	 eax, 4
  09c61	48 6b c0 03	 imul	 rax, rax, 3
  09c65	48 89 44 24 58	 mov	 QWORD PTR tv6037[rsp], rax
  09c6a	b9 04 00 00 00	 mov	 ecx, 4
  09c6f	48 6b c9 0e	 imul	 rcx, rcx, 14
  09c73	33 d2		 xor	 edx, edx
  09c75	8b 84 0c f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rcx]
  09c7c	b9 04 00 00 00	 mov	 ecx, 4
  09c81	f7 f1		 div	 ecx
  09c83	05 40 01 00 00	 add	 eax, 320		; 00000140H
  09c88	8b c0		 mov	 eax, eax
  09c8a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?XorConstant@?1??gen_csv_sid@@9@9
  09c91	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  09c94	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv6037[rsp]
  09c99	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09ca0	33 c8		 xor	 ecx, eax
  09ca2	8b c1		 mov	 eax, ecx
  09ca4	b9 04 00 00 00	 mov	 ecx, 4
  09ca9	48 6b c9 03	 imul	 rcx, rcx, 3
  09cad	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9448 :         wv[3] ^= XorConstant[384 + ( wv[4] / 4 )];

  09cb4	b8 04 00 00 00	 mov	 eax, 4
  09cb9	48 6b c0 03	 imul	 rax, rax, 3
  09cbd	48 89 44 24 60	 mov	 QWORD PTR tv6049[rsp], rax
  09cc2	b9 04 00 00 00	 mov	 ecx, 4
  09cc7	48 6b c9 04	 imul	 rcx, rcx, 4
  09ccb	33 d2		 xor	 edx, edx
  09ccd	8b 84 0c f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rcx]
  09cd4	b9 04 00 00 00	 mov	 ecx, 4
  09cd9	f7 f1		 div	 ecx
  09cdb	05 80 01 00 00	 add	 eax, 384		; 00000180H
  09ce0	8b c0		 mov	 eax, eax
  09ce2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?XorConstant@?1??gen_csv_sid@@9@9
  09ce9	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  09cec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv6049[rsp]
  09cf1	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09cf8	33 c8		 xor	 ecx, eax
  09cfa	8b c1		 mov	 eax, ecx
  09cfc	b9 04 00 00 00	 mov	 ecx, 4
  09d01	48 6b c9 03	 imul	 rcx, rcx, 3
  09d05	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9449 :         wv[3] ^= XorConstant[448 + ( wv[6] / 4 )];

  09d0c	b8 04 00 00 00	 mov	 eax, 4
  09d11	48 6b c0 03	 imul	 rax, rax, 3
  09d15	48 89 44 24 68	 mov	 QWORD PTR tv6061[rsp], rax
  09d1a	b9 04 00 00 00	 mov	 ecx, 4
  09d1f	48 6b c9 06	 imul	 rcx, rcx, 6
  09d23	33 d2		 xor	 edx, edx
  09d25	8b 84 0c f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rcx]
  09d2c	b9 04 00 00 00	 mov	 ecx, 4
  09d31	f7 f1		 div	 ecx
  09d33	05 c0 01 00 00	 add	 eax, 448		; 000001c0H
  09d38	8b c0		 mov	 eax, eax
  09d3a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?XorConstant@?1??gen_csv_sid@@9@9
  09d41	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  09d44	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv6061[rsp]
  09d49	8b 8c 0c f0 00
	00 00		 mov	 ecx, DWORD PTR wv$[rsp+rcx]
  09d50	33 c8		 xor	 ecx, eax
  09d52	8b c1		 mov	 eax, ecx
  09d54	b9 04 00 00 00	 mov	 ecx, 4
  09d59	48 6b c9 03	 imul	 rcx, rcx, 3
  09d5d	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9450 :         wv[5] = wv[3];

  09d64	b8 04 00 00 00	 mov	 eax, 4
  09d69	48 6b c0 03	 imul	 rax, rax, 3
  09d6d	b9 04 00 00 00	 mov	 ecx, 4
  09d72	48 6b c9 05	 imul	 rcx, rcx, 5
  09d76	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09d7d	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9451 :         wv[3] = wv[2];

  09d84	b8 04 00 00 00	 mov	 eax, 4
  09d89	48 6b c0 02	 imul	 rax, rax, 2
  09d8d	b9 04 00 00 00	 mov	 ecx, 4
  09d92	48 6b c9 03	 imul	 rcx, rcx, 3
  09d96	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09d9d	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9452 :         j = j - 2;                       // Index to previous two OrResult[] values.

  09da4	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  09da8	83 e8 02	 sub	 eax, 2
  09dab	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax

; 9453 :     }

  09daf	e9 68 f8 ff ff	 jmp	 $LN8@gen_csv_si
$LN9@gen_csv_si:

; 9454 : 
; 9455 :     wv[6] = wv[5];

  09db4	b8 04 00 00 00	 mov	 eax, 4
  09db9	48 6b c0 05	 imul	 rax, rax, 5
  09dbd	b9 04 00 00 00	 mov	 ecx, 4
  09dc2	48 6b c9 06	 imul	 rcx, rcx, 6
  09dc6	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09dcd	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9456 :     wv[7] = wv[6];

  09dd4	b8 04 00 00 00	 mov	 eax, 4
  09dd9	48 6b c0 06	 imul	 rax, rax, 6
  09ddd	b9 04 00 00 00	 mov	 ecx, 4
  09de2	48 6b c9 07	 imul	 rcx, rcx, 7
  09de6	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09ded	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9457 :     shift_left_dbl( &wv[2], &wv[3], 1 );

  09df4	b8 04 00 00 00	 mov	 eax, 4
  09df9	48 6b c0 03	 imul	 rax, rax, 3
  09dfd	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  09e05	b9 04 00 00 00	 mov	 ecx, 4
  09e0a	48 6b c9 02	 imul	 rcx, rcx, 2
  09e0e	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  09e16	41 b8 01 00 00
	00		 mov	 r8d, 1
  09e1c	48 8b d0	 mov	 rdx, rax
  09e1f	e8 00 00 00 00	 call	 shift_left_dbl

; 9458 :     shift_left_dbl( &wv[6], &wv[7], 1 );

  09e24	b8 04 00 00 00	 mov	 eax, 4
  09e29	48 6b c0 07	 imul	 rax, rax, 7
  09e2d	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR wv$[rsp+rax]
  09e35	b9 04 00 00 00	 mov	 ecx, 4
  09e3a	48 6b c9 06	 imul	 rcx, rcx, 6
  09e3e	48 8d 8c 0c f0
	00 00 00	 lea	 rcx, QWORD PTR wv$[rsp+rcx]
  09e46	41 b8 01 00 00
	00		 mov	 r8d, 1
  09e4c	48 8b d0	 mov	 rdx, rax
  09e4f	e8 00 00 00 00	 call	 shift_left_dbl

; 9459 :     wv[3] = wv[6];

  09e54	b8 04 00 00 00	 mov	 eax, 4
  09e59	48 6b c0 06	 imul	 rax, rax, 6
  09e5d	b9 04 00 00 00	 mov	 ecx, 4
  09e62	48 6b c9 03	 imul	 rcx, rcx, 3
  09e66	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09e6d	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9460 :     wv[4] = wv[2];

  09e74	b8 04 00 00 00	 mov	 eax, 4
  09e79	48 6b c0 02	 imul	 rax, rax, 2
  09e7d	b9 04 00 00 00	 mov	 ecx, 4
  09e82	48 6b c9 04	 imul	 rcx, rcx, 4
  09e86	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09e8d	89 84 0c f0 00
	00 00		 mov	 DWORD PTR wv$[rsp+rcx], eax

; 9461 :     XorResult[0] = wv[3];

  09e94	b8 04 00 00 00	 mov	 eax, 4
  09e99	48 6b c0 03	 imul	 rax, rax, 3
  09e9d	b9 04 00 00 00	 mov	 ecx, 4
  09ea2	48 6b c9 00	 imul	 rcx, rcx, 0
  09ea6	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09ead	89 44 0c 28	 mov	 DWORD PTR XorResult$[rsp+rcx], eax

; 9462 :     XorResult[1] = wv[4];

  09eb1	b8 04 00 00 00	 mov	 eax, 4
  09eb6	48 6b c0 04	 imul	 rax, rax, 4
  09eba	b9 04 00 00 00	 mov	 ecx, 4
  09ebf	48 6b c9 01	 imul	 rcx, rcx, 1
  09ec3	8b 84 04 f0 00
	00 00		 mov	 eax, DWORD PTR wv$[rsp+rax]
  09eca	89 44 0c 28	 mov	 DWORD PTR XorResult$[rsp+rcx], eax

; 9463 : 
; 9464 :     // Return the 2 XorResult[] values in the output pToken value.
; 9465 :     STORE_FW( pToken+0, XorResult[0] );

  09ece	b8 04 00 00 00	 mov	 eax, 4
  09ed3	48 6b c0 00	 imul	 rax, rax, 0
  09ed7	8b 4c 04 28	 mov	 ecx, DWORD PTR XorResult$[rsp+rax]
  09edb	e8 00 00 00 00	 call	 _byteswap_ulong
  09ee0	8b d0		 mov	 edx, eax
  09ee2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pToken$[rsp]
  09eea	e8 00 00 00 00	 call	 store_fw_noswap

; 9466 :     STORE_FW( pToken+4, XorResult[1] );

  09eef	b8 04 00 00 00	 mov	 eax, 4
  09ef4	48 6b c0 01	 imul	 rax, rax, 1
  09ef8	8b 4c 04 28	 mov	 ecx, DWORD PTR XorResult$[rsp+rax]
  09efc	e8 00 00 00 00	 call	 _byteswap_ulong
  09f01	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pToken$[rsp]
  09f09	48 83 c1 04	 add	 rcx, 4
  09f0d	8b d0		 mov	 edx, eax
  09f0f	e8 00 00 00 00	 call	 store_fw_noswap

; 9467 : 
; 9468 :     return;
; 9469 : }   /* End function  gen_csv_sid() */

  09f14	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  09f1c	48 33 cc	 xor	 rcx, rsp
  09f1f	e8 00 00 00 00	 call	 __security_check_cookie
  09f24	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  09f2b	c3		 ret	 0
gen_csv_sid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength6$ = 32
pIP6FRMre$ = 40
uLength3$ = 48
pMPC_RRHre$ = 56
uLength5$ = 64
uLength4$ = 68
pMPC_THre$ = 72
pIcmpHdr$ = 80
uLength1$ = 88
uLength2$ = 92
pMPC_PHre$ = 96
pPTPHDRre$ = 104
pPTPBLK$ = 112
pHopOpt$ = 120
pPTPATHre$ = 128
pPTPATH$ = 136
pDEVBLK$ = 176
build_8108_icmpv6_packets PROC

; 7854 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 7855 :     PTPATH*    pPTPATH   = pDEVBLK->dev_data;

  0000e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00016	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0001d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7856 :     PTPBLK*    pPTPBLK   = pPTPATH->pPTPBLK;

  00025	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 70	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7857 :     PTPATH*    pPTPATHre = pPTPBLK->pPTPATHRead;

  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPATHre$[rsp], rax

; 7858 :     U32        uLength1;
; 7859 :     U32        uLength2;
; 7860 :     U32        uLength3;
; 7861 :     U16        uLength4;
; 7862 :     U16        uLength5;
; 7863 :     U16        uLength6;
; 7864 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7865 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7866 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7867 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7868 :     PIP6FRM    pIP6FRMre;     // IPv6 header
; 7869 :     BYTE*      pHopOpt;       // Hop-by-Hop Options follows IPv6 header
; 7870 :     BYTE*      pIcmpHdr;      // ICMPv6 header follows IPv6 header or Hop-by-Hop
; 7871 : 
; 7872 : 
; 7873 :     // Allocate a buffer in which the ICMPv6 Neighbor Advertisment message
; 7874 :     // will be built. Note: the message will be 128 bytes.
; 7875 :     // The source address is the drive link local address, the destination
; 7876 :     // address is the Link-Local Scope All Nodes multicast address, i.e.
; 7877 :     // FF02:0:0:0:0:0:0:1.
; 7878 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00045	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0004a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00052	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00057	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7879 :     if (!pPTPHDRre)

  0005c	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00062	75 05		 jne	 SHORT $LN2@build_8108

; 7880 :         return;

  00064	e9 33 11 00 00	 jmp	 $LN1@build_8108
$LN2@build_8108:

; 7881 : 
; 7882 :     // Fix-up various lengths
; 7883 :     uLength6 = 24;                            // the ICMPv6 packet

  00069	b8 18 00 00 00	 mov	 eax, 24
  0006e	66 89 44 24 20	 mov	 WORD PTR uLength6$[rsp], ax

; 7884 :     uLength5 = 0;                             // no Hop-by-Hop Options

  00073	33 c0		 xor	 eax, eax
  00075	66 89 44 24 40	 mov	 WORD PTR uLength5$[rsp], ax

; 7885 :     uLength4 = sizeof(IP6FRM);                // the IPv6 header

  0007a	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  0007f	66 89 44 24 44	 mov	 WORD PTR uLength4$[rsp], ax

; 7886 :     uLength3 = uLength4 + uLength6;           // the data

  00084	0f b7 44 24 44	 movzx	 eax, WORD PTR uLength4$[rsp]
  00089	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  0008e	03 c1		 add	 eax, ecx
  00090	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 7887 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00094	c7 44 24 5c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7888 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  0009c	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  000a0	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  000a4	03 c8		 add	 ecx, eax
  000a6	8b c1		 mov	 eax, ecx
  000a8	89 44 24 58	 mov	 DWORD PTR uLength1$[rsp], eax

; 7889 : 
; 7890 :     // Fix-up various pointers
; 7891 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000b1	48 83 c0 10	 add	 rax, 16
  000b5	48 89 44 24 48	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7892 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  000ba	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  000bf	48 83 c0 14	 add	 rax, 20
  000c3	48 89 44 24 38	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7893 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  000c8	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  000cd	48 83 c0 24	 add	 rax, 36			; 00000024H
  000d1	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7894 :     pIP6FRMre = (IP6FRM*)((BYTE*)pMPC_PHre + SIZE_PH);

  000d6	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000db	48 83 c0 08	 add	 rax, 8
  000df	48 89 44 24 28	 mov	 QWORD PTR pIP6FRMre$[rsp], rax

; 7895 :     pHopOpt   = NULL;

  000e4	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pHopOpt$[rsp], 0

; 7896 :     pIcmpHdr  = (BYTE*)pIP6FRMre->bPayload;

  000ed	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  000f2	48 83 c0 28	 add	 rax, 40			; 00000028H
  000f6	48 89 44 24 50	 mov	 QWORD PTR pIcmpHdr$[rsp], rax

; 7897 : 
; 7898 :     // Prepare PTPHDRre
; 7899 :     pPTPHDRre->iDataLen = uLength1;

  000fb	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00100	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00104	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7900 : 
; 7901 :     // Prepare MPC_THre
; 7902 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00107	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  0010c	e8 00 00 00 00	 call	 _byteswap_ulong
  00111	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00116	8b d0		 mov	 edx, eax
  00118	e8 00 00 00 00	 call	 store_fw_noswap

; 7903 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  0011d	b9 14 00 00 00	 mov	 ecx, 20
  00122	e8 00 00 00 00	 call	 _byteswap_ulong
  00127	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0012c	48 83 c1 08	 add	 rcx, 8
  00130	8b d0		 mov	 edx, eax
  00132	e8 00 00 00 00	 call	 store_fw_noswap

; 7904 :     STORE_FW( pMPC_THre->length, uLength1 );

  00137	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0013b	e8 00 00 00 00	 call	 _byteswap_ulong
  00140	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00145	48 83 c1 0c	 add	 rcx, 12
  00149	8b d0		 mov	 edx, eax
  0014b	e8 00 00 00 00	 call	 store_fw_noswap

; 7905 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00150	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00154	e8 00 00 00 00	 call	 _byteswap_ushort
  00159	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0015e	48 83 c1 10	 add	 rcx, 16
  00162	0f b7 d0	 movzx	 edx, ax
  00165	e8 00 00 00 00	 call	 store_hw_noswap

; 7906 :     STORE_HW( pMPC_THre->numrrh, 1 );

  0016a	66 b9 01 00	 mov	 cx, 1
  0016e	e8 00 00 00 00	 call	 _byteswap_ushort
  00173	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00178	48 83 c1 12	 add	 rcx, 18
  0017c	0f b7 d0	 movzx	 edx, ax
  0017f	e8 00 00 00 00	 call	 store_hw_noswap

; 7907 : 
; 7908 :     // Prepare MPC_RRHre
; 7909 :     pMPC_RRHre->type = RRH_TYPE_CM;

  00184	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00189	c6 40 04 81	 mov	 BYTE PTR [rax+4], 129	; 00000081H

; 7910 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  0018d	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00192	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7911 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00196	66 b9 01 00	 mov	 cx, 1
  0019a	e8 00 00 00 00	 call	 _byteswap_ushort
  0019f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a4	48 83 c1 06	 add	 rcx, 6
  001a8	0f b7 d0	 movzx	 edx, ax
  001ab	e8 00 00 00 00	 call	 store_hw_noswap

; 7912 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  001b0	66 b9 24 00	 mov	 cx, 36			; 00000024H
  001b4	e8 00 00 00 00	 call	 _byteswap_ushort
  001b9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001be	48 83 c1 10	 add	 rcx, 16
  001c2	0f b7 d0	 movzx	 edx, ax
  001c5	e8 00 00 00 00	 call	 store_hw_noswap

; 7913 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  001ca	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  001cf	e8 00 00 00 00	 call	 _byteswap_ushort
  001d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001d9	48 83 c1 12	 add	 rcx, 18
  001dd	0f b7 d0	 movzx	 edx, ax
  001e0	e8 00 00 00 00	 call	 store_hw_noswap

; 7914 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  001e5	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001e9	e8 00 00 00 00	 call	 _byteswap_ulong
  001ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001f3	48 83 c1 14	 add	 rcx, 20
  001f7	8b d0		 mov	 edx, eax
  001f9	e8 00 00 00 00	 call	 store_f3_noswap

; 7915 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001fe	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00203	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7916 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  00207	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0020c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00211	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  00217	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7917 : 
; 7918 :     // Prepare MPC_PHre
; 7919 :     pMPC_PHre->locdata = PH_LOC_1;

  0021a	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0021f	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7920 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  00222	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00226	e8 00 00 00 00	 call	 _byteswap_ulong
  0022b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00230	48 ff c1	 inc	 rcx
  00233	8b d0		 mov	 edx, eax
  00235	e8 00 00 00 00	 call	 store_f3_noswap

; 7921 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  0023a	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  0023e	e8 00 00 00 00	 call	 _byteswap_ulong
  00243	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00248	48 83 c1 04	 add	 rcx, 4
  0024c	8b d0		 mov	 edx, eax
  0024e	e8 00 00 00 00	 call	 store_fw_noswap

; 7922 : 
; 7923 :     // Prepare IP6FRMre, i.e. IPv6 header
; 7924 :     pIP6FRMre->bVersTCFlow[0] = 0x60;

  00253	b8 01 00 00 00	 mov	 eax, 1
  00258	48 6b c0 00	 imul	 rax, rax, 0
  0025c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00261	c6 04 01 60	 mov	 BYTE PTR [rcx+rax], 96	; 00000060H

; 7925 :     STORE_HW( pIP6FRMre->bPayloadLength, uLength6 );

  00265	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  0026a	e8 00 00 00 00	 call	 _byteswap_ushort
  0026f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00274	48 83 c1 04	 add	 rcx, 4
  00278	0f b7 d0	 movzx	 edx, ax
  0027b	e8 00 00 00 00	 call	 store_hw_noswap

; 7926 :     pIP6FRMre->bNextHeader = 0x3A;

  00280	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00285	c6 40 06 3a	 mov	 BYTE PTR [rax+6], 58	; 0000003aH

; 7927 :     pIP6FRMre->bHopLimit = 0xFF;

  00289	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  0028e	c6 40 07 ff	 mov	 BYTE PTR [rax+7], 255	; 000000ffH

; 7928 :     memcpy( pIP6FRMre->bSrcAddr, &pPTPBLK->iaDriveLLAddr6, 16 );

  00292	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00297	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0029c	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  002a0	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  002a7	b9 10 00 00 00	 mov	 ecx, 16
  002ac	f3 a4		 rep movsb

; 7929 :     pIP6FRMre->bDstAddr[0]  = 0xFF;

  002ae	b8 01 00 00 00	 mov	 eax, 1
  002b3	48 6b c0 00	 imul	 rax, rax, 0
  002b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  002bc	c6 44 01 18 ff	 mov	 BYTE PTR [rcx+rax+24], 255 ; 000000ffH

; 7930 :     pIP6FRMre->bDstAddr[1]  = 0x02;

  002c1	b8 01 00 00 00	 mov	 eax, 1
  002c6	48 6b c0 01	 imul	 rax, rax, 1
  002ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  002cf	c6 44 01 18 02	 mov	 BYTE PTR [rcx+rax+24], 2

; 7931 :     pIP6FRMre->bDstAddr[15] = 0x01;

  002d4	b8 01 00 00 00	 mov	 eax, 1
  002d9	48 6b c0 0f	 imul	 rax, rax, 15
  002dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  002e2	c6 44 01 18 01	 mov	 BYTE PTR [rcx+rax+24], 1

; 7932 : 
; 7933 :     // Prepare ICMPv6 packet
; 7934 :     pIcmpHdr[0] = 0x88;

  002e7	b8 01 00 00 00	 mov	 eax, 1
  002ec	48 6b c0 00	 imul	 rax, rax, 0
  002f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  002f5	c6 04 01 88	 mov	 BYTE PTR [rcx+rax], 136	; 00000088H

; 7935 :     pIcmpHdr[4] = 0x20;

  002f9	b8 01 00 00 00	 mov	 eax, 1
  002fe	48 6b c0 04	 imul	 rax, rax, 4
  00302	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00307	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H

; 7936 :     memcpy( pIcmpHdr+8, &pPTPBLK->iaDriveLLAddr6, 16 );

  0030b	48 8b 44 24 50	 mov	 rax, QWORD PTR pIcmpHdr$[rsp]
  00310	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00315	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  00319	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  00320	b9 10 00 00 00	 mov	 ecx, 16
  00325	f3 a4		 rep movsb

; 7937 : 
; 7938 :     // Calculate and set the ICMPv6 checksum
; 7939 :     calculate_icmpv6_checksum( pIP6FRMre, pIcmpHdr, (int)uLength6 );

  00327	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength6$[rsp]
  0032c	44 8b c0	 mov	 r8d, eax
  0032f	48 8b 54 24 50	 mov	 rdx, QWORD PTR pIcmpHdr$[rsp]
  00334	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00339	e8 00 00 00 00	 call	 calculate_icmpv6_checksum

; 7940 : 
; 7941 :     // Display various information, maybe
; 7942 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0033e	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00343	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00346	83 e0 10	 and	 eax, 16
  00349	85 c0		 test	 eax, eax
  0034b	74 15		 je	 SHORT $LN3@build_8108

; 7943 :     {
; 7944 :         mpc_display_description( pDEVBLK, "Out RRH 0x8108 (UlpComm) Neighbor advertisment" );

  0034d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172850
  00354	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_8108:

; 7945 :     }
; 7946 : 
; 7947 :     // Add PTPHDR to chain.
; 7948 :     add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00362	48 8b 54 24 68	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00367	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  0036f	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 7949 : 
; 7950 : 
; 7951 :     // Allocate a buffer in which the ICMPv6 Router Solicitation message
; 7952 :     // will be built. Note: the message will be 120 bytes.
; 7953 :     // The source address is the drive link local address, the destination
; 7954 :     // address is the Link-Local Scope All Routers multicast address, i.e.
; 7955 :     // FF02:0:0:0:0:0:0:2.
; 7956 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00374	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00379	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00381	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00386	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7957 :     if (!pPTPHDRre)

  0038b	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00391	75 05		 jne	 SHORT $LN4@build_8108

; 7958 :         return;

  00393	e9 04 0e 00 00	 jmp	 $LN1@build_8108
$LN4@build_8108:

; 7959 : 
; 7960 :     // Fix-up various lengths
; 7961 :     uLength6 = 16;                            // the ICMPv6 packet

  00398	b8 10 00 00 00	 mov	 eax, 16
  0039d	66 89 44 24 20	 mov	 WORD PTR uLength6$[rsp], ax

; 7962 :     uLength5 = 0;                             // no Hop-by-Hop Options

  003a2	33 c0		 xor	 eax, eax
  003a4	66 89 44 24 40	 mov	 WORD PTR uLength5$[rsp], ax

; 7963 :     uLength4 = sizeof(IP6FRM);                // the IPv6 header

  003a9	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  003ae	66 89 44 24 44	 mov	 WORD PTR uLength4$[rsp], ax

; 7964 :     uLength3 = uLength4 + uLength6;           // the data

  003b3	0f b7 44 24 44	 movzx	 eax, WORD PTR uLength4$[rsp]
  003b8	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  003bd	03 c1		 add	 eax, ecx
  003bf	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 7965 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  003c3	c7 44 24 5c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7966 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  003cb	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  003cf	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  003d3	03 c8		 add	 ecx, eax
  003d5	8b c1		 mov	 eax, ecx
  003d7	89 44 24 58	 mov	 DWORD PTR uLength1$[rsp], eax

; 7967 : 
; 7968 :     // Fix-up various pointers
; 7969 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  003db	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  003e0	48 83 c0 10	 add	 rax, 16
  003e4	48 89 44 24 48	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7970 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  003e9	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  003ee	48 83 c0 14	 add	 rax, 20
  003f2	48 89 44 24 38	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7971 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  003f7	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  003fc	48 83 c0 24	 add	 rax, 36			; 00000024H
  00400	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7972 :     pIP6FRMre = (IP6FRM*)((BYTE*)pMPC_PHre + SIZE_PH);

  00405	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0040a	48 83 c0 08	 add	 rax, 8
  0040e	48 89 44 24 28	 mov	 QWORD PTR pIP6FRMre$[rsp], rax

; 7973 :     pHopOpt   = NULL;

  00413	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pHopOpt$[rsp], 0

; 7974 :     pIcmpHdr  = (BYTE*)pIP6FRMre->bPayload;

  0041c	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00421	48 83 c0 28	 add	 rax, 40			; 00000028H
  00425	48 89 44 24 50	 mov	 QWORD PTR pIcmpHdr$[rsp], rax

; 7975 : 
; 7976 :     // Prepare PTPHDRre
; 7977 :     pPTPHDRre->iDataLen = uLength1;

  0042a	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0042f	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00433	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7978 : 
; 7979 :     // Prepare MPC_THre
; 7980 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00436	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  0043b	e8 00 00 00 00	 call	 _byteswap_ulong
  00440	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00445	8b d0		 mov	 edx, eax
  00447	e8 00 00 00 00	 call	 store_fw_noswap

; 7981 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  0044c	b9 14 00 00 00	 mov	 ecx, 20
  00451	e8 00 00 00 00	 call	 _byteswap_ulong
  00456	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0045b	48 83 c1 08	 add	 rcx, 8
  0045f	8b d0		 mov	 edx, eax
  00461	e8 00 00 00 00	 call	 store_fw_noswap

; 7982 :     STORE_FW( pMPC_THre->length, uLength1 );

  00466	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0046a	e8 00 00 00 00	 call	 _byteswap_ulong
  0046f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00474	48 83 c1 0c	 add	 rcx, 12
  00478	8b d0		 mov	 edx, eax
  0047a	e8 00 00 00 00	 call	 store_fw_noswap

; 7983 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  0047f	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00483	e8 00 00 00 00	 call	 _byteswap_ushort
  00488	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0048d	48 83 c1 10	 add	 rcx, 16
  00491	0f b7 d0	 movzx	 edx, ax
  00494	e8 00 00 00 00	 call	 store_hw_noswap

; 7984 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00499	66 b9 01 00	 mov	 cx, 1
  0049d	e8 00 00 00 00	 call	 _byteswap_ushort
  004a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  004a7	48 83 c1 12	 add	 rcx, 18
  004ab	0f b7 d0	 movzx	 edx, ax
  004ae	e8 00 00 00 00	 call	 store_hw_noswap

; 7985 : 
; 7986 :     // Prepare MPC_RRHre
; 7987 :     pMPC_RRHre->type = RRH_TYPE_CM;

  004b3	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  004b8	c6 40 04 81	 mov	 BYTE PTR [rax+4], 129	; 00000081H

; 7988 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  004bc	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  004c1	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7989 :     STORE_HW( pMPC_RRHre->numph, 1 );

  004c5	66 b9 01 00	 mov	 cx, 1
  004c9	e8 00 00 00 00	 call	 _byteswap_ushort
  004ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  004d3	48 83 c1 06	 add	 rcx, 6
  004d7	0f b7 d0	 movzx	 edx, ax
  004da	e8 00 00 00 00	 call	 store_hw_noswap

; 7990 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  004df	66 b9 24 00	 mov	 cx, 36			; 00000024H
  004e3	e8 00 00 00 00	 call	 _byteswap_ushort
  004e8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  004ed	48 83 c1 10	 add	 rcx, 16
  004f1	0f b7 d0	 movzx	 edx, ax
  004f4	e8 00 00 00 00	 call	 store_hw_noswap

; 7991 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  004f9	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  004fe	e8 00 00 00 00	 call	 _byteswap_ushort
  00503	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00508	48 83 c1 12	 add	 rcx, 18
  0050c	0f b7 d0	 movzx	 edx, ax
  0050f	e8 00 00 00 00	 call	 store_hw_noswap

; 7992 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00514	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00518	e8 00 00 00 00	 call	 _byteswap_ulong
  0051d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00522	48 83 c1 14	 add	 rcx, 20
  00526	8b d0		 mov	 edx, eax
  00528	e8 00 00 00 00	 call	 store_f3_noswap

; 7993 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  0052d	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00532	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7994 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  00536	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0053b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00540	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  00546	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7995 : 
; 7996 :     // Prepare MPC_PHre
; 7997 :     pMPC_PHre->locdata = PH_LOC_1;

  00549	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0054e	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7998 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  00551	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00555	e8 00 00 00 00	 call	 _byteswap_ulong
  0055a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  0055f	48 ff c1	 inc	 rcx
  00562	8b d0		 mov	 edx, eax
  00564	e8 00 00 00 00	 call	 store_f3_noswap

; 7999 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  00569	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  0056d	e8 00 00 00 00	 call	 _byteswap_ulong
  00572	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00577	48 83 c1 04	 add	 rcx, 4
  0057b	8b d0		 mov	 edx, eax
  0057d	e8 00 00 00 00	 call	 store_fw_noswap

; 8000 : 
; 8001 :     // Prepare IP6FRMre, i.e. IPv6 header
; 8002 :     pIP6FRMre->bVersTCFlow[0] = 0x60;

  00582	b8 01 00 00 00	 mov	 eax, 1
  00587	48 6b c0 00	 imul	 rax, rax, 0
  0058b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00590	c6 04 01 60	 mov	 BYTE PTR [rcx+rax], 96	; 00000060H

; 8003 :     STORE_HW( pIP6FRMre->bPayloadLength, uLength6 );

  00594	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  00599	e8 00 00 00 00	 call	 _byteswap_ushort
  0059e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  005a3	48 83 c1 04	 add	 rcx, 4
  005a7	0f b7 d0	 movzx	 edx, ax
  005aa	e8 00 00 00 00	 call	 store_hw_noswap

; 8004 :     pIP6FRMre->bNextHeader = 0x3A;

  005af	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  005b4	c6 40 06 3a	 mov	 BYTE PTR [rax+6], 58	; 0000003aH

; 8005 :     pIP6FRMre->bHopLimit = 0xFF;

  005b8	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  005bd	c6 40 07 ff	 mov	 BYTE PTR [rax+7], 255	; 000000ffH

; 8006 :     memcpy( pIP6FRMre->bSrcAddr, &pPTPBLK->iaDriveLLAddr6, 16 );

  005c1	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  005c6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  005cb	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  005cf	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  005d6	b9 10 00 00 00	 mov	 ecx, 16
  005db	f3 a4		 rep movsb

; 8007 :     pIP6FRMre->bDstAddr[0]  = 0xFF;

  005dd	b8 01 00 00 00	 mov	 eax, 1
  005e2	48 6b c0 00	 imul	 rax, rax, 0
  005e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  005eb	c6 44 01 18 ff	 mov	 BYTE PTR [rcx+rax+24], 255 ; 000000ffH

; 8008 :     pIP6FRMre->bDstAddr[1]  = 0x02;

  005f0	b8 01 00 00 00	 mov	 eax, 1
  005f5	48 6b c0 01	 imul	 rax, rax, 1
  005f9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  005fe	c6 44 01 18 02	 mov	 BYTE PTR [rcx+rax+24], 2

; 8009 :     pIP6FRMre->bDstAddr[15] = 0x02;

  00603	b8 01 00 00 00	 mov	 eax, 1
  00608	48 6b c0 0f	 imul	 rax, rax, 15
  0060c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00611	c6 44 01 18 02	 mov	 BYTE PTR [rcx+rax+24], 2

; 8010 : 
; 8011 :     // Prepare ICMPv6 packet
; 8012 :     pIcmpHdr[0] = 0x85;

  00616	b8 01 00 00 00	 mov	 eax, 1
  0061b	48 6b c0 00	 imul	 rax, rax, 0
  0061f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00624	c6 04 01 85	 mov	 BYTE PTR [rcx+rax], 133	; 00000085H

; 8013 :     pIcmpHdr[8] = 0x01;

  00628	b8 01 00 00 00	 mov	 eax, 1
  0062d	48 6b c0 08	 imul	 rax, rax, 8
  00631	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00636	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 8014 :     pIcmpHdr[9] = 0x01;

  0063a	b8 01 00 00 00	 mov	 eax, 1
  0063f	48 6b c0 09	 imul	 rax, rax, 9
  00643	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00648	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 8015 : 
; 8016 :     // Calculate and set the ICMPv6 checksum
; 8017 :     calculate_icmpv6_checksum( pIP6FRMre, pIcmpHdr, (int)uLength6 );

  0064c	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength6$[rsp]
  00651	44 8b c0	 mov	 r8d, eax
  00654	48 8b 54 24 50	 mov	 rdx, QWORD PTR pIcmpHdr$[rsp]
  00659	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  0065e	e8 00 00 00 00	 call	 calculate_icmpv6_checksum

; 8018 : 
; 8019 :     // Display various information, maybe
; 8020 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00663	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00668	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0066b	83 e0 10	 and	 eax, 16
  0066e	85 c0		 test	 eax, eax
  00670	74 15		 je	 SHORT $LN5@build_8108

; 8021 :     {
; 8022 :         mpc_display_description( pDEVBLK, "Out RRH 0x8108 (UlpComm) Router solicitation" );

  00672	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172853
  00679	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00681	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN5@build_8108:

; 8023 :     }
; 8024 : 
; 8025 :     // Add PTPHDR to chain.
; 8026 :     add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00687	48 8b 54 24 68	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  0068c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00694	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 8027 : 
; 8028 : 
; 8029 :     // Allocate a buffer in which the ICMPv6 Neighbor Advertisment message
; 8030 :     // will be built. Note: the message will be 128 bytes.
; 8031 :     // The source address is the drive address, the destination address
; 8032 :     // is the Link-Local Scope All Nodes multicast address, i.e.
; 8033 :     // FF02:0:0:0:0:0:0:1.
; 8034 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00699	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0069e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006a6	e8 00 00 00 00	 call	 alloc_ptp_buffer
  006ab	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 8035 :     if (!pPTPHDRre)

  006b0	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  006b6	75 05		 jne	 SHORT $LN6@build_8108

; 8036 :         return;

  006b8	e9 df 0a 00 00	 jmp	 $LN1@build_8108
$LN6@build_8108:

; 8037 : 
; 8038 :     // Fix-up various lengths
; 8039 :     uLength6 = 24;                            // the ICMPv6 packet

  006bd	b8 18 00 00 00	 mov	 eax, 24
  006c2	66 89 44 24 20	 mov	 WORD PTR uLength6$[rsp], ax

; 8040 :     uLength5 = 0;                             // no Hop-by-Hop Options

  006c7	33 c0		 xor	 eax, eax
  006c9	66 89 44 24 40	 mov	 WORD PTR uLength5$[rsp], ax

; 8041 :     uLength4 = sizeof(IP6FRM);                // the IPv6 header

  006ce	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  006d3	66 89 44 24 44	 mov	 WORD PTR uLength4$[rsp], ax

; 8042 :     uLength3 = uLength4 + uLength6;           // the data

  006d8	0f b7 44 24 44	 movzx	 eax, WORD PTR uLength4$[rsp]
  006dd	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  006e2	03 c1		 add	 eax, ecx
  006e4	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 8043 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  006e8	c7 44 24 5c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 8044 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  006f0	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  006f4	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  006f8	03 c8		 add	 ecx, eax
  006fa	8b c1		 mov	 eax, ecx
  006fc	89 44 24 58	 mov	 DWORD PTR uLength1$[rsp], eax

; 8045 : 
; 8046 :     // Fix-up various pointers
; 8047 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00700	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00705	48 83 c0 10	 add	 rax, 16
  00709	48 89 44 24 48	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 8048 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  0070e	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00713	48 83 c0 14	 add	 rax, 20
  00717	48 89 44 24 38	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 8049 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  0071c	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00721	48 83 c0 24	 add	 rax, 36			; 00000024H
  00725	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 8050 :     pIP6FRMre = (IP6FRM*)((BYTE*)pMPC_PHre + SIZE_PH);

  0072a	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0072f	48 83 c0 08	 add	 rax, 8
  00733	48 89 44 24 28	 mov	 QWORD PTR pIP6FRMre$[rsp], rax

; 8051 :     pHopOpt   = NULL;

  00738	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pHopOpt$[rsp], 0

; 8052 :     pIcmpHdr  = (BYTE*)pIP6FRMre->bPayload;

  00741	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00746	48 83 c0 28	 add	 rax, 40			; 00000028H
  0074a	48 89 44 24 50	 mov	 QWORD PTR pIcmpHdr$[rsp], rax

; 8053 : 
; 8054 :     // Prepare PTPHDRre
; 8055 :     pPTPHDRre->iDataLen = uLength1;

  0074f	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00754	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00758	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 8056 : 
; 8057 :     // Prepare MPC_THre
; 8058 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  0075b	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00760	e8 00 00 00 00	 call	 _byteswap_ulong
  00765	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0076a	8b d0		 mov	 edx, eax
  0076c	e8 00 00 00 00	 call	 store_fw_noswap

; 8059 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  00771	b9 14 00 00 00	 mov	 ecx, 20
  00776	e8 00 00 00 00	 call	 _byteswap_ulong
  0077b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00780	48 83 c1 08	 add	 rcx, 8
  00784	8b d0		 mov	 edx, eax
  00786	e8 00 00 00 00	 call	 store_fw_noswap

; 8060 :     STORE_FW( pMPC_THre->length, uLength1 );

  0078b	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0078f	e8 00 00 00 00	 call	 _byteswap_ulong
  00794	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00799	48 83 c1 0c	 add	 rcx, 12
  0079d	8b d0		 mov	 edx, eax
  0079f	e8 00 00 00 00	 call	 store_fw_noswap

; 8061 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  007a4	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  007a8	e8 00 00 00 00	 call	 _byteswap_ushort
  007ad	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  007b2	48 83 c1 10	 add	 rcx, 16
  007b6	0f b7 d0	 movzx	 edx, ax
  007b9	e8 00 00 00 00	 call	 store_hw_noswap

; 8062 :     STORE_HW( pMPC_THre->numrrh, 1 );

  007be	66 b9 01 00	 mov	 cx, 1
  007c2	e8 00 00 00 00	 call	 _byteswap_ushort
  007c7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  007cc	48 83 c1 12	 add	 rcx, 18
  007d0	0f b7 d0	 movzx	 edx, ax
  007d3	e8 00 00 00 00	 call	 store_hw_noswap

; 8063 : 
; 8064 :     // Prepare MPC_RRHre
; 8065 :     pMPC_RRHre->type = RRH_TYPE_CM;

  007d8	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  007dd	c6 40 04 81	 mov	 BYTE PTR [rax+4], 129	; 00000081H

; 8066 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  007e1	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  007e6	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 8067 :     STORE_HW( pMPC_RRHre->numph, 1 );

  007ea	66 b9 01 00	 mov	 cx, 1
  007ee	e8 00 00 00 00	 call	 _byteswap_ushort
  007f3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  007f8	48 83 c1 06	 add	 rcx, 6
  007fc	0f b7 d0	 movzx	 edx, ax
  007ff	e8 00 00 00 00	 call	 store_hw_noswap

; 8068 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00804	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00808	e8 00 00 00 00	 call	 _byteswap_ushort
  0080d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00812	48 83 c1 10	 add	 rcx, 16
  00816	0f b7 d0	 movzx	 edx, ax
  00819	e8 00 00 00 00	 call	 store_hw_noswap

; 8069 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  0081e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00823	e8 00 00 00 00	 call	 _byteswap_ushort
  00828	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0082d	48 83 c1 12	 add	 rcx, 18
  00831	0f b7 d0	 movzx	 edx, ax
  00834	e8 00 00 00 00	 call	 store_hw_noswap

; 8070 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00839	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0083d	e8 00 00 00 00	 call	 _byteswap_ulong
  00842	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00847	48 83 c1 14	 add	 rcx, 20
  0084b	8b d0		 mov	 edx, eax
  0084d	e8 00 00 00 00	 call	 store_f3_noswap

; 8071 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00852	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00857	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 8072 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  0085b	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00860	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00865	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  0086b	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 8073 : 
; 8074 :     // Prepare MPC_PHre
; 8075 :     pMPC_PHre->locdata = PH_LOC_1;

  0086e	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  00873	c6 00 01	 mov	 BYTE PTR [rax], 1

; 8076 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  00876	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0087a	e8 00 00 00 00	 call	 _byteswap_ulong
  0087f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00884	48 ff c1	 inc	 rcx
  00887	8b d0		 mov	 edx, eax
  00889	e8 00 00 00 00	 call	 store_f3_noswap

; 8077 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  0088e	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00892	e8 00 00 00 00	 call	 _byteswap_ulong
  00897	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  0089c	48 83 c1 04	 add	 rcx, 4
  008a0	8b d0		 mov	 edx, eax
  008a2	e8 00 00 00 00	 call	 store_fw_noswap

; 8078 : 
; 8079 :     // Prepare IP6FRMre, i.e. IPv6 header
; 8080 :     pIP6FRMre->bVersTCFlow[0] = 0x60;

  008a7	b8 01 00 00 00	 mov	 eax, 1
  008ac	48 6b c0 00	 imul	 rax, rax, 0
  008b0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  008b5	c6 04 01 60	 mov	 BYTE PTR [rcx+rax], 96	; 00000060H

; 8081 :     STORE_HW( pIP6FRMre->bPayloadLength, uLength6 );

  008b9	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  008be	e8 00 00 00 00	 call	 _byteswap_ushort
  008c3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  008c8	48 83 c1 04	 add	 rcx, 4
  008cc	0f b7 d0	 movzx	 edx, ax
  008cf	e8 00 00 00 00	 call	 store_hw_noswap

; 8082 :     pIP6FRMre->bNextHeader = 0x3A;

  008d4	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  008d9	c6 40 06 3a	 mov	 BYTE PTR [rax+6], 58	; 0000003aH

; 8083 :     pIP6FRMre->bHopLimit = 0xFF;

  008dd	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  008e2	c6 40 07 ff	 mov	 BYTE PTR [rax+7], 255	; 000000ffH

; 8084 :     memcpy( pIP6FRMre->bSrcAddr, &pPTPBLK->iaDriveIPAddr6, 16 );

  008e6	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  008eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  008f0	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  008f4	48 8d b1 e0 02
	00 00		 lea	 rsi, QWORD PTR [rcx+736]
  008fb	b9 10 00 00 00	 mov	 ecx, 16
  00900	f3 a4		 rep movsb

; 8085 :     pIP6FRMre->bDstAddr[0]  = 0xFF;

  00902	b8 01 00 00 00	 mov	 eax, 1
  00907	48 6b c0 00	 imul	 rax, rax, 0
  0090b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00910	c6 44 01 18 ff	 mov	 BYTE PTR [rcx+rax+24], 255 ; 000000ffH

; 8086 :     pIP6FRMre->bDstAddr[1]  = 0x02;

  00915	b8 01 00 00 00	 mov	 eax, 1
  0091a	48 6b c0 01	 imul	 rax, rax, 1
  0091e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00923	c6 44 01 18 02	 mov	 BYTE PTR [rcx+rax+24], 2

; 8087 :     pIP6FRMre->bDstAddr[15] = 0x01;

  00928	b8 01 00 00 00	 mov	 eax, 1
  0092d	48 6b c0 0f	 imul	 rax, rax, 15
  00931	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00936	c6 44 01 18 01	 mov	 BYTE PTR [rcx+rax+24], 1

; 8088 : 
; 8089 :     // Prepare ICMPv6 packet
; 8090 :     pIcmpHdr[0] = 0x88;

  0093b	b8 01 00 00 00	 mov	 eax, 1
  00940	48 6b c0 00	 imul	 rax, rax, 0
  00944	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00949	c6 04 01 88	 mov	 BYTE PTR [rcx+rax], 136	; 00000088H

; 8091 :     pIcmpHdr[4] = 0x20;

  0094d	b8 01 00 00 00	 mov	 eax, 1
  00952	48 6b c0 04	 imul	 rax, rax, 4
  00956	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  0095b	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H

; 8092 :     memcpy( pIcmpHdr+8, &pPTPBLK->iaDriveIPAddr6, 16 );

  0095f	48 8b 44 24 50	 mov	 rax, QWORD PTR pIcmpHdr$[rsp]
  00964	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00969	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  0096d	48 8d b1 e0 02
	00 00		 lea	 rsi, QWORD PTR [rcx+736]
  00974	b9 10 00 00 00	 mov	 ecx, 16
  00979	f3 a4		 rep movsb

; 8093 : 
; 8094 :     // Calculate and set the ICMPv6 checksum
; 8095 :     calculate_icmpv6_checksum( pIP6FRMre, pIcmpHdr, (int)uLength6 );

  0097b	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength6$[rsp]
  00980	44 8b c0	 mov	 r8d, eax
  00983	48 8b 54 24 50	 mov	 rdx, QWORD PTR pIcmpHdr$[rsp]
  00988	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  0098d	e8 00 00 00 00	 call	 calculate_icmpv6_checksum

; 8096 : 
; 8097 :     // Display various information, maybe
; 8098 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00992	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00997	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0099a	83 e0 10	 and	 eax, 16
  0099d	85 c0		 test	 eax, eax
  0099f	74 15		 je	 SHORT $LN7@build_8108

; 8099 :     {
; 8100 :         mpc_display_description( pDEVBLK, "Out RRH 0x8108 (UlpComm) Neighbor advertisment" );

  009a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172856
  009a8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN7@build_8108:

; 8101 :     }
; 8102 : 
; 8103 :     // Add PTPHDR to chain.
; 8104 :     add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  009b6	48 8b 54 24 68	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  009bb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  009c3	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 8105 : 
; 8106 : 
; 8107 :     // Allocate a buffer in which the ICMPv6 Group Membership Report message
; 8108 :     // will be built. Note: the message will be 136 bytes.
; 8109 :     // The source address is the drive link local address, the destination
; 8110 :     // address is the Link-Local Scope Selected-Node multicast address for
; 8111 :     // the drive link local address, i.e. FF02:0:0:0:0:1:FFxx:xxxx.
; 8112 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  009c8	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  009cd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009d5	e8 00 00 00 00	 call	 alloc_ptp_buffer
  009da	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 8113 :     if (!pPTPHDRre)

  009df	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  009e5	75 05		 jne	 SHORT $LN8@build_8108

; 8114 :         return;

  009e7	e9 b0 07 00 00	 jmp	 $LN1@build_8108
$LN8@build_8108:

; 8115 : 
; 8116 :     // Fix-up various lengths
; 8117 :     uLength6 = 24;                              // the ICMPv6 packet

  009ec	b8 18 00 00 00	 mov	 eax, 24
  009f1	66 89 44 24 20	 mov	 WORD PTR uLength6$[rsp], ax

; 8118 :     uLength5 = 8;                               // the Hop-by-Hop Options

  009f6	b8 08 00 00 00	 mov	 eax, 8
  009fb	66 89 44 24 40	 mov	 WORD PTR uLength5$[rsp], ax

; 8119 :     uLength4 = sizeof(IP6FRM);                  // the IPv6 header

  00a00	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00a05	66 89 44 24 44	 mov	 WORD PTR uLength4$[rsp], ax

; 8120 :     uLength3 = uLength4 + uLength5 + uLength6;  // the data

  00a0a	0f b7 44 24 44	 movzx	 eax, WORD PTR uLength4$[rsp]
  00a0f	0f b7 4c 24 40	 movzx	 ecx, WORD PTR uLength5$[rsp]
  00a14	03 c1		 add	 eax, ecx
  00a16	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  00a1b	03 c1		 add	 eax, ecx
  00a1d	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 8121 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;    // the MPC_TH/MPC_RRH/MPC_PH

  00a21	c7 44 24 5c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 8122 :     uLength1 = uLength2 + uLength3;             // the MPC_TH/MPC_RRH/MPC_PH and data

  00a29	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  00a2d	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00a31	03 c8		 add	 ecx, eax
  00a33	8b c1		 mov	 eax, ecx
  00a35	89 44 24 58	 mov	 DWORD PTR uLength1$[rsp], eax

; 8123 : 
; 8124 :     // Fix-up various pointers
; 8125 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00a39	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00a3e	48 83 c0 10	 add	 rax, 16
  00a42	48 89 44 24 48	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 8126 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00a47	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00a4c	48 83 c0 14	 add	 rax, 20
  00a50	48 89 44 24 38	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 8127 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00a55	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00a5a	48 83 c0 24	 add	 rax, 36			; 00000024H
  00a5e	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 8128 :     pIP6FRMre = (IP6FRM*)((BYTE*)pMPC_PHre + SIZE_PH);

  00a63	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  00a68	48 83 c0 08	 add	 rax, 8
  00a6c	48 89 44 24 28	 mov	 QWORD PTR pIP6FRMre$[rsp], rax

; 8129 :     pHopOpt   = (BYTE*)pIP6FRMre->bPayload;

  00a71	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00a76	48 83 c0 28	 add	 rax, 40			; 00000028H
  00a7a	48 89 44 24 78	 mov	 QWORD PTR pHopOpt$[rsp], rax

; 8130 :     pIcmpHdr  = pHopOpt + uLength5;

  00a7f	0f b7 44 24 40	 movzx	 eax, WORD PTR uLength5$[rsp]
  00a84	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pHopOpt$[rsp]
  00a89	48 03 c8	 add	 rcx, rax
  00a8c	48 8b c1	 mov	 rax, rcx
  00a8f	48 89 44 24 50	 mov	 QWORD PTR pIcmpHdr$[rsp], rax

; 8131 : 
; 8132 :     // Prepare PTPHDRre
; 8133 :     pPTPHDRre->iDataLen = uLength1;

  00a94	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00a99	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00a9d	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 8134 : 
; 8135 :     // Prepare MPC_THre
; 8136 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00aa0	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00aa5	e8 00 00 00 00	 call	 _byteswap_ulong
  00aaa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00aaf	8b d0		 mov	 edx, eax
  00ab1	e8 00 00 00 00	 call	 store_fw_noswap

; 8137 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  00ab6	b9 14 00 00 00	 mov	 ecx, 20
  00abb	e8 00 00 00 00	 call	 _byteswap_ulong
  00ac0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00ac5	48 83 c1 08	 add	 rcx, 8
  00ac9	8b d0		 mov	 edx, eax
  00acb	e8 00 00 00 00	 call	 store_fw_noswap

; 8138 :     STORE_FW( pMPC_THre->length, uLength1 );

  00ad0	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00ad4	e8 00 00 00 00	 call	 _byteswap_ulong
  00ad9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00ade	48 83 c1 0c	 add	 rcx, 12
  00ae2	8b d0		 mov	 edx, eax
  00ae4	e8 00 00 00 00	 call	 store_fw_noswap

; 8139 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00ae9	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00aed	e8 00 00 00 00	 call	 _byteswap_ushort
  00af2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00af7	48 83 c1 10	 add	 rcx, 16
  00afb	0f b7 d0	 movzx	 edx, ax
  00afe	e8 00 00 00 00	 call	 store_hw_noswap

; 8140 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00b03	66 b9 01 00	 mov	 cx, 1
  00b07	e8 00 00 00 00	 call	 _byteswap_ushort
  00b0c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00b11	48 83 c1 12	 add	 rcx, 18
  00b15	0f b7 d0	 movzx	 edx, ax
  00b18	e8 00 00 00 00	 call	 store_hw_noswap

; 8141 : 
; 8142 :     // Prepare MPC_RRHre
; 8143 :     pMPC_RRHre->type = RRH_TYPE_CM;

  00b1d	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00b22	c6 40 04 81	 mov	 BYTE PTR [rax+4], 129	; 00000081H

; 8144 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  00b26	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00b2b	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 8145 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00b2f	66 b9 01 00	 mov	 cx, 1
  00b33	e8 00 00 00 00	 call	 _byteswap_ushort
  00b38	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00b3d	48 83 c1 06	 add	 rcx, 6
  00b41	0f b7 d0	 movzx	 edx, ax
  00b44	e8 00 00 00 00	 call	 store_hw_noswap

; 8146 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00b49	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00b4d	e8 00 00 00 00	 call	 _byteswap_ushort
  00b52	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00b57	48 83 c1 10	 add	 rcx, 16
  00b5b	0f b7 d0	 movzx	 edx, ax
  00b5e	e8 00 00 00 00	 call	 store_hw_noswap

; 8147 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00b63	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00b68	e8 00 00 00 00	 call	 _byteswap_ushort
  00b6d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00b72	48 83 c1 12	 add	 rcx, 18
  00b76	0f b7 d0	 movzx	 edx, ax
  00b79	e8 00 00 00 00	 call	 store_hw_noswap

; 8148 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00b7e	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00b82	e8 00 00 00 00	 call	 _byteswap_ulong
  00b87	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00b8c	48 83 c1 14	 add	 rcx, 20
  00b90	8b d0		 mov	 edx, eax
  00b92	e8 00 00 00 00	 call	 store_f3_noswap

; 8149 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00b97	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00b9c	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 8150 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  00ba0	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00ba5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00baa	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  00bb0	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 8151 : 
; 8152 :     // Prepare MPC_PHre
; 8153 :     pMPC_PHre->locdata = PH_LOC_1;

  00bb3	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  00bb8	c6 00 01	 mov	 BYTE PTR [rax], 1

; 8154 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  00bbb	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00bbf	e8 00 00 00 00	 call	 _byteswap_ulong
  00bc4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00bc9	48 ff c1	 inc	 rcx
  00bcc	8b d0		 mov	 edx, eax
  00bce	e8 00 00 00 00	 call	 store_f3_noswap

; 8155 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  00bd3	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00bd7	e8 00 00 00 00	 call	 _byteswap_ulong
  00bdc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00be1	48 83 c1 04	 add	 rcx, 4
  00be5	8b d0		 mov	 edx, eax
  00be7	e8 00 00 00 00	 call	 store_fw_noswap

; 8156 : 
; 8157 :     // Prepare IP6FRMre, i.e. IPv6 header
; 8158 :     pIP6FRMre->bVersTCFlow[0] = 0x60;

  00bec	b8 01 00 00 00	 mov	 eax, 1
  00bf1	48 6b c0 00	 imul	 rax, rax, 0
  00bf5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00bfa	c6 04 01 60	 mov	 BYTE PTR [rcx+rax], 96	; 00000060H

; 8159 :     STORE_HW( pIP6FRMre->bPayloadLength, uLength5 + uLength6 );

  00bfe	0f b7 44 24 40	 movzx	 eax, WORD PTR uLength5$[rsp]
  00c03	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  00c08	03 c1		 add	 eax, ecx
  00c0a	0f b7 c8	 movzx	 ecx, ax
  00c0d	e8 00 00 00 00	 call	 _byteswap_ushort
  00c12	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00c17	48 83 c1 04	 add	 rcx, 4
  00c1b	0f b7 d0	 movzx	 edx, ax
  00c1e	e8 00 00 00 00	 call	 store_hw_noswap

; 8160 :     pIP6FRMre->bNextHeader = 0x00;

  00c23	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00c28	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 8161 :     pIP6FRMre->bHopLimit = 0x01;

  00c2c	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00c31	c6 40 07 01	 mov	 BYTE PTR [rax+7], 1

; 8162 :     memcpy( pIP6FRMre->bSrcAddr, &pPTPBLK->iaDriveLLAddr6, 16 );

  00c35	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00c3a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00c3f	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  00c43	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  00c4a	b9 10 00 00 00	 mov	 ecx, 16
  00c4f	f3 a4		 rep movsb

; 8163 :     pIP6FRMre->bDstAddr[0]  = 0xFF;

  00c51	b8 01 00 00 00	 mov	 eax, 1
  00c56	48 6b c0 00	 imul	 rax, rax, 0
  00c5a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00c5f	c6 44 01 18 ff	 mov	 BYTE PTR [rcx+rax+24], 255 ; 000000ffH

; 8164 :     pIP6FRMre->bDstAddr[1]  = 0x02;

  00c64	b8 01 00 00 00	 mov	 eax, 1
  00c69	48 6b c0 01	 imul	 rax, rax, 1
  00c6d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00c72	c6 44 01 18 02	 mov	 BYTE PTR [rcx+rax+24], 2

; 8165 :     pIP6FRMre->bDstAddr[11] = 0x01;

  00c77	b8 01 00 00 00	 mov	 eax, 1
  00c7c	48 6b c0 0b	 imul	 rax, rax, 11
  00c80	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00c85	c6 44 01 18 01	 mov	 BYTE PTR [rcx+rax+24], 1

; 8166 :     pIP6FRMre->bDstAddr[12] = 0xFF;

  00c8a	b8 01 00 00 00	 mov	 eax, 1
  00c8f	48 6b c0 0c	 imul	 rax, rax, 12
  00c93	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00c98	c6 44 01 18 ff	 mov	 BYTE PTR [rcx+rax+24], 255 ; 000000ffH

; 8167 :     memcpy( pIP6FRMre->bDstAddr+13, &pPTPBLK->iaDriveLLAddr6+13, 3 );

  00c9d	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00ca2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00ca7	48 8d 78 25	 lea	 rdi, QWORD PTR [rax+37]
  00cab	48 8d b1 d0 03
	00 00		 lea	 rsi, QWORD PTR [rcx+976]
  00cb2	b9 03 00 00 00	 mov	 ecx, 3
  00cb7	f3 a4		 rep movsb

; 8168 : 
; 8169 :     // Prepare Hop-by-Hop Options
; 8170 :     pHopOpt[0] = 0x3A;

  00cb9	b8 01 00 00 00	 mov	 eax, 1
  00cbe	48 6b c0 00	 imul	 rax, rax, 0
  00cc2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pHopOpt$[rsp]
  00cc7	c6 04 01 3a	 mov	 BYTE PTR [rcx+rax], 58	; 0000003aH

; 8171 :     pHopOpt[2] = 0x05;

  00ccb	b8 01 00 00 00	 mov	 eax, 1
  00cd0	48 6b c0 02	 imul	 rax, rax, 2
  00cd4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pHopOpt$[rsp]
  00cd9	c6 04 01 05	 mov	 BYTE PTR [rcx+rax], 5

; 8172 :     pHopOpt[3] = 0x02;

  00cdd	b8 01 00 00 00	 mov	 eax, 1
  00ce2	48 6b c0 03	 imul	 rax, rax, 3
  00ce6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pHopOpt$[rsp]
  00ceb	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2

; 8173 : 
; 8174 :     // Prepare ICMPv6 packet
; 8175 :     pIcmpHdr[0] = 0x83;

  00cef	b8 01 00 00 00	 mov	 eax, 1
  00cf4	48 6b c0 00	 imul	 rax, rax, 0
  00cf8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00cfd	c6 04 01 83	 mov	 BYTE PTR [rcx+rax], 131	; 00000083H

; 8176 :     pIcmpHdr[8]  = 0xFF;

  00d01	b8 01 00 00 00	 mov	 eax, 1
  00d06	48 6b c0 08	 imul	 rax, rax, 8
  00d0a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00d0f	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 8177 :     pIcmpHdr[9]  = 0x02;

  00d13	b8 01 00 00 00	 mov	 eax, 1
  00d18	48 6b c0 09	 imul	 rax, rax, 9
  00d1c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00d21	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2

; 8178 :     pIcmpHdr[19] = 0x01;

  00d25	b8 01 00 00 00	 mov	 eax, 1
  00d2a	48 6b c0 13	 imul	 rax, rax, 19
  00d2e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00d33	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 8179 :     pIcmpHdr[20] = 0xFF;

  00d37	b8 01 00 00 00	 mov	 eax, 1
  00d3c	48 6b c0 14	 imul	 rax, rax, 20
  00d40	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00d45	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 8180 :     memcpy( pIcmpHdr+21, &pPTPBLK->iaDriveLLAddr6+13, 3 );

  00d49	48 8b 44 24 50	 mov	 rax, QWORD PTR pIcmpHdr$[rsp]
  00d4e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00d53	48 8d 78 15	 lea	 rdi, QWORD PTR [rax+21]
  00d57	48 8d b1 d0 03
	00 00		 lea	 rsi, QWORD PTR [rcx+976]
  00d5e	b9 03 00 00 00	 mov	 ecx, 3
  00d63	f3 a4		 rep movsb

; 8181 : 
; 8182 :     // Calculate and set the ICMPv6 checksum
; 8183 :     calculate_icmpv6_checksum( pIP6FRMre, pIcmpHdr, (int)uLength6 );

  00d65	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength6$[rsp]
  00d6a	44 8b c0	 mov	 r8d, eax
  00d6d	48 8b 54 24 50	 mov	 rdx, QWORD PTR pIcmpHdr$[rsp]
  00d72	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00d77	e8 00 00 00 00	 call	 calculate_icmpv6_checksum

; 8184 : 
; 8185 :     // Display various information, maybe
; 8186 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00d7c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00d81	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00d84	83 e0 10	 and	 eax, 16
  00d87	85 c0		 test	 eax, eax
  00d89	74 15		 je	 SHORT $LN9@build_8108

; 8187 :     {
; 8188 :         mpc_display_description( pDEVBLK, "Out RRH 0x8108 (UlpComm) Group membership report" );

  00d8b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172859
  00d92	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d9a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN9@build_8108:

; 8189 :     }
; 8190 : 
; 8191 :     // Add PTPHDR to chain.
; 8192 :     add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00da0	48 8b 54 24 68	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00da5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00dad	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 8193 : 
; 8194 : 
; 8195 :     // Allocate a buffer in which the ICMPv6 Group Membership Report message
; 8196 :     // will be built. Note: the message will be 136 bytes.
; 8197 :     // The source address is the drive link local address, the destination
; 8198 :     // address is the Link-Local Scope Selected-Node multicast address for
; 8199 :     // the drive address, i.e. FF02:0:0:0:0:1:FFyy:yyyy.
; 8200 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00db2	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00db7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00dbf	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00dc4	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 8201 :     if (!pPTPHDRre)

  00dc9	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00dcf	75 05		 jne	 SHORT $LN10@build_8108

; 8202 :         return;

  00dd1	e9 c6 03 00 00	 jmp	 $LN1@build_8108
$LN10@build_8108:

; 8203 : 
; 8204 :     // Fix-up various lengths
; 8205 :     uLength6 = 24;                              // the ICMPv6 packet

  00dd6	b8 18 00 00 00	 mov	 eax, 24
  00ddb	66 89 44 24 20	 mov	 WORD PTR uLength6$[rsp], ax

; 8206 :     uLength5 = 8;                               // the Hop-by-Hop Options

  00de0	b8 08 00 00 00	 mov	 eax, 8
  00de5	66 89 44 24 40	 mov	 WORD PTR uLength5$[rsp], ax

; 8207 :     uLength4 = sizeof(IP6FRM);                  // the IPv6 header

  00dea	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00def	66 89 44 24 44	 mov	 WORD PTR uLength4$[rsp], ax

; 8208 :     uLength3 = uLength4 + uLength5 + uLength6;  // the data

  00df4	0f b7 44 24 44	 movzx	 eax, WORD PTR uLength4$[rsp]
  00df9	0f b7 4c 24 40	 movzx	 ecx, WORD PTR uLength5$[rsp]
  00dfe	03 c1		 add	 eax, ecx
  00e00	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  00e05	03 c1		 add	 eax, ecx
  00e07	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 8209 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;    // the MPC_TH/MPC_RRH/MPC_PH

  00e0b	c7 44 24 5c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 8210 :     uLength1 = uLength2 + uLength3;             // the MPC_TH/MPC_RRH/MPC_PH and data

  00e13	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  00e17	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00e1b	03 c8		 add	 ecx, eax
  00e1d	8b c1		 mov	 eax, ecx
  00e1f	89 44 24 58	 mov	 DWORD PTR uLength1$[rsp], eax

; 8211 : 
; 8212 :     // Fix-up various pointers
; 8213 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00e23	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00e28	48 83 c0 10	 add	 rax, 16
  00e2c	48 89 44 24 48	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 8214 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00e31	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00e36	48 83 c0 14	 add	 rax, 20
  00e3a	48 89 44 24 38	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 8215 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00e3f	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00e44	48 83 c0 24	 add	 rax, 36			; 00000024H
  00e48	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 8216 :     pIP6FRMre = (IP6FRM*)((BYTE*)pMPC_PHre + SIZE_PH);

  00e4d	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  00e52	48 83 c0 08	 add	 rax, 8
  00e56	48 89 44 24 28	 mov	 QWORD PTR pIP6FRMre$[rsp], rax

; 8217 :     pHopOpt   = (BYTE*)pIP6FRMre->bPayload;

  00e5b	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  00e60	48 83 c0 28	 add	 rax, 40			; 00000028H
  00e64	48 89 44 24 78	 mov	 QWORD PTR pHopOpt$[rsp], rax

; 8218 :     pIcmpHdr  = pHopOpt + uLength5;

  00e69	0f b7 44 24 40	 movzx	 eax, WORD PTR uLength5$[rsp]
  00e6e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pHopOpt$[rsp]
  00e73	48 03 c8	 add	 rcx, rax
  00e76	48 8b c1	 mov	 rax, rcx
  00e79	48 89 44 24 50	 mov	 QWORD PTR pIcmpHdr$[rsp], rax

; 8219 : 
; 8220 :     // Prepare PTPHDRre
; 8221 :     pPTPHDRre->iDataLen = uLength1;

  00e7e	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00e83	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00e87	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 8222 : 
; 8223 :     // Prepare MPC_THre
; 8224 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00e8a	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00e8f	e8 00 00 00 00	 call	 _byteswap_ulong
  00e94	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00e99	8b d0		 mov	 edx, eax
  00e9b	e8 00 00 00 00	 call	 store_fw_noswap

; 8225 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  00ea0	b9 14 00 00 00	 mov	 ecx, 20
  00ea5	e8 00 00 00 00	 call	 _byteswap_ulong
  00eaa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00eaf	48 83 c1 08	 add	 rcx, 8
  00eb3	8b d0		 mov	 edx, eax
  00eb5	e8 00 00 00 00	 call	 store_fw_noswap

; 8226 :     STORE_FW( pMPC_THre->length, uLength1 );

  00eba	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00ebe	e8 00 00 00 00	 call	 _byteswap_ulong
  00ec3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00ec8	48 83 c1 0c	 add	 rcx, 12
  00ecc	8b d0		 mov	 edx, eax
  00ece	e8 00 00 00 00	 call	 store_fw_noswap

; 8227 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00ed3	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00ed7	e8 00 00 00 00	 call	 _byteswap_ushort
  00edc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00ee1	48 83 c1 10	 add	 rcx, 16
  00ee5	0f b7 d0	 movzx	 edx, ax
  00ee8	e8 00 00 00 00	 call	 store_hw_noswap

; 8228 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00eed	66 b9 01 00	 mov	 cx, 1
  00ef1	e8 00 00 00 00	 call	 _byteswap_ushort
  00ef6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00efb	48 83 c1 12	 add	 rcx, 18
  00eff	0f b7 d0	 movzx	 edx, ax
  00f02	e8 00 00 00 00	 call	 store_hw_noswap

; 8229 : 
; 8230 :     // Prepare MPC_RRHre
; 8231 :     pMPC_RRHre->type = RRH_TYPE_CM;

  00f07	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00f0c	c6 40 04 81	 mov	 BYTE PTR [rax+4], 129	; 00000081H

; 8232 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  00f10	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00f15	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 8233 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00f19	66 b9 01 00	 mov	 cx, 1
  00f1d	e8 00 00 00 00	 call	 _byteswap_ushort
  00f22	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00f27	48 83 c1 06	 add	 rcx, 6
  00f2b	0f b7 d0	 movzx	 edx, ax
  00f2e	e8 00 00 00 00	 call	 store_hw_noswap

; 8234 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00f33	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00f37	e8 00 00 00 00	 call	 _byteswap_ushort
  00f3c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00f41	48 83 c1 10	 add	 rcx, 16
  00f45	0f b7 d0	 movzx	 edx, ax
  00f48	e8 00 00 00 00	 call	 store_hw_noswap

; 8235 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00f4d	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00f52	e8 00 00 00 00	 call	 _byteswap_ushort
  00f57	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00f5c	48 83 c1 12	 add	 rcx, 18
  00f60	0f b7 d0	 movzx	 edx, ax
  00f63	e8 00 00 00 00	 call	 store_hw_noswap

; 8236 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00f68	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00f6c	e8 00 00 00 00	 call	 _byteswap_ulong
  00f71	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00f76	48 83 c1 14	 add	 rcx, 20
  00f7a	8b d0		 mov	 edx, eax
  00f7c	e8 00 00 00 00	 call	 store_f3_noswap

; 8237 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00f81	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00f86	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 8238 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  00f8a	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00f8f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00f94	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  00f9a	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 8239 : 
; 8240 :     // Prepare MPC_PHre
; 8241 :     pMPC_PHre->locdata = PH_LOC_1;

  00f9d	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  00fa2	c6 00 01	 mov	 BYTE PTR [rax], 1

; 8242 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  00fa5	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00fa9	e8 00 00 00 00	 call	 _byteswap_ulong
  00fae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00fb3	48 ff c1	 inc	 rcx
  00fb6	8b d0		 mov	 edx, eax
  00fb8	e8 00 00 00 00	 call	 store_f3_noswap

; 8243 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  00fbd	8b 4c 24 5c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00fc1	e8 00 00 00 00	 call	 _byteswap_ulong
  00fc6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00fcb	48 83 c1 04	 add	 rcx, 4
  00fcf	8b d0		 mov	 edx, eax
  00fd1	e8 00 00 00 00	 call	 store_fw_noswap

; 8244 : 
; 8245 :     // Prepare IP6FRMre, i.e. IPv6 header
; 8246 :     pIP6FRMre->bVersTCFlow[0] = 0x60;

  00fd6	b8 01 00 00 00	 mov	 eax, 1
  00fdb	48 6b c0 00	 imul	 rax, rax, 0
  00fdf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  00fe4	c6 04 01 60	 mov	 BYTE PTR [rcx+rax], 96	; 00000060H

; 8247 :     STORE_HW( pIP6FRMre->bPayloadLength, uLength5 + uLength6 );

  00fe8	0f b7 44 24 40	 movzx	 eax, WORD PTR uLength5$[rsp]
  00fed	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength6$[rsp]
  00ff2	03 c1		 add	 eax, ecx
  00ff4	0f b7 c8	 movzx	 ecx, ax
  00ff7	e8 00 00 00 00	 call	 _byteswap_ushort
  00ffc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  01001	48 83 c1 04	 add	 rcx, 4
  01005	0f b7 d0	 movzx	 edx, ax
  01008	e8 00 00 00 00	 call	 store_hw_noswap

; 8248 :     pIP6FRMre->bNextHeader = 0x00;

  0100d	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  01012	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 8249 :     pIP6FRMre->bHopLimit = 0x01;

  01016	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  0101b	c6 40 07 01	 mov	 BYTE PTR [rax+7], 1

; 8250 :     memcpy( pIP6FRMre->bSrcAddr, &pPTPBLK->iaDriveLLAddr6, 16 );

  0101f	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  01024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01029	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  0102d	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  01034	b9 10 00 00 00	 mov	 ecx, 16
  01039	f3 a4		 rep movsb

; 8251 :     pIP6FRMre->bDstAddr[0]  = 0xFF;

  0103b	b8 01 00 00 00	 mov	 eax, 1
  01040	48 6b c0 00	 imul	 rax, rax, 0
  01044	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  01049	c6 44 01 18 ff	 mov	 BYTE PTR [rcx+rax+24], 255 ; 000000ffH

; 8252 :     pIP6FRMre->bDstAddr[1]  = 0x02;

  0104e	b8 01 00 00 00	 mov	 eax, 1
  01053	48 6b c0 01	 imul	 rax, rax, 1
  01057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  0105c	c6 44 01 18 02	 mov	 BYTE PTR [rcx+rax+24], 2

; 8253 :     pIP6FRMre->bDstAddr[11] = 0x01;

  01061	b8 01 00 00 00	 mov	 eax, 1
  01066	48 6b c0 0b	 imul	 rax, rax, 11
  0106a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  0106f	c6 44 01 18 01	 mov	 BYTE PTR [rcx+rax+24], 1

; 8254 :     pIP6FRMre->bDstAddr[12] = 0xFF;

  01074	b8 01 00 00 00	 mov	 eax, 1
  01079	48 6b c0 0c	 imul	 rax, rax, 12
  0107d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  01082	c6 44 01 18 ff	 mov	 BYTE PTR [rcx+rax+24], 255 ; 000000ffH

; 8255 :     memcpy( pIP6FRMre->bDstAddr+13, &pPTPBLK->iaDriveIPAddr6+13, 3 );

  01087	48 8b 44 24 28	 mov	 rax, QWORD PTR pIP6FRMre$[rsp]
  0108c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01091	48 8d 78 25	 lea	 rdi, QWORD PTR [rax+37]
  01095	48 8d b1 b0 03
	00 00		 lea	 rsi, QWORD PTR [rcx+944]
  0109c	b9 03 00 00 00	 mov	 ecx, 3
  010a1	f3 a4		 rep movsb

; 8256 : 
; 8257 :     // Prepare Hop-by-Hop Options
; 8258 :     pHopOpt[0] = 0x3A;

  010a3	b8 01 00 00 00	 mov	 eax, 1
  010a8	48 6b c0 00	 imul	 rax, rax, 0
  010ac	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pHopOpt$[rsp]
  010b1	c6 04 01 3a	 mov	 BYTE PTR [rcx+rax], 58	; 0000003aH

; 8259 :     pHopOpt[2] = 0x05;

  010b5	b8 01 00 00 00	 mov	 eax, 1
  010ba	48 6b c0 02	 imul	 rax, rax, 2
  010be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pHopOpt$[rsp]
  010c3	c6 04 01 05	 mov	 BYTE PTR [rcx+rax], 5

; 8260 :     pHopOpt[3] = 0x02;

  010c7	b8 01 00 00 00	 mov	 eax, 1
  010cc	48 6b c0 03	 imul	 rax, rax, 3
  010d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pHopOpt$[rsp]
  010d5	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2

; 8261 : 
; 8262 :     // Prepare ICMPv6 packet
; 8263 :     pIcmpHdr[0] = 0x83;

  010d9	b8 01 00 00 00	 mov	 eax, 1
  010de	48 6b c0 00	 imul	 rax, rax, 0
  010e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  010e7	c6 04 01 83	 mov	 BYTE PTR [rcx+rax], 131	; 00000083H

; 8264 :     pIcmpHdr[8]  = 0xFF;

  010eb	b8 01 00 00 00	 mov	 eax, 1
  010f0	48 6b c0 08	 imul	 rax, rax, 8
  010f4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  010f9	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 8265 :     pIcmpHdr[9]  = 0x02;

  010fd	b8 01 00 00 00	 mov	 eax, 1
  01102	48 6b c0 09	 imul	 rax, rax, 9
  01106	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  0110b	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2

; 8266 :     pIcmpHdr[19] = 0x01;

  0110f	b8 01 00 00 00	 mov	 eax, 1
  01114	48 6b c0 13	 imul	 rax, rax, 19
  01118	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  0111d	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 8267 :     pIcmpHdr[20] = 0xFF;

  01121	b8 01 00 00 00	 mov	 eax, 1
  01126	48 6b c0 14	 imul	 rax, rax, 20
  0112a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  0112f	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 8268 :     memcpy( pIcmpHdr+21, &pPTPBLK->iaDriveIPAddr6+13, 3 );

  01133	48 8b 44 24 50	 mov	 rax, QWORD PTR pIcmpHdr$[rsp]
  01138	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0113d	48 8d 78 15	 lea	 rdi, QWORD PTR [rax+21]
  01141	48 8d b1 b0 03
	00 00		 lea	 rsi, QWORD PTR [rcx+944]
  01148	b9 03 00 00 00	 mov	 ecx, 3
  0114d	f3 a4		 rep movsb

; 8269 : 
; 8270 :     // Calculate and set the ICMPv6 checksum
; 8271 :     calculate_icmpv6_checksum( pIP6FRMre, pIcmpHdr, (int)uLength6 );

  0114f	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength6$[rsp]
  01154	44 8b c0	 mov	 r8d, eax
  01157	48 8b 54 24 50	 mov	 rdx, QWORD PTR pIcmpHdr$[rsp]
  0115c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pIP6FRMre$[rsp]
  01161	e8 00 00 00 00	 call	 calculate_icmpv6_checksum

; 8272 : 
; 8273 :     // Display various information, maybe
; 8274 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  01166	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0116b	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0116e	83 e0 10	 and	 eax, 16
  01171	85 c0		 test	 eax, eax
  01173	74 15		 je	 SHORT $LN11@build_8108

; 8275 :     {
; 8276 :         mpc_display_description( pDEVBLK, "Out RRH 0x8108 (UlpComm) Group membership report" );

  01175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172862
  0117c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN11@build_8108:

; 8277 :     }
; 8278 : 
; 8279 :     // Add PTPHDR to chain.
; 8280 :     add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  0118a	48 8b 54 24 68	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  0118f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01197	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event
$LN1@build_8108:

; 8281 : 
; 8282 :     return;
; 8283 : }   /* End function  build_8108_icmpv6_packets() */

  0119c	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  011a3	5f		 pop	 rdi
  011a4	5e		 pop	 rsi
  011a5	c3		 ret	 0
build_8108_icmpv6_packets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength3$ = 32
pMPC_RRHre$ = 40
pMPC_THre$ = 48
uLength1$ = 56
uLength2$ = 60
pMPC_PIXre$ = 64
pMPC_PHre$ = 72
pPTPHDRre$ = 80
pPTPBLK$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
pMPC_PIXwr$ = 136
build_C108_i_will_stop_6 PROC

; 7776 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7777 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00016	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0001d	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7778 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 44 24 58	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7779 :     U32        uLength1;
; 7780 :     U32        uLength2;
; 7781 :     U32        uLength3;
; 7782 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7783 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7784 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7785 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7786 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7787 : 
; 7788 : 
; 7789 :     // Allocate a buffer in which the response will be build.
; 7790 :     // Note: the largest reply will be 88 bytes.
; 7791 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  0002f	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00034	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0003c	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00041	48 89 44 24 50	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7792 :     if (!pPTPHDRre)

  00046	48 83 7c 24 50
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  0004c	75 07		 jne	 SHORT $LN2@build_C108

; 7793 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 11 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7794 : 
; 7795 :     // Fix-up various lengths
; 7796 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  00055	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7797 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  0005d	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7798 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  00065	8b 44 24 20	 mov	 eax, DWORD PTR uLength3$[rsp]
  00069	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  0006d	03 c8		 add	 ecx, eax
  0006f	8b c1		 mov	 eax, ecx
  00071	89 44 24 38	 mov	 DWORD PTR uLength1$[rsp], eax

; 7799 : 
; 7800 :     // Fix-up various pointers
; 7801 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0007a	48 83 c0 10	 add	 rax, 16
  0007e	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7802 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00088	48 83 c0 14	 add	 rax, 20
  0008c	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7803 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00096	48 83 c0 24	 add	 rax, 36			; 00000024H
  0009a	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7804 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000a4	48 83 c0 08	 add	 rax, 8
  000a8	48 89 44 24 40	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7805 : 
; 7806 :     // Prepare PTPHDRre
; 7807 :     pPTPHDRre->iDataLen = uLength1;

  000ad	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000b2	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000b6	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7808 : 
; 7809 :     // Prepare MPC_THre
; 7810 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000b9	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000be	e8 00 00 00 00	 call	 _byteswap_ulong
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000c8	8b d0		 mov	 edx, eax
  000ca	e8 00 00 00 00	 call	 store_fw_noswap

; 7811 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000cf	b9 14 00 00 00	 mov	 ecx, 20
  000d4	e8 00 00 00 00	 call	 _byteswap_ulong
  000d9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000de	48 83 c1 08	 add	 rcx, 8
  000e2	8b d0		 mov	 edx, eax
  000e4	e8 00 00 00 00	 call	 store_fw_noswap

; 7812 :     STORE_FW( pMPC_THre->length, uLength1 );

  000e9	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000ed	e8 00 00 00 00	 call	 _byteswap_ulong
  000f2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000f7	48 83 c1 0c	 add	 rcx, 12
  000fb	8b d0		 mov	 edx, eax
  000fd	e8 00 00 00 00	 call	 store_fw_noswap

; 7813 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00102	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00106	e8 00 00 00 00	 call	 _byteswap_ushort
  0010b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00110	48 83 c1 10	 add	 rcx, 16
  00114	0f b7 d0	 movzx	 edx, ax
  00117	e8 00 00 00 00	 call	 store_hw_noswap

; 7814 :     STORE_HW( pMPC_THre->numrrh, 1 );

  0011c	66 b9 01 00	 mov	 cx, 1
  00120	e8 00 00 00 00	 call	 _byteswap_ushort
  00125	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0012a	48 83 c1 12	 add	 rcx, 18
  0012e	0f b7 d0	 movzx	 edx, ax
  00131	e8 00 00 00 00	 call	 store_hw_noswap

; 7815 : 
; 7816 :     // Prepare MPC_RRHre
; 7817 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0013b	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7818 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  0013f	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00144	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7819 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00148	66 b9 01 00	 mov	 cx, 1
  0014c	e8 00 00 00 00	 call	 _byteswap_ushort
  00151	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00156	48 83 c1 06	 add	 rcx, 6
  0015a	0f b7 d0	 movzx	 edx, ax
  0015d	e8 00 00 00 00	 call	 store_hw_noswap

; 7820 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00162	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00166	e8 00 00 00 00	 call	 _byteswap_ushort
  0016b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00170	48 83 c1 10	 add	 rcx, 16
  00174	0f b7 d0	 movzx	 edx, ax
  00177	e8 00 00 00 00	 call	 store_hw_noswap

; 7821 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  0017c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00181	e8 00 00 00 00	 call	 _byteswap_ushort
  00186	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0018b	48 83 c1 12	 add	 rcx, 18
  0018f	0f b7 d0	 movzx	 edx, ax
  00192	e8 00 00 00 00	 call	 store_hw_noswap

; 7822 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00197	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0019b	e8 00 00 00 00	 call	 _byteswap_ulong
  001a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a5	48 83 c1 14	 add	 rcx, 20
  001a9	8b d0		 mov	 edx, eax
  001ab	e8 00 00 00 00	 call	 store_f3_noswap

; 7823 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001b0	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b5	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7824 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001b9	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001be	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001c3	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001c9	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7825 : 
; 7826 :     // Prepare MPC_PHre
; 7827 :     pMPC_PHre->locdata = PH_LOC_1;

  001cc	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001d1	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7828 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001d4	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001d8	e8 00 00 00 00	 call	 _byteswap_ulong
  001dd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001e2	48 ff c1	 inc	 rcx
  001e5	8b d0		 mov	 edx, eax
  001e7	e8 00 00 00 00	 call	 store_f3_noswap

; 7829 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001ec	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001f0	e8 00 00 00 00	 call	 _byteswap_ulong
  001f5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001fa	48 83 c1 04	 add	 rcx, 4
  001fe	8b d0		 mov	 edx, eax
  00200	e8 00 00 00 00	 call	 store_fw_noswap

; 7830 : 
; 7831 :     // Prepare MPC_PIXre
; 7832 :     pMPC_PIXre->action = PIX_STOP;

  00205	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0020a	c6 00 02	 mov	 BYTE PTR [rax], 2

; 7833 :     pMPC_PIXre->askans = PIX_ANSWER;

  0020d	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00212	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 7834 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  00216	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021b	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7835 :     pMPC_PIXre->iptype = PIX_IPV6;

  0021f	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00224	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 7836 :     memcpy( pMPC_PIXre->idnum, pMPC_PIXwr->idnum, sizeof(pMPC_PIXre->idnum) );

  00228	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0022d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  00235	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  00239	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 7837 : 
; 7838 :     // Display various information, maybe
; 7839 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0023d	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00242	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00245	83 e0 10	 and	 eax, 16
  00248	85 c0		 test	 eax, eax
  0024a	74 15		 je	 SHORT $LN3@build_C108

; 7840 :     {
; 7841 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) I will stop IPv6" );

  0024c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172760
  00253	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0025b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7842 :     }
; 7843 : 
; 7844 :     return pPTPHDRre;

  00261	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7845 : }   /* End function  build_C108_i_will_stop_6() */

  00266	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0026a	c3		 ret	 0
build_C108_i_will_stop_6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength3$ = 32
pMPC_RRHre$ = 40
pMPC_THre$ = 48
uLength1$ = 56
uLength2$ = 60
pMPC_PIXre$ = 64
pMPC_PHre$ = 72
pPTPHDRre$ = 80
pPTPBLK$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
pMPC_PIXwr$ = 136
build_C108_i_will_stop_4 PROC

; 7699 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7700 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00016	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0001d	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7701 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 44 24 58	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7702 :     U32        uLength1;
; 7703 :     U32        uLength2;
; 7704 :     U32        uLength3;
; 7705 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7706 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7707 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7708 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7709 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7710 : 
; 7711 : 
; 7712 :     // Allocate a buffer in which the response will be build.
; 7713 :     // Note: the largest reply will be 88 bytes.
; 7714 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  0002f	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00034	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0003c	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00041	48 89 44 24 50	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7715 :     if (!pPTPHDRre)

  00046	48 83 7c 24 50
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  0004c	75 07		 jne	 SHORT $LN2@build_C108

; 7716 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 11 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7717 : 
; 7718 :     // Fix-up various lengths
; 7719 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  00055	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7720 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  0005d	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7721 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  00065	8b 44 24 20	 mov	 eax, DWORD PTR uLength3$[rsp]
  00069	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  0006d	03 c8		 add	 ecx, eax
  0006f	8b c1		 mov	 eax, ecx
  00071	89 44 24 38	 mov	 DWORD PTR uLength1$[rsp], eax

; 7722 : 
; 7723 :     // Fix-up various pointers
; 7724 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0007a	48 83 c0 10	 add	 rax, 16
  0007e	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7725 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00088	48 83 c0 14	 add	 rax, 20
  0008c	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7726 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00096	48 83 c0 24	 add	 rax, 36			; 00000024H
  0009a	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7727 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000a4	48 83 c0 08	 add	 rax, 8
  000a8	48 89 44 24 40	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7728 : 
; 7729 :     // Prepare PTPHDRre
; 7730 :     pPTPHDRre->iDataLen = uLength1;

  000ad	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000b2	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000b6	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7731 : 
; 7732 :     // Prepare MPC_THre
; 7733 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000b9	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000be	e8 00 00 00 00	 call	 _byteswap_ulong
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000c8	8b d0		 mov	 edx, eax
  000ca	e8 00 00 00 00	 call	 store_fw_noswap

; 7734 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000cf	b9 14 00 00 00	 mov	 ecx, 20
  000d4	e8 00 00 00 00	 call	 _byteswap_ulong
  000d9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000de	48 83 c1 08	 add	 rcx, 8
  000e2	8b d0		 mov	 edx, eax
  000e4	e8 00 00 00 00	 call	 store_fw_noswap

; 7735 :     STORE_FW( pMPC_THre->length, uLength1 );

  000e9	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000ed	e8 00 00 00 00	 call	 _byteswap_ulong
  000f2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000f7	48 83 c1 0c	 add	 rcx, 12
  000fb	8b d0		 mov	 edx, eax
  000fd	e8 00 00 00 00	 call	 store_fw_noswap

; 7736 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00102	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00106	e8 00 00 00 00	 call	 _byteswap_ushort
  0010b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00110	48 83 c1 10	 add	 rcx, 16
  00114	0f b7 d0	 movzx	 edx, ax
  00117	e8 00 00 00 00	 call	 store_hw_noswap

; 7737 :     STORE_HW( pMPC_THre->numrrh, 1 );

  0011c	66 b9 01 00	 mov	 cx, 1
  00120	e8 00 00 00 00	 call	 _byteswap_ushort
  00125	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0012a	48 83 c1 12	 add	 rcx, 18
  0012e	0f b7 d0	 movzx	 edx, ax
  00131	e8 00 00 00 00	 call	 store_hw_noswap

; 7738 : 
; 7739 :     // Prepare MPC_RRHre
; 7740 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0013b	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7741 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  0013f	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00144	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7742 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00148	66 b9 01 00	 mov	 cx, 1
  0014c	e8 00 00 00 00	 call	 _byteswap_ushort
  00151	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00156	48 83 c1 06	 add	 rcx, 6
  0015a	0f b7 d0	 movzx	 edx, ax
  0015d	e8 00 00 00 00	 call	 store_hw_noswap

; 7743 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00162	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00166	e8 00 00 00 00	 call	 _byteswap_ushort
  0016b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00170	48 83 c1 10	 add	 rcx, 16
  00174	0f b7 d0	 movzx	 edx, ax
  00177	e8 00 00 00 00	 call	 store_hw_noswap

; 7744 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  0017c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00181	e8 00 00 00 00	 call	 _byteswap_ushort
  00186	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0018b	48 83 c1 12	 add	 rcx, 18
  0018f	0f b7 d0	 movzx	 edx, ax
  00192	e8 00 00 00 00	 call	 store_hw_noswap

; 7745 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00197	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0019b	e8 00 00 00 00	 call	 _byteswap_ulong
  001a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a5	48 83 c1 14	 add	 rcx, 20
  001a9	8b d0		 mov	 edx, eax
  001ab	e8 00 00 00 00	 call	 store_f3_noswap

; 7746 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001b0	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b5	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7747 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001b9	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001be	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001c3	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001c9	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7748 : 
; 7749 :     // Prepare MPC_PHre
; 7750 :     pMPC_PHre->locdata = PH_LOC_1;

  001cc	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001d1	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7751 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001d4	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001d8	e8 00 00 00 00	 call	 _byteswap_ulong
  001dd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001e2	48 ff c1	 inc	 rcx
  001e5	8b d0		 mov	 edx, eax
  001e7	e8 00 00 00 00	 call	 store_f3_noswap

; 7752 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001ec	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001f0	e8 00 00 00 00	 call	 _byteswap_ulong
  001f5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001fa	48 83 c1 04	 add	 rcx, 4
  001fe	8b d0		 mov	 edx, eax
  00200	e8 00 00 00 00	 call	 store_fw_noswap

; 7753 : 
; 7754 :     // Prepare MPC_PIXre
; 7755 :     pMPC_PIXre->action = PIX_STOP;

  00205	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0020a	c6 00 02	 mov	 BYTE PTR [rax], 2

; 7756 :     pMPC_PIXre->askans = PIX_ANSWER;

  0020d	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00212	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 7757 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  00216	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021b	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7758 :     pMPC_PIXre->iptype = PIX_IPV4;

  0021f	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00224	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 7759 :     memcpy( pMPC_PIXre->idnum, pMPC_PIXwr->idnum, sizeof(pMPC_PIXre->idnum) );

  00228	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0022d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  00235	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  00239	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 7760 : 
; 7761 :     // Display various information, maybe
; 7762 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0023d	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00242	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00245	83 e0 10	 and	 eax, 16
  00248	85 c0		 test	 eax, eax
  0024a	74 15		 je	 SHORT $LN3@build_C108

; 7763 :     {
; 7764 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) I will stop IPv4" );

  0024c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172731
  00253	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0025b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7765 :     }
; 7766 : 
; 7767 :     return pPTPHDRre;

  00261	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7768 : }   /* End function  build_C108_i_will_stop_4() */

  00266	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0026a	c3		 ret	 0
build_C108_i_will_stop_4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
tv183 = 32
uLength3$ = 36
pMPC_RRHre$ = 40
pMPC_THre$ = 48
uLength1$ = 56
uLength2$ = 60
pMPC_PIXre$ = 64
pMPC_PHre$ = 72
pPTPBLK$ = 80
pPTPHDRre$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
build_C108_will_you_stop_6 PROC

; 7622 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7623 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00011	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00018	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7624 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 50	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7625 :     U32        uLength1;
; 7626 :     U32        uLength2;
; 7627 :     U32        uLength3;
; 7628 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7629 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7630 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7631 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7632 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7633 : 
; 7634 : 
; 7635 :     // Allocate a buffer in which the response will be build.
; 7636 :     // Note: the largest reply will be 88 bytes.
; 7637 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  0002a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0002f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00037	e8 00 00 00 00	 call	 alloc_ptp_buffer
  0003c	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7638 :     if (!pPTPHDRre)

  00041	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00047	75 07		 jne	 SHORT $LN2@build_C108

; 7639 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 3c 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7640 : 
; 7641 :     // Fix-up various lengths
; 7642 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  00050	c7 44 24 24 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7643 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00058	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7644 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  00060	8b 44 24 24	 mov	 eax, DWORD PTR uLength3$[rsp]
  00064	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 38	 mov	 DWORD PTR uLength1$[rsp], eax

; 7645 : 
; 7646 :     // Fix-up various pointers
; 7647 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00070	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00075	48 83 c0 10	 add	 rax, 16
  00079	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7648 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00083	48 83 c0 14	 add	 rax, 20
  00087	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7649 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00091	48 83 c0 24	 add	 rax, 36			; 00000024H
  00095	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7650 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0009f	48 83 c0 08	 add	 rax, 8
  000a3	48 89 44 24 40	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7651 : 
; 7652 :     // Prepare PTPHDRre
; 7653 :     pPTPHDRre->iDataLen = uLength1;

  000a8	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000ad	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000b1	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7654 : 
; 7655 :     // Prepare MPC_THre
; 7656 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000b4	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000b9	e8 00 00 00 00	 call	 _byteswap_ulong
  000be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000c3	8b d0		 mov	 edx, eax
  000c5	e8 00 00 00 00	 call	 store_fw_noswap

; 7657 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000ca	b9 14 00 00 00	 mov	 ecx, 20
  000cf	e8 00 00 00 00	 call	 _byteswap_ulong
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000d9	48 83 c1 08	 add	 rcx, 8
  000dd	8b d0		 mov	 edx, eax
  000df	e8 00 00 00 00	 call	 store_fw_noswap

; 7658 :     STORE_FW( pMPC_THre->length, uLength1 );

  000e4	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000f2	48 83 c1 0c	 add	 rcx, 12
  000f6	8b d0		 mov	 edx, eax
  000f8	e8 00 00 00 00	 call	 store_fw_noswap

; 7659 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  000fd	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00101	e8 00 00 00 00	 call	 _byteswap_ushort
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0010b	48 83 c1 10	 add	 rcx, 16
  0010f	0f b7 d0	 movzx	 edx, ax
  00112	e8 00 00 00 00	 call	 store_hw_noswap

; 7660 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00117	66 b9 01 00	 mov	 cx, 1
  0011b	e8 00 00 00 00	 call	 _byteswap_ushort
  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00125	48 83 c1 12	 add	 rcx, 18
  00129	0f b7 d0	 movzx	 edx, ax
  0012c	e8 00 00 00 00	 call	 store_hw_noswap

; 7661 : 
; 7662 :     // Prepare MPC_RRHre
; 7663 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00136	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7664 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0013f	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7665 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00143	66 b9 01 00	 mov	 cx, 1
  00147	e8 00 00 00 00	 call	 _byteswap_ushort
  0014c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00151	48 83 c1 06	 add	 rcx, 6
  00155	0f b7 d0	 movzx	 edx, ax
  00158	e8 00 00 00 00	 call	 store_hw_noswap

; 7666 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  0015d	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00161	e8 00 00 00 00	 call	 _byteswap_ushort
  00166	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0016b	48 83 c1 10	 add	 rcx, 16
  0016f	0f b7 d0	 movzx	 edx, ax
  00172	e8 00 00 00 00	 call	 store_hw_noswap

; 7667 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00177	0f b7 4c 24 24	 movzx	 ecx, WORD PTR uLength3$[rsp]
  0017c	e8 00 00 00 00	 call	 _byteswap_ushort
  00181	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00186	48 83 c1 12	 add	 rcx, 18
  0018a	0f b7 d0	 movzx	 edx, ax
  0018d	e8 00 00 00 00	 call	 store_hw_noswap

; 7668 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00192	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00196	e8 00 00 00 00	 call	 _byteswap_ulong
  0019b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a0	48 83 c1 14	 add	 rcx, 20
  001a4	8b d0		 mov	 edx, eax
  001a6	e8 00 00 00 00	 call	 store_f3_noswap

; 7669 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b0	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7670 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001be	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001c4	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7671 : 
; 7672 :     // Prepare MPC_PHre
; 7673 :     pMPC_PHre->locdata = PH_LOC_1;

  001c7	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001cc	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7674 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001cf	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001d3	e8 00 00 00 00	 call	 _byteswap_ulong
  001d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001dd	48 ff c1	 inc	 rcx
  001e0	8b d0		 mov	 edx, eax
  001e2	e8 00 00 00 00	 call	 store_f3_noswap

; 7675 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001e7	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001eb	e8 00 00 00 00	 call	 _byteswap_ulong
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001f5	48 83 c1 04	 add	 rcx, 4
  001f9	8b d0		 mov	 edx, eax
  001fb	e8 00 00 00 00	 call	 store_fw_noswap

; 7676 : 
; 7677 :     // Prepare MPC_PIXre
; 7678 :     pMPC_PIXre->action = PIX_STOP;

  00200	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00205	c6 00 02	 mov	 BYTE PTR [rax], 2

; 7679 :     pMPC_PIXre->askans = PIX_ASK;

  00208	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0020d	c6 40 01 80	 mov	 BYTE PTR [rax+1], 128	; 00000080H

; 7680 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  00211	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00216	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7681 :     pMPC_PIXre->iptype = PIX_IPV6;

  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021f	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 7682 :     STORE_HW( pMPC_PIXre->idnum, ++pPTPBLK->uIdNum );

  00223	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00228	0f b7 80 82 03
	00 00		 movzx	 eax, WORD PTR [rax+898]
  0022f	66 ff c0	 inc	 ax
  00232	66 89 44 24 20	 mov	 WORD PTR tv183[rsp], ax
  00237	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0023c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  00241	66 89 88 82 03
	00 00		 mov	 WORD PTR [rax+898], cx
  00248	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  0024d	e8 00 00 00 00	 call	 _byteswap_ushort
  00252	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00257	48 83 c1 04	 add	 rcx, 4
  0025b	0f b7 d0	 movzx	 edx, ax
  0025e	e8 00 00 00 00	 call	 store_hw_noswap

; 7683 : 
; 7684 :     // Display various information, maybe
; 7685 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00263	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00268	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0026b	83 e0 10	 and	 eax, 16
  0026e	85 c0		 test	 eax, eax
  00270	74 15		 je	 SHORT $LN3@build_C108

; 7686 :     {
; 7687 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) Will you stop IPv6?" );

  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172702
  00279	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7688 :     }
; 7689 : 
; 7690 :     return pPTPHDRre;

  00287	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7691 : }   /* End function  build_C108_will_you_stop_6() */

  0028c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00290	c3		 ret	 0
build_C108_will_you_stop_6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
tv183 = 32
uLength3$ = 36
pMPC_RRHre$ = 40
pMPC_THre$ = 48
uLength1$ = 56
uLength2$ = 60
pMPC_PIXre$ = 64
pMPC_PHre$ = 72
pPTPBLK$ = 80
pPTPHDRre$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
build_C108_will_you_stop_4 PROC

; 7545 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7546 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00011	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00018	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7547 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 50	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7548 :     U32        uLength1;
; 7549 :     U32        uLength2;
; 7550 :     U32        uLength3;
; 7551 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7552 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7553 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7554 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7555 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7556 : 
; 7557 : 
; 7558 :     // Allocate a buffer in which the response will be build.
; 7559 :     // Note: the largest reply will be 88 bytes.
; 7560 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  0002a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0002f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00037	e8 00 00 00 00	 call	 alloc_ptp_buffer
  0003c	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7561 :     if (!pPTPHDRre)

  00041	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00047	75 07		 jne	 SHORT $LN2@build_C108

; 7562 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 3c 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7563 : 
; 7564 :     // Fix-up various lengths
; 7565 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  00050	c7 44 24 24 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7566 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00058	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7567 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  00060	8b 44 24 24	 mov	 eax, DWORD PTR uLength3$[rsp]
  00064	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 38	 mov	 DWORD PTR uLength1$[rsp], eax

; 7568 : 
; 7569 :     // Fix-up various pointers
; 7570 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00070	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00075	48 83 c0 10	 add	 rax, 16
  00079	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7571 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00083	48 83 c0 14	 add	 rax, 20
  00087	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7572 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00091	48 83 c0 24	 add	 rax, 36			; 00000024H
  00095	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7573 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0009f	48 83 c0 08	 add	 rax, 8
  000a3	48 89 44 24 40	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7574 : 
; 7575 :     // Prepare PTPHDRre
; 7576 :     pPTPHDRre->iDataLen = uLength1;

  000a8	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000ad	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000b1	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7577 : 
; 7578 :     // Prepare MPC_THre
; 7579 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000b4	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000b9	e8 00 00 00 00	 call	 _byteswap_ulong
  000be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000c3	8b d0		 mov	 edx, eax
  000c5	e8 00 00 00 00	 call	 store_fw_noswap

; 7580 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000ca	b9 14 00 00 00	 mov	 ecx, 20
  000cf	e8 00 00 00 00	 call	 _byteswap_ulong
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000d9	48 83 c1 08	 add	 rcx, 8
  000dd	8b d0		 mov	 edx, eax
  000df	e8 00 00 00 00	 call	 store_fw_noswap

; 7581 :     STORE_FW( pMPC_THre->length, uLength1 );

  000e4	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000f2	48 83 c1 0c	 add	 rcx, 12
  000f6	8b d0		 mov	 edx, eax
  000f8	e8 00 00 00 00	 call	 store_fw_noswap

; 7582 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  000fd	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00101	e8 00 00 00 00	 call	 _byteswap_ushort
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0010b	48 83 c1 10	 add	 rcx, 16
  0010f	0f b7 d0	 movzx	 edx, ax
  00112	e8 00 00 00 00	 call	 store_hw_noswap

; 7583 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00117	66 b9 01 00	 mov	 cx, 1
  0011b	e8 00 00 00 00	 call	 _byteswap_ushort
  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00125	48 83 c1 12	 add	 rcx, 18
  00129	0f b7 d0	 movzx	 edx, ax
  0012c	e8 00 00 00 00	 call	 store_hw_noswap

; 7584 : 
; 7585 :     // Prepare MPC_RRHre
; 7586 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00136	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7587 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0013f	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7588 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00143	66 b9 01 00	 mov	 cx, 1
  00147	e8 00 00 00 00	 call	 _byteswap_ushort
  0014c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00151	48 83 c1 06	 add	 rcx, 6
  00155	0f b7 d0	 movzx	 edx, ax
  00158	e8 00 00 00 00	 call	 store_hw_noswap

; 7589 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  0015d	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00161	e8 00 00 00 00	 call	 _byteswap_ushort
  00166	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0016b	48 83 c1 10	 add	 rcx, 16
  0016f	0f b7 d0	 movzx	 edx, ax
  00172	e8 00 00 00 00	 call	 store_hw_noswap

; 7590 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00177	0f b7 4c 24 24	 movzx	 ecx, WORD PTR uLength3$[rsp]
  0017c	e8 00 00 00 00	 call	 _byteswap_ushort
  00181	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00186	48 83 c1 12	 add	 rcx, 18
  0018a	0f b7 d0	 movzx	 edx, ax
  0018d	e8 00 00 00 00	 call	 store_hw_noswap

; 7591 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00192	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00196	e8 00 00 00 00	 call	 _byteswap_ulong
  0019b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a0	48 83 c1 14	 add	 rcx, 20
  001a4	8b d0		 mov	 edx, eax
  001a6	e8 00 00 00 00	 call	 store_f3_noswap

; 7592 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b0	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7593 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001be	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001c4	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7594 : 
; 7595 :     // Prepare MPC_PHre
; 7596 :     pMPC_PHre->locdata = PH_LOC_1;

  001c7	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001cc	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7597 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001cf	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001d3	e8 00 00 00 00	 call	 _byteswap_ulong
  001d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001dd	48 ff c1	 inc	 rcx
  001e0	8b d0		 mov	 edx, eax
  001e2	e8 00 00 00 00	 call	 store_f3_noswap

; 7598 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001e7	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001eb	e8 00 00 00 00	 call	 _byteswap_ulong
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001f5	48 83 c1 04	 add	 rcx, 4
  001f9	8b d0		 mov	 edx, eax
  001fb	e8 00 00 00 00	 call	 store_fw_noswap

; 7599 : 
; 7600 :     // Prepare MPC_PIXre
; 7601 :     pMPC_PIXre->action = PIX_STOP;

  00200	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00205	c6 00 02	 mov	 BYTE PTR [rax], 2

; 7602 :     pMPC_PIXre->askans = PIX_ASK;

  00208	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0020d	c6 40 01 80	 mov	 BYTE PTR [rax+1], 128	; 00000080H

; 7603 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  00211	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00216	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7604 :     pMPC_PIXre->iptype = PIX_IPV4;

  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021f	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 7605 :     STORE_HW( pMPC_PIXre->idnum, ++pPTPBLK->uIdNum );

  00223	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00228	0f b7 80 82 03
	00 00		 movzx	 eax, WORD PTR [rax+898]
  0022f	66 ff c0	 inc	 ax
  00232	66 89 44 24 20	 mov	 WORD PTR tv183[rsp], ax
  00237	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0023c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  00241	66 89 88 82 03
	00 00		 mov	 WORD PTR [rax+898], cx
  00248	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  0024d	e8 00 00 00 00	 call	 _byteswap_ushort
  00252	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00257	48 83 c1 04	 add	 rcx, 4
  0025b	0f b7 d0	 movzx	 edx, ax
  0025e	e8 00 00 00 00	 call	 store_hw_noswap

; 7606 : 
; 7607 :     // Display various information, maybe
; 7608 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00263	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00268	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0026b	83 e0 10	 and	 eax, 16
  0026e	85 c0		 test	 eax, eax
  00270	74 15		 je	 SHORT $LN3@build_C108

; 7609 :     {
; 7610 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) Will you stop IPv4?" );

  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172675
  00279	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7611 :     }
; 7612 : 
; 7613 :     return pPTPHDRre;

  00287	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7614 : }   /* End function  build_C108_will_you_stop_4() */

  0028c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00290	c3		 ret	 0
build_C108_will_you_stop_4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength3$ = 32
pMPC_RRHre$ = 40
pMPC_PIXre$ = 48
pMPC_THre$ = 56
uLength1$ = 64
uLength2$ = 68
pMPC_PHre$ = 72
pPTPHDRre$ = 80
pPTPBLK$ = 88
pPTPATH$ = 96
pDEVBLK$ = 144
pMPC_PIXwr$ = 152
uRCode$ = 160
build_C108_your_address_6 PROC

; 7466 : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7467 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00016	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00025	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7468 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 89 44 24 58	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7469 :     U32        uLength1;
; 7470 :     U32        uLength2;
; 7471 :     U32        uLength3;
; 7472 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7473 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7474 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7475 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7476 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7477 : 
; 7478 : 
; 7479 :     // Allocate a buffer in which the first reply will be build.
; 7480 :     // Note: the largest reply will be 88 bytes.
; 7481 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00037	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0003c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00044	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00049	48 89 44 24 50	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7482 :     if (!pPTPHDRre)

  0004e	48 83 7c 24 50
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00054	75 07		 jne	 SHORT $LN2@build_C108

; 7483 :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	e9 4b 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7484 : 
; 7485 :     // Fix-up various lengths
; 7486 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  0005d	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7487 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00065	c7 44 24 44 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7488 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  0006d	8b 44 24 20	 mov	 eax, DWORD PTR uLength3$[rsp]
  00071	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00075	03 c8		 add	 ecx, eax
  00077	8b c1		 mov	 eax, ecx
  00079	89 44 24 40	 mov	 DWORD PTR uLength1$[rsp], eax

; 7489 : 
; 7490 :     // Fix-up various pointers
; 7491 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00082	48 83 c0 10	 add	 rax, 16
  00086	48 89 44 24 38	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7492 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  0008b	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00090	48 83 c0 14	 add	 rax, 20
  00094	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7493 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0009e	48 83 c0 24	 add	 rax, 36			; 00000024H
  000a2	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7494 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  000a7	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000ac	48 83 c0 08	 add	 rax, 8
  000b0	48 89 44 24 30	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7495 : 
; 7496 :     // Prepare PTPHDRre
; 7497 :     pPTPHDRre->iDataLen = uLength1;

  000b5	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000ba	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000be	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7498 : 
; 7499 :     // Prepare MPC_THre
; 7500 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000c1	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000c6	e8 00 00 00 00	 call	 _byteswap_ulong
  000cb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000d0	8b d0		 mov	 edx, eax
  000d2	e8 00 00 00 00	 call	 store_fw_noswap

; 7501 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000d7	b9 14 00 00 00	 mov	 ecx, 20
  000dc	e8 00 00 00 00	 call	 _byteswap_ulong
  000e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000e6	48 83 c1 08	 add	 rcx, 8
  000ea	8b d0		 mov	 edx, eax
  000ec	e8 00 00 00 00	 call	 store_fw_noswap

; 7502 :     STORE_FW( pMPC_THre->length, uLength1 );

  000f1	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000f5	e8 00 00 00 00	 call	 _byteswap_ulong
  000fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000ff	48 83 c1 0c	 add	 rcx, 12
  00103	8b d0		 mov	 edx, eax
  00105	e8 00 00 00 00	 call	 store_fw_noswap

; 7503 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  0010a	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  0010e	e8 00 00 00 00	 call	 _byteswap_ushort
  00113	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00118	48 83 c1 10	 add	 rcx, 16
  0011c	0f b7 d0	 movzx	 edx, ax
  0011f	e8 00 00 00 00	 call	 store_hw_noswap

; 7504 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00124	66 b9 01 00	 mov	 cx, 1
  00128	e8 00 00 00 00	 call	 _byteswap_ushort
  0012d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00132	48 83 c1 12	 add	 rcx, 18
  00136	0f b7 d0	 movzx	 edx, ax
  00139	e8 00 00 00 00	 call	 store_hw_noswap

; 7505 : 
; 7506 :     // Prepare MPC_RRHre
; 7507 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  0013e	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00143	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7508 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  00147	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0014c	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7509 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00150	66 b9 01 00	 mov	 cx, 1
  00154	e8 00 00 00 00	 call	 _byteswap_ushort
  00159	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0015e	48 83 c1 06	 add	 rcx, 6
  00162	0f b7 d0	 movzx	 edx, ax
  00165	e8 00 00 00 00	 call	 store_hw_noswap

; 7510 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  0016a	66 b9 24 00	 mov	 cx, 36			; 00000024H
  0016e	e8 00 00 00 00	 call	 _byteswap_ushort
  00173	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00178	48 83 c1 10	 add	 rcx, 16
  0017c	0f b7 d0	 movzx	 edx, ax
  0017f	e8 00 00 00 00	 call	 store_hw_noswap

; 7511 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00184	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00189	e8 00 00 00 00	 call	 _byteswap_ushort
  0018e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00193	48 83 c1 12	 add	 rcx, 18
  00197	0f b7 d0	 movzx	 edx, ax
  0019a	e8 00 00 00 00	 call	 store_hw_noswap

; 7512 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  0019f	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001a3	e8 00 00 00 00	 call	 _byteswap_ulong
  001a8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001ad	48 83 c1 14	 add	 rcx, 20
  001b1	8b d0		 mov	 edx, eax
  001b3	e8 00 00 00 00	 call	 store_f3_noswap

; 7513 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001b8	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001bd	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7514 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001c1	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001cb	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001d1	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7515 : 
; 7516 :     // Prepare MPC_PHre
; 7517 :     pMPC_PHre->locdata = PH_LOC_1;

  001d4	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001d9	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7518 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001dc	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001e0	e8 00 00 00 00	 call	 _byteswap_ulong
  001e5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001ea	48 ff c1	 inc	 rcx
  001ed	8b d0		 mov	 edx, eax
  001ef	e8 00 00 00 00	 call	 store_f3_noswap

; 7519 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001f4	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001f8	e8 00 00 00 00	 call	 _byteswap_ulong
  001fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00202	48 83 c1 04	 add	 rcx, 4
  00206	8b d0		 mov	 edx, eax
  00208	e8 00 00 00 00	 call	 store_fw_noswap

; 7520 : 
; 7521 :     // Prepare MPC_PIXre
; 7522 :     pMPC_PIXre->action = PIX_ADDRESS;

  0020d	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00212	c6 00 11	 mov	 BYTE PTR [rax], 17

; 7523 :     pMPC_PIXre->askans = PIX_ANSWER;

  00215	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021a	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 7524 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  0021e	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00223	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7525 :     pMPC_PIXre->iptype = PIX_IPV6;

  00227	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0022c	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 7526 :     memcpy( pMPC_PIXre->idnum, pMPC_PIXwr->idnum, sizeof(pMPC_PIXre->idnum) );

  00230	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00235	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  0023d	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  00241	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 7527 :     STORE_HW( pMPC_PIXre->rcode, uRCode );

  00245	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR uRCode$[rsp]
  0024d	e8 00 00 00 00	 call	 _byteswap_ushort
  00252	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00257	48 83 c1 06	 add	 rcx, 6
  0025b	0f b7 d0	 movzx	 edx, ax
  0025e	e8 00 00 00 00	 call	 store_hw_noswap

; 7528 :     memcpy( pMPC_PIXre->ipaddr, pMPC_PIXwr->ipaddr, 16 );

  00263	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00268	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  00270	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  00274	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  00278	b9 10 00 00 00	 mov	 ecx, 16
  0027d	f3 a4		 rep movsb

; 7529 : 
; 7530 :     // Display various information, maybe
; 7531 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0027f	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00284	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00287	83 e0 10	 and	 eax, 16
  0028a	85 c0		 test	 eax, eax
  0028c	74 15		 je	 SHORT $LN3@build_C108

; 7532 :     {
; 7533 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) Your address IPv6" );

  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172648
  00295	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7534 :     }
; 7535 : 
; 7536 :     return pPTPHDRre;

  002a3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7537 : }   /* End function  build_C108_your_address_6() */

  002a8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002ac	5f		 pop	 rdi
  002ad	5e		 pop	 rsi
  002ae	c3		 ret	 0
build_C108_your_address_6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength3$ = 32
pMPC_RRHre$ = 40
pMPC_PIXre$ = 48
pMPC_THre$ = 56
uLength1$ = 64
uLength2$ = 68
pMPC_PHre$ = 72
pPTPHDRre$ = 80
pPTPBLK$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
pMPC_PIXwr$ = 136
uRCode$ = 144
build_C108_your_address_4 PROC

; 7387 : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7388 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00014	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001c	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00023	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7389 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 58	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7390 :     U32        uLength1;
; 7391 :     U32        uLength2;
; 7392 :     U32        uLength3;
; 7393 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7394 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7395 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7396 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7397 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7398 : 
; 7399 : 
; 7400 :     // Allocate a buffer in which the response will be build.
; 7401 :     // Note: the largest reply will be 88 bytes.
; 7402 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00035	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0003a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00042	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00047	48 89 44 24 50	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7403 :     if (!pPTPHDRre)

  0004c	48 83 7c 24 50
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00052	75 07		 jne	 SHORT $LN2@build_C108

; 7404 :         return NULL;

  00054	33 c0		 xor	 eax, eax
  00056	e9 42 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7405 : 
; 7406 :     // Fix-up various lengths
; 7407 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  0005b	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7408 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00063	c7 44 24 44 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7409 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  0006b	8b 44 24 20	 mov	 eax, DWORD PTR uLength3$[rsp]
  0006f	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00073	03 c8		 add	 ecx, eax
  00075	8b c1		 mov	 eax, ecx
  00077	89 44 24 40	 mov	 DWORD PTR uLength1$[rsp], eax

; 7410 : 
; 7411 :     // Fix-up various pointers
; 7412 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00080	48 83 c0 10	 add	 rax, 16
  00084	48 89 44 24 38	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7413 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00089	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  0008e	48 83 c0 14	 add	 rax, 20
  00092	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7414 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0009c	48 83 c0 24	 add	 rax, 36			; 00000024H
  000a0	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7415 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  000a5	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000aa	48 83 c0 08	 add	 rax, 8
  000ae	48 89 44 24 30	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7416 : 
; 7417 :     // Prepare PTPHDRre
; 7418 :     pPTPHDRre->iDataLen = uLength1;

  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000b8	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000bc	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7419 : 
; 7420 :     // Prepare MPC_THre
; 7421 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000bf	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000c4	e8 00 00 00 00	 call	 _byteswap_ulong
  000c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000ce	8b d0		 mov	 edx, eax
  000d0	e8 00 00 00 00	 call	 store_fw_noswap

; 7422 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000d5	b9 14 00 00 00	 mov	 ecx, 20
  000da	e8 00 00 00 00	 call	 _byteswap_ulong
  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000e4	48 83 c1 08	 add	 rcx, 8
  000e8	8b d0		 mov	 edx, eax
  000ea	e8 00 00 00 00	 call	 store_fw_noswap

; 7423 :     STORE_FW( pMPC_THre->length, uLength1 );

  000ef	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000f3	e8 00 00 00 00	 call	 _byteswap_ulong
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000fd	48 83 c1 0c	 add	 rcx, 12
  00101	8b d0		 mov	 edx, eax
  00103	e8 00 00 00 00	 call	 store_fw_noswap

; 7424 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00108	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  0010c	e8 00 00 00 00	 call	 _byteswap_ushort
  00111	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00116	48 83 c1 10	 add	 rcx, 16
  0011a	0f b7 d0	 movzx	 edx, ax
  0011d	e8 00 00 00 00	 call	 store_hw_noswap

; 7425 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00122	66 b9 01 00	 mov	 cx, 1
  00126	e8 00 00 00 00	 call	 _byteswap_ushort
  0012b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00130	48 83 c1 12	 add	 rcx, 18
  00134	0f b7 d0	 movzx	 edx, ax
  00137	e8 00 00 00 00	 call	 store_hw_noswap

; 7426 : 
; 7427 :     // Prepare MPC_RRHre
; 7428 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  0013c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00141	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7429 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  00145	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0014a	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7430 :     STORE_HW( pMPC_RRHre->numph, 1 );

  0014e	66 b9 01 00	 mov	 cx, 1
  00152	e8 00 00 00 00	 call	 _byteswap_ushort
  00157	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0015c	48 83 c1 06	 add	 rcx, 6
  00160	0f b7 d0	 movzx	 edx, ax
  00163	e8 00 00 00 00	 call	 store_hw_noswap

; 7431 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00168	66 b9 24 00	 mov	 cx, 36			; 00000024H
  0016c	e8 00 00 00 00	 call	 _byteswap_ushort
  00171	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00176	48 83 c1 10	 add	 rcx, 16
  0017a	0f b7 d0	 movzx	 edx, ax
  0017d	e8 00 00 00 00	 call	 store_hw_noswap

; 7432 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00182	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00187	e8 00 00 00 00	 call	 _byteswap_ushort
  0018c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00191	48 83 c1 12	 add	 rcx, 18
  00195	0f b7 d0	 movzx	 edx, ax
  00198	e8 00 00 00 00	 call	 store_hw_noswap

; 7433 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  0019d	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001a1	e8 00 00 00 00	 call	 _byteswap_ulong
  001a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001ab	48 83 c1 14	 add	 rcx, 20
  001af	8b d0		 mov	 edx, eax
  001b1	e8 00 00 00 00	 call	 store_f3_noswap

; 7434 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001bb	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7435 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001bf	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001c4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001c9	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001cf	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7436 : 
; 7437 :     // Prepare MPC_PHre
; 7438 :     pMPC_PHre->locdata = PH_LOC_1;

  001d2	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001d7	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7439 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001da	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001de	e8 00 00 00 00	 call	 _byteswap_ulong
  001e3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001e8	48 ff c1	 inc	 rcx
  001eb	8b d0		 mov	 edx, eax
  001ed	e8 00 00 00 00	 call	 store_f3_noswap

; 7440 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001f2	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001f6	e8 00 00 00 00	 call	 _byteswap_ulong
  001fb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00200	48 83 c1 04	 add	 rcx, 4
  00204	8b d0		 mov	 edx, eax
  00206	e8 00 00 00 00	 call	 store_fw_noswap

; 7441 : 
; 7442 :     // Prepare MPC_PIXre
; 7443 :     pMPC_PIXre->action = PIX_ADDRESS;

  0020b	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00210	c6 00 11	 mov	 BYTE PTR [rax], 17

; 7444 :     pMPC_PIXre->askans = PIX_ANSWER;

  00213	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00218	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 7445 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  0021c	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00221	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7446 :     pMPC_PIXre->iptype = PIX_IPV4;

  00225	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0022a	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 7447 :     memcpy( pMPC_PIXre->idnum, pMPC_PIXwr->idnum, sizeof(pMPC_PIXre->idnum) );

  0022e	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00233	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  0023b	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  0023f	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 7448 :     STORE_HW( pMPC_PIXre->rcode, uRCode );

  00243	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR uRCode$[rsp]
  0024b	e8 00 00 00 00	 call	 _byteswap_ushort
  00250	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00255	48 83 c1 06	 add	 rcx, 6
  00259	0f b7 d0	 movzx	 edx, ax
  0025c	e8 00 00 00 00	 call	 store_hw_noswap

; 7449 :     memcpy( pMPC_PIXre->ipaddr, pMPC_PIXwr->ipaddr, 4 );

  00261	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00266	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  0026e	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00271	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 7450 : 
; 7451 :     // Display various information, maybe
; 7452 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00274	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00279	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0027c	83 e0 10	 and	 eax, 16
  0027f	85 c0		 test	 eax, eax
  00281	74 15		 je	 SHORT $LN3@build_C108

; 7453 :     {
; 7454 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) Your address IPv4" );

  00283	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172617
  0028a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7455 :     }
; 7456 : 
; 7457 :     return pPTPHDRre;

  00298	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7458 : }   /* End function  build_C108_your_address_4() */

  0029d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002a1	c3		 ret	 0
build_C108_your_address_4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
tv183 = 32
uLength3$ = 36
pMPC_RRHre$ = 40
pMPC_PIXre$ = 48
pMPC_THre$ = 56
pPTPBLK$ = 64
uLength1$ = 72
uLength2$ = 76
pMPC_PHre$ = 80
pPTPHDRre$ = 88
pPTPATH$ = 96
pDEVBLK$ = 144
fLL$ = 152
build_C108_my_address_6 PROC

; 7300 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7301 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  0000f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00017	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0001e	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7302 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 89 44 24 40	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7303 :     U32        uLength1;
; 7304 :     U32        uLength2;
; 7305 :     U32        uLength3;
; 7306 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7307 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7308 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7309 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7310 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7311 : 
; 7312 : 
; 7313 :     // Allocate a buffer in which the response will be build.
; 7314 :     // Note: the largest reply will be 88 bytes.
; 7315 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00030	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00035	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0003d	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00042	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7316 :     if (!pPTPHDRre)

  00047	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  0004d	75 07		 jne	 SHORT $LN2@build_C108

; 7317 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 80 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7318 : 
; 7319 :     // Fix-up various lengths
; 7320 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  00056	c7 44 24 24 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7321 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  0005e	c7 44 24 4c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7322 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  00066	8b 44 24 24	 mov	 eax, DWORD PTR uLength3$[rsp]
  0006a	8b 4c 24 4c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  0006e	03 c8		 add	 ecx, eax
  00070	8b c1		 mov	 eax, ecx
  00072	89 44 24 48	 mov	 DWORD PTR uLength1$[rsp], eax

; 7323 : 
; 7324 :     // Fix-up various pointers
; 7325 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00076	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0007b	48 83 c0 10	 add	 rax, 16
  0007f	48 89 44 24 38	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7326 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00084	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00089	48 83 c0 14	 add	 rax, 20
  0008d	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7327 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00092	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00097	48 83 c0 24	 add	 rax, 36			; 00000024H
  0009b	48 89 44 24 50	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7328 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000a5	48 83 c0 08	 add	 rax, 8
  000a9	48 89 44 24 30	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7329 : 
; 7330 :     // Prepare PTPHDRre
; 7331 :     pPTPHDRre->iDataLen = uLength1;

  000ae	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000b3	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000b7	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7332 : 
; 7333 :     // Prepare MPC_THre
; 7334 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000ba	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000bf	e8 00 00 00 00	 call	 _byteswap_ulong
  000c4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000c9	8b d0		 mov	 edx, eax
  000cb	e8 00 00 00 00	 call	 store_fw_noswap

; 7335 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000d0	b9 14 00 00 00	 mov	 ecx, 20
  000d5	e8 00 00 00 00	 call	 _byteswap_ulong
  000da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000df	48 83 c1 08	 add	 rcx, 8
  000e3	8b d0		 mov	 edx, eax
  000e5	e8 00 00 00 00	 call	 store_fw_noswap

; 7336 :     STORE_FW( pMPC_THre->length, uLength1 );

  000ea	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000ee	e8 00 00 00 00	 call	 _byteswap_ulong
  000f3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000f8	48 83 c1 0c	 add	 rcx, 12
  000fc	8b d0		 mov	 edx, eax
  000fe	e8 00 00 00 00	 call	 store_fw_noswap

; 7337 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00103	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00107	e8 00 00 00 00	 call	 _byteswap_ushort
  0010c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00111	48 83 c1 10	 add	 rcx, 16
  00115	0f b7 d0	 movzx	 edx, ax
  00118	e8 00 00 00 00	 call	 store_hw_noswap

; 7338 :     STORE_HW( pMPC_THre->numrrh, 1 );

  0011d	66 b9 01 00	 mov	 cx, 1
  00121	e8 00 00 00 00	 call	 _byteswap_ushort
  00126	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0012b	48 83 c1 12	 add	 rcx, 18
  0012f	0f b7 d0	 movzx	 edx, ax
  00132	e8 00 00 00 00	 call	 store_hw_noswap

; 7339 : 
; 7340 :     // Prepare MPC_RRHre
; 7341 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0013c	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7342 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  00140	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00145	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7343 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00149	66 b9 01 00	 mov	 cx, 1
  0014d	e8 00 00 00 00	 call	 _byteswap_ushort
  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00157	48 83 c1 06	 add	 rcx, 6
  0015b	0f b7 d0	 movzx	 edx, ax
  0015e	e8 00 00 00 00	 call	 store_hw_noswap

; 7344 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00163	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00167	e8 00 00 00 00	 call	 _byteswap_ushort
  0016c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00171	48 83 c1 10	 add	 rcx, 16
  00175	0f b7 d0	 movzx	 edx, ax
  00178	e8 00 00 00 00	 call	 store_hw_noswap

; 7345 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  0017d	0f b7 4c 24 24	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00182	e8 00 00 00 00	 call	 _byteswap_ushort
  00187	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0018c	48 83 c1 12	 add	 rcx, 18
  00190	0f b7 d0	 movzx	 edx, ax
  00193	e8 00 00 00 00	 call	 store_hw_noswap

; 7346 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00198	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0019c	e8 00 00 00 00	 call	 _byteswap_ulong
  001a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a6	48 83 c1 14	 add	 rcx, 20
  001aa	8b d0		 mov	 edx, eax
  001ac	e8 00 00 00 00	 call	 store_f3_noswap

; 7347 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001b1	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b6	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7348 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001ba	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001c4	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001ca	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7349 : 
; 7350 :     // Prepare MPC_PHre
; 7351 :     pMPC_PHre->locdata = PH_LOC_1;

  001cd	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001d2	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7352 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001d5	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001d9	e8 00 00 00 00	 call	 _byteswap_ulong
  001de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001e3	48 ff c1	 inc	 rcx
  001e6	8b d0		 mov	 edx, eax
  001e8	e8 00 00 00 00	 call	 store_f3_noswap

; 7353 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001ed	8b 4c 24 4c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001f1	e8 00 00 00 00	 call	 _byteswap_ulong
  001f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001fb	48 83 c1 04	 add	 rcx, 4
  001ff	8b d0		 mov	 edx, eax
  00201	e8 00 00 00 00	 call	 store_fw_noswap

; 7354 : 
; 7355 :     // Prepare MPC_PIXre
; 7356 :     pMPC_PIXre->action = PIX_ADDRESS;

  00206	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0020b	c6 00 11	 mov	 BYTE PTR [rax], 17

; 7357 :     pMPC_PIXre->askans = PIX_ASK;

  0020e	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00213	c6 40 01 80	 mov	 BYTE PTR [rax+1], 128	; 00000080H

; 7358 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  00217	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021c	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7359 :     pMPC_PIXre->iptype = PIX_IPV6;

  00220	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00225	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 7360 :     STORE_HW( pMPC_PIXre->idnum, ++pPTPBLK->uIdNum );

  00229	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0022e	0f b7 80 82 03
	00 00		 movzx	 eax, WORD PTR [rax+898]
  00235	66 ff c0	 inc	 ax
  00238	66 89 44 24 20	 mov	 WORD PTR tv183[rsp], ax
  0023d	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00242	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  00247	66 89 88 82 03
	00 00		 mov	 WORD PTR [rax+898], cx
  0024e	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  00253	e8 00 00 00 00	 call	 _byteswap_ushort
  00258	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  0025d	48 83 c1 04	 add	 rcx, 4
  00261	0f b7 d0	 movzx	 edx, ax
  00264	e8 00 00 00 00	 call	 store_hw_noswap

; 7361 :     if (fLL)

  00269	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR fLL$[rsp], 0
  00271	74 1e		 je	 SHORT $LN3@build_C108

; 7362 :     {
; 7363 : #if defined(ENABLE_IPV6)
; 7364 :         memcpy( pMPC_PIXre->ipaddr, &pPTPBLK->iaDriveLLAddr6, 16 );

  00273	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00278	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0027d	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  00281	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  00288	b9 10 00 00 00	 mov	 ecx, 16
  0028d	f3 a4		 rep movsb

; 7365 :     }

  0028f	eb 1c		 jmp	 SHORT $LN4@build_C108
$LN3@build_C108:

; 7366 :     else
; 7367 :     {
; 7368 :         memcpy( pMPC_PIXre->ipaddr, &pPTPBLK->iaDriveIPAddr6, 16 );

  00291	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00296	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0029b	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  0029f	48 8d b1 e0 02
	00 00		 lea	 rsi, QWORD PTR [rcx+736]
  002a6	b9 10 00 00 00	 mov	 ecx, 16
  002ab	f3 a4		 rep movsb
$LN4@build_C108:

; 7369 : #endif /* defined(ENABLE_IPV6) */
; 7370 :     }
; 7371 : 
; 7372 :     // Display various information, maybe
; 7373 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  002ad	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002b2	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  002b5	83 e0 10	 and	 eax, 16
  002b8	85 c0		 test	 eax, eax
  002ba	74 15		 je	 SHORT $LN5@build_C108

; 7374 :     {
; 7375 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) My address IPv6" );

  002bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172586
  002c3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN5@build_C108:

; 7376 :     }
; 7377 : 
; 7378 :     return pPTPHDRre;

  002d1	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7379 : }   /* End function  build_C108_my_address_6() */

  002d6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002da	5f		 pop	 rdi
  002db	5e		 pop	 rsi
  002dc	c3		 ret	 0
build_C108_my_address_6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
tv183 = 32
uLength3$ = 36
pMPC_RRHre$ = 40
pMPC_THre$ = 48
pMPC_PIXre$ = 56
uLength1$ = 64
uLength2$ = 68
pPTPBLK$ = 72
pMPC_PHre$ = 80
pPTPHDRre$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
build_C108_my_address_4 PROC

; 7222 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7223 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00011	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00018	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7224 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 48	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7225 :     U32        uLength1;
; 7226 :     U32        uLength2;
; 7227 :     U32        uLength3;
; 7228 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7229 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7230 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7231 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7232 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7233 : 
; 7234 : 
; 7235 :     // Allocate a buffer in which the response will be build.
; 7236 :     // Note: the largest reply will be 88 bytes.
; 7237 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  0002a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0002f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00037	e8 00 00 00 00	 call	 alloc_ptp_buffer
  0003c	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7238 :     if (!pPTPHDRre)

  00041	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00047	75 07		 jne	 SHORT $LN2@build_C108

; 7239 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 4f 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7240 : 
; 7241 :     // Fix-up various lengths
; 7242 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  00050	c7 44 24 24 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7243 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00058	c7 44 24 44 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7244 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  00060	8b 44 24 24	 mov	 eax, DWORD PTR uLength3$[rsp]
  00064	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 40	 mov	 DWORD PTR uLength1$[rsp], eax

; 7245 : 
; 7246 :     // Fix-up various pointers
; 7247 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00070	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00075	48 83 c0 10	 add	 rax, 16
  00079	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7248 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00083	48 83 c0 14	 add	 rax, 20
  00087	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7249 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00091	48 83 c0 24	 add	 rax, 36			; 00000024H
  00095	48 89 44 24 50	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7250 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0009f	48 83 c0 08	 add	 rax, 8
  000a3	48 89 44 24 38	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7251 : 
; 7252 :     // Prepare PTPHDRre
; 7253 :     pPTPHDRre->iDataLen = uLength1;

  000a8	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000ad	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000b1	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7254 : 
; 7255 :     // Prepare MPC_THre
; 7256 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000b4	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000b9	e8 00 00 00 00	 call	 _byteswap_ulong
  000be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000c3	8b d0		 mov	 edx, eax
  000c5	e8 00 00 00 00	 call	 store_fw_noswap

; 7257 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000ca	b9 14 00 00 00	 mov	 ecx, 20
  000cf	e8 00 00 00 00	 call	 _byteswap_ulong
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000d9	48 83 c1 08	 add	 rcx, 8
  000dd	8b d0		 mov	 edx, eax
  000df	e8 00 00 00 00	 call	 store_fw_noswap

; 7258 :     STORE_FW( pMPC_THre->length, uLength1 );

  000e4	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000f2	48 83 c1 0c	 add	 rcx, 12
  000f6	8b d0		 mov	 edx, eax
  000f8	e8 00 00 00 00	 call	 store_fw_noswap

; 7259 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  000fd	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00101	e8 00 00 00 00	 call	 _byteswap_ushort
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0010b	48 83 c1 10	 add	 rcx, 16
  0010f	0f b7 d0	 movzx	 edx, ax
  00112	e8 00 00 00 00	 call	 store_hw_noswap

; 7260 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00117	66 b9 01 00	 mov	 cx, 1
  0011b	e8 00 00 00 00	 call	 _byteswap_ushort
  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00125	48 83 c1 12	 add	 rcx, 18
  00129	0f b7 d0	 movzx	 edx, ax
  0012c	e8 00 00 00 00	 call	 store_hw_noswap

; 7261 : 
; 7262 :     // Prepare MPC_RRHre
; 7263 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00136	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7264 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0013f	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7265 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00143	66 b9 01 00	 mov	 cx, 1
  00147	e8 00 00 00 00	 call	 _byteswap_ushort
  0014c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00151	48 83 c1 06	 add	 rcx, 6
  00155	0f b7 d0	 movzx	 edx, ax
  00158	e8 00 00 00 00	 call	 store_hw_noswap

; 7266 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  0015d	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00161	e8 00 00 00 00	 call	 _byteswap_ushort
  00166	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0016b	48 83 c1 10	 add	 rcx, 16
  0016f	0f b7 d0	 movzx	 edx, ax
  00172	e8 00 00 00 00	 call	 store_hw_noswap

; 7267 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00177	0f b7 4c 24 24	 movzx	 ecx, WORD PTR uLength3$[rsp]
  0017c	e8 00 00 00 00	 call	 _byteswap_ushort
  00181	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00186	48 83 c1 12	 add	 rcx, 18
  0018a	0f b7 d0	 movzx	 edx, ax
  0018d	e8 00 00 00 00	 call	 store_hw_noswap

; 7268 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00192	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00196	e8 00 00 00 00	 call	 _byteswap_ulong
  0019b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a0	48 83 c1 14	 add	 rcx, 20
  001a4	8b d0		 mov	 edx, eax
  001a6	e8 00 00 00 00	 call	 store_f3_noswap

; 7269 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b0	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7270 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001be	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001c4	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7271 : 
; 7272 :     // Prepare MPC_PHre
; 7273 :     pMPC_PHre->locdata = PH_LOC_1;

  001c7	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001cc	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7274 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001cf	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001d3	e8 00 00 00 00	 call	 _byteswap_ulong
  001d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001dd	48 ff c1	 inc	 rcx
  001e0	8b d0		 mov	 edx, eax
  001e2	e8 00 00 00 00	 call	 store_f3_noswap

; 7275 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001e7	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001eb	e8 00 00 00 00	 call	 _byteswap_ulong
  001f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001f5	48 83 c1 04	 add	 rcx, 4
  001f9	8b d0		 mov	 edx, eax
  001fb	e8 00 00 00 00	 call	 store_fw_noswap

; 7276 : 
; 7277 :     // Prepare MPC_PIXre
; 7278 :     pMPC_PIXre->action = PIX_ADDRESS;

  00200	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00205	c6 00 11	 mov	 BYTE PTR [rax], 17

; 7279 :     pMPC_PIXre->askans = PIX_ASK;

  00208	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0020d	c6 40 01 80	 mov	 BYTE PTR [rax+1], 128	; 00000080H

; 7280 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00216	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7281 :     pMPC_PIXre->iptype = PIX_IPV4;

  0021a	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021f	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 7282 :     STORE_HW( pMPC_PIXre->idnum, ++pPTPBLK->uIdNum );

  00223	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00228	0f b7 80 82 03
	00 00		 movzx	 eax, WORD PTR [rax+898]
  0022f	66 ff c0	 inc	 ax
  00232	66 89 44 24 20	 mov	 WORD PTR tv183[rsp], ax
  00237	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0023c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  00241	66 89 88 82 03
	00 00		 mov	 WORD PTR [rax+898], cx
  00248	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  0024d	e8 00 00 00 00	 call	 _byteswap_ushort
  00252	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00257	48 83 c1 04	 add	 rcx, 4
  0025b	0f b7 d0	 movzx	 edx, ax
  0025e	e8 00 00 00 00	 call	 store_hw_noswap

; 7283 :     memcpy( pMPC_PIXre->ipaddr, &pPTPBLK->iaDriveIPAddr4, 4 );

  00263	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00268	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0026d	8b 89 d8 02 00
	00		 mov	 ecx, DWORD PTR [rcx+728]
  00273	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 7284 : 
; 7285 :     // Display various information, maybe
; 7286 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00276	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0027b	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0027e	83 e0 10	 and	 eax, 16
  00281	85 c0		 test	 eax, eax
  00283	74 15		 je	 SHORT $LN3@build_C108

; 7287 :     {
; 7288 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) My address IPv4" );

  00285	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172555
  0028c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00294	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7289 :     }
; 7290 : 
; 7291 :     return pPTPHDRre;

  0029a	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7292 : }   /* End function  build_C108_my_address_4() */

  0029f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002a3	c3		 ret	 0
build_C108_my_address_4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength3$ = 32
pMPC_RRHre$ = 40
pMPC_THre$ = 48
pMPC_PIXre$ = 56
uLength1$ = 64
uLength2$ = 68
pMPC_PHre$ = 72
pPTPHDRre$ = 80
pPTPBLK$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
pMPC_PIXwr$ = 136
uRCode$ = 144
build_C108_i_will_start_6 PROC

; 7144 : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7145 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00014	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001c	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00023	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7146 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 58	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7147 :     U32        uLength1;
; 7148 :     U32        uLength2;
; 7149 :     U32        uLength3;
; 7150 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7151 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7152 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7153 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7154 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7155 : 
; 7156 : 
; 7157 :     // Allocate a buffer in which the response will be build.
; 7158 :     // Note: the largest reply will be 88 bytes.
; 7159 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00035	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0003a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00042	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00047	48 89 44 24 50	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7160 :     if (!pPTPHDRre)

  0004c	48 83 7c 24 50
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00052	75 07		 jne	 SHORT $LN2@build_C108

; 7161 :         return NULL;

  00054	33 c0		 xor	 eax, eax
  00056	e9 2f 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7162 : 
; 7163 :     // Fix-up various lengths
; 7164 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  0005b	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7165 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00063	c7 44 24 44 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7166 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  0006b	8b 44 24 20	 mov	 eax, DWORD PTR uLength3$[rsp]
  0006f	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00073	03 c8		 add	 ecx, eax
  00075	8b c1		 mov	 eax, ecx
  00077	89 44 24 40	 mov	 DWORD PTR uLength1$[rsp], eax

; 7167 : 
; 7168 :     // Fix-up various pointers
; 7169 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00080	48 83 c0 10	 add	 rax, 16
  00084	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7170 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  0008e	48 83 c0 14	 add	 rax, 20
  00092	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7171 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0009c	48 83 c0 24	 add	 rax, 36			; 00000024H
  000a0	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7172 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  000a5	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000aa	48 83 c0 08	 add	 rax, 8
  000ae	48 89 44 24 38	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7173 : 
; 7174 :     // Prepare PTPHDRre
; 7175 :     pPTPHDRre->iDataLen = uLength1;

  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000b8	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000bc	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7176 : 
; 7177 :     // Prepare MPC_THre
; 7178 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000bf	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000c4	e8 00 00 00 00	 call	 _byteswap_ulong
  000c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000ce	8b d0		 mov	 edx, eax
  000d0	e8 00 00 00 00	 call	 store_fw_noswap

; 7179 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000d5	b9 14 00 00 00	 mov	 ecx, 20
  000da	e8 00 00 00 00	 call	 _byteswap_ulong
  000df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000e4	48 83 c1 08	 add	 rcx, 8
  000e8	8b d0		 mov	 edx, eax
  000ea	e8 00 00 00 00	 call	 store_fw_noswap

; 7180 :     STORE_FW( pMPC_THre->length, uLength1 );

  000ef	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000f3	e8 00 00 00 00	 call	 _byteswap_ulong
  000f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000fd	48 83 c1 0c	 add	 rcx, 12
  00101	8b d0		 mov	 edx, eax
  00103	e8 00 00 00 00	 call	 store_fw_noswap

; 7181 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00108	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  0010c	e8 00 00 00 00	 call	 _byteswap_ushort
  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00116	48 83 c1 10	 add	 rcx, 16
  0011a	0f b7 d0	 movzx	 edx, ax
  0011d	e8 00 00 00 00	 call	 store_hw_noswap

; 7182 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00122	66 b9 01 00	 mov	 cx, 1
  00126	e8 00 00 00 00	 call	 _byteswap_ushort
  0012b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00130	48 83 c1 12	 add	 rcx, 18
  00134	0f b7 d0	 movzx	 edx, ax
  00137	e8 00 00 00 00	 call	 store_hw_noswap

; 7183 : 
; 7184 :     // Prepare MPC_RRHre
; 7185 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  0013c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00141	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7186 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  00145	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0014a	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7187 :     STORE_HW( pMPC_RRHre->numph, 1 );

  0014e	66 b9 01 00	 mov	 cx, 1
  00152	e8 00 00 00 00	 call	 _byteswap_ushort
  00157	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0015c	48 83 c1 06	 add	 rcx, 6
  00160	0f b7 d0	 movzx	 edx, ax
  00163	e8 00 00 00 00	 call	 store_hw_noswap

; 7188 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00168	66 b9 24 00	 mov	 cx, 36			; 00000024H
  0016c	e8 00 00 00 00	 call	 _byteswap_ushort
  00171	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00176	48 83 c1 10	 add	 rcx, 16
  0017a	0f b7 d0	 movzx	 edx, ax
  0017d	e8 00 00 00 00	 call	 store_hw_noswap

; 7189 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00182	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00187	e8 00 00 00 00	 call	 _byteswap_ushort
  0018c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00191	48 83 c1 12	 add	 rcx, 18
  00195	0f b7 d0	 movzx	 edx, ax
  00198	e8 00 00 00 00	 call	 store_hw_noswap

; 7190 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  0019d	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001a1	e8 00 00 00 00	 call	 _byteswap_ulong
  001a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001ab	48 83 c1 14	 add	 rcx, 20
  001af	8b d0		 mov	 edx, eax
  001b1	e8 00 00 00 00	 call	 store_f3_noswap

; 7191 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001bb	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7192 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001bf	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001c4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001c9	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001cf	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7193 : 
; 7194 :     // Prepare MPC_PHre
; 7195 :     pMPC_PHre->locdata = PH_LOC_1;

  001d2	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001d7	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7196 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001da	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001de	e8 00 00 00 00	 call	 _byteswap_ulong
  001e3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001e8	48 ff c1	 inc	 rcx
  001eb	8b d0		 mov	 edx, eax
  001ed	e8 00 00 00 00	 call	 store_f3_noswap

; 7197 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001f2	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001f6	e8 00 00 00 00	 call	 _byteswap_ulong
  001fb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00200	48 83 c1 04	 add	 rcx, 4
  00204	8b d0		 mov	 edx, eax
  00206	e8 00 00 00 00	 call	 store_fw_noswap

; 7198 : 
; 7199 :     // Prepare MPC_PIXre
; 7200 :     pMPC_PIXre->action = PIX_START;

  0020b	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00210	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7201 :     pMPC_PIXre->askans = PIX_ANSWER;

  00213	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00218	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 7202 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  0021c	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00221	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7203 :     pMPC_PIXre->iptype = PIX_IPV6;

  00225	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0022a	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 7204 :     memcpy( pMPC_PIXre->idnum, pMPC_PIXwr->idnum, sizeof(pMPC_PIXre->idnum) );

  0022e	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00233	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  0023b	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  0023f	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 7205 :     STORE_HW( pMPC_PIXre->rcode, uRCode );

  00243	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR uRCode$[rsp]
  0024b	e8 00 00 00 00	 call	 _byteswap_ushort
  00250	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00255	48 83 c1 06	 add	 rcx, 6
  00259	0f b7 d0	 movzx	 edx, ax
  0025c	e8 00 00 00 00	 call	 store_hw_noswap

; 7206 : 
; 7207 :     // Display various information, maybe
; 7208 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00261	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00266	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00269	83 e0 10	 and	 eax, 16
  0026c	85 c0		 test	 eax, eax
  0026e	74 15		 je	 SHORT $LN3@build_C108

; 7209 :     {
; 7210 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) I will start IPv6" );

  00270	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172528
  00277	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7211 :     }
; 7212 : 
; 7213 :     return pPTPHDRre;

  00285	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7214 : }   /* End function  build_C108_i_will_start_6() */

  0028a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0028e	c3		 ret	 0
build_C108_i_will_start_6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength3$ = 32
pMPC_RRHre$ = 40
pMPC_THre$ = 48
pMPC_PIXre$ = 56
uLength1$ = 64
uLength2$ = 68
pMPC_PHre$ = 72
pPTPHDRre$ = 80
pPTPBLK$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
pMPC_PIXwr$ = 136
uRCode$ = 144
build_C108_i_will_start_4 PROC

; 7067 : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7068 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00014	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001c	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00023	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 7069 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 58	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 7070 :     U32        uLength1;
; 7071 :     U32        uLength2;
; 7072 :     U32        uLength3;
; 7073 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 7074 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 7075 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 7076 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7077 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7078 : 
; 7079 : 
; 7080 :     // Allocate a buffer in which the message will be build.
; 7081 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00035	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0003a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00042	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00047	48 89 44 24 50	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7082 :     if (!pPTPHDRre)

  0004c	48 83 7c 24 50
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00052	75 07		 jne	 SHORT $LN2@build_C108

; 7083 :         return NULL;

  00054	33 c0		 xor	 eax, eax
  00056	e9 2f 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7084 : 
; 7085 :     // Fix-up various lengths
; 7086 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  0005b	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7087 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00063	c7 44 24 44 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7088 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  0006b	8b 44 24 20	 mov	 eax, DWORD PTR uLength3$[rsp]
  0006f	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00073	03 c8		 add	 ecx, eax
  00075	8b c1		 mov	 eax, ecx
  00077	89 44 24 40	 mov	 DWORD PTR uLength1$[rsp], eax

; 7089 : 
; 7090 :     // Fix-up various pointers
; 7091 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00080	48 83 c0 10	 add	 rax, 16
  00084	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7092 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  0008e	48 83 c0 14	 add	 rax, 20
  00092	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7093 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0009c	48 83 c0 24	 add	 rax, 36			; 00000024H
  000a0	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7094 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  000a5	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000aa	48 83 c0 08	 add	 rax, 8
  000ae	48 89 44 24 38	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7095 : 
; 7096 :     // Prepare PTPHDRre
; 7097 :     pPTPHDRre->iDataLen = uLength1;

  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000b8	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000bc	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7098 : 
; 7099 :     // Prepare MPC_THre
; 7100 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000bf	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000c4	e8 00 00 00 00	 call	 _byteswap_ulong
  000c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000ce	8b d0		 mov	 edx, eax
  000d0	e8 00 00 00 00	 call	 store_fw_noswap

; 7101 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000d5	b9 14 00 00 00	 mov	 ecx, 20
  000da	e8 00 00 00 00	 call	 _byteswap_ulong
  000df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000e4	48 83 c1 08	 add	 rcx, 8
  000e8	8b d0		 mov	 edx, eax
  000ea	e8 00 00 00 00	 call	 store_fw_noswap

; 7102 :     STORE_FW( pMPC_THre->length, uLength1 );

  000ef	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000f3	e8 00 00 00 00	 call	 _byteswap_ulong
  000f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000fd	48 83 c1 0c	 add	 rcx, 12
  00101	8b d0		 mov	 edx, eax
  00103	e8 00 00 00 00	 call	 store_fw_noswap

; 7103 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00108	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  0010c	e8 00 00 00 00	 call	 _byteswap_ushort
  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00116	48 83 c1 10	 add	 rcx, 16
  0011a	0f b7 d0	 movzx	 edx, ax
  0011d	e8 00 00 00 00	 call	 store_hw_noswap

; 7104 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00122	66 b9 01 00	 mov	 cx, 1
  00126	e8 00 00 00 00	 call	 _byteswap_ushort
  0012b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00130	48 83 c1 12	 add	 rcx, 18
  00134	0f b7 d0	 movzx	 edx, ax
  00137	e8 00 00 00 00	 call	 store_hw_noswap

; 7105 : 
; 7106 :     // Prepare MPC_RRHre
; 7107 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  0013c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00141	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7108 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  00145	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0014a	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7109 :     STORE_HW( pMPC_RRHre->numph, 1 );

  0014e	66 b9 01 00	 mov	 cx, 1
  00152	e8 00 00 00 00	 call	 _byteswap_ushort
  00157	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0015c	48 83 c1 06	 add	 rcx, 6
  00160	0f b7 d0	 movzx	 edx, ax
  00163	e8 00 00 00 00	 call	 store_hw_noswap

; 7110 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00168	66 b9 24 00	 mov	 cx, 36			; 00000024H
  0016c	e8 00 00 00 00	 call	 _byteswap_ushort
  00171	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00176	48 83 c1 10	 add	 rcx, 16
  0017a	0f b7 d0	 movzx	 edx, ax
  0017d	e8 00 00 00 00	 call	 store_hw_noswap

; 7111 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00182	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00187	e8 00 00 00 00	 call	 _byteswap_ushort
  0018c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00191	48 83 c1 12	 add	 rcx, 18
  00195	0f b7 d0	 movzx	 edx, ax
  00198	e8 00 00 00 00	 call	 store_hw_noswap

; 7112 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  0019d	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001a1	e8 00 00 00 00	 call	 _byteswap_ulong
  001a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001ab	48 83 c1 14	 add	 rcx, 20
  001af	8b d0		 mov	 edx, eax
  001b1	e8 00 00 00 00	 call	 store_f3_noswap

; 7113 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001bb	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7114 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001bf	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001c4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001c9	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001cf	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7115 : 
; 7116 :     // Prepare MPC_PHre
; 7117 :     pMPC_PHre->locdata = PH_LOC_1;

  001d2	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001d7	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7118 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001da	8b 4c 24 20	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001de	e8 00 00 00 00	 call	 _byteswap_ulong
  001e3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001e8	48 ff c1	 inc	 rcx
  001eb	8b d0		 mov	 edx, eax
  001ed	e8 00 00 00 00	 call	 store_f3_noswap

; 7119 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001f2	8b 4c 24 44	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001f6	e8 00 00 00 00	 call	 _byteswap_ulong
  001fb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00200	48 83 c1 04	 add	 rcx, 4
  00204	8b d0		 mov	 edx, eax
  00206	e8 00 00 00 00	 call	 store_fw_noswap

; 7120 : 
; 7121 :     // Prepare MPC_PIXre
; 7122 :     pMPC_PIXre->action = PIX_START;

  0020b	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00210	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7123 :     pMPC_PIXre->askans = PIX_ANSWER;

  00213	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00218	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 7124 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  0021c	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00221	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7125 :     pMPC_PIXre->iptype = PIX_IPV4;

  00225	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0022a	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 7126 :     memcpy( pMPC_PIXre->idnum, pMPC_PIXwr->idnum, sizeof(pMPC_PIXre->idnum) );

  0022e	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00233	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  0023b	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  0023f	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 7127 :     STORE_HW( pMPC_PIXre->rcode, uRCode );

  00243	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR uRCode$[rsp]
  0024b	e8 00 00 00 00	 call	 _byteswap_ushort
  00250	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00255	48 83 c1 06	 add	 rcx, 6
  00259	0f b7 d0	 movzx	 edx, ax
  0025c	e8 00 00 00 00	 call	 store_hw_noswap

; 7128 : 
; 7129 :     // Display various information, maybe
; 7130 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00261	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00266	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00269	83 e0 10	 and	 eax, 16
  0026c	85 c0		 test	 eax, eax
  0026e	74 15		 je	 SHORT $LN3@build_C108

; 7131 :     {
; 7132 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) I will start IPv4" );

  00270	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172497
  00277	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7133 :     }
; 7134 : 
; 7135 :     return pPTPHDRre;

  00285	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7136 : }   /* End function  build_C108_i_will_start_4() */

  0028a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0028e	c3		 ret	 0
build_C108_i_will_start_4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
tv183 = 32
uLength3$ = 36
pMPC_RRHre$ = 40
pMPC_THre$ = 48
uLength1$ = 56
uLength2$ = 60
pMPC_PIXre$ = 64
pMPC_PHre$ = 72
pPTPBLK$ = 80
pPTPHDRre$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
build_C108_will_you_start_6 PROC

; 6990 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 6991 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00011	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00018	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 6992 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 50	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 6993 :     U32        uLength1;
; 6994 :     U32        uLength2;
; 6995 :     U32        uLength3;
; 6996 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 6997 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 6998 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 6999 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 7000 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 7001 : 
; 7002 : 
; 7003 :     // Allocate a buffer in which the response will be build.
; 7004 :     // Note: the largest reply will be 88 bytes.
; 7005 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  0002a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0002f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00037	e8 00 00 00 00	 call	 alloc_ptp_buffer
  0003c	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 7006 :     if (!pPTPHDRre)

  00041	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00047	75 07		 jne	 SHORT $LN2@build_C108

; 7007 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 3c 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 7008 : 
; 7009 :     // Fix-up various lengths
; 7010 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  00050	c7 44 24 24 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 7011 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00058	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 7012 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  00060	8b 44 24 24	 mov	 eax, DWORD PTR uLength3$[rsp]
  00064	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 38	 mov	 DWORD PTR uLength1$[rsp], eax

; 7013 : 
; 7014 :     // Fix-up various pointers
; 7015 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00070	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00075	48 83 c0 10	 add	 rax, 16
  00079	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 7016 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00083	48 83 c0 14	 add	 rax, 20
  00087	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 7017 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00091	48 83 c0 24	 add	 rax, 36			; 00000024H
  00095	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 7018 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0009f	48 83 c0 08	 add	 rax, 8
  000a3	48 89 44 24 40	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 7019 : 
; 7020 :     // Prepare PTPHDRre
; 7021 :     pPTPHDRre->iDataLen = uLength1;

  000a8	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000ad	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000b1	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 7022 : 
; 7023 :     // Prepare MPC_THre
; 7024 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000b4	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000b9	e8 00 00 00 00	 call	 _byteswap_ulong
  000be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000c3	8b d0		 mov	 edx, eax
  000c5	e8 00 00 00 00	 call	 store_fw_noswap

; 7025 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000ca	b9 14 00 00 00	 mov	 ecx, 20
  000cf	e8 00 00 00 00	 call	 _byteswap_ulong
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000d9	48 83 c1 08	 add	 rcx, 8
  000dd	8b d0		 mov	 edx, eax
  000df	e8 00 00 00 00	 call	 store_fw_noswap

; 7026 :     STORE_FW( pMPC_THre->length, uLength1 );

  000e4	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000f2	48 83 c1 0c	 add	 rcx, 12
  000f6	8b d0		 mov	 edx, eax
  000f8	e8 00 00 00 00	 call	 store_fw_noswap

; 7027 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  000fd	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00101	e8 00 00 00 00	 call	 _byteswap_ushort
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0010b	48 83 c1 10	 add	 rcx, 16
  0010f	0f b7 d0	 movzx	 edx, ax
  00112	e8 00 00 00 00	 call	 store_hw_noswap

; 7028 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00117	66 b9 01 00	 mov	 cx, 1
  0011b	e8 00 00 00 00	 call	 _byteswap_ushort
  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00125	48 83 c1 12	 add	 rcx, 18
  00129	0f b7 d0	 movzx	 edx, ax
  0012c	e8 00 00 00 00	 call	 store_hw_noswap

; 7029 : 
; 7030 :     // Prepare MPC_RRHre
; 7031 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00136	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 7032 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0013f	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 7033 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00143	66 b9 01 00	 mov	 cx, 1
  00147	e8 00 00 00 00	 call	 _byteswap_ushort
  0014c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00151	48 83 c1 06	 add	 rcx, 6
  00155	0f b7 d0	 movzx	 edx, ax
  00158	e8 00 00 00 00	 call	 store_hw_noswap

; 7034 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  0015d	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00161	e8 00 00 00 00	 call	 _byteswap_ushort
  00166	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0016b	48 83 c1 10	 add	 rcx, 16
  0016f	0f b7 d0	 movzx	 edx, ax
  00172	e8 00 00 00 00	 call	 store_hw_noswap

; 7035 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00177	0f b7 4c 24 24	 movzx	 ecx, WORD PTR uLength3$[rsp]
  0017c	e8 00 00 00 00	 call	 _byteswap_ushort
  00181	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00186	48 83 c1 12	 add	 rcx, 18
  0018a	0f b7 d0	 movzx	 edx, ax
  0018d	e8 00 00 00 00	 call	 store_hw_noswap

; 7036 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00192	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00196	e8 00 00 00 00	 call	 _byteswap_ulong
  0019b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a0	48 83 c1 14	 add	 rcx, 20
  001a4	8b d0		 mov	 edx, eax
  001a6	e8 00 00 00 00	 call	 store_f3_noswap

; 7037 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b0	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 7038 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001be	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001c4	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 7039 : 
; 7040 :     // Prepare MPC_PHre
; 7041 :     pMPC_PHre->locdata = PH_LOC_1;

  001c7	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001cc	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7042 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001cf	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001d3	e8 00 00 00 00	 call	 _byteswap_ulong
  001d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001dd	48 ff c1	 inc	 rcx
  001e0	8b d0		 mov	 edx, eax
  001e2	e8 00 00 00 00	 call	 store_f3_noswap

; 7043 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001e7	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001eb	e8 00 00 00 00	 call	 _byteswap_ulong
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001f5	48 83 c1 04	 add	 rcx, 4
  001f9	8b d0		 mov	 edx, eax
  001fb	e8 00 00 00 00	 call	 store_fw_noswap

; 7044 : 
; 7045 :     // Prepare MPC_PIXre
; 7046 :     pMPC_PIXre->action = PIX_START;

  00200	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00205	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7047 :     pMPC_PIXre->askans = PIX_ASK;

  00208	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0020d	c6 40 01 80	 mov	 BYTE PTR [rax+1], 128	; 00000080H

; 7048 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  00211	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00216	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 7049 :     pMPC_PIXre->iptype = PIX_IPV6;

  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021f	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 7050 :     STORE_HW( pMPC_PIXre->idnum, ++pPTPBLK->uIdNum );

  00223	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00228	0f b7 80 82 03
	00 00		 movzx	 eax, WORD PTR [rax+898]
  0022f	66 ff c0	 inc	 ax
  00232	66 89 44 24 20	 mov	 WORD PTR tv183[rsp], ax
  00237	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0023c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  00241	66 89 88 82 03
	00 00		 mov	 WORD PTR [rax+898], cx
  00248	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  0024d	e8 00 00 00 00	 call	 _byteswap_ushort
  00252	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00257	48 83 c1 04	 add	 rcx, 4
  0025b	0f b7 d0	 movzx	 edx, ax
  0025e	e8 00 00 00 00	 call	 store_hw_noswap

; 7051 : 
; 7052 :     // Display various information, maybe
; 7053 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00263	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00268	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0026b	83 e0 10	 and	 eax, 16
  0026e	85 c0		 test	 eax, eax
  00270	74 15		 je	 SHORT $LN3@build_C108

; 7054 :     {
; 7055 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) Will you start IPv6?" );

  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172466
  00279	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 7056 :     }
; 7057 : 
; 7058 :     return pPTPHDRre;

  00287	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 7059 : }   /* End function  build_C108_will_you_start_6() */

  0028c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00290	c3		 ret	 0
build_C108_will_you_start_6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
tv183 = 32
uLength3$ = 36
pMPC_RRHre$ = 40
pMPC_THre$ = 48
uLength1$ = 56
uLength2$ = 60
pMPC_PIXre$ = 64
pMPC_PHre$ = 72
pPTPBLK$ = 80
pPTPHDRre$ = 88
pPTPATH$ = 96
pDEVBLK$ = 128
build_C108_will_you_start_4 PROC

; 6913 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 6914 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00011	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00018	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 6915 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 50	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 6916 :     U32        uLength1;
; 6917 :     U32        uLength2;
; 6918 :     U32        uLength3;
; 6919 :     PTPHDR*    pPTPHDRre;     // PTPHDR to be read
; 6920 :     MPC_TH*    pMPC_THre;     // MPC_TH follows PTPHDR
; 6921 :     MPC_RRH*   pMPC_RRHre;    // MPC_RRH follows MPC_TH
; 6922 :     MPC_PH*    pMPC_PHre;     // MPC_PH follows MPC_RRH
; 6923 :     MPC_PIX*   pMPC_PIXre;    // MPC_PIX follows MPC_PH
; 6924 : 
; 6925 : 
; 6926 :     // Allocate a buffer in which the response will be build.
; 6927 :     // Note: the largest reply will be 88 bytes.
; 6928 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  0002a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0002f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00037	e8 00 00 00 00	 call	 alloc_ptp_buffer
  0003c	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 6929 :     if (!pPTPHDRre)

  00041	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00047	75 07		 jne	 SHORT $LN2@build_C108

; 6930 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 3c 02 00 00	 jmp	 $LN1@build_C108
$LN2@build_C108:

; 6931 : 
; 6932 :     // Fix-up various lengths
; 6933 :     uLength3 = SIZE_PIX;                     // the MPC_PIX

  00050	c7 44 24 24 18
	00 00 00	 mov	 DWORD PTR uLength3$[rsp], 24

; 6934 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00058	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 6935 :     uLength1 = uLength2 + uLength3;          // the MPC_TH/MPC_RRH/MPC_PH and data

  00060	8b 44 24 24	 mov	 eax, DWORD PTR uLength3$[rsp]
  00064	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 38	 mov	 DWORD PTR uLength1$[rsp], eax

; 6936 : 
; 6937 :     // Fix-up various pointers
; 6938 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00070	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00075	48 83 c0 10	 add	 rax, 16
  00079	48 89 44 24 30	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 6939 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00083	48 83 c0 14	 add	 rax, 20
  00087	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 6940 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00091	48 83 c0 24	 add	 rax, 36			; 00000024H
  00095	48 89 44 24 48	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 6941 :     pMPC_PIXre = (MPC_PIX*)((BYTE*)pMPC_PHre + SIZE_PH);

  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0009f	48 83 c0 08	 add	 rax, 8
  000a3	48 89 44 24 40	 mov	 QWORD PTR pMPC_PIXre$[rsp], rax

; 6942 : 
; 6943 :     // Prepare PTPHDRre
; 6944 :     pPTPHDRre->iDataLen = uLength1;

  000a8	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000ad	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000b1	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 6945 : 
; 6946 :     // Prepare MPC_THre
; 6947 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000b4	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000b9	e8 00 00 00 00	 call	 _byteswap_ulong
  000be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000c3	8b d0		 mov	 edx, eax
  000c5	e8 00 00 00 00	 call	 store_fw_noswap

; 6948 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000ca	b9 14 00 00 00	 mov	 ecx, 20
  000cf	e8 00 00 00 00	 call	 _byteswap_ulong
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000d9	48 83 c1 08	 add	 rcx, 8
  000dd	8b d0		 mov	 edx, eax
  000df	e8 00 00 00 00	 call	 store_fw_noswap

; 6949 :     STORE_FW( pMPC_THre->length, uLength1 );

  000e4	8b 4c 24 38	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000f2	48 83 c1 0c	 add	 rcx, 12
  000f6	8b d0		 mov	 edx, eax
  000f8	e8 00 00 00 00	 call	 store_fw_noswap

; 6950 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  000fd	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00101	e8 00 00 00 00	 call	 _byteswap_ushort
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0010b	48 83 c1 10	 add	 rcx, 16
  0010f	0f b7 d0	 movzx	 edx, ax
  00112	e8 00 00 00 00	 call	 store_hw_noswap

; 6951 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00117	66 b9 01 00	 mov	 cx, 1
  0011b	e8 00 00 00 00	 call	 _byteswap_ushort
  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00125	48 83 c1 12	 add	 rcx, 18
  00129	0f b7 d0	 movzx	 edx, ax
  0012c	e8 00 00 00 00	 call	 store_hw_noswap

; 6952 : 
; 6953 :     // Prepare MPC_RRHre
; 6954 :     pMPC_RRHre->type = RRH_TYPE_IPA;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00136	c6 40 04 c1	 mov	 BYTE PTR [rax+4], 193	; 000000c1H

; 6955 :     pMPC_RRHre->proto = PROTOCOL_LAYER2;

  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0013f	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 6956 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00143	66 b9 01 00	 mov	 cx, 1
  00147	e8 00 00 00 00	 call	 _byteswap_ushort
  0014c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00151	48 83 c1 06	 add	 rcx, 6
  00155	0f b7 d0	 movzx	 edx, ax
  00158	e8 00 00 00 00	 call	 store_hw_noswap

; 6957 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  0015d	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00161	e8 00 00 00 00	 call	 _byteswap_ushort
  00166	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0016b	48 83 c1 10	 add	 rcx, 16
  0016f	0f b7 d0	 movzx	 edx, ax
  00172	e8 00 00 00 00	 call	 store_hw_noswap

; 6958 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00177	0f b7 4c 24 24	 movzx	 ecx, WORD PTR uLength3$[rsp]
  0017c	e8 00 00 00 00	 call	 _byteswap_ushort
  00181	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00186	48 83 c1 12	 add	 rcx, 18
  0018a	0f b7 d0	 movzx	 edx, ax
  0018d	e8 00 00 00 00	 call	 store_hw_noswap

; 6959 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00192	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00196	e8 00 00 00 00	 call	 _byteswap_ulong
  0019b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001a0	48 83 c1 14	 add	 rcx, 20
  001a4	8b d0		 mov	 edx, eax
  001a6	e8 00 00 00 00	 call	 store_f3_noswap

; 6960 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b0	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 6961 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001be	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  001c4	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 6962 : 
; 6963 :     // Prepare MPC_PHre
; 6964 :     pMPC_PHre->locdata = PH_LOC_1;

  001c7	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  001cc	c6 00 01	 mov	 BYTE PTR [rax], 1

; 6965 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  001cf	8b 4c 24 24	 mov	 ecx, DWORD PTR uLength3$[rsp]
  001d3	e8 00 00 00 00	 call	 _byteswap_ulong
  001d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001dd	48 ff c1	 inc	 rcx
  001e0	8b d0		 mov	 edx, eax
  001e2	e8 00 00 00 00	 call	 store_f3_noswap

; 6966 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  001e7	8b 4c 24 3c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  001eb	e8 00 00 00 00	 call	 _byteswap_ulong
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  001f5	48 83 c1 04	 add	 rcx, 4
  001f9	8b d0		 mov	 edx, eax
  001fb	e8 00 00 00 00	 call	 store_fw_noswap

; 6967 : 
; 6968 :     // Prepare MPC_PIXre
; 6969 :     pMPC_PIXre->action = PIX_START;

  00200	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00205	c6 00 01	 mov	 BYTE PTR [rax], 1

; 6970 :     pMPC_PIXre->askans = PIX_ASK;

  00208	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0020d	c6 40 01 80	 mov	 BYTE PTR [rax+1], 128	; 00000080H

; 6971 :     pMPC_PIXre->numaddr = PIX_ONEADDR;

  00211	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  00216	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 6972 :     pMPC_PIXre->iptype = PIX_IPV4;

  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PIXre$[rsp]
  0021f	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 6973 :     STORE_HW( pMPC_PIXre->idnum, ++pPTPBLK->uIdNum );

  00223	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00228	0f b7 80 82 03
	00 00		 movzx	 eax, WORD PTR [rax+898]
  0022f	66 ff c0	 inc	 ax
  00232	66 89 44 24 20	 mov	 WORD PTR tv183[rsp], ax
  00237	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0023c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  00241	66 89 88 82 03
	00 00		 mov	 WORD PTR [rax+898], cx
  00248	0f b7 4c 24 20	 movzx	 ecx, WORD PTR tv183[rsp]
  0024d	e8 00 00 00 00	 call	 _byteswap_ushort
  00252	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_PIXre$[rsp]
  00257	48 83 c1 04	 add	 rcx, 4
  0025b	0f b7 d0	 movzx	 edx, ax
  0025e	e8 00 00 00 00	 call	 store_hw_noswap

; 6974 : 
; 6975 :     // Display various information, maybe
; 6976 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00263	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00268	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0026b	83 e0 10	 and	 eax, 16
  0026e	85 c0		 test	 eax, eax
  00270	74 15		 je	 SHORT $LN3@build_C108

; 6977 :     {
; 6978 :         mpc_display_description( pDEVBLK, "Out RRH 0xC108 (UlpComm) Will you start IPv4?" );

  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172439
  00279	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_C108:

; 6979 :     }
; 6980 : 
; 6981 :     return pPTPHDRre;

  00287	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_C108:

; 6982 : }   /* End function  build_C108_will_you_start_4() */

  0028c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00290	c3		 ret	 0
build_C108_will_you_start_4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPBLK$ = 80
pPTPHDRr1$ = 88
pMPC_PIXwr$ = 96
iWhat$ = 104
pPTPATHre$ = 112
pPTPHDRr2$ = 120
fLL$ = 128
tv176 = 132
uOffPH$ = 136
tv387 = 140
tv391 = 144
tv462 = 148
tv466 = 152
addr4$ = 156
tv543 = 160
tv547 = 164
tv578 = 168
tv582 = 172
tv666 = 176
tv670 = 180
tv775 = 184
tv779 = 188
tv846 = 192
tv850 = 196
tv877 = 200
tv881 = 204
tv918 = 208
tv922 = 212
tv971 = 216
tv975 = 220
tv1007 = 224
tv1011 = 228
tv1131 = 232
tv1135 = 236
tv1208 = 240
tv1212 = 244
tv1238 = 248
tv1242 = 252
tv1260 = 256
tv1264 = 260
uOffData$ = 264
tv315 = 268
tv319 = 272
tv356 = 276
tv360 = 280
pPTPHDRr3$ = 288
pPTPATH$ = 296
pMPC_PHwr$ = 304
tv312 = 312
tv353 = 320
tv384 = 328
tv575 = 336
tv843 = 344
tv874 = 352
tv915 = 360
tv968 = 368
tv1004 = 376
tv1128 = 384
tv1205 = 392
tv1235 = 400
addr6$ = 408
cIPaddr$ = 424
__$ArrayPad$ = 472
pDEVBLK$ = 512
pMPC_THwr$ = 520
pMPC_RRHwr$ = 528
write_rrh_C108 PROC

; 6016 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6017 :     PTPATH*    pPTPATH   = pDEVBLK->dev_data;

  0002a	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00032	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00039	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 6018 :     PTPBLK*    pPTPBLK   = pPTPATH->pPTPBLK;

  00041	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 89 44 24 50	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 6019 :     PTPATH*    pPTPATHre = pPTPBLK->pPTPATHRead;

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 89 44 24 70	 mov	 QWORD PTR pPTPATHre$[rsp], rax

; 6020 :     MPC_PH*    pMPC_PHwr;
; 6021 :     MPC_PIX*   pMPC_PIXwr;
; 6022 :     U32        uOffData;
; 6023 : //  U32        uLenData;
; 6024 :     U16        uOffPH;
; 6025 : #if defined(ENABLE_IPV6)
; 6026 :     u_int      fLL;
; 6027 :     struct in6_addr addr6;
; 6028 : #endif /* defined(ENABLE_IPV6) */
; 6029 :     struct in_addr  addr4;
; 6030 :     char       cIPaddr[48];
; 6031 :     PTPHDR*    pPTPHDRr1;
; 6032 :     PTPHDR*    pPTPHDRr2;
; 6033 : #if defined(ENABLE_IPV6)
; 6034 :     PTPHDR*    pPTPHDRr3;
; 6035 : #endif /* defined(ENABLE_IPV6) */
; 6036 :     int        iWhat;
; 6037 : #define UNKNOWN_PIX          0
; 6038 : #define WILL_YOU_START_IPV4  1
; 6039 : #define WILL_YOU_START_IPV6  2
; 6040 : #define I_WILL_START_IPV4    3
; 6041 : #define I_WILL_START_IPV6    4
; 6042 : #define MY_ADDRESS_IPV4      5
; 6043 : #define MY_ADDRESS_IPV6      6
; 6044 : #define YOUR_ADDRESS_IPV4    7
; 6045 : #define YOUR_ADDRESS_IPV6    8
; 6046 : #define WILL_YOU_STOP_IPV4   9
; 6047 : #define WILL_YOU_STOP_IPV6   10
; 6048 : #define I_WILL_STOP_IPV4     11
; 6049 : #define I_WILL_STOP_IPV6     12
; 6050 : 
; 6051 : 
; 6052 :     // Point to the MPC_PH.
; 6053 :     FETCH_HW( uOffPH, pMPC_RRHwr->offph );

  0005e	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR pMPC_RRHwr$[rsp]
  00066	48 83 c0 10	 add	 rax, 16
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00072	0f b7 c8	 movzx	 ecx, ax
  00075	e8 00 00 00 00	 call	 _byteswap_ushort
  0007a	66 89 84 24 88
	00 00 00	 mov	 WORD PTR uOffPH$[rsp], ax

; 6054 :     pMPC_PHwr = (MPC_PH*)((BYTE*)pMPC_RRHwr + uOffPH);

  00082	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0008a	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  00092	48 03 c8	 add	 rcx, rax
  00095	48 8b c1	 mov	 rax, rcx
  00098	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR pMPC_PHwr$[rsp], rax

; 6055 : 
; 6056 :     // Get the length of and point to the data referenced by the
; 6057 :     // MPC_PH. The data is a MPC_PIX.
; 6058 : //  FETCH_F3( uLenData, pMPC_PH->lendata );
; 6059 :     FETCH_FW( uOffData, pMPC_PHwr->offdata );

  000a0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pMPC_PHwr$[rsp]
  000a8	48 83 c0 04	 add	 rax, 4
  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 fetch_fw_noswap
  000b4	8b c8		 mov	 ecx, eax
  000b6	e8 00 00 00 00	 call	 _byteswap_ulong
  000bb	89 84 24 08 01
	00 00		 mov	 DWORD PTR uOffData$[rsp], eax

; 6060 :     pMPC_PIXwr = (MPC_PIX*)((BYTE*)pMPC_THwr + uOffData);

  000c2	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR uOffData$[rsp]
  000c9	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR pMPC_THwr$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 60	 mov	 QWORD PTR pMPC_PIXwr$[rsp], rax

; 6061 : 
; 6062 :     // Decide what the PIX contains.
; 6063 :     iWhat = UNKNOWN_PIX;

  000dc	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 0

; 6064 :     if (pMPC_PIXwr->action == PIX_START)

  000e4	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  000e9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ec	83 f8 01	 cmp	 eax, 1
  000ef	0f 85 81 00 00
	00		 jne	 $LN10@write_rrh_

; 6065 :     {
; 6066 :         if (pMPC_PIXwr->askans == PIX_ASK)

  000f5	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  000fa	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000fe	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00103	75 30		 jne	 SHORT $LN12@write_rrh_

; 6067 :         {
; 6068 :             if (pMPC_PIXwr->iptype == PIX_IPV4)

  00105	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  0010a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0010e	83 f8 04	 cmp	 eax, 4
  00111	75 0a		 jne	 SHORT $LN14@write_rrh_

; 6069 :                 iWhat = WILL_YOU_START_IPV4;

  00113	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 1
  0011b	eb 16		 jmp	 SHORT $LN15@write_rrh_
$LN14@write_rrh_:

; 6070 :             else if (pMPC_PIXwr->iptype == PIX_IPV6)

  0011d	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00122	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00126	83 f8 06	 cmp	 eax, 6
  00129	75 08		 jne	 SHORT $LN16@write_rrh_

; 6071 :                 iWhat = WILL_YOU_START_IPV6;

  0012b	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 2
$LN16@write_rrh_:
$LN15@write_rrh_:

; 6072 :         }

  00133	eb 3c		 jmp	 SHORT $LN13@write_rrh_
$LN12@write_rrh_:

; 6073 :         else if (pMPC_PIXwr->askans == PIX_ANSWER)

  00135	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  0013a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0013e	83 f8 01	 cmp	 eax, 1
  00141	75 2e		 jne	 SHORT $LN17@write_rrh_

; 6074 :         {
; 6075 :             if (pMPC_PIXwr->iptype == PIX_IPV4)

  00143	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00148	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0014c	83 f8 04	 cmp	 eax, 4
  0014f	75 0a		 jne	 SHORT $LN18@write_rrh_

; 6076 :                 iWhat = I_WILL_START_IPV4;

  00151	c7 44 24 68 03
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 3
  00159	eb 16		 jmp	 SHORT $LN19@write_rrh_
$LN18@write_rrh_:

; 6077 :             else if (pMPC_PIXwr->iptype == PIX_IPV6)

  0015b	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00160	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00164	83 f8 06	 cmp	 eax, 6
  00167	75 08		 jne	 SHORT $LN20@write_rrh_

; 6078 :                 iWhat = I_WILL_START_IPV6;

  00169	c7 44 24 68 04
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 4
$LN20@write_rrh_:
$LN19@write_rrh_:
$LN17@write_rrh_:
$LN13@write_rrh_:

; 6079 :         }
; 6080 :     }

  00171	e9 15 01 00 00	 jmp	 $LN11@write_rrh_
$LN10@write_rrh_:

; 6081 :     else if (pMPC_PIXwr->action == PIX_ADDRESS)

  00176	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  0017b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0017e	83 f8 11	 cmp	 eax, 17
  00181	75 7f		 jne	 SHORT $LN21@write_rrh_

; 6082 :     {
; 6083 :         if (pMPC_PIXwr->askans == PIX_ASK)

  00183	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00188	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0018c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00191	75 2e		 jne	 SHORT $LN23@write_rrh_

; 6084 :         {
; 6085 :             if (pMPC_PIXwr->iptype == PIX_IPV4)

  00193	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00198	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0019c	83 f8 04	 cmp	 eax, 4
  0019f	75 0a		 jne	 SHORT $LN24@write_rrh_

; 6086 :                 iWhat = MY_ADDRESS_IPV4;

  001a1	c7 44 24 68 05
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 5
  001a9	eb 16		 jmp	 SHORT $LN25@write_rrh_
$LN24@write_rrh_:

; 6087 :             else if (pMPC_PIXwr->iptype == PIX_IPV6)

  001ab	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  001b0	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001b4	83 f8 06	 cmp	 eax, 6
  001b7	75 08		 jne	 SHORT $LN26@write_rrh_

; 6088 :                 iWhat = MY_ADDRESS_IPV6;

  001b9	c7 44 24 68 06
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 6
$LN26@write_rrh_:
$LN25@write_rrh_:
$LN23@write_rrh_:

; 6089 :         }
; 6090 :         if (pMPC_PIXwr->askans == PIX_ANSWER)

  001c1	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  001c6	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001ca	83 f8 01	 cmp	 eax, 1
  001cd	75 2e		 jne	 SHORT $LN27@write_rrh_

; 6091 :         {
; 6092 :             if (pMPC_PIXwr->iptype == PIX_IPV4)

  001cf	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  001d4	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001d8	83 f8 04	 cmp	 eax, 4
  001db	75 0a		 jne	 SHORT $LN28@write_rrh_

; 6093 :                 iWhat = YOUR_ADDRESS_IPV4;

  001dd	c7 44 24 68 07
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 7
  001e5	eb 16		 jmp	 SHORT $LN29@write_rrh_
$LN28@write_rrh_:

; 6094 :             else if (pMPC_PIXwr->iptype == PIX_IPV6)

  001e7	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  001ec	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001f0	83 f8 06	 cmp	 eax, 6
  001f3	75 08		 jne	 SHORT $LN30@write_rrh_

; 6095 :                 iWhat = YOUR_ADDRESS_IPV6;

  001f5	c7 44 24 68 08
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 8
$LN30@write_rrh_:
$LN29@write_rrh_:
$LN27@write_rrh_:

; 6096 :         }
; 6097 :     }

  001fd	e9 89 00 00 00	 jmp	 $LN22@write_rrh_
$LN21@write_rrh_:

; 6098 :     else if (pMPC_PIXwr->action == PIX_STOP)

  00202	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00207	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020a	83 f8 02	 cmp	 eax, 2
  0020d	75 7c		 jne	 SHORT $LN31@write_rrh_

; 6099 :     {
; 6100 :         if (pMPC_PIXwr->askans == PIX_ASK)

  0020f	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00214	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00218	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0021d	75 30		 jne	 SHORT $LN32@write_rrh_

; 6101 :         {
; 6102 :             if (pMPC_PIXwr->iptype == PIX_IPV4)

  0021f	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00224	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00228	83 f8 04	 cmp	 eax, 4
  0022b	75 0a		 jne	 SHORT $LN34@write_rrh_

; 6103 :                 iWhat = WILL_YOU_STOP_IPV4;

  0022d	c7 44 24 68 09
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 9
  00235	eb 16		 jmp	 SHORT $LN35@write_rrh_
$LN34@write_rrh_:

; 6104 :             else if (pMPC_PIXwr->iptype == PIX_IPV6)

  00237	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  0023c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00240	83 f8 06	 cmp	 eax, 6
  00243	75 08		 jne	 SHORT $LN36@write_rrh_

; 6105 :                 iWhat = WILL_YOU_STOP_IPV6;

  00245	c7 44 24 68 0a
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 10
$LN36@write_rrh_:
$LN35@write_rrh_:

; 6106 :         }

  0024d	eb 3c		 jmp	 SHORT $LN33@write_rrh_
$LN32@write_rrh_:

; 6107 :         else if (pMPC_PIXwr->askans == PIX_ANSWER)

  0024f	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00254	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00258	83 f8 01	 cmp	 eax, 1
  0025b	75 2e		 jne	 SHORT $LN37@write_rrh_

; 6108 :         {
; 6109 :             if (pMPC_PIXwr->iptype == PIX_IPV4)

  0025d	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00262	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00266	83 f8 04	 cmp	 eax, 4
  00269	75 0a		 jne	 SHORT $LN38@write_rrh_

; 6110 :                 iWhat = I_WILL_STOP_IPV4;

  0026b	c7 44 24 68 0b
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 11
  00273	eb 16		 jmp	 SHORT $LN39@write_rrh_
$LN38@write_rrh_:

; 6111 :             else if (pMPC_PIXwr->iptype == PIX_IPV6)

  00275	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  0027a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0027e	83 f8 06	 cmp	 eax, 6
  00281	75 08		 jne	 SHORT $LN40@write_rrh_

; 6112 :                 iWhat = I_WILL_STOP_IPV6;

  00283	c7 44 24 68 0c
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 12
$LN40@write_rrh_:
$LN39@write_rrh_:
$LN37@write_rrh_:
$LN33@write_rrh_:
$LN31@write_rrh_:
$LN22@write_rrh_:
$LN11@write_rrh_:

; 6113 :         }
; 6114 :     }
; 6115 : 
; 6116 :     // Process what the PIX contains.
; 6117 :     switch( iWhat )

  0028b	8b 44 24 68	 mov	 eax, DWORD PTR iWhat$[rsp]
  0028f	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  00296	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv176[rsp]
  0029d	ff c8		 dec	 eax
  0029f	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  002a6	83 bc 24 84 00
	00 00 0b	 cmp	 DWORD PTR tv176[rsp], 11
  002ae	0f 87 46 1d 00
	00		 ja	 $LN133@write_rrh_
  002b4	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv176[rsp]
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002c3	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN135@write_rrh_[rcx+rax*4]
  002ca	48 03 c1	 add	 rax, rcx
  002cd	ff e0		 jmp	 rax
$LN41@write_rrh_:

; 6118 :     {
; 6119 : 
; 6120 :     case WILL_YOU_START_IPV4:
; 6121 : 
; 6122 :         // Display various information, maybe
; 6123 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  002cf	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002d4	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  002d7	83 e0 10	 and	 eax, 16
  002da	85 c0		 test	 eax, eax
  002dc	74 15		 je	 SHORT $LN42@write_rrh_

; 6124 :         {
; 6125 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) Will you start IPv4?" );

  002de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172241
  002e5	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN42@write_rrh_:

; 6126 :         }
; 6127 : 
; 6128 :         // Remember the activation status.
; 6129 :         pPTPBLK->bActivate4 |= HEASKEDME_START;

  002f3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002f8	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  002ff	0f ba e8 07	 bts	 eax, 7
  00303	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00308	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6130 : 
; 6131 :         // Build RRH 0xC108 PIX 0x0101 to yTokenUlpConnection (I will start IPv4)
; 6132 :         pPTPHDRr1 = build_C108_i_will_start_4( pDEVBLK, pMPC_PIXwr, 0 );

  0030e	45 33 c0	 xor	 r8d, r8d
  00311	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  00316	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0031e	e8 00 00 00 00	 call	 build_C108_i_will_start_4
  00323	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6133 :         if (!pPTPHDRr1)

  00328	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  0032e	75 05		 jne	 SHORT $LN43@write_rrh_

; 6134 :             break;

  00330	e9 77 1d 00 00	 jmp	 $LN2@write_rrh_
$LN43@write_rrh_:

; 6135 : 
; 6136 :         // Remember the activation status.
; 6137 :         pPTPBLK->bActivate4 |= IANSWEREDHIM_START;

  00335	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0033a	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  00341	83 c8 40	 or	 eax, 64			; 00000040H
  00344	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00349	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6138 : 
; 6139 :         // Add PTPHDRs to chain.
; 6140 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  0034f	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  00354	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00359	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6141 : 
; 6142 :         // We have said we will start IPv4, but if IPv4 was not specified
; 6143 :         // that's all we will do. The y-side will wait patiently for our
; 6144 :         // will you start IPv4, which will never arrive. He's quite happy,
; 6145 :         // he just assumes the device/link has not been started on this side
; 6146 :         // and might be at sometime in the future.
; 6147 :         if (pPTPBLK->fIPv4Spec)

  0035e	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00363	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00366	83 e0 01	 and	 eax, 1
  00369	85 c0		 test	 eax, eax
  0036b	0f 84 9f 00 00
	00		 je	 $LN44@write_rrh_
$LN4@write_rrh_:

; 6148 :         {
; 6149 :             for( ; ; )
; 6150 :             {
; 6151 : 
; 6152 :                 // Build RRH 0xC108 PIX 0x0180 to yTokenUlpConnection (Will you start IPv4?)
; 6153 :                 pPTPHDRr1 = build_C108_will_you_start_4( pDEVBLK );

  00371	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00379	e8 00 00 00 00	 call	 build_C108_will_you_start_4
  0037e	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6154 :                 if (!pPTPHDRr1)

  00383	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  00389	75 05		 jne	 SHORT $LN45@write_rrh_

; 6155 :                 {
; 6156 :                     break;

  0038b	e9 80 00 00 00	 jmp	 $LN5@write_rrh_
$LN45@write_rrh_:

; 6157 :                 }
; 6158 : 
; 6159 :                 // Build RRH 0xC108 PIX 0x1180 to yTokenUlpConnection (My address IPv4)
; 6160 :                 pPTPHDRr2 = build_C108_my_address_4( pDEVBLK );

  00390	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00398	e8 00 00 00 00	 call	 build_C108_my_address_4
  0039d	48 89 44 24 78	 mov	 QWORD PTR pPTPHDRr2$[rsp], rax

; 6161 :                 if (!pPTPHDRr2)

  003a2	48 83 7c 24 78
	00		 cmp	 QWORD PTR pPTPHDRr2$[rsp], 0
  003a8	75 0d		 jne	 SHORT $LN46@write_rrh_

; 6162 :                 {
; 6163 :                     free( pPTPHDRr1 );

  003aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPHDRr1$[rsp]
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6164 :                     break;

  003b5	eb 59		 jmp	 SHORT $LN5@write_rrh_
$LN46@write_rrh_:

; 6165 :                 }
; 6166 : 
; 6167 :                 // Remember the activation status.
; 6168 :                 pPTPBLK->bActivate4 |= IASKEDHIM_START;

  003b7	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003bc	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  003c3	83 c8 20	 or	 eax, 32			; 00000020H
  003c6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003cb	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6169 :                 pPTPBLK->bActivate4 |= ITOLDHIMMY_ADDRESS;

  003d1	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003d6	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  003dd	83 c8 02	 or	 eax, 2
  003e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003e5	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6170 : 
; 6171 :                 // Add PTPHDRs to chain.
; 6172 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  003eb	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  003f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  003f5	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6173 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr2 );

  003fa	48 8b 54 24 78	 mov	 rdx, QWORD PTR pPTPHDRr2$[rsp]
  003ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00404	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6174 : 
; 6175 :                 break;

  00409	eb 05		 jmp	 SHORT $LN5@write_rrh_

; 6176 :             }

  0040b	e9 61 ff ff ff	 jmp	 $LN4@write_rrh_
$LN5@write_rrh_:
$LN44@write_rrh_:

; 6177 :         }
; 6178 : 
; 6179 :         break;

  00410	e9 97 1c 00 00	 jmp	 $LN2@write_rrh_
$LN47@write_rrh_:

; 6180 : 
; 6181 :     case WILL_YOU_START_IPV6:
; 6182 : 
; 6183 :         // Display various information, maybe
; 6184 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00415	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0041a	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0041d	83 e0 10	 and	 eax, 16
  00420	85 c0		 test	 eax, eax
  00422	74 15		 je	 SHORT $LN48@write_rrh_

; 6185 :         {
; 6186 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) Will you start IPv6?" );

  00424	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172248
  0042b	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00433	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN48@write_rrh_:

; 6187 :         }
; 6188 : 
; 6189 :         // Remember the activation status.
; 6190 :         pPTPBLK->bActivate6 |= HEASKEDME_START;

  00439	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0043e	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  00445	0f ba e8 07	 bts	 eax, 7
  00449	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0044e	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6191 :         pPTPBLK->bActivateLL6 |= HEASKEDME_START;

  00454	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00459	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  00460	0f ba e8 07	 bts	 eax, 7
  00464	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00469	88 81 86 03 00
	00		 mov	 BYTE PTR [rcx+902], al

; 6192 : 
; 6193 :         // Build RRH 0xC108 PIX 0x0101 to yTokenUlpConnection (I will start IPv6)
; 6194 :         pPTPHDRr1 = build_C108_i_will_start_6( pDEVBLK, pMPC_PIXwr, 0 );

  0046f	45 33 c0	 xor	 r8d, r8d
  00472	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  00477	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0047f	e8 00 00 00 00	 call	 build_C108_i_will_start_6
  00484	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6195 :         if (!pPTPHDRr1)

  00489	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  0048f	75 05		 jne	 SHORT $LN49@write_rrh_

; 6196 :             break;

  00491	e9 16 1c 00 00	 jmp	 $LN2@write_rrh_
$LN49@write_rrh_:

; 6197 : 
; 6198 :         // Remember the activation status.
; 6199 :         pPTPBLK->bActivate6 |= IANSWEREDHIM_START;

  00496	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0049b	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  004a2	83 c8 40	 or	 eax, 64			; 00000040H
  004a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  004aa	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6200 :         pPTPBLK->bActivateLL6 |= IANSWEREDHIM_START;

  004b0	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004b5	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  004bc	83 c8 40	 or	 eax, 64			; 00000040H
  004bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  004c4	88 81 86 03 00
	00		 mov	 BYTE PTR [rcx+902], al

; 6201 : 
; 6202 :         // Add PTPHDR to chain.
; 6203 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  004ca	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  004cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  004d4	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6204 : 
; 6205 : #if defined(ENABLE_IPV6)
; 6206 :         // We have said we will start IPv6, but if IPv6 was not specified
; 6207 :         // that's all we will do. The y-side will wait patiently for our
; 6208 :         // will you start IPv6, which will never arrive. He's quite happy,
; 6209 :         // he just assumes the interface has not been started on this side
; 6210 :         // and might be at sometime in the future.
; 6211 :         if (pPTPBLK->fIPv6Spec)

  004d9	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004de	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  004e1	d1 e8		 shr	 eax, 1
  004e3	83 e0 01	 and	 eax, 1
  004e6	85 c0		 test	 eax, eax
  004e8	0f 84 2a 01 00
	00		 je	 $LN50@write_rrh_
$LN7@write_rrh_:

; 6212 :         {
; 6213 :             for( ; ; )
; 6214 :             {
; 6215 : 
; 6216 :                 // Build RRH 0xC108 PIX 0x0180 to yTokenUlpConnection (Will you start IPv6?)
; 6217 :                 pPTPHDRr1 = build_C108_will_you_start_6( pDEVBLK );

  004ee	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004f6	e8 00 00 00 00	 call	 build_C108_will_you_start_6
  004fb	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6218 :                 if (!pPTPHDRr1)

  00500	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  00506	75 05		 jne	 SHORT $LN51@write_rrh_

; 6219 :                     break;

  00508	e9 0b 01 00 00	 jmp	 $LN8@write_rrh_
$LN51@write_rrh_:

; 6220 : 
; 6221 :                 // Build RRH 0xC108 PIX 0x1180 to yTokenUlpConnection (My address IPv6)
; 6222 :                 pPTPHDRr2 = build_C108_my_address_6( pDEVBLK, TRUE );  // Link local

  0050d	ba 01 00 00 00	 mov	 edx, 1
  00512	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0051a	e8 00 00 00 00	 call	 build_C108_my_address_6
  0051f	48 89 44 24 78	 mov	 QWORD PTR pPTPHDRr2$[rsp], rax

; 6223 :                 if (!pPTPHDRr2)

  00524	48 83 7c 24 78
	00		 cmp	 QWORD PTR pPTPHDRr2$[rsp], 0
  0052a	75 10		 jne	 SHORT $LN52@write_rrh_

; 6224 :                 {
; 6225 :                     free( pPTPHDRr1 );

  0052c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPHDRr1$[rsp]
  00531	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6226 :                     break;

  00537	e9 dc 00 00 00	 jmp	 $LN8@write_rrh_
$LN52@write_rrh_:

; 6227 :                 }
; 6228 : 
; 6229 :                 // Build RRH 0xC108 PIX 0x1180 to yTokenUlpConnection (My address IPv6)
; 6230 :                 pPTPHDRr3 = build_C108_my_address_6( pDEVBLK, FALSE );

  0053c	33 d2		 xor	 edx, edx
  0053e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00546	e8 00 00 00 00	 call	 build_C108_my_address_6
  0054b	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR pPTPHDRr3$[rsp], rax

; 6231 :                 if (!pPTPHDRr3)

  00553	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR pPTPHDRr3$[rsp], 0
  0055c	75 1b		 jne	 SHORT $LN53@write_rrh_

; 6232 :                 {
; 6233 :                     free( pPTPHDRr2 );

  0055e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPHDRr2$[rsp]
  00563	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6234 :                     free( pPTPHDRr1 );

  00569	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPHDRr1$[rsp]
  0056e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6235 :                     break;

  00574	e9 9f 00 00 00	 jmp	 $LN8@write_rrh_
$LN53@write_rrh_:

; 6236 :                 }
; 6237 : 
; 6238 :                 // Remember the activation status.
; 6239 :                 pPTPBLK->bActivate6 |= IASKEDHIM_START;

  00579	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0057e	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  00585	83 c8 20	 or	 eax, 32			; 00000020H
  00588	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0058d	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6240 :                 pPTPBLK->bActivateLL6 |= IASKEDHIM_START;

  00593	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00598	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  0059f	83 c8 20	 or	 eax, 32			; 00000020H
  005a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  005a7	88 81 86 03 00
	00		 mov	 BYTE PTR [rcx+902], al

; 6241 :                 pPTPBLK->bActivate6 |= ITOLDHIMMY_ADDRESS;

  005ad	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005b2	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  005b9	83 c8 02	 or	 eax, 2
  005bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  005c1	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6242 :                 pPTPBLK->bActivateLL6 |= ITOLDHIMMY_ADDRESS;

  005c7	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005cc	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  005d3	83 c8 02	 or	 eax, 2
  005d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  005db	88 81 86 03 00
	00		 mov	 BYTE PTR [rcx+902], al

; 6243 : 
; 6244 :                 // Add PTPHDRs to chain.
; 6245 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  005e1	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  005e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  005eb	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6246 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr2 );

  005f0	48 8b 54 24 78	 mov	 rdx, QWORD PTR pPTPHDRr2$[rsp]
  005f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  005fa	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6247 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr3 );

  005ff	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR pPTPHDRr3$[rsp]
  00607	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  0060c	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6248 : 
; 6249 :                 break;

  00611	eb 05		 jmp	 SHORT $LN8@write_rrh_

; 6250 :             }

  00613	e9 d6 fe ff ff	 jmp	 $LN7@write_rrh_
$LN8@write_rrh_:
$LN50@write_rrh_:

; 6251 :         }
; 6252 : #endif /* defined(ENABLE_IPV6) */
; 6253 : 
; 6254 :         break;

  00618	e9 8f 1a 00 00	 jmp	 $LN2@write_rrh_
$LN54@write_rrh_:

; 6255 : 
; 6256 :     case I_WILL_START_IPV4:
; 6257 : 
; 6258 :         // Display various information, maybe
; 6259 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0061d	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00622	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00625	83 e0 10	 and	 eax, 16
  00628	85 c0		 test	 eax, eax
  0062a	74 15		 je	 SHORT $LN55@write_rrh_

; 6260 :         {
; 6261 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) I will start IPv4" );

  0062c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172256
  00633	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0063b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN55@write_rrh_:

; 6262 :         }
; 6263 : 
; 6264 :         // Remember the activation status.
; 6265 :         pPTPBLK->bActivate4 |= HEANSWEREDME_START;

  00641	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00646	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  0064d	83 c8 10	 or	 eax, 16
  00650	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00655	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6266 : 
; 6267 :         // Check whether the connection is active.
; 6268 :         if (pPTPBLK->bActivate4 == WEAREACTIVE)

  0065b	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00660	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  00667	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0066c	0f 85 d0 00 00
	00		 jne	 $LN56@write_rrh_

; 6269 :         {
; 6270 :             // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6271 :             WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00672	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00677	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  0067d	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv312[rsp], rax
  00685	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0068d	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00691	89 8c 24 0c 01
	00 00		 mov	 DWORD PTR tv315[rsp], ecx
  00698	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  006a0	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  006a4	d1 fa		 sar	 edx, 1
  006a6	89 94 24 10 01
	00 00		 mov	 DWORD PTR tv319[rsp], edx
  006ad	b9 01 00 00 00	 mov	 ecx, 1
  006b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006b8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv312[rsp]
  006c0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006c5	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv315[rsp]
  006cc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006d0	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv319[rsp]
  006d7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172258
  006e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172259
  006ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  006fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172260
  00705	ba 80 18 00 00	 mov	 edx, 6272		; 00001880H
  0070a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172261
  00711	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6272 :                 pPTPBLK->szGuestIPAddr4 );
; 6273 :             pPTPBLK->fActive4 = TRUE;

  00717	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0071c	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0071f	83 c8 08	 or	 eax, 8
  00722	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00727	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6274 :             pPTPBLK->bActivate4 = 0x00;

  0072a	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0072f	c6 80 84 03 00
	00 00		 mov	 BYTE PTR [rax+900], 0

; 6275 :             pPTPBLK->bTerminate4 = 0x00;

  00736	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0073b	c6 80 87 03 00
	00 00		 mov	 BYTE PTR [rax+903], 0
$LN56@write_rrh_:

; 6276 :         }
; 6277 : 
; 6278 :         break;

  00742	e9 65 19 00 00	 jmp	 $LN2@write_rrh_
$LN57@write_rrh_:

; 6279 : 
; 6280 :     case I_WILL_START_IPV6:
; 6281 : 
; 6282 :         // Display various information, maybe
; 6283 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00747	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0074c	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0074f	83 e0 10	 and	 eax, 16
  00752	85 c0		 test	 eax, eax
  00754	74 15		 je	 SHORT $LN58@write_rrh_

; 6284 :         {
; 6285 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) I will start IPv6" );

  00756	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172264
  0075d	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00765	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN58@write_rrh_:

; 6286 :         }
; 6287 : 
; 6288 :         // Remember the activation status.
; 6289 :         pPTPBLK->bActivate6 |= HEANSWEREDME_START;

  0076b	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00770	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  00777	83 c8 10	 or	 eax, 16
  0077a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0077f	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6290 :         pPTPBLK->bActivateLL6 |= HEANSWEREDME_START;

  00785	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0078a	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  00791	83 c8 10	 or	 eax, 16
  00794	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00799	88 81 86 03 00
	00		 mov	 BYTE PTR [rcx+902], al

; 6291 : 
; 6292 : #if defined(ENABLE_IPV6)
; 6293 :         // Check whether the connection is active.
; 6294 :         if (pPTPBLK->bActivateLL6 == WEAREACTIVE)

  0079f	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007a4	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  007ab	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  007b0	0f 85 ef 00 00
	00		 jne	 $LN59@write_rrh_

; 6295 :         {
; 6296 :             // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6297 :             WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  007b6	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007bb	48 05 a0 02 00
	00		 add	 rax, 672		; 000002a0H
  007c1	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv353[rsp], rax
  007c9	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007d1	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  007d5	89 8c 24 14 01
	00 00		 mov	 DWORD PTR tv356[rsp], ecx
  007dc	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  007e4	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  007e8	d1 fa		 sar	 edx, 1
  007ea	89 94 24 18 01
	00 00		 mov	 DWORD PTR tv360[rsp], edx
  007f1	b9 01 00 00 00	 mov	 ecx, 1
  007f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007fc	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv353[rsp]
  00804	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00809	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv356[rsp]
  00810	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00814	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv360[rsp]
  0081b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0081f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172266
  00826	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0082b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172267
  00832	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00837	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0083c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00842	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172268
  00849	ba 9a 18 00 00	 mov	 edx, 6298		; 0000189aH
  0084e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172269
  00855	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6298 :                 pPTPBLK->szGuestLLAddr6 );
; 6299 :             pPTPBLK->fActiveLL6 = TRUE;

  0085b	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00860	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00863	83 c8 20	 or	 eax, 32			; 00000020H
  00866	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0086b	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6300 :             pPTPBLK->bActivateLL6 = 0x00;

  0086e	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00873	c6 80 86 03 00
	00 00		 mov	 BYTE PTR [rax+902], 0

; 6301 :             pPTPBLK->bTerminateLL6 = 0x00;

  0087a	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0087f	c6 80 89 03 00
	00 00		 mov	 BYTE PTR [rax+905], 0

; 6302 :             if (pPTPBLK->fActive6)

  00886	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0088b	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0088e	c1 e8 04	 shr	 eax, 4
  00891	83 e0 01	 and	 eax, 1
  00894	85 c0		 test	 eax, eax
  00896	74 0d		 je	 SHORT $LN60@write_rrh_

; 6303 :             {
; 6304 :                 build_8108_icmpv6_packets( pDEVBLK );

  00898	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  008a0	e8 00 00 00 00	 call	 build_8108_icmpv6_packets
$LN60@write_rrh_:
$LN59@write_rrh_:

; 6305 :             }
; 6306 :         }
; 6307 :         if (pPTPBLK->bActivate6 == WEAREACTIVE)

  008a5	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  008aa	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  008b1	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  008b6	0f 85 ef 00 00
	00		 jne	 $LN61@write_rrh_

; 6308 :         {
; 6309 :             // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6310 :             WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  008bc	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  008c1	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  008c7	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv384[rsp], rax
  008cf	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  008d7	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  008db	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv387[rsp], ecx
  008e2	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  008ea	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  008ee	d1 fa		 sar	 edx, 1
  008f0	89 94 24 90 00
	00 00		 mov	 DWORD PTR tv391[rsp], edx
  008f7	b9 01 00 00 00	 mov	 ecx, 1
  008fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00902	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv384[rsp]
  0090a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0090f	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv387[rsp]
  00916	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0091a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv391[rsp]
  00921	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00925	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172272
  0092c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00931	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172273
  00938	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0093d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00942	41 b9 03 00 00
	00		 mov	 r9d, 3
  00948	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172274
  0094f	ba a7 18 00 00	 mov	 edx, 6311		; 000018a7H
  00954	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172275
  0095b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6311 :                 pPTPBLK->szGuestIPAddr6 );
; 6312 :             pPTPBLK->fActive6 = TRUE;

  00961	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00966	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00969	83 c8 10	 or	 eax, 16
  0096c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00971	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6313 :             pPTPBLK->bActivate6 = 0x00;

  00974	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00979	c6 80 85 03 00
	00 00		 mov	 BYTE PTR [rax+901], 0

; 6314 :             pPTPBLK->bTerminate6 = 0x00;

  00980	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00985	c6 80 88 03 00
	00 00		 mov	 BYTE PTR [rax+904], 0

; 6315 :             if (pPTPBLK->fActiveLL6)

  0098c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00991	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00994	c1 e8 05	 shr	 eax, 5
  00997	83 e0 01	 and	 eax, 1
  0099a	85 c0		 test	 eax, eax
  0099c	74 0d		 je	 SHORT $LN62@write_rrh_

; 6316 :             {
; 6317 :                 build_8108_icmpv6_packets( pDEVBLK );

  0099e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009a6	e8 00 00 00 00	 call	 build_8108_icmpv6_packets
$LN62@write_rrh_:
$LN61@write_rrh_:

; 6318 :             }
; 6319 :         }
; 6320 : #endif /* defined(ENABLE_IPV6) */
; 6321 : 
; 6322 :         break;

  009ab	e9 fc 16 00 00	 jmp	 $LN2@write_rrh_
$LN63@write_rrh_:

; 6323 : 
; 6324 :     case MY_ADDRESS_IPV4:
; 6325 : 
; 6326 :         // Display various information, maybe
; 6327 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  009b0	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  009b5	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  009b8	83 e0 10	 and	 eax, 16
  009bb	85 c0		 test	 eax, eax
  009bd	74 15		 je	 SHORT $LN64@write_rrh_

; 6328 :         {
; 6329 :           mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) My address IPv4" );

  009bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172279
  009c6	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN64@write_rrh_:

; 6330 :         }
; 6331 : 
; 6332 :         // The y-side is telling us about his IPv4 address, which means
; 6333 :         // IPv4 is defined in the guest and that the device/link is started.
; 6334 :         // However, if IPv4 was not specified on the config statement, or
; 6335 :         // the pre-configured TUN interface, we are not interested. We will
; 6336 :         // respond to his message to keep him happy but that is all.
; 6337 :         if (pPTPBLK->fIPv4Spec)

  009d4	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  009d9	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  009dc	83 e0 01	 and	 eax, 1
  009df	85 c0		 test	 eax, eax
  009e1	0f 84 b8 03 00
	00		 je	 $LN65@write_rrh_

; 6338 :         {
; 6339 :           // Check for the guests IPv4 address.
; 6340 :           if (memcmp( pMPC_PIXwr->ipaddr, &pPTPBLK->iaGuestIPAddr4, 4 ) == 0)

  009e7	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  009ec	48 05 dc 02 00
	00		 add	 rax, 732		; 000002dcH
  009f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  009f7	48 83 c1 08	 add	 rcx, 8
  009fb	41 b8 04 00 00
	00		 mov	 r8d, 4
  00a01	48 8b d0	 mov	 rdx, rax
  00a04	e8 00 00 00 00	 call	 memcmp
  00a09	85 c0		 test	 eax, eax
  00a0b	75 6f		 jne	 SHORT $LN67@write_rrh_

; 6341 :           {
; 6342 :             // The y-side has told us his IPv4 address and it is the
; 6343 :             // guest address specified on the config statement or the
; 6344 :             // pre-configured TUN interface, which is of course good news.
; 6345 :             // Remember the activation status.
; 6346 :             pPTPBLK->bActivate4 |= HETOLDMEHIS_ADDRESS;

  00a0d	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00a12	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  00a19	83 c8 08	 or	 eax, 8
  00a1c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00a21	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6347 : 
; 6348 :             // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv4)
; 6349 :             pPTPHDRr1 = build_C108_your_address_4( pDEVBLK, pMPC_PIXwr, 0 );

  00a27	45 33 c0	 xor	 r8d, r8d
  00a2a	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  00a2f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a37	e8 00 00 00 00	 call	 build_C108_your_address_4
  00a3c	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6350 :             if (!pPTPHDRr1)

  00a41	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  00a47	75 05		 jne	 SHORT $LN69@write_rrh_

; 6351 :                 break;

  00a49	e9 5e 16 00 00	 jmp	 $LN2@write_rrh_
$LN69@write_rrh_:

; 6352 : 
; 6353 :             // Remember the activation status.
; 6354 :             pPTPBLK->bActivate4 |= IANSWEREDHIS_ADDRESS;

  00a4e	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00a53	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  00a5a	83 c8 04	 or	 eax, 4
  00a5d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00a62	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6355 : 
; 6356 :             // Add PTPHDR to chain.
; 6357 :             add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  00a68	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  00a6d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00a72	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6358 :           }

  00a77	e9 21 03 00 00	 jmp	 $LN68@write_rrh_
$LN67@write_rrh_:

; 6359 :           else
; 6360 :           {
; 6361 :             // Hmm... the y-side has told us his IPv4 address and it wasn't
; 6362 :             // the guest IPv4 address specified on the config statement
; 6363 :             // or the pre-configured TUN interface. This could happen if
; 6364 :             // if have been told the wrong address on the config statement,
; 6365 :             // or we are using a pre-configured TUN interface that did not
; 6366 :             // specify the guest IPv4 address.
; 6367 :             // Perhaps the guest and driver addresses were transposed.
; 6368 :             if (memcmp( pMPC_PIXwr->ipaddr, &pPTPBLK->iaDriveIPAddr4, 4 ) == 0)

  00a7c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00a81	48 05 d8 02 00
	00		 add	 rax, 728		; 000002d8H
  00a87	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  00a8c	48 83 c1 08	 add	 rcx, 8
  00a90	41 b8 04 00 00
	00		 mov	 r8d, 4
  00a96	48 8b d0	 mov	 rdx, rax
  00a99	e8 00 00 00 00	 call	 memcmp
  00a9e	85 c0		 test	 eax, eax
  00aa0	0f 85 f4 00 00
	00		 jne	 $LN70@write_rrh_

; 6369 :             {
; 6370 :                 // Looks like the guest and driver IPv4 addresses were transposed.
; 6371 :                 hinet_ntop( AF_INET, &pMPC_PIXwr->ipaddr, cIPaddr, sizeof(cIPaddr) );

  00aa6	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00aab	48 83 c0 08	 add	 rax, 8
  00aaf	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00ab5	4c 8d 84 24 a8
	01 00 00	 lea	 r8, QWORD PTR cIPaddr$[rsp]
  00abd	48 8b d0	 mov	 rdx, rax
  00ac0	b9 02 00 00 00	 mov	 ecx, 2
  00ac5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 6372 :                 // HHC03912 "%1d:%04X PTP: Guest has the driver IP address '%s'"
; 6373 :                 WRMSG(HHC03912, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, cIPaddr );

  00acb	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ad3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ad7	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv462[rsp], eax
  00ade	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ae6	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00aea	d1 f9		 sar	 ecx, 1
  00aec	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv466[rsp], ecx
  00af3	b9 01 00 00 00	 mov	 ecx, 1
  00af8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00afe	48 8d 8c 24 a8
	01 00 00	 lea	 rcx, QWORD PTR cIPaddr$[rsp]
  00b06	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b0b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv462[rsp]
  00b12	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b16	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv466[rsp]
  00b1d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172287
  00b28	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172288
  00b34	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b39	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b3e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b44	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172289
  00b4b	ba e5 18 00 00	 mov	 edx, 6373		; 000018e5H
  00b50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172290
  00b57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6374 : 
; 6375 :                 // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv4)
; 6376 :                 pPTPHDRr1 = build_C108_your_address_4( pDEVBLK, pMPC_PIXwr, 12 );

  00b5d	66 41 b8 0c 00	 mov	 r8w, 12
  00b62	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  00b67	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00b6f	e8 00 00 00 00	 call	 build_C108_your_address_4
  00b74	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6377 :                 if (!pPTPHDRr1)

  00b79	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  00b7f	75 05		 jne	 SHORT $LN72@write_rrh_

; 6378 :                     break;

  00b81	e9 26 15 00 00	 jmp	 $LN2@write_rrh_
$LN72@write_rrh_:

; 6379 : 
; 6380 :                 // Add PTPHDR to chain.
; 6381 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  00b86	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  00b8b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00b90	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6382 :             }

  00b95	e9 03 02 00 00	 jmp	 $LN71@write_rrh_
$LN70@write_rrh_:

; 6383 :             else
; 6384 :             {
; 6385 :               // Hmm... the y-side has told us his IPv4 address and it wasn't
; 6386 :               // the guest or driver IPv4 address specified on the config
; 6387 :               // statement or the pre-configured TUN interface.
; 6388 :               // Check whether we are using a pre-configured TUN interface
; 6389 :               // that did not specify the guest IPv4 address, and that we
; 6390 :               // have not already been told an address.
; 6391 :               memset(&addr4, 0, sizeof(addr4));

  00b9a	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR addr4$[rsp]
  00ba2	48 8b f8	 mov	 rdi, rax
  00ba5	33 c0		 xor	 eax, eax
  00ba7	b9 04 00 00 00	 mov	 ecx, 4
  00bac	f3 aa		 rep stosb

; 6392 :               if (pPTPBLK->fPreconfigured && !pPTPBLK->fPreGuestIPAddr4 &&

  00bae	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00bb3	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00bb6	c1 e8 06	 shr	 eax, 6
  00bb9	83 e0 01	 and	 eax, 1
  00bbc	85 c0		 test	 eax, eax
  00bbe	0f 84 ec 00 00
	00		 je	 $LN73@write_rrh_
  00bc4	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00bc9	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00bcc	c1 e8 07	 shr	 eax, 7
  00bcf	83 e0 01	 and	 eax, 1
  00bd2	85 c0		 test	 eax, eax
  00bd4	0f 85 d6 00 00
	00		 jne	 $LN73@write_rrh_
  00bda	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00bdf	48 05 dc 02 00
	00		 add	 rax, 732		; 000002dcH
  00be5	41 b8 04 00 00
	00		 mov	 r8d, 4
  00beb	48 8b d0	 mov	 rdx, rax
  00bee	48 8d 8c 24 9c
	00 00 00	 lea	 rcx, QWORD PTR addr4$[rsp]
  00bf6	e8 00 00 00 00	 call	 memcmp
  00bfb	85 c0		 test	 eax, eax
  00bfd	0f 85 ad 00 00
	00		 jne	 $LN73@write_rrh_

; 6393 :                   ( memcmp( &addr4, &pPTPBLK->iaGuestIPAddr4, sizeof(addr4) ) == 0 )) {
; 6394 : 
; 6395 :                 // We are using a pre-configured TUN interface that didn't
; 6396 :                 // specify the guest IPv4 address. Hooray, the y-side has
; 6397 :                 // told us his IPv4 address, something we didn't know, but
; 6398 :                 // need to. Copy the y-side's IPv4 address.
; 6399 :                 memcpy( &pPTPBLK->iaGuestIPAddr4, &pMPC_PIXwr->ipaddr,

  00c03	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00c08	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  00c0d	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00c10	89 88 dc 02 00
	00		 mov	 DWORD PTR [rax+732], ecx

; 6400 :                         sizeof(pPTPBLK->iaGuestIPAddr4) );
; 6401 :                 hinet_ntop( AF_INET, &pMPC_PIXwr->ipaddr, pPTPBLK->szGuestIPAddr4,

  00c16	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00c1b	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  00c21	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  00c26	48 83 c1 08	 add	 rcx, 8
  00c2a	41 b9 14 00 00
	00		 mov	 r9d, 20
  00c30	4c 8b c0	 mov	 r8, rax
  00c33	48 8b d1	 mov	 rdx, rcx
  00c36	b9 02 00 00 00	 mov	 ecx, 2
  00c3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 6402 :                                                           sizeof(pPTPBLK->szGuestIPAddr4) );
; 6403 : 
; 6404 :                 // Remember the activation status.
; 6405 :                 pPTPBLK->bActivate4 |= HETOLDMEHIS_ADDRESS;

  00c41	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00c46	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  00c4d	83 c8 08	 or	 eax, 8
  00c50	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00c55	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6406 : 
; 6407 :                 // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv4)
; 6408 :                 pPTPHDRr1 = build_C108_your_address_4( pDEVBLK, pMPC_PIXwr, 0 );

  00c5b	45 33 c0	 xor	 r8d, r8d
  00c5e	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  00c63	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c6b	e8 00 00 00 00	 call	 build_C108_your_address_4
  00c70	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6409 :                 if (!pPTPHDRr1)

  00c75	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  00c7b	75 05		 jne	 SHORT $LN75@write_rrh_

; 6410 :                     break;

  00c7d	e9 2a 14 00 00	 jmp	 $LN2@write_rrh_
$LN75@write_rrh_:

; 6411 : 
; 6412 :                 // Remember the activation status.
; 6413 :                 pPTPBLK->bActivate4 |= IANSWEREDHIS_ADDRESS;

  00c82	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00c87	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  00c8e	83 c8 04	 or	 eax, 4
  00c91	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00c96	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6414 : 
; 6415 :                 // Add PTPHDR to chain.
; 6416 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  00c9c	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  00ca1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00ca6	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6417 :               }

  00cab	e9 ed 00 00 00	 jmp	 $LN74@write_rrh_
$LN73@write_rrh_:

; 6418 :               else
; 6419 :               {
; 6420 :                 // The guest has an IPv4 address we know nothing about. The guest
; 6421 :                 // can only have one IPv4 address associated with a link.
; 6422 :                 hinet_ntop( AF_INET, &pMPC_PIXwr->ipaddr, cIPaddr, sizeof(cIPaddr) );

  00cb0	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00cb5	48 83 c0 08	 add	 rax, 8
  00cb9	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00cbf	4c 8d 84 24 a8
	01 00 00	 lea	 r8, QWORD PTR cIPaddr$[rsp]
  00cc7	48 8b d0	 mov	 rdx, rax
  00cca	b9 02 00 00 00	 mov	 ecx, 2
  00ccf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 6423 :                 // HHC03913 "%1d:%04X PTP: Guest has IP address '%s'"
; 6424 :                 WRMSG(HHC03913, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00cd5	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00cdd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ce1	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv543[rsp], eax
  00ce8	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00cf0	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00cf4	d1 f9		 sar	 ecx, 1
  00cf6	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv547[rsp], ecx
  00cfd	b9 01 00 00 00	 mov	 ecx, 1
  00d02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d08	48 8d 8c 24 a8
	01 00 00	 lea	 rcx, QWORD PTR cIPaddr$[rsp]
  00d10	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00d15	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv543[rsp]
  00d1c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d20	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv547[rsp]
  00d27	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172295
  00d32	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172296
  00d3e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d43	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d48	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d4e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172297
  00d55	ba 19 19 00 00	 mov	 edx, 6425		; 00001919H
  00d5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172298
  00d61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6425 :                                      cIPaddr );
; 6426 : 
; 6427 :                 // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv4)
; 6428 :                 pPTPHDRr1 = build_C108_your_address_4( pDEVBLK, pMPC_PIXwr, 0 );

  00d67	45 33 c0	 xor	 r8d, r8d
  00d6a	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  00d6f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d77	e8 00 00 00 00	 call	 build_C108_your_address_4
  00d7c	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6429 :                 if (!pPTPHDRr1)

  00d81	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  00d87	75 05		 jne	 SHORT $LN76@write_rrh_

; 6430 :                     break;

  00d89	e9 1e 13 00 00	 jmp	 $LN2@write_rrh_
$LN76@write_rrh_:

; 6431 : 
; 6432 :                 // Add PTPHDR to chain.
; 6433 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  00d8e	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  00d93	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00d98	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event
$LN74@write_rrh_:
$LN71@write_rrh_:
$LN68@write_rrh_:

; 6434 :               }
; 6435 :             }
; 6436 :           }
; 6437 :         }

  00d9d	eb 36		 jmp	 SHORT $LN66@write_rrh_
$LN65@write_rrh_:

; 6438 :         else
; 6439 :         {
; 6440 :           // IPv4 was not specified on the config statement or the
; 6441 :           // preconfigured TUN interface, but the guest has informed
; 6442 :           // us of his IPv4 address. Reply but otherwise ignore.
; 6443 : 
; 6444 :           // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv4)
; 6445 :           pPTPHDRr1 = build_C108_your_address_4( pDEVBLK, pMPC_PIXwr, 0 );

  00d9f	45 33 c0	 xor	 r8d, r8d
  00da2	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  00da7	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00daf	e8 00 00 00 00	 call	 build_C108_your_address_4
  00db4	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6446 :           if (!pPTPHDRr1)

  00db9	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  00dbf	75 05		 jne	 SHORT $LN77@write_rrh_

; 6447 :                break;

  00dc1	e9 e6 12 00 00	 jmp	 $LN2@write_rrh_
$LN77@write_rrh_:

; 6448 : 
; 6449 :           // Add PTPHDR to chain.
; 6450 :           add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  00dc6	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  00dcb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00dd0	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event
$LN66@write_rrh_:

; 6451 :         }
; 6452 : 
; 6453 :         // Check whether the connection is active.
; 6454 :         if (pPTPBLK->bActivate4 == WEAREACTIVE)

  00dd5	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00dda	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  00de1	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00de6	0f 85 d0 00 00
	00		 jne	 $LN78@write_rrh_

; 6455 :         {
; 6456 :             // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6457 :             WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00dec	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00df1	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  00df7	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv575[rsp], rax
  00dff	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e07	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00e0b	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv578[rsp], ecx
  00e12	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00e1a	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00e1e	d1 fa		 sar	 edx, 1
  00e20	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv582[rsp], edx
  00e27	b9 01 00 00 00	 mov	 ecx, 1
  00e2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e32	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv575[rsp]
  00e3a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e3f	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv578[rsp]
  00e46	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e4a	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv582[rsp]
  00e51	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e55	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172302
  00e5c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172303
  00e68	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e6d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e72	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e78	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172304
  00e7f	ba 3a 19 00 00	 mov	 edx, 6458		; 0000193aH
  00e84	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172305
  00e8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6458 :                 pPTPBLK->szGuestIPAddr4 );
; 6459 :             pPTPBLK->fActive4 = TRUE;

  00e91	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00e96	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00e99	83 c8 08	 or	 eax, 8
  00e9c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00ea1	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6460 :             pPTPBLK->bActivate4 = 0x00;

  00ea4	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ea9	c6 80 84 03 00
	00 00		 mov	 BYTE PTR [rax+900], 0

; 6461 :             pPTPBLK->bTerminate4 = 0x00;

  00eb0	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00eb5	c6 80 87 03 00
	00 00		 mov	 BYTE PTR [rax+903], 0
$LN78@write_rrh_:

; 6462 :         }
; 6463 : 
; 6464 :         break;

  00ebc	e9 eb 11 00 00	 jmp	 $LN2@write_rrh_
$LN79@write_rrh_:

; 6465 : 
; 6466 :     case MY_ADDRESS_IPV6:
; 6467 : 
; 6468 :         // Display various information, maybe
; 6469 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00ec1	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ec6	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00ec9	83 e0 10	 and	 eax, 16
  00ecc	85 c0		 test	 eax, eax
  00ece	74 15		 je	 SHORT $LN80@write_rrh_

; 6470 :         {
; 6471 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) My address IPv6" );

  00ed0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172308
  00ed7	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00edf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN80@write_rrh_:

; 6472 :         }
; 6473 : 
; 6474 : #if defined(ENABLE_IPV6)
; 6475 :         // Check whether the y-side is telling us about a Link Local address.
; 6476 :         fLL = FALSE;

  00ee5	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fLL$[rsp], 0

; 6477 :         memset( addr6.s6_addr, 0, 16 );

  00ef0	48 8d 84 24 98
	01 00 00	 lea	 rax, QWORD PTR addr6$[rsp]
  00ef8	48 8b f8	 mov	 rdi, rax
  00efb	33 c0		 xor	 eax, eax
  00efd	b9 10 00 00 00	 mov	 ecx, 16
  00f02	f3 aa		 rep stosb

; 6478 :         addr6.s6_addr[0] = 0xFE;

  00f04	b8 01 00 00 00	 mov	 eax, 1
  00f09	48 6b c0 00	 imul	 rax, rax, 0
  00f0d	c6 84 04 98 01
	00 00 fe	 mov	 BYTE PTR addr6$[rsp+rax], 254 ; 000000feH

; 6479 :         addr6.s6_addr[1] = 0x80;

  00f15	b8 01 00 00 00	 mov	 eax, 1
  00f1a	48 6b c0 01	 imul	 rax, rax, 1
  00f1e	c6 84 04 98 01
	00 00 80	 mov	 BYTE PTR addr6$[rsp+rax], 128 ; 00000080H

; 6480 :         if (memcmp( pMPC_PIXwr->ipaddr, &addr6, 8 ) == 0)

  00f26	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  00f2b	48 83 c0 08	 add	 rax, 8
  00f2f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00f35	48 8d 94 24 98
	01 00 00	 lea	 rdx, QWORD PTR addr6$[rsp]
  00f3d	48 8b c8	 mov	 rcx, rax
  00f40	e8 00 00 00 00	 call	 memcmp
  00f45	85 c0		 test	 eax, eax
  00f47	75 0b		 jne	 SHORT $LN81@write_rrh_

; 6481 :             fLL = TRUE;

  00f49	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fLL$[rsp], 1
$LN81@write_rrh_:

; 6482 : 
; 6483 :         // The y-side is telling us about his IPv6 address(es), which means
; 6484 :         // IPv6 is defined in the guest and that the interface is started.
; 6485 :         // However, if IPv6 was not specified on the config statement, or
; 6486 :         // the pre-configured TUN interface, we are not interested. We will
; 6487 :         // respond to his message to keep him happy but that is all.
; 6488 :         if (pPTPBLK->fIPv6Spec)

  00f54	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00f59	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00f5c	d1 e8		 shr	 eax, 1
  00f5e	83 e0 01	 and	 eax, 1
  00f61	85 c0		 test	 eax, eax
  00f63	0f 84 72 04 00
	00		 je	 $LN82@write_rrh_

; 6489 :         {
; 6490 :           if (!fLL)

  00f69	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR fLL$[rsp], 0
  00f71	0f 85 ae 03 00
	00		 jne	 $LN84@write_rrh_

; 6491 :           {
; 6492 :             // The y-side has told us about an address that is not his Link
; 6493 :             // Local address. Check whether the guests IPv6 is the address
; 6494 :             // that was specified on the config statement.
; 6495 :             if (memcmp( pMPC_PIXwr->ipaddr, &pPTPBLK->iaGuestIPAddr6, 16 ) == 0)

  00f77	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00f7c	48 05 f0 02 00
	00		 add	 rax, 752		; 000002f0H
  00f82	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  00f87	48 83 c1 08	 add	 rcx, 8
  00f8b	41 b8 10 00 00
	00		 mov	 r8d, 16
  00f91	48 8b d0	 mov	 rdx, rax
  00f94	e8 00 00 00 00	 call	 memcmp
  00f99	85 c0		 test	 eax, eax
  00f9b	75 6f		 jne	 SHORT $LN86@write_rrh_

; 6496 :             {
; 6497 :               // The y-side has told us his IPv6 address and it is the guest
; 6498 :               // address specified on the config statement, which is of course
; 6499 :               // good news. Remember the activation status.
; 6500 :               pPTPBLK->bActivate6 |= HETOLDMEHIS_ADDRESS;

  00f9d	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00fa2	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  00fa9	83 c8 08	 or	 eax, 8
  00fac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00fb1	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6501 : 
; 6502 :               // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv6)
; 6503 :               pPTPHDRr1 = build_C108_your_address_6( pDEVBLK, pMPC_PIXwr, 0 );

  00fb7	45 33 c0	 xor	 r8d, r8d
  00fba	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  00fbf	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00fc7	e8 00 00 00 00	 call	 build_C108_your_address_6
  00fcc	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6504 :               if (!pPTPHDRr1)

  00fd1	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  00fd7	75 05		 jne	 SHORT $LN88@write_rrh_

; 6505 :                   break;

  00fd9	e9 ce 10 00 00	 jmp	 $LN2@write_rrh_
$LN88@write_rrh_:

; 6506 : 
; 6507 :               // Remember the activation status.
; 6508 :               pPTPBLK->bActivate6 |= IANSWEREDHIS_ADDRESS;

  00fde	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00fe3	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  00fea	83 c8 04	 or	 eax, 4
  00fed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00ff2	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6509 : 
; 6510 :               // Add PTPHDR to chain.
; 6511 :               add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  00ff8	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  00ffd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01002	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6512 :             }

  01007	e9 14 03 00 00	 jmp	 $LN87@write_rrh_
$LN86@write_rrh_:

; 6513 :             else
; 6514 :             {
; 6515 :               // Hmm... the y-side has told us his IPv6 address and it wasn't
; 6516 :               // the guest IPv6 address specified on the config statement. This
; 6517 :               // could happen; the guest can have multiple IPv6 addresses, or
; 6518 :               // we are using a pre-configured TUN interface and we don't know
; 6519 :               // the guest IPv6 address, or we have been told the wrong address.
; 6520 :               // Perhaps the guest and driver IPv6 addresses were transposed on
; 6521 :               // the config statement.
; 6522 :               if (memcmp( pMPC_PIXwr->ipaddr, &pPTPBLK->iaDriveIPAddr6, 16 ) == 0)

  0100c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01011	48 05 e0 02 00
	00		 add	 rax, 736		; 000002e0H
  01017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  0101c	48 83 c1 08	 add	 rcx, 8
  01020	41 b8 10 00 00
	00		 mov	 r8d, 16
  01026	48 8b d0	 mov	 rdx, rax
  01029	e8 00 00 00 00	 call	 memcmp
  0102e	85 c0		 test	 eax, eax
  01030	0f 85 f4 00 00
	00		 jne	 $LN89@write_rrh_

; 6523 :               {
; 6524 :                 // Looks like the guest and driver IPv6 addresses were transposed.
; 6525 :                 hinet_ntop( AF_INET, &pMPC_PIXwr->ipaddr, cIPaddr, sizeof(cIPaddr) );

  01036	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  0103b	48 83 c0 08	 add	 rax, 8
  0103f	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  01045	4c 8d 84 24 a8
	01 00 00	 lea	 r8, QWORD PTR cIPaddr$[rsp]
  0104d	48 8b d0	 mov	 rdx, rax
  01050	b9 02 00 00 00	 mov	 ecx, 2
  01055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 6526 :                 // HHC03912 "%1d:%04X PTP: Guest has the driver IP address '%s'"
; 6527 :                 WRMSG(HHC03912, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  0105b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01063	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01067	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv666[rsp], eax
  0106e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01076	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0107a	d1 f9		 sar	 ecx, 1
  0107c	89 8c 24 b4 00
	00 00		 mov	 DWORD PTR tv670[rsp], ecx
  01083	b9 01 00 00 00	 mov	 ecx, 1
  01088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0108e	48 8d 8c 24 a8
	01 00 00	 lea	 rcx, QWORD PTR cIPaddr$[rsp]
  01096	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0109b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv666[rsp]
  010a2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010a6	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv670[rsp]
  010ad	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172319
  010b8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172320
  010c4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010ce	41 b9 03 00 00
	00		 mov	 r9d, 3
  010d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172321
  010db	ba 80 19 00 00	 mov	 edx, 6528		; 00001980H
  010e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172322
  010e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6528 :                                      cIPaddr );
; 6529 : 
; 6530 :                 // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv6)
; 6531 :                 pPTPHDRr1 = build_C108_your_address_6( pDEVBLK, pMPC_PIXwr, 12 );

  010ed	66 41 b8 0c 00	 mov	 r8w, 12
  010f2	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  010f7	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  010ff	e8 00 00 00 00	 call	 build_C108_your_address_6
  01104	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6532 :                 if (!pPTPHDRr1)

  01109	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  0110f	75 05		 jne	 SHORT $LN91@write_rrh_

; 6533 :                     break;

  01111	e9 96 0f 00 00	 jmp	 $LN2@write_rrh_
$LN91@write_rrh_:

; 6534 : 
; 6535 :                 // Add PTPHDR to chain.
; 6536 :                 add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  01116	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  0111b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01120	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6537 :               }

  01125	e9 f6 01 00 00	 jmp	 $LN90@write_rrh_
$LN89@write_rrh_:

; 6538 :               else
; 6539 :               {
; 6540 :                 // Hmm... the y-side has told us an IPv6 address and it wasn't
; 6541 :                 // the guest or driver IPv4 address specified on the config
; 6542 :                 // statement or the pre-configured TUN interface.
; 6543 :                 // Check whether we are using a pre-configured TUN interface,
; 6544 :                 // and that we have not already been told an address.
; 6545 :                 memset(&addr6, 0, sizeof(addr6));

  0112a	48 8d 84 24 98
	01 00 00	 lea	 rax, QWORD PTR addr6$[rsp]
  01132	48 8b f8	 mov	 rdi, rax
  01135	33 c0		 xor	 eax, eax
  01137	b9 10 00 00 00	 mov	 ecx, 16
  0113c	f3 aa		 rep stosb

; 6546 :                 if (pPTPBLK->fPreconfigured &&

  0113e	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01143	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01146	c1 e8 06	 shr	 eax, 6
  01149	83 e0 01	 and	 eax, 1
  0114c	85 c0		 test	 eax, eax
  0114e	0f 84 df 00 00
	00		 je	 $LN92@write_rrh_
  01154	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01159	48 05 f0 02 00
	00		 add	 rax, 752		; 000002f0H
  0115f	41 b8 10 00 00
	00		 mov	 r8d, 16
  01165	48 8b d0	 mov	 rdx, rax
  01168	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR addr6$[rsp]
  01170	e8 00 00 00 00	 call	 memcmp
  01175	85 c0		 test	 eax, eax
  01177	0f 85 b6 00 00
	00		 jne	 $LN92@write_rrh_

; 6547 :                     ( memcmp( &addr6, &pPTPBLK->iaGuestIPAddr6, sizeof(addr6) ) == 0 )) {
; 6548 : 
; 6549 :                   // We are using a pre-configured TUN interface. Hooray, the
; 6550 :                   // y-side has told us his IPv6 address, something we didn't
; 6551 :                   // know but need to. Copy the y-side's IPv6 address.
; 6552 :                   memcpy( &pPTPBLK->iaGuestIPAddr6, &pMPC_PIXwr->ipaddr,

  0117d	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01182	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  01187	48 8d b8 f0 02
	00 00		 lea	 rdi, QWORD PTR [rax+752]
  0118e	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  01192	b9 10 00 00 00	 mov	 ecx, 16
  01197	f3 a4		 rep movsb

; 6553 :                           sizeof(pPTPBLK->iaGuestIPAddr6) );
; 6554 :                   hinet_ntop( AF_INET6, &pMPC_PIXwr->ipaddr, pPTPBLK->szGuestIPAddr6,

  01199	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0119e	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  011a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  011a9	48 83 c1 08	 add	 rcx, 8
  011ad	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  011b3	4c 8b c0	 mov	 r8, rax
  011b6	48 8b d1	 mov	 rdx, rcx
  011b9	b9 17 00 00 00	 mov	 ecx, 23
  011be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 6555 :                                                              sizeof(pPTPBLK->szGuestIPAddr6) );
; 6556 : 
; 6557 :                   // The y-side has told us his IPv6 address and it is the guest
; 6558 :                   // address specified on the config statement, which is of course
; 6559 :                   // good news. Remember the activation status.
; 6560 :                   pPTPBLK->bActivate6 |= HETOLDMEHIS_ADDRESS;

  011c4	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  011c9	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  011d0	83 c8 08	 or	 eax, 8
  011d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  011d8	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6561 : 
; 6562 :                   // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv6)
; 6563 :                   pPTPHDRr1 = build_C108_your_address_6( pDEVBLK, pMPC_PIXwr, 0 );

  011de	45 33 c0	 xor	 r8d, r8d
  011e1	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  011e6	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  011ee	e8 00 00 00 00	 call	 build_C108_your_address_6
  011f3	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6564 :                   if (!pPTPHDRr1)

  011f8	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  011fe	75 05		 jne	 SHORT $LN94@write_rrh_

; 6565 :                       break;

  01200	e9 a7 0e 00 00	 jmp	 $LN2@write_rrh_
$LN94@write_rrh_:

; 6566 : 
; 6567 :                   // Remember the activation status.
; 6568 :                   pPTPBLK->bActivate6 |= IANSWEREDHIS_ADDRESS;

  01205	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0120a	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  01211	83 c8 04	 or	 eax, 4
  01214	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01219	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6569 : 
; 6570 :                   // Add PTPHDR to chain.
; 6571 :                   add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  0121f	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  01224	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01229	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6572 :                 }

  0122e	e9 ed 00 00 00	 jmp	 $LN93@write_rrh_
$LN92@write_rrh_:

; 6573 :                 else
; 6574 :                 {
; 6575 :                   // The guest has an IPv6 address we know nothing about. The guest
; 6576 :                   // can have multiple IPv6 addresses associated with an interface.
; 6577 :                   hinet_ntop( AF_INET6, &pMPC_PIXwr->ipaddr, cIPaddr, sizeof(cIPaddr) );

  01233	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  01238	48 83 c0 08	 add	 rax, 8
  0123c	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  01242	4c 8d 84 24 a8
	01 00 00	 lea	 r8, QWORD PTR cIPaddr$[rsp]
  0124a	48 8b d0	 mov	 rdx, rax
  0124d	b9 17 00 00 00	 mov	 ecx, 23
  01252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 6578 :                   // HHC03914 "%1d:%04X PTP: Guest has IP address '%s'"
; 6579 :                   WRMSG(HHC03914, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  01258	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01260	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01264	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv775[rsp], eax
  0126b	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01273	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01277	d1 f9		 sar	 ecx, 1
  01279	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv779[rsp], ecx
  01280	b9 01 00 00 00	 mov	 ecx, 1
  01285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0128b	48 8d 8c 24 a8
	01 00 00	 lea	 rcx, QWORD PTR cIPaddr$[rsp]
  01293	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01298	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv775[rsp]
  0129f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  012a3	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv779[rsp]
  012aa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  012ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172327
  012b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172328
  012c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  012d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172329
  012d8	ba b4 19 00 00	 mov	 edx, 6580		; 000019b4H
  012dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172330
  012e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6580 :                                        cIPaddr );
; 6581 : 
; 6582 :                   // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv6)
; 6583 :                   pPTPHDRr1 = build_C108_your_address_6( pDEVBLK, pMPC_PIXwr, 0 );

  012ea	45 33 c0	 xor	 r8d, r8d
  012ed	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  012f2	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  012fa	e8 00 00 00 00	 call	 build_C108_your_address_6
  012ff	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6584 :                   if (!pPTPHDRr1)

  01304	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  0130a	75 05		 jne	 SHORT $LN95@write_rrh_

; 6585 :                       break;

  0130c	e9 9b 0d 00 00	 jmp	 $LN2@write_rrh_
$LN95@write_rrh_:

; 6586 : 
; 6587 :                   // Add PTPHDR to chain.
; 6588 :                   add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  01311	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  01316	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  0131b	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event
$LN93@write_rrh_:
$LN90@write_rrh_:
$LN87@write_rrh_:

; 6589 :                 }
; 6590 :               }
; 6591 :             }
; 6592 :           }

  01320	e9 b4 00 00 00	 jmp	 $LN85@write_rrh_
$LN84@write_rrh_:

; 6593 :           else
; 6594 :           {
; 6595 :             // The y-side has told us about his Link Local address.
; 6596 :             // Remember the activation status.
; 6597 :             pPTPBLK->bActivateLL6 |= HETOLDMEHIS_ADDRESS;

  01325	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0132a	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  01331	83 c8 08	 or	 eax, 8
  01334	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01339	88 81 86 03 00
	00		 mov	 BYTE PTR [rcx+902], al

; 6598 : 
; 6599 :             // Copy the y-side's Link Local address.
; 6600 :             memcpy( &pPTPBLK->iaGuestLLAddr6, pMPC_PIXwr->ipaddr, 16 );

  0133f	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01344	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PIXwr$[rsp]
  01349	48 8d b8 10 03
	00 00		 lea	 rdi, QWORD PTR [rax+784]
  01350	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  01354	b9 10 00 00 00	 mov	 ecx, 16
  01359	f3 a4		 rep movsb

; 6601 :             hinet_ntop( AF_INET6, &pPTPBLK->iaGuestLLAddr6,

  0135b	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01360	48 05 a0 02 00
	00		 add	 rax, 672		; 000002a0H
  01366	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0136b	48 81 c1 10 03
	00 00		 add	 rcx, 784		; 00000310H
  01372	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  01378	4c 8b c0	 mov	 r8, rax
  0137b	48 8b d1	 mov	 rdx, rcx
  0137e	b9 17 00 00 00	 mov	 ecx, 23
  01383	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 6602 :                                   pPTPBLK->szGuestLLAddr6,
; 6603 :                                   sizeof(pPTPBLK->szGuestLLAddr6) );
; 6604 : 
; 6605 :             // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv6)
; 6606 :             pPTPHDRr1 = build_C108_your_address_6( pDEVBLK, pMPC_PIXwr, 0 );

  01389	45 33 c0	 xor	 r8d, r8d
  0138c	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  01391	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01399	e8 00 00 00 00	 call	 build_C108_your_address_6
  0139e	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6607 :             if (!pPTPHDRr1)

  013a3	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  013a9	75 05		 jne	 SHORT $LN96@write_rrh_

; 6608 :                 break;

  013ab	e9 fc 0c 00 00	 jmp	 $LN2@write_rrh_
$LN96@write_rrh_:

; 6609 : 
; 6610 :             // Remember the activation status.
; 6611 :             pPTPBLK->bActivateLL6 |= IANSWEREDHIS_ADDRESS;

  013b0	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  013b5	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  013bc	83 c8 04	 or	 eax, 4
  013bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  013c4	88 81 86 03 00
	00		 mov	 BYTE PTR [rcx+902], al

; 6612 : 
; 6613 :             // Add PTPHDR to chain.
; 6614 :             add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  013ca	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  013cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  013d4	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event
$LN85@write_rrh_:

; 6615 :           }
; 6616 :         }

  013d9	eb 36		 jmp	 SHORT $LN83@write_rrh_
$LN82@write_rrh_:

; 6617 :         else
; 6618 :         {
; 6619 : #endif /* defined(ENABLE_IPV6) */
; 6620 :           // IPv6 was not specified on the config statement, but the guest
; 6621 :           // has informed us of an IPv6 address. Reply but otherwise ignore.
; 6622 : 
; 6623 :           // Build RRH 0xC108 PIX 0x1101 to yTokenUlpConnection (Your address IPv6)
; 6624 :           pPTPHDRr1 = build_C108_your_address_6( pDEVBLK, pMPC_PIXwr, 0 );

  013db	45 33 c0	 xor	 r8d, r8d
  013de	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  013e3	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  013eb	e8 00 00 00 00	 call	 build_C108_your_address_6
  013f0	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6625 :           if (!pPTPHDRr1)

  013f5	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  013fb	75 05		 jne	 SHORT $LN97@write_rrh_

; 6626 :               break;

  013fd	e9 aa 0c 00 00	 jmp	 $LN2@write_rrh_
$LN97@write_rrh_:

; 6627 : 
; 6628 :           // Add PTPHDR to chain.
; 6629 :             add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  01402	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  01407	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  0140c	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event
$LN83@write_rrh_:

; 6630 : #if defined(ENABLE_IPV6)
; 6631 :         }
; 6632 : 
; 6633 :         //
; 6634 :         if (pPTPBLK->fIPv6Spec)

  01411	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01416	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01419	d1 e8		 shr	 eax, 1
  0141b	83 e0 01	 and	 eax, 1
  0141e	85 c0		 test	 eax, eax
  01420	0f 84 0c 02 00
	00		 je	 $LN98@write_rrh_

; 6635 :         {
; 6636 :             // Check whether the connection is active.
; 6637 :             if (pPTPBLK->bActivateLL6 == WEAREACTIVE)

  01426	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0142b	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  01432	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01437	0f 85 ef 00 00
	00		 jne	 $LN99@write_rrh_

; 6638 :             {
; 6639 :                 // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6640 :                 WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  0143d	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01442	48 05 a0 02 00
	00		 add	 rax, 672		; 000002a0H
  01448	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv843[rsp], rax
  01450	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01458	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0145c	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv846[rsp], ecx
  01463	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0146b	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0146f	d1 fa		 sar	 edx, 1
  01471	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv850[rsp], edx
  01478	b9 01 00 00 00	 mov	 ecx, 1
  0147d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01483	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv843[rsp]
  0148b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01490	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv846[rsp]
  01497	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0149b	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv850[rsp]
  014a2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  014a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172336
  014ad	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172337
  014b9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014c3	41 b9 03 00 00
	00		 mov	 r9d, 3
  014c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172338
  014d0	ba f1 19 00 00	 mov	 edx, 6641		; 000019f1H
  014d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172339
  014dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6641 :                     pPTPBLK->szGuestLLAddr6 );
; 6642 :                 pPTPBLK->fActiveLL6 = TRUE;

  014e2	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  014e7	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  014ea	83 c8 20	 or	 eax, 32			; 00000020H
  014ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  014f2	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6643 :                 pPTPBLK->bActivateLL6 = 0x00;

  014f5	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  014fa	c6 80 86 03 00
	00 00		 mov	 BYTE PTR [rax+902], 0

; 6644 :                 pPTPBLK->bTerminateLL6 = 0x00;

  01501	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01506	c6 80 89 03 00
	00 00		 mov	 BYTE PTR [rax+905], 0

; 6645 :                 if (pPTPBLK->fActive6)

  0150d	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01512	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01515	c1 e8 04	 shr	 eax, 4
  01518	83 e0 01	 and	 eax, 1
  0151b	85 c0		 test	 eax, eax
  0151d	74 0d		 je	 SHORT $LN100@write_rrh_

; 6646 :                     build_8108_icmpv6_packets( pDEVBLK );

  0151f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01527	e8 00 00 00 00	 call	 build_8108_icmpv6_packets
$LN100@write_rrh_:
$LN99@write_rrh_:

; 6647 :             }
; 6648 :             if (pPTPBLK->bActivate6 == WEAREACTIVE)

  0152c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01531	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  01538	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0153d	0f 85 ef 00 00
	00		 jne	 $LN101@write_rrh_

; 6649 :             {
; 6650 :                 // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6651 :                 WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  01543	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01548	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  0154e	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv874[rsp], rax
  01556	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0155e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01562	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv877[rsp], ecx
  01569	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01571	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  01575	d1 fa		 sar	 edx, 1
  01577	89 94 24 cc 00
	00 00		 mov	 DWORD PTR tv881[rsp], edx
  0157e	b9 01 00 00 00	 mov	 ecx, 1
  01583	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01589	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv874[rsp]
  01591	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01596	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv877[rsp]
  0159d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  015a1	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv881[rsp]
  015a8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  015ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172342
  015b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  015b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172343
  015bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  015cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172344
  015d6	ba fc 19 00 00	 mov	 edx, 6652		; 000019fcH
  015db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172345
  015e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6652 :                     pPTPBLK->szGuestIPAddr6 );
; 6653 :                 pPTPBLK->fActive6 = TRUE;

  015e8	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  015ed	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  015f0	83 c8 10	 or	 eax, 16
  015f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  015f8	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6654 :                 pPTPBLK->bActivate6 = 0x00;

  015fb	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01600	c6 80 85 03 00
	00 00		 mov	 BYTE PTR [rax+901], 0

; 6655 :                 pPTPBLK->bTerminate6 = 0x00;

  01607	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0160c	c6 80 88 03 00
	00 00		 mov	 BYTE PTR [rax+904], 0

; 6656 :                 if (pPTPBLK->fActiveLL6)

  01613	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01618	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0161b	c1 e8 05	 shr	 eax, 5
  0161e	83 e0 01	 and	 eax, 1
  01621	85 c0		 test	 eax, eax
  01623	74 0d		 je	 SHORT $LN102@write_rrh_

; 6657 :                     build_8108_icmpv6_packets( pDEVBLK );

  01625	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0162d	e8 00 00 00 00	 call	 build_8108_icmpv6_packets
$LN102@write_rrh_:
$LN101@write_rrh_:
$LN98@write_rrh_:

; 6658 :             }
; 6659 :         }
; 6660 : #endif /* defined(ENABLE_IPV6) */
; 6661 : 
; 6662 :         break;

  01632	e9 75 0a 00 00	 jmp	 $LN2@write_rrh_
$LN103@write_rrh_:

; 6663 : 
; 6664 :     case YOUR_ADDRESS_IPV4:
; 6665 : 
; 6666 :         // Display various information, maybe
; 6667 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  01637	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0163c	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0163f	83 e0 10	 and	 eax, 16
  01642	85 c0		 test	 eax, eax
  01644	74 15		 je	 SHORT $LN104@write_rrh_

; 6668 :         {
; 6669 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) Your address IPv4" );

  01646	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172349
  0164d	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01655	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN104@write_rrh_:

; 6670 :         }
; 6671 : 
; 6672 :         // Remember the activation status.
; 6673 :         pPTPBLK->bActivate4 |= HEANSWEREDMY_ADDRESS;

  0165b	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01660	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  01667	83 c8 01	 or	 eax, 1
  0166a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0166f	88 81 84 03 00
	00		 mov	 BYTE PTR [rcx+900], al

; 6674 : 
; 6675 :         // Check whether the connection is active.
; 6676 :         if (pPTPBLK->bActivate4 == WEAREACTIVE)

  01675	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0167a	0f b6 80 84 03
	00 00		 movzx	 eax, BYTE PTR [rax+900]
  01681	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01686	0f 85 d0 00 00
	00		 jne	 $LN105@write_rrh_

; 6677 :         {
; 6678 :             // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6679 :             WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  0168c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01691	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  01697	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv915[rsp], rax
  0169f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  016a7	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  016ab	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv918[rsp], ecx
  016b2	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  016ba	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  016be	d1 fa		 sar	 edx, 1
  016c0	89 94 24 d4 00
	00 00		 mov	 DWORD PTR tv922[rsp], edx
  016c7	b9 01 00 00 00	 mov	 ecx, 1
  016cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  016d2	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv915[rsp]
  016da	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  016df	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv918[rsp]
  016e6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  016ea	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv922[rsp]
  016f1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  016f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172351
  016fc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01701	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172352
  01708	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0170d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01712	41 b9 03 00 00
	00		 mov	 r9d, 3
  01718	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172353
  0171f	ba 18 1a 00 00	 mov	 edx, 6680		; 00001a18H
  01724	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172354
  0172b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6680 :                 pPTPBLK->szGuestIPAddr4 );
; 6681 :             pPTPBLK->fActive4 = TRUE;

  01731	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01736	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01739	83 c8 08	 or	 eax, 8
  0173c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01741	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6682 :             pPTPBLK->bActivate4 = 0x00;

  01744	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01749	c6 80 84 03 00
	00 00		 mov	 BYTE PTR [rax+900], 0

; 6683 :             pPTPBLK->bTerminate4 = 0x00;

  01750	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01755	c6 80 87 03 00
	00 00		 mov	 BYTE PTR [rax+903], 0
$LN105@write_rrh_:

; 6684 :         }
; 6685 : 
; 6686 :         break;

  0175c	e9 4b 09 00 00	 jmp	 $LN2@write_rrh_
$LN106@write_rrh_:

; 6687 : 
; 6688 :     case YOUR_ADDRESS_IPV6:
; 6689 : 
; 6690 :         // Display various information, maybe
; 6691 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  01761	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01766	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  01769	83 e0 10	 and	 eax, 16
  0176c	85 c0		 test	 eax, eax
  0176e	74 15		 je	 SHORT $LN107@write_rrh_

; 6692 :         {
; 6693 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) Your address IPv6" );

  01770	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172357
  01777	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0177f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN107@write_rrh_:

; 6694 :         }
; 6695 : 
; 6696 : #if defined(ENABLE_IPV6)
; 6697 :         // Check whether the y-side is telling us about a Link Local address.
; 6698 :         fLL = FALSE;

  01785	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fLL$[rsp], 0

; 6699 :         memset( addr6.s6_addr, 0, 16 );

  01790	48 8d 84 24 98
	01 00 00	 lea	 rax, QWORD PTR addr6$[rsp]
  01798	48 8b f8	 mov	 rdi, rax
  0179b	33 c0		 xor	 eax, eax
  0179d	b9 10 00 00 00	 mov	 ecx, 16
  017a2	f3 aa		 rep stosb

; 6700 :         addr6.s6_addr[0] = 0xFE;

  017a4	b8 01 00 00 00	 mov	 eax, 1
  017a9	48 6b c0 00	 imul	 rax, rax, 0
  017ad	c6 84 04 98 01
	00 00 fe	 mov	 BYTE PTR addr6$[rsp+rax], 254 ; 000000feH

; 6701 :         addr6.s6_addr[1] = 0x80;

  017b5	b8 01 00 00 00	 mov	 eax, 1
  017ba	48 6b c0 01	 imul	 rax, rax, 1
  017be	c6 84 04 98 01
	00 00 80	 mov	 BYTE PTR addr6$[rsp+rax], 128 ; 00000080H

; 6702 :         if (memcmp( pMPC_PIXwr->ipaddr, &addr6, 8 ) == 0)

  017c6	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PIXwr$[rsp]
  017cb	48 83 c0 08	 add	 rax, 8
  017cf	41 b8 08 00 00
	00		 mov	 r8d, 8
  017d5	48 8d 94 24 98
	01 00 00	 lea	 rdx, QWORD PTR addr6$[rsp]
  017dd	48 8b c8	 mov	 rcx, rax
  017e0	e8 00 00 00 00	 call	 memcmp
  017e5	85 c0		 test	 eax, eax
  017e7	75 0b		 jne	 SHORT $LN108@write_rrh_

; 6703 :             fLL = TRUE;

  017e9	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fLL$[rsp], 1
$LN108@write_rrh_:

; 6704 : 
; 6705 :         //
; 6706 :         if (!fLL)

  017f4	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR fLL$[rsp], 0
  017fc	0f 85 25 01 00
	00		 jne	 $LN109@write_rrh_

; 6707 :         {
; 6708 :             // The y-side has told us about our IPv6 address.
; 6709 :             // Remember the activation status.
; 6710 :             pPTPBLK->bActivate6 |= HEANSWEREDMY_ADDRESS;

  01802	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01807	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  0180e	83 c8 01	 or	 eax, 1
  01811	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01816	88 81 85 03 00
	00		 mov	 BYTE PTR [rcx+901], al

; 6711 : 
; 6712 :             // Check whether the connection is active.
; 6713 :             if (pPTPBLK->bActivate6 == WEAREACTIVE)

  0181c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01821	0f b6 80 85 03
	00 00		 movzx	 eax, BYTE PTR [rax+901]
  01828	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0182d	0f 85 ef 00 00
	00		 jne	 $LN111@write_rrh_

; 6714 :             {
; 6715 :                 // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6716 :                 WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  01833	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01838	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  0183e	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv968[rsp], rax
  01846	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0184e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01852	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv971[rsp], ecx
  01859	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01861	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  01865	d1 fa		 sar	 edx, 1
  01867	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv975[rsp], edx
  0186e	b9 01 00 00 00	 mov	 ecx, 1
  01873	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01879	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv968[rsp]
  01881	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01886	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv971[rsp]
  0188d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01891	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv975[rsp]
  01898	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0189c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172362
  018a3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  018a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172363
  018af	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  018b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018b9	41 b9 03 00 00
	00		 mov	 r9d, 3
  018bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172364
  018c6	ba 3d 1a 00 00	 mov	 edx, 6717		; 00001a3dH
  018cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172365
  018d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6717 :                     pPTPBLK->szGuestIPAddr6 );
; 6718 :                 pPTPBLK->fActive6 = TRUE;

  018d8	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  018dd	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  018e0	83 c8 10	 or	 eax, 16
  018e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  018e8	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6719 :                 pPTPBLK->bActivate6 = 0x00;

  018eb	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  018f0	c6 80 85 03 00
	00 00		 mov	 BYTE PTR [rax+901], 0

; 6720 :                 pPTPBLK->bTerminate6 = 0x00;

  018f7	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  018fc	c6 80 88 03 00
	00 00		 mov	 BYTE PTR [rax+904], 0

; 6721 :                 if (pPTPBLK->fActiveLL6)

  01903	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01908	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0190b	c1 e8 05	 shr	 eax, 5
  0190e	83 e0 01	 and	 eax, 1
  01911	85 c0		 test	 eax, eax
  01913	74 0d		 je	 SHORT $LN112@write_rrh_

; 6722 :                     build_8108_icmpv6_packets( pDEVBLK );

  01915	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0191d	e8 00 00 00 00	 call	 build_8108_icmpv6_packets
$LN112@write_rrh_:
$LN111@write_rrh_:

; 6723 :             }
; 6724 :         }

  01922	e9 20 01 00 00	 jmp	 $LN110@write_rrh_
$LN109@write_rrh_:

; 6725 :         else
; 6726 :         {
; 6727 :             // The y-side has told us about our Link Local address.
; 6728 :             // Remember the activation status.
; 6729 :             pPTPBLK->bActivateLL6 |= HEANSWEREDMY_ADDRESS;

  01927	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0192c	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  01933	83 c8 01	 or	 eax, 1
  01936	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0193b	88 81 86 03 00
	00		 mov	 BYTE PTR [rcx+902], al

; 6730 : 
; 6731 :             // Check whether the connection is active.
; 6732 :             if (pPTPBLK->bActivateLL6 == WEAREACTIVE)

  01941	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01946	0f b6 80 86 03
	00 00		 movzx	 eax, BYTE PTR [rax+902]
  0194d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01952	0f 85 ef 00 00
	00		 jne	 $LN113@write_rrh_

; 6733 :             {
; 6734 :                 // HHC03915 "%1d:%04X PTP: Connection active to guest IP address '%s'"
; 6735 :                 WRMSG(HHC03915, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  01958	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0195d	48 05 a0 02 00
	00		 add	 rax, 672		; 000002a0H
  01963	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv1004[rsp], rax
  0196b	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01973	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01977	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR tv1007[rsp], ecx
  0197e	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01986	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0198a	d1 fa		 sar	 edx, 1
  0198c	89 94 24 e4 00
	00 00		 mov	 DWORD PTR tv1011[rsp], edx
  01993	b9 01 00 00 00	 mov	 ecx, 1
  01998	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0199e	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv1004[rsp]
  019a6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  019ab	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv1007[rsp]
  019b2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  019b6	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv1011[rsp]
  019bd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  019c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172368
  019c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172369
  019d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  019d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019de	41 b9 03 00 00
	00		 mov	 r9d, 3
  019e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172370
  019eb	ba 50 1a 00 00	 mov	 edx, 6736		; 00001a50H
  019f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172371
  019f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6736 :                     pPTPBLK->szGuestLLAddr6 );
; 6737 :                 pPTPBLK->fActiveLL6 = TRUE;

  019fd	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01a02	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01a05	83 c8 20	 or	 eax, 32			; 00000020H
  01a08	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01a0d	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6738 :                 pPTPBLK->bActivateLL6 = 0x00;

  01a10	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01a15	c6 80 86 03 00
	00 00		 mov	 BYTE PTR [rax+902], 0

; 6739 :                 pPTPBLK->bTerminateLL6 = 0x00;

  01a1c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01a21	c6 80 89 03 00
	00 00		 mov	 BYTE PTR [rax+905], 0

; 6740 :                 if (pPTPBLK->fActive6)

  01a28	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01a2d	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01a30	c1 e8 04	 shr	 eax, 4
  01a33	83 e0 01	 and	 eax, 1
  01a36	85 c0		 test	 eax, eax
  01a38	74 0d		 je	 SHORT $LN114@write_rrh_

; 6741 :                     build_8108_icmpv6_packets( pDEVBLK );

  01a3a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01a42	e8 00 00 00 00	 call	 build_8108_icmpv6_packets
$LN114@write_rrh_:
$LN113@write_rrh_:
$LN110@write_rrh_:

; 6742 :             }
; 6743 :         }
; 6744 : #endif /* defined(ENABLE_IPV6) */
; 6745 : 
; 6746 :         break;

  01a47	e9 60 06 00 00	 jmp	 $LN2@write_rrh_
$LN115@write_rrh_:

; 6747 : 
; 6748 :     case WILL_YOU_STOP_IPV4:
; 6749 : 
; 6750 :         // Display various information, maybe
; 6751 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  01a4c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01a51	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  01a54	83 e0 10	 and	 eax, 16
  01a57	85 c0		 test	 eax, eax
  01a59	74 15		 je	 SHORT $LN116@write_rrh_

; 6752 :         {
; 6753 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) Will you stop IPv4?" );

  01a5b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172375
  01a62	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01a6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN116@write_rrh_:

; 6754 :         }
; 6755 : 
; 6756 :         // Remember the termination status.
; 6757 :         pPTPBLK->bTerminate4 |= HEASKEDME_STOP;

  01a70	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01a75	0f b6 80 87 03
	00 00		 movzx	 eax, BYTE PTR [rax+903]
  01a7c	0f ba e8 07	 bts	 eax, 7
  01a80	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01a85	88 81 87 03 00
	00		 mov	 BYTE PTR [rcx+903], al

; 6758 : 
; 6759 :         // Build RRH 0xC108 PIX 0x0180 to yTokenUlpConnection (I will stop IPv4)
; 6760 :         pPTPHDRr1 = build_C108_i_will_stop_4( pDEVBLK, pMPC_PIXwr );

  01a8b	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  01a90	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01a98	e8 00 00 00 00	 call	 build_C108_i_will_stop_4
  01a9d	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6761 :         if (!pPTPHDRr1)

  01aa2	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  01aa8	75 05		 jne	 SHORT $LN117@write_rrh_

; 6762 :             break;

  01aaa	e9 fd 05 00 00	 jmp	 $LN2@write_rrh_
$LN117@write_rrh_:

; 6763 : 
; 6764 :         // Build RRH 0xC108 PIX 0x0180 to yTokenUlpConnection (Will you stop IPv4)
; 6765 :         pPTPHDRr2 = build_C108_will_you_stop_4( pDEVBLK );

  01aaf	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01ab7	e8 00 00 00 00	 call	 build_C108_will_you_stop_4
  01abc	48 89 44 24 78	 mov	 QWORD PTR pPTPHDRr2$[rsp], rax

; 6766 :         if (!pPTPHDRr2)

  01ac1	48 83 7c 24 78
	00		 cmp	 QWORD PTR pPTPHDRr2$[rsp], 0
  01ac7	75 10		 jne	 SHORT $LN118@write_rrh_

; 6767 :         {
; 6768 :             free( pPTPHDRr1 );

  01ac9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPHDRr1$[rsp]
  01ace	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6769 :             break;

  01ad4	e9 d3 05 00 00	 jmp	 $LN2@write_rrh_
$LN118@write_rrh_:

; 6770 :         }
; 6771 : 
; 6772 :         // Remember the termination status.
; 6773 :         pPTPBLK->bTerminate4 |= IANSWEREDHIM_STOP;

  01ad9	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01ade	0f b6 80 87 03
	00 00		 movzx	 eax, BYTE PTR [rax+903]
  01ae5	83 c8 40	 or	 eax, 64			; 00000040H
  01ae8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01aed	88 81 87 03 00
	00		 mov	 BYTE PTR [rcx+903], al

; 6774 :         pPTPBLK->bTerminate4 |= IASKEDHIM_STOP;

  01af3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01af8	0f b6 80 87 03
	00 00		 movzx	 eax, BYTE PTR [rax+903]
  01aff	83 c8 20	 or	 eax, 32			; 00000020H
  01b02	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01b07	88 81 87 03 00
	00		 mov	 BYTE PTR [rcx+903], al

; 6775 : 
; 6776 :         // Add PTPHDRs to chain.
; 6777 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  01b0d	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  01b12	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01b17	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6778 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr2 );

  01b1c	48 8b 54 24 78	 mov	 rdx, QWORD PTR pPTPHDRr2$[rsp]
  01b21	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01b26	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6779 : 
; 6780 :         break;

  01b2b	e9 7c 05 00 00	 jmp	 $LN2@write_rrh_
$LN119@write_rrh_:

; 6781 : 
; 6782 :     case WILL_YOU_STOP_IPV6:
; 6783 : 
; 6784 :         // Display various information, maybe
; 6785 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  01b30	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01b35	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  01b38	83 e0 10	 and	 eax, 16
  01b3b	85 c0		 test	 eax, eax
  01b3d	74 15		 je	 SHORT $LN120@write_rrh_

; 6786 :         {
; 6787 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) Will you stop IPv6?" );

  01b3f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172380
  01b46	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01b4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN120@write_rrh_:

; 6788 :         }
; 6789 : 
; 6790 :         // Remember the termination status.
; 6791 :         pPTPBLK->bTerminate6 |= HEASKEDME_STOP;

  01b54	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01b59	0f b6 80 88 03
	00 00		 movzx	 eax, BYTE PTR [rax+904]
  01b60	0f ba e8 07	 bts	 eax, 7
  01b64	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01b69	88 81 88 03 00
	00		 mov	 BYTE PTR [rcx+904], al

; 6792 :         pPTPBLK->bTerminateLL6 |= HEASKEDME_STOP;

  01b6f	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01b74	0f b6 80 89 03
	00 00		 movzx	 eax, BYTE PTR [rax+905]
  01b7b	0f ba e8 07	 bts	 eax, 7
  01b7f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01b84	88 81 89 03 00
	00		 mov	 BYTE PTR [rcx+905], al

; 6793 : 
; 6794 :         // Build RRH 0xC108 PIX 0x0180 to yTokenUlpConnection (I will stop IPv6)
; 6795 :         pPTPHDRr1 = build_C108_i_will_stop_6( pDEVBLK, pMPC_PIXwr );

  01b8a	48 8b 54 24 60	 mov	 rdx, QWORD PTR pMPC_PIXwr$[rsp]
  01b8f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01b97	e8 00 00 00 00	 call	 build_C108_i_will_stop_6
  01b9c	48 89 44 24 58	 mov	 QWORD PTR pPTPHDRr1$[rsp], rax

; 6796 :         if (!pPTPHDRr1)

  01ba1	48 83 7c 24 58
	00		 cmp	 QWORD PTR pPTPHDRr1$[rsp], 0
  01ba7	75 05		 jne	 SHORT $LN121@write_rrh_

; 6797 :             break;

  01ba9	e9 fe 04 00 00	 jmp	 $LN2@write_rrh_
$LN121@write_rrh_:

; 6798 : 
; 6799 :         // Build RRH 0xC108 PIX 0x0180 to yTokenUlpConnection (Will you stop IPv6)
; 6800 :         pPTPHDRr2 = build_C108_will_you_stop_6( pDEVBLK );

  01bae	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01bb6	e8 00 00 00 00	 call	 build_C108_will_you_stop_6
  01bbb	48 89 44 24 78	 mov	 QWORD PTR pPTPHDRr2$[rsp], rax

; 6801 :         if (!pPTPHDRr2)

  01bc0	48 83 7c 24 78
	00		 cmp	 QWORD PTR pPTPHDRr2$[rsp], 0
  01bc6	75 10		 jne	 SHORT $LN122@write_rrh_

; 6802 :         {
; 6803 :             free( pPTPHDRr1 );

  01bc8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPHDRr1$[rsp]
  01bcd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6804 :             break;

  01bd3	e9 d4 04 00 00	 jmp	 $LN2@write_rrh_
$LN122@write_rrh_:

; 6805 :         }
; 6806 : 
; 6807 :         // Remember the termination status.
; 6808 :         pPTPBLK->bTerminate6 |= IANSWEREDHIM_STOP;

  01bd8	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01bdd	0f b6 80 88 03
	00 00		 movzx	 eax, BYTE PTR [rax+904]
  01be4	83 c8 40	 or	 eax, 64			; 00000040H
  01be7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01bec	88 81 88 03 00
	00		 mov	 BYTE PTR [rcx+904], al

; 6809 :         pPTPBLK->bTerminate6 |= IASKEDHIM_STOP;

  01bf2	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01bf7	0f b6 80 88 03
	00 00		 movzx	 eax, BYTE PTR [rax+904]
  01bfe	83 c8 20	 or	 eax, 32			; 00000020H
  01c01	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01c06	88 81 88 03 00
	00		 mov	 BYTE PTR [rcx+904], al

; 6810 :         pPTPBLK->bTerminateLL6 |= IANSWEREDHIM_STOP;

  01c0c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01c11	0f b6 80 89 03
	00 00		 movzx	 eax, BYTE PTR [rax+905]
  01c18	83 c8 40	 or	 eax, 64			; 00000040H
  01c1b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01c20	88 81 89 03 00
	00		 mov	 BYTE PTR [rcx+905], al

; 6811 :         pPTPBLK->bTerminateLL6 |= IASKEDHIM_STOP;

  01c26	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01c2b	0f b6 80 89 03
	00 00		 movzx	 eax, BYTE PTR [rax+905]
  01c32	83 c8 20	 or	 eax, 32			; 00000020H
  01c35	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01c3a	88 81 89 03 00
	00		 mov	 BYTE PTR [rcx+905], al

; 6812 : 
; 6813 :         // Add PTPHDRs to chain.
; 6814 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr1 );

  01c40	48 8b 54 24 58	 mov	 rdx, QWORD PTR pPTPHDRr1$[rsp]
  01c45	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01c4a	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6815 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRr2 );

  01c4f	48 8b 54 24 78	 mov	 rdx, QWORD PTR pPTPHDRr2$[rsp]
  01c54	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01c59	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 6816 : 
; 6817 :         break;

  01c5e	e9 49 04 00 00	 jmp	 $LN2@write_rrh_
$LN123@write_rrh_:

; 6818 : 
; 6819 :     case I_WILL_STOP_IPV4:
; 6820 : 
; 6821 :         // Display various information, maybe
; 6822 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  01c63	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01c68	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  01c6b	83 e0 10	 and	 eax, 16
  01c6e	85 c0		 test	 eax, eax
  01c70	74 15		 je	 SHORT $LN124@write_rrh_

; 6823 :         {
; 6824 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) I will stop IPv4" );

  01c72	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172385
  01c79	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01c81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN124@write_rrh_:

; 6825 :         }
; 6826 : 
; 6827 :         // Remember the termination status.
; 6828 :         pPTPBLK->bTerminate4 |= HEANSWEREDME_STOP;

  01c87	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01c8c	0f b6 80 87 03
	00 00		 movzx	 eax, BYTE PTR [rax+903]
  01c93	83 c8 10	 or	 eax, 16
  01c96	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01c9b	88 81 87 03 00
	00		 mov	 BYTE PTR [rcx+903], al

; 6829 : 
; 6830 :         // Check whether the connection is terminated.
; 6831 :         if (pPTPBLK->bTerminate4 == WEARETERMINATED)

  01ca1	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01ca6	0f b6 80 87 03
	00 00		 movzx	 eax, BYTE PTR [rax+903]
  01cad	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  01cb2	0f 85 e6 00 00
	00		 jne	 $LN125@write_rrh_

; 6832 :         {
; 6833 :             // The guest OS on the y-side has stopped the device.
; 6834 :             if (pPTPBLK->fActive4)

  01cb8	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01cbd	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01cc0	c1 e8 03	 shr	 eax, 3
  01cc3	83 e0 01	 and	 eax, 1
  01cc6	85 c0		 test	 eax, eax
  01cc8	0f 84 a5 00 00
	00		 je	 $LN126@write_rrh_

; 6835 :             {
; 6836 :                 // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 6837 :                 WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  01cce	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01cd3	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  01cd9	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv1128[rsp], rax
  01ce1	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01ce9	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01ced	89 8c 24 e8 00
	00 00		 mov	 DWORD PTR tv1131[rsp], ecx
  01cf4	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01cfc	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  01d00	d1 fa		 sar	 edx, 1
  01d02	89 94 24 ec 00
	00 00		 mov	 DWORD PTR tv1135[rsp], edx
  01d09	b9 01 00 00 00	 mov	 ecx, 1
  01d0e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01d14	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv1128[rsp]
  01d1c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01d21	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv1131[rsp]
  01d28	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01d2c	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv1135[rsp]
  01d33	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01d37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172388
  01d3e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01d43	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172389
  01d4a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01d4f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d54	41 b9 03 00 00
	00		 mov	 r9d, 3
  01d5a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172390
  01d61	ba b6 1a 00 00	 mov	 edx, 6838		; 00001ab6H
  01d66	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172391
  01d6d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN126@write_rrh_:

; 6838 :                     pPTPBLK->szGuestIPAddr4 );
; 6839 :             }
; 6840 :             pPTPBLK->fActive4 = FALSE;

  01d73	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01d78	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01d7b	83 e0 f7	 and	 eax, -9			; fffffff7H
  01d7e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01d83	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6841 :             pPTPBLK->bActivate4 = 0x00;

  01d86	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01d8b	c6 80 84 03 00
	00 00		 mov	 BYTE PTR [rax+900], 0

; 6842 :             pPTPBLK->bTerminate4 = 0x00;

  01d92	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01d97	c6 80 87 03 00
	00 00		 mov	 BYTE PTR [rax+903], 0
$LN125@write_rrh_:

; 6843 :         }
; 6844 : 
; 6845 :         break;

  01d9e	e9 09 03 00 00	 jmp	 $LN2@write_rrh_
$LN127@write_rrh_:

; 6846 : 
; 6847 :     case I_WILL_STOP_IPV6:
; 6848 : 
; 6849 :         // Display various information, maybe
; 6850 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  01da3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01da8	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  01dab	83 e0 10	 and	 eax, 16
  01dae	85 c0		 test	 eax, eax
  01db0	74 15		 je	 SHORT $LN128@write_rrh_

; 6851 :         {
; 6852 :             mpc_display_description( pDEVBLK, "In RRH 0xC108 (UlpComm) I will stop IPv6" );

  01db2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172394
  01db9	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01dc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN128@write_rrh_:

; 6853 :         }
; 6854 : 
; 6855 :         // Remember the termination status.
; 6856 :         pPTPBLK->bTerminate6 |= HEANSWEREDME_STOP;

  01dc7	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01dcc	0f b6 80 88 03
	00 00		 movzx	 eax, BYTE PTR [rax+904]
  01dd3	83 c8 10	 or	 eax, 16
  01dd6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01ddb	88 81 88 03 00
	00		 mov	 BYTE PTR [rcx+904], al

; 6857 :         pPTPBLK->bTerminateLL6 |= HEANSWEREDME_STOP;

  01de1	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01de6	0f b6 80 89 03
	00 00		 movzx	 eax, BYTE PTR [rax+905]
  01ded	83 c8 10	 or	 eax, 16
  01df0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01df5	88 81 89 03 00
	00		 mov	 BYTE PTR [rcx+905], al

; 6858 : 
; 6859 :         // Check whether the connection is terminated.
; 6860 :         if (pPTPBLK->bTerminate6 == WEARETERMINATED)

  01dfb	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01e00	0f b6 80 88 03
	00 00		 movzx	 eax, BYTE PTR [rax+904]
  01e07	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  01e0c	0f 85 e6 00 00
	00		 jne	 $LN129@write_rrh_

; 6861 :         {
; 6862 :             // The guest OS on the y-side has stopped the device.
; 6863 : #if defined(ENABLE_IPV6)
; 6864 :             if (pPTPBLK->fActive6)

  01e12	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01e17	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01e1a	c1 e8 04	 shr	 eax, 4
  01e1d	83 e0 01	 and	 eax, 1
  01e20	85 c0		 test	 eax, eax
  01e22	0f 84 a5 00 00
	00		 je	 $LN130@write_rrh_

; 6865 :             {
; 6866 :                 // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 6867 :                 WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  01e28	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01e2d	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  01e33	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv1205[rsp], rax
  01e3b	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01e43	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01e47	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR tv1208[rsp], ecx
  01e4e	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01e56	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  01e5a	d1 fa		 sar	 edx, 1
  01e5c	89 94 24 f4 00
	00 00		 mov	 DWORD PTR tv1212[rsp], edx
  01e63	b9 01 00 00 00	 mov	 ecx, 1
  01e68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01e6e	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv1205[rsp]
  01e76	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01e7b	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv1208[rsp]
  01e82	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01e86	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv1212[rsp]
  01e8d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01e91	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172397
  01e98	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172398
  01ea4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01ea9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01eae	41 b9 03 00 00
	00		 mov	 r9d, 3
  01eb4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172399
  01ebb	ba d4 1a 00 00	 mov	 edx, 6868		; 00001ad4H
  01ec0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172400
  01ec7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN130@write_rrh_:

; 6868 :                     pPTPBLK->szGuestIPAddr6 );
; 6869 :             }
; 6870 : #endif /* defined(ENABLE_IPV6) */
; 6871 :             pPTPBLK->fActive6 = FALSE;

  01ecd	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01ed2	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01ed5	83 e0 ef	 and	 eax, -17		; ffffffefH
  01ed8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01edd	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6872 :             pPTPBLK->bActivate6 = 0x00;

  01ee0	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01ee5	c6 80 85 03 00
	00 00		 mov	 BYTE PTR [rax+901], 0

; 6873 :             pPTPBLK->bTerminate6 = 0x00;

  01eec	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01ef1	c6 80 88 03 00
	00 00		 mov	 BYTE PTR [rax+904], 0
$LN129@write_rrh_:

; 6874 :         }
; 6875 :         if (pPTPBLK->bTerminateLL6 == WEARETERMINATED)

  01ef8	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01efd	0f b6 80 89 03
	00 00		 movzx	 eax, BYTE PTR [rax+905]
  01f04	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  01f09	0f 85 e6 00 00
	00		 jne	 $LN131@write_rrh_

; 6876 :         {
; 6877 :             // The guest OS on the y-side has stopped the device.
; 6878 : #if defined(ENABLE_IPV6)
; 6879 :             if (pPTPBLK->fActiveLL6)

  01f0f	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01f14	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01f17	c1 e8 05	 shr	 eax, 5
  01f1a	83 e0 01	 and	 eax, 1
  01f1d	85 c0		 test	 eax, eax
  01f1f	0f 84 a5 00 00
	00		 je	 $LN132@write_rrh_

; 6880 :             {
; 6881 :                 // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 6882 :                 WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  01f25	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01f2a	48 05 a0 02 00
	00		 add	 rax, 672		; 000002a0H
  01f30	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv1235[rsp], rax
  01f38	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01f40	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01f44	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR tv1238[rsp], ecx
  01f4b	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01f53	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  01f57	d1 fa		 sar	 edx, 1
  01f59	89 94 24 fc 00
	00 00		 mov	 DWORD PTR tv1242[rsp], edx
  01f60	b9 01 00 00 00	 mov	 ecx, 1
  01f65	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01f6b	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv1235[rsp]
  01f73	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01f78	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv1238[rsp]
  01f7f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01f83	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv1242[rsp]
  01f8a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01f8e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172403
  01f95	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01f9a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172404
  01fa1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01fa6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01fab	41 b9 03 00 00
	00		 mov	 r9d, 3
  01fb1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172405
  01fb8	ba e3 1a 00 00	 mov	 edx, 6883		; 00001ae3H
  01fbd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172406
  01fc4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN132@write_rrh_:

; 6883 :                     pPTPBLK->szGuestLLAddr6 );
; 6884 :             }
; 6885 : #endif /* defined(ENABLE_IPV6) */
; 6886 :             pPTPBLK->fActiveLL6 = FALSE;

  01fca	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01fcf	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01fd2	83 e0 df	 and	 eax, -33		; ffffffdfH
  01fd5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01fda	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 6887 :             pPTPBLK->bActivateLL6 = 0x00;

  01fdd	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01fe2	c6 80 86 03 00
	00 00		 mov	 BYTE PTR [rax+902], 0

; 6888 :             pPTPBLK->bTerminateLL6 = 0x00;

  01fe9	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01fee	c6 80 89 03 00
	00 00		 mov	 BYTE PTR [rax+905], 0
$LN131@write_rrh_:

; 6889 :         }
; 6890 : 
; 6891 :         break;

  01ff5	e9 b2 00 00 00	 jmp	 $LN2@write_rrh_
$LN133@write_rrh_:

; 6892 : 
; 6893 :     default:
; 6894 : 
; 6895 :         // HHC03936 "%1d:%04X PTP: Accept data contains unknown %s"
; 6896 :         WRMSG(HHC03936, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PIX" );

  01ffa	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  02002	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02006	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv1260[rsp], eax
  0200d	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  02015	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  02019	d1 f9		 sar	 ecx, 1
  0201b	89 8c 24 04 01
	00 00		 mov	 DWORD PTR tv1264[rsp], ecx
  02022	b9 01 00 00 00	 mov	 ecx, 1
  02027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0202d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172408
  02034	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02039	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv1260[rsp]
  02040	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02044	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv1264[rsp]
  0204b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0204f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172409
  02056	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0205b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172410
  02062	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02067	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0206c	41 b9 03 00 00
	00		 mov	 r9d, 3
  02072	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172411
  02079	ba f0 1a 00 00	 mov	 edx, 6896		; 00001af0H
  0207e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172412
  02085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6897 :         mpc_display_rrh_and_pix( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  0208b	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0208e	4c 8b 84 24 10
	02 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  02096	48 8b 94 24 08
	02 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  0209e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  020a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_pix
$LN2@write_rrh_:

; 6898 : 
; 6899 :         break;
; 6900 : 
; 6901 :     }
; 6902 : 
; 6903 :     return 0;

  020ac	33 c0		 xor	 eax, eax

; 6904 : }   /* End function  write_rrh_C108() */

  020ae	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  020b6	48 33 cc	 xor	 rcx, rsp
  020b9	e8 00 00 00 00	 call	 __security_check_cookie
  020be	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  020c5	5f		 pop	 rdi
  020c6	5e		 pop	 rsi
  020c7	c3		 ret	 0
$LN135@write_rrh_:
  020c8	00 00 00 00	 DD	 $LN41@write_rrh_
  020cc	00 00 00 00	 DD	 $LN47@write_rrh_
  020d0	00 00 00 00	 DD	 $LN54@write_rrh_
  020d4	00 00 00 00	 DD	 $LN57@write_rrh_
  020d8	00 00 00 00	 DD	 $LN63@write_rrh_
  020dc	00 00 00 00	 DD	 $LN79@write_rrh_
  020e0	00 00 00 00	 DD	 $LN103@write_rrh_
  020e4	00 00 00 00	 DD	 $LN106@write_rrh_
  020e8	00 00 00 00	 DD	 $LN115@write_rrh_
  020ec	00 00 00 00	 DD	 $LN119@write_rrh_
  020f0	00 00 00 00	 DD	 $LN123@write_rrh_
  020f4	00 00 00 00	 DD	 $LN127@write_rrh_
write_rrh_C108 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uOffPH$ = 80
iWhat$ = 84
uOffData$ = 88
tv95 = 92
tv135 = 96
tv139 = 100
pMPC_PUKwr$ = 104
pPTPBLK$ = 112
pPTPATH$ = 120
pMPC_PHwr$ = 128
pDEVBLK$ = 160
pMPC_THwr$ = 168
pMPC_RRHwr$ = 176
write_rrh_C17E PROC

; 5940 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 5941 :     PTPATH*    pPTPATH   = pDEVBLK->dev_data;

  00016	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00025	48 89 44 24 78	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 5942 :     PTPBLK*    pPTPBLK   = pPTPATH->pPTPBLK;

  0002a	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 89 44 24 70	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 5943 :     MPC_PH*    pMPC_PHwr;                      // MPC_PH being written
; 5944 :     MPC_PUK*   pMPC_PUKwr;                     // MPC_PUK being written
; 5945 : //  MPC_PUS*   pMPC_PUSwr;                     // MPC_PUSs being written
; 5946 :     U16        uOffPH;
; 5947 : //  U32        uLenData;
; 5948 :     U32        uOffData;
; 5949 :     int        iWhat;
; 5950 : #define PUK_4501      1
; 5951 : 
; 5952 : 
; 5953 :     // Point to the MPC_PH.
; 5954 :     FETCH_HW( uOffPH, pMPC_RRHwr->offph );

  00037	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRHwr$[rsp]
  0003f	48 83 c0 10	 add	 rax, 16
  00043	48 8b c8	 mov	 rcx, rax
  00046	e8 00 00 00 00	 call	 fetch_hw_noswap
  0004b	0f b7 c8	 movzx	 ecx, ax
  0004e	e8 00 00 00 00	 call	 _byteswap_ushort
  00053	66 89 44 24 50	 mov	 WORD PTR uOffPH$[rsp], ax

; 5955 :     pMPC_PHwr = (MPC_PH*)((BYTE*)pMPC_RRHwr + uOffPH);

  00058	0f b7 44 24 50	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0005d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  00065	48 03 c8	 add	 rcx, rax
  00068	48 8b c1	 mov	 rax, rcx
  0006b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pMPC_PHwr$[rsp], rax

; 5956 : 
; 5957 :     // Get the length of and point to the data referenced by the
; 5958 :     // MPC_PH. The data contain a MPC_PUK and one or more MPC_PUSs.
; 5959 : //  FETCH_F3( uLenData, pMPC_PH->lendata );
; 5960 :     FETCH_FW( uOffData, pMPC_PHwr->offdata );

  00073	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PHwr$[rsp]
  0007b	48 83 c0 04	 add	 rax, 4
  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 fetch_fw_noswap
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 _byteswap_ulong
  0008e	89 44 24 58	 mov	 DWORD PTR uOffData$[rsp], eax

; 5961 :     pMPC_PUKwr = (MPC_PUK*)((BYTE*)pMPC_THwr + uOffData);

  00092	8b 44 24 58	 mov	 eax, DWORD PTR uOffData$[rsp]
  00096	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pMPC_THwr$[rsp]
  0009e	48 03 c8	 add	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 68	 mov	 QWORD PTR pMPC_PUKwr$[rsp], rax

; 5962 : 
; 5963 :     // Decide what the PUK contains.
; 5964 :     iWhat = UNKNOWN_PUK;

  000a9	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 0

; 5965 :     if (memcmp( pMPC_RRHwr->token, pPTPBLK->xTokenIssuerRm, MPC_TOKEN_LENGTH ) == 0)

  000b1	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000b6	48 05 3d 03 00
	00		 add	 rax, 829		; 0000033dH
  000bc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  000c4	48 83 c1 18	 add	 rcx, 24
  000c8	41 b8 04 00 00
	00		 mov	 r8d, 4
  000ce	48 8b d0	 mov	 rdx, rax
  000d1	e8 00 00 00 00	 call	 memcmp
  000d6	85 c0		 test	 eax, eax
  000d8	75 24		 jne	 SHORT $LN4@write_rrh_

; 5966 :     {
; 5967 :         if (pMPC_PUKwr->what == PUK_WHAT_45)

  000da	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  000df	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000e3	83 f8 45	 cmp	 eax, 69			; 00000045H
  000e6	75 16		 jne	 SHORT $LN5@write_rrh_

; 5968 :         {
; 5969 :             if (pMPC_PUKwr->type == PUK_TYPE_01)

  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  000ed	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000f1	83 f8 01	 cmp	 eax, 1
  000f4	75 08		 jne	 SHORT $LN6@write_rrh_

; 5970 :             {
; 5971 :                 iWhat = PUK_4501;

  000f6	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 1
$LN6@write_rrh_:
$LN5@write_rrh_:
$LN4@write_rrh_:

; 5972 :             }
; 5973 :         }
; 5974 :     }
; 5975 : 
; 5976 :     // Process the PUK.
; 5977 :     switch( iWhat )

  000fe	8b 44 24 54	 mov	 eax, DWORD PTR iWhat$[rsp]
  00102	89 44 24 5c	 mov	 DWORD PTR tv95[rsp], eax
  00106	83 7c 24 5c 01	 cmp	 DWORD PTR tv95[rsp], 1
  0010b	74 02		 je	 SHORT $LN7@write_rrh_
  0010d	eb 29		 jmp	 SHORT $LN9@write_rrh_
$LN7@write_rrh_:

; 5978 :     {
; 5979 : 
; 5980 :     // PUK 0x4501 to xTokenIssuerRm
; 5981 :     // The MPC_PUK should be followed by two MPC_PUSs, the first a type
; 5982 :     // 0x0409 and the second a type 0x0404.
; 5983 :     case PUK_4501:
; 5984 : 
; 5985 :         // Display various information, maybe
; 5986 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0010f	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00114	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00117	83 e0 10	 and	 eax, 16
  0011a	85 c0		 test	 eax, eax
  0011c	74 15		 je	 SHORT $LN8@write_rrh_

; 5987 :         {
; 5988 :             mpc_display_description( pDEVBLK, "In RRH 0xC17E (Issuer)" );

  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172161
  00125	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN8@write_rrh_:

; 5989 :         }
; 5990 : 
; 5991 :         break;

  00133	e9 a6 00 00 00	 jmp	 $LN2@write_rrh_
$LN9@write_rrh_:

; 5992 : 
; 5993 :     // Unknown PUK
; 5994 :     default:
; 5995 : 
; 5996 :         // HHC03936 "%1d:%04X PTP: Accept data contains unknown %s"
; 5997 :         WRMSG(HHC03936, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK" );

  00138	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00140	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00144	89 44 24 60	 mov	 DWORD PTR tv135[rsp], eax
  00148	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00150	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00154	d1 f9		 sar	 ecx, 1
  00156	89 4c 24 64	 mov	 DWORD PTR tv139[rsp], ecx
  0015a	b9 01 00 00 00	 mov	 ecx, 1
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172163
  0016c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00171	8b 4c 24 60	 mov	 ecx, DWORD PTR tv135[rsp]
  00175	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00179	8b 4c 24 64	 mov	 ecx, DWORD PTR tv139[rsp]
  0017d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172164
  00188	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172165
  00194	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00199	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019e	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172166
  001ab	ba 6d 17 00 00	 mov	 edx, 5997		; 0000176dH
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172167
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5998 :         mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  001bd	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  001c0	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  001c8	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  001d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk
$LN2@write_rrh_:

; 5999 : 
; 6000 :         break;
; 6001 : 
; 6002 :     }  /* switch( iWhat ) */
; 6003 : 
; 6004 :     return 0;

  001de	33 c0		 xor	 eax, eax

; 6005 : }   /* End function  write_rrh_C17E() */

  001e0	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001e7	c3		 ret	 0
write_rrh_C17E ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength4$ = 32
pMPC_RRHre$ = 40
uLength3$ = 48
pMPC_THre$ = 56
uLength1$ = 64
tv146 = 68
uLength2$ = 72
pMPC_PUKre$ = 80
pMPC_PUSre$ = 88
pPTPBLK$ = 96
pMPC_PHre$ = 104
pPTPHDRre$ = 112
pPTPATH$ = 120
pDEVBLK$ = 144
pMPC_RRHwr$ = 152
build_417E_dm_act PROC

; 5848 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 5849 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00011	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00019	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00020	48 89 44 24 78	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 5850 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00025	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 44 24 60	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 5851 :     U32        uLength1;
; 5852 :     U32        uLength2;
; 5853 :     U32        uLength3;
; 5854 :     U16        uLength4;
; 5855 :     PTPHDR*    pPTPHDRre;      // PTPHDR to be read
; 5856 :     MPC_TH*    pMPC_THre;      // MPC_TH follows PTPHDR
; 5857 :     MPC_RRH*   pMPC_RRHre;     // MPC_RRH follows MPC_TH
; 5858 :     MPC_PH*    pMPC_PHre;      // MPC_PH follows MPC_RRH
; 5859 :     MPC_PUK*   pMPC_PUKre;     // MPC_PUK follows MPC_PH
; 5860 :     MPC_PUS*   pMPC_PUSre;     // MPC_PUS follows MPC_PUK
; 5861 : 
; 5862 : 
; 5863 :     // Allocate a buffer in which the response will be build.
; 5864 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00032	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00037	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0003f	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00044	48 89 44 24 70	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 5865 :     if (!pPTPHDRre)

  00049	48 83 7c 24 70
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  0004f	75 07		 jne	 SHORT $LN2@build_417E

; 5866 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 c8 02 00 00	 jmp	 $LN1@build_417E
$LN2@build_417E:

; 5867 : 
; 5868 :     // Fix-up various lengths
; 5869 :     uLength4 = SIZE_PUS_04;                    // the MPC_PUS

  00058	b8 09 00 00 00	 mov	 eax, 9
  0005d	66 89 44 24 20	 mov	 WORD PTR uLength4$[rsp], ax

; 5870 :     uLength3 = SIZE_PUK + uLength4;            // the MPC_PUK and MPC_PUS (the data)

  00062	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength4$[rsp]
  00067	83 c0 0c	 add	 eax, 12
  0006a	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 5871 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;   // the MPC_TH/MPC_RRH/MPC_PH

  0006e	c7 44 24 48 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 5872 :     uLength1 = uLength2 + uLength3;            // the MPC_TH/MPC_RRH/MPC_PH and data

  00076	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  0007a	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength2$[rsp]
  0007e	03 c8		 add	 ecx, eax
  00080	8b c1		 mov	 eax, ecx
  00082	89 44 24 40	 mov	 DWORD PTR uLength1$[rsp], eax

; 5873 : 
; 5874 :     // Fix-up various pointers
; 5875 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00086	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0008b	48 83 c0 10	 add	 rax, 16
  0008f	48 89 44 24 38	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 5876 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  00094	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  00099	48 83 c0 14	 add	 rax, 20
  0009d	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 5877 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  000a7	48 83 c0 24	 add	 rax, 36			; 00000024H
  000ab	48 89 44 24 68	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 5878 :     pMPC_PUKre = (MPC_PUK*)((BYTE*)pMPC_PHre + SIZE_PH);

  000b0	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000b5	48 83 c0 08	 add	 rax, 8
  000b9	48 89 44 24 50	 mov	 QWORD PTR pMPC_PUKre$[rsp], rax

; 5879 :     pMPC_PUSre = (MPC_PUS*)((BYTE*)pMPC_PUKre + SIZE_PUK);

  000be	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  000c3	48 83 c0 0c	 add	 rax, 12
  000c7	48 89 44 24 58	 mov	 QWORD PTR pMPC_PUSre$[rsp], rax

; 5880 : 
; 5881 :     // Prepare PTPHDRre
; 5882 :     pPTPHDRre->iDataLen = uLength1;

  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000d1	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  000d5	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5883 : 
; 5884 :     // Prepare MPC_THre
; 5885 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  000d8	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  000dd	e8 00 00 00 00	 call	 _byteswap_ulong
  000e2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000e7	8b d0		 mov	 edx, eax
  000e9	e8 00 00 00 00	 call	 store_fw_noswap

; 5886 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  000ee	b9 14 00 00 00	 mov	 ecx, 20
  000f3	e8 00 00 00 00	 call	 _byteswap_ulong
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  000fd	48 83 c1 08	 add	 rcx, 8
  00101	8b d0		 mov	 edx, eax
  00103	e8 00 00 00 00	 call	 store_fw_noswap

; 5887 :     STORE_FW( pMPC_THre->length, uLength1 );

  00108	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0010c	e8 00 00 00 00	 call	 _byteswap_ulong
  00111	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00116	48 83 c1 0c	 add	 rcx, 12
  0011a	8b d0		 mov	 edx, eax
  0011c	e8 00 00 00 00	 call	 store_fw_noswap

; 5888 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00121	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00125	e8 00 00 00 00	 call	 _byteswap_ushort
  0012a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0012f	48 83 c1 10	 add	 rcx, 16
  00133	0f b7 d0	 movzx	 edx, ax
  00136	e8 00 00 00 00	 call	 store_hw_noswap

; 5889 :     STORE_HW( pMPC_THre->numrrh, 1 );

  0013b	66 b9 01 00	 mov	 cx, 1
  0013f	e8 00 00 00 00	 call	 _byteswap_ushort
  00144	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00149	48 83 c1 12	 add	 rcx, 18
  0014d	0f b7 d0	 movzx	 edx, ax
  00150	e8 00 00 00 00	 call	 store_hw_noswap

; 5890 : 
; 5891 :     // Prepare MPC_RRHre
; 5892 :     pMPC_RRHre->type = RRH_TYPE_ULP;

  00155	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0015a	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 5893 :     pMPC_RRHre->proto = PROTOCOL_UNKNOWN;

  0015e	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00163	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5894 :     STORE_HW( pMPC_RRHre->numph, 1 );

  00167	66 b9 01 00	 mov	 cx, 1
  0016b	e8 00 00 00 00	 call	 _byteswap_ushort
  00170	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00175	48 83 c1 06	 add	 rcx, 6
  00179	0f b7 d0	 movzx	 edx, ax
  0017c	e8 00 00 00 00	 call	 store_hw_noswap

; 5895 :     STORE_FW( pMPC_RRHre->seqnum, ++pPTPBLK->uSeqNumCm );

  00181	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00186	8b 80 7e 03 00
	00		 mov	 eax, DWORD PTR [rax+894]
  0018c	ff c0		 inc	 eax
  0018e	89 44 24 44	 mov	 DWORD PTR tv146[rsp], eax
  00192	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00197	8b 4c 24 44	 mov	 ecx, DWORD PTR tv146[rsp]
  0019b	89 88 7e 03 00
	00		 mov	 DWORD PTR [rax+894], ecx
  001a1	8b 4c 24 44	 mov	 ecx, DWORD PTR tv146[rsp]
  001a5	e8 00 00 00 00	 call	 _byteswap_ulong
  001aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001af	48 83 c1 08	 add	 rcx, 8
  001b3	8b d0		 mov	 edx, eax
  001b5	e8 00 00 00 00	 call	 store_fw_noswap

; 5896 :     memcpy( pMPC_RRHre->ackseq, pMPC_RRHwr->seqnum, 4 );

  001ba	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001bf	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  001c7	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  001ca	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5897 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  001cd	66 b9 24 00	 mov	 cx, 36			; 00000024H
  001d1	e8 00 00 00 00	 call	 _byteswap_ushort
  001d6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001db	48 83 c1 10	 add	 rcx, 16
  001df	0f b7 d0	 movzx	 edx, ax
  001e2	e8 00 00 00 00	 call	 store_hw_noswap

; 5898 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  001e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  001ec	e8 00 00 00 00	 call	 _byteswap_ushort
  001f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001f6	48 83 c1 12	 add	 rcx, 18
  001fa	0f b7 d0	 movzx	 edx, ax
  001fd	e8 00 00 00 00	 call	 store_hw_noswap

; 5899 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00202	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00206	e8 00 00 00 00	 call	 _byteswap_ulong
  0020b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00210	48 83 c1 14	 add	 rcx, 20
  00214	8b d0		 mov	 edx, eax
  00216	e8 00 00 00 00	 call	 store_f3_noswap

; 5900 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  0021b	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00220	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5901 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenCmConnection, MPC_TOKEN_LENGTH );

  00224	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00229	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0022e	8b 89 68 03 00
	00		 mov	 ecx, DWORD PTR [rcx+872]
  00234	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5902 : 
; 5903 :     // Prepare MPC_PHre
; 5904 :     pMPC_PHre->locdata = PH_LOC_1;

  00237	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0023c	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5905 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  0023f	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00243	e8 00 00 00 00	 call	 _byteswap_ulong
  00248	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  0024d	48 ff c1	 inc	 rcx
  00250	8b d0		 mov	 edx, eax
  00252	e8 00 00 00 00	 call	 store_f3_noswap

; 5906 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  00257	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength2$[rsp]
  0025b	e8 00 00 00 00	 call	 _byteswap_ulong
  00260	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00265	48 83 c1 04	 add	 rcx, 4
  00269	8b d0		 mov	 edx, eax
  0026b	e8 00 00 00 00	 call	 store_fw_noswap

; 5907 : 
; 5908 :     // Prepare MPC_PUKre
; 5909 :     STORE_HW( pMPC_PUKre->length, SIZE_PUK );

  00270	66 b9 0c 00	 mov	 cx, 12
  00274	e8 00 00 00 00	 call	 _byteswap_ushort
  00279	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  0027e	0f b7 d0	 movzx	 edx, ax
  00281	e8 00 00 00 00	 call	 store_hw_noswap

; 5910 :     pMPC_PUKre->what = PUK_WHAT_43;

  00286	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  0028b	c6 40 02 43	 mov	 BYTE PTR [rax+2], 67	; 00000043H

; 5911 :     pMPC_PUKre->type = PUK_TYPE_ACTIVE;

  0028f	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  00294	c6 40 03 60	 mov	 BYTE PTR [rax+3], 96	; 00000060H

; 5912 :     STORE_HW( pMPC_PUKre->lenpus, uLength4 );

  00298	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength4$[rsp]
  0029d	e8 00 00 00 00	 call	 _byteswap_ushort
  002a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  002a7	48 83 c1 04	 add	 rcx, 4
  002ab	0f b7 d0	 movzx	 edx, ax
  002ae	e8 00 00 00 00	 call	 store_hw_noswap

; 5913 : 
; 5914 :     // Prepare first MPC_PUSre
; 5915 :     STORE_HW( pMPC_PUSre->length, SIZE_PUS_04 );

  002b3	66 b9 09 00	 mov	 cx, 9
  002b7	e8 00 00 00 00	 call	 _byteswap_ushort
  002bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp]
  002c1	0f b7 d0	 movzx	 edx, ax
  002c4	e8 00 00 00 00	 call	 store_hw_noswap

; 5916 :     pMPC_PUSre->what = PUS_WHAT_04;

  002c9	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp]
  002ce	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5917 :     pMPC_PUSre->type = PUS_TYPE_04;

  002d2	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp]
  002d7	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 5918 :     pMPC_PUSre->vc.pus_04.tokenx5 = MPC_TOKEN_X5;

  002db	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp]
  002e0	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5919 :     memcpy( pMPC_PUSre->vc.pus_04.token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  002e4	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp]
  002e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  002ee	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  002f4	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5920 : 
; 5921 :     // Display various information, maybe
; 5922 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  002f7	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002fc	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  002ff	83 e0 10	 and	 eax, 16
  00302	85 c0		 test	 eax, eax
  00304	74 15		 je	 SHORT $LN3@build_417E

; 5923 :     {
; 5924 :         mpc_display_description( pDEVBLK, "Out RRH 0x417E (CmComm) PUK 0x4360 (DM_ACT)" );

  00306	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172135
  0030d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00315	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_417E:

; 5925 :     }
; 5926 : 
; 5927 :     return pPTPHDRre;

  0031b	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_417E:

; 5928 : }   /* End function  build_417E_dm_act() */

  00320	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00327	c3		 ret	 0
build_417E_dm_act ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength4$ = 32
pMPC_RRHre$ = 40
uLength3$ = 48
pPTPBLK$ = 56
pMPC_THre$ = 64
uLength1$ = 72
tv163 = 76
uLength2$ = 80
pMPC_PUKre$ = 88
pMPC_PHre$ = 96
pPTPHDRre$ = 104
pPTPATH$ = 112
pMPC_PUSre$ = 120
__$ArrayPad$ = 152
pDEVBLK$ = 192
pMPC_RRHwr$ = 200
build_417E_ulp_confirm PROC

; 5720 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5721 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00025	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0002d	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00034	48 89 44 24 70	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 5722 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00039	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	48 89 44 24 38	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 5723 :     U32        uLength1;
; 5724 :     U32        uLength2;
; 5725 :     U32        uLength3;
; 5726 :     U16        uLength4;
; 5727 :     PTPHDR*    pPTPHDRre;       // PTPHDR to be read
; 5728 :     MPC_TH*    pMPC_THre;       // MPC_TH follows PTPHDR
; 5729 :     MPC_RRH*   pMPC_RRHre;      // MPC_RRH follows MPC_TH
; 5730 :     MPC_PH*    pMPC_PHre;       // MPC_PH follows MPC_RRH
; 5731 :     MPC_PUK*   pMPC_PUKre;      // MPC_PUK follows MPC_PH
; 5732 :     MPC_PUS*   pMPC_PUSre[4];   // MPC_PUSs follow MPC_PUK
; 5733 : 
; 5734 : 
; 5735 :     // Allocate a buffer.
; 5736 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00046	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0004b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00053	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00058	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 5737 :     if (!pPTPHDRre)

  0005d	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00063	75 07		 jne	 SHORT $LN2@build_417E

; 5738 :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 1f 05 00 00	 jmp	 $LN1@build_417E
$LN2@build_417E:

; 5739 : 
; 5740 :     // Fix-up various lengths
; 5741 :     uLength4 = SIZE_PUS_04 +                  // first MPC_PUS (0x0404)

  0006c	b8 46 00 00 00	 mov	 eax, 70			; 00000046H
  00071	66 89 44 24 20	 mov	 WORD PTR uLength4$[rsp], ax

; 5742 :                SIZE_PUS_08 +                  // second MPC_PUS (0x0408)
; 5743 :                SIZE_PUS_07 +                  // third MPC_PUS (0x0407)
; 5744 :                SIZE_PUS_02_B;                 // fourth MPC_PUS (0x0402)
; 5745 :     uLength3 = SIZE_PUK + uLength4;           // the MPC_PUK and the MPC_PUSs (the data)

  00076	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength4$[rsp]
  0007b	83 c0 0c	 add	 eax, 12
  0007e	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 5746 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00082	c7 44 24 50 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 5747 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  0008a	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  0008e	8b 4c 24 50	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00092	03 c8		 add	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	89 44 24 48	 mov	 DWORD PTR uLength1$[rsp], eax

; 5748 : 
; 5749 :     // Fix-up various pointers
; 5750 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  0009a	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0009f	48 83 c0 10	 add	 rax, 16
  000a3	48 89 44 24 40	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 5751 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  000ad	48 83 c0 14	 add	 rax, 20
  000b1	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 5752 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  000b6	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  000bb	48 83 c0 24	 add	 rax, 36			; 00000024H
  000bf	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 5753 :     pMPC_PUKre = (MPC_PUK*)((BYTE*)pMPC_PHre + SIZE_PH);

  000c4	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000c9	48 83 c0 08	 add	 rax, 8
  000cd	48 89 44 24 58	 mov	 QWORD PTR pMPC_PUKre$[rsp], rax

; 5754 :     pMPC_PUSre[0] = (MPC_PUS*)((BYTE*)pMPC_PUKre + SIZE_PUK);

  000d2	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  000d7	48 83 c0 0c	 add	 rax, 12
  000db	b9 08 00 00 00	 mov	 ecx, 8
  000e0	48 6b c9 00	 imul	 rcx, rcx, 0
  000e4	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5755 :     pMPC_PUSre[1] = (MPC_PUS*)((BYTE*)pMPC_PUSre[0] + SIZE_PUS_04);

  000e9	b8 08 00 00 00	 mov	 eax, 8
  000ee	48 6b c0 00	 imul	 rax, rax, 0
  000f2	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  000f7	48 83 c0 09	 add	 rax, 9
  000fb	b9 08 00 00 00	 mov	 ecx, 8
  00100	48 6b c9 01	 imul	 rcx, rcx, 1
  00104	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5756 :     pMPC_PUSre[2] = (MPC_PUS*)((BYTE*)pMPC_PUSre[1] + SIZE_PUS_08);

  00109	b8 08 00 00 00	 mov	 eax, 8
  0010e	48 6b c0 01	 imul	 rax, rax, 1
  00112	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00117	48 83 c0 09	 add	 rax, 9
  0011b	b9 08 00 00 00	 mov	 ecx, 8
  00120	48 6b c9 02	 imul	 rcx, rcx, 2
  00124	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5757 :     pMPC_PUSre[3] = (MPC_PUS*)((BYTE*)pMPC_PUSre[2] + SIZE_PUS_07);

  00129	b8 08 00 00 00	 mov	 eax, 8
  0012e	48 6b c0 02	 imul	 rax, rax, 2
  00132	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00137	48 83 c0 08	 add	 rax, 8
  0013b	b9 08 00 00 00	 mov	 ecx, 8
  00140	48 6b c9 03	 imul	 rcx, rcx, 3
  00144	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5758 : 
; 5759 :     // Prepare PTPHDRre
; 5760 :     pPTPHDRre->iDataLen = uLength1;

  00149	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0014e	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00152	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5761 : 
; 5762 :     // Prepare MPC_THre
; 5763 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00155	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  0015a	e8 00 00 00 00	 call	 _byteswap_ulong
  0015f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00164	8b d0		 mov	 edx, eax
  00166	e8 00 00 00 00	 call	 store_fw_noswap

; 5764 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  0016b	b9 14 00 00 00	 mov	 ecx, 20
  00170	e8 00 00 00 00	 call	 _byteswap_ulong
  00175	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0017a	48 83 c1 08	 add	 rcx, 8
  0017e	8b d0		 mov	 edx, eax
  00180	e8 00 00 00 00	 call	 store_fw_noswap

; 5765 :     STORE_FW( pMPC_THre->length, uLength1 );

  00185	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00189	e8 00 00 00 00	 call	 _byteswap_ulong
  0018e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00193	48 83 c1 0c	 add	 rcx, 12
  00197	8b d0		 mov	 edx, eax
  00199	e8 00 00 00 00	 call	 store_fw_noswap

; 5766 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  0019e	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  001a2	e8 00 00 00 00	 call	 _byteswap_ushort
  001a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  001ac	48 83 c1 10	 add	 rcx, 16
  001b0	0f b7 d0	 movzx	 edx, ax
  001b3	e8 00 00 00 00	 call	 store_hw_noswap

; 5767 :     STORE_HW( pMPC_THre->numrrh, 1 );

  001b8	66 b9 01 00	 mov	 cx, 1
  001bc	e8 00 00 00 00	 call	 _byteswap_ushort
  001c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  001c6	48 83 c1 12	 add	 rcx, 18
  001ca	0f b7 d0	 movzx	 edx, ax
  001cd	e8 00 00 00 00	 call	 store_hw_noswap

; 5768 : 
; 5769 :     // Prepare MPC_RRHre
; 5770 :     pMPC_RRHre->type = RRH_TYPE_ULP;

  001d2	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001d7	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 5771 :     pMPC_RRHre->proto = PROTOCOL_UNKNOWN;

  001db	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001e0	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5772 :     STORE_HW( pMPC_RRHre->numph, 1 );

  001e4	66 b9 01 00	 mov	 cx, 1
  001e8	e8 00 00 00 00	 call	 _byteswap_ushort
  001ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001f2	48 83 c1 06	 add	 rcx, 6
  001f6	0f b7 d0	 movzx	 edx, ax
  001f9	e8 00 00 00 00	 call	 store_hw_noswap

; 5773 :     STORE_FW( pMPC_RRHre->seqnum, ++pPTPBLK->uSeqNumCm );

  001fe	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00203	8b 80 7e 03 00
	00		 mov	 eax, DWORD PTR [rax+894]
  00209	ff c0		 inc	 eax
  0020b	89 44 24 4c	 mov	 DWORD PTR tv163[rsp], eax
  0020f	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00214	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv163[rsp]
  00218	89 88 7e 03 00
	00		 mov	 DWORD PTR [rax+894], ecx
  0021e	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv163[rsp]
  00222	e8 00 00 00 00	 call	 _byteswap_ulong
  00227	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0022c	48 83 c1 08	 add	 rcx, 8
  00230	8b d0		 mov	 edx, eax
  00232	e8 00 00 00 00	 call	 store_fw_noswap

; 5774 :     memcpy( pMPC_RRHre->ackseq, pMPC_RRHwr->seqnum, 4 );

  00237	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0023c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  00244	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00247	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5775 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  0024a	66 b9 24 00	 mov	 cx, 36			; 00000024H
  0024e	e8 00 00 00 00	 call	 _byteswap_ushort
  00253	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00258	48 83 c1 10	 add	 rcx, 16
  0025c	0f b7 d0	 movzx	 edx, ax
  0025f	e8 00 00 00 00	 call	 store_hw_noswap

; 5776 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00264	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00269	e8 00 00 00 00	 call	 _byteswap_ushort
  0026e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00273	48 83 c1 12	 add	 rcx, 18
  00277	0f b7 d0	 movzx	 edx, ax
  0027a	e8 00 00 00 00	 call	 store_hw_noswap

; 5777 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  0027f	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00283	e8 00 00 00 00	 call	 _byteswap_ulong
  00288	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0028d	48 83 c1 14	 add	 rcx, 20
  00291	8b d0		 mov	 edx, eax
  00293	e8 00 00 00 00	 call	 store_f3_noswap

; 5778 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00298	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0029d	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5779 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenCmConnection, MPC_TOKEN_LENGTH );

  002a1	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  002a6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  002ab	8b 89 68 03 00
	00		 mov	 ecx, DWORD PTR [rcx+872]
  002b1	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5780 : 
; 5781 :     // Prepare MPC_PHre
; 5782 :     pMPC_PHre->locdata = PH_LOC_1;

  002b4	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  002b9	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5783 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  002bc	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  002c0	e8 00 00 00 00	 call	 _byteswap_ulong
  002c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002ca	48 ff c1	 inc	 rcx
  002cd	8b d0		 mov	 edx, eax
  002cf	e8 00 00 00 00	 call	 store_f3_noswap

; 5784 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  002d4	8b 4c 24 50	 mov	 ecx, DWORD PTR uLength2$[rsp]
  002d8	e8 00 00 00 00	 call	 _byteswap_ulong
  002dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002e2	48 83 c1 04	 add	 rcx, 4
  002e6	8b d0		 mov	 edx, eax
  002e8	e8 00 00 00 00	 call	 store_fw_noswap

; 5785 : 
; 5786 :     // Prepare MPC_PUKre
; 5787 :     STORE_HW( pMPC_PUKre->length, SIZE_PUK );

  002ed	66 b9 0c 00	 mov	 cx, 12
  002f1	e8 00 00 00 00	 call	 _byteswap_ushort
  002f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  002fb	0f b7 d0	 movzx	 edx, ax
  002fe	e8 00 00 00 00	 call	 store_hw_noswap

; 5788 :     pMPC_PUKre->what = PUK_WHAT_41;

  00303	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  00308	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5789 :     pMPC_PUKre->type = PUK_TYPE_CONFIRM;

  0030c	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  00311	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 5790 :     STORE_HW( pMPC_PUKre->lenpus, uLength4 );

  00315	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength4$[rsp]
  0031a	e8 00 00 00 00	 call	 _byteswap_ushort
  0031f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  00324	48 83 c1 04	 add	 rcx, 4
  00328	0f b7 d0	 movzx	 edx, ax
  0032b	e8 00 00 00 00	 call	 store_hw_noswap

; 5791 : 
; 5792 :     // Prepare first MPC_PUSre
; 5793 :     STORE_HW( pMPC_PUSre[0]->length, SIZE_PUS_04 );

  00330	66 b9 09 00	 mov	 cx, 9
  00334	e8 00 00 00 00	 call	 _byteswap_ushort
  00339	b9 08 00 00 00	 mov	 ecx, 8
  0033e	48 6b c9 00	 imul	 rcx, rcx, 0
  00342	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00347	0f b7 d0	 movzx	 edx, ax
  0034a	e8 00 00 00 00	 call	 store_hw_noswap

; 5794 :     pMPC_PUSre[0]->what = PUS_WHAT_04;

  0034f	b8 08 00 00 00	 mov	 eax, 8
  00354	48 6b c0 00	 imul	 rax, rax, 0
  00358	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0035d	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5795 :     pMPC_PUSre[0]->type = PUS_TYPE_04;

  00361	b8 08 00 00 00	 mov	 eax, 8
  00366	48 6b c0 00	 imul	 rax, rax, 0
  0036a	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0036f	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 5796 :     pMPC_PUSre[0]->vc.pus_04.tokenx5 = MPC_TOKEN_X5;

  00373	b8 08 00 00 00	 mov	 eax, 8
  00378	48 6b c0 00	 imul	 rax, rax, 0
  0037c	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00381	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5797 :     memcpy( pMPC_PUSre[0]->vc.pus_04.token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  00385	b8 08 00 00 00	 mov	 eax, 8
  0038a	48 6b c0 00	 imul	 rax, rax, 0
  0038e	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00393	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00398	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  0039e	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5798 : 
; 5799 :     // Prepare second MPC_PUSre
; 5800 :     STORE_HW( pMPC_PUSre[1]->length, SIZE_PUS_08 );

  003a1	66 b9 09 00	 mov	 cx, 9
  003a5	e8 00 00 00 00	 call	 _byteswap_ushort
  003aa	b9 08 00 00 00	 mov	 ecx, 8
  003af	48 6b c9 01	 imul	 rcx, rcx, 1
  003b3	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  003b8	0f b7 d0	 movzx	 edx, ax
  003bb	e8 00 00 00 00	 call	 store_hw_noswap

; 5801 :     pMPC_PUSre[1]->what = PUS_WHAT_04;

  003c0	b8 08 00 00 00	 mov	 eax, 8
  003c5	48 6b c0 01	 imul	 rax, rax, 1
  003c9	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003ce	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5802 :     pMPC_PUSre[1]->type = PUS_TYPE_08;

  003d2	b8 08 00 00 00	 mov	 eax, 8
  003d7	48 6b c0 01	 imul	 rax, rax, 1
  003db	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003e0	c6 40 03 08	 mov	 BYTE PTR [rax+3], 8

; 5803 :     pMPC_PUSre[1]->vc.pus_08.tokenx5 = MPC_TOKEN_X5;

  003e4	b8 08 00 00 00	 mov	 eax, 8
  003e9	48 6b c0 01	 imul	 rax, rax, 1
  003ed	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003f2	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5804 :     memcpy( pMPC_PUSre[1]->vc.pus_08.token, pPTPBLK->xTokenUlpConnection, MPC_TOKEN_LENGTH );

  003f6	b8 08 00 00 00	 mov	 eax, 8
  003fb	48 6b c0 01	 imul	 rax, rax, 1
  003ff	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00404	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00409	8b 89 4d 03 00
	00		 mov	 ecx, DWORD PTR [rcx+845]
  0040f	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5805 : 
; 5806 :     // Prepare third MPC_PUSre
; 5807 :     STORE_HW( pMPC_PUSre[2]->length, SIZE_PUS_07 );

  00412	66 b9 08 00	 mov	 cx, 8
  00416	e8 00 00 00 00	 call	 _byteswap_ushort
  0041b	b9 08 00 00 00	 mov	 ecx, 8
  00420	48 6b c9 02	 imul	 rcx, rcx, 2
  00424	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00429	0f b7 d0	 movzx	 edx, ax
  0042c	e8 00 00 00 00	 call	 store_hw_noswap

; 5808 :     pMPC_PUSre[2]->what = PUS_WHAT_04;

  00431	b8 08 00 00 00	 mov	 eax, 8
  00436	48 6b c0 02	 imul	 rax, rax, 2
  0043a	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0043f	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5809 :     pMPC_PUSre[2]->type = PUS_TYPE_07;

  00443	b8 08 00 00 00	 mov	 eax, 8
  00448	48 6b c0 02	 imul	 rax, rax, 2
  0044c	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00451	c6 40 03 07	 mov	 BYTE PTR [rax+3], 7

; 5810 :     pMPC_PUSre[2]->vc.pus_07.unknown04[0] = 0x40;        // !!! //

  00455	b8 08 00 00 00	 mov	 eax, 8
  0045a	48 6b c0 02	 imul	 rax, rax, 2
  0045e	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00463	b9 01 00 00 00	 mov	 ecx, 1
  00468	48 6b c9 00	 imul	 rcx, rcx, 0
  0046c	c6 44 08 04 40	 mov	 BYTE PTR [rax+rcx+4], 64 ; 00000040H

; 5811 : 
; 5812 :     // Prepare fourth MPC_PUSre
; 5813 :     STORE_HW( pMPC_PUSre[3]->length, SIZE_PUS_02_B );

  00471	66 b9 2c 00	 mov	 cx, 44			; 0000002cH
  00475	e8 00 00 00 00	 call	 _byteswap_ushort
  0047a	b9 08 00 00 00	 mov	 ecx, 8
  0047f	48 6b c9 03	 imul	 rcx, rcx, 3
  00483	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00488	0f b7 d0	 movzx	 edx, ax
  0048b	e8 00 00 00 00	 call	 store_hw_noswap

; 5814 :     pMPC_PUSre[3]->what = PUS_WHAT_04;

  00490	b8 08 00 00 00	 mov	 eax, 8
  00495	48 6b c0 03	 imul	 rax, rax, 3
  00499	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0049e	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5815 :     pMPC_PUSre[3]->type = PUS_TYPE_02;

  004a2	b8 08 00 00 00	 mov	 eax, 8
  004a7	48 6b c0 03	 imul	 rax, rax, 3
  004ab	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004b0	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5816 :     pMPC_PUSre[3]->vc.pus_02.b.unknown04 = 0x02;         // !!! //

  004b4	b8 08 00 00 00	 mov	 eax, 8
  004b9	48 6b c0 03	 imul	 rax, rax, 3
  004bd	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004c2	c6 40 04 02	 mov	 BYTE PTR [rax+4], 2

; 5817 :     pMPC_PUSre[3]->vc.pus_02.b.flags = 0x90;         // !!! //

  004c6	b8 08 00 00 00	 mov	 eax, 8
  004cb	48 6b c0 03	 imul	 rax, rax, 3
  004cf	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004d4	c6 40 05 90	 mov	 BYTE PTR [rax+5], 144	; 00000090H

; 5818 :     pMPC_PUSre[3]->vc.pus_02.b.unknown0A = 0x40;         // !!! //

  004d8	b8 08 00 00 00	 mov	 eax, 8
  004dd	48 6b c0 03	 imul	 rax, rax, 3
  004e1	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004e6	c6 40 0a 40	 mov	 BYTE PTR [rax+10], 64	; 00000040H

; 5819 : #if defined(ENABLE_IPV6)
; 5820 :     if (pPTPBLK->fIPv4Spec)

  004ea	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004ef	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  004f2	83 e0 01	 and	 eax, 1
  004f5	85 c0		 test	 eax, eax
  004f7	74 1e		 je	 SHORT $LN3@build_417E

; 5821 :     {
; 5822 : #endif /* defined(ENABLE_IPV6) */
; 5823 :         memcpy( pMPC_PUSre[3]->vc.pus_02.b.ipaddr, &pPTPBLK->iaDriveIPAddr4, 4 );

  004f9	b8 08 00 00 00	 mov	 eax, 8
  004fe	48 6b c0 03	 imul	 rax, rax, 3
  00502	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00507	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0050c	8b 89 d8 02 00
	00		 mov	 ecx, DWORD PTR [rcx+728]
  00512	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5824 : #if defined(ENABLE_IPV6)
; 5825 :     }

  00515	eb 4b		 jmp	 SHORT $LN4@build_417E
$LN3@build_417E:

; 5826 :     else
; 5827 :     {
; 5828 :         pMPC_PUSre[1]->vc.pus_02.b.flags |= 0x08;

  00517	b8 08 00 00 00	 mov	 eax, 8
  0051c	48 6b c0 01	 imul	 rax, rax, 1
  00520	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00525	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00529	83 c8 08	 or	 eax, 8
  0052c	b9 08 00 00 00	 mov	 ecx, 8
  00531	48 6b c9 01	 imul	 rcx, rcx, 1
  00535	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  0053a	88 41 05	 mov	 BYTE PTR [rcx+5], al

; 5829 :         memcpy( pMPC_PUSre[3]->vc.pus_02.b.ipaddr, &pPTPBLK->iaDriveLLAddr6, 16 );

  0053d	b8 08 00 00 00	 mov	 eax, 8
  00542	48 6b c0 03	 imul	 rax, rax, 3
  00546	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0054b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00550	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  00554	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  0055b	b9 10 00 00 00	 mov	 ecx, 16
  00560	f3 a4		 rep movsb
$LN4@build_417E:

; 5830 :     }
; 5831 : #endif /* defined(ENABLE_IPV6) */
; 5832 : 
; 5833 :     // Display various information, maybe
; 5834 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00562	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00567	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0056a	83 e0 10	 and	 eax, 16
  0056d	85 c0		 test	 eax, eax
  0056f	74 15		 je	 SHORT $LN5@build_417E

; 5835 :     {
; 5836 :         mpc_display_description( pDEVBLK, "Out RRH 0x417E (CmComm) PUK 0x4106 (ULP_CONFIRM)" );

  00571	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172102
  00578	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00580	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN5@build_417E:

; 5837 :     }
; 5838 : 
; 5839 :     return pPTPHDRre;

  00586	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_417E:

; 5840 : }   /* End function  build_417E_ulp_confirm() */

  0058b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00593	48 33 cc	 xor	 rcx, rsp
  00596	e8 00 00 00 00	 call	 __security_check_cookie
  0059b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  005a2	5f		 pop	 rdi
  005a3	5e		 pop	 rsi
  005a4	c3		 ret	 0
build_417E_ulp_confirm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength4$ = 32
pMPC_RRHre$ = 40
uLength3$ = 48
pPTPBLK$ = 56
pMPC_THre$ = 64
uLength1$ = 72
tv163 = 76
uLength2$ = 80
pMPC_PUKre$ = 88
pMPC_PHre$ = 96
pPTPHDRre$ = 104
pPTPATH$ = 112
pMPC_PUSre$ = 120
__$ArrayPad$ = 152
pDEVBLK$ = 192
pMPC_RRHwr$ = 200
build_417E_ulp_setup PROC

; 5592 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5593 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00025	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0002d	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00034	48 89 44 24 70	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 5594 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00039	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	48 89 44 24 38	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 5595 :     U32        uLength1;
; 5596 :     U32        uLength2;
; 5597 :     U32        uLength3;
; 5598 :     U16        uLength4;
; 5599 :     PTPHDR*    pPTPHDRre;       // PTPHDR to be read
; 5600 :     MPC_TH*    pMPC_THre;       // MPC_TH follows PTPHDR
; 5601 :     MPC_RRH*   pMPC_RRHre;      // MPC_RRH follows MPC_TH
; 5602 :     MPC_PH*    pMPC_PHre;       // MPC_PH follows MPC_RRH
; 5603 :     MPC_PUK*   pMPC_PUKre;      // MPC_PUK follows MPC_PH
; 5604 :     MPC_PUS*   pMPC_PUSre[4];   // MPC_PUSs follow MPC_PUK
; 5605 : 
; 5606 : 
; 5607 :     // Allocate a buffer in which the response will be build.
; 5608 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00046	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0004b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00053	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00058	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 5609 :     if (!pPTPHDRre)

  0005d	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00063	75 07		 jne	 SHORT $LN2@build_417E

; 5610 :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 1f 05 00 00	 jmp	 $LN1@build_417E
$LN2@build_417E:

; 5611 : 
; 5612 :     // Fix-up various lengths
; 5613 :     uLength4 = SIZE_PUS_04 +                  // first MPC_PUS (0x0404)

  0006c	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  00071	66 89 44 24 20	 mov	 WORD PTR uLength4$[rsp], ax

; 5614 :                SIZE_PUS_05 +                  // second MPC_PUS (0x0405)
; 5615 :                SIZE_PUS_06 +                  // third MPC_PUS (0x0406)
; 5616 :                SIZE_PUS_02_B;                 // fourth MPC_PUS (0x0402)
; 5617 :     uLength3 = SIZE_PUK + uLength4;           // the MPC_PUK and the MPC_PUSs (the data)

  00076	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength4$[rsp]
  0007b	83 c0 0c	 add	 eax, 12
  0007e	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 5618 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00082	c7 44 24 50 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 5619 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  0008a	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  0008e	8b 4c 24 50	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00092	03 c8		 add	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	89 44 24 48	 mov	 DWORD PTR uLength1$[rsp], eax

; 5620 : 
; 5621 :     // Fix-up various pointers
; 5622 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  0009a	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0009f	48 83 c0 10	 add	 rax, 16
  000a3	48 89 44 24 40	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 5623 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  000ad	48 83 c0 14	 add	 rax, 20
  000b1	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 5624 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  000b6	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  000bb	48 83 c0 24	 add	 rax, 36			; 00000024H
  000bf	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 5625 :     pMPC_PUKre = (MPC_PUK*)((BYTE*)pMPC_PHre + SIZE_PH);

  000c4	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000c9	48 83 c0 08	 add	 rax, 8
  000cd	48 89 44 24 58	 mov	 QWORD PTR pMPC_PUKre$[rsp], rax

; 5626 :     pMPC_PUSre[0] = (MPC_PUS*)((BYTE*)pMPC_PUKre + SIZE_PUK);

  000d2	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  000d7	48 83 c0 0c	 add	 rax, 12
  000db	b9 08 00 00 00	 mov	 ecx, 8
  000e0	48 6b c9 00	 imul	 rcx, rcx, 0
  000e4	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5627 :     pMPC_PUSre[1] = (MPC_PUS*)((BYTE*)pMPC_PUSre[0] + SIZE_PUS_04);

  000e9	b8 08 00 00 00	 mov	 eax, 8
  000ee	48 6b c0 00	 imul	 rax, rax, 0
  000f2	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  000f7	48 83 c0 09	 add	 rax, 9
  000fb	b9 08 00 00 00	 mov	 ecx, 8
  00100	48 6b c9 01	 imul	 rcx, rcx, 1
  00104	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5628 :     pMPC_PUSre[2] = (MPC_PUS*)((BYTE*)pMPC_PUSre[1] + SIZE_PUS_05);

  00109	b8 08 00 00 00	 mov	 eax, 8
  0010e	48 6b c0 01	 imul	 rax, rax, 1
  00112	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00117	48 83 c0 09	 add	 rax, 9
  0011b	b9 08 00 00 00	 mov	 ecx, 8
  00120	48 6b c9 02	 imul	 rcx, rcx, 2
  00124	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5629 :     pMPC_PUSre[3] = (MPC_PUS*)((BYTE*)pMPC_PUSre[2] + SIZE_PUS_06);

  00129	b8 08 00 00 00	 mov	 eax, 8
  0012e	48 6b c0 02	 imul	 rax, rax, 2
  00132	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	b9 08 00 00 00	 mov	 ecx, 8
  00140	48 6b c9 03	 imul	 rcx, rcx, 3
  00144	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5630 : 
; 5631 :     // Prepare PTPHDRre
; 5632 :     pPTPHDRre->iDataLen = uLength1;

  00149	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0014e	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00152	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5633 : 
; 5634 :     // Prepare MPC_THre
; 5635 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00155	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  0015a	e8 00 00 00 00	 call	 _byteswap_ulong
  0015f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00164	8b d0		 mov	 edx, eax
  00166	e8 00 00 00 00	 call	 store_fw_noswap

; 5636 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  0016b	b9 14 00 00 00	 mov	 ecx, 20
  00170	e8 00 00 00 00	 call	 _byteswap_ulong
  00175	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0017a	48 83 c1 08	 add	 rcx, 8
  0017e	8b d0		 mov	 edx, eax
  00180	e8 00 00 00 00	 call	 store_fw_noswap

; 5637 :     STORE_FW( pMPC_THre->length, uLength1 );

  00185	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00189	e8 00 00 00 00	 call	 _byteswap_ulong
  0018e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00193	48 83 c1 0c	 add	 rcx, 12
  00197	8b d0		 mov	 edx, eax
  00199	e8 00 00 00 00	 call	 store_fw_noswap

; 5638 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  0019e	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  001a2	e8 00 00 00 00	 call	 _byteswap_ushort
  001a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  001ac	48 83 c1 10	 add	 rcx, 16
  001b0	0f b7 d0	 movzx	 edx, ax
  001b3	e8 00 00 00 00	 call	 store_hw_noswap

; 5639 :     STORE_HW( pMPC_THre->numrrh, 1 );

  001b8	66 b9 01 00	 mov	 cx, 1
  001bc	e8 00 00 00 00	 call	 _byteswap_ushort
  001c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  001c6	48 83 c1 12	 add	 rcx, 18
  001ca	0f b7 d0	 movzx	 edx, ax
  001cd	e8 00 00 00 00	 call	 store_hw_noswap

; 5640 : 
; 5641 :     // Prepare MPC_RRHre
; 5642 :     pMPC_RRHre->type = RRH_TYPE_ULP;

  001d2	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001d7	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 5643 :     pMPC_RRHre->proto = PROTOCOL_UNKNOWN;

  001db	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001e0	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5644 :     STORE_HW( pMPC_RRHre->numph, 1 );

  001e4	66 b9 01 00	 mov	 cx, 1
  001e8	e8 00 00 00 00	 call	 _byteswap_ushort
  001ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001f2	48 83 c1 06	 add	 rcx, 6
  001f6	0f b7 d0	 movzx	 edx, ax
  001f9	e8 00 00 00 00	 call	 store_hw_noswap

; 5645 :     STORE_FW( pMPC_RRHre->seqnum, ++pPTPBLK->uSeqNumCm );

  001fe	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00203	8b 80 7e 03 00
	00		 mov	 eax, DWORD PTR [rax+894]
  00209	ff c0		 inc	 eax
  0020b	89 44 24 4c	 mov	 DWORD PTR tv163[rsp], eax
  0020f	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00214	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv163[rsp]
  00218	89 88 7e 03 00
	00		 mov	 DWORD PTR [rax+894], ecx
  0021e	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv163[rsp]
  00222	e8 00 00 00 00	 call	 _byteswap_ulong
  00227	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0022c	48 83 c1 08	 add	 rcx, 8
  00230	8b d0		 mov	 edx, eax
  00232	e8 00 00 00 00	 call	 store_fw_noswap

; 5646 :     memcpy( pMPC_RRHre->ackseq, pMPC_RRHwr->seqnum, 4 );

  00237	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0023c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  00244	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00247	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5647 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  0024a	66 b9 24 00	 mov	 cx, 36			; 00000024H
  0024e	e8 00 00 00 00	 call	 _byteswap_ushort
  00253	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00258	48 83 c1 10	 add	 rcx, 16
  0025c	0f b7 d0	 movzx	 edx, ax
  0025f	e8 00 00 00 00	 call	 store_hw_noswap

; 5648 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00264	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00269	e8 00 00 00 00	 call	 _byteswap_ushort
  0026e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00273	48 83 c1 12	 add	 rcx, 18
  00277	0f b7 d0	 movzx	 edx, ax
  0027a	e8 00 00 00 00	 call	 store_hw_noswap

; 5649 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  0027f	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00283	e8 00 00 00 00	 call	 _byteswap_ulong
  00288	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0028d	48 83 c1 14	 add	 rcx, 20
  00291	8b d0		 mov	 edx, eax
  00293	e8 00 00 00 00	 call	 store_f3_noswap

; 5650 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00298	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0029d	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5651 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenCmConnection, MPC_TOKEN_LENGTH );

  002a1	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  002a6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  002ab	8b 89 68 03 00
	00		 mov	 ecx, DWORD PTR [rcx+872]
  002b1	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5652 : 
; 5653 :     // Prepare MPC_PHre
; 5654 :     pMPC_PHre->locdata = PH_LOC_1;

  002b4	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  002b9	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5655 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  002bc	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  002c0	e8 00 00 00 00	 call	 _byteswap_ulong
  002c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002ca	48 ff c1	 inc	 rcx
  002cd	8b d0		 mov	 edx, eax
  002cf	e8 00 00 00 00	 call	 store_f3_noswap

; 5656 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  002d4	8b 4c 24 50	 mov	 ecx, DWORD PTR uLength2$[rsp]
  002d8	e8 00 00 00 00	 call	 _byteswap_ulong
  002dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002e2	48 83 c1 04	 add	 rcx, 4
  002e6	8b d0		 mov	 edx, eax
  002e8	e8 00 00 00 00	 call	 store_fw_noswap

; 5657 : 
; 5658 :     // Prepare MPC_PUKre
; 5659 :     STORE_HW( pMPC_PUKre->length, SIZE_PUK );

  002ed	66 b9 0c 00	 mov	 cx, 12
  002f1	e8 00 00 00 00	 call	 _byteswap_ushort
  002f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  002fb	0f b7 d0	 movzx	 edx, ax
  002fe	e8 00 00 00 00	 call	 store_hw_noswap

; 5660 :     pMPC_PUKre->what = PUK_WHAT_41;

  00303	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  00308	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5661 :     pMPC_PUKre->type = PUK_TYPE_SETUP;

  0030c	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  00311	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 5662 :     STORE_HW( pMPC_PUKre->lenpus, uLength4 );

  00315	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength4$[rsp]
  0031a	e8 00 00 00 00	 call	 _byteswap_ushort
  0031f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  00324	48 83 c1 04	 add	 rcx, 4
  00328	0f b7 d0	 movzx	 edx, ax
  0032b	e8 00 00 00 00	 call	 store_hw_noswap

; 5663 : 
; 5664 :     // Prepare first MPC_PUSre
; 5665 :     STORE_HW( pMPC_PUSre[0]->length, SIZE_PUS_04 );

  00330	66 b9 09 00	 mov	 cx, 9
  00334	e8 00 00 00 00	 call	 _byteswap_ushort
  00339	b9 08 00 00 00	 mov	 ecx, 8
  0033e	48 6b c9 00	 imul	 rcx, rcx, 0
  00342	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00347	0f b7 d0	 movzx	 edx, ax
  0034a	e8 00 00 00 00	 call	 store_hw_noswap

; 5666 :     pMPC_PUSre[0]->what = PUS_WHAT_04;

  0034f	b8 08 00 00 00	 mov	 eax, 8
  00354	48 6b c0 00	 imul	 rax, rax, 0
  00358	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0035d	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5667 :     pMPC_PUSre[0]->type = PUS_TYPE_04;

  00361	b8 08 00 00 00	 mov	 eax, 8
  00366	48 6b c0 00	 imul	 rax, rax, 0
  0036a	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0036f	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 5668 :     pMPC_PUSre[0]->vc.pus_04.tokenx5 = MPC_TOKEN_X5;

  00373	b8 08 00 00 00	 mov	 eax, 8
  00378	48 6b c0 00	 imul	 rax, rax, 0
  0037c	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00381	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5669 :     memcpy( pMPC_PUSre[0]->vc.pus_04.token, pPTPBLK->xTokenUlpConnection, MPC_TOKEN_LENGTH );

  00385	b8 08 00 00 00	 mov	 eax, 8
  0038a	48 6b c0 00	 imul	 rax, rax, 0
  0038e	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00393	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00398	8b 89 4d 03 00
	00		 mov	 ecx, DWORD PTR [rcx+845]
  0039e	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5670 : 
; 5671 :     // Prepare second MPC_PUSre
; 5672 :     STORE_HW( pMPC_PUSre[1]->length, SIZE_PUS_05 );

  003a1	66 b9 09 00	 mov	 cx, 9
  003a5	e8 00 00 00 00	 call	 _byteswap_ushort
  003aa	b9 08 00 00 00	 mov	 ecx, 8
  003af	48 6b c9 01	 imul	 rcx, rcx, 1
  003b3	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  003b8	0f b7 d0	 movzx	 edx, ax
  003bb	e8 00 00 00 00	 call	 store_hw_noswap

; 5673 :     pMPC_PUSre[1]->what = PUS_WHAT_04;

  003c0	b8 08 00 00 00	 mov	 eax, 8
  003c5	48 6b c0 01	 imul	 rax, rax, 1
  003c9	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003ce	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5674 :     pMPC_PUSre[1]->type = PUS_TYPE_05;

  003d2	b8 08 00 00 00	 mov	 eax, 8
  003d7	48 6b c0 01	 imul	 rax, rax, 1
  003db	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003e0	c6 40 03 05	 mov	 BYTE PTR [rax+3], 5

; 5675 :     pMPC_PUSre[1]->vc.pus_05.tokenx5 = MPC_TOKEN_X5;

  003e4	b8 08 00 00 00	 mov	 eax, 8
  003e9	48 6b c0 01	 imul	 rax, rax, 1
  003ed	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003f2	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5676 :     memcpy( pMPC_PUSre[1]->vc.pus_05.token, pPTPBLK->yTokenUlpFilter, MPC_TOKEN_LENGTH );

  003f6	b8 08 00 00 00	 mov	 eax, 8
  003fb	48 6b c0 01	 imul	 rax, rax, 1
  003ff	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00404	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00409	8b 89 6c 03 00
	00		 mov	 ecx, DWORD PTR [rcx+876]
  0040f	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5677 : 
; 5678 :     // Prepare third MPC_PUSre
; 5679 :     STORE_HW( pMPC_PUSre[2]->length, SIZE_PUS_06 );

  00412	66 b9 06 00	 mov	 cx, 6
  00416	e8 00 00 00 00	 call	 _byteswap_ushort
  0041b	b9 08 00 00 00	 mov	 ecx, 8
  00420	48 6b c9 02	 imul	 rcx, rcx, 2
  00424	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00429	0f b7 d0	 movzx	 edx, ax
  0042c	e8 00 00 00 00	 call	 store_hw_noswap

; 5680 :     pMPC_PUSre[2]->what = PUS_WHAT_04;

  00431	b8 08 00 00 00	 mov	 eax, 8
  00436	48 6b c0 02	 imul	 rax, rax, 2
  0043a	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0043f	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5681 :     pMPC_PUSre[2]->type = PUS_TYPE_06;

  00443	b8 08 00 00 00	 mov	 eax, 8
  00448	48 6b c0 02	 imul	 rax, rax, 2
  0044c	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00451	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 5682 :     pMPC_PUSre[2]->vc.pus_06.unknown04[0] = 0x40;        // !!! //

  00455	b8 08 00 00 00	 mov	 eax, 8
  0045a	48 6b c0 02	 imul	 rax, rax, 2
  0045e	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00463	b9 01 00 00 00	 mov	 ecx, 1
  00468	48 6b c9 00	 imul	 rcx, rcx, 0
  0046c	c6 44 08 04 40	 mov	 BYTE PTR [rax+rcx+4], 64 ; 00000040H

; 5683 : 
; 5684 :     // Prepare fourth MPC_PUSre
; 5685 :     STORE_HW( pMPC_PUSre[3]->length, SIZE_PUS_02_B );

  00471	66 b9 2c 00	 mov	 cx, 44			; 0000002cH
  00475	e8 00 00 00 00	 call	 _byteswap_ushort
  0047a	b9 08 00 00 00	 mov	 ecx, 8
  0047f	48 6b c9 03	 imul	 rcx, rcx, 3
  00483	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00488	0f b7 d0	 movzx	 edx, ax
  0048b	e8 00 00 00 00	 call	 store_hw_noswap

; 5686 :     pMPC_PUSre[3]->what = PUS_WHAT_04;

  00490	b8 08 00 00 00	 mov	 eax, 8
  00495	48 6b c0 03	 imul	 rax, rax, 3
  00499	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0049e	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5687 :     pMPC_PUSre[3]->type = PUS_TYPE_02;

  004a2	b8 08 00 00 00	 mov	 eax, 8
  004a7	48 6b c0 03	 imul	 rax, rax, 3
  004ab	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004b0	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5688 :     pMPC_PUSre[3]->vc.pus_02.b.unknown04 = 0x02;         // !!! //

  004b4	b8 08 00 00 00	 mov	 eax, 8
  004b9	48 6b c0 03	 imul	 rax, rax, 3
  004bd	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004c2	c6 40 04 02	 mov	 BYTE PTR [rax+4], 2

; 5689 :     pMPC_PUSre[3]->vc.pus_02.b.flags = 0x90;         // !!! //

  004c6	b8 08 00 00 00	 mov	 eax, 8
  004cb	48 6b c0 03	 imul	 rax, rax, 3
  004cf	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004d4	c6 40 05 90	 mov	 BYTE PTR [rax+5], 144	; 00000090H

; 5690 :     pMPC_PUSre[3]->vc.pus_02.b.unknown0A = 0x40;         // !!! //

  004d8	b8 08 00 00 00	 mov	 eax, 8
  004dd	48 6b c0 03	 imul	 rax, rax, 3
  004e1	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004e6	c6 40 0a 40	 mov	 BYTE PTR [rax+10], 64	; 00000040H

; 5691 : #if defined(ENABLE_IPV6)
; 5692 :     if (pPTPBLK->fIPv4Spec)

  004ea	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004ef	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  004f2	83 e0 01	 and	 eax, 1
  004f5	85 c0		 test	 eax, eax
  004f7	74 1e		 je	 SHORT $LN3@build_417E

; 5693 :     {
; 5694 : #endif /* defined(ENABLE_IPV6) */
; 5695 :         memcpy( pMPC_PUSre[3]->vc.pus_02.b.ipaddr, &pPTPBLK->iaDriveIPAddr4, 4 );

  004f9	b8 08 00 00 00	 mov	 eax, 8
  004fe	48 6b c0 03	 imul	 rax, rax, 3
  00502	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00507	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0050c	8b 89 d8 02 00
	00		 mov	 ecx, DWORD PTR [rcx+728]
  00512	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5696 : #if defined(ENABLE_IPV6)
; 5697 :     }

  00515	eb 4b		 jmp	 SHORT $LN4@build_417E
$LN3@build_417E:

; 5698 :     else
; 5699 :     {
; 5700 :         pMPC_PUSre[1]->vc.pus_02.b.flags |= 0x08;

  00517	b8 08 00 00 00	 mov	 eax, 8
  0051c	48 6b c0 01	 imul	 rax, rax, 1
  00520	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00525	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00529	83 c8 08	 or	 eax, 8
  0052c	b9 08 00 00 00	 mov	 ecx, 8
  00531	48 6b c9 01	 imul	 rcx, rcx, 1
  00535	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  0053a	88 41 05	 mov	 BYTE PTR [rcx+5], al

; 5701 :         memcpy( pMPC_PUSre[3]->vc.pus_02.b.ipaddr, &pPTPBLK->iaDriveLLAddr6, 16 );

  0053d	b8 08 00 00 00	 mov	 eax, 8
  00542	48 6b c0 03	 imul	 rax, rax, 3
  00546	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0054b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00550	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  00554	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  0055b	b9 10 00 00 00	 mov	 ecx, 16
  00560	f3 a4		 rep movsb
$LN4@build_417E:

; 5702 :     }
; 5703 : #endif /* defined(ENABLE_IPV6) */
; 5704 : 
; 5705 :     // Display various information, maybe
; 5706 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00562	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00567	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0056a	83 e0 10	 and	 eax, 16
  0056d	85 c0		 test	 eax, eax
  0056f	74 15		 je	 SHORT $LN5@build_417E

; 5707 :     {
; 5708 :         mpc_display_description( pDEVBLK, "Out RRH 0x417E (CmComm) PUK 0x4104 (ULP_SETUP)" );

  00571	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172061
  00578	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00580	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN5@build_417E:

; 5709 :     }
; 5710 : 
; 5711 :     return pPTPHDRre;

  00586	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_417E:

; 5712 : }   /* End function  build_417E_ulp_setup() */

  0058b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00593	48 33 cc	 xor	 rcx, rsp
  00596	e8 00 00 00 00	 call	 __security_check_cookie
  0059b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  005a2	5f		 pop	 rdi
  005a3	5e		 pop	 rsi
  005a4	c3		 ret	 0
build_417E_ulp_setup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength4$ = 32
pMPC_RRHre$ = 40
pMPC_PUSre$ = 48
uLength3$ = 64
pPTPBLK$ = 72
pMPC_THre$ = 80
uLength1$ = 88
tv154 = 92
uLength2$ = 96
rc$ = 100
pMPC_PUKre$ = 104
pMPC_PHre$ = 112
pPTPHDRre$ = 120
pPTPATH$ = 128
pDEVBLK$ = 176
pMPC_RRHwr$ = 184
pMPC_PUSwr$ = 192
fxSideWins$ = 200
build_417E_ulp_enable PROC

; 5432 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 5433 : 
; 5434 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  0001d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00025	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0002c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 5435 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00034	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003f	48 89 44 24 48	 mov	 QWORD PTR pPTPBLK$[rsp], rax
$LN4@build_417E:

; 5436 :     U32        uLength1;
; 5437 :     U32        uLength2;
; 5438 :     U32        uLength3;
; 5439 :     U16        uLength4;
; 5440 :     PTPHDR*    pPTPHDRre;       // PTPHDR to be read
; 5441 :     MPC_TH*    pMPC_THre;       // MPC_TH follows PTPHDR
; 5442 :     MPC_RRH*   pMPC_RRHre;      // MPC_RRH follows MPC_TH
; 5443 :     MPC_PH*    pMPC_PHre;       // MPC_PH follows MPC_RRH
; 5444 :     MPC_PUK*   pMPC_PUKre;      // MPC_PUK follows MPC_PH
; 5445 :     MPC_PUS*    pMPC_PUSre[2];  // MPC_PUSs follow MPC_PUK
; 5446 :     int        rc;
; 5447 : 
; 5448 :     UNREFERENCED( pMPC_RRHwr );

  00044	33 c0		 xor	 eax, eax
  00046	85 c0		 test	 eax, eax
  00048	75 fa		 jne	 SHORT $LN4@build_417E

; 5449 : 
; 5450 : 
; 5451 :     // Allocate a buffer in which the response will be build.
; 5452 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  0004a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0004f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00057	e8 00 00 00 00	 call	 alloc_ptp_buffer
  0005c	48 89 44 24 78	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 5453 :     if (!pPTPHDRre)

  00061	48 83 7c 24 78
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00067	75 07		 jne	 SHORT $LN5@build_417E

; 5454 :         return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 e8 04 00 00	 jmp	 $LN1@build_417E
$LN5@build_417E:

; 5455 : 
; 5456 :     // Fix-up various lengths
; 5457 :     uLength4 = SIZE_PUS_01 +                  // first MPC_PUS (0x0401)

  00070	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  00075	66 89 44 24 20	 mov	 WORD PTR uLength4$[rsp], ax

; 5458 :                SIZE_PUS_02_B;                 // second MPC_PUS (0x0402)
; 5459 :     uLength3 = SIZE_PUK + uLength4;           // the MPC_PUK and the MPC_PUSs (the data)

  0007a	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength4$[rsp]
  0007f	83 c0 0c	 add	 eax, 12
  00082	89 44 24 40	 mov	 DWORD PTR uLength3$[rsp], eax

; 5460 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00086	c7 44 24 60 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 5461 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  0008e	8b 44 24 40	 mov	 eax, DWORD PTR uLength3$[rsp]
  00092	8b 4c 24 60	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00096	03 c8		 add	 ecx, eax
  00098	8b c1		 mov	 eax, ecx
  0009a	89 44 24 58	 mov	 DWORD PTR uLength1$[rsp], eax

; 5462 : 
; 5463 :     // Fix-up various pointers
; 5464 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000a3	48 83 c0 10	 add	 rax, 16
  000a7	48 89 44 24 50	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 5465 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  000b1	48 83 c0 14	 add	 rax, 20
  000b5	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 5466 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  000ba	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  000bf	48 83 c0 24	 add	 rax, 36			; 00000024H
  000c3	48 89 44 24 70	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 5467 :     pMPC_PUKre = (MPC_PUK*)((BYTE*)pMPC_PHre + SIZE_PH);

  000c8	48 8b 44 24 70	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000cd	48 83 c0 08	 add	 rax, 8
  000d1	48 89 44 24 68	 mov	 QWORD PTR pMPC_PUKre$[rsp], rax

; 5468 :     pMPC_PUSre[0] = (MPC_PUS*)((BYTE*)pMPC_PUKre + SIZE_PUK);

  000d6	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  000db	48 83 c0 0c	 add	 rax, 12
  000df	b9 08 00 00 00	 mov	 ecx, 8
  000e4	48 6b c9 00	 imul	 rcx, rcx, 0
  000e8	48 89 44 0c 30	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5469 :     pMPC_PUSre[1] = (MPC_PUS*)((BYTE*)pMPC_PUSre[0] + SIZE_PUS_01);

  000ed	b8 08 00 00 00	 mov	 eax, 8
  000f2	48 6b c0 00	 imul	 rax, rax, 0
  000f6	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  000fb	48 83 c0 0b	 add	 rax, 11
  000ff	b9 08 00 00 00	 mov	 ecx, 8
  00104	48 6b c9 01	 imul	 rcx, rcx, 1
  00108	48 89 44 0c 30	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5470 : 
; 5471 :     // Prepare PTPHDRre
; 5472 :     pPTPHDRre->iDataLen = uLength1;

  0010d	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  00112	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00116	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5473 : 
; 5474 :     // Prepare MPC_THre
; 5475 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00119	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  0011e	e8 00 00 00 00	 call	 _byteswap_ulong
  00123	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00128	8b d0		 mov	 edx, eax
  0012a	e8 00 00 00 00	 call	 store_fw_noswap

; 5476 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  0012f	b9 14 00 00 00	 mov	 ecx, 20
  00134	e8 00 00 00 00	 call	 _byteswap_ulong
  00139	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0013e	48 83 c1 08	 add	 rcx, 8
  00142	8b d0		 mov	 edx, eax
  00144	e8 00 00 00 00	 call	 store_fw_noswap

; 5477 :     STORE_FW( pMPC_THre->length, uLength1 );

  00149	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0014d	e8 00 00 00 00	 call	 _byteswap_ulong
  00152	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00157	48 83 c1 0c	 add	 rcx, 12
  0015b	8b d0		 mov	 edx, eax
  0015d	e8 00 00 00 00	 call	 store_fw_noswap

; 5478 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  00162	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00166	e8 00 00 00 00	 call	 _byteswap_ushort
  0016b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00170	48 83 c1 10	 add	 rcx, 16
  00174	0f b7 d0	 movzx	 edx, ax
  00177	e8 00 00 00 00	 call	 store_hw_noswap

; 5479 :     STORE_HW( pMPC_THre->numrrh, 1 );

  0017c	66 b9 01 00	 mov	 cx, 1
  00180	e8 00 00 00 00	 call	 _byteswap_ushort
  00185	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0018a	48 83 c1 12	 add	 rcx, 18
  0018e	0f b7 d0	 movzx	 edx, ax
  00191	e8 00 00 00 00	 call	 store_hw_noswap

; 5480 : 
; 5481 :     // Prepare MPC_RRHre
; 5482 :     pMPC_RRHre->type = RRH_TYPE_ULP;

  00196	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0019b	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 5483 :     pMPC_RRHre->proto = PROTOCOL_UNKNOWN;

  0019f	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001a4	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5484 :     STORE_HW( pMPC_RRHre->numph, 1 );

  001a8	66 b9 01 00	 mov	 cx, 1
  001ac	e8 00 00 00 00	 call	 _byteswap_ushort
  001b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001b6	48 83 c1 06	 add	 rcx, 6
  001ba	0f b7 d0	 movzx	 edx, ax
  001bd	e8 00 00 00 00	 call	 store_hw_noswap

; 5485 :     STORE_FW( pMPC_RRHre->seqnum, ++pPTPBLK->uSeqNumCm );

  001c2	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001c7	8b 80 7e 03 00
	00		 mov	 eax, DWORD PTR [rax+894]
  001cd	ff c0		 inc	 eax
  001cf	89 44 24 5c	 mov	 DWORD PTR tv154[rsp], eax
  001d3	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001d8	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv154[rsp]
  001dc	89 88 7e 03 00
	00		 mov	 DWORD PTR [rax+894], ecx
  001e2	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv154[rsp]
  001e6	e8 00 00 00 00	 call	 _byteswap_ulong
  001eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001f0	48 83 c1 08	 add	 rcx, 8
  001f4	8b d0		 mov	 edx, eax
  001f6	e8 00 00 00 00	 call	 store_fw_noswap

; 5486 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  001fb	66 b9 24 00	 mov	 cx, 36			; 00000024H
  001ff	e8 00 00 00 00	 call	 _byteswap_ushort
  00204	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00209	48 83 c1 10	 add	 rcx, 16
  0020d	0f b7 d0	 movzx	 edx, ax
  00210	e8 00 00 00 00	 call	 store_hw_noswap

; 5487 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00215	0f b7 4c 24 40	 movzx	 ecx, WORD PTR uLength3$[rsp]
  0021a	e8 00 00 00 00	 call	 _byteswap_ushort
  0021f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00224	48 83 c1 12	 add	 rcx, 18
  00228	0f b7 d0	 movzx	 edx, ax
  0022b	e8 00 00 00 00	 call	 store_hw_noswap

; 5488 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00230	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00234	e8 00 00 00 00	 call	 _byteswap_ulong
  00239	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0023e	48 83 c1 14	 add	 rcx, 20
  00242	8b d0		 mov	 edx, eax
  00244	e8 00 00 00 00	 call	 store_f3_noswap

; 5489 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00249	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0024e	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5490 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenCmConnection, MPC_TOKEN_LENGTH );

  00252	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00257	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0025c	8b 89 68 03 00
	00		 mov	 ecx, DWORD PTR [rcx+872]
  00262	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5491 : 
; 5492 :     // Prepare MPC_PHre
; 5493 :     pMPC_PHre->locdata = PH_LOC_1;

  00265	48 8b 44 24 70	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  0026a	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5494 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  0026d	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00271	e8 00 00 00 00	 call	 _byteswap_ulong
  00276	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  0027b	48 ff c1	 inc	 rcx
  0027e	8b d0		 mov	 edx, eax
  00280	e8 00 00 00 00	 call	 store_f3_noswap

; 5495 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  00285	8b 4c 24 60	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00289	e8 00 00 00 00	 call	 _byteswap_ulong
  0028e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  00293	48 83 c1 04	 add	 rcx, 4
  00297	8b d0		 mov	 edx, eax
  00299	e8 00 00 00 00	 call	 store_fw_noswap

; 5496 : 
; 5497 :     // Prepare MPC_PUKre
; 5498 :     STORE_HW( pMPC_PUKre->length, SIZE_PUK );

  0029e	66 b9 0c 00	 mov	 cx, 12
  002a2	e8 00 00 00 00	 call	 _byteswap_ushort
  002a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  002ac	0f b7 d0	 movzx	 edx, ax
  002af	e8 00 00 00 00	 call	 store_hw_noswap

; 5499 :     pMPC_PUKre->what = PUK_WHAT_41;

  002b4	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  002b9	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5500 :     pMPC_PUKre->type = PUK_TYPE_ENABLE;

  002bd	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  002c2	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5501 :     STORE_HW( pMPC_PUKre->lenpus, uLength4 );

  002c6	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength4$[rsp]
  002cb	e8 00 00 00 00	 call	 _byteswap_ushort
  002d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  002d5	48 83 c1 04	 add	 rcx, 4
  002d9	0f b7 d0	 movzx	 edx, ax
  002dc	e8 00 00 00 00	 call	 store_hw_noswap

; 5502 : 
; 5503 :     // Prepare first MPC_PUSre
; 5504 :     STORE_HW( pMPC_PUSre[0]->length, SIZE_PUS_01 );

  002e1	66 b9 0b 00	 mov	 cx, 11
  002e5	e8 00 00 00 00	 call	 _byteswap_ushort
  002ea	b9 08 00 00 00	 mov	 ecx, 8
  002ef	48 6b c9 00	 imul	 rcx, rcx, 0
  002f3	48 8b 4c 0c 30	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  002f8	0f b7 d0	 movzx	 edx, ax
  002fb	e8 00 00 00 00	 call	 store_hw_noswap

; 5505 :     pMPC_PUSre[0]->what = PUS_WHAT_04;

  00300	b8 08 00 00 00	 mov	 eax, 8
  00305	48 6b c0 00	 imul	 rax, rax, 0
  00309	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0030e	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5506 :     pMPC_PUSre[0]->type = PUS_TYPE_01;

  00312	b8 08 00 00 00	 mov	 eax, 8
  00317	48 6b c0 00	 imul	 rax, rax, 0
  0031b	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00320	c6 40 03 01	 mov	 BYTE PTR [rax+3], 1

; 5507 :     pMPC_PUSre[0]->vc.pus_01.proto = PROTOCOL_LAYER2;

  00324	b8 08 00 00 00	 mov	 eax, 8
  00329	48 6b c0 00	 imul	 rax, rax, 0
  0032d	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00332	c6 40 04 08	 mov	 BYTE PTR [rax+4], 8

; 5508 :     pMPC_PUSre[0]->vc.pus_01.unknown05 = 0x01;           // !!! //

  00336	b8 08 00 00 00	 mov	 eax, 8
  0033b	48 6b c0 00	 imul	 rax, rax, 0
  0033f	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00344	c6 40 05 01	 mov	 BYTE PTR [rax+5], 1

; 5509 :     pMPC_PUSre[0]->vc.pus_01.tokenx5 = MPC_TOKEN_X5;

  00348	b8 08 00 00 00	 mov	 eax, 8
  0034d	48 6b c0 00	 imul	 rax, rax, 0
  00351	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00356	c6 40 06 05	 mov	 BYTE PTR [rax+6], 5

; 5510 :     memcpy( pMPC_PUSre[0]->vc.pus_01.token, pPTPBLK->xTokenUlpFilter, MPC_TOKEN_LENGTH );

  0035a	b8 08 00 00 00	 mov	 eax, 8
  0035f	48 6b c0 00	 imul	 rax, rax, 0
  00363	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00368	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0036d	8b 89 49 03 00
	00		 mov	 ecx, DWORD PTR [rcx+841]
  00373	89 48 07	 mov	 DWORD PTR [rax+7], ecx

; 5511 : 
; 5512 :     // Prepare second MPC_PUSre
; 5513 :     // Note: the 40-bytes placed in the second MPC_PUS are important.
; 5514 :     // Whichever side has the lowest value 'wins', and dictates the
; 5515 :     // 'handedness' of the RRH 0x417E exchanges. If this code 'wins'
; 5516 :     // and then acts like a 'loser', confusion reigns.
; 5517 :     STORE_HW( pMPC_PUSre[1]->length, SIZE_PUS_02_B );

  00376	66 b9 2c 00	 mov	 cx, 44			; 0000002cH
  0037a	e8 00 00 00 00	 call	 _byteswap_ushort
  0037f	b9 08 00 00 00	 mov	 ecx, 8
  00384	48 6b c9 01	 imul	 rcx, rcx, 1
  00388	48 8b 4c 0c 30	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  0038d	0f b7 d0	 movzx	 edx, ax
  00390	e8 00 00 00 00	 call	 store_hw_noswap

; 5518 :     pMPC_PUSre[1]->what = PUS_WHAT_04;

  00395	b8 08 00 00 00	 mov	 eax, 8
  0039a	48 6b c0 01	 imul	 rax, rax, 1
  0039e	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003a3	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5519 :     pMPC_PUSre[1]->type = PUS_TYPE_02;

  003a7	b8 08 00 00 00	 mov	 eax, 8
  003ac	48 6b c0 01	 imul	 rax, rax, 1
  003b0	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003b5	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5520 :     pMPC_PUSre[1]->vc.pus_02.b.unknown04 = 0x02;         // !!! //

  003b9	b8 08 00 00 00	 mov	 eax, 8
  003be	48 6b c0 01	 imul	 rax, rax, 1
  003c2	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003c7	c6 40 04 02	 mov	 BYTE PTR [rax+4], 2

; 5521 :     pMPC_PUSre[1]->vc.pus_02.b.flags = 0x90;         // !!! //

  003cb	b8 08 00 00 00	 mov	 eax, 8
  003d0	48 6b c0 01	 imul	 rax, rax, 1
  003d4	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003d9	c6 40 05 90	 mov	 BYTE PTR [rax+5], 144	; 00000090H

; 5522 :     pMPC_PUSre[1]->vc.pus_02.b.unknown0A = 0x40;         // !!! //

  003dd	b8 08 00 00 00	 mov	 eax, 8
  003e2	48 6b c0 01	 imul	 rax, rax, 1
  003e6	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003eb	c6 40 0a 40	 mov	 BYTE PTR [rax+10], 64	; 00000040H

; 5523 : #if defined(ENABLE_IPV6)
; 5524 :     if (pPTPBLK->fIPv4Spec)

  003ef	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003f4	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  003f7	83 e0 01	 and	 eax, 1
  003fa	85 c0		 test	 eax, eax
  003fc	74 1e		 je	 SHORT $LN6@build_417E

; 5525 :     {
; 5526 : #endif /* defined(ENABLE_IPV6) */
; 5527 :         memcpy( pMPC_PUSre[1]->vc.pus_02.b.ipaddr, &pPTPBLK->iaDriveIPAddr4, 4 );

  003fe	b8 08 00 00 00	 mov	 eax, 8
  00403	48 6b c0 01	 imul	 rax, rax, 1
  00407	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0040c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00411	8b 89 d8 02 00
	00		 mov	 ecx, DWORD PTR [rcx+728]
  00417	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5528 : #if defined(ENABLE_IPV6)
; 5529 :     }

  0041a	eb 4b		 jmp	 SHORT $LN7@build_417E
$LN6@build_417E:

; 5530 :     else
; 5531 :     {
; 5532 :         pMPC_PUSre[1]->vc.pus_02.b.flags |= 0x08;

  0041c	b8 08 00 00 00	 mov	 eax, 8
  00421	48 6b c0 01	 imul	 rax, rax, 1
  00425	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0042a	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0042e	83 c8 08	 or	 eax, 8
  00431	b9 08 00 00 00	 mov	 ecx, 8
  00436	48 6b c9 01	 imul	 rcx, rcx, 1
  0043a	48 8b 4c 0c 30	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  0043f	88 41 05	 mov	 BYTE PTR [rcx+5], al

; 5533 :         memcpy( pMPC_PUSre[1]->vc.pus_02.b.ipaddr, &pPTPBLK->iaDriveLLAddr6, 16 );

  00442	b8 08 00 00 00	 mov	 eax, 8
  00447	48 6b c0 01	 imul	 rax, rax, 1
  0044b	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00450	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00455	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  00459	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  00460	b9 10 00 00 00	 mov	 ecx, 16
  00465	f3 a4		 rep movsb
$LN7@build_417E:

; 5534 :     }
; 5535 : #endif /* defined(ENABLE_IPV6) */
; 5536 : 
; 5537 :     // Compare the IP address in the MPC_PUSwr with the IP address in
; 5538 :     // the second MPC_PUSre to determine which side wins. First, check
; 5539 :     // whether both sides are using the same variety of IP address.
; 5540 :     if (( pMPC_PUSwr->vc.pus_02.b.flags & 0x08 ) == ( pMPC_PUSre[1]->vc.pus_02.b.flags & 0x08 ))

  00467	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSwr$[rsp]
  0046f	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00473	83 e0 08	 and	 eax, 8
  00476	b9 08 00 00 00	 mov	 ecx, 8
  0047b	48 6b c9 01	 imul	 rcx, rcx, 1
  0047f	48 8b 4c 0c 30	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00484	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  00488	83 e1 08	 and	 ecx, 8
  0048b	3b c1		 cmp	 eax, ecx
  0048d	75 6e		 jne	 SHORT $LN8@build_417E

; 5541 :     {
; 5542 :         // Both sides are using the same variety of IP address.
; 5543 :         rc = memcmp( &pMPC_PUSwr->vc.pus_02.b.ipaddr, &pMPC_PUSre[1]->vc.pus_02.b.ipaddr, 16 );

  0048f	b8 08 00 00 00	 mov	 eax, 8
  00494	48 6b c0 01	 imul	 rax, rax, 1
  00498	48 8b 44 04 30	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0049d	48 83 c0 0c	 add	 rax, 12
  004a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PUSwr$[rsp]
  004a9	48 83 c1 0c	 add	 rcx, 12
  004ad	41 b8 10 00 00
	00		 mov	 r8d, 16
  004b3	48 8b d0	 mov	 rdx, rax
  004b6	e8 00 00 00 00	 call	 memcmp
  004bb	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 5544 :         if (rc < 0)

  004bf	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  004c4	7d 10		 jge	 SHORT $LN10@build_417E

; 5545 :             // The y-side's IP address is lower than the x-side's.
; 5546 :             *fxSideWins = TRUE;     // i.e. the x-side wins

  004c6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR fxSideWins$[rsp]
  004ce	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
  004d4	eb 25		 jmp	 SHORT $LN11@build_417E
$LN10@build_417E:

; 5547 :         else if (rc > 0)

  004d6	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  004db	7e 10		 jle	 SHORT $LN12@build_417E

; 5548 :             // The y-side's IP address is higher than the x-side's.
; 5549 :             *fxSideWins = FALSE;    // i.e. the y-side wins

  004dd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR fxSideWins$[rsp]
  004e5	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  004eb	eb 0e		 jmp	 SHORT $LN13@build_417E
$LN12@build_417E:

; 5550 :         else
; 5551 :             // This shouldn't happen; the y-side and the x-side have the
; 5552 :             // same IP address! Empirical evidence suggests that in
; 5553 :             // these circumstances each side believes that it has the
; 5554 :             // lower address. As a result communication between them
; 5555 :             // stalls, with each side waiting for the other side to send
; 5556 :             // the next message. Presumably the VTAM coders didn't think
; 5557 :             // anyone would be daft enough to give both sides the same
; 5558 :             // IP address, or possibly they didn't think of it at all.
; 5559 :             // Until a stop command is issued on the y-side nothing else
; 5560 :             // will happen. However, to prevent that unhappy situation
; 5561 :             // we will deem ourselves the winner.
; 5562 :             *fxSideWins = TRUE;     // i.e. the x-side wins

  004ed	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR fxSideWins$[rsp]
  004f5	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN13@build_417E:
$LN11@build_417E:

; 5563 :     }

  004fb	eb 32		 jmp	 SHORT $LN9@build_417E
$LN8@build_417E:

; 5564 :     else
; 5565 :     {
; 5566 :         // One side is using an IPv4 address, the other an IPv6 address.
; 5567 :         // This is normal behaviour when one side is starting both the
; 5568 :         // IPv4 and IPv6 connections, and the other is only starting the
; 5569 :         // IPv6 connection. The side that is using the IPv4 address is
; 5570 :         // the winner. Check the y-side's variety of IP address.
; 5571 :         if (( pMPC_PUSwr->vc.pus_02.b.flags & 0x08 ) == 0x08)

  004fd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSwr$[rsp]
  00505	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00509	83 e0 08	 and	 eax, 8
  0050c	83 f8 08	 cmp	 eax, 8
  0050f	75 10		 jne	 SHORT $LN14@build_417E

; 5572 :             *fxSideWins = TRUE;     // i.e. the x-side wins, it's using IPv4

  00511	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR fxSideWins$[rsp]
  00519	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
  0051f	eb 0e		 jmp	 SHORT $LN15@build_417E
$LN14@build_417E:

; 5573 :         else
; 5574 :             *fxSideWins = FALSE;    // i.e. the y-side wins, it's using IPv4

  00521	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR fxSideWins$[rsp]
  00529	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN15@build_417E:
$LN9@build_417E:

; 5575 :     }
; 5576 : 
; 5577 :     // Display various information, maybe
; 5578 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0052f	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00534	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00537	83 e0 10	 and	 eax, 16
  0053a	85 c0		 test	 eax, eax
  0053c	74 15		 je	 SHORT $LN16@build_417E

; 5579 :     {
; 5580 :         mpc_display_description( pDEVBLK, "Out RRH 0x417E (CmComm) PUK 0x4102 (ULP_ENABLE)" );

  0053e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172020
  00545	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0054d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN16@build_417E:

; 5581 :     }
; 5582 : 
; 5583 :     return pPTPHDRre;

  00553	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_417E:

; 5584 : }   /* End function  build_417E_ulp_enable() */

  00558	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0055f	5f		 pop	 rdi
  00560	5e		 pop	 rsi
  00561	c3		 ret	 0
build_417E_ulp_enable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength4$ = 32
pMPC_RRHre$ = 40
uLength3$ = 48
pMPC_THre$ = 56
pPTPBLK$ = 64
uLength1$ = 72
tv158 = 76
uLength2$ = 80
pMPC_PUKre$ = 88
pMPC_PHre$ = 96
pPTPHDRre$ = 104
pPTPATH$ = 112
pMPC_PUSre$ = 120
__$ArrayPad$ = 144
pDEVBLK$ = 176
pMPC_RRHwr$ = 184
build_417E_cm_confirm PROC

; 5326 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5327 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00023	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0002b	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00032	48 89 44 24 70	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 5328 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00037	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003f	48 89 44 24 40	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 5329 :     U32        uLength1;
; 5330 :     U32        uLength2;
; 5331 :     U32        uLength3;
; 5332 :     U16        uLength4;
; 5333 :     PTPHDR*    pPTPHDRre;       // PTPHDR to be read
; 5334 :     MPC_TH*    pMPC_THre;       // MPC_TH follows PTPHDR
; 5335 :     MPC_RRH*   pMPC_RRHre;      // MPC_RRH follows MPC_TH
; 5336 :     MPC_PH*    pMPC_PHre;       // MPC_PH follows MPC_RRH
; 5337 :     MPC_PUK*   pMPC_PUKre;      // MPC_PUK follows MPC_PH
; 5338 :     MPC_PUS*   pMPC_PUSre[3];   // MPC_PUSs follow MPC_PUK
; 5339 : 
; 5340 : 
; 5341 :     // Allocate a buffer.
; 5342 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00044	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00049	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00051	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00056	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 5343 :     if (!pPTPHDRre)

  0005b	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00061	75 07		 jne	 SHORT $LN2@build_417E

; 5344 :         return NULL;

  00063	33 c0		 xor	 eax, eax
  00065	e9 0e 04 00 00	 jmp	 $LN1@build_417E
$LN2@build_417E:

; 5345 : 
; 5346 :     // Fix-up various lengths
; 5347 :     uLength4 = SIZE_PUS_04 +                  // first MPC_PUS (0x0404)

  0006a	b8 1a 00 00 00	 mov	 eax, 26
  0006f	66 89 44 24 20	 mov	 WORD PTR uLength4$[rsp], ax

; 5348 :                SIZE_PUS_08 +                  // second MPC_PUS (0x0408)
; 5349 :                SIZE_PUS_07;                   // third MPC_PUS (0x0407)
; 5350 :     uLength3 = SIZE_PUK + uLength4;           // the MPC_PUK and the MPC_PUSs (the data)

  00074	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength4$[rsp]
  00079	83 c0 0c	 add	 eax, 12
  0007c	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 5351 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00080	c7 44 24 50 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 5352 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  00088	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  0008c	8b 4c 24 50	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00090	03 c8		 add	 ecx, eax
  00092	8b c1		 mov	 eax, ecx
  00094	89 44 24 48	 mov	 DWORD PTR uLength1$[rsp], eax

; 5353 : 
; 5354 :     // Fix-up various pointers
; 5355 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00098	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0009d	48 83 c0 10	 add	 rax, 16
  000a1	48 89 44 24 38	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 5356 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  000a6	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  000ab	48 83 c0 14	 add	 rax, 20
  000af	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 5357 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  000b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  000b9	48 83 c0 24	 add	 rax, 36			; 00000024H
  000bd	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 5358 :     pMPC_PUKre = (MPC_PUK*)((BYTE*)pMPC_PHre + SIZE_PH);

  000c2	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000c7	48 83 c0 08	 add	 rax, 8
  000cb	48 89 44 24 58	 mov	 QWORD PTR pMPC_PUKre$[rsp], rax

; 5359 :     pMPC_PUSre[0] = (MPC_PUS*)((BYTE*)pMPC_PUKre + SIZE_PUK);

  000d0	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  000d5	48 83 c0 0c	 add	 rax, 12
  000d9	b9 08 00 00 00	 mov	 ecx, 8
  000de	48 6b c9 00	 imul	 rcx, rcx, 0
  000e2	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5360 :     pMPC_PUSre[1] = (MPC_PUS*)((BYTE*)pMPC_PUSre[0] + SIZE_PUS_04);

  000e7	b8 08 00 00 00	 mov	 eax, 8
  000ec	48 6b c0 00	 imul	 rax, rax, 0
  000f0	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  000f5	48 83 c0 09	 add	 rax, 9
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5361 :     pMPC_PUSre[2] = (MPC_PUS*)((BYTE*)pMPC_PUSre[1] + SIZE_PUS_08);

  00107	b8 08 00 00 00	 mov	 eax, 8
  0010c	48 6b c0 01	 imul	 rax, rax, 1
  00110	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00115	48 83 c0 09	 add	 rax, 9
  00119	b9 08 00 00 00	 mov	 ecx, 8
  0011e	48 6b c9 02	 imul	 rcx, rcx, 2
  00122	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5362 : 
; 5363 :     // Prepare PTPHDRre
; 5364 :     pPTPHDRre->iDataLen = uLength1;

  00127	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0012c	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00130	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5365 : 
; 5366 :     // Prepare MPC_THre
; 5367 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00133	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00138	e8 00 00 00 00	 call	 _byteswap_ulong
  0013d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00142	8b d0		 mov	 edx, eax
  00144	e8 00 00 00 00	 call	 store_fw_noswap

; 5368 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  00149	b9 14 00 00 00	 mov	 ecx, 20
  0014e	e8 00 00 00 00	 call	 _byteswap_ulong
  00153	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00158	48 83 c1 08	 add	 rcx, 8
  0015c	8b d0		 mov	 edx, eax
  0015e	e8 00 00 00 00	 call	 store_fw_noswap

; 5369 :     STORE_FW( pMPC_THre->length, uLength1 );

  00163	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00167	e8 00 00 00 00	 call	 _byteswap_ulong
  0016c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00171	48 83 c1 0c	 add	 rcx, 12
  00175	8b d0		 mov	 edx, eax
  00177	e8 00 00 00 00	 call	 store_fw_noswap

; 5370 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  0017c	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00180	e8 00 00 00 00	 call	 _byteswap_ushort
  00185	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0018a	48 83 c1 10	 add	 rcx, 16
  0018e	0f b7 d0	 movzx	 edx, ax
  00191	e8 00 00 00 00	 call	 store_hw_noswap

; 5371 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00196	66 b9 01 00	 mov	 cx, 1
  0019a	e8 00 00 00 00	 call	 _byteswap_ushort
  0019f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  001a4	48 83 c1 12	 add	 rcx, 18
  001a8	0f b7 d0	 movzx	 edx, ax
  001ab	e8 00 00 00 00	 call	 store_hw_noswap

; 5372 : 
; 5373 :     // Prepare MPC_RRHre
; 5374 :     pMPC_RRHre->type = RRH_TYPE_ULP;

  001b0	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b5	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 5375 :     pMPC_RRHre->proto = PROTOCOL_UNKNOWN;

  001b9	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001be	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5376 :     STORE_HW( pMPC_RRHre->numph, 1 );

  001c2	66 b9 01 00	 mov	 cx, 1
  001c6	e8 00 00 00 00	 call	 _byteswap_ushort
  001cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001d0	48 83 c1 06	 add	 rcx, 6
  001d4	0f b7 d0	 movzx	 edx, ax
  001d7	e8 00 00 00 00	 call	 store_hw_noswap

; 5377 :     STORE_FW( pMPC_RRHre->seqnum, ++pPTPBLK->uSeqNumIssuer );

  001dc	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001e1	8b 80 7a 03 00
	00		 mov	 eax, DWORD PTR [rax+890]
  001e7	ff c0		 inc	 eax
  001e9	89 44 24 4c	 mov	 DWORD PTR tv158[rsp], eax
  001ed	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001f2	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv158[rsp]
  001f6	89 88 7a 03 00
	00		 mov	 DWORD PTR [rax+890], ecx
  001fc	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv158[rsp]
  00200	e8 00 00 00 00	 call	 _byteswap_ulong
  00205	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0020a	48 83 c1 08	 add	 rcx, 8
  0020e	8b d0		 mov	 edx, eax
  00210	e8 00 00 00 00	 call	 store_fw_noswap

; 5378 :     memcpy( pMPC_RRHre->ackseq, pMPC_RRHwr->seqnum, 4 );

  00215	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0021a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  00222	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00225	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5379 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00228	66 b9 24 00	 mov	 cx, 36			; 00000024H
  0022c	e8 00 00 00 00	 call	 _byteswap_ushort
  00231	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00236	48 83 c1 10	 add	 rcx, 16
  0023a	0f b7 d0	 movzx	 edx, ax
  0023d	e8 00 00 00 00	 call	 store_hw_noswap

; 5380 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00242	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00247	e8 00 00 00 00	 call	 _byteswap_ushort
  0024c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00251	48 83 c1 12	 add	 rcx, 18
  00255	0f b7 d0	 movzx	 edx, ax
  00258	e8 00 00 00 00	 call	 store_hw_noswap

; 5381 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  0025d	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00261	e8 00 00 00 00	 call	 _byteswap_ulong
  00266	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0026b	48 83 c1 14	 add	 rcx, 20
  0026f	8b d0		 mov	 edx, eax
  00271	e8 00 00 00 00	 call	 store_f3_noswap

; 5382 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00276	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0027b	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5383 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenIssuerRm, MPC_TOKEN_LENGTH );

  0027f	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00284	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00289	8b 89 60 03 00
	00		 mov	 ecx, DWORD PTR [rcx+864]
  0028f	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5384 : 
; 5385 :     // Prepare MPC_PHre
; 5386 :     pMPC_PHre->locdata = PH_LOC_1;

  00292	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  00297	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5387 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  0029a	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0029e	e8 00 00 00 00	 call	 _byteswap_ulong
  002a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002a8	48 ff c1	 inc	 rcx
  002ab	8b d0		 mov	 edx, eax
  002ad	e8 00 00 00 00	 call	 store_f3_noswap

; 5388 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  002b2	8b 4c 24 50	 mov	 ecx, DWORD PTR uLength2$[rsp]
  002b6	e8 00 00 00 00	 call	 _byteswap_ulong
  002bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002c0	48 83 c1 04	 add	 rcx, 4
  002c4	8b d0		 mov	 edx, eax
  002c6	e8 00 00 00 00	 call	 store_fw_noswap

; 5389 : 
; 5390 :     // Prepare MPC_PUKre
; 5391 :     STORE_HW( pMPC_PUKre->length, SIZE_PUK );

  002cb	66 b9 0c 00	 mov	 cx, 12
  002cf	e8 00 00 00 00	 call	 _byteswap_ushort
  002d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  002d9	0f b7 d0	 movzx	 edx, ax
  002dc	e8 00 00 00 00	 call	 store_hw_noswap

; 5392 :     pMPC_PUKre->what = PUK_WHAT_41;

  002e1	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  002e6	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5393 :     pMPC_PUKre->type = PUK_TYPE_CONFIRM;

  002ea	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  002ef	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 5394 :     STORE_HW( pMPC_PUKre->lenpus, uLength4 );

  002f3	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength4$[rsp]
  002f8	e8 00 00 00 00	 call	 _byteswap_ushort
  002fd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  00302	48 83 c1 04	 add	 rcx, 4
  00306	0f b7 d0	 movzx	 edx, ax
  00309	e8 00 00 00 00	 call	 store_hw_noswap

; 5395 : 
; 5396 :     // Prepare first MPC_PUSre
; 5397 :     STORE_HW( pMPC_PUSre[0]->length, SIZE_PUS_04 );

  0030e	66 b9 09 00	 mov	 cx, 9
  00312	e8 00 00 00 00	 call	 _byteswap_ushort
  00317	b9 08 00 00 00	 mov	 ecx, 8
  0031c	48 6b c9 00	 imul	 rcx, rcx, 0
  00320	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00325	0f b7 d0	 movzx	 edx, ax
  00328	e8 00 00 00 00	 call	 store_hw_noswap

; 5398 :     pMPC_PUSre[0]->what = PUS_WHAT_04;

  0032d	b8 08 00 00 00	 mov	 eax, 8
  00332	48 6b c0 00	 imul	 rax, rax, 0
  00336	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0033b	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5399 :     pMPC_PUSre[0]->type = PUS_TYPE_04;

  0033f	b8 08 00 00 00	 mov	 eax, 8
  00344	48 6b c0 00	 imul	 rax, rax, 0
  00348	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0034d	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 5400 :     pMPC_PUSre[0]->vc.pus_04.tokenx5 = MPC_TOKEN_X5;

  00351	b8 08 00 00 00	 mov	 eax, 8
  00356	48 6b c0 00	 imul	 rax, rax, 0
  0035a	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0035f	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5401 :     memcpy( pMPC_PUSre[0]->vc.pus_04.token, pPTPBLK->yTokenCmConnection, MPC_TOKEN_LENGTH );

  00363	b8 08 00 00 00	 mov	 eax, 8
  00368	48 6b c0 00	 imul	 rax, rax, 0
  0036c	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00371	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00376	8b 89 68 03 00
	00		 mov	 ecx, DWORD PTR [rcx+872]
  0037c	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5402 : 
; 5403 :     // Prepare second MPC_PUSre
; 5404 :     STORE_HW( pMPC_PUSre[1]->length, SIZE_PUS_08 );

  0037f	66 b9 09 00	 mov	 cx, 9
  00383	e8 00 00 00 00	 call	 _byteswap_ushort
  00388	b9 08 00 00 00	 mov	 ecx, 8
  0038d	48 6b c9 01	 imul	 rcx, rcx, 1
  00391	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00396	0f b7 d0	 movzx	 edx, ax
  00399	e8 00 00 00 00	 call	 store_hw_noswap

; 5405 :     pMPC_PUSre[1]->what = PUS_WHAT_04;

  0039e	b8 08 00 00 00	 mov	 eax, 8
  003a3	48 6b c0 01	 imul	 rax, rax, 1
  003a7	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003ac	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5406 :     pMPC_PUSre[1]->type = PUS_TYPE_08;

  003b0	b8 08 00 00 00	 mov	 eax, 8
  003b5	48 6b c0 01	 imul	 rax, rax, 1
  003b9	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003be	c6 40 03 08	 mov	 BYTE PTR [rax+3], 8

; 5407 :     pMPC_PUSre[1]->vc.pus_08.tokenx5 = MPC_TOKEN_X5;

  003c2	b8 08 00 00 00	 mov	 eax, 8
  003c7	48 6b c0 01	 imul	 rax, rax, 1
  003cb	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003d0	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5408 :     memcpy( pMPC_PUSre[1]->vc.pus_08.token, pPTPBLK->xTokenCmFilter, MPC_TOKEN_LENGTH );

  003d4	b8 08 00 00 00	 mov	 eax, 8
  003d9	48 6b c0 01	 imul	 rax, rax, 1
  003dd	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003e7	8b 89 41 03 00
	00		 mov	 ecx, DWORD PTR [rcx+833]
  003ed	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5409 : 
; 5410 :     // Prepare third MPC_PUSre
; 5411 :     STORE_HW( pMPC_PUSre[2]->length, SIZE_PUS_07 );

  003f0	66 b9 08 00	 mov	 cx, 8
  003f4	e8 00 00 00 00	 call	 _byteswap_ushort
  003f9	b9 08 00 00 00	 mov	 ecx, 8
  003fe	48 6b c9 02	 imul	 rcx, rcx, 2
  00402	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00407	0f b7 d0	 movzx	 edx, ax
  0040a	e8 00 00 00 00	 call	 store_hw_noswap

; 5412 :     pMPC_PUSre[2]->what = PUS_WHAT_04;

  0040f	b8 08 00 00 00	 mov	 eax, 8
  00414	48 6b c0 02	 imul	 rax, rax, 2
  00418	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0041d	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5413 :     pMPC_PUSre[2]->type = PUS_TYPE_07;

  00421	b8 08 00 00 00	 mov	 eax, 8
  00426	48 6b c0 02	 imul	 rax, rax, 2
  0042a	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0042f	c6 40 03 07	 mov	 BYTE PTR [rax+3], 7

; 5414 :     pMPC_PUSre[2]->vc.pus_07.unknown04[0] = 0xC8;        // !!! //

  00433	b8 08 00 00 00	 mov	 eax, 8
  00438	48 6b c0 02	 imul	 rax, rax, 2
  0043c	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00441	b9 01 00 00 00	 mov	 ecx, 1
  00446	48 6b c9 00	 imul	 rcx, rcx, 0
  0044a	c6 44 08 04 c8	 mov	 BYTE PTR [rax+rcx+4], 200 ; 000000c8H

; 5415 : 
; 5416 :     // Display various information, maybe
; 5417 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0044f	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00454	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00457	83 e0 10	 and	 eax, 16
  0045a	85 c0		 test	 eax, eax
  0045c	74 15		 je	 SHORT $LN3@build_417E

; 5418 :     {
; 5419 :         mpc_display_description( pDEVBLK, "Out RRH 0x417E (Issuer) PUK 0x4106 (CM_CONFIRM)" );

  0045e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171967
  00465	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_417E:

; 5420 :     }
; 5421 : 
; 5422 :     return pPTPHDRre;

  00473	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_417E:

; 5423 : }   /* End function  build_417E_cm_confirm() */

  00478	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00480	48 33 cc	 xor	 rcx, rsp
  00483	e8 00 00 00 00	 call	 __security_check_cookie
  00488	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0048f	c3		 ret	 0
build_417E_cm_confirm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength4$ = 32
pMPC_RRHre$ = 40
uLength3$ = 48
pMPC_THre$ = 56
pPTPBLK$ = 64
uLength1$ = 72
tv158 = 76
uLength2$ = 80
pMPC_PUKre$ = 88
pMPC_PHre$ = 96
pPTPHDRre$ = 104
pPTPATH$ = 112
pMPC_PUSre$ = 120
__$ArrayPad$ = 144
pDEVBLK$ = 176
pMPC_RRHwr$ = 184
build_417E_cm_setup PROC

; 5221 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5222 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  00023	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0002b	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00032	48 89 44 24 70	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 5223 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00037	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003f	48 89 44 24 40	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 5224 :     U32        uLength1;
; 5225 :     U32        uLength2;
; 5226 :     U32        uLength3;
; 5227 :     U16        uLength4;
; 5228 :     PTPHDR*    pPTPHDRre;       // PTPHDR to be read
; 5229 :     MPC_TH*    pMPC_THre;       // MPC_TH follows PTPHDR
; 5230 :     MPC_RRH*   pMPC_RRHre;      // MPC_RRH follows MPC_TH
; 5231 :     MPC_PH*    pMPC_PHre;       // MPC_PH follows MPC_RRH
; 5232 :     MPC_PUK*   pMPC_PUKre;      // MPC_PUK follows MPC_PH
; 5233 :     MPC_PUS*   pMPC_PUSre[3];   // MPC_PUSs follow MPC_PUK
; 5234 : 
; 5235 : 
; 5236 :     // Allocate a buffer.
; 5237 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00044	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00049	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00051	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00056	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 5238 :     if (!pPTPHDRre)

  0005b	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00061	75 07		 jne	 SHORT $LN2@build_417E

; 5239 :         return NULL;

  00063	33 c0		 xor	 eax, eax
  00065	e9 0e 04 00 00	 jmp	 $LN1@build_417E
$LN2@build_417E:

; 5240 : 
; 5241 :     // Fix-up various lengths
; 5242 :     uLength4 = SIZE_PUS_04 +                  // first MPC_PUS (0x0404)

  0006a	b8 18 00 00 00	 mov	 eax, 24
  0006f	66 89 44 24 20	 mov	 WORD PTR uLength4$[rsp], ax

; 5243 :                SIZE_PUS_05 +                  // second MPC_PUS (0x0405)
; 5244 :                SIZE_PUS_06;                   // third MPC_PUS (0x0406)
; 5245 :     uLength3 = SIZE_PUK + uLength4;           // the MPC_PUK and the MPC_PUSs (the data)

  00074	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength4$[rsp]
  00079	83 c0 0c	 add	 eax, 12
  0007c	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 5246 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00080	c7 44 24 50 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 5247 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  00088	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  0008c	8b 4c 24 50	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00090	03 c8		 add	 ecx, eax
  00092	8b c1		 mov	 eax, ecx
  00094	89 44 24 48	 mov	 DWORD PTR uLength1$[rsp], eax

; 5248 : 
; 5249 :     // Fix-up various pointers
; 5250 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  00098	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0009d	48 83 c0 10	 add	 rax, 16
  000a1	48 89 44 24 38	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 5251 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  000a6	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  000ab	48 83 c0 14	 add	 rax, 20
  000af	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 5252 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  000b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  000b9	48 83 c0 24	 add	 rax, 36			; 00000024H
  000bd	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 5253 :     pMPC_PUKre = (MPC_PUK*)((BYTE*)pMPC_PHre + SIZE_PH);

  000c2	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000c7	48 83 c0 08	 add	 rax, 8
  000cb	48 89 44 24 58	 mov	 QWORD PTR pMPC_PUKre$[rsp], rax

; 5254 :     pMPC_PUSre[0] = (MPC_PUS*)((BYTE*)pMPC_PUKre + SIZE_PUK);

  000d0	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  000d5	48 83 c0 0c	 add	 rax, 12
  000d9	b9 08 00 00 00	 mov	 ecx, 8
  000de	48 6b c9 00	 imul	 rcx, rcx, 0
  000e2	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5255 :     pMPC_PUSre[1] = (MPC_PUS*)((BYTE*)pMPC_PUSre[0] + SIZE_PUS_04);

  000e7	b8 08 00 00 00	 mov	 eax, 8
  000ec	48 6b c0 00	 imul	 rax, rax, 0
  000f0	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  000f5	48 83 c0 09	 add	 rax, 9
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5256 :     pMPC_PUSre[2] = (MPC_PUS*)((BYTE*)pMPC_PUSre[1] + SIZE_PUS_05);

  00107	b8 08 00 00 00	 mov	 eax, 8
  0010c	48 6b c0 01	 imul	 rax, rax, 1
  00110	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00115	48 83 c0 09	 add	 rax, 9
  00119	b9 08 00 00 00	 mov	 ecx, 8
  0011e	48 6b c9 02	 imul	 rcx, rcx, 2
  00122	48 89 44 0c 78	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5257 : 
; 5258 :     // Prepare PTPHDRre
; 5259 :     pPTPHDRre->iDataLen = uLength1;

  00127	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0012c	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00130	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5260 : 
; 5261 :     // Prepare MPC_THre
; 5262 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00133	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00138	e8 00 00 00 00	 call	 _byteswap_ulong
  0013d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00142	8b d0		 mov	 edx, eax
  00144	e8 00 00 00 00	 call	 store_fw_noswap

; 5263 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  00149	b9 14 00 00 00	 mov	 ecx, 20
  0014e	e8 00 00 00 00	 call	 _byteswap_ulong
  00153	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00158	48 83 c1 08	 add	 rcx, 8
  0015c	8b d0		 mov	 edx, eax
  0015e	e8 00 00 00 00	 call	 store_fw_noswap

; 5264 :     STORE_FW( pMPC_THre->length, uLength1 );

  00163	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00167	e8 00 00 00 00	 call	 _byteswap_ulong
  0016c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00171	48 83 c1 0c	 add	 rcx, 12
  00175	8b d0		 mov	 edx, eax
  00177	e8 00 00 00 00	 call	 store_fw_noswap

; 5265 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  0017c	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00180	e8 00 00 00 00	 call	 _byteswap_ushort
  00185	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  0018a	48 83 c1 10	 add	 rcx, 16
  0018e	0f b7 d0	 movzx	 edx, ax
  00191	e8 00 00 00 00	 call	 store_hw_noswap

; 5266 :     STORE_HW( pMPC_THre->numrrh, 1 );

  00196	66 b9 01 00	 mov	 cx, 1
  0019a	e8 00 00 00 00	 call	 _byteswap_ushort
  0019f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  001a4	48 83 c1 12	 add	 rcx, 18
  001a8	0f b7 d0	 movzx	 edx, ax
  001ab	e8 00 00 00 00	 call	 store_hw_noswap

; 5267 : 
; 5268 :     // Prepare MPC_RRHre
; 5269 :     pMPC_RRHre->type = RRH_TYPE_ULP;

  001b0	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001b5	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 5270 :     pMPC_RRHre->proto = PROTOCOL_UNKNOWN;

  001b9	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001be	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5271 :     STORE_HW( pMPC_RRHre->numph, 1 );

  001c2	66 b9 01 00	 mov	 cx, 1
  001c6	e8 00 00 00 00	 call	 _byteswap_ushort
  001cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001d0	48 83 c1 06	 add	 rcx, 6
  001d4	0f b7 d0	 movzx	 edx, ax
  001d7	e8 00 00 00 00	 call	 store_hw_noswap

; 5272 :     STORE_FW( pMPC_RRHre->seqnum, ++pPTPBLK->uSeqNumIssuer );

  001dc	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001e1	8b 80 7a 03 00
	00		 mov	 eax, DWORD PTR [rax+890]
  001e7	ff c0		 inc	 eax
  001e9	89 44 24 4c	 mov	 DWORD PTR tv158[rsp], eax
  001ed	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001f2	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv158[rsp]
  001f6	89 88 7a 03 00
	00		 mov	 DWORD PTR [rax+890], ecx
  001fc	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv158[rsp]
  00200	e8 00 00 00 00	 call	 _byteswap_ulong
  00205	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0020a	48 83 c1 08	 add	 rcx, 8
  0020e	8b d0		 mov	 edx, eax
  00210	e8 00 00 00 00	 call	 store_fw_noswap

; 5273 :     memcpy( pMPC_RRHre->ackseq, pMPC_RRHwr->seqnum, 4 );

  00215	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0021a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  00222	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00225	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5274 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00228	66 b9 24 00	 mov	 cx, 36			; 00000024H
  0022c	e8 00 00 00 00	 call	 _byteswap_ushort
  00231	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00236	48 83 c1 10	 add	 rcx, 16
  0023a	0f b7 d0	 movzx	 edx, ax
  0023d	e8 00 00 00 00	 call	 store_hw_noswap

; 5275 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  00242	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00247	e8 00 00 00 00	 call	 _byteswap_ushort
  0024c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00251	48 83 c1 12	 add	 rcx, 18
  00255	0f b7 d0	 movzx	 edx, ax
  00258	e8 00 00 00 00	 call	 store_hw_noswap

; 5276 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  0025d	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00261	e8 00 00 00 00	 call	 _byteswap_ulong
  00266	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0026b	48 83 c1 14	 add	 rcx, 20
  0026f	8b d0		 mov	 edx, eax
  00271	e8 00 00 00 00	 call	 store_f3_noswap

; 5277 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00276	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  0027b	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5278 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenIssuerRm, MPC_TOKEN_LENGTH );

  0027f	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00284	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00289	8b 89 60 03 00
	00		 mov	 ecx, DWORD PTR [rcx+864]
  0028f	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5279 : 
; 5280 :     // Prepare MPC_PHre
; 5281 :     pMPC_PHre->locdata = PH_LOC_1;

  00292	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  00297	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5282 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  0029a	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0029e	e8 00 00 00 00	 call	 _byteswap_ulong
  002a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002a8	48 ff c1	 inc	 rcx
  002ab	8b d0		 mov	 edx, eax
  002ad	e8 00 00 00 00	 call	 store_f3_noswap

; 5283 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  002b2	8b 4c 24 50	 mov	 ecx, DWORD PTR uLength2$[rsp]
  002b6	e8 00 00 00 00	 call	 _byteswap_ulong
  002bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002c0	48 83 c1 04	 add	 rcx, 4
  002c4	8b d0		 mov	 edx, eax
  002c6	e8 00 00 00 00	 call	 store_fw_noswap

; 5284 : 
; 5285 :     // Prepare MPC_PUKre
; 5286 :     STORE_HW( pMPC_PUKre->length, SIZE_PUK );

  002cb	66 b9 0c 00	 mov	 cx, 12
  002cf	e8 00 00 00 00	 call	 _byteswap_ushort
  002d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  002d9	0f b7 d0	 movzx	 edx, ax
  002dc	e8 00 00 00 00	 call	 store_hw_noswap

; 5287 :     pMPC_PUKre->what = PUK_WHAT_41;

  002e1	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  002e6	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5288 :     pMPC_PUKre->type = PUK_TYPE_SETUP;

  002ea	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  002ef	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 5289 :     STORE_HW( pMPC_PUKre->lenpus, uLength4 );

  002f3	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength4$[rsp]
  002f8	e8 00 00 00 00	 call	 _byteswap_ushort
  002fd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  00302	48 83 c1 04	 add	 rcx, 4
  00306	0f b7 d0	 movzx	 edx, ax
  00309	e8 00 00 00 00	 call	 store_hw_noswap

; 5290 : 
; 5291 :     // Prepare first MPC_PUSre
; 5292 :     STORE_HW( pMPC_PUSre[0]->length, SIZE_PUS_04 );

  0030e	66 b9 09 00	 mov	 cx, 9
  00312	e8 00 00 00 00	 call	 _byteswap_ushort
  00317	b9 08 00 00 00	 mov	 ecx, 8
  0031c	48 6b c9 00	 imul	 rcx, rcx, 0
  00320	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00325	0f b7 d0	 movzx	 edx, ax
  00328	e8 00 00 00 00	 call	 store_hw_noswap

; 5293 :     pMPC_PUSre[0]->what = PUS_WHAT_04;

  0032d	b8 08 00 00 00	 mov	 eax, 8
  00332	48 6b c0 00	 imul	 rax, rax, 0
  00336	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0033b	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5294 :     pMPC_PUSre[0]->type = PUS_TYPE_04;

  0033f	b8 08 00 00 00	 mov	 eax, 8
  00344	48 6b c0 00	 imul	 rax, rax, 0
  00348	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0034d	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 5295 :     pMPC_PUSre[0]->vc.pus_04.tokenx5 = MPC_TOKEN_X5;

  00351	b8 08 00 00 00	 mov	 eax, 8
  00356	48 6b c0 00	 imul	 rax, rax, 0
  0035a	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0035f	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5296 :     memcpy( pMPC_PUSre[0]->vc.pus_04.token, pPTPBLK->xTokenCmConnection, MPC_TOKEN_LENGTH );

  00363	b8 08 00 00 00	 mov	 eax, 8
  00368	48 6b c0 00	 imul	 rax, rax, 0
  0036c	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00371	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00376	8b 89 45 03 00
	00		 mov	 ecx, DWORD PTR [rcx+837]
  0037c	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5297 : 
; 5298 :     // Prepare second MPC_PUSre
; 5299 :     STORE_HW( pMPC_PUSre[1]->length, SIZE_PUS_05 );

  0037f	66 b9 09 00	 mov	 cx, 9
  00383	e8 00 00 00 00	 call	 _byteswap_ushort
  00388	b9 08 00 00 00	 mov	 ecx, 8
  0038d	48 6b c9 01	 imul	 rcx, rcx, 1
  00391	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00396	0f b7 d0	 movzx	 edx, ax
  00399	e8 00 00 00 00	 call	 store_hw_noswap

; 5300 :     pMPC_PUSre[1]->what = PUS_WHAT_04;

  0039e	b8 08 00 00 00	 mov	 eax, 8
  003a3	48 6b c0 01	 imul	 rax, rax, 1
  003a7	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003ac	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5301 :     pMPC_PUSre[1]->type = PUS_TYPE_05;

  003b0	b8 08 00 00 00	 mov	 eax, 8
  003b5	48 6b c0 01	 imul	 rax, rax, 1
  003b9	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003be	c6 40 03 05	 mov	 BYTE PTR [rax+3], 5

; 5302 :     pMPC_PUSre[1]->vc.pus_05.tokenx5 = MPC_TOKEN_X5;

  003c2	b8 08 00 00 00	 mov	 eax, 8
  003c7	48 6b c0 01	 imul	 rax, rax, 1
  003cb	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003d0	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5303 :     memcpy( pMPC_PUSre[1]->vc.pus_05.token, pPTPBLK->yTokenCmFilter, MPC_TOKEN_LENGTH );

  003d4	b8 08 00 00 00	 mov	 eax, 8
  003d9	48 6b c0 01	 imul	 rax, rax, 1
  003dd	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003e7	8b 89 64 03 00
	00		 mov	 ecx, DWORD PTR [rcx+868]
  003ed	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5304 : 
; 5305 :     // Prepare third MPC_PUSre
; 5306 :     STORE_HW( pMPC_PUSre[2]->length, SIZE_PUS_06 );

  003f0	66 b9 06 00	 mov	 cx, 6
  003f4	e8 00 00 00 00	 call	 _byteswap_ushort
  003f9	b9 08 00 00 00	 mov	 ecx, 8
  003fe	48 6b c9 02	 imul	 rcx, rcx, 2
  00402	48 8b 4c 0c 78	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00407	0f b7 d0	 movzx	 edx, ax
  0040a	e8 00 00 00 00	 call	 store_hw_noswap

; 5307 :     pMPC_PUSre[2]->what = PUS_WHAT_04;

  0040f	b8 08 00 00 00	 mov	 eax, 8
  00414	48 6b c0 02	 imul	 rax, rax, 2
  00418	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0041d	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5308 :     pMPC_PUSre[2]->type = PUS_TYPE_06;

  00421	b8 08 00 00 00	 mov	 eax, 8
  00426	48 6b c0 02	 imul	 rax, rax, 2
  0042a	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0042f	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 5309 :     pMPC_PUSre[2]->vc.pus_06.unknown04[0] = 0xC8;        // !!! //

  00433	b8 08 00 00 00	 mov	 eax, 8
  00438	48 6b c0 02	 imul	 rax, rax, 2
  0043c	48 8b 44 04 78	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00441	b9 01 00 00 00	 mov	 ecx, 1
  00446	48 6b c9 00	 imul	 rcx, rcx, 0
  0044a	c6 44 08 04 c8	 mov	 BYTE PTR [rax+rcx+4], 200 ; 000000c8H

; 5310 : 
; 5311 :     // Display various information, maybe
; 5312 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0044f	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00454	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00457	83 e0 10	 and	 eax, 16
  0045a	85 c0		 test	 eax, eax
  0045c	74 15		 je	 SHORT $LN3@build_417E

; 5313 :     {
; 5314 :         mpc_display_description( pDEVBLK, "Out RRH 0x417E (Issuer) PUK 0x4104 (CM_SETUP)" );

  0045e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171930
  00465	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN3@build_417E:

; 5315 :     }
; 5316 : 
; 5317 :     return pPTPHDRre;

  00473	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_417E:

; 5318 : }   /* End function  build_417E_cm_setup() */

  00478	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00480	48 33 cc	 xor	 rcx, rsp
  00483	e8 00 00 00 00	 call	 __security_check_cookie
  00488	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0048f	c3		 ret	 0
build_417E_cm_setup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
uLength4$ = 32
pMPC_RRHre$ = 40
uLength3$ = 48
pMPC_THre$ = 56
uLength1$ = 64
tv159 = 68
uLength2$ = 72
rc$ = 76
pMPC_PUKre$ = 80
pPTPBLK$ = 88
pMPC_PHre$ = 96
pPTPHDRre$ = 104
uTod$ = 112
pPTPATH$ = 120
pMPC_PUSre$ = 128
__$ArrayPad$ = 152
pDEVBLK$ = 176
pMPC_RRHwr$ = 184
pMPC_PUSwr$ = 192
fxSideWins$ = 200
build_417E_cm_enable PROC

; 5069 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5070 : 
; 5071 :     PTPATH*    pPTPATH      = pDEVBLK->dev_data;

  0002d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00035	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0003c	48 89 44 24 78	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 5072 :     PTPBLK*    pPTPBLK      = pPTPATH->pPTPBLK;

  00041	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 89 44 24 58	 mov	 QWORD PTR pPTPBLK$[rsp], rax
$LN4@build_417E:

; 5073 :     U32        uLength1;
; 5074 :     U32        uLength2;
; 5075 :     U32        uLength3;
; 5076 :     U16        uLength4;
; 5077 :     PTPHDR*    pPTPHDRre;      // PTPHDR to be read
; 5078 :     MPC_TH*    pMPC_THre;      // MPC_TH follows PTPHDR
; 5079 :     MPC_RRH*   pMPC_RRHre;     // MPC_RRH follows MPC_TH
; 5080 :     MPC_PH*    pMPC_PHre;      // MPC_PH follows MPC_RRH
; 5081 :     MPC_PUK*   pMPC_PUKre;     // MPC_PUK follows MPC_PH
; 5082 :     MPC_PUS*   pMPC_PUSre[3];  // MPC_PUSs follow MPC_PUK
; 5083 :     U64        uTod;
; 5084 :     int        rc;
; 5085 : 
; 5086 :     UNREFERENCED( pMPC_RRHwr );

  0004e	33 c0		 xor	 eax, eax
  00050	85 c0		 test	 eax, eax
  00052	75 fa		 jne	 SHORT $LN4@build_417E

; 5087 : 
; 5088 : 
; 5089 :     // Allocate a buffer in which the response will be build.
; 5090 :     pPTPHDRre = alloc_ptp_buffer( pDEVBLK, 256 );

  00054	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00059	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00061	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00066	48 89 44 24 68	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 5091 :     if (!pPTPHDRre)

  0006b	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDRre$[rsp], 0
  00071	75 07		 jne	 SHORT $LN5@build_417E

; 5092 :         return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	e9 0f 06 00 00	 jmp	 $LN1@build_417E
$LN5@build_417E:

; 5093 : 
; 5094 :     // Fix-up various lengths
; 5095 :     uLength4 = SIZE_PUS_01 +                  // first MPC_PUS (0x0401)

  0007a	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  0007f	66 89 44 24 20	 mov	 WORD PTR uLength4$[rsp], ax

; 5096 :                SIZE_PUS_02_A +                // second MPC_PUS (0x0402)
; 5097 :                SIZE_PUS_0C;                   // third MPC_PUS (0x040c)
; 5098 :     uLength3 = SIZE_PUK + uLength4;           // the MPC_PUK and the MPC_PUSs (the data)

  00084	0f b7 44 24 20	 movzx	 eax, WORD PTR uLength4$[rsp]
  00089	83 c0 0c	 add	 eax, 12
  0008c	89 44 24 30	 mov	 DWORD PTR uLength3$[rsp], eax

; 5099 :     uLength2 = SIZE_TH + SIZE_RRH + SIZE_PH;  // the MPC_TH/MPC_RRH/MPC_PH

  00090	c7 44 24 48 40
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 64 ; 00000040H

; 5100 :     uLength1 = uLength2 + uLength3;           // the MPC_TH/MPC_RRH/MPC_PH and data

  00098	8b 44 24 30	 mov	 eax, DWORD PTR uLength3$[rsp]
  0009c	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength2$[rsp]
  000a0	03 c8		 add	 ecx, eax
  000a2	8b c1		 mov	 eax, ecx
  000a4	89 44 24 40	 mov	 DWORD PTR uLength1$[rsp], eax

; 5101 : 
; 5102 :     // Fix-up various pointers
; 5103 :     pMPC_THre = (MPC_TH*)((BYTE*)pPTPHDRre + SIZE_HDR);

  000a8	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  000ad	48 83 c0 10	 add	 rax, 16
  000b1	48 89 44 24 38	 mov	 QWORD PTR pMPC_THre$[rsp], rax

; 5104 :     pMPC_RRHre = (MPC_RRH*)((BYTE*)pMPC_THre + SIZE_TH);

  000b6	48 8b 44 24 38	 mov	 rax, QWORD PTR pMPC_THre$[rsp]
  000bb	48 83 c0 14	 add	 rax, 20
  000bf	48 89 44 24 28	 mov	 QWORD PTR pMPC_RRHre$[rsp], rax

; 5105 :     pMPC_PHre = (MPC_PH*)((BYTE*)pMPC_RRHre + SIZE_RRH);

  000c4	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  000c9	48 83 c0 24	 add	 rax, 36			; 00000024H
  000cd	48 89 44 24 60	 mov	 QWORD PTR pMPC_PHre$[rsp], rax

; 5106 :     pMPC_PUKre = (MPC_PUK*)((BYTE*)pMPC_PHre + SIZE_PH);

  000d2	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  000d7	48 83 c0 08	 add	 rax, 8
  000db	48 89 44 24 50	 mov	 QWORD PTR pMPC_PUKre$[rsp], rax

; 5107 :     pMPC_PUSre[0] = (MPC_PUS*)((BYTE*)pMPC_PUKre + SIZE_PUK);

  000e0	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  000e5	48 83 c0 0c	 add	 rax, 12
  000e9	b9 08 00 00 00	 mov	 ecx, 8
  000ee	48 6b c9 00	 imul	 rcx, rcx, 0
  000f2	48 89 84 0c 80
	00 00 00	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5108 :     pMPC_PUSre[1] = (MPC_PUS*)((BYTE*)pMPC_PUSre[0] + SIZE_PUS_01);

  000fa	b8 08 00 00 00	 mov	 eax, 8
  000ff	48 6b c0 00	 imul	 rax, rax, 0
  00103	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0010b	48 83 c0 0b	 add	 rax, 11
  0010f	b9 08 00 00 00	 mov	 ecx, 8
  00114	48 6b c9 01	 imul	 rcx, rcx, 1
  00118	48 89 84 0c 80
	00 00 00	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5109 :     pMPC_PUSre[2] = (MPC_PUS*)((BYTE*)pMPC_PUSre[1] + SIZE_PUS_02_A);

  00120	b8 08 00 00 00	 mov	 eax, 8
  00125	48 6b c0 01	 imul	 rax, rax, 1
  00129	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00131	48 83 c0 0c	 add	 rax, 12
  00135	b9 08 00 00 00	 mov	 ecx, 8
  0013a	48 6b c9 02	 imul	 rcx, rcx, 2
  0013e	48 89 84 0c 80
	00 00 00	 mov	 QWORD PTR pMPC_PUSre$[rsp+rcx], rax

; 5110 : 
; 5111 :     // Prepare PTPHDRre
; 5112 :     pPTPHDRre->iDataLen = uLength1;

  00146	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
  0014b	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0014f	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5113 : 
; 5114 :     // Prepare MPC_THre
; 5115 :     STORE_FW( pMPC_THre->first4, MPC_TH_FIRST4 );

  00152	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00157	e8 00 00 00 00	 call	 _byteswap_ulong
  0015c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00161	8b d0		 mov	 edx, eax
  00163	e8 00 00 00 00	 call	 store_fw_noswap

; 5116 :     STORE_FW( pMPC_THre->offrrh, SIZE_TH );

  00168	b9 14 00 00 00	 mov	 ecx, 20
  0016d	e8 00 00 00 00	 call	 _byteswap_ulong
  00172	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00177	48 83 c1 08	 add	 rcx, 8
  0017b	8b d0		 mov	 edx, eax
  0017d	e8 00 00 00 00	 call	 store_fw_noswap

; 5117 :     STORE_FW( pMPC_THre->length, uLength1 );

  00182	8b 4c 24 40	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00186	e8 00 00 00 00	 call	 _byteswap_ulong
  0018b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  00190	48 83 c1 0c	 add	 rcx, 12
  00194	8b d0		 mov	 edx, eax
  00196	e8 00 00 00 00	 call	 store_fw_noswap

; 5118 :     STORE_HW( pMPC_THre->unknown10, MPC_TH_UNKNOWN10 );      // !!! //

  0019b	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  0019f	e8 00 00 00 00	 call	 _byteswap_ushort
  001a4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  001a9	48 83 c1 10	 add	 rcx, 16
  001ad	0f b7 d0	 movzx	 edx, ax
  001b0	e8 00 00 00 00	 call	 store_hw_noswap

; 5119 :     STORE_HW( pMPC_THre->numrrh, 1 );

  001b5	66 b9 01 00	 mov	 cx, 1
  001b9	e8 00 00 00 00	 call	 _byteswap_ushort
  001be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pMPC_THre$[rsp]
  001c3	48 83 c1 12	 add	 rcx, 18
  001c7	0f b7 d0	 movzx	 edx, ax
  001ca	e8 00 00 00 00	 call	 store_hw_noswap

; 5120 : 
; 5121 :     // Prepare MPC_RRHre
; 5122 :     pMPC_RRHre->type = RRH_TYPE_ULP;

  001cf	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001d4	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 5123 :     pMPC_RRHre->proto = PROTOCOL_UNKNOWN;

  001d8	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  001dd	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5124 :     STORE_HW( pMPC_RRHre->numph, 1 );

  001e1	66 b9 01 00	 mov	 cx, 1
  001e5	e8 00 00 00 00	 call	 _byteswap_ushort
  001ea	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  001ef	48 83 c1 06	 add	 rcx, 6
  001f3	0f b7 d0	 movzx	 edx, ax
  001f6	e8 00 00 00 00	 call	 store_hw_noswap

; 5125 :     STORE_FW( pMPC_RRHre->seqnum, ++pPTPBLK->uSeqNumIssuer );

  001fb	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00200	8b 80 7a 03 00
	00		 mov	 eax, DWORD PTR [rax+890]
  00206	ff c0		 inc	 eax
  00208	89 44 24 44	 mov	 DWORD PTR tv159[rsp], eax
  0020c	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00211	8b 4c 24 44	 mov	 ecx, DWORD PTR tv159[rsp]
  00215	89 88 7a 03 00
	00		 mov	 DWORD PTR [rax+890], ecx
  0021b	8b 4c 24 44	 mov	 ecx, DWORD PTR tv159[rsp]
  0021f	e8 00 00 00 00	 call	 _byteswap_ulong
  00224	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00229	48 83 c1 08	 add	 rcx, 8
  0022d	8b d0		 mov	 edx, eax
  0022f	e8 00 00 00 00	 call	 store_fw_noswap

; 5126 :     STORE_HW( pMPC_RRHre->offph, SIZE_RRH );

  00234	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00238	e8 00 00 00 00	 call	 _byteswap_ushort
  0023d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00242	48 83 c1 10	 add	 rcx, 16
  00246	0f b7 d0	 movzx	 edx, ax
  00249	e8 00 00 00 00	 call	 store_hw_noswap

; 5127 :     STORE_HW( pMPC_RRHre->lenfida, (U16)uLength3 );

  0024e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00253	e8 00 00 00 00	 call	 _byteswap_ushort
  00258	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  0025d	48 83 c1 12	 add	 rcx, 18
  00261	0f b7 d0	 movzx	 edx, ax
  00264	e8 00 00 00 00	 call	 store_hw_noswap

; 5128 :     STORE_F3( pMPC_RRHre->lenalda, uLength3 );

  00269	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0026d	e8 00 00 00 00	 call	 _byteswap_ulong
  00272	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pMPC_RRHre$[rsp]
  00277	48 83 c1 14	 add	 rcx, 20
  0027b	8b d0		 mov	 edx, eax
  0027d	e8 00 00 00 00	 call	 store_f3_noswap

; 5129 :     pMPC_RRHre->tokenx5 = MPC_TOKEN_X5;

  00282	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00287	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5130 :     memcpy( pMPC_RRHre->token, pPTPBLK->yTokenIssuerRm, MPC_TOKEN_LENGTH );

  0028b	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_RRHre$[rsp]
  00290	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00295	8b 89 60 03 00
	00		 mov	 ecx, DWORD PTR [rcx+864]
  0029b	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5131 : 
; 5132 :     // Prepare MPC_PHre
; 5133 :     pMPC_PHre->locdata = PH_LOC_1;

  0029e	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PHre$[rsp]
  002a3	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5134 :     STORE_F3( pMPC_PHre->lendata, uLength3 );

  002a6	8b 4c 24 30	 mov	 ecx, DWORD PTR uLength3$[rsp]
  002aa	e8 00 00 00 00	 call	 _byteswap_ulong
  002af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002b4	48 ff c1	 inc	 rcx
  002b7	8b d0		 mov	 edx, eax
  002b9	e8 00 00 00 00	 call	 store_f3_noswap

; 5135 :     STORE_FW( pMPC_PHre->offdata, uLength2 );

  002be	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength2$[rsp]
  002c2	e8 00 00 00 00	 call	 _byteswap_ulong
  002c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_PHre$[rsp]
  002cc	48 83 c1 04	 add	 rcx, 4
  002d0	8b d0		 mov	 edx, eax
  002d2	e8 00 00 00 00	 call	 store_fw_noswap

; 5136 : 
; 5137 :     // Prepare MPC_PUKre
; 5138 :     STORE_HW( pMPC_PUKre->length, SIZE_PUK );

  002d7	66 b9 0c 00	 mov	 cx, 12
  002db	e8 00 00 00 00	 call	 _byteswap_ushort
  002e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  002e5	0f b7 d0	 movzx	 edx, ax
  002e8	e8 00 00 00 00	 call	 store_hw_noswap

; 5139 :     pMPC_PUKre->what = PUK_WHAT_41;

  002ed	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  002f2	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5140 :     pMPC_PUKre->type = PUK_TYPE_ENABLE;

  002f6	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PUKre$[rsp]
  002fb	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5141 :     STORE_HW( pMPC_PUKre->lenpus, uLength4 );

  002ff	0f b7 4c 24 20	 movzx	 ecx, WORD PTR uLength4$[rsp]
  00304	e8 00 00 00 00	 call	 _byteswap_ushort
  00309	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PUKre$[rsp]
  0030e	48 83 c1 04	 add	 rcx, 4
  00312	0f b7 d0	 movzx	 edx, ax
  00315	e8 00 00 00 00	 call	 store_hw_noswap

; 5142 : 
; 5143 :     // Prepare first MPC_PUSre
; 5144 :     STORE_HW( pMPC_PUSre[0]->length, SIZE_PUS_01 );

  0031a	66 b9 0b 00	 mov	 cx, 11
  0031e	e8 00 00 00 00	 call	 _byteswap_ushort
  00323	b9 08 00 00 00	 mov	 ecx, 8
  00328	48 6b c9 00	 imul	 rcx, rcx, 0
  0032c	48 8b 8c 0c 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00334	0f b7 d0	 movzx	 edx, ax
  00337	e8 00 00 00 00	 call	 store_hw_noswap

; 5145 :     pMPC_PUSre[0]->what = PUS_WHAT_04;

  0033c	b8 08 00 00 00	 mov	 eax, 8
  00341	48 6b c0 00	 imul	 rax, rax, 0
  00345	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0034d	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5146 :     pMPC_PUSre[0]->type = PUS_TYPE_01;

  00351	b8 08 00 00 00	 mov	 eax, 8
  00356	48 6b c0 00	 imul	 rax, rax, 0
  0035a	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00362	c6 40 03 01	 mov	 BYTE PTR [rax+3], 1

; 5147 :     pMPC_PUSre[0]->vc.pus_01.proto = PROTOCOL_UNKNOWN;

  00366	b8 08 00 00 00	 mov	 eax, 8
  0036b	48 6b c0 00	 imul	 rax, rax, 0
  0036f	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00377	c6 40 04 7e	 mov	 BYTE PTR [rax+4], 126	; 0000007eH

; 5148 :     pMPC_PUSre[0]->vc.pus_01.unknown05 = 0x01;           // !!! //

  0037b	b8 08 00 00 00	 mov	 eax, 8
  00380	48 6b c0 00	 imul	 rax, rax, 0
  00384	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0038c	c6 40 05 01	 mov	 BYTE PTR [rax+5], 1

; 5149 :     pMPC_PUSre[0]->vc.pus_01.tokenx5 = MPC_TOKEN_X5;

  00390	b8 08 00 00 00	 mov	 eax, 8
  00395	48 6b c0 00	 imul	 rax, rax, 0
  00399	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003a1	c6 40 06 05	 mov	 BYTE PTR [rax+6], 5

; 5150 :     memcpy( pMPC_PUSre[0]->vc.pus_01.token, pPTPBLK->xTokenCmFilter, MPC_TOKEN_LENGTH );

  003a5	b8 08 00 00 00	 mov	 eax, 8
  003aa	48 6b c0 00	 imul	 rax, rax, 0
  003ae	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003bb	8b 89 41 03 00
	00		 mov	 ecx, DWORD PTR [rcx+833]
  003c1	89 48 07	 mov	 DWORD PTR [rax+7], ecx

; 5151 : 
; 5152 :     // Prepare second MPC_PUSre
; 5153 :     // Note: the 8-byte value placed in the second MPC_PUS is important.
; 5154 :     // Whichever side has the highest value 'wins', and dictates the
; 5155 :     // 'handedness' of the RRH 0x417E exchanges. If this code 'wins'
; 5156 :     // and then acts like a 'loser', confusion reigns, to the extent
; 5157 :     // that VTAM on the y-side will not shutdown because it thinks
; 5158 :     // the link is still active. Presumably we could always return
; 5159 :     // 0xFF's, but hey...
; 5160 :     STORE_HW( pMPC_PUSre[1]->length, SIZE_PUS_02_A );

  003c4	66 b9 0c 00	 mov	 cx, 12
  003c8	e8 00 00 00 00	 call	 _byteswap_ushort
  003cd	b9 08 00 00 00	 mov	 ecx, 8
  003d2	48 6b c9 01	 imul	 rcx, rcx, 1
  003d6	48 8b 8c 0c 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  003de	0f b7 d0	 movzx	 edx, ax
  003e1	e8 00 00 00 00	 call	 store_hw_noswap

; 5161 :     pMPC_PUSre[1]->what = PUS_WHAT_04;

  003e6	b8 08 00 00 00	 mov	 eax, 8
  003eb	48 6b c0 01	 imul	 rax, rax, 1
  003ef	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  003f7	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5162 :     pMPC_PUSre[1]->type = PUS_TYPE_02;

  003fb	b8 08 00 00 00	 mov	 eax, 8
  00400	48 6b c0 01	 imul	 rax, rax, 1
  00404	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0040c	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5163 :     ptp_get_tod_clock( pMPC_PUSre[1]->vc.pus_02.a.clock ); // x-side's time

  00410	b8 08 00 00 00	 mov	 eax, 8
  00415	48 6b c0 01	 imul	 rax, rax, 1
  00419	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00421	48 83 c0 04	 add	 rax, 4
  00425	48 8b c8	 mov	 rcx, rax
  00428	e8 00 00 00 00	 call	 ptp_get_tod_clock

; 5164 : 
; 5165 :     // Prepare third MPC_PUSre
; 5166 :     STORE_HW( pMPC_PUSre[2]->length, SIZE_PUS_0C );

  0042d	66 b9 0d 00	 mov	 cx, 13
  00431	e8 00 00 00 00	 call	 _byteswap_ushort
  00436	b9 08 00 00 00	 mov	 ecx, 8
  0043b	48 6b c9 02	 imul	 rcx, rcx, 2
  0043f	48 8b 8c 0c 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00447	0f b7 d0	 movzx	 edx, ax
  0044a	e8 00 00 00 00	 call	 store_hw_noswap

; 5167 :     pMPC_PUSre[2]->what = PUS_WHAT_04;

  0044f	b8 08 00 00 00	 mov	 eax, 8
  00454	48 6b c0 02	 imul	 rax, rax, 2
  00458	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00460	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5168 :     pMPC_PUSre[2]->type = PUS_TYPE_0C;

  00464	b8 08 00 00 00	 mov	 eax, 8
  00469	48 6b c0 02	 imul	 rax, rax, 2
  0046d	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00475	c6 40 03 0c	 mov	 BYTE PTR [rax+3], 12

; 5169 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[0] = 0x00;        // !!! //

  00479	b8 08 00 00 00	 mov	 eax, 8
  0047e	48 6b c0 02	 imul	 rax, rax, 2
  00482	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  0048a	b9 01 00 00 00	 mov	 ecx, 1
  0048f	48 6b c9 00	 imul	 rcx, rcx, 0
  00493	c6 44 08 04 00	 mov	 BYTE PTR [rax+rcx+4], 0

; 5170 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[1] = 0x09;        // !!! //

  00498	b8 08 00 00 00	 mov	 eax, 8
  0049d	48 6b c0 02	 imul	 rax, rax, 2
  004a1	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004a9	b9 01 00 00 00	 mov	 ecx, 1
  004ae	48 6b c9 01	 imul	 rcx, rcx, 1
  004b2	c6 44 08 04 09	 mov	 BYTE PTR [rax+rcx+4], 9

; 5171 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[2] = 0x00;        // !!! //

  004b7	b8 08 00 00 00	 mov	 eax, 8
  004bc	48 6b c0 02	 imul	 rax, rax, 2
  004c0	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004c8	b9 01 00 00 00	 mov	 ecx, 1
  004cd	48 6b c9 02	 imul	 rcx, rcx, 2
  004d1	c6 44 08 04 00	 mov	 BYTE PTR [rax+rcx+4], 0

; 5172 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[3] = 0x06;        // !!! //

  004d6	b8 08 00 00 00	 mov	 eax, 8
  004db	48 6b c0 02	 imul	 rax, rax, 2
  004df	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  004e7	b9 01 00 00 00	 mov	 ecx, 1
  004ec	48 6b c9 03	 imul	 rcx, rcx, 3
  004f0	c6 44 08 04 06	 mov	 BYTE PTR [rax+rcx+4], 6

; 5173 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[4] = 0x04;        // !!! //

  004f5	b8 08 00 00 00	 mov	 eax, 8
  004fa	48 6b c0 02	 imul	 rax, rax, 2
  004fe	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00506	b9 01 00 00 00	 mov	 ecx, 1
  0050b	48 6b c9 04	 imul	 rcx, rcx, 4
  0050f	c6 44 08 04 04	 mov	 BYTE PTR [rax+rcx+4], 4

; 5174 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[5] = 0x01;        // !!! //

  00514	b8 08 00 00 00	 mov	 eax, 8
  00519	48 6b c0 02	 imul	 rax, rax, 2
  0051d	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00525	b9 01 00 00 00	 mov	 ecx, 1
  0052a	48 6b c9 05	 imul	 rcx, rcx, 5
  0052e	c6 44 08 04 01	 mov	 BYTE PTR [rax+rcx+4], 1

; 5175 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[6] = 0x03;        // !!! //

  00533	b8 08 00 00 00	 mov	 eax, 8
  00538	48 6b c0 02	 imul	 rax, rax, 2
  0053c	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00544	b9 01 00 00 00	 mov	 ecx, 1
  00549	48 6b c9 06	 imul	 rcx, rcx, 6
  0054d	c6 44 08 04 03	 mov	 BYTE PTR [rax+rcx+4], 3

; 5176 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[7] = 0x04;        // !!! //

  00552	b8 08 00 00 00	 mov	 eax, 8
  00557	48 6b c0 02	 imul	 rax, rax, 2
  0055b	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00563	b9 01 00 00 00	 mov	 ecx, 1
  00568	48 6b c9 07	 imul	 rcx, rcx, 7
  0056c	c6 44 08 04 04	 mov	 BYTE PTR [rax+rcx+4], 4

; 5177 :     pMPC_PUSre[2]->vc.pus_0C.unknown04[8] = 0x08;        // !!! //

  00571	b8 08 00 00 00	 mov	 eax, 8
  00576	48 6b c0 02	 imul	 rax, rax, 2
  0057a	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00582	b9 01 00 00 00	 mov	 ecx, 1
  00587	48 6b c9 08	 imul	 rcx, rcx, 8
  0058b	c6 44 08 04 08	 mov	 BYTE PTR [rax+rcx+4], 8

; 5178 : 
; 5179 :     // Compare the tod clock value in the MPC_PUSwr with the tod clock
; 5180 :     // value in the second MPC_PUSre to determine which side wins.
; 5181 :     rc = memcmp( pMPC_PUSwr->vc.pus_02.a.clock,

  00590	b8 08 00 00 00	 mov	 eax, 8
  00595	48 6b c0 01	 imul	 rax, rax, 1
  00599	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  005a1	48 83 c0 04	 add	 rax, 4
  005a5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PUSwr$[rsp]
  005ad	48 83 c1 04	 add	 rcx, 4
  005b1	41 b8 08 00 00
	00		 mov	 r8d, 8
  005b7	48 8b d0	 mov	 rdx, rax
  005ba	e8 00 00 00 00	 call	 memcmp
  005bf	89 44 24 4c	 mov	 DWORD PTR rc$[rsp], eax

; 5182 :                  pMPC_PUSre[1]->vc.pus_02.a.clock,
; 5183 :                  sizeof(pMPC_PUSwr->vc.pus_02.a.clock) );
; 5184 :     if (rc < 0)

  005c3	83 7c 24 4c 00	 cmp	 DWORD PTR rc$[rsp], 0
  005c8	7d 13		 jge	 SHORT $LN6@build_417E

; 5185 :         // This should be the normal case; the other side must have
; 5186 :         // obtained the tod clock a few moments ago for it to be in the
; 5187 :         // message we recently received.
; 5188 :         *fxSideWins = TRUE;     // i.e. the x-side wins

  005ca	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR fxSideWins$[rsp]
  005d2	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
  005d8	e9 83 00 00 00	 jmp	 $LN7@build_417E
$LN6@build_417E:

; 5189 :     else if (rc > 0)

  005dd	83 7c 24 4c 00	 cmp	 DWORD PTR rc$[rsp], 0
  005e2	7e 10		 jle	 SHORT $LN8@build_417E

; 5190 :         // This shouldn't happen; the tod clock we have just obtained is
; 5191 :         // earlier than the tod clock in the message we recently received.
; 5192 :         // Presumably it wasn't a tod clock, or it was manipulated somehow.
; 5193 :         *fxSideWins = FALSE;    // i.e. the y-side wins

  005e4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR fxSideWins$[rsp]
  005ec	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  005f2	eb 6c		 jmp	 SHORT $LN9@build_417E
$LN8@build_417E:

; 5194 :     else
; 5195 :     {
; 5196 :         // This shouldn't happen; the tod clock we have just obtained is
; 5197 :         // equal to the tod clock in the message we recently received.
; 5198 :         // Perhaps Hercules hasn't updated the tod clock for ages, though
; 5199 :         // that seems unlikely, so assume it was manipulated somehow.
; 5200 :         FETCH_DW( uTod, pMPC_PUSre[1]->vc.pus_02.a.clock );  // get x-side's time

  005f4	b8 08 00 00 00	 mov	 eax, 8
  005f9	48 6b c0 01	 imul	 rax, rax, 1
  005fd	48 8b 84 04 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PUSre$[rsp+rax]
  00605	48 83 c0 04	 add	 rax, 4
  00609	48 8b c8	 mov	 rcx, rax
  0060c	e8 00 00 00 00	 call	 fetch_dw_noswap
  00611	48 8b c8	 mov	 rcx, rax
  00614	e8 00 00 00 00	 call	 _byteswap_uint64
  00619	48 89 44 24 70	 mov	 QWORD PTR uTod$[rsp], rax

; 5201 :         uTod += 0x0000000000000001;                          // Add a tiny amount

  0061e	48 8b 44 24 70	 mov	 rax, QWORD PTR uTod$[rsp]
  00623	48 ff c0	 inc	 rax
  00626	48 89 44 24 70	 mov	 QWORD PTR uTod$[rsp], rax

; 5202 :         STORE_DW( pMPC_PUSre[1]->vc.pus_02.a.clock, uTod );  // set x-side's time

  0062b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR uTod$[rsp]
  00630	e8 00 00 00 00	 call	 _byteswap_uint64
  00635	b9 08 00 00 00	 mov	 ecx, 8
  0063a	48 6b c9 01	 imul	 rcx, rcx, 1
  0063e	48 8b 8c 0c 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PUSre$[rsp+rcx]
  00646	48 83 c1 04	 add	 rcx, 4
  0064a	48 8b d0	 mov	 rdx, rax
  0064d	e8 00 00 00 00	 call	 store_dw_noswap

; 5203 :         *fxSideWins = TRUE;                                  // the x-side wins

  00652	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR fxSideWins$[rsp]
  0065a	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN9@build_417E:
$LN7@build_417E:

; 5204 :     }
; 5205 : 
; 5206 :     // Display various information, maybe
; 5207 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00660	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00665	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00668	83 e0 10	 and	 eax, 16
  0066b	85 c0		 test	 eax, eax
  0066d	74 15		 je	 SHORT $LN10@build_417E

; 5208 :     {
; 5209 :         mpc_display_description( pDEVBLK, "Out RRH 0x417E (Issuer) PUK 0x4102 (CM_ENABLE)" );

  0066f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171893
  00676	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0067e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN10@build_417E:

; 5210 :     }
; 5211 : 
; 5212 :     return pPTPHDRre;

  00684	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDRre$[rsp]
$LN1@build_417E:

; 5213 : }   /* End function  build_417E_cm_enable() */

  00689	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00691	48 33 cc	 xor	 rcx, rsp
  00694	e8 00 00 00 00	 call	 __security_check_cookie
  00699	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  006a0	c3		 ret	 0
build_417E_cm_enable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPBLK$ = 96
iWhat$ = 104
pMPC_PUSwr$ = 112
pMPC_PUKwr$ = 120
pPTPHDRre$ = 128
fxSideWins$ = 136
pPTPATHre$ = 144
tv174 = 152
uOffPH$ = 156
tv269 = 160
tv273 = 164
tv315 = 168
tv319 = 172
tv366 = 176
tv370 = 180
tv434 = 184
tv438 = 188
tv479 = 192
tv483 = 196
tv530 = 200
tv534 = 204
tv585 = 208
tv589 = 212
tv612 = 216
tv616 = 220
tv639 = 224
tv675 = 228
tv697 = 232
tv701 = 236
uOffData$ = 240
tv188 = 244
tv192 = 248
tv224 = 252
tv228 = 256
pPTPATHwr$ = 264
pPTPATH$ = 272
pMPC_PHwr$ = 280
tv582 = 288
tv609 = 296
tv636 = 304
pDEVBLK$ = 336
pMPC_THwr$ = 344
pMPC_RRHwr$ = 352
write_rrh_417E PROC

; 4589 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H

; 4590 :     PTPATH*    pPTPATH   = pDEVBLK->dev_data;

  00016	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 4591 :     PTPBLK*    pPTPBLK   = pPTPATH->pPTPBLK;

  0002d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 89 44 24 60	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 4592 :     PTPATH*    pPTPATHre = pPTPBLK->pPTPATHRead;

  0003d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pPTPATHre$[rsp], rax

; 4593 :     PTPATH*    pPTPATHwr = pPTPBLK->pPTPATHWrite;

  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00052	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00056	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR pPTPATHwr$[rsp], rax

; 4594 :     MPC_PH*    pMPC_PHwr;                      // MPC_PH being written
; 4595 :     MPC_PUK*   pMPC_PUKwr;                     // MPC_PUK being written
; 4596 :     MPC_PUS*   pMPC_PUSwr;                     // MPC_PUSs being written
; 4597 :     U16        uOffPH;
; 4598 : //  U32        uLenData;
; 4599 :     U32        uOffData;
; 4600 :     u_int      fxSideWins;
; 4601 :     PTPHDR*    pPTPHDRre;                      // PTPHDR to be read
; 4602 :     int        iWhat;
; 4603 : #define UNKNOWN_PUK   0
; 4604 : #define CM_ENABLE     1
; 4605 : #define CM_SETUP      2
; 4606 : #define CM_CONFIRM    3
; 4607 : #define CM_DISABLE    4
; 4608 : #define CM_TAKEDOWN   5
; 4609 : #define ULP_ENABLE    6
; 4610 : #define ULP_SETUP     7
; 4611 : #define ULP_CONFIRM   8
; 4612 : #define ULP_DISABLE   9
; 4613 : #define ULP_TAKEDOWN  10
; 4614 : #define DM_ACT        11
; 4615 : 
; 4616 : 
; 4617 :     // Point to the MPC_PH.
; 4618 :     FETCH_HW( uOffPH, pMPC_RRHwr->offph );

  0005e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pMPC_RRHwr$[rsp]
  00066	48 83 c0 10	 add	 rax, 16
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00072	0f b7 c8	 movzx	 ecx, ax
  00075	e8 00 00 00 00	 call	 _byteswap_ushort
  0007a	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR uOffPH$[rsp], ax

; 4619 :     pMPC_PHwr = (MPC_PH*)((BYTE*)pMPC_RRHwr + uOffPH);

  00082	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0008a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  00092	48 03 c8	 add	 rcx, rax
  00095	48 8b c1	 mov	 rax, rcx
  00098	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR pMPC_PHwr$[rsp], rax

; 4620 : 
; 4621 :     // Get the length of and point to the data referenced by the
; 4622 :     // MPC_PH. The data contain a MPC_PUK and one or more MPC_PUSs.
; 4623 : //  FETCH_F3( uLenData, pMPC_PH->lendata );
; 4624 :     FETCH_FW( uOffData, pMPC_PHwr->offdata );

  000a0	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pMPC_PHwr$[rsp]
  000a8	48 83 c0 04	 add	 rax, 4
  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 fetch_fw_noswap
  000b4	8b c8		 mov	 ecx, eax
  000b6	e8 00 00 00 00	 call	 _byteswap_ulong
  000bb	89 84 24 f0 00
	00 00		 mov	 DWORD PTR uOffData$[rsp], eax

; 4625 :     pMPC_PUKwr = (MPC_PUK*)((BYTE*)pMPC_THwr + uOffData);

  000c2	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR uOffData$[rsp]
  000c9	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR pMPC_THwr$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 78	 mov	 QWORD PTR pMPC_PUKwr$[rsp], rax

; 4626 : 
; 4627 :     // Decide what the PUK contains.
; 4628 :     iWhat = UNKNOWN_PUK;

  000dc	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 0

; 4629 :     if (memcmp( pMPC_RRHwr->token, pPTPBLK->xTokenIssuerRm, MPC_TOKEN_LENGTH ) == 0)

  000e4	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000e9	48 05 3d 03 00
	00		 add	 rax, 829		; 0000033dH
  000ef	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  000f7	48 83 c1 18	 add	 rcx, 24
  000fb	41 b8 04 00 00
	00		 mov	 r8d, 4
  00101	48 8b d0	 mov	 rdx, rax
  00104	e8 00 00 00 00	 call	 memcmp
  00109	85 c0		 test	 eax, eax
  0010b	0f 85 89 00 00
	00		 jne	 $LN4@write_rrh_

; 4630 :     {
; 4631 :         if (pMPC_PUKwr->what == PUK_WHAT_41)

  00111	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  00116	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0011a	83 f8 41	 cmp	 eax, 65			; 00000041H
  0011d	75 76		 jne	 SHORT $LN6@write_rrh_

; 4632 :         {
; 4633 :             if (pMPC_PUKwr->type == PUK_TYPE_ENABLE)

  0011f	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  00124	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00128	83 f8 02	 cmp	 eax, 2
  0012b	75 0a		 jne	 SHORT $LN7@write_rrh_

; 4634 :             {
; 4635 :                 iWhat = CM_ENABLE;

  0012d	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 1

; 4636 :             }

  00135	eb 5e		 jmp	 SHORT $LN8@write_rrh_
$LN7@write_rrh_:

; 4637 :             else if (pMPC_PUKwr->type == PUK_TYPE_SETUP)

  00137	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  0013c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00140	83 f8 04	 cmp	 eax, 4
  00143	75 0a		 jne	 SHORT $LN9@write_rrh_

; 4638 :             {
; 4639 :                 iWhat = CM_SETUP;

  00145	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 2

; 4640 :             }

  0014d	eb 46		 jmp	 SHORT $LN10@write_rrh_
$LN9@write_rrh_:

; 4641 :             else if (pMPC_PUKwr->type == PUK_TYPE_CONFIRM)

  0014f	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  00154	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00158	83 f8 06	 cmp	 eax, 6
  0015b	75 0a		 jne	 SHORT $LN11@write_rrh_

; 4642 :             {
; 4643 :                 iWhat = CM_CONFIRM;

  0015d	c7 44 24 68 03
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 3

; 4644 :             }

  00165	eb 2e		 jmp	 SHORT $LN12@write_rrh_
$LN11@write_rrh_:

; 4645 :             else if (pMPC_PUKwr->type == PUK_TYPE_DISABLE)

  00167	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  0016c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00170	83 f8 03	 cmp	 eax, 3
  00173	75 0a		 jne	 SHORT $LN13@write_rrh_

; 4646 :             {
; 4647 :                 iWhat = CM_DISABLE;

  00175	c7 44 24 68 04
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 4

; 4648 :             }

  0017d	eb 16		 jmp	 SHORT $LN14@write_rrh_
$LN13@write_rrh_:

; 4649 :             else if (pMPC_PUKwr->type == PUK_TYPE_TAKEDOWN)

  0017f	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  00184	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00188	83 f8 05	 cmp	 eax, 5
  0018b	75 08		 jne	 SHORT $LN15@write_rrh_

; 4650 :             {
; 4651 :                 iWhat = CM_TAKEDOWN;

  0018d	c7 44 24 68 05
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 5
$LN15@write_rrh_:
$LN14@write_rrh_:
$LN12@write_rrh_:
$LN10@write_rrh_:
$LN8@write_rrh_:
$LN6@write_rrh_:

; 4652 :             }
; 4653 :         }
; 4654 :     }

  00195	e9 d7 00 00 00	 jmp	 $LN5@write_rrh_
$LN4@write_rrh_:

; 4655 :     else if (memcmp( pMPC_RRHwr->token, pPTPBLK->xTokenCmConnection, MPC_TOKEN_LENGTH ) == 0)

  0019a	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0019f	48 05 45 03 00
	00		 add	 rax, 837		; 00000345H
  001a5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pMPC_RRHwr$[rsp]
  001ad	48 83 c1 18	 add	 rcx, 24
  001b1	41 b8 04 00 00
	00		 mov	 r8d, 4
  001b7	48 8b d0	 mov	 rdx, rax
  001ba	e8 00 00 00 00	 call	 memcmp
  001bf	85 c0		 test	 eax, eax
  001c1	0f 85 aa 00 00
	00		 jne	 $LN16@write_rrh_

; 4656 :     {
; 4657 :         if (pMPC_PUKwr->what == PUK_WHAT_41)

  001c7	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  001cc	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001d0	83 f8 41	 cmp	 eax, 65			; 00000041H
  001d3	75 78		 jne	 SHORT $LN17@write_rrh_

; 4658 :         {
; 4659 :             if (pMPC_PUKwr->type == PUK_TYPE_ENABLE)

  001d5	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  001da	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001de	83 f8 02	 cmp	 eax, 2
  001e1	75 0a		 jne	 SHORT $LN19@write_rrh_

; 4660 :             {
; 4661 :                 iWhat = ULP_ENABLE;

  001e3	c7 44 24 68 06
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 6

; 4662 :             }

  001eb	eb 5e		 jmp	 SHORT $LN20@write_rrh_
$LN19@write_rrh_:

; 4663 :             else if (pMPC_PUKwr->type == PUK_TYPE_SETUP)

  001ed	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  001f2	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001f6	83 f8 04	 cmp	 eax, 4
  001f9	75 0a		 jne	 SHORT $LN21@write_rrh_

; 4664 :             {
; 4665 :                 iWhat = ULP_SETUP;

  001fb	c7 44 24 68 07
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 7

; 4666 :             }

  00203	eb 46		 jmp	 SHORT $LN22@write_rrh_
$LN21@write_rrh_:

; 4667 :             else if (pMPC_PUKwr->type == PUK_TYPE_CONFIRM)

  00205	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  0020a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0020e	83 f8 06	 cmp	 eax, 6
  00211	75 0a		 jne	 SHORT $LN23@write_rrh_

; 4668 :             {
; 4669 :                 iWhat = ULP_CONFIRM;

  00213	c7 44 24 68 08
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 8

; 4670 :             }

  0021b	eb 2e		 jmp	 SHORT $LN24@write_rrh_
$LN23@write_rrh_:

; 4671 :             else if (pMPC_PUKwr->type == PUK_TYPE_DISABLE)

  0021d	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  00222	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00226	83 f8 03	 cmp	 eax, 3
  00229	75 0a		 jne	 SHORT $LN25@write_rrh_

; 4672 :             {
; 4673 :                 iWhat = ULP_DISABLE;

  0022b	c7 44 24 68 09
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 9

; 4674 :             }

  00233	eb 16		 jmp	 SHORT $LN26@write_rrh_
$LN25@write_rrh_:

; 4675 :             else if (pMPC_PUKwr->type == PUK_TYPE_TAKEDOWN)

  00235	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  0023a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0023e	83 f8 05	 cmp	 eax, 5
  00241	75 08		 jne	 SHORT $LN27@write_rrh_

; 4676 :             {
; 4677 :                 iWhat = ULP_TAKEDOWN;

  00243	c7 44 24 68 0a
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 10
$LN27@write_rrh_:
$LN26@write_rrh_:
$LN24@write_rrh_:
$LN22@write_rrh_:
$LN20@write_rrh_:

; 4678 :             }
; 4679 :         }

  0024b	eb 24		 jmp	 SHORT $LN18@write_rrh_
$LN17@write_rrh_:

; 4680 :         else if (pMPC_PUKwr->what == PUK_WHAT_43)

  0024d	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  00252	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00256	83 f8 43	 cmp	 eax, 67			; 00000043H
  00259	75 16		 jne	 SHORT $LN28@write_rrh_

; 4681 :         {
; 4682 :             if (pMPC_PUKwr->type == PUK_TYPE_ACTIVE)

  0025b	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_PUKwr$[rsp]
  00260	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00264	83 f8 60	 cmp	 eax, 96			; 00000060H
  00267	75 08		 jne	 SHORT $LN29@write_rrh_

; 4683 :             {
; 4684 :                 iWhat = DM_ACT;

  00269	c7 44 24 68 0b
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 11
$LN29@write_rrh_:
$LN28@write_rrh_:
$LN18@write_rrh_:
$LN16@write_rrh_:
$LN5@write_rrh_:

; 4685 :             }
; 4686 :         }
; 4687 :     }
; 4688 : 
; 4689 :     // Process the PUK.
; 4690 :     switch( iWhat )

  00271	8b 44 24 68	 mov	 eax, DWORD PTR iWhat$[rsp]
  00275	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv174[rsp], eax
  0027c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv174[rsp]
  00283	ff c8		 dec	 eax
  00285	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv174[rsp], eax
  0028c	83 bc 24 98 00
	00 00 0a	 cmp	 DWORD PTR tv174[rsp], 10
  00294	0f 87 5e 0e 00
	00		 ja	 $LN65@write_rrh_
  0029a	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv174[rsp]
  002a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002a9	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN67@write_rrh_[rcx+rax*4]
  002b0	48 03 c1	 add	 rax, rcx
  002b3	ff e0		 jmp	 rax
$LN30@write_rrh_:

; 4691 :     {
; 4692 : 
; 4693 :     // PUK 0x4102 to xTokenIssuerRm
; 4694 :     // The MPC_PUK should be followed by three MPC_PUSs, the first a type
; 4695 :     // 0x0401, the second a type 0x0402, and the third a type 0x040c.
; 4696 :     case CM_ENABLE:
; 4697 : 
; 4698 :         // Display various information, maybe
; 4699 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  002b5	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002ba	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  002bd	83 e0 10	 and	 eax, 16
  002c0	85 c0		 test	 eax, eax
  002c2	74 15		 je	 SHORT $LN31@write_rrh_

; 4700 :         {
; 4701 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (Issuer) PUK 0x4102 (CM_ENABLE)" );

  002c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171734
  002cb	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN31@write_rrh_:

; 4702 :         }
; 4703 : 
; 4704 :         // Find the PUS and copy the yTokenCmFilter.
; 4705 :         pMPC_PUSwr = mpc_point_pus( pDEVBLK, pMPC_PUKwr, PUS_TYPE_01 );

  002d9	41 b0 01	 mov	 r8b, 1
  002dc	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_PUKwr$[rsp]
  002e1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  002ef	48 89 44 24 70	 mov	 QWORD PTR pMPC_PUSwr$[rsp], rax

; 4706 :         if (!pMPC_PUSwr)

  002f4	48 83 7c 24 70
	00		 cmp	 QWORD PTR pMPC_PUSwr$[rsp], 0
  002fa	0f 85 c3 00 00
	00		 jne	 $LN32@write_rrh_

; 4707 :         {
; 4708 :             // HHC03937 "%1d:%04X PTP: Accept data contains %s that does not contain expected %s"
; 4709 :             WRMSG(HHC03937, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK (CM_ENABLE)", "PUS_01" );

  00300	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00308	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0030c	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv188[rsp], eax
  00313	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0031b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0031f	d1 f9		 sar	 ecx, 1
  00321	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR tv192[rsp], ecx
  00328	b9 01 00 00 00	 mov	 ecx, 1
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171736
  0033a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0033f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171737
  00346	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0034b	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  00352	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00356	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  0035d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171738
  00368	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171739
  00374	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00379	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00384	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171740
  0038b	ba 65 12 00 00	 mov	 edx, 4709		; 00001265H
  00390	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171741
  00397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4710 :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  0039d	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  003a0	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  003a8	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  003b0	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk

; 4711 :             break;

  003be	e9 e7 0d 00 00	 jmp	 $LN2@write_rrh_
$LN32@write_rrh_:

; 4712 :         }
; 4713 :         memcpy( pPTPBLK->yTokenCmFilter, pMPC_PUSwr->vc.pus_01.token, MPC_TOKEN_LENGTH );

  003c3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003c8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_PUSwr$[rsp]
  003cd	8b 49 07	 mov	 ecx, DWORD PTR [rcx+7]
  003d0	89 88 64 03 00
	00		 mov	 DWORD PTR [rax+868], ecx

; 4714 : 
; 4715 :         // Find the PUS that contains the 'bid' value.
; 4716 :         // Build RRH 0x417E PUK 0x4102 to yTokenIssuerRm
; 4717 :         pMPC_PUSwr = mpc_point_pus( pDEVBLK, pMPC_PUKwr, PUS_TYPE_02 );

  003d6	41 b0 02	 mov	 r8b, 2
  003d9	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_PUKwr$[rsp]
  003de	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  003ec	48 89 44 24 70	 mov	 QWORD PTR pMPC_PUSwr$[rsp], rax

; 4718 :         if (!pMPC_PUSwr)

  003f1	48 83 7c 24 70
	00		 cmp	 QWORD PTR pMPC_PUSwr$[rsp], 0
  003f7	0f 85 c3 00 00
	00		 jne	 $LN33@write_rrh_

; 4719 :         {
; 4720 :             // HHC03937 "%1d:%04X PTP: Accept data contains %s that does not contain expected %s"
; 4721 :             WRMSG(HHC03937, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK (CM_ENABLE)", "PUS_02" );

  003fd	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00405	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00409	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  00410	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00418	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0041c	d1 f9		 sar	 ecx, 1
  0041e	89 8c 24 00 01
	00 00		 mov	 DWORD PTR tv228[rsp], ecx
  00425	b9 01 00 00 00	 mov	 ecx, 1
  0042a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171743
  00437	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0043c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171744
  00443	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00448	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  0044f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00453	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  0045a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0045e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171745
  00465	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0046a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171746
  00471	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00476	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00481	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171747
  00488	ba 71 12 00 00	 mov	 edx, 4721		; 00001271H
  0048d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171748
  00494	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4722 :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  0049a	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0049d	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  004a5	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  004ad	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk

; 4723 :             break;

  004bb	e9 ea 0c 00 00	 jmp	 $LN2@write_rrh_
$LN33@write_rrh_:

; 4724 :         }
; 4725 :         fxSideWins = FALSE;

  004c0	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fxSideWins$[rsp], 0

; 4726 :         pPTPHDRre = build_417E_cm_enable( pDEVBLK, pMPC_RRHwr, pMPC_PUSwr, &fxSideWins );

  004cb	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR fxSideWins$[rsp]
  004d3	4c 8b 44 24 70	 mov	 r8, QWORD PTR pMPC_PUSwr$[rsp]
  004d8	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pMPC_RRHwr$[rsp]
  004e0	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004e8	e8 00 00 00 00	 call	 build_417E_cm_enable
  004ed	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 4727 : 
; 4728 :         // Add PTPHDR to chain.
; 4729 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  004f5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  004fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00505	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 4730 : 
; 4731 :         // If this side 'wins' the 'handedness' this side must now  send
; 4732 :         // a RRH 0x417E PUK 0x4104 to yTokenIssuerRm on the other side.
; 4733 :         // If the other side 'wins' the 'handedness' this side must now wait
; 4734 :         // to receive a RRH 0x417E PUK 0x4104 to xTokenIssuerRm from the
; 4735 :         // other side.
; 4736 :         if (fxSideWins)     // if the x-side wins

  0050a	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR fxSideWins$[rsp], 0
  00512	74 32		 je	 SHORT $LN34@write_rrh_

; 4737 :         {
; 4738 : 
; 4739 :             // Build RRH 0x417E PUK 0x4104 to yTokenIssuerRm
; 4740 :             pPTPHDRre = build_417E_cm_setup( pDEVBLK, pMPC_RRHwr );

  00514	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pMPC_RRHwr$[rsp]
  0051c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00524	e8 00 00 00 00	 call	 build_417E_cm_setup
  00529	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 4741 : 
; 4742 :             // Add PTPHDR to chain.
; 4743 :             add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00531	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00539	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00541	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event
$LN34@write_rrh_:

; 4744 : 
; 4745 :         }
; 4746 : 
; 4747 :         break;

  00546	e9 5f 0c 00 00	 jmp	 $LN2@write_rrh_
$LN35@write_rrh_:

; 4748 : 
; 4749 :     // PUK 0x4104 to xTokenIssuerRm
; 4750 :     // The MPC_PUK should be followed by three MPC_PUSs, the first a type
; 4751 :     // 0x0404, the second a type 0x0405, and the third a type 0x0406.
; 4752 :     case CM_SETUP:
; 4753 : 
; 4754 :         // Display various information, maybe
; 4755 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0054b	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00550	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00553	83 e0 10	 and	 eax, 16
  00556	85 c0		 test	 eax, eax
  00558	74 15		 je	 SHORT $LN36@write_rrh_

; 4756 :         {
; 4757 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (Issuer) PUK 0x4104 (CM_SETUP)" );

  0055a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171752
  00561	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN36@write_rrh_:

; 4758 :         }
; 4759 : 
; 4760 :         // Find the PUS and copy the yTokenCmConnection.
; 4761 :         pMPC_PUSwr = mpc_point_pus( pDEVBLK, pMPC_PUKwr, PUS_TYPE_04 );

  0056f	41 b0 04	 mov	 r8b, 4
  00572	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_PUKwr$[rsp]
  00577	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0057f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  00585	48 89 44 24 70	 mov	 QWORD PTR pMPC_PUSwr$[rsp], rax

; 4762 :         if (!pMPC_PUSwr)

  0058a	48 83 7c 24 70
	00		 cmp	 QWORD PTR pMPC_PUSwr$[rsp], 0
  00590	0f 85 c3 00 00
	00		 jne	 $LN37@write_rrh_

; 4763 :         {
; 4764 :             // HHC03937 "%1d:%04X PTP: Accept data contains %s that does not contain expected %s"
; 4765 :             WRMSG(HHC03937, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK (CM_SETUP)", "PUS_04" );

  00596	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0059e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005a2	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv269[rsp], eax
  005a9	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005b1	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  005b5	d1 f9		 sar	 ecx, 1
  005b7	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv273[rsp], ecx
  005be	b9 01 00 00 00	 mov	 ecx, 1
  005c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171754
  005d0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171755
  005dc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005e1	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv269[rsp]
  005e8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005ec	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  005f3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171756
  005fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00603	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171757
  0060a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0060f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00614	41 b9 03 00 00
	00		 mov	 r9d, 3
  0061a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171758
  00621	ba 9d 12 00 00	 mov	 edx, 4765		; 0000129dH
  00626	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171759
  0062d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4766 :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  00633	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00636	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  0063e	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  00646	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0064e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk

; 4767 :             break;

  00654	e9 51 0b 00 00	 jmp	 $LN2@write_rrh_
$LN37@write_rrh_:

; 4768 :         }
; 4769 :         memcpy( pPTPBLK->yTokenCmConnection, pMPC_PUSwr->vc.pus_04.token, MPC_TOKEN_LENGTH );

  00659	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0065e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_PUSwr$[rsp]
  00663	8b 49 05	 mov	 ecx, DWORD PTR [rcx+5]
  00666	89 88 68 03 00
	00		 mov	 DWORD PTR [rax+872], ecx

; 4770 : 
; 4771 :         // Build RRH 0x417E PUK 0x4106 to yTokenIssuerRm
; 4772 :         pPTPHDRre = build_417E_cm_confirm( pDEVBLK, pMPC_RRHwr );

  0066c	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pMPC_RRHwr$[rsp]
  00674	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0067c	e8 00 00 00 00	 call	 build_417E_cm_confirm
  00681	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 4773 : 
; 4774 :         // Add PTPHDR to chain.
; 4775 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00689	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00691	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00699	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 4776 : 
; 4777 :         // When the y-side receives the RRH 0x417E PUK 0x4106 the control
; 4778 :         // process between the x-side and the y-side is active. On a connection
; 4779 :         // between two VTAMs, the x-side VTAM sends messages from xTokenCmFilter
; 4780 :         // to yTokenCmConnection, and the y-side VTAM sends messages from yTokenCmFilter
; 4781 :         // to xTokenCmConnection. The x-side (i.e. Hercules) will now wait for the
; 4782 :         // y-side VTAM to send a MSG 0x417E PUK 0x4102 to xTokenCmConnection to
; 4783 :         // begin the setup of the communication process.
; 4784 : 
; 4785 :         break;

  0069e	e9 07 0b 00 00	 jmp	 $LN2@write_rrh_
$LN38@write_rrh_:

; 4786 : 
; 4787 :     // PUK 0x4106 to xTokenIssuerRm
; 4788 :     // The MPC_PUK should be followed by three MPC_PUSs, the first a type
; 4789 :     // 0x0404, the second a type 0x0408, and the third a type 0x0407.
; 4790 :     case CM_CONFIRM:
; 4791 : 
; 4792 :         // Display various information, maybe
; 4793 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  006a3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  006a8	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  006ab	83 e0 10	 and	 eax, 16
  006ae	85 c0		 test	 eax, eax
  006b0	74 15		 je	 SHORT $LN39@write_rrh_

; 4794 :         {
; 4795 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (Issuer) PUK 0x4106 (CM_CONFIRM)" );

  006b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171762
  006b9	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN39@write_rrh_:

; 4796 :         }
; 4797 : 
; 4798 :         // Find the PUS and copy the yTokenCmConnection.
; 4799 :         pMPC_PUSwr = mpc_point_pus( pDEVBLK, pMPC_PUKwr, PUS_TYPE_08 );

  006c7	41 b0 08	 mov	 r8b, 8
  006ca	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_PUKwr$[rsp]
  006cf	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  006dd	48 89 44 24 70	 mov	 QWORD PTR pMPC_PUSwr$[rsp], rax

; 4800 :         if (!pMPC_PUSwr)

  006e2	48 83 7c 24 70
	00		 cmp	 QWORD PTR pMPC_PUSwr$[rsp], 0
  006e8	0f 85 c3 00 00
	00		 jne	 $LN40@write_rrh_

; 4801 :         {
; 4802 :             // HHC03937 "%1d:%04X PTP: Accept data contains %s that does not contain expected %s"
; 4803 :             WRMSG(HHC03937, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK (CM_CONFIRM)", "PUS_08" );

  006ee	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006f6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006fa	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv315[rsp], eax
  00701	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00709	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0070d	d1 f9		 sar	 ecx, 1
  0070f	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv319[rsp], ecx
  00716	b9 01 00 00 00	 mov	 ecx, 1
  0071b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00721	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171764
  00728	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0072d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171765
  00734	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00739	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv315[rsp]
  00740	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00744	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv319[rsp]
  0074b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0074f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171766
  00756	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0075b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171767
  00762	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00767	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00772	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171768
  00779	ba c3 12 00 00	 mov	 edx, 4803		; 000012c3H
  0077e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171769
  00785	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4804 :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  0078b	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0078e	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  00796	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  0079e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk

; 4805 :             break;

  007ac	e9 f9 09 00 00	 jmp	 $LN2@write_rrh_
$LN40@write_rrh_:

; 4806 :         }
; 4807 :         memcpy( pPTPBLK->yTokenCmConnection, pMPC_PUSwr->vc.pus_08.token, MPC_TOKEN_LENGTH );

  007b1	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_PUSwr$[rsp]
  007bb	8b 49 05	 mov	 ecx, DWORD PTR [rcx+5]
  007be	89 88 68 03 00
	00		 mov	 DWORD PTR [rax+872], ecx

; 4808 : 
; 4809 :         // The control process between the x-side and the y-side is active. On
; 4810 :         // a connection between two VTAMs, the x-side VTAM sends messages from
; 4811 :         // xTokenCmFilter to yTokenCmConnection, and the y-side VTAM sends messages
; 4812 :         // from yTokenCmFilter to xTokenCmConnection. The x-side (i.e. Hercules)
; 4813 :         // will now wait for the y-side VTAM to send a MSG 0x417E PUK 0x4102
; 4814 :         // to xTokenCmConnection to begin the setup of the communication process.
; 4815 : 
; 4816 :         break;

  007c4	e9 e1 09 00 00	 jmp	 $LN2@write_rrh_
$LN41@write_rrh_:

; 4817 : 
; 4818 :     // PUK 0x4103 to xTokenIssuerRm
; 4819 :     // The MPC_PUK should be followed by a single MPC_PUS, a type 0x0403.
; 4820 :     case CM_DISABLE:
; 4821 : 
; 4822 :         // Display various information, maybe
; 4823 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  007c9	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007ce	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  007d1	83 e0 10	 and	 eax, 16
  007d4	85 c0		 test	 eax, eax
  007d6	74 15		 je	 SHORT $LN42@write_rrh_

; 4824 :         {
; 4825 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (Issuer) PUK 0x4103 (CM_DISABLE)" );

  007d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171772
  007df	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN42@write_rrh_:

; 4826 :         }
; 4827 : 
; 4828 :         break;

  007ed	e9 b8 09 00 00	 jmp	 $LN2@write_rrh_
$LN43@write_rrh_:

; 4829 : 
; 4830 :     // PUK 0x4105 to xTokenIssuerRm
; 4831 :     // The MPC_PUK should be followed by a single MPC_PUS, a type 0x0404.
; 4832 :     case CM_TAKEDOWN:
; 4833 : 
; 4834 :         // Display various information, maybe
; 4835 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  007f2	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007f7	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  007fa	83 e0 10	 and	 eax, 16
  007fd	85 c0		 test	 eax, eax
  007ff	74 15		 je	 SHORT $LN44@write_rrh_

; 4836 :         {
; 4837 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (Issuer) PUK 0x4105 (CM_TAKEDOWN)" );

  00801	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171775
  00808	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00810	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN44@write_rrh_:

; 4838 :         }
; 4839 : 
; 4840 :         // The guest OS on the y-side has stopped the device
; 4841 : 
; 4842 :         break;

  00816	e9 8f 09 00 00	 jmp	 $LN2@write_rrh_
$LN45@write_rrh_:

; 4843 : 
; 4844 :     // PUK 0x4102 to xTokenCmConnection
; 4845 :     // The MPC_PUK should be followed by two MPC_PUSs, the first a type
; 4846 :     // 0x0401 and the second a type 0x0402.
; 4847 :     case ULP_ENABLE:
; 4848 : 
; 4849 :         // Display various information, maybe
; 4850 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0081b	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00820	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00823	83 e0 10	 and	 eax, 16
  00826	85 c0		 test	 eax, eax
  00828	74 15		 je	 SHORT $LN46@write_rrh_

; 4851 :         {
; 4852 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (CmComm) PUK 0x4102 (ULP_ENABLE)" );

  0082a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171778
  00831	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00839	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN46@write_rrh_:

; 4853 :         }
; 4854 : 
; 4855 :         // Find the PUS and copy the yTokenUlpFilter.
; 4856 :         pMPC_PUSwr = mpc_point_pus( pDEVBLK, pMPC_PUKwr, PUS_TYPE_01 );

  0083f	41 b0 01	 mov	 r8b, 1
  00842	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_PUKwr$[rsp]
  00847	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0084f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  00855	48 89 44 24 70	 mov	 QWORD PTR pMPC_PUSwr$[rsp], rax

; 4857 :         if (!pMPC_PUSwr)

  0085a	48 83 7c 24 70
	00		 cmp	 QWORD PTR pMPC_PUSwr$[rsp], 0
  00860	0f 85 c3 00 00
	00		 jne	 $LN47@write_rrh_

; 4858 :         {
; 4859 :             // HHC03937 "%1d:%04X PTP: Accept data contains %s that does not contain expected %s"
; 4860 :             WRMSG(HHC03937, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK (ULP_ENABLE)", "PUS_01" );

  00866	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0086e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00872	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv366[rsp], eax
  00879	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00881	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00885	d1 f9		 sar	 ecx, 1
  00887	89 8c 24 b4 00
	00 00		 mov	 DWORD PTR tv370[rsp], ecx
  0088e	b9 01 00 00 00	 mov	 ecx, 1
  00893	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00899	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171780
  008a0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  008a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171781
  008ac	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008b1	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv366[rsp]
  008b8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008bc	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv370[rsp]
  008c3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171782
  008ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171783
  008da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  008ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171784
  008f1	ba fc 12 00 00	 mov	 edx, 4860		; 000012fcH
  008f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171785
  008fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4861 :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  00903	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00906	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  0090e	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  00916	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0091e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk

; 4862 :             break;

  00924	e9 81 08 00 00	 jmp	 $LN2@write_rrh_
$LN47@write_rrh_:

; 4863 :         }
; 4864 :         memcpy( pPTPBLK->yTokenUlpFilter, pMPC_PUSwr->vc.pus_01.token, MPC_TOKEN_LENGTH );

  00929	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0092e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_PUSwr$[rsp]
  00933	8b 49 07	 mov	 ecx, DWORD PTR [rcx+7]
  00936	89 88 6c 03 00
	00		 mov	 DWORD PTR [rax+876], ecx

; 4865 : 
; 4866 :         // Find the PUS that contains the 'bid' value.
; 4867 :         // Build RRH 0x417E PUK 0x4102 to yTokenCmConnection
; 4868 :         pMPC_PUSwr = mpc_point_pus( pDEVBLK, pMPC_PUKwr, PUS_TYPE_02 );

  0093c	41 b0 02	 mov	 r8b, 2
  0093f	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_PUKwr$[rsp]
  00944	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0094c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  00952	48 89 44 24 70	 mov	 QWORD PTR pMPC_PUSwr$[rsp], rax

; 4869 :         if (!pMPC_PUSwr)

  00957	48 83 7c 24 70
	00		 cmp	 QWORD PTR pMPC_PUSwr$[rsp], 0
  0095d	0f 85 c3 00 00
	00		 jne	 $LN48@write_rrh_

; 4870 :         {
; 4871 :             // HHC03937 "%1d:%04X PTP: Accept data contains %s that does not contain expected %s"
; 4872 :             WRMSG(HHC03937, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK (ULP_ENABLE)", "PUS_02" );

  00963	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0096b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0096f	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv434[rsp], eax
  00976	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0097e	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00982	d1 f9		 sar	 ecx, 1
  00984	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv438[rsp], ecx
  0098b	b9 01 00 00 00	 mov	 ecx, 1
  00990	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00996	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171787
  0099d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171788
  009a9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009ae	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv434[rsp]
  009b5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009b9	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv438[rsp]
  009c0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171789
  009cb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171790
  009d7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009e1	41 b9 03 00 00
	00		 mov	 r9d, 3
  009e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171791
  009ee	ba 08 13 00 00	 mov	 edx, 4872		; 00001308H
  009f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171792
  009fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4873 :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  00a00	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00a03	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  00a0b	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  00a13	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk

; 4874 :             break;

  00a21	e9 84 07 00 00	 jmp	 $LN2@write_rrh_
$LN48@write_rrh_:

; 4875 :         }
; 4876 :         fxSideWins = FALSE;

  00a26	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fxSideWins$[rsp], 0

; 4877 :         pPTPHDRre = build_417E_ulp_enable( pDEVBLK, pMPC_RRHwr, pMPC_PUSwr, &fxSideWins );

  00a31	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR fxSideWins$[rsp]
  00a39	4c 8b 44 24 70	 mov	 r8, QWORD PTR pMPC_PUSwr$[rsp]
  00a3e	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pMPC_RRHwr$[rsp]
  00a46	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a4e	e8 00 00 00 00	 call	 build_417E_ulp_enable
  00a53	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 4878 : 
; 4879 :         // Add PTPHDR to chain.
; 4880 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00a5b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00a63	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00a6b	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 4881 : 
; 4882 :         // If this side 'wins' the 'handedness' this side must now send
; 4883 :         // a RRH 0x417E PUK 0x4104 to yTokenCmConnection on the other side.
; 4884 :         // If the other side 'wins' the 'handedness' this side must now wait
; 4885 :         // to receive a RRH 0x417E PUK 0x4104 to xTokenCmConnection from the
; 4886 :         // other side.
; 4887 :         if (fxSideWins)     // if the x-side wins

  00a70	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR fxSideWins$[rsp], 0
  00a78	74 32		 je	 SHORT $LN49@write_rrh_

; 4888 :         {
; 4889 : 
; 4890 :             // Build RRH 0x417E PUK 0x4104 to yTokenCmConnection
; 4891 :             pPTPHDRre = build_417E_ulp_setup( pDEVBLK, pMPC_RRHwr );

  00a7a	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pMPC_RRHwr$[rsp]
  00a82	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a8a	e8 00 00 00 00	 call	 build_417E_ulp_setup
  00a8f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 4892 : 
; 4893 :             // Add PTPHDR to chain.
; 4894 :             add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00a97	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00a9f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00aa7	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event
$LN49@write_rrh_:

; 4895 : 
; 4896 :         }
; 4897 : 
; 4898 :         break;

  00aac	e9 f9 06 00 00	 jmp	 $LN2@write_rrh_
$LN50@write_rrh_:

; 4899 : 
; 4900 :     // PUK 0x4104 to xTokenCmConnection
; 4901 :     // The MPC_PUK should be followed by four MPC_PUSs, the first a type
; 4902 :     // 0x0404, the second a type 0x0405, the third a type 0x0406, and
; 4903 :     // the fourth a type 0x0402.
; 4904 :     case ULP_SETUP:
; 4905 : 
; 4906 :         // Display various information, maybe
; 4907 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00ab1	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ab6	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00ab9	83 e0 10	 and	 eax, 16
  00abc	85 c0		 test	 eax, eax
  00abe	74 15		 je	 SHORT $LN51@write_rrh_

; 4908 :         {
; 4909 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (CmComm) PUK 0x4104 (ULP_SETUP)" );

  00ac0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171796
  00ac7	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00acf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN51@write_rrh_:

; 4910 :         }
; 4911 : 
; 4912 :         // Find the PUS and copy the yTokenUlpConnection.
; 4913 :         pMPC_PUSwr = mpc_point_pus( pDEVBLK, pMPC_PUKwr, PUS_TYPE_04 );

  00ad5	41 b0 04	 mov	 r8b, 4
  00ad8	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_PUKwr$[rsp]
  00add	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ae5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  00aeb	48 89 44 24 70	 mov	 QWORD PTR pMPC_PUSwr$[rsp], rax

; 4914 :         if (!pMPC_PUSwr)

  00af0	48 83 7c 24 70
	00		 cmp	 QWORD PTR pMPC_PUSwr$[rsp], 0
  00af6	0f 85 c3 00 00
	00		 jne	 $LN52@write_rrh_

; 4915 :         {
; 4916 :             // HHC03937 "%1d:%04X PTP: Accept data contains %s that does not contain expected %s"
; 4917 :             WRMSG(HHC03937, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK (ULP_SETUP)", "PUS_04" );

  00afc	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b04	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b08	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv479[rsp], eax
  00b0f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00b17	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00b1b	d1 f9		 sar	 ecx, 1
  00b1d	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv483[rsp], ecx
  00b24	b9 01 00 00 00	 mov	 ecx, 1
  00b29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171798
  00b36	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171799
  00b42	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b47	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv479[rsp]
  00b4e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b52	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv483[rsp]
  00b59	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b5d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171800
  00b64	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b69	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171801
  00b70	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b75	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b7a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b80	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171802
  00b87	ba 35 13 00 00	 mov	 edx, 4917		; 00001335H
  00b8c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171803
  00b93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4918 :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  00b99	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00b9c	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  00ba4	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  00bac	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00bb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk

; 4919 :             break;

  00bba	e9 eb 05 00 00	 jmp	 $LN2@write_rrh_
$LN52@write_rrh_:

; 4920 :         }
; 4921 :         memcpy( pPTPBLK->yTokenUlpConnection, pMPC_PUSwr->vc.pus_04.token, MPC_TOKEN_LENGTH );

  00bbf	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00bc4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_PUSwr$[rsp]
  00bc9	8b 49 05	 mov	 ecx, DWORD PTR [rcx+5]
  00bcc	89 88 70 03 00
	00		 mov	 DWORD PTR [rax+880], ecx

; 4922 : 
; 4923 :         // Build RRH 0x417E PUK 0x4106 to yTokenCmConnection
; 4924 :         pPTPHDRre = build_417E_ulp_confirm( pDEVBLK, pMPC_RRHwr );

  00bd2	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pMPC_RRHwr$[rsp]
  00bda	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00be2	e8 00 00 00 00	 call	 build_417E_ulp_confirm
  00be7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 4925 : 
; 4926 :         // Add PTPHDR to chain.
; 4927 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00bef	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00bf7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00bff	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 4928 : 
; 4929 :         // Build RRH 0x417E PUK 0x4360 to yTokenCmConnection
; 4930 :         pPTPHDRre = build_417E_dm_act( pDEVBLK, pMPC_RRHwr );

  00c04	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pMPC_RRHwr$[rsp]
  00c0c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c14	e8 00 00 00 00	 call	 build_417E_dm_act
  00c19	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 4931 : 
; 4932 :         // Add PTPHDR to chain.
; 4933 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00c21	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00c29	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00c31	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 4934 : 
; 4935 :         break;

  00c36	e9 6f 05 00 00	 jmp	 $LN2@write_rrh_
$LN53@write_rrh_:

; 4936 : 
; 4937 :     // PUK 0x4106 to xTokenCmConnection
; 4938 :     // The MPC_PUK should be followed by four MPC_PUSs, the first a type
; 4939 :     // 0x0404, the second a type 0x0408, the third a type 0x0407, and
; 4940 :     // the fourth a type 0x0402.
; 4941 :     case ULP_CONFIRM:
; 4942 : 
; 4943 :         // Display various information, maybe
; 4944 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00c3b	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00c40	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00c43	83 e0 10	 and	 eax, 16
  00c46	85 c0		 test	 eax, eax
  00c48	74 15		 je	 SHORT $LN54@write_rrh_

; 4945 :         {
; 4946 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (CmComm) PUK 0x4106 (ULP_CONFIRM)" );

  00c4a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171806
  00c51	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN54@write_rrh_:

; 4947 :         }
; 4948 : 
; 4949 :         // Find the PUS and copy the yTokenUlpConnection.
; 4950 :         pMPC_PUSwr = mpc_point_pus( pDEVBLK, pMPC_PUKwr, PUS_TYPE_08 );

  00c5f	41 b0 08	 mov	 r8b, 8
  00c62	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_PUKwr$[rsp]
  00c67	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  00c75	48 89 44 24 70	 mov	 QWORD PTR pMPC_PUSwr$[rsp], rax

; 4951 :         if (!pMPC_PUSwr)

  00c7a	48 83 7c 24 70
	00		 cmp	 QWORD PTR pMPC_PUSwr$[rsp], 0
  00c80	0f 85 c3 00 00
	00		 jne	 $LN55@write_rrh_

; 4952 :         {
; 4953 :             // HHC03937 "%1d:%04X PTP: Accept data contains %s that does not contain expected %s"
; 4954 :             WRMSG(HHC03937, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK (ULP_CONFIRM)", "PUS_08" );

  00c86	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c8e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c92	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv530[rsp], eax
  00c99	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ca1	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00ca5	d1 f9		 sar	 ecx, 1
  00ca7	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv534[rsp], ecx
  00cae	b9 01 00 00 00	 mov	 ecx, 1
  00cb3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cb9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171808
  00cc0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00cc5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171809
  00ccc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cd1	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv530[rsp]
  00cd8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cdc	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv534[rsp]
  00ce3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ce7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171810
  00cee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cf3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171811
  00cfa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00cff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d04	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d0a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171812
  00d11	ba 5a 13 00 00	 mov	 edx, 4954		; 0000135aH
  00d16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171813
  00d1d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4955 :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  00d23	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00d26	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  00d2e	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  00d36	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d3e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk

; 4956 :             break;

  00d44	e9 61 04 00 00	 jmp	 $LN2@write_rrh_
$LN55@write_rrh_:

; 4957 :         }
; 4958 :         memcpy( pPTPBLK->yTokenUlpConnection, pMPC_PUSwr->vc.pus_08.token, MPC_TOKEN_LENGTH );

  00d49	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00d4e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_PUSwr$[rsp]
  00d53	8b 49 05	 mov	 ecx, DWORD PTR [rcx+5]
  00d56	89 88 70 03 00
	00		 mov	 DWORD PTR [rax+880], ecx

; 4959 : 
; 4960 :         // Build RRH 0x417E PUK 0x4360 to yTokenCmConnection
; 4961 :         pPTPHDRre = build_417E_dm_act( pDEVBLK, pMPC_RRHwr );

  00d5c	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pMPC_RRHwr$[rsp]
  00d64	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d6c	e8 00 00 00 00	 call	 build_417E_dm_act
  00d71	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPHDRre$[rsp], rax

; 4962 : 
; 4963 :         // Add PTPHDR to chain.
; 4964 :         add_buffer_to_chain_and_signal_event( pPTPATHre, pPTPHDRre );

  00d79	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRre$[rsp]
  00d81	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00d89	e8 00 00 00 00	 call	 add_buffer_to_chain_and_signal_event

; 4965 : 
; 4966 :         break;

  00d8e	e9 17 04 00 00	 jmp	 $LN2@write_rrh_
$LN56@write_rrh_:

; 4967 : 
; 4968 :     // PUK 0x4360 to xTokenCmConnection
; 4969 :     // The MPC_PUK should be followed by a single MPC_PUS, a type 0x0404.
; 4970 :     case DM_ACT:
; 4971 : 
; 4972 :         // Display various information, maybe
; 4973 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00d93	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00d98	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00d9b	83 e0 10	 and	 eax, 16
  00d9e	85 c0		 test	 eax, eax
  00da0	74 15		 je	 SHORT $LN57@write_rrh_

; 4974 :         {
; 4975 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (CmComm) PUK 0x4360 (DM_ACT)" );

  00da2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171816
  00da9	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00db1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN57@write_rrh_:

; 4976 :         }
; 4977 : 
; 4978 :         break;

  00db7	e9 ee 03 00 00	 jmp	 $LN2@write_rrh_
$LN58@write_rrh_:

; 4979 : 
; 4980 :     // PUK 0x4103 to xTokenCmConnection
; 4981 :     // The MPC_PUK should be followed by a single MPC_PUS, a type 0x0403.
; 4982 :     case ULP_DISABLE:
; 4983 : 
; 4984 :         // Display various information, maybe
; 4985 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00dbc	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00dc1	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00dc4	83 e0 10	 and	 eax, 16
  00dc7	85 c0		 test	 eax, eax
  00dc9	74 15		 je	 SHORT $LN59@write_rrh_

; 4986 :         {
; 4987 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (CmComm) PUK 0x4103 (ULP_DISABLE)" );

  00dcb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171819
  00dd2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00dda	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN59@write_rrh_:

; 4988 :         }
; 4989 : 
; 4990 :         break;

  00de0	e9 c5 03 00 00	 jmp	 $LN2@write_rrh_
$LN60@write_rrh_:

; 4991 : 
; 4992 :     // PUK 0x4105 to xTokenCmConnection
; 4993 :     // The MPC_PUK should be followed by a single MPC_PUS, a type 0x0404.
; 4994 :     case ULP_TAKEDOWN:
; 4995 : 
; 4996 :         // Display various information, maybe
; 4997 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00de5	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00dea	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00ded	83 e0 10	 and	 eax, 16
  00df0	85 c0		 test	 eax, eax
  00df2	74 15		 je	 SHORT $LN61@write_rrh_

; 4998 :         {
; 4999 :             mpc_display_description( pDEVBLK, "In RRH 0x417E (CmComm) PUK 0x4105 (ULP_TAKEDOWN)" );

  00df4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171822
  00dfb	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN61@write_rrh_:

; 5000 :         }
; 5001 : 
; 5002 :         // The guest OS on the y-side has stopped the device
; 5003 :         if (pPTPBLK->fActive4)

  00e09	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00e0e	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00e11	c1 e8 03	 shr	 eax, 3
  00e14	83 e0 01	 and	 eax, 1
  00e17	85 c0		 test	 eax, eax
  00e19	0f 84 a5 00 00
	00		 je	 $LN62@write_rrh_

; 5004 :         {
; 5005 :             // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 5006 :             WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00e1f	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00e24	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  00e2a	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv582[rsp], rax
  00e32	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e3a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00e3e	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv585[rsp], ecx
  00e45	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00e4d	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00e51	d1 fa		 sar	 edx, 1
  00e53	89 94 24 d4 00
	00 00		 mov	 DWORD PTR tv589[rsp], edx
  00e5a	b9 01 00 00 00	 mov	 ecx, 1
  00e5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e65	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv582[rsp]
  00e6d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e72	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv585[rsp]
  00e79	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e7d	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv589[rsp]
  00e84	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171824
  00e8f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171825
  00e9b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ea0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ea5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00eab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171826
  00eb2	ba 8f 13 00 00	 mov	 edx, 5007		; 0000138fH
  00eb7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171827
  00ebe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN62@write_rrh_:

; 5007 :                 pPTPBLK->szGuestIPAddr4 );
; 5008 :         }
; 5009 :         pPTPBLK->fActive4 = FALSE;

  00ec4	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ec9	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00ecc	83 e0 f7	 and	 eax, -9			; fffffff7H
  00ecf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00ed4	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 5010 :         pPTPBLK->bActivate4 = 0x00;

  00ed7	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00edc	c6 80 84 03 00
	00 00		 mov	 BYTE PTR [rax+900], 0

; 5011 :         pPTPBLK->bTerminate4 = 0x00;

  00ee3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ee8	c6 80 87 03 00
	00 00		 mov	 BYTE PTR [rax+903], 0

; 5012 : #if defined(ENABLE_IPV6)
; 5013 :         if (pPTPBLK->fActive6)

  00eef	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ef4	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00ef7	c1 e8 04	 shr	 eax, 4
  00efa	83 e0 01	 and	 eax, 1
  00efd	85 c0		 test	 eax, eax
  00eff	0f 84 a5 00 00
	00		 je	 $LN63@write_rrh_

; 5014 :         {
; 5015 :             // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 5016 :             WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00f05	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00f0a	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  00f10	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv609[rsp], rax
  00f18	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00f20	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00f24	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv612[rsp], ecx
  00f2b	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00f33	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00f37	d1 fa		 sar	 edx, 1
  00f39	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv616[rsp], edx
  00f40	b9 01 00 00 00	 mov	 ecx, 1
  00f45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f4b	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv609[rsp]
  00f53	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f58	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv612[rsp]
  00f5f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f63	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv616[rsp]
  00f6a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f6e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171829
  00f75	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f7a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171830
  00f81	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f86	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f8b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f91	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171831
  00f98	ba 99 13 00 00	 mov	 edx, 5017		; 00001399H
  00f9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171832
  00fa4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN63@write_rrh_:

; 5017 :                 pPTPBLK->szGuestIPAddr6 );
; 5018 :         }
; 5019 : #endif /* defined(ENABLE_IPV6) */
; 5020 :         pPTPBLK->fActive6 = FALSE;

  00faa	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00faf	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00fb2	83 e0 ef	 and	 eax, -17		; ffffffefH
  00fb5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00fba	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 5021 :         pPTPBLK->bActivate6 = 0x00;

  00fbd	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00fc2	c6 80 85 03 00
	00 00		 mov	 BYTE PTR [rax+901], 0

; 5022 :         pPTPBLK->bTerminate6 = 0x00;

  00fc9	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00fce	c6 80 88 03 00
	00 00		 mov	 BYTE PTR [rax+904], 0

; 5023 : #if defined(ENABLE_IPV6)
; 5024 :         if (pPTPBLK->fActiveLL6)

  00fd5	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00fda	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00fdd	c1 e8 05	 shr	 eax, 5
  00fe0	83 e0 01	 and	 eax, 1
  00fe3	85 c0		 test	 eax, eax
  00fe5	0f 84 a5 00 00
	00		 je	 $LN64@write_rrh_

; 5025 :         {
; 5026 :             // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 5027 :             WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00feb	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ff0	48 05 a0 02 00
	00		 add	 rax, 672		; 000002a0H
  00ff6	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv636[rsp], rax
  00ffe	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01006	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0100a	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR tv639[rsp], ecx
  01011	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01019	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0101d	d1 fa		 sar	 edx, 1
  0101f	89 94 24 e4 00
	00 00		 mov	 DWORD PTR tv675[rsp], edx
  01026	b9 01 00 00 00	 mov	 ecx, 1
  0102b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01031	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv636[rsp]
  01039	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0103e	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv639[rsp]
  01045	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01049	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv675[rsp]
  01050	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171834
  0105b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171835
  01067	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0106c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01071	41 b9 03 00 00
	00		 mov	 r9d, 3
  01077	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171836
  0107e	ba a4 13 00 00	 mov	 edx, 5028		; 000013a4H
  01083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171837
  0108a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN64@write_rrh_:

; 5028 :                 pPTPBLK->szGuestLLAddr6 );
; 5029 :         }
; 5030 : #endif /* defined(ENABLE_IPV6) */
; 5031 :         pPTPBLK->fActiveLL6 = FALSE;

  01090	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01095	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01098	83 e0 df	 and	 eax, -33		; ffffffdfH
  0109b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  010a0	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 5032 :         pPTPBLK->bActivateLL6 = 0x00;

  010a3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  010a8	c6 80 86 03 00
	00 00		 mov	 BYTE PTR [rax+902], 0

; 5033 :         pPTPBLK->bTerminateLL6 = 0x00;

  010af	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  010b4	c6 80 89 03 00
	00 00		 mov	 BYTE PTR [rax+905], 0

; 5034 :         // Dispose of any data waiting to be read by the y-side.
; 5035 :         // Free any PTPHDR on the chain for the read path
; 5036 :         remove_and_free_any_buffers_on_chain( pPTPATHre );

  010bb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  010c3	e8 00 00 00 00	 call	 remove_and_free_any_buffers_on_chain

; 5037 :         // Reset the message sequence number
; 5038 :         pPTPATHre->uSeqNum = 0;

  010c8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPATHre$[rsp]
  010d0	c7 40 42 00 00
	00 00		 mov	 DWORD PTR [rax+66], 0

; 5039 :         // Free any PTPHDR on the chain for the write path
; 5040 :         remove_and_free_any_buffers_on_chain( pPTPATHwr );

  010d7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pPTPATHwr$[rsp]
  010df	e8 00 00 00 00	 call	 remove_and_free_any_buffers_on_chain

; 5041 :         // Reset the message sequence number
; 5042 :         pPTPATHwr->uSeqNum = 0;

  010e4	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pPTPATHwr$[rsp]
  010ec	c7 40 42 00 00
	00 00		 mov	 DWORD PTR [rax+66], 0

; 5043 : 
; 5044 :         break;

  010f3	e9 b2 00 00 00	 jmp	 $LN2@write_rrh_
$LN65@write_rrh_:

; 5045 : 
; 5046 :     // Unknown PUK
; 5047 :     default:
; 5048 : 
; 5049 :         // HHC03936 "%1d:%04X PTP: Accept data contains unknown %s"
; 5050 :         WRMSG(HHC03936, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "PUK" );

  010f8	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01100	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01104	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv697[rsp], eax
  0110b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01113	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01117	d1 f9		 sar	 ecx, 1
  01119	89 8c 24 ec 00
	00 00		 mov	 DWORD PTR tv701[rsp], ecx
  01120	b9 01 00 00 00	 mov	 ecx, 1
  01125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0112b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171839
  01132	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01137	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv697[rsp]
  0113e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01142	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv701[rsp]
  01149	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0114d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171840
  01154	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171841
  01160	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01165	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0116a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01170	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171842
  01177	ba ba 13 00 00	 mov	 edx, 5050		; 000013baH
  0117c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171843
  01183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5051 :         mpc_display_rrh_and_puk( pDEVBLK, pMPC_THwr, pMPC_RRHwr, FROM_GUEST );

  01189	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0118c	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR pMPC_RRHwr$[rsp]
  01194	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR pMPC_THwr$[rsp]
  0119c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  011a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh_and_puk
$LN2@write_rrh_:

; 5052 : 
; 5053 :         break;
; 5054 : 
; 5055 :     }  /* switch( iWhat ) */
; 5056 : 
; 5057 : 
; 5058 :     return 0;

  011aa	33 c0		 xor	 eax, eax

; 5059 : }   /* End function  write_rrh_417E() */

  011ac	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  011b3	c3		 ret	 0
$LN67@write_rrh_:
  011b4	00 00 00 00	 DD	 $LN30@write_rrh_
  011b8	00 00 00 00	 DD	 $LN35@write_rrh_
  011bc	00 00 00 00	 DD	 $LN38@write_rrh_
  011c0	00 00 00 00	 DD	 $LN41@write_rrh_
  011c4	00 00 00 00	 DD	 $LN43@write_rrh_
  011c8	00 00 00 00	 DD	 $LN45@write_rrh_
  011cc	00 00 00 00	 DD	 $LN50@write_rrh_
  011d0	00 00 00 00	 DD	 $LN53@write_rrh_
  011d4	00 00 00 00	 DD	 $LN58@write_rrh_
  011d8	00 00 00 00	 DD	 $LN60@write_rrh_
  011dc	00 00 00 00	 DD	 $LN56@write_rrh_
write_rrh_417E ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pCurCv$ = 0
pPTPHSV$ = 8
pEndCv$ = 16
pDEVBLK$ = 48
pPTPHX2$ = 56
point_CSVcv PROC

; 4553 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@point_CSVc:

; 4554 : 
; 4555 :     PTPHSV*   pPTPHSV;
; 4556 :     BYTE*     pCurCv;
; 4557 :     BYTE*     pEndCv;
; 4558 : 
; 4559 :     UNREFERENCED( pDEVBLK );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@point_CSVc

; 4560 : 
; 4561 : 
; 4562 :     // Point to the first cv, point to the end of the cv's, and
; 4563 :     // work down the cv's until we find the CSVcv.
; 4564 :     pCurCv = (BYTE*)pPTPHX2 + pPTPHX2->LenXcv;

  00014	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPHX2$[rsp]
  00019	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPHX2$[rsp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 89 04 24	 mov	 QWORD PTR pCurCv$[rsp], rax

; 4565 :     pEndCv = (BYTE*)pPTPHX2 + pPTPHX2->Length;

  0002c	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPHX2$[rsp]
  00031	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00035	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPHX2$[rsp]
  0003a	48 03 c8	 add	 rcx, rax
  0003d	48 8b c1	 mov	 rax, rcx
  00040	48 89 44 24 10	 mov	 QWORD PTR pEndCv$[rsp], rax
$LN5@point_CSVc:

; 4566 : 
; 4567 :     while( pCurCv < pEndCv )

  00045	48 8b 44 24 10	 mov	 rax, QWORD PTR pEndCv$[rsp]
  0004a	48 39 04 24	 cmp	 QWORD PTR pCurCv$[rsp], rax
  0004e	73 3a		 jae	 SHORT $LN6@point_CSVc

; 4568 :     {
; 4569 :         pPTPHSV = (PTPHSV*)pCurCv;

  00050	48 8b 04 24	 mov	 rax, QWORD PTR pCurCv$[rsp]
  00054	48 89 44 24 08	 mov	 QWORD PTR pPTPHSV$[rsp], rax

; 4570 :         if (pPTPHSV->Key == CSV_KEY)

  00059	48 8b 44 24 08	 mov	 rax, QWORD PTR pPTPHSV$[rsp]
  0005e	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00062	83 f8 56	 cmp	 eax, 86			; 00000056H
  00065	75 02		 jne	 SHORT $LN7@point_CSVc

; 4571 :             break;

  00067	eb 21		 jmp	 SHORT $LN6@point_CSVc
$LN7@point_CSVc:

; 4572 :         pCurCv += pPTPHSV->Length;

  00069	48 8b 44 24 08	 mov	 rax, QWORD PTR pPTPHSV$[rsp]
  0006e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00071	48 8b 0c 24	 mov	 rcx, QWORD PTR pCurCv$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 04 24	 mov	 QWORD PTR pCurCv$[rsp], rax

; 4573 :         pPTPHSV = NULL;

  0007f	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR pPTPHSV$[rsp], 0

; 4574 :     }

  00088	eb bb		 jmp	 SHORT $LN5@point_CSVc
$LN6@point_CSVc:

; 4575 : 
; 4576 :     return pPTPHSV;

  0008a	48 8b 44 24 08	 mov	 rax, QWORD PTR pPTPHSV$[rsp]

; 4577 : }   /* End function  point_CSVcv() */

  0008f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00093	c3		 ret	 0
point_CSVcv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPBLK$ = 96
uMaxReadLen$ = 104
pPTPHX2re$ = 112
pPTPATH$ = 120
uDataLen1$ = 128
pPTPHDR$ = 136
pPTPHSVre$ = 144
pPTPHDRx0$ = 152
pPTPHDRx2$ = 160
pPTPHX2wr$ = 168
pMPC_TH$1 = 176
pPTPHX0re$ = 184
pPTPHDRvt$ = 192
pMPC_RRH$2 = 200
tv93 = 208
tv129 = 212
tv256 = 216
tv259 = 220
tv262 = 224
tv278 = 228
tv281 = 232
tv284 = 236
uNodeID$ = 240
pPTPVTMre$ = 248
pPTPHSVwr$ = 256
tv166 = 264
tv202 = 272
pDEVBLK$ = 304
uCount$ = 312
iCCWSeq$ = 320
pIOBuf$ = 328
pMore$ = 336
pUnitStat$ = 344
pResidual$ = 352
write_hx2 PROC

; 4241 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H

; 4242 : 
; 4243 :     PTPATH*    pPTPATH     = pDEVBLK->dev_data;

  0001b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00023	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0002a	48 89 44 24 78	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 4244 :     PTPBLK*    pPTPBLK     = pPTPATH->pPTPBLK;

  0002f	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 89 44 24 60	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 4245 :     PTPHX2*    pPTPHX2wr   = (PTPHX2*)pIOBuf;   // PTPHX2 being written

  0003c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  00044	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pPTPHX2wr$[rsp], rax

; 4246 :     PTPHSV*    pPTPHSVwr;                       // PTPHSV being written
; 4247 : 
; 4248 :     PTPHDR*    pPTPHDRx0   = NULL;              // PTPHDR before PTPHX0

  0004c	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pPTPHDRx0$[rsp], 0

; 4249 :     PTPHX0*    pPTPHX0re   = NULL;              // PTPHX0 to be read

  00058	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pPTPHX0re$[rsp], 0

; 4250 :     PTPHDR*    pPTPHDRx2   = NULL;              // PTPHDR before PTPHX2

  00064	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pPTPHDRx2$[rsp], 0

; 4251 :     PTPHX2*    pPTPHX2re   = NULL;              // PTPHX2 to be read

  00070	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR pPTPHX2re$[rsp], 0

; 4252 :     PTPHSV*    pPTPHSVre   = NULL;              // PTPHSV to be read

  00079	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pPTPHSVre$[rsp], 0

; 4253 :     PTPHDR*    pPTPHDRvt   = NULL;              // PTPHDR before 'VTAM'

  00085	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pPTPHDRvt$[rsp], 0

; 4254 :     BYTE*      pPTPVTMre   = NULL;              // 'VTAM' to be read

  00091	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pPTPVTMre$[rsp], 0
$LN4@write_hx2:

; 4255 : 
; 4256 :     U16        uDataLen1;                       // Data length one
; 4257 :     U16        uMaxReadLen;                     // Maximum read length
; 4258 :     PTPHDR*    pPTPHDR;                         // PTPHDR
; 4259 :     U32        uNodeID;
; 4260 : 
; 4261 :     UNREFERENCED( uCount  );

  0009d	33 c0		 xor	 eax, eax
  0009f	85 c0		 test	 eax, eax
  000a1	75 fa		 jne	 SHORT $LN4@write_hx2
$LN7@write_hx2:

; 4262 :     UNREFERENCED( iCCWSeq );

  000a3	33 c0		 xor	 eax, eax
  000a5	85 c0		 test	 eax, eax
  000a7	75 fa		 jne	 SHORT $LN7@write_hx2
$LN10@write_hx2:

; 4263 :     UNREFERENCED( pIOBuf  );

  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 fa		 jne	 SHORT $LN10@write_hx2

; 4264 : 
; 4265 : 
; 4266 :     // Display various information, maybe
; 4267 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  000af	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000b4	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  000b7	83 e0 10	 and	 eax, 16
  000ba	85 c0		 test	 eax, eax
  000bc	74 15		 je	 SHORT $LN11@write_hx2

; 4268 :     {
; 4269 :         mpc_display_description( pDEVBLK, "In HX2" );

  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171620
  000c5	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN11@write_hx2:

; 4270 :     }
; 4271 : 
; 4272 :     // Point to the CSVcv following the XID2.
; 4273 :     pPTPHSVwr = point_CSVcv( pDEVBLK, pPTPHX2wr );

  000d3	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pPTPHX2wr$[rsp]
  000db	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000e3	e8 00 00 00 00	 call	 point_CSVcv
  000e8	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR pPTPHSVwr$[rsp], rax

; 4274 : 
; 4275 :     // XID2's should only be written when handshaking is in progress.
; 4276 :     if (pPTPATH->fHandshaking)

  000f0	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000f5	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  000f9	24 01		 and	 al, 1
  000fb	0f b6 c0	 movzx	 eax, al
  000fe	85 c0		 test	 eax, eax
  00100	0f 84 4b 09 00
	00		 je	 $LN12@write_hx2

; 4277 :     {
; 4278 :         // An XID2 is being written by the y-side and handshaking is
; 4279 :         // in progress on the path; all is well with the world.
; 4280 : 
; 4281 :         // Copy the start time and token from the XID2.
; 4282 :         // Note: this section of code is executed twice, once for the read
; 4283 :         // path and once for the write path, though not necessarily in that
; 4284 :         // order. Whichever path executes the routine first will copy the
; 4285 :         // values.
; 4286 :         if (pPTPATH->fHandshakeCur == HANDSHAKE_ONE)

  00106	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0010b	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  0010f	83 f8 01	 cmp	 eax, 1
  00112	0f 85 55 05 00
	00		 jne	 $LN14@write_hx2

; 4287 :         {
; 4288 : 
; 4289 :             obtain_lock( &pPTPBLK->UpdateLock );

  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0011d	48 83 c0 60	 add	 rax, 96			; 00000060H
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171624
  00128	48 8b c8	 mov	 rcx, rax
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4290 : 
; 4291 :             if (pPTPHX2wr->DLCtype != pPTPATH->bDLCtype )  // XID2 from expected y-side's path?

  00131	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX2wr$[rsp]
  00139	0f b6 40 1e	 movzx	 eax, BYTE PTR [rax+30]
  0013d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00142	0f b6 49 41	 movzx	 ecx, BYTE PTR [rcx+65]
  00146	3b c1		 cmp	 eax, ecx
  00148	0f 84 85 00 00
	00		 je	 $LN15@write_hx2

; 4292 :             {
; 4293 :                 // HHC03917 "%1d:%04X PTP: Guest read and write paths mis-configured"
; 4294 :                 WRMSG(HHC03917, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum );

  0014e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00156	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0015a	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv93[rsp], eax
  00161	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00169	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0016d	d1 f9		 sar	 ecx, 1
  0016f	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv129[rsp], ecx
  00176	b9 01 00 00 00	 mov	 ecx, 1
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00181	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv93[rsp]
  00188	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0018c	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv129[rsp]
  00193	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171626
  0019e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171627
  001aa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171628
  001c1	ba c6 10 00 00	 mov	 edx, 4294		; 000010c6H
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171629
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@write_hx2:

; 4295 :             }
; 4296 : 
; 4297 :             if (pPTPBLK->yTokensCopied == 0)

  001d3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001d8	0f b6 80 5f 03
	00 00		 movzx	 eax, BYTE PTR [rax+863]
  001df	85 c0		 test	 eax, eax
  001e1	75 7b		 jne	 SHORT $LN16@write_hx2

; 4298 :             {
; 4299 : 
; 4300 :                 pPTPBLK->yTokensCopied = 1;

  001e3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001e8	c6 80 5f 03 00
	00 01		 mov	 BYTE PTR [rax+863], 1

; 4301 :                 memcpy( pPTPBLK->yTokenIssuerRm, pPTPHX2wr->Token, MPC_TOKEN_LENGTH );

  001ef	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001f4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pPTPHX2wr$[rsp]
  001fc	8b 49 26	 mov	 ecx, DWORD PTR [rcx+38]
  001ff	89 88 60 03 00
	00		 mov	 DWORD PTR [rax+864], ecx

; 4302 :                 memcpy( pPTPBLK->yStartTime, pPTPHSVwr->SID1, 8 );

  00205	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0020a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR pPTPHSVwr$[rsp]
  00212	48 8b 49 04	 mov	 rcx, QWORD PTR [rcx+4]
  00216	48 89 88 57 03
	00 00		 mov	 QWORD PTR [rax+855], rcx

; 4303 : 
; 4304 :                 gen_csv_sid( pPTPBLK->yStartTime, pPTPBLK->xStartTime,

  0021d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00222	48 05 34 03 00
	00		 add	 rax, 820		; 00000334H
  00228	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0022d	48 81 c1 24 03
	00 00		 add	 rcx, 804		; 00000324H
  00234	48 8b 54 24 60	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  00239	48 81 c2 57 03
	00 00		 add	 rdx, 855		; 00000357H
  00240	48 89 94 24 08
	01 00 00	 mov	 QWORD PTR tv166[rsp], rdx
  00248	4c 8b c0	 mov	 r8, rax
  0024b	48 8b d1	 mov	 rdx, rcx
  0024e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv166[rsp]
  00256	48 8b c8	 mov	 rcx, rax
  00259	e8 00 00 00 00	 call	 gen_csv_sid
$LN16@write_hx2:

; 4305 :                              pPTPBLK->xSecondCsvSID2 );
; 4306 : 
; 4307 :             }
; 4308 : 
; 4309 :             if (pPTPHX2wr->DLCtype == DLCTYPE_READ)              // XID2 from y-side's Read path?

  0025e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX2wr$[rsp]
  00266	0f b6 40 1e	 movzx	 eax, BYTE PTR [rax+30]
  0026a	83 f8 05	 cmp	 eax, 5
  0026d	0f 85 e1 03 00
	00		 jne	 $LN17@write_hx2

; 4310 :             {
; 4311 :                 // Extract the data lengths from the XID2.
; 4312 :                 FETCH_HW( uDataLen1, pPTPHX2wr->DataLen1 );      // Get y-side's data length one

  00273	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX2wr$[rsp]
  0027b	48 83 c0 1f	 add	 rax, 31
  0027f	48 8b c8	 mov	 rcx, rax
  00282	e8 00 00 00 00	 call	 fetch_hw_noswap
  00287	0f b7 c8	 movzx	 ecx, ax
  0028a	e8 00 00 00 00	 call	 _byteswap_ushort
  0028f	66 89 84 24 80
	00 00 00	 mov	 WORD PTR uDataLen1$[rsp], ax

; 4313 :                 FETCH_HW( uMaxReadLen, pPTPHX2wr->MaxReadLen );  // Get y-side's maximum read length

  00297	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX2wr$[rsp]
  0029f	48 83 c0 23	 add	 rax, 35			; 00000023H
  002a3	48 8b c8	 mov	 rcx, rax
  002a6	e8 00 00 00 00	 call	 fetch_hw_noswap
  002ab	0f b7 c8	 movzx	 ecx, ax
  002ae	e8 00 00 00 00	 call	 _byteswap_ushort
  002b3	66 89 44 24 68	 mov	 WORD PTR uMaxReadLen$[rsp], ax

; 4314 : 
; 4315 :                 // Obtain the read buffer lock.
; 4316 :                 obtain_lock( &pPTPBLK->ReadBufferLock );

  002b8	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002bd	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  002c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171632
  002c8	48 8b c8	 mov	 rcx, rax
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4317 : 
; 4318 :                 // Point to the read buffer.
; 4319 :                 pPTPHDR = pPTPBLK->pReadBuffer;

  002d1	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002d6	48 8b 40 34	 mov	 rax, QWORD PTR [rax+52]
  002da	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pPTPHDR$[rsp], rax

; 4320 :                 pPTPBLK->pReadBuffer = NULL;

  002e2	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002e7	48 c7 40 34 00
	00 00 00	 mov	 QWORD PTR [rax+52], 0

; 4321 : 
; 4322 :                 // Replace the existing read buffer if necessary.
; 4323 :                 // (This is the buffer into which we place packets
; 4324 :                 // received from the TUN interface, and from which
; 4325 :                 // the y-side's read path reads the packets.)
; 4326 :                 if (pPTPBLK->yMaxReadLen != uMaxReadLen)

  002ef	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002f4	0f b7 80 76 03
	00 00		 movzx	 eax, WORD PTR [rax+886]
  002fb	0f b7 4c 24 68	 movzx	 ecx, WORD PTR uMaxReadLen$[rsp]
  00300	3b c1		 cmp	 eax, ecx
  00302	74 35		 je	 SHORT $LN18@write_hx2

; 4327 :                 {
; 4328 :                     // Free the existing read buffer, if there is one.
; 4329 :                     if (pPTPHDR)

  00304	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  0030d	74 0e		 je	 SHORT $LN19@write_hx2

; 4330 :                         free( pPTPHDR );

  0030f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN19@write_hx2:

; 4331 : 
; 4332 :                     // Allocate a new read buffer.
; 4333 :                     pPTPHDR = alloc_ptp_buffer( pDEVBLK, (int)uMaxReadLen );

  0031d	0f b7 44 24 68	 movzx	 eax, WORD PTR uMaxReadLen$[rsp]
  00322	8b d0		 mov	 edx, eax
  00324	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0032c	e8 00 00 00 00	 call	 alloc_ptp_buffer
  00331	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pPTPHDR$[rsp], rax
$LN18@write_hx2:

; 4334 :                 }
; 4335 : 
; 4336 :                 // Initialize the existing or new read buffer, if there is one.
; 4337 :                 if (pPTPHDR)

  00339	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  00342	0f 84 2c 01 00
	00		 je	 $LN20@write_hx2

; 4338 :                 {
; 4339 :                     MPC_TH*    pMPC_TH;        // MPC_TH follows the PTPHDR
; 4340 :                     MPC_RRH*   pMPC_RRH;       // MPC_RRH follows the MPC_TH
; 4341 : //                  MPC_PH*    pMPC_PH;        // MPC_PH follows the MPC_RRH
; 4342 : 
; 4343 :                     // Fix-up various pointers
; 4344 :                     pMPC_TH = (MPC_TH*)((BYTE*)pPTPHDR + SIZE_HDR);

  00348	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00350	48 83 c0 10	 add	 rax, 16
  00354	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pMPC_TH$1[rsp], rax

; 4345 :                     pMPC_RRH = (MPC_RRH*)((BYTE*)pMPC_TH + SIZE_TH);

  0035c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMPC_TH$1[rsp]
  00364	48 83 c0 14	 add	 rax, 20
  00368	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pMPC_RRH$2[rsp], rax

; 4346 : //                  pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + SIZE_RRH);
; 4347 : 
; 4348 :                     // Prepare PTPHDR
; 4349 :                     pPTPHDR->iDataLen = LEN_OF_PAGE_ONE;

  00370	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00378	c7 40 0c fc 0f
	00 00		 mov	 DWORD PTR [rax+12], 4092 ; 00000ffcH

; 4350 : 
; 4351 :                     // Clear the data area.
; 4352 :                     memset( pMPC_TH, 0, (int)uMaxReadLen );

  0037f	0f b7 44 24 68	 movzx	 eax, WORD PTR uMaxReadLen$[rsp]
  00384	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv202[rsp], rax
  0038c	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR pMPC_TH$1[rsp]
  00394	33 c0		 xor	 eax, eax
  00396	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv202[rsp]
  0039e	f3 aa		 rep stosb

; 4353 : 
; 4354 :                     // Prepare MPC_TH
; 4355 :                     STORE_FW( pMPC_TH->first4, MPC_TH_FIRST4 );

  003a0	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  003a5	e8 00 00 00 00	 call	 _byteswap_ulong
  003aa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMPC_TH$1[rsp]
  003b2	8b d0		 mov	 edx, eax
  003b4	e8 00 00 00 00	 call	 store_fw_noswap

; 4356 :                     STORE_FW( pMPC_TH->offrrh, SIZE_TH );

  003b9	b9 14 00 00 00	 mov	 ecx, 20
  003be	e8 00 00 00 00	 call	 _byteswap_ulong
  003c3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMPC_TH$1[rsp]
  003cb	48 83 c1 08	 add	 rcx, 8
  003cf	8b d0		 mov	 edx, eax
  003d1	e8 00 00 00 00	 call	 store_fw_noswap

; 4357 :                     STORE_HW( pMPC_TH->unknown10, MPC_TH_UNKNOWN10 );    // !!! //

  003d6	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  003da	e8 00 00 00 00	 call	 _byteswap_ushort
  003df	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMPC_TH$1[rsp]
  003e7	48 83 c1 10	 add	 rcx, 16
  003eb	0f b7 d0	 movzx	 edx, ax
  003ee	e8 00 00 00 00	 call	 store_hw_noswap

; 4358 :                     STORE_HW( pMPC_TH->numrrh, 1 );

  003f3	66 b9 01 00	 mov	 cx, 1
  003f7	e8 00 00 00 00	 call	 _byteswap_ushort
  003fc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMPC_TH$1[rsp]
  00404	48 83 c1 12	 add	 rcx, 18
  00408	0f b7 d0	 movzx	 edx, ax
  0040b	e8 00 00 00 00	 call	 store_hw_noswap

; 4359 : 
; 4360 :                     // Prepare MPC_RRH
; 4361 :                     pMPC_RRH->type = RRH_TYPE_CM;

  00410	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRH$2[rsp]
  00418	c6 40 04 81	 mov	 BYTE PTR [rax+4], 129	; 00000081H

; 4362 :                     pMPC_RRH->proto = PROTOCOL_LAYER2;

  0041c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRH$2[rsp]
  00424	c6 40 05 08	 mov	 BYTE PTR [rax+5], 8

; 4363 :                     STORE_HW( pMPC_RRH->numph, 1 );

  00428	66 b9 01 00	 mov	 cx, 1
  0042c	e8 00 00 00 00	 call	 _byteswap_ushort
  00431	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$2[rsp]
  00439	48 83 c1 06	 add	 rcx, 6
  0043d	0f b7 d0	 movzx	 edx, ax
  00440	e8 00 00 00 00	 call	 store_hw_noswap

; 4364 :                     STORE_HW( pMPC_RRH->offph, SIZE_RRH );

  00445	66 b9 24 00	 mov	 cx, 36			; 00000024H
  00449	e8 00 00 00 00	 call	 _byteswap_ushort
  0044e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$2[rsp]
  00456	48 83 c1 10	 add	 rcx, 16
  0045a	0f b7 d0	 movzx	 edx, ax
  0045d	e8 00 00 00 00	 call	 store_hw_noswap

; 4365 : 
; 4366 :                     // Prepare MPC_PH
; 4367 : 
; 4368 :                     // increment the read buffer generation number
; 4369 :                     pPTPBLK->iReadBufferGen++;

  00462	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00467	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0046a	ff c0		 inc	 eax
  0046c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00471	89 41 3c	 mov	 DWORD PTR [rcx+60], eax
$LN20@write_hx2:

; 4370 :                 }
; 4371 : 
; 4372 :                 // Set the pointer to the read buffer.
; 4373 :                 pPTPBLK->pReadBuffer = pPTPHDR;

  00474	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00479	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00481	48 89 48 34	 mov	 QWORD PTR [rax+52], rcx

; 4374 : 
; 4375 :                 // Release the read buffer lock.
; 4376 :                 release_lock( &pPTPBLK->ReadBufferLock );

  00485	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0048a	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0048e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171636
  00495	48 8b c8	 mov	 rcx, rax
  00498	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4377 : 
; 4378 :                 // Copy the data lengths extracted from the XID2.
; 4379 :                 pPTPBLK->yDataLen1 = uDataLen1;

  0049e	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004a3	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR uDataLen1$[rsp]
  004ab	66 89 88 74 03
	00 00		 mov	 WORD PTR [rax+884], cx

; 4380 :                 pPTPBLK->yMaxReadLen = uMaxReadLen;

  004b2	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004b7	0f b7 4c 24 68	 movzx	 ecx, WORD PTR uMaxReadLen$[rsp]
  004bc	66 89 88 76 03
	00 00		 mov	 WORD PTR [rax+886], cx

; 4381 :                 pPTPBLK->yActMTU = ( pPTPBLK->yMaxReadLen - pPTPBLK->yDataLen1 ) - 2048;

  004c3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004c8	0f b7 80 76 03
	00 00		 movzx	 eax, WORD PTR [rax+886]
  004cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  004d4	0f b7 89 74 03
	00 00		 movzx	 ecx, WORD PTR [rcx+884]
  004db	2b c1		 sub	 eax, ecx
  004dd	2d 00 08 00 00	 sub	 eax, 2048		; 00000800H
  004e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  004e7	66 89 81 78 03
	00 00		 mov	 WORD PTR [rcx+888], ax

; 4382 : 
; 4383 :                 // An MPCPTP/MPCPTP6 connection uses an MTU that is the  smaller of
; 4384 :                 // a) the MTU specified on a route statement, or b) the MTU calculated
; 4385 :                 // from the maximum read length reported by the other side during
; 4386 :                 // handshaking. For example, if the x-side's TRLE definition is using
; 4387 :                 // the default MAXBFRU value of 5, the maximum read length reported
; 4388 :                 // by the x-side to the y-side will be 20476 (0x4FFC) bytes, from
; 4389 :                 // which both sides will calculate an MTU of 14336 (0x3800) bytes.
; 4390 :                 // If the y-side has a route statement that specifies an MTU of 24576
; 4391 :                 // (0x6000) bytes, the specified MTU is ignored and the calculated MTU
; 4392 :                 // will be used. Depending on the values specified for MAXBFRU and for
; 4393 :                 // route statements, the MTU in use from the x-side to the y-side
; 4394 :                 // could be different to the MTU in use from the y-side to the x-side.
; 4395 :                 // For a real MPCPTP/MPCPTP6 connection this is probably a good thing,
; 4396 :                 // with the maximum capacity in each direction automatically used.
; 4397 :                 // However, for this emulated MPCPTP/MPCPTP6 connection this could be
; 4398 :                 // a bad thing because we are not processing the packets, we are simply
; 4399 :                 // forwarding them, and we may be forwarding them to something that is
; 4400 :                 // using a smaller MTU.
; 4401 : 
; 4402 :                 // HHC03910 "%1d:%04X PTP: Hercules has maximum read length of size %d bytes and actual MTU of size %d bytes"
; 4403 :                 WRMSG(HHC03910, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  004ee	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004f3	0f b7 80 55 03
	00 00		 movzx	 eax, WORD PTR [rax+853]
  004fa	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv256[rsp], eax
  00501	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00506	0f b7 89 53 03
	00 00		 movzx	 ecx, WORD PTR [rcx+851]
  0050d	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv259[rsp], ecx
  00514	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0051c	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00520	89 94 24 e0 00
	00 00		 mov	 DWORD PTR tv262[rsp], edx
  00527	48 8b bc 24 30
	01 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  0052f	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00533	d1 ff		 sar	 edi, 1
  00535	b9 01 00 00 00	 mov	 ecx, 1
  0053a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00540	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv256[rsp]
  00547	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0054b	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv259[rsp]
  00552	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00556	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv262[rsp]
  0055d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00561	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00565	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171637
  0056c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00571	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171638
  00578	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0057d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00582	41 b9 03 00 00
	00		 mov	 r9d, 3
  00588	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171639
  0058f	ba 34 11 00 00	 mov	 edx, 4404		; 00001134H
  00594	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171640
  0059b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4404 :                                      (int)pPTPBLK->xMaxReadLen, (int)pPTPBLK->xActMTU );
; 4405 :                 // HHC03911 "%1d:%04X PTP: Guest has maximum read length of size %d bytes and actual MTU of size %d bytes"
; 4406 :                 WRMSG(HHC03911, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  005a1	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005a6	0f b7 80 78 03
	00 00		 movzx	 eax, WORD PTR [rax+888]
  005ad	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv278[rsp], eax
  005b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  005b9	0f b7 89 76 03
	00 00		 movzx	 ecx, WORD PTR [rcx+886]
  005c0	89 8c 24 e8 00
	00 00		 mov	 DWORD PTR tv281[rsp], ecx
  005c7	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  005cf	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  005d3	89 94 24 ec 00
	00 00		 mov	 DWORD PTR tv284[rsp], edx
  005da	48 8b bc 24 30
	01 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  005e2	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  005e6	d1 ff		 sar	 edi, 1
  005e8	b9 01 00 00 00	 mov	 ecx, 1
  005ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005f3	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv278[rsp]
  005fa	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  005fe	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  00605	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00609	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv284[rsp]
  00610	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00614	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00618	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171641
  0061f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00624	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171642
  0062b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00630	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00635	41 b9 03 00 00
	00		 mov	 r9d, 3
  0063b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171643
  00642	ba 37 11 00 00	 mov	 edx, 4407		; 00001137H
  00647	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171644
  0064e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@write_hx2:

; 4407 :                                      (int)pPTPBLK->yMaxReadLen, (int)pPTPBLK->yActMTU );
; 4408 : 
; 4409 :             }
; 4410 : 
; 4411 :             release_lock( &pPTPBLK->UpdateLock );

  00654	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00659	48 83 c0 60	 add	 rax, 96			; 00000060H
  0065d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171645
  00664	48 8b c8	 mov	 rcx, rax
  00667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN14@write_hx2:

; 4412 : 
; 4413 :         }
; 4414 : 
; 4415 :         // Allocate a buffer in which the PTPHX0 will be build.
; 4416 :         pPTPHDRx0 = alloc_ptp_buffer( pDEVBLK, SIZE_HX0 );

  0066d	ba 08 00 00 00	 mov	 edx, 8
  00672	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0067a	e8 00 00 00 00	 call	 alloc_ptp_buffer
  0067f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pPTPHDRx0$[rsp], rax

; 4417 :         if (!pPTPHDRx0)

  00687	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pPTPHDRx0$[rsp], 0
  00690	75 05		 jne	 SHORT $LN21@write_hx2

; 4418 :             return;

  00692	e9 de 03 00 00	 jmp	 $LN1@write_hx2
$LN21@write_hx2:

; 4419 :         pPTPHX0re = (PTPHX0*)((BYTE*)pPTPHDRx0 + SIZE_HDR);

  00697	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPHDRx0$[rsp]
  0069f	48 83 c0 10	 add	 rax, 16
  006a3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pPTPHX0re$[rsp], rax

; 4420 : 
; 4421 :         // Allocate a buffer in which the PTPHX2 and PTPHSV will be build.
; 4422 :         pPTPHDRx2 = alloc_ptp_buffer( pDEVBLK, 255 );

  006ab	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  006b0	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006b8	e8 00 00 00 00	 call	 alloc_ptp_buffer
  006bd	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pPTPHDRx2$[rsp], rax

; 4423 :         if (!pPTPHDRx2)

  006c5	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pPTPHDRx2$[rsp], 0
  006ce	75 13		 jne	 SHORT $LN22@write_hx2

; 4424 :         {
; 4425 :             // Free the PTPHDR
; 4426 :             free( pPTPHDRx0 );

  006d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pPTPHDRx0$[rsp]
  006d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4427 :             return;

  006de	e9 92 03 00 00	 jmp	 $LN1@write_hx2
$LN22@write_hx2:

; 4428 :         }
; 4429 :         pPTPHX2re = (PTPHX2*)((BYTE*)pPTPHDRx2 + SIZE_HDR);

  006e3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pPTPHDRx2$[rsp]
  006eb	48 83 c0 10	 add	 rax, 16
  006ef	48 89 44 24 70	 mov	 QWORD PTR pPTPHX2re$[rsp], rax

; 4430 :         pPTPHSVre = (PTPHSV*)((BYTE*)pPTPHDRx2 + SIZE_HDR + SIZE_HX2);

  006f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pPTPHDRx2$[rsp]
  006fc	48 83 c0 41	 add	 rax, 65			; 00000041H
  00700	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pPTPHSVre$[rsp], rax

; 4431 : 
; 4432 :         // Allocate a buffer in which the literal 'VTAM' will be build.
; 4433 :         pPTPHDRvt = alloc_ptp_buffer( pDEVBLK, 4 );

  00708	ba 04 00 00 00	 mov	 edx, 4
  0070d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00715	e8 00 00 00 00	 call	 alloc_ptp_buffer
  0071a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pPTPHDRvt$[rsp], rax

; 4434 :         if (!pPTPHDRvt)

  00722	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR pPTPHDRvt$[rsp], 0
  0072b	75 21		 jne	 SHORT $LN23@write_hx2

; 4435 :         {
; 4436 :             // Free the PTPHDRs
; 4437 :             free( pPTPHDRx2 );

  0072d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pPTPHDRx2$[rsp]
  00735	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4438 :             free( pPTPHDRx0 );

  0073b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pPTPHDRx0$[rsp]
  00743	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4439 :             return;

  00749	e9 27 03 00 00	 jmp	 $LN1@write_hx2
$LN23@write_hx2:

; 4440 :         }
; 4441 :         pPTPVTMre = (BYTE*)pPTPHDRvt + SIZE_HDR;

  0074e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pPTPHDRvt$[rsp]
  00756	48 83 c0 10	 add	 rax, 16
  0075a	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR pPTPVTMre$[rsp], rax

; 4442 : 
; 4443 :         // Prepare PTPHDRx0 and PTPHX0re
; 4444 :         pPTPHDRx0->iDataLen = SIZE_HX0;

  00762	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPHDRx0$[rsp]
  0076a	c7 40 0c 08 00
	00 00		 mov	 DWORD PTR [rax+12], 8

; 4445 :         // PTPHX0
; 4446 :         if (pPTPATH->fHandshakeCur == HANDSHAKE_ONE ||

  00771	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00776	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  0077a	83 f8 01	 cmp	 eax, 1
  0077d	74 0e		 je	 SHORT $LN26@write_hx2
  0077f	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00784	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  00788	83 f8 02	 cmp	 eax, 2
  0078b	75 0e		 jne	 SHORT $LN24@write_hx2
$LN26@write_hx2:

; 4447 :             pPTPATH->fHandshakeCur == HANDSHAKE_TWO)
; 4448 :         {
; 4449 :             pPTPHX0re->TH_ch_flag = TH_CH_0x01;

  0078d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX0re$[rsp]
  00795	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 4450 :         }

  00799	eb 0c		 jmp	 SHORT $LN25@write_hx2
$LN24@write_hx2:

; 4451 :         else
; 4452 :         {
; 4453 :             pPTPHX0re->TH_ch_flag = TH_CH_0x00;

  0079b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX0re$[rsp]
  007a3	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
$LN25@write_hx2:

; 4454 :         }
; 4455 :         pPTPHX0re->TH_blk_flag = TH_DATA_IS_XID;

  007a7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX0re$[rsp]
  007af	c6 40 02 80	 mov	 BYTE PTR [rax+2], 128	; 00000080H

; 4456 :         pPTPHX0re->TH_is_xid = TH_IS_0x01;

  007b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX0re$[rsp]
  007bb	c6 40 03 01	 mov	 BYTE PTR [rax+3], 1

; 4457 :         STORE_FW( pPTPHX0re->TH_SeqNum, PTPHX0_SEQNUM );      // !!! //

  007bf	b9 10 00 05 00	 mov	 ecx, 327696		; 00050010H
  007c4	e8 00 00 00 00	 call	 _byteswap_ulong
  007c9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pPTPHX0re$[rsp]
  007d1	48 83 c1 04	 add	 rcx, 4
  007d5	8b d0		 mov	 edx, eax
  007d7	e8 00 00 00 00	 call	 store_fw_noswap

; 4458 : 
; 4459 :         // Prepare PTPHDRx2 PTPHX2re and PTPHSVre
; 4460 :         pPTPHDRx2->iDataLen = 255;

  007dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pPTPHDRx2$[rsp]
  007e4	c7 40 0c ff 00
	00 00		 mov	 DWORD PTR [rax+12], 255	; 000000ffH

; 4461 :         // XID2
; 4462 :         pPTPHX2re->Ft = 0x20;

  007eb	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  007f0	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 4463 :         pPTPHX2re->Length = SIZE_HX2 + SIZE_HSV;

  007f3	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  007f8	c6 40 01 45	 mov	 BYTE PTR [rax+1], 69	; 00000045H

; 4464 :         uNodeID = ( sysblk.cpuid >> 36 ) | 0xFFF00000;

  007fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00803	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0080a	48 c1 e8 24	 shr	 rax, 36			; 00000024H
  0080e	b9 00 00 f0 ff	 mov	 ecx, -1048576		; fff00000H
  00813	48 0b c1	 or	 rax, rcx
  00816	89 84 24 f0 00
	00 00		 mov	 DWORD PTR uNodeID$[rsp], eax

; 4465 :         STORE_FW( pPTPHX2re->NodeID, uNodeID );

  0081d	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR uNodeID$[rsp]
  00824	e8 00 00 00 00	 call	 _byteswap_ulong
  00829	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPHX2re$[rsp]
  0082e	48 83 c1 02	 add	 rcx, 2
  00832	8b d0		 mov	 edx, eax
  00834	e8 00 00 00 00	 call	 store_fw_noswap

; 4466 :         pPTPHX2re->LenXcv = SIZE_HX2;

  00839	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  0083e	c6 40 06 31	 mov	 BYTE PTR [rax+6], 49	; 00000031H

; 4467 :         pPTPHX2re->ULPuse = 0x80;

  00842	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  00847	c6 40 0a 80	 mov	 BYTE PTR [rax+10], 128	; 00000080H

; 4468 :         memcpy( pPTPHX2re->SAaddress, pPTPBLK->xSAaddress, 4 );

  0084b	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  00850	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00855	8b 89 20 03 00
	00		 mov	 ecx, DWORD PTR [rcx+800]
  0085b	89 48 0e	 mov	 DWORD PTR [rax+14], ecx

; 4469 :         if (pPTPATH->fHandshakeCur != HANDSHAKE_ONE)

  0085e	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00863	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  00867	83 f8 01	 cmp	 eax, 1
  0086a	74 09		 je	 SHORT $LN27@write_hx2

; 4470 :         {
; 4471 :             pPTPHX2re->CLstatus = 0x07;

  0086c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  00871	c6 40 13 07	 mov	 BYTE PTR [rax+19], 7
$LN27@write_hx2:

; 4472 :         }
; 4473 :         if (pPTPATH->bDLCtype == DLCTYPE_WRITE)         // Destined for the y-side's Write path?

  00875	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0087a	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0087e	83 f8 04	 cmp	 eax, 4
  00881	75 0b		 jne	 SHORT $LN28@write_hx2

; 4474 :         {
; 4475 :             pPTPHX2re->DLCtype = DLCTYPE_READ;          // This XID2 is from x-side's Read path

  00883	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  00888	c6 40 1e 05	 mov	 BYTE PTR [rax+30], 5

; 4476 :         }

  0088c	eb 09		 jmp	 SHORT $LN29@write_hx2
$LN28@write_hx2:

; 4477 :         else
; 4478 :         {
; 4479 :             pPTPHX2re->DLCtype = DLCTYPE_WRITE;         // This XID2 is from x-side's Write path

  0088e	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  00893	c6 40 1e 04	 mov	 BYTE PTR [rax+30], 4
$LN29@write_hx2:

; 4480 :         }
; 4481 :         if (pPTPATH->fHandshakeCur == HANDSHAKE_ONE &&  // The first exchange of handshaking and

  00897	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0089c	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  008a0	83 f8 01	 cmp	 eax, 1
  008a3	75 52		 jne	 SHORT $LN30@write_hx2
  008a5	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  008aa	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  008ae	83 f8 04	 cmp	 eax, 4
  008b1	75 44		 jne	 SHORT $LN30@write_hx2

; 4482 :             pPTPATH->bDLCtype == DLCTYPE_WRITE)         // destined for the y-side's Write path?
; 4483 :         {
; 4484 :             STORE_HW( pPTPHX2re->DataLen1, pPTPBLK->xDataLen1 );

  008b3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  008b8	0f b7 88 51 03
	00 00		 movzx	 ecx, WORD PTR [rax+849]
  008bf	e8 00 00 00 00	 call	 _byteswap_ushort
  008c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPHX2re$[rsp]
  008c9	48 83 c1 1f	 add	 rcx, 31
  008cd	0f b7 d0	 movzx	 edx, ax
  008d0	e8 00 00 00 00	 call	 store_hw_noswap

; 4485 :             STORE_HW( pPTPHX2re->MaxReadLen, pPTPBLK->xMaxReadLen );

  008d5	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  008da	0f b7 88 53 03
	00 00		 movzx	 ecx, WORD PTR [rax+851]
  008e1	e8 00 00 00 00	 call	 _byteswap_ushort
  008e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPHX2re$[rsp]
  008eb	48 83 c1 23	 add	 rcx, 35			; 00000023H
  008ef	0f b7 d0	 movzx	 edx, ax
  008f2	e8 00 00 00 00	 call	 store_hw_noswap
$LN30@write_hx2:

; 4486 :         }
; 4487 :         pPTPHX2re->MpcFlag = 0x27;

  008f7	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  008fc	c6 40 21 27	 mov	 BYTE PTR [rax+33], 39	; 00000027H

; 4488 :         if (pPTPATH->fHandshakeCur == HANDSHAKE_ONE)

  00900	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00905	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  00909	83 f8 01	 cmp	 eax, 1
  0090c	75 1e		 jne	 SHORT $LN31@write_hx2

; 4489 :         {
; 4490 :             pPTPHX2re->TokenX5 = MPC_TOKEN_X5;

  0090e	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  00913	c6 40 25 05	 mov	 BYTE PTR [rax+37], 5

; 4491 :             memcpy( pPTPHX2re->Token, pPTPBLK->xTokenIssuerRm, MPC_TOKEN_LENGTH );

  00917	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  0091c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00921	8b 89 3d 03 00
	00		 mov	 ecx, DWORD PTR [rcx+829]
  00927	89 48 26	 mov	 DWORD PTR [rax+38], ecx

; 4492 :         }

  0092a	eb 1c		 jmp	 SHORT $LN32@write_hx2
$LN31@write_hx2:

; 4493 :         else
; 4494 :         {
; 4495 :             pPTPHX2re->TokenX5 = MPC_TOKEN_X5;

  0092c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  00931	c6 40 25 05	 mov	 BYTE PTR [rax+37], 5

; 4496 :             memcpy( pPTPHX2re->Token, pPTPBLK->yTokenIssuerRm, MPC_TOKEN_LENGTH );

  00935	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPHX2re$[rsp]
  0093a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0093f	8b 89 60 03 00
	00		 mov	 ecx, DWORD PTR [rcx+864]
  00945	89 48 26	 mov	 DWORD PTR [rax+38], ecx
$LN32@write_hx2:

; 4497 :         }
; 4498 :         // CSVcv
; 4499 :         pPTPHSVre->Length = SIZE_HSV;

  00948	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPHSVre$[rsp]
  00950	c6 00 14	 mov	 BYTE PTR [rax], 20

; 4500 :         pPTPHSVre->Key = CSV_KEY;

  00953	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPHSVre$[rsp]
  0095b	c6 40 01 56	 mov	 BYTE PTR [rax+1], 86	; 00000056H

; 4501 :         pPTPHSVre->LenSIDs = sizeof(pPTPHSVre->LenSIDs) +

  0095f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPHSVre$[rsp]
  00967	c6 40 03 11	 mov	 BYTE PTR [rax+3], 17

; 4502 :                               sizeof(pPTPHSVre->SID1) + sizeof(pPTPHSVre->SID2);
; 4503 :         memcpy( pPTPHSVre->SID1, &pPTPBLK->xStartTime, 8 );  // x-side's start time

  0096b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPHSVre$[rsp]
  00973	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00978	48 8b 89 24 03
	00 00		 mov	 rcx, QWORD PTR [rcx+804]
  0097f	48 89 48 04	 mov	 QWORD PTR [rax+4], rcx

; 4504 :         if (pPTPATH->fHandshakeCur == HANDSHAKE_ONE)

  00983	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00988	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  0098c	83 f8 01	 cmp	 eax, 1
  0098f	75 1a		 jne	 SHORT $LN33@write_hx2

; 4505 :         {
; 4506 :             memcpy( pPTPHSVre->SID2, &pPTPBLK->xFirstCsvSID2, 8 );

  00991	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPHSVre$[rsp]
  00999	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0099e	48 8b 89 2c 03
	00 00		 mov	 rcx, QWORD PTR [rcx+812]
  009a5	48 89 48 0c	 mov	 QWORD PTR [rax+12], rcx

; 4507 :         }

  009a9	eb 18		 jmp	 SHORT $LN34@write_hx2
$LN33@write_hx2:

; 4508 :         else
; 4509 :         {
; 4510 :             memcpy( pPTPHSVre->SID2, &pPTPBLK->xSecondCsvSID2, 8 );

  009ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPHSVre$[rsp]
  009b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  009b8	48 8b 89 34 03
	00 00		 mov	 rcx, QWORD PTR [rcx+820]
  009bf	48 89 48 0c	 mov	 QWORD PTR [rax+12], rcx
$LN34@write_hx2:

; 4511 :         }
; 4512 : 
; 4513 :         // Prepare PTPHDRvt
; 4514 :         pPTPHDRvt->iDataLen = 4;

  009c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pPTPHDRvt$[rsp]
  009cb	c7 40 0c 04 00
	00 00		 mov	 DWORD PTR [rax+12], 4

; 4515 :         memcpy( pPTPVTMre, &VTAM_ebcdic, 4 );      // 'VTAM' in EBCDIC

  009d2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pPTPVTMre$[rsp]
  009da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR VTAM_ebcdic
  009e0	89 08		 mov	 DWORD PTR [rax], ecx

; 4516 : 
; 4517 :         // Display various information, maybe
; 4518 :         if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  009e2	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  009e7	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  009ea	83 e0 10	 and	 eax, 16
  009ed	85 c0		 test	 eax, eax
  009ef	74 2a		 je	 SHORT $LN35@write_hx2

; 4519 :         {
; 4520 :             mpc_display_description( pDEVBLK, "Out HX0" );

  009f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171661
  009f8	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a00	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description

; 4521 :             mpc_display_description( pDEVBLK, "Out HX2" );

  00a06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171662
  00a0d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN35@write_hx2:

; 4522 :         }
; 4523 : 
; 4524 :         // Add PTPHDRs to chain.
; 4525 :         add_buffer_to_chain( pPTPATH, pPTPHDRx0 );

  00a1b	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRx0$[rsp]
  00a23	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00a28	e8 00 00 00 00	 call	 add_buffer_to_chain

; 4526 :         add_buffer_to_chain( pPTPATH, pPTPHDRx2 );

  00a2d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRx2$[rsp]
  00a35	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00a3a	e8 00 00 00 00	 call	 add_buffer_to_chain

; 4527 :         add_buffer_to_chain( pPTPATH, pPTPHDRvt );

  00a3f	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR pPTPHDRvt$[rsp]
  00a47	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00a4c	e8 00 00 00 00	 call	 add_buffer_to_chain
$LN12@write_hx2:

; 4528 : 
; 4529 :     }
; 4530 :     else
; 4531 :     {
; 4532 :         // An XID2 is being written by the y-side but handshaking is
; 4533 :         // not in progress on the path; we don't understand!
; 4534 :     }
; 4535 : 
; 4536 :     // Set residual byte count and unit status.
; 4537 :     *pMore = 0;

  00a51	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00a59	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4538 :     *pResidual = 0;

  00a5c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00a64	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4539 :     *pUnitStat = CSW_CE | CSW_DE;

  00a6a	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00a72	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN1@write_hx2:

; 4540 : 
; 4541 :     return;
; 4542 : }   /* End function  write_hx2() */

  00a75	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  00a7c	5f		 pop	 rdi
  00a7d	c3		 ret	 0
write_hx2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPATH$ = 32
pPTPBLK$ = 40
pDEVBLK$ = 64
uCount$ = 72
iCCWSeq$ = 80
pIOBuf$ = 88
pMore$ = 96
pUnitStat$ = 104
pResidual$ = 112
write_hx0_00 PROC

; 4187 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4188 : 
; 4189 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001c	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00023	48 89 44 24 20	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 4190 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 28	 mov	 QWORD PTR pPTPBLK$[rsp], rax
$LN4@write_hx0_:

; 4191 : //  PTPHX0*    pPTPHX0  = (PTPHX0*)pIOBuf;
; 4192 : 
; 4193 :     UNREFERENCED( uCount  );

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN4@write_hx0_
$LN7@write_hx0_:

; 4194 :     UNREFERENCED( iCCWSeq );

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN7@write_hx0_
$LN10@write_hx0_:

; 4195 :     UNREFERENCED( pIOBuf  );

  00041	33 c0		 xor	 eax, eax
  00043	85 c0		 test	 eax, eax
  00045	75 fa		 jne	 SHORT $LN10@write_hx0_

; 4196 : 
; 4197 : 
; 4198 :     // Display various information, maybe
; 4199 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0004c	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0004f	83 e0 10	 and	 eax, 16
  00052	85 c0		 test	 eax, eax
  00054	74 12		 je	 SHORT $LN11@write_hx0_

; 4200 :     {
; 4201 :         mpc_display_description( pDEVBLK, "In HX0" );

  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171540
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN11@write_hx0_:

; 4202 :     }
; 4203 : 
; 4204 :     // PTPHX0 type 0x00 should only be written when handshaking is in progress.
; 4205 :     if (pPTPATH->fHandshaking)

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0006d	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  00071	24 01		 and	 al, 1
  00073	0f b6 c0	 movzx	 eax, al
  00076	85 c0		 test	 eax, eax
  00078	74 1d		 je	 SHORT $LN12@write_hx0_

; 4206 :     {
; 4207 :         // An PTPHX0 type 0x00 is being written by the y-side and handshaking
; 4208 :         // is in progress on the path; we will assume that the y-side
; 4209 :         // is continuing handshaking and that the PTPHX0 is the start
; 4210 :         // of handshake two.
; 4211 :         pPTPATH->fHandshakeCur = HANDSHAKE_TWO;        // Handshake two in progress

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0007f	c6 40 3d 02	 mov	 BYTE PTR [rax+61], 2

; 4212 :         pPTPATH->fHandshakeSta |= HANDSHAKE_TWO;       // handshake two started

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00088	0f b6 40 3e	 movzx	 eax, BYTE PTR [rax+62]
  0008c	83 c8 02	 or	 eax, 2
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00094	88 41 3e	 mov	 BYTE PTR [rcx+62], al
$LN12@write_hx0_:

; 4213 :     }
; 4214 :     else
; 4215 :     {
; 4216 :         // An PTPHX0 type 0x00 is being written by the y-side and handshaking
; 4217 :         // is not in progress on the path; we don't understand!
; 4218 :     }
; 4219 : 
; 4220 :     // Set residual byte count and unit status.
; 4221 :     *pMore = 0;

  00097	48 8b 44 24 60	 mov	 rax, QWORD PTR pMore$[rsp]
  0009c	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4222 :     *pResidual = 0;

  0009f	48 8b 44 24 70	 mov	 rax, QWORD PTR pResidual$[rsp]
  000a4	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4223 :     *pUnitStat = CSW_CE | CSW_DE;

  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  000af	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4224 : 
; 4225 :     return;
; 4226 : }   /* End function  write_hx0_00() */

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
write_hx0_00 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPBLK$ = 80
pPTPATH$ = 88
tv133 = 96
tv137 = 100
tv160 = 104
tv164 = 108
tv187 = 112
tv191 = 116
tv130 = 120
tv157 = 128
tv184 = 136
pDEVBLK$ = 160
uCount$ = 168
iCCWSeq$ = 176
pIOBuf$ = 184
pMore$ = 192
pUnitStat$ = 200
pResidual$ = 208
write_hx0_01 PROC

; 4025 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 4026 : 
; 4027 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;

  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00023	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0002a	48 89 44 24 58	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 4028 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;

  0002f	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 89 44 24 50	 mov	 QWORD PTR pPTPBLK$[rsp], rax
$LN4@write_hx0_:

; 4029 : //  PTPHX0*    pPTPHX0  = (PTPHX0*)pIOBuf;
; 4030 : 
; 4031 :     UNREFERENCED( uCount  );

  0003c	33 c0		 xor	 eax, eax
  0003e	85 c0		 test	 eax, eax
  00040	75 fa		 jne	 SHORT $LN4@write_hx0_
$LN7@write_hx0_:

; 4032 :     UNREFERENCED( iCCWSeq );

  00042	33 c0		 xor	 eax, eax
  00044	85 c0		 test	 eax, eax
  00046	75 fa		 jne	 SHORT $LN7@write_hx0_
$LN10@write_hx0_:

; 4033 :     UNREFERENCED( pIOBuf  );

  00048	33 c0		 xor	 eax, eax
  0004a	85 c0		 test	 eax, eax
  0004c	75 fa		 jne	 SHORT $LN10@write_hx0_

; 4034 : 
; 4035 : 
; 4036 :     // Display various information, maybe
; 4037 :     if (pPTPBLK->uDebugMask & DBGPTPUPDOWN)

  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00053	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00056	83 e0 10	 and	 eax, 16
  00059	85 c0		 test	 eax, eax
  0005b	74 15		 je	 SHORT $LN11@write_hx0_

; 4038 :     {
; 4039 :         mpc_display_description( pDEVBLK, "In HX0" );

  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171487
  00064	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description
$LN11@write_hx0_:

; 4040 :     }
; 4041 : 
; 4042 :     // PTPHX0 type 0x01's should only be written when handshaking is being
; 4043 :     // initiated or is in progress.
; 4044 :     if (!pPTPATH->fHandshaking)

  00072	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00077	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  0007b	24 01		 and	 al, 1
  0007d	0f b6 c0	 movzx	 eax, al
  00080	85 c0		 test	 eax, eax
  00082	0f 85 88 05 00
	00		 jne	 $LN12@write_hx0_

; 4045 :     {
; 4046 :         // An PTPHX0 type 0x01 is being written by the y-side when handshaking
; 4047 :         // was not in progress on the path; we will assume that the y-side
; 4048 :         // has initiated handshaking and that the PTPHX0 is the start of
; 4049 :         // handshake one.
; 4050 :         pPTPATH->fHandshaking = TRUE;                  // Hanshakining in progress

  00088	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0008d	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  00091	0c 01		 or	 al, 1
  00093	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00098	88 41 3c	 mov	 BYTE PTR [rcx+60], al

; 4051 :         pPTPATH->fHandshakeCur = HANDSHAKE_ONE;        // Handshake one in progress

  0009b	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000a0	c6 40 3d 01	 mov	 BYTE PTR [rax+61], 1

; 4052 :         pPTPATH->fHandshakeSta |= HANDSHAKE_ONE;       // handshake one started

  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000a9	0f b6 40 3e	 movzx	 eax, BYTE PTR [rax+62]
  000ad	83 c8 01	 or	 eax, 1
  000b0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  000b5	88 41 3e	 mov	 BYTE PTR [rcx+62], al

; 4053 : 
; 4054 :         // The guest OS on the y-side has started, or restarted, the
; 4055 :         // device, so reset or update any necessary values in the PTPBLK.
; 4056 :         // Note: this section of code is executed twice, once for the read
; 4057 :         // path and once for the write path, though not necessarily in that
; 4058 :         // order. Whichever path executes the routine first will reset or
; 4059 :         // update the values.
; 4060 :         obtain_lock( &pPTPBLK->UpdateLock );

  000b8	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000bd	48 83 c0 60	 add	 rax, 96			; 00000060H
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171490
  000c8	48 8b c8	 mov	 rcx, rax
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4061 :         if (pPTPBLK->xTokensUpdated == 0)              // if not updated

  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000d6	0f b6 80 3c 03
	00 00		 movzx	 eax, BYTE PTR [rax+828]
  000dd	85 c0		 test	 eax, eax
  000df	0f 85 ee 04 00
	00		 jne	 $LN14@write_hx0_

; 4062 :         {
; 4063 :             pPTPBLK->xTokensUpdated = 1;               // updated

  000e5	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000ea	c6 80 3c 03 00
	00 01		 mov	 BYTE PTR [rax+828], 1

; 4064 : 
; 4065 :             // Reset the active & terminate indicators
; 4066 :             if (pPTPBLK->fActive4)

  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000f6	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000f9	c1 e8 03	 shr	 eax, 3
  000fc	83 e0 01	 and	 eax, 1
  000ff	85 c0		 test	 eax, eax
  00101	0f 84 93 00 00
	00		 je	 $LN16@write_hx0_

; 4067 :             {
; 4068 :                 // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 4069 :                 WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00107	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0010c	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  00112	48 89 44 24 78	 mov	 QWORD PTR tv130[rsp], rax
  00117	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0011f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00123	89 4c 24 60	 mov	 DWORD PTR tv133[rsp], ecx
  00127	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0012f	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00133	d1 fa		 sar	 edx, 1
  00135	89 54 24 64	 mov	 DWORD PTR tv137[rsp], edx
  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00144	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv130[rsp]
  00149	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0014e	8b 4c 24 60	 mov	 ecx, DWORD PTR tv133[rsp]
  00152	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00156	8b 4c 24 64	 mov	 ecx, DWORD PTR tv137[rsp]
  0015a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171494
  00165	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171495
  00171	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00176	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0017b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00181	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171496
  00188	ba e6 0f 00 00	 mov	 edx, 4070		; 00000fe6H
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171497
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@write_hx0_:

; 4070 :                     pPTPBLK->szGuestIPAddr4 );
; 4071 :             }
; 4072 :             pPTPBLK->fActive4 = FALSE;

  0019a	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0019f	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001a2	83 e0 f7	 and	 eax, -9			; fffffff7H
  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  001aa	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 4073 :             pPTPBLK->bActivate4 = 0x00;

  001ad	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001b2	c6 80 84 03 00
	00 00		 mov	 BYTE PTR [rax+900], 0

; 4074 :             pPTPBLK->bTerminate4 = 0x00;

  001b9	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001be	c6 80 87 03 00
	00 00		 mov	 BYTE PTR [rax+903], 0

; 4075 : #if defined(ENABLE_IPV6)
; 4076 :             if (pPTPBLK->fActive6)

  001c5	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001ca	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001cd	c1 e8 04	 shr	 eax, 4
  001d0	83 e0 01	 and	 eax, 1
  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 99 00 00
	00		 je	 $LN17@write_hx0_

; 4077 :             {
; 4078 :                 // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 4079 :                 WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  001db	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001e0	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  001e6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv157[rsp], rax
  001ee	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001f6	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001fa	89 4c 24 68	 mov	 DWORD PTR tv160[rsp], ecx
  001fe	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00206	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0020a	d1 fa		 sar	 edx, 1
  0020c	89 54 24 6c	 mov	 DWORD PTR tv164[rsp], edx
  00210	b9 01 00 00 00	 mov	 ecx, 1
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0021b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv157[rsp]
  00223	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00228	8b 4c 24 68	 mov	 ecx, DWORD PTR tv160[rsp]
  0022c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00230	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv164[rsp]
  00234	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171499
  0023f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171500
  0024b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00250	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00255	41 b9 03 00 00
	00		 mov	 r9d, 3
  0025b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171501
  00262	ba f0 0f 00 00	 mov	 edx, 4080		; 00000ff0H
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171502
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@write_hx0_:

; 4080 :                     pPTPBLK->szGuestIPAddr6 );
; 4081 :             }
; 4082 : #endif /* defined(ENABLE_IPV6) */
; 4083 :             pPTPBLK->fActive6 = FALSE;

  00274	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00279	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0027c	83 e0 ef	 and	 eax, -17		; ffffffefH
  0027f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00284	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 4084 :             pPTPBLK->bActivate6 = 0x00;

  00287	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0028c	c6 80 85 03 00
	00 00		 mov	 BYTE PTR [rax+901], 0

; 4085 :             pPTPBLK->bTerminate6 = 0x00;

  00293	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00298	c6 80 88 03 00
	00 00		 mov	 BYTE PTR [rax+904], 0

; 4086 : #if defined(ENABLE_IPV6)
; 4087 :             if (pPTPBLK->fActiveLL6)

  0029f	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002a4	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  002a7	c1 e8 05	 shr	 eax, 5
  002aa	83 e0 01	 and	 eax, 1
  002ad	85 c0		 test	 eax, eax
  002af	0f 84 99 00 00
	00		 je	 $LN18@write_hx0_

; 4088 :             {
; 4089 :                 // HHC03916 "%1d:%04X PTP: Connection cleared to guest IP address '%s'"
; 4090 :                 WRMSG(HHC03916, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  002b5	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002ba	48 05 a0 02 00
	00		 add	 rax, 672		; 000002a0H
  002c0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv184[rsp], rax
  002c8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002d0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002d4	89 4c 24 70	 mov	 DWORD PTR tv187[rsp], ecx
  002d8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  002e0	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  002e4	d1 fa		 sar	 edx, 1
  002e6	89 54 24 74	 mov	 DWORD PTR tv191[rsp], edx
  002ea	b9 01 00 00 00	 mov	 ecx, 1
  002ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv184[rsp]
  002fd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00302	8b 4c 24 70	 mov	 ecx, DWORD PTR tv187[rsp]
  00306	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0030a	8b 4c 24 74	 mov	 ecx, DWORD PTR tv191[rsp]
  0030e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00312	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171504
  00319	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0031e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171505
  00325	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00335	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171506
  0033c	ba fb 0f 00 00	 mov	 edx, 4091		; 00000ffbH
  00341	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171507
  00348	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@write_hx0_:

; 4091 :                     pPTPBLK->szGuestLLAddr6 );
; 4092 :             }
; 4093 : #endif /* defined(ENABLE_IPV6) */
; 4094 :             pPTPBLK->fActiveLL6 = FALSE;

  0034e	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00353	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00356	83 e0 df	 and	 eax, -33		; ffffffdfH
  00359	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0035e	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 4095 :             pPTPBLK->bActivateLL6 = 0x00;

  00361	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00366	c6 80 86 03 00
	00 00		 mov	 BYTE PTR [rax+902], 0

; 4096 :             pPTPBLK->bTerminateLL6 = 0x00;

  0036d	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00372	c6 80 89 03 00
	00 00		 mov	 BYTE PTR [rax+905], 0

; 4097 : 
; 4098 :             // Obtain the lock for manipulating the tokens
; 4099 :             obtain_lock( &TokenLock );

  00379	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171508
  00380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  00387	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4100 : 
; 4101 :             // Set the x-side tokens
; 4102 :             STORE_FW( pPTPBLK->xTokenIssuerRm, uTokenIssuerRm );

  0038d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR uTokenIssuerRm
  00393	e8 00 00 00 00	 call	 _byteswap_ulong
  00398	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0039d	48 81 c1 3d 03
	00 00		 add	 rcx, 829		; 0000033dH
  003a4	8b d0		 mov	 edx, eax
  003a6	e8 00 00 00 00	 call	 store_fw_noswap

; 4103 :             STORE_FW( pPTPBLK->xTokenCmFilter, uTokenCmFilter );

  003ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR uTokenCmFilter
  003b1	e8 00 00 00 00	 call	 _byteswap_ulong
  003b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003bb	48 81 c1 41 03
	00 00		 add	 rcx, 833		; 00000341H
  003c2	8b d0		 mov	 edx, eax
  003c4	e8 00 00 00 00	 call	 store_fw_noswap

; 4104 :             STORE_FW( pPTPBLK->xTokenCmConnection, uTokenCmConnection );

  003c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR uTokenCmConnection
  003cf	e8 00 00 00 00	 call	 _byteswap_ulong
  003d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003d9	48 81 c1 45 03
	00 00		 add	 rcx, 837		; 00000345H
  003e0	8b d0		 mov	 edx, eax
  003e2	e8 00 00 00 00	 call	 store_fw_noswap

; 4105 :             STORE_FW( pPTPBLK->xTokenUlpFilter, uTokenUlpFilter );

  003e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR uTokenUlpFilter
  003ed	e8 00 00 00 00	 call	 _byteswap_ulong
  003f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003f7	48 81 c1 49 03
	00 00		 add	 rcx, 841		; 00000349H
  003fe	8b d0		 mov	 edx, eax
  00400	e8 00 00 00 00	 call	 store_fw_noswap

; 4106 :             STORE_FW( pPTPBLK->xTokenUlpConnection, uTokenUlpConnection );

  00405	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR uTokenUlpConnection
  0040b	e8 00 00 00 00	 call	 _byteswap_ulong
  00410	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00415	48 81 c1 4d 03
	00 00		 add	 rcx, 845		; 0000034dH
  0041c	8b d0		 mov	 edx, eax
  0041e	e8 00 00 00 00	 call	 store_fw_noswap

; 4107 : 
; 4108 :             // Increment the tokens
; 4109 :             uTokenIssuerRm      += INCREMENT_TOKEN;

  00423	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR uTokenIssuerRm
  00429	83 c0 10	 add	 eax, 16
  0042c	89 05 00 00 00
	00		 mov	 DWORD PTR uTokenIssuerRm, eax

; 4110 :             uTokenCmFilter      += INCREMENT_TOKEN;

  00432	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR uTokenCmFilter
  00438	83 c0 10	 add	 eax, 16
  0043b	89 05 00 00 00
	00		 mov	 DWORD PTR uTokenCmFilter, eax

; 4111 :             uTokenCmConnection  += INCREMENT_TOKEN;

  00441	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR uTokenCmConnection
  00447	83 c0 10	 add	 eax, 16
  0044a	89 05 00 00 00
	00		 mov	 DWORD PTR uTokenCmConnection, eax

; 4112 :             uTokenUlpFilter     += INCREMENT_TOKEN;

  00450	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR uTokenUlpFilter
  00456	83 c0 10	 add	 eax, 16
  00459	89 05 00 00 00
	00		 mov	 DWORD PTR uTokenUlpFilter, eax

; 4113 :             uTokenUlpConnection += INCREMENT_TOKEN;

  0045f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR uTokenUlpConnection
  00465	83 c0 10	 add	 eax, 16
  00468	89 05 00 00 00
	00		 mov	 DWORD PTR uTokenUlpConnection, eax

; 4114 : 
; 4115 :             // Release the lock for manipulating the tokens
; 4116 :             release_lock( &TokenLock );

  0046e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171509
  00475	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  0047c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4117 : 
; 4118 :             // Clear the y-side tokens
; 4119 :             pPTPBLK->yTokensCopied = 0;

  00482	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00487	c6 80 5f 03 00
	00 00		 mov	 BYTE PTR [rax+863], 0

; 4120 :             memset( pPTPBLK->yTokenIssuerRm, 0, MPC_TOKEN_LENGTH );

  0048e	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00493	48 05 60 03 00
	00		 add	 rax, 864		; 00000360H
  00499	48 8b f8	 mov	 rdi, rax
  0049c	33 c0		 xor	 eax, eax
  0049e	b9 04 00 00 00	 mov	 ecx, 4
  004a3	f3 aa		 rep stosb

; 4121 :             memset( pPTPBLK->yTokenCmFilter, 0, MPC_TOKEN_LENGTH );

  004a5	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004aa	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  004b0	48 8b f8	 mov	 rdi, rax
  004b3	33 c0		 xor	 eax, eax
  004b5	b9 04 00 00 00	 mov	 ecx, 4
  004ba	f3 aa		 rep stosb

; 4122 :             memset( pPTPBLK->yTokenCmConnection, 0, MPC_TOKEN_LENGTH );

  004bc	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004c1	48 05 68 03 00
	00		 add	 rax, 872		; 00000368H
  004c7	48 8b f8	 mov	 rdi, rax
  004ca	33 c0		 xor	 eax, eax
  004cc	b9 04 00 00 00	 mov	 ecx, 4
  004d1	f3 aa		 rep stosb

; 4123 :             memset( pPTPBLK->yTokenUlpFilter, 0, MPC_TOKEN_LENGTH );

  004d3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004d8	48 05 6c 03 00
	00		 add	 rax, 876		; 0000036cH
  004de	48 8b f8	 mov	 rdi, rax
  004e1	33 c0		 xor	 eax, eax
  004e3	b9 04 00 00 00	 mov	 ecx, 4
  004e8	f3 aa		 rep stosb

; 4124 :             memset( pPTPBLK->yTokenUlpConnection, 0, MPC_TOKEN_LENGTH );

  004ea	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004ef	48 05 70 03 00
	00		 add	 rax, 880		; 00000370H
  004f5	48 8b f8	 mov	 rdi, rax
  004f8	33 c0		 xor	 eax, eax
  004fa	b9 04 00 00 00	 mov	 ecx, 4
  004ff	f3 aa		 rep stosb

; 4125 : 
; 4126 :             // Reset the y-side process sequence numbers
; 4127 :             pPTPBLK->uSeqNumIssuer = 0;

  00501	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00506	c7 80 7a 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+890], 0

; 4128 :             pPTPBLK->uSeqNumCm = 0;

  00510	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00515	c7 80 7e 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+894], 0

; 4129 : 
; 4130 :             /* Clear the y-side IP address information */
; 4131 :             if (pPTPBLK->fPreconfigured) {

  0051f	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00524	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00527	c1 e8 06	 shr	 eax, 6
  0052a	83 e0 01	 and	 eax, 1
  0052d	85 c0		 test	 eax, eax
  0052f	0f 84 9c 00 00
	00		 je	 $LN19@write_hx0_

; 4132 :                 if (!pPTPBLK->fPreGuestIPAddr4) {

  00535	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0053a	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0053d	c1 e8 07	 shr	 eax, 7
  00540	83 e0 01	 and	 eax, 1
  00543	85 c0		 test	 eax, eax
  00545	75 2e		 jne	 SHORT $LN20@write_hx0_

; 4133 :                 memset(pPTPBLK->szGuestIPAddr4, 0, sizeof(pPTPBLK->szGuestIPAddr4));

  00547	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0054c	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  00552	48 8b f8	 mov	 rdi, rax
  00555	33 c0		 xor	 eax, eax
  00557	b9 14 00 00 00	 mov	 ecx, 20
  0055c	f3 aa		 rep stosb

; 4134 :                 memset(&pPTPBLK->iaGuestIPAddr4, 0, sizeof(pPTPBLK->iaGuestIPAddr4));

  0055e	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00563	48 05 dc 02 00
	00		 add	 rax, 732		; 000002dcH
  00569	48 8b f8	 mov	 rdi, rax
  0056c	33 c0		 xor	 eax, eax
  0056e	b9 04 00 00 00	 mov	 ecx, 4
  00573	f3 aa		 rep stosb
$LN20@write_hx0_:

; 4135 :                 }
; 4136 : #if defined(ENABLE_IPV6)
; 4137 :                 memset(pPTPBLK->szGuestIPAddr6, 0, sizeof(pPTPBLK->szGuestIPAddr6));

  00575	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0057a	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  00580	48 8b f8	 mov	 rdi, rax
  00583	33 c0		 xor	 eax, eax
  00585	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0058a	f3 aa		 rep stosb

; 4138 :                 memset(&pPTPBLK->iaGuestIPAddr6, 0, sizeof(pPTPBLK->iaGuestIPAddr6));

  0058c	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00591	48 05 f0 02 00
	00		 add	 rax, 752		; 000002f0H
  00597	48 8b f8	 mov	 rdi, rax
  0059a	33 c0		 xor	 eax, eax
  0059c	b9 10 00 00 00	 mov	 ecx, 16
  005a1	f3 aa		 rep stosb

; 4139 :                 memset(pPTPBLK->szGuestLLAddr6, 0, sizeof(pPTPBLK->szGuestLLAddr6));

  005a3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005a8	48 05 a0 02 00
	00		 add	 rax, 672		; 000002a0H
  005ae	48 8b f8	 mov	 rdi, rax
  005b1	33 c0		 xor	 eax, eax
  005b3	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  005b8	f3 aa		 rep stosb

; 4140 :                 memset(&pPTPBLK->iaGuestLLAddr6, 0, sizeof(pPTPBLK->iaGuestLLAddr6));

  005ba	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005bf	48 05 10 03 00
	00		 add	 rax, 784		; 00000310H
  005c5	48 8b f8	 mov	 rdi, rax
  005c8	33 c0		 xor	 eax, eax
  005ca	b9 10 00 00 00	 mov	 ecx, 16
  005cf	f3 aa		 rep stosb
$LN19@write_hx0_:

; 4141 : #endif /* defined(ENABLE_IPV6) */
; 4142 :             }
; 4143 : 
; 4144 :         }

  005d1	eb 0c		 jmp	 SHORT $LN15@write_hx0_
$LN14@write_hx0_:

; 4145 :         else
; 4146 :         {
; 4147 :             pPTPBLK->xTokensUpdated = 0;               // update next restart

  005d3	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005d8	c6 80 3c 03 00
	00 00		 mov	 BYTE PTR [rax+828], 0
$LN15@write_hx0_:

; 4148 :         }
; 4149 :         release_lock( &pPTPBLK->UpdateLock );

  005df	48 8b 44 24 50	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005e4	48 83 c0 60	 add	 rax, 96			; 00000060H
  005e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171512
  005ef	48 8b c8	 mov	 rcx, rax
  005f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4150 : 
; 4151 :         // The guest OS on the y-side has started, or restarted, the
; 4152 :         // device, so dispose of any data waiting to be read by the y-side.
; 4153 :         // Free any PTPHDR on the chain for the path
; 4154 :         remove_and_free_any_buffers_on_chain( pPTPATH );

  005f8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  005fd	e8 00 00 00 00	 call	 remove_and_free_any_buffers_on_chain

; 4155 :         // Reset the message sequence number
; 4156 :         pPTPATH->uSeqNum = 0;

  00602	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00607	c7 40 42 00 00
	00 00		 mov	 DWORD PTR [rax+66], 0

; 4157 :     }

  0060e	eb 1d		 jmp	 SHORT $LN13@write_hx0_
$LN12@write_hx0_:

; 4158 :     else
; 4159 :     {
; 4160 :         // An PTPHX0 type 0x01 is being written by the y-side and handshaking
; 4161 :         // is in progress on the path; we will assume that the y-side
; 4162 :         // is continuing handshaking and that the PTPHX0 is the start
; 4163 :         // of handshake three.
; 4164 :         pPTPATH->fHandshakeCur = HANDSHAKE_THREE;      // Handshake three in progress

  00610	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00615	c6 40 3d 04	 mov	 BYTE PTR [rax+61], 4

; 4165 :         pPTPATH->fHandshakeSta |= HANDSHAKE_THREE;     // handshake three started

  00619	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0061e	0f b6 40 3e	 movzx	 eax, BYTE PTR [rax+62]
  00622	83 c8 04	 or	 eax, 4
  00625	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  0062a	88 41 3e	 mov	 BYTE PTR [rcx+62], al
$LN13@write_hx0_:

; 4166 :     }
; 4167 : 
; 4168 :     // Set residual byte count and unit status.
; 4169 :     *pMore = 0;

  0062d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00635	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4170 :     *pResidual = 0;

  00638	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00640	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4171 :     *pUnitStat = CSW_CE | CSW_DE;

  00646	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0064e	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4172 : 
; 4173 :     return;
; 4174 : }   /* End function  write_hx0_01() */

  00651	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00658	5f		 pop	 rdi
  00659	c3		 ret	 0
write_hx0_01 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
hreg$ = 32
regs$ = 40
dreg$ = 48
tod$ = 56
$T1 = 64
ETOD$ = 80
__$ArrayPad$ = 96
SAaddress$ = 144
get_subarea_address PROC

; 3990 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3991 :     REGS    *regs;
; 3992 :     ETOD    ETOD;
; 3993 :     TOD     tod;
; 3994 :     U64     dreg;                       /* Double word workarea       */
; 3995 :     U16     hreg;                       /* Half word workarea         */
; 3996 : 
; 3997 : 
; 3998 :     obtain_lock(&sysblk.cpulock[sysblk.pcpu]);

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002f	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171458
  0003e	48 8b c8	 mov	 rcx, rax
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3999 :     regs = sysblk.regs[sysblk.pcpu];

  00047	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004e	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005c	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00064	48 89 44 24 28	 mov	 QWORD PTR regs$[rsp], rax

; 4000 :     etod_clock(regs, &ETOD, ETOD_standard);

  00069	41 b8 02 00 00
	00		 mov	 r8d, 2
  0006f	48 8d 54 24 50	 lea	 rdx, QWORD PTR ETOD$[rsp]
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_etod_clock

; 4001 :     tod = ETOD2TOD(ETOD);

  0007f	48 8d 44 24 40	 lea	 rax, QWORD PTR $T1[rsp]
  00084	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ETOD$[rsp]
  00089	48 8b f8	 mov	 rdi, rax
  0008c	48 8b f1	 mov	 rsi, rcx
  0008f	b9 10 00 00 00	 mov	 ecx, 16
  00094	f3 a4		 rep movsb
  00096	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T1[rsp]
  0009b	e8 00 00 00 00	 call	 ETOD2TOD
  000a0	48 89 44 24 38	 mov	 QWORD PTR tod$[rsp], rax

; 4002 :     release_lock(&sysblk.cpulock[sysblk.pcpu]);

  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ac	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ba	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171459
  000c9	48 8b c8	 mov	 rcx, rax
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4003 : 
; 4004 :     dreg = sysblk.cpuid;

  000d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d9	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  000e0	48 89 44 24 30	 mov	 QWORD PTR dreg$[rsp], rax

; 4005 : 
; 4006 :     hreg = ( ( dreg >> 20 ) & 0x000000000000FFFFULL );

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR dreg$[rsp]
  000ea	48 c1 e8 14	 shr	 rax, 20
  000ee	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  000f4	66 89 44 24 20	 mov	 WORD PTR hreg$[rsp], ax

; 4007 :     STORE_HW( SAaddress+0, hreg );

  000f9	0f b7 4c 24 20	 movzx	 ecx, WORD PTR hreg$[rsp]
  000fe	e8 00 00 00 00	 call	 _byteswap_ushort
  00103	0f b7 d0	 movzx	 edx, ax
  00106	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR SAaddress$[rsp]
  0010e	e8 00 00 00 00	 call	 store_hw_noswap

; 4008 :     hreg = ( ( tod >> 17 ) & 0x000000000000FFFFULL );

  00113	48 8b 44 24 38	 mov	 rax, QWORD PTR tod$[rsp]
  00118	48 c1 e8 11	 shr	 rax, 17
  0011c	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00122	66 89 44 24 20	 mov	 WORD PTR hreg$[rsp], ax

; 4009 :     STORE_HW( SAaddress+2, hreg );

  00127	0f b7 4c 24 20	 movzx	 ecx, WORD PTR hreg$[rsp]
  0012c	e8 00 00 00 00	 call	 _byteswap_ushort
  00131	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR SAaddress$[rsp]
  00139	48 83 c1 02	 add	 rcx, 2
  0013d	0f b7 d0	 movzx	 edx, ax
  00140	e8 00 00 00 00	 call	 store_hw_noswap

; 4010 : 
; 4011 :     return;
; 4012 : }

  00145	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014a	48 33 cc	 xor	 rcx, rsp
  0014d	e8 00 00 00 00	 call	 __security_check_cookie
  00152	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00156	5f		 pop	 rdi
  00157	5e		 pop	 rsi
  00158	c3		 ret	 0
get_subarea_address ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
regs$ = 32
tod$ = 40
$T1 = 48
ETOD$ = 64
__$ArrayPad$ = 80
TodClock$ = 128
ptp_get_tod_clock PROC

; 3957 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3958 :     REGS    *regs;
; 3959 :     ETOD    ETOD;
; 3960 :     TOD     tod;
; 3961 : 
; 3962 :     obtain_lock( &sysblk.cpulock[ sysblk.pcpu ]);

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002f	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171448
  0003e	48 8b c8	 mov	 rcx, rax
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3963 :     {
; 3964 :         regs = sysblk.regs[ sysblk.pcpu ];

  00047	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004e	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005c	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00064	48 89 44 24 20	 mov	 QWORD PTR regs$[rsp], rax

; 3965 :         etod_clock( regs, &ETOD, ETOD_standard );

  00069	41 b8 02 00 00
	00		 mov	 r8d, 2
  0006f	48 8d 54 24 40	 lea	 rdx, QWORD PTR ETOD$[rsp]
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_etod_clock

; 3966 :         tod = ETOD2TOD( ETOD );

  0007f	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00084	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ETOD$[rsp]
  00089	48 8b f8	 mov	 rdi, rax
  0008c	48 8b f1	 mov	 rsi, rcx
  0008f	b9 10 00 00 00	 mov	 ecx, 16
  00094	f3 a4		 rep movsb
  00096	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0009b	e8 00 00 00 00	 call	 ETOD2TOD
  000a0	48 89 44 24 28	 mov	 QWORD PTR tod$[rsp], rax

; 3967 :     }
; 3968 :     release_lock( &sysblk.cpulock[ sysblk.pcpu ]);

  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ac	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ba	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171449
  000c9	48 8b c8	 mov	 rcx, rax
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3969 : 
; 3970 :     STORE_DW( TodClock, tod );

  000d2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tod$[rsp]
  000d7	e8 00 00 00 00	 call	 _byteswap_uint64
  000dc	48 8b d0	 mov	 rdx, rax
  000df	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR TodClock$[rsp]
  000e7	e8 00 00 00 00	 call	 store_dw_noswap

; 3971 : 
; 3972 :     return;
; 3973 : }

  000ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f1	48 33 cc	 xor	 rcx, rsp
  000f4	e8 00 00 00 00	 call	 __security_check_cookie
  000f9	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000fd	5f		 pop	 rdi
  000fe	5e		 pop	 rsi
  000ff	c3		 ret	 0
ptp_get_tod_clock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
rc$ = 96
pPTPATH$ = 104
pPTPINT$ = 112
i$ = 120
pDEVBLK$ = 128
now$ = 136
pPTPBLK$ = 144
delay_q$ = 152
delay_r$ = 156
tv132 = 160
tv137 = 164
tv141 = 168
waittime$ = 176
__$ArrayPad$ = 192
arg$ = 224
ptp_unsol_int_thread PROC

; 3841 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3842 :     PTPINT*    pPTPINT  = (PTPINT*) arg;

  0001e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00026	48 89 44 24 70	 mov	 QWORD PTR pPTPINT$[rsp], rax

; 3843 :     DEVBLK*    pDEVBLK  = pPTPINT->pDEVBLK;    // DEVBLK

  0002b	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  00030	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00034	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 3844 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;   // PTPATH

  0003c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00044	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0004b	48 89 44 24 68	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 3845 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;    // PTPBLK

  00050	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 3846 :     int        rc;
; 3847 :     int        i;
; 3848 :     int        delay_q;
; 3849 :     int        delay_r;
; 3850 :     struct timespec waittime;
; 3851 :     struct timeval  now;
; 3852 : 
; 3853 : 
; 3854 :     // Check whether the requestor wants a delay before the interrupt
; 3855 :     // is raised.
; 3856 :     if (pPTPINT->iDelay != 0)

  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  00065	83 78 11 00	 cmp	 DWORD PTR [rax+17], 0
  00069	0f 84 12 01 00
	00		 je	 $LN5@ptp_unsol_

; 3857 :     {
; 3858 :         // Wait for the number of milliseconds specified by the requestor.
; 3859 :         // Calculate when to end the wait.
; 3860 :         delay_q = pPTPINT->iDelay / 1000;

  0006f	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  00074	8b 40 11	 mov	 eax, DWORD PTR [rax+17]
  00077	99		 cdq
  00078	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0007d	f7 f9		 idiv	 ecx
  0007f	89 84 24 98 00
	00 00		 mov	 DWORD PTR delay_q$[rsp], eax

; 3861 :         delay_r = pPTPINT->iDelay % 1000;

  00086	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  0008b	8b 40 11	 mov	 eax, DWORD PTR [rax+17]
  0008e	99		 cdq
  0008f	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00094	f7 f9		 idiv	 ecx
  00096	8b c2		 mov	 eax, edx
  00098	89 84 24 9c 00
	00 00		 mov	 DWORD PTR delay_r$[rsp], eax

; 3862 : 
; 3863 :         gettimeofday( &now, NULL );

  0009f	33 d2		 xor	 edx, edx
  000a1	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR now$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 3864 : 
; 3865 :         waittime.tv_sec  = now.tv_sec + delay_q;

  000af	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR delay_q$[rsp]
  000b6	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR now$[rsp]
  000bd	03 c8		 add	 ecx, eax
  000bf	8b c1		 mov	 eax, ecx
  000c1	48 98		 cdqe
  000c3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR waittime$[rsp], rax

; 3866 :         waittime.tv_nsec = (now.tv_usec + (delay_r * 1000)) * 1000;

  000cb	69 84 24 9c 00
	00 00 e8 03 00
	00		 imul	 eax, DWORD PTR delay_r$[rsp], 1000 ; 000003e8H
  000d6	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR now$[rsp+4]
  000dd	03 c8		 add	 ecx, eax
  000df	8b c1		 mov	 eax, ecx
  000e1	69 c0 e8 03 00
	00		 imul	 eax, eax, 1000		; 000003e8H
  000e7	89 84 24 b8 00
	00 00		 mov	 DWORD PTR waittime$[rsp+8], eax

; 3867 :         if (waittime.tv_nsec >= 1000000000)

  000ee	81 bc 24 b8 00
	00 00 00 ca 9a
	3b		 cmp	 DWORD PTR waittime$[rsp+8], 1000000000 ; 3b9aca00H
  000f9	7c 26		 jl	 SHORT $LN6@ptp_unsol_

; 3868 :         {
; 3869 :             waittime.tv_sec++;

  000fb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR waittime$[rsp]
  00103	48 ff c0	 inc	 rax
  00106	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR waittime$[rsp], rax

; 3870 :             waittime.tv_nsec -= 1000000000;

  0010e	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR waittime$[rsp+8]
  00115	2d 00 ca 9a 3b	 sub	 eax, 1000000000		; 3b9aca00H
  0011a	89 84 24 b8 00
	00 00		 mov	 DWORD PTR waittime$[rsp+8], eax
$LN6@ptp_unsol_:

; 3871 :         }
; 3872 : 
; 3873 :         // Obtain the path unsolicited interrupt event lock
; 3874 :         obtain_lock( &pPTPATH->UnsolEventLock );

  00121	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00126	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171426
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3875 : 
; 3876 :         // Use a calculated wait
; 3877 :         rc = timed_wait_condition( &pPTPATH->UnsolEvent,

  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0013f	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00143	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00148	48 83 c1 34	 add	 rcx, 52			; 00000034H
  0014c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171427
  00153	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR waittime$[rsp]
  0015b	48 8b d0	 mov	 rdx, rax
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition
  00164	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3878 :                                    &pPTPATH->UnsolEventLock,
; 3879 :                                    &waittime );
; 3880 : 
; 3881 :         // Release the path unsolicited interrupt event lock
; 3882 :         release_lock( &pPTPATH->UnsolEventLock );

  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0016d	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171428
  00178	48 8b c8	 mov	 rcx, rax
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN5@ptp_unsol_:

; 3883 :     }
; 3884 : 
; 3885 :     // Display various information, maybe
; 3886 :     if (pPTPBLK->uDebugMask & DBGPTPCCW)

  00181	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00189	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0018c	83 e0 20	 and	 eax, 32			; 00000020H
  0018f	85 c0		 test	 eax, eax
  00191	0f 84 b1 00 00
	00		 je	 $LN7@ptp_unsol_

; 3887 :     {
; 3888 :         // HHC03994 "%1d:%04X %s: Status %02X"
; 3889 :         WRMSG(HHC03994, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00197	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  0019c	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  001a0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv132[rsp], eax
  001a7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001af	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001b3	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv137[rsp], ecx
  001ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  001c2	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  001c6	d1 fa		 sar	 edx, 1
  001c8	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv141[rsp], edx
  001cf	b9 01 00 00 00	 mov	 ecx, 1
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001da	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv132[rsp]
  001e1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  001e5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001ed	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001f1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001f6	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv137[rsp]
  001fd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00201	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv141[rsp]
  00208	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0020c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171430
  00213	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171431
  0021f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00224	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00229	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171432
  00236	ba 32 0f 00 00	 mov	 edx, 3890		; 00000f32H
  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171433
  00242	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@ptp_unsol_:

; 3890 :             pPTPINT->bStatus );
; 3891 :     }
; 3892 : 
; 3893 :     // Raise an interrupt.
; 3894 :     // device_attention() (in channel.c) raises an unsolicited interrupt
; 3895 :     // for the specified device. Return value is 0 if successful, 1 if
; 3896 :     // the device is busy or pending, or 3 if subchannel is not valid
; 3897 :     // or not enabled.
; 3898 :     // If the device is busy or pending, wait for 100 milliseconds and
; 3899 :     // attempt to raise the interrupt again. Retry up to nine times,
; 3900 :     // i.e. attempt to raise the interrupt up to a total of ten times.
; 3901 :     rc = device_attention( pDEVBLK, pPTPINT->bStatus );

  00248	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  0024d	0f b6 50 10	 movzx	 edx, BYTE PTR [rax+16]
  00251	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention
  0025f	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3902 :     if (rc == 1)

  00263	83 7c 24 60 01	 cmp	 DWORD PTR rc$[rsp], 1
  00268	0f 85 14 01 00
	00		 jne	 $LN8@ptp_unsol_

; 3903 :     {
; 3904 :         for( i = 0; i <= 8; i++ )

  0026e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00276	eb 0a		 jmp	 SHORT $LN4@ptp_unsol_
$LN2@ptp_unsol_:
  00278	8b 44 24 78	 mov	 eax, DWORD PTR i$[rsp]
  0027c	ff c0		 inc	 eax
  0027e	89 44 24 78	 mov	 DWORD PTR i$[rsp], eax
$LN4@ptp_unsol_:
  00282	83 7c 24 78 08	 cmp	 DWORD PTR i$[rsp], 8
  00287	0f 8f f5 00 00
	00		 jg	 $LN3@ptp_unsol_

; 3905 :         {
; 3906 :             // Wait for 100 milliseconds
; 3907 :             // Calculate when to end the wait.
; 3908 :             gettimeofday( &now, NULL );

  0028d	33 d2		 xor	 edx, edx
  0028f	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR now$[rsp]
  00297	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 3909 : 
; 3910 :             waittime.tv_sec  = now.tv_sec;

  0029d	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR now$[rsp]
  002a5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR waittime$[rsp], rax

; 3911 :             waittime.tv_nsec = (now.tv_usec + (100 * 1000)) * 1000;

  002ad	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR now$[rsp+4]
  002b4	05 a0 86 01 00	 add	 eax, 100000		; 000186a0H
  002b9	69 c0 e8 03 00
	00		 imul	 eax, eax, 1000		; 000003e8H
  002bf	89 84 24 b8 00
	00 00		 mov	 DWORD PTR waittime$[rsp+8], eax

; 3912 :             if (waittime.tv_nsec >= 1000000000)

  002c6	81 bc 24 b8 00
	00 00 00 ca 9a
	3b		 cmp	 DWORD PTR waittime$[rsp+8], 1000000000 ; 3b9aca00H
  002d1	7c 26		 jl	 SHORT $LN9@ptp_unsol_

; 3913 :             {
; 3914 :                 waittime.tv_sec++;

  002d3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR waittime$[rsp]
  002db	48 ff c0	 inc	 rax
  002de	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR waittime$[rsp], rax

; 3915 :                 waittime.tv_nsec -= 1000000000;

  002e6	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR waittime$[rsp+8]
  002ed	2d 00 ca 9a 3b	 sub	 eax, 1000000000		; 3b9aca00H
  002f2	89 84 24 b8 00
	00 00		 mov	 DWORD PTR waittime$[rsp+8], eax
$LN9@ptp_unsol_:

; 3916 :             }
; 3917 : 
; 3918 :             // Obtain the path unsolicited interrupt event lock
; 3919 :             obtain_lock( &pPTPATH->UnsolEventLock );

  002f9	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  002fe	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00302	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171436
  00309	48 8b c8	 mov	 rcx, rax
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3920 : 
; 3921 :             // Use a calculated wait
; 3922 :             rc = timed_wait_condition( &pPTPATH->UnsolEvent,

  00312	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00317	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0031b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00320	48 83 c1 34	 add	 rcx, 52			; 00000034H
  00324	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171437
  0032b	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR waittime$[rsp]
  00333	48 8b d0	 mov	 rdx, rax
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition
  0033c	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3923 :                                        &pPTPATH->UnsolEventLock,
; 3924 :                                        &waittime );
; 3925 : 
; 3926 :             // Release the path unsolicited interrupt event lock
; 3927 :             release_lock( &pPTPATH->UnsolEventLock );

  00340	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00345	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00349	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171438
  00350	48 8b c8	 mov	 rcx, rax
  00353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3928 : 
; 3929 :             // Attempt to raise the interrupt again.
; 3930 :             rc = device_attention( pDEVBLK, pPTPINT->bStatus );

  00359	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  0035e	0f b6 50 10	 movzx	 edx, BYTE PTR [rax+16]
  00362	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention
  00370	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3931 :             if (rc != 1)

  00374	83 7c 24 60 01	 cmp	 DWORD PTR rc$[rsp], 1
  00379	74 02		 je	 SHORT $LN10@ptp_unsol_

; 3932 :                 break;

  0037b	eb 05		 jmp	 SHORT $LN3@ptp_unsol_
$LN10@ptp_unsol_:

; 3933 :         }

  0037d	e9 f6 fe ff ff	 jmp	 $LN2@ptp_unsol_
$LN3@ptp_unsol_:
$LN8@ptp_unsol_:

; 3934 :     }
; 3935 : 
; 3936 :     // Obtain the unsolicited interrupt list lock.
; 3937 :     obtain_lock( &pPTPBLK->UnsolListLock );

  00382	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0038a	48 83 c0 50	 add	 rax, 80			; 00000050H
  0038e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171440
  00395	48 8b c8	 mov	 rcx, rax
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3938 : 
; 3939 :     // Return the PTPINT to the LIFO linked list.
; 3940 :     pPTPINT->pNextPTPINT = pPTPBLK->pFirstPTPINT;

  0039e	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  003a3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003ab	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  003af	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3941 :     pPTPBLK->pFirstPTPINT = pPTPINT;

  003b2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPINT$[rsp]
  003bf	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 3942 : 
; 3943 :     // Release the unsolicited interrupt list lock.
; 3944 :     release_lock( &pPTPBLK->UnsolListLock );

  003c3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003cb	48 83 c0 50	 add	 rax, 80			; 00000050H
  003cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171441
  003d6	48 8b c8	 mov	 rcx, rax
  003d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3945 : 
; 3946 :     // That's all; the interrupt has been raised, or maybe not...
; 3947 :     return NULL;

  003df	33 c0		 xor	 eax, eax

; 3948 : }   /* End function  ptp_unsol_int_thread() */

  003e1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003e9	48 33 cc	 xor	 rcx, rsp
  003ec	e8 00 00 00 00	 call	 __security_check_cookie
  003f1	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  003f8	c3		 ret	 0
ptp_unsol_int_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPINT$ = 64
pPTPBLK$ = 72
rc$ = 80
tid$ = 84
pPTPATH$ = 88
tv146 = 96
thread_name$ = 104
__$ArrayPad$ = 136
pDEVBLK$ = 160
bStatus$ = 168
iDelay$ = 176
raise_unsol_int PROC

; 3774 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3775 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;   // PTPATH

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0002f	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00036	48 89 44 24 58	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 3776 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;    // PTPBLK

  0003b	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	48 89 44 24 48	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 3777 :     PTPINT*    pPTPINT;                        // PTPINT
; 3778 :     TID        tid;                            // ptp_unsol_int_thread thread ID
; 3779 :     char       thread_name[32];                // ptp_unsol_int_thread
; 3780 :     int        rc;                             // Return code
; 3781 : 
; 3782 : 
; 3783 :     // Obtain the unsolicited interrupt list lock.
; 3784 :     obtain_lock( &pPTPBLK->UnsolListLock );

  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0004d	48 83 c0 50	 add	 rax, 80			; 00000050H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171387
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3785 : 
; 3786 :     // Obtain a PTPINT from the LIFO linked list.
; 3787 :     pPTPINT = pPTPBLK->pFirstPTPINT;                   // Pointer to first PTPINT

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	48 89 44 24 40	 mov	 QWORD PTR pPTPINT$[rsp], rax

; 3788 :     if (pPTPINT)                                       // If there is a PTPINT

  0006f	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPTPINT$[rsp], 0
  00075	74 1d		 je	 SHORT $LN2@raise_unso

; 3789 :     {
; 3790 :         pPTPBLK->pFirstPTPINT = pPTPINT->pNextPTPINT;  // Make the next the first PTPINT

  00077	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPINT$[rsp]
  00081	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00084	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 3791 :         pPTPINT->pNextPTPINT = NULL;                   // Clear the pointer to next PTPINT

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  0008d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@raise_unso:

; 3792 :     }
; 3793 : 
; 3794 :     // Release the unsolicited interrupt list lock.
; 3795 :     release_lock( &pPTPBLK->UnsolListLock );

  00094	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00099	48 83 c0 50	 add	 rax, 80			; 00000050H
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171389
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3796 : 
; 3797 :     // If we did not obtain a PTPINT from the LIFO linked list
; 3798 :     // then allocate storage for a PTPINT.
; 3799 :     if (!pPTPINT)                                      // If there isn't a PTPINT

  000ad	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPTPINT$[rsp], 0
  000b3	75 7c		 jne	 SHORT $LN3@raise_unso

; 3800 :     {
; 3801 :         pPTPINT = alloc_storage( pDEVBLK, (int)sizeof(PTPINT) );

  000b5	ba 15 00 00 00	 mov	 edx, 21
  000ba	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000c2	e8 00 00 00 00	 call	 alloc_storage
  000c7	48 89 44 24 40	 mov	 QWORD PTR pPTPINT$[rsp], rax

; 3802 :         if (!pPTPINT)                                  // If there is no storage

  000cc	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPTPINT$[rsp], 0
  000d2	75 5d		 jne	 SHORT $LN4@raise_unso

; 3803 :         {
; 3804 :             // Report the bad news.
; 3805 :             // HHC00102 "Error in function create_thread(): %s"
; 3806 :             WRMSG(HHC00102, "E", "No storage available!");

  000d4	b9 01 00 00 00	 mov	 ecx, 1
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171392
  000e6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171393
  000f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171394
  000fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00103	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00108	41 b9 03 00 00
	00		 mov	 r9d, 3
  0010e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171395
  00115	ba de 0e 00 00	 mov	 edx, 3806		; 00000edeH
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171396
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3807 :             // Hmm... the interrupt to the y-side will not be raised.
; 3808 :             return -1;

  00127	b8 ff ff ff ff	 mov	 eax, -1
  0012c	e9 16 01 00 00	 jmp	 $LN1@raise_unso
$LN4@raise_unso:
$LN3@raise_unso:

; 3809 :         }
; 3810 :     }
; 3811 : 
; 3812 :     // Initialize the PTPINT.
; 3813 :     pPTPINT->pDEVBLK = pDEVBLK;

  00131	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  00136	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0013e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3814 :     pPTPINT->bStatus = bStatus;

  00142	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  00147	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR bStatus$[rsp]
  0014f	88 48 10	 mov	 BYTE PTR [rax+16], cl

; 3815 :     pPTPINT->iDelay  = iDelay;

  00152	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPINT$[rsp]
  00157	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR iDelay$[rsp]
  0015e	89 48 11	 mov	 DWORD PTR [rax+17], ecx

; 3816 : 
; 3817 :     // Create the unsolicited interrupt thread.
; 3818 :     MSGBUF( thread_name, "%s %4.4X UnsolIntThread",

  00161	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00166	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0016a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0016e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00173	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00177	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0017b	4c 8b 49 50	 mov	 r9, QWORD PTR [rcx+80]
  0017f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171397
  00186	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0018b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR thread_name$[rsp]
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3819 :                          pPTPBLK->pDEVBLKRead->typname,
; 3820 :                          pPTPBLK->pDEVBLKRead->devnum);
; 3821 :     rc = create_thread( &tid, JOINABLE, ptp_unsol_int_thread, pPTPINT, thread_name );

  00196	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0019d	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171398
  001aa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001af	48 8d 4c 24 68	 lea	 rcx, QWORD PTR thread_name$[rsp]
  001b4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001b9	4c 8b 4c 24 40	 mov	 r9, QWORD PTR pPTPINT$[rsp]
  001be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ptp_unsol_int_thread
  001c5	48 8b d0	 mov	 rdx, rax
  001c8	48 8d 4c 24 54	 lea	 rcx, QWORD PTR tid$[rsp]
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  001d3	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 3822 :     if (rc)

  001d7	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  001dc	74 67		 je	 SHORT $LN5@raise_unso

; 3823 :     {
; 3824 :         // Report the bad news.
; 3825 :         // HHC00102 "Error in function create_thread(): %s"
; 3826 :         WRMSG(HHC00102, "E", strerror(rc));

  001de	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001e8	48 89 44 24 60	 mov	 QWORD PTR tv146[rsp], rax
  001ed	b9 01 00 00 00	 mov	 ecx, 1
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv146[rsp]
  001fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171400
  00209	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171401
  00215	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171402
  0022c	ba f2 0e 00 00	 mov	 edx, 3826		; 00000ef2H
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171403
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3827 :         // Hmm... the interrupt to the y-side will not be raised.
; 3828 :         return -2;

  0023e	b8 fe ff ff ff	 mov	 eax, -2
  00243	eb 02		 jmp	 SHORT $LN1@raise_unso
$LN5@raise_unso:

; 3829 :     }
; 3830 : 
; 3831 :     // Good, the thread is active.
; 3832 :     return 0;

  00245	33 c0		 xor	 eax, eax
$LN1@raise_unso:

; 3833 : }   /* End function  raise_unsol_int() */

  00247	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0024f	48 33 cc	 xor	 rcx, rsp
  00252	e8 00 00 00 00	 call	 __security_check_cookie
  00257	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0025e	c3		 ret	 0
raise_unsol_int ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
j$ = 96
fd$ = 100
tv77 = 104
tv81 = 108
tv138 = 112
tv142 = 116
tv163 = 120
tv167 = 124
tv189 = 128
tv193 = 132
addr6$ = 136
__$ArrayPad$ = 152
pDEVBLK$ = 192
pPTPBLK$ = 200
check_specified_value PROC

; 3688 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3689 : #if defined(ENABLE_IPV6)
; 3690 :     struct in6_addr addr6;             /* Work area for IPv6 addresses */
; 3691 :     int             fd;
; 3692 :     int             j;
; 3693 : #endif /* defined(ENABLE_IPV6) */
; 3694 : 
; 3695 : 
; 3696 :     // If IPv4 addresses were specified check that the same IPv4 address
; 3697 :     // has not been specified for the guest and driver.
; 3698 :     if (pPTPBLK->fIPv4Spec &&

  00025	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0002d	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	0f 84 b6 00 00
	00		 je	 $LN5@check_spec
  0003b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00043	48 05 d8 02 00
	00		 add	 rax, 728		; 000002d8H
  00049	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00051	48 81 c1 dc 02
	00 00		 add	 rcx, 732		; 000002dcH
  00058	41 b8 04 00 00
	00		 mov	 r8d, 4
  0005e	48 8b d0	 mov	 rdx, rax
  00061	e8 00 00 00 00	 call	 memcmp
  00066	85 c0		 test	 eax, eax
  00068	0f 85 83 00 00
	00		 jne	 $LN5@check_spec

; 3699 :         memcmp( &pPTPBLK->iaGuestIPAddr4, &pPTPBLK->iaDriveIPAddr4, 4 ) == 0)
; 3700 :     {
; 3701 :         // HHC03901 "%1d:%04X PTP: Guest and driver IP addresses are the same"
; 3702 :         WRMSG(HHC03901, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum );

  0006e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00076	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0007a	89 44 24 68	 mov	 DWORD PTR tv77[rsp], eax
  0007e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00086	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0008a	d1 f9		 sar	 ecx, 1
  0008c	89 4c 24 6c	 mov	 DWORD PTR tv81[rsp], ecx
  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009b	8b 4c 24 68	 mov	 ecx, DWORD PTR tv77[rsp]
  0009f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000a3	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv81[rsp]
  000a7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171348
  000b2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171349
  000be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171350
  000d5	ba 76 0e 00 00	 mov	 edx, 3702		; 00000e76H
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171351
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3703 :         return -1;

  000e7	b8 ff ff ff ff	 mov	 eax, -1
  000ec	e9 87 03 00 00	 jmp	 $LN1@check_spec
$LN5@check_spec:

; 3704 :     }
; 3705 : 
; 3706 : #if defined(ENABLE_IPV6)
; 3707 :     // If IPv6 addresses were specified check that the same IPv6 address
; 3708 :     // has not been specified for the guest and driver.
; 3709 :     if (pPTPBLK->fIPv6Spec &&

  000f1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000f9	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000fc	d1 e8		 shr	 eax, 1
  000fe	83 e0 01	 and	 eax, 1
  00101	85 c0		 test	 eax, eax
  00103	0f 84 b6 00 00
	00		 je	 $LN6@check_spec
  00109	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00111	48 05 e0 02 00
	00		 add	 rax, 736		; 000002e0H
  00117	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0011f	48 81 c1 f0 02
	00 00		 add	 rcx, 752		; 000002f0H
  00126	41 b8 10 00 00
	00		 mov	 r8d, 16
  0012c	48 8b d0	 mov	 rdx, rax
  0012f	e8 00 00 00 00	 call	 memcmp
  00134	85 c0		 test	 eax, eax
  00136	0f 85 83 00 00
	00		 jne	 $LN6@check_spec

; 3710 :         memcmp( &pPTPBLK->iaGuestIPAddr6, &pPTPBLK->iaDriveIPAddr6, 16 ) == 0)
; 3711 :     {
; 3712 :         // HHC03901 "%1d:%04X PTP: Guest and driver IP addresses are the same"
; 3713 :         WRMSG(HHC03901, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum );

  0013c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00144	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00148	89 44 24 70	 mov	 DWORD PTR tv138[rsp], eax
  0014c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00154	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00158	d1 f9		 sar	 ecx, 1
  0015a	89 4c 24 74	 mov	 DWORD PTR tv142[rsp], ecx
  0015e	b9 01 00 00 00	 mov	 ecx, 1
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00169	8b 4c 24 70	 mov	 ecx, DWORD PTR tv138[rsp]
  0016d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00171	8b 4c 24 74	 mov	 ecx, DWORD PTR tv142[rsp]
  00175	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171353
  00180	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171354
  0018c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00191	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00196	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171355
  001a3	ba 81 0e 00 00	 mov	 edx, 3713		; 00000e81H
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171356
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3714 :         return -1;

  001b5	b8 ff ff ff ff	 mov	 eax, -1
  001ba	e9 b9 02 00 00	 jmp	 $LN1@check_spec
$LN6@check_spec:

; 3715 :     }
; 3716 : 
; 3717 :     // If IPv6 addresses were specified check that IPv6 is supported on
; 3718 :     // this machine.
; 3719 :     if (pPTPBLK->fIPv6Spec)

  001bf	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001c7	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001ca	d1 e8		 shr	 eax, 1
  001cc	83 e0 01	 and	 eax, 1
  001cf	85 c0		 test	 eax, eax
  001d1	0f 84 b1 00 00
	00		 je	 $LN7@check_spec

; 3720 :     {
; 3721 :         fd = socket( AF_INET6, SOCK_DGRAM, 0 );

  001d7	45 33 c0	 xor	 r8d, r8d
  001da	ba 02 00 00 00	 mov	 edx, 2
  001df	b9 17 00 00 00	 mov	 ecx, 23
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  001ea	89 44 24 64	 mov	 DWORD PTR fd$[rsp], eax

; 3722 :         if (fd < 0)

  001ee	83 7c 24 64 00	 cmp	 DWORD PTR fd$[rsp], 0
  001f3	0f 8d 85 00 00
	00		 jge	 $LN8@check_spec

; 3723 :         {
; 3724 :             // HHC03902 "%1d:%04X PTP: Inet6 not supported"
; 3725 :             WRMSG(HHC03902, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum );

  001f9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00201	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00205	89 44 24 78	 mov	 DWORD PTR tv163[rsp], eax
  00209	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00211	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00215	d1 f9		 sar	 ecx, 1
  00217	89 4c 24 7c	 mov	 DWORD PTR tv167[rsp], ecx
  0021b	b9 01 00 00 00	 mov	 ecx, 1
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00226	8b 4c 24 78	 mov	 ecx, DWORD PTR tv163[rsp]
  0022a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0022e	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv167[rsp]
  00232	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171360
  0023d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171361
  00249	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00253	41 b9 03 00 00
	00		 mov	 r9d, 3
  00259	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171362
  00260	ba 8d 0e 00 00	 mov	 edx, 3725		; 00000e8dH
  00265	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171363
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3726 :             return -1;

  00272	b8 ff ff ff ff	 mov	 eax, -1
  00277	e9 fc 01 00 00	 jmp	 $LN1@check_spec

; 3727 :         }

  0027c	eb 0a		 jmp	 SHORT $LN9@check_spec
$LN8@check_spec:

; 3728 :         else
; 3729 :         {
; 3730 :             close( fd );

  0027e	8b 4c 24 64	 mov	 ecx, DWORD PTR fd$[rsp]
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN9@check_spec:
$LN7@check_spec:

; 3731 :         }
; 3732 :     }
; 3733 : 
; 3734 :     // If IPv6 addresses were specified check that the MTU size is at
; 3735 :     // least the minimum size for an IPv6 link.
; 3736 :     if (pPTPBLK->fIPv6Spec &&

  00288	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00290	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00293	d1 e8		 shr	 eax, 1
  00295	83 e0 01	 and	 eax, 1
  00298	85 c0		 test	 eax, eax
  0029a	0f 84 ed 00 00
	00		 je	 $LN10@check_spec
  002a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002a8	81 b8 d4 02 00
	00 00 05 00 00	 cmp	 DWORD PTR [rax+724], 1280 ; 00000500H
  002b2	0f 8d d5 00 00
	00		 jge	 $LN10@check_spec

; 3737 :         pPTPBLK->iMTU < 1280)
; 3738 :     {
; 3739 :         // HHC03918 "%1d:%04X PTP: MTU changed from size %d bytes to size %d bytes"
; 3740 :         WRMSG(HHC03918, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pPTPBLK->iMTU, 1280 );

  002b8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002c0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002c4	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv189[rsp], eax
  002cb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002d3	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  002d7	d1 f9		 sar	 ecx, 1
  002d9	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv193[rsp], ecx
  002e0	b9 01 00 00 00	 mov	 ecx, 1
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002eb	c7 44 24 50 00
	05 00 00	 mov	 DWORD PTR [rsp+80], 1280 ; 00000500H
  002f3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  002fb	8b 89 d4 02 00
	00		 mov	 ecx, DWORD PTR [rcx+724]
  00301	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00305	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  0030c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00310	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv193[rsp]
  00317	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171365
  00322	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171366
  0032e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00333	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00338	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171367
  00345	ba 9c 0e 00 00	 mov	 edx, 3740		; 00000e9cH
  0034a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171368
  00351	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3741 :         STRLCPY( pPTPBLK->szMTU, "1280" );

  00357	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0035f	48 05 94 01 00
	00		 add	 rax, 404		; 00000194H
  00365	41 b8 08 00 00
	00		 mov	 r8d, 8
  0036b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171369
  00372	48 8b c8	 mov	 rcx, rax
  00375	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3742 :         pPTPBLK->iMTU = 1280;

  0037b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00383	c7 80 d4 02 00
	00 00 05 00 00	 mov	 DWORD PTR [rax+724], 1280 ; 00000500H
$LN10@check_spec:

; 3743 :     }
; 3744 : 
; 3745 :     // If IPv6 addresses were specified create a Driver Link Local IPv6
; 3746 :     // address using pseudo-random numbers.
; 3747 :     if (pPTPBLK->fIPv6Spec)

  0038d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00395	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00398	d1 e8		 shr	 eax, 1
  0039a	83 e0 01	 and	 eax, 1
  0039d	85 c0		 test	 eax, eax
  0039f	0f 84 d1 00 00
	00		 je	 $LN11@check_spec

; 3748 :     {
; 3749 :         addr6.s6_addr[0] = 0xFE;

  003a5	b8 01 00 00 00	 mov	 eax, 1
  003aa	48 6b c0 00	 imul	 rax, rax, 0
  003ae	c6 84 04 88 00
	00 00 fe	 mov	 BYTE PTR addr6$[rsp+rax], 254 ; 000000feH

; 3750 :         addr6.s6_addr[1] = 0x80;

  003b6	b8 01 00 00 00	 mov	 eax, 1
  003bb	48 6b c0 01	 imul	 rax, rax, 1
  003bf	c6 84 04 88 00
	00 00 80	 mov	 BYTE PTR addr6$[rsp+rax], 128 ; 00000080H

; 3751 :         memset( &addr6.s6_addr[2], 0, 6 );

  003c7	b8 01 00 00 00	 mov	 eax, 1
  003cc	48 6b c0 02	 imul	 rax, rax, 2
  003d0	48 8d 84 04 88
	00 00 00	 lea	 rax, QWORD PTR addr6$[rsp+rax]
  003d8	48 8b f8	 mov	 rdi, rax
  003db	33 c0		 xor	 eax, eax
  003dd	b9 06 00 00 00	 mov	 ecx, 6
  003e2	f3 aa		 rep stosb

; 3752 :         for( j = 8; j < 16; j++ )

  003e4	c7 44 24 60 08
	00 00 00	 mov	 DWORD PTR j$[rsp], 8
  003ec	eb 0a		 jmp	 SHORT $LN4@check_spec
$LN2@check_spec:
  003ee	8b 44 24 60	 mov	 eax, DWORD PTR j$[rsp]
  003f2	ff c0		 inc	 eax
  003f4	89 44 24 60	 mov	 DWORD PTR j$[rsp], eax
$LN4@check_spec:
  003f8	83 7c 24 60 10	 cmp	 DWORD PTR j$[rsp], 16
  003fd	7d 2c		 jge	 SHORT $LN3@check_spec

; 3753 :             addr6.s6_addr[j] = (int)((rand()/(RAND_MAX+1.0))*256);

  003ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00405	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00409	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  00411	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4070000000000000
  00419	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0041d	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR j$[rsp]
  00422	88 84 0c 88 00
	00 00		 mov	 BYTE PTR addr6$[rsp+rcx], al
  00429	eb c3		 jmp	 SHORT $LN2@check_spec
$LN3@check_spec:

; 3754 : 
; 3755 :         hinet_ntop( AF_INET6, &addr6, pPTPBLK->szDriveLLAddr6, sizeof(pPTPBLK->szDriveLLAddr6) );

  0042b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00433	48 05 68 02 00
	00		 add	 rax, 616		; 00000268H
  00439	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  0043f	4c 8b c0	 mov	 r8, rax
  00442	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR addr6$[rsp]
  0044a	b9 17 00 00 00	 mov	 ecx, 23
  0044f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 3756 :         memcpy( &pPTPBLK->iaDriveLLAddr6, &addr6, sizeof(pPTPBLK->iaDriveLLAddr6) );

  00455	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0045d	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR addr6$[rsp]
  00465	48 8d b8 00 03
	00 00		 lea	 rdi, QWORD PTR [rax+768]
  0046c	48 8b f1	 mov	 rsi, rcx
  0046f	b9 10 00 00 00	 mov	 ecx, 16
  00474	f3 a4		 rep movsb
$LN11@check_spec:

; 3757 :     }
; 3758 : #endif /* defined(ENABLE_IPV6) */
; 3759 : 
; 3760 :     // That's all folks.
; 3761 :     return 0;

  00476	33 c0		 xor	 eax, eax
$LN1@check_spec:

; 3762 : }   /* End function  check_specified_value() */

  00478	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00480	48 33 cc	 xor	 rcx, rsp
  00483	e8 00 00 00 00	 call	 __security_check_cookie
  00488	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0048f	5f		 pop	 rdi
  00490	5e		 pop	 rsi
  00491	c3		 ret	 0
check_specified_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
tv69 = 96
tv73 = 100
tv64 = 104
pDEVBLK$ = 128
pPTPBLK$ = 136
get_preconfigured_value PROC

; 3316 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3317 : 
; 3318 : #if defined(OPTION_W32_CTCI)
; 3319 :     // HHC03965 "%id:%04X %s; Preconfigured interface %s does not exist or is not accessible by Hercules"
; 3320 :     WRMSG(HHC03965, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0000e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00016	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  0001c	48 89 44 24 68	 mov	 QWORD PTR tv64[rsp], rax
  00021	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00029	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0002d	89 4c 24 60	 mov	 DWORD PTR tv69[rsp], ecx
  00031	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00039	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0003d	d1 fa		 sar	 edx, 1
  0003f	89 54 24 64	 mov	 DWORD PTR tv73[rsp], edx
  00043	b9 01 00 00 00	 mov	 ecx, 1
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv64[rsp]
  00053	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00060	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00064	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00069	8b 4c 24 60	 mov	 ecx, DWORD PTR tv69[rsp]
  0006d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00071	8b 4c 24 64	 mov	 ecx, DWORD PTR tv73[rsp]
  00075	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171331
  00080	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171332
  0008c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00091	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00096	41 b9 03 00 00
	00		 mov	 r9d, 3
  0009c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171333
  000a3	ba f9 0c 00 00	 mov	 edx, 3321		; 00000cf9H
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171334
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3321 :                          pPTPBLK->szTUNIfName);
; 3322 :     return -1;

  000b5	b8 ff ff ff ff	 mov	 eax, -1

; 3323 : #else /* defined(OPTION_W32_CTCI) */
; 3324 : /* Extract from Linux getifaddrs/freeifaddrs man page */
; 3325 : //
; 3326 : //    struct ifaddrs {
; 3327 : //         struct ifaddrs  *ifa_next;    /* Next item in list */
; 3328 : //         char            *ifa_name;    /* Name of interface */
; 3329 : //         unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */
; 3330 : //         struct sockaddr *ifa_addr;    /* Address of interface */
; 3331 : //         struct sockaddr *ifa_netmask; /* Netmask of interface */
; 3332 : //         union {
; 3333 : //             struct sockaddr *ifu_broadaddr;
; 3334 : //                              /* Broadcast address of interface */
; 3335 : //             struct sockaddr *ifu_dstaddr;
; 3336 : //                              /* Point-to-point destination address */
; 3337 : //         } ifa_ifu;
; 3338 : //     #define              ifa_broadaddr ifa_ifu.ifu_broadaddr
; 3339 : //     #define              ifa_dstaddr   ifa_ifu.ifu_dstaddr
; 3340 : //         void            *ifa_data;    /* Address-specific data */
; 3341 : //     };
; 3342 : //
; 3343 : //   The ifa_next field contains a pointer to the next structure on the list, or
; 3344 : //   NULL if this is the last item of the list.
; 3345 : //
; 3346 : //   The ifa_name points to the null-terminated interface name.
; 3347 : //
; 3348 : //   The ifa_flags field contains the interface flags, as returned by the
; 3349 : //   SIOCGIFFLAGS ioctl(2) operation (see netdevice(7) for a list of these flags).
; 3350 : //
; 3351 : //   The ifa_addr field points to a structure containing the interface address.
; 3352 : //   (The sa_family subfield should be consulted to determine the format of the
; 3353 : //   address structure.)
; 3354 : //
; 3355 : //   The ifa_netmask field points to a structure containing the netmask associated
; 3356 : //   with ifa_addr, if applicable for the address family.
; 3357 : //
; 3358 : //   Depending on whether the bit IFF_BROADCAST or IFF_POINTOPOINT is set in
; 3359 : //   ifa_flags (only one can be set at a time), either ifa_broadaddr will contain
; 3360 : //   the broadcast address associated with ifa_addr (if applicable for the address
; 3361 : //   family) or ifa_dstaddr will contain the destination address of the point-to-
; 3362 : //   point interface.
; 3363 : //
; 3364 : //   The ifa_data field points to a buffer containing address-family-specific data;
; 3365 : //   this field may be NULL if there is no such data for this interface.
; 3366 : //
; 3367 : //   The data returned by getifaddrs() is dynamically allocated and should be freed
; 3368 : //   using freeifaddrs() when no longer needed.
; 3369 : //
; 3370 : //
; 3371 : //   On success, getifaddrs() returns zero; on error, -1 is returned, and errno is
; 3372 : //   set appropriately.
; 3373 : //
; 3374 : //   The addresses returned on Linux will usually be the IPv4 and IPv6 addresses
; 3375 : //   assigned to the interface, but also one AF_PACKET address per interface
; 3376 : //   containing lower-level details about the interface and its physical layer. In
; 3377 : //   this case, the ifa_data field may contain a pointer to a struct
; 3378 : //   net_device_stats, defined in <linux/netdevice.h>, which contains various
; 3379 : //   interface attributes and statistics.
; 3380 : //
; 3381 :     struct ifaddrs      *ifaddr;
; 3382 :     struct ifaddrs      *ifacur;
; 3383 :     int family;
; 3384 :     u_int                have_name = FALSE;
; 3385 :     struct sockaddr_in  *sin;
; 3386 :     struct in_addr       drive4;
; 3387 :     struct in_addr       guest4;
; 3388 :     struct in_addr       mask4;
; 3389 :     u_int                have_drive4 = FALSE;
; 3390 :     u_int                have_guest4 = FALSE;
; 3391 :     u_int                have_mask4 = FALSE;
; 3392 : #if defined(ENABLE_IPV6)
; 3393 :     struct sockaddr_in6 *sin6;
; 3394 :     struct in6_addr      addr6;
; 3395 :     struct in6_addr      mask6;
; 3396 :     struct in6_addr      adll6;
; 3397 :     struct in6_addr      mall6;
; 3398 :     u_int                have_addr6 = FALSE;
; 3399 :     u_int                have_mask6 = FALSE;
; 3400 :     u_int                have_adll6 = FALSE;
; 3401 :     u_int                have_mall6 = FALSE;
; 3402 :     struct in6_addr      work6;
; 3403 : #endif /* defined(ENABLE_IPV6) */
; 3404 :     struct {
; 3405 :       union {
; 3406 :         struct in_addr   ip4;
; 3407 : #if defined(ENABLE_IPV6)
; 3408 :         struct in6_addr  ip6;
; 3409 : #endif /* defined(ENABLE_IPV6) */
; 3410 :         unsigned int     uint[4];
; 3411 :       }                mask;
; 3412 :       unsigned int       bit;
; 3413 :       int                size;
; 3414 :     }                pfx;
; 3415 :     int                  fd, rc, j;
; 3416 :     struct hifr          hifr;
; 3417 : 
; 3418 : 
; 3419 :     /* */
; 3420 :     memset( &drive4, 0, sizeof(drive4) );
; 3421 :     memset( &guest4, 0, sizeof(guest4) );
; 3422 :     memset( &mask4, 0, sizeof(mask4) );
; 3423 : #if defined(ENABLE_IPV6)
; 3424 :     memset( &addr6, 0, sizeof(addr6) );
; 3425 :     memset( &mask6, 0, sizeof(mask6) );
; 3426 :     memset( &adll6, 0, sizeof(adll6) );
; 3427 :     memset( &mall6, 0, sizeof(mall6) );
; 3428 : #endif /* defined(ENABLE_IPV6) */
; 3429 : 
; 3430 :     /* Get the address information for all of the interfaces */
; 3431 :     if (getifaddrs(&ifaddr) == -1) {
; 3432 :         // HHC00900 "%1d:%04X %s: error in function %s: %s"
; 3433 :         WRMSG(HHC00900, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3434 :                              "getifaddrs", strerror(errno) );
; 3435 :         return -1;
; 3436 :     }
; 3437 : 
; 3438 :     /* Process the ifaddr structure(s) for the tun */
; 3439 :     /* interface in the chain of ifaddr structures */
; 3440 :     for (ifacur = ifaddr; ifacur != NULL; ifacur = ifacur->ifa_next) {
; 3441 :       if (strcmp(ifacur->ifa_name, pPTPBLK->szTUNIfName) == 0) {
; 3442 :         have_name = TRUE;
; 3443 : 
; 3444 :         /* Extract info from the ifaddr structure for the tun interface */
; 3445 :         if (ifacur->ifa_addr != NULL) {
; 3446 :           family = ifacur->ifa_addr->sa_family;
; 3447 :           if (family == AF_INET) {
; 3448 :             /* If the tun device was configured with an IP command with the */
; 3449 :             /* form:-                                                       */
; 3450 :             /*   ip -f inet addr add dev tun99 192.168.1.1                  */
; 3451 :             /* the device address and the peer (destination) address will   */
; 3452 :             /* be the identical.                                            */
; 3453 :             /* If the tun device was configured with an IP command with the */
; 3454 :             /* form:-                                                       */
; 3455 :             /*   ip -f inet addr add dev tun99 192.168.1.1 peer 192.168.1.2 */
; 3456 :             /* the device address and the peer (destination) address will   */
; 3457 :             /* be different (obviously!).                                   */
; 3458 :             if (!have_drive4) {
; 3459 :               sin = (struct sockaddr_in*)ifacur->ifa_addr;
; 3460 :               memcpy( &drive4, &sin->sin_addr, sizeof(drive4) );
; 3461 :               have_drive4 = TRUE;
; 3462 :               sin = (struct sockaddr_in*)ifacur->ifa_netmask;
; 3463 :               memcpy( &mask4, &sin->sin_addr, sizeof(mask4) );
; 3464 :               have_mask4 = TRUE;
; 3465 :               if ((ifacur->ifa_flags & IFF_POINTOPOINT) && ifacur->ifa_dstaddr) {
; 3466 :                 sin = (struct sockaddr_in*)ifacur->ifa_dstaddr;
; 3467 :                 memset( &guest4, 0, sizeof(guest4) );
; 3468 :                 if ( (memcmp(&drive4, &sin->sin_addr, sizeof(drive4)) != 0) &&
; 3469 :                      (memcmp(&guest4, &sin->sin_addr, sizeof(guest4)) != 0) ) {
; 3470 :                   memcpy( &guest4, &sin->sin_addr, sizeof(guest4) );
; 3471 :                   have_guest4 = TRUE;
; 3472 :                 }
; 3473 :               }
; 3474 :             }
; 3475 : #if defined(ENABLE_IPV6)
; 3476 :           } else if (family == AF_INET6) {
; 3477 :             sin6 = (struct sockaddr_in6*)ifacur->ifa_addr;
; 3478 :             memset( work6.s6_addr, 0, 16 );
; 3479 :             work6.s6_addr[0] = 0xFE;
; 3480 :             work6.s6_addr[1] = 0x80;
; 3481 :             if (memcmp( &sin6->sin6_addr, &work6, 8 ) != 0) {
; 3482 :               if (!have_addr6) {
; 3483 :                 sin6 = (struct sockaddr_in6*)ifacur->ifa_addr;
; 3484 :                 memcpy( &addr6, &sin6->sin6_addr, sizeof(addr6) );
; 3485 :                 have_addr6 = TRUE;
; 3486 :                 sin6 = (struct sockaddr_in6*)ifacur->ifa_netmask;
; 3487 :                 memcpy( &mask6, &sin6->sin6_addr, sizeof(mask6) );
; 3488 :                 have_mask6 = TRUE;
; 3489 :               }
; 3490 :             } else {
; 3491 :               if (!have_adll6) {
; 3492 :                 sin6 = (struct sockaddr_in6*)ifacur->ifa_addr;
; 3493 :                 memcpy( &adll6, &sin6->sin6_addr, sizeof(adll6) );
; 3494 :                 have_adll6 = TRUE;
; 3495 :                 sin6 = (struct sockaddr_in6*)ifacur->ifa_netmask;
; 3496 :                 memcpy( &mall6, &sin6->sin6_addr, sizeof(mall6) );
; 3497 :                 have_mall6 = TRUE;
; 3498 :               }
; 3499 :             }
; 3500 : #endif /* defined(ENABLE_IPV6) */
; 3501 :           }
; 3502 :         } /* End of   if (ifacur->ifa_addr != NULL) */
; 3503 : 
; 3504 :       } /* End of  if (strcmp(ifa_name, pPTPBLK->szTUNIfName) == 0) */
; 3505 :     } /* End of  for (ifacur = ifaddr; ifacur != NULL; ifacur = ifacur->ifa_next) */
; 3506 : 
; 3507 :     /* Dispose of all of the returned ifaddrs structures */
; 3508 :     freeifaddrs(ifaddr);
; 3509 : 
; 3510 :     /* Check whether the interface exists */
; 3511 :     if (!have_name) {
; 3512 :         // HHC03965 "%id:%04X %s; Preconfigured interface %s does not exist or is not accessible by Hercules"
; 3513 :         WRMSG(HHC03965, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3514 :                          pPTPBLK->szTUNIfName);
; 3515 :         return -1;
; 3516 :     }
; 3517 : 
; 3518 :     /* Process the extracted IPv4 addresses and netmask */
; 3519 :     if (have_drive4 && have_mask4) {
; 3520 :         hinet_ntop( AF_INET, &drive4, pPTPBLK->szDriveIPAddr4, sizeof(pPTPBLK->szDriveIPAddr4) );
; 3521 :         memcpy( &pPTPBLK->iaDriveIPAddr4, &drive4, sizeof(pPTPBLK->iaDriveIPAddr4) );
; 3522 :         memcpy( &pfx.mask.ip4, &mask4, sizeof(mask4) );
; 3523 :         pfx.mask.uint[0] = ntohl(pfx.mask.uint[0]);
; 3524 :         pfx.size = 0;
; 3525 :         pfx.bit = 0x80000000;
; 3526 :         while (pfx.bit) {
; 3527 :           if (pfx.mask.uint[0] & pfx.bit) {
; 3528 :             pfx.size++;
; 3529 :           }
; 3530 :           pfx.bit >>= 1;
; 3531 :         }
; 3532 :         snprintf( pPTPBLK->szDrivePfxSiz4, sizeof(pPTPBLK->szDrivePfxSiz4), "%d", pfx.size );
; 3533 :         hinet_ntop( AF_INET, &mask4, pPTPBLK->szNetMask, sizeof(pPTPBLK->szNetMask) );
; 3534 :         if (have_guest4) {
; 3535 :           hinet_ntop( AF_INET, &guest4, pPTPBLK->szGuestIPAddr4, sizeof(pPTPBLK->szGuestIPAddr4) );
; 3536 :           memcpy( &pPTPBLK->iaGuestIPAddr4, &guest4, sizeof(pPTPBLK->iaGuestIPAddr4) );
; 3537 :           pPTPBLK->fPreGuestIPAddr4 = TRUE;
; 3538 :         }
; 3539 :         pPTPBLK->fIPv4Spec = TRUE;
; 3540 :     }
; 3541 :     else if (!have_drive4 && !have_mask4) {
; 3542 :         pPTPBLK->fIPv4Spec = FALSE;
; 3543 :     }
; 3544 :     else {
; 3545 :         // HHC03965 "%id:%04X %s; Preconfigured interface %s does not exist or is not accessible by Hercules"
; 3546 :         WRMSG(HHC03965, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3547 :                          pPTPBLK->szTUNIfName);
; 3548 :         return -1;
; 3549 :     }
; 3550 : 
; 3551 : #if defined(ENABLE_IPV6)
; 3552 :     /* Process the extracted IPv6 addresses and masks */
; 3553 :     if (have_addr6 && have_mask6) {
; 3554 :         /* Setup drive IPv6 addresses */
; 3555 :         hinet_ntop( AF_INET6, &addr6, pPTPBLK->szDriveIPAddr6, sizeof(pPTPBLK->szDriveIPAddr6) );
; 3556 :         memcpy( &pPTPBLK->iaDriveIPAddr6, &addr6, sizeof(pPTPBLK->iaDriveIPAddr6) );
; 3557 :         /* Setup drive IPv6 prefix length */
; 3558 :         memcpy( &pfx.mask.ip6, &mask6, sizeof(mask6) );
; 3559 :         pfx.mask.uint[0] = ntohl(pfx.mask.uint[0]);
; 3560 :         pfx.mask.uint[1] = ntohl(pfx.mask.uint[1]);
; 3561 :         pfx.mask.uint[2] = ntohl(pfx.mask.uint[2]);
; 3562 :         pfx.mask.uint[3] = ntohl(pfx.mask.uint[3]);
; 3563 :         pfx.size = 0;
; 3564 :         for (j = 0; j <= 3; j++) {
; 3565 :           if (pfx.mask.uint[j] == 0x00000000)
; 3566 :             break;
; 3567 :           if (pfx.mask.uint[j] == 0xFFFFFFFF) {
; 3568 :             pfx.size += 32;
; 3569 :           } else {
; 3570 :             pfx.bit = 0x80000000;
; 3571 :             while (pfx.bit) {
; 3572 :               if (pfx.mask.uint[j] & pfx.bit) {
; 3573 :                 pfx.size++;
; 3574 :               }
; 3575 :               pfx.bit >>= 1;
; 3576 :             }
; 3577 :           }
; 3578 :         }
; 3579 :         snprintf( pPTPBLK->szDrivePfxSiz6, sizeof(pPTPBLK->szDrivePfxSiz6), "%d", pfx.size );
; 3580 :         if (have_adll6 && have_mall6) {
; 3581 :           /* Setup drive IPv6 link local address */
; 3582 :           hinet_ntop( AF_INET6, &adll6, pPTPBLK->szDriveLLAddr6, sizeof(pPTPBLK->szDriveLLAddr6) );
; 3583 :           memcpy( &pPTPBLK->iaDriveLLAddr6, &adll6, sizeof(pPTPBLK->iaDriveLLAddr6) );
; 3584 :           /* Setup drive IPv6 link local prefix length */
; 3585 :           memcpy( &pfx.mask.ip6, &mall6, sizeof(mall6) );
; 3586 :           pfx.mask.uint[0] = ntohl(pfx.mask.uint[0]);
; 3587 :           pfx.mask.uint[1] = ntohl(pfx.mask.uint[1]);
; 3588 :           pfx.mask.uint[2] = ntohl(pfx.mask.uint[2]);
; 3589 :           pfx.mask.uint[3] = ntohl(pfx.mask.uint[3]);
; 3590 :           pfx.size = 0;
; 3591 :           for (j = 0; j <= 3; j++) {
; 3592 :             if (pfx.mask.uint[j] == 0x00000000)
; 3593 :               break;
; 3594 :             if (pfx.mask.uint[j] == 0xFFFFFFFF) {
; 3595 :               pfx.size += 32;
; 3596 :             } else {
; 3597 :               pfx.bit = 0x80000000;
; 3598 :               while (pfx.bit) {
; 3599 :                 if (pfx.mask.uint[j] & pfx.bit) {
; 3600 :                   pfx.size++;
; 3601 :                 }
; 3602 :                 pfx.bit >>= 1;
; 3603 :               }
; 3604 :             }
; 3605 :           }
; 3606 :           snprintf( pPTPBLK->szDriveLLxSiz6, sizeof(pPTPBLK->szDriveLLxSiz6), "%d", pfx.size );
; 3607 :         } else {
; 3608 :           // Create a Driver Link Local address using pseudo-random numbers.
; 3609 :           addr6.s6_addr[0] = 0xFE;
; 3610 :           addr6.s6_addr[1] = 0x80;
; 3611 :           memset( &addr6.s6_addr[2], 0, 6 );
; 3612 :           for( j = 8; j < 16; j++ )
; 3613 :               addr6.s6_addr[j] = (int)((rand()/(RAND_MAX+1.0))*256);
; 3614 :           hinet_ntop( AF_INET6, &addr6, pPTPBLK->szDriveLLAddr6, sizeof(pPTPBLK->szDriveLLAddr6) );
; 3615 :           memcpy( &pPTPBLK->iaDriveLLAddr6, &addr6, sizeof(pPTPBLK->iaDriveLLAddr6) );
; 3616 :         }
; 3617 :         pPTPBLK->fIPv6Spec = TRUE;
; 3618 :     }
; 3619 :     else if (!have_addr6 && !have_mask6 && !have_adll6 && !have_mall6) {
; 3620 :         pPTPBLK->fIPv6Spec = FALSE;
; 3621 :     }
; 3622 :     else {
; 3623 :         // HHC03965 "%id:%04X %s; Preconfigured interface %s does not exist or is not accessible by Hercules"
; 3624 :         WRMSG(HHC03965, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3625 :                          pPTPBLK->szTUNIfName);
; 3626 :         return -1;
; 3627 :     }
; 3628 : #endif /* defined(ENABLE_IPV6) */
; 3629 : 
; 3630 :     /* Check that either IPv4 or IPv6 addresses were extracted */
; 3631 :     if (!pPTPBLK->fIPv4Spec
; 3632 : #if defined(ENABLE_IPV6)
; 3633 :                        && !pPTPBLK->fIPv6Spec
; 3634 : #endif /* defined(ENABLE_IPV6) */
; 3635 :                                    )
; 3636 :     {
; 3637 :         // HHC03965 "%id:%04X %s; Preconfigured interface %s does not exist or is not accessible by Hercules"
; 3638 :         WRMSG(HHC03965, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3639 :                          pPTPBLK->szTUNIfName);
; 3640 :         return -1;
; 3641 :     }
; 3642 : 
; 3643 :     /* Obtain the MTU value */
; 3644 :     memset( &hifr, 0, sizeof(struct hifr) );
; 3645 :     strncpy( hifr.hifr_name, pPTPBLK->szTUNIfName, sizeof(hifr.hifr_name)-1 );
; 3646 : 
; 3647 :     fd = socket(AF_INET, SOCK_STREAM, 0);
; 3648 :     rc = TUNTAP_IOCtl( fd, SIOCGIFMTU, (char*)&hifr );
; 3649 :     close(fd);
; 3650 : 
; 3651 :     if (rc < 0) {
; 3652 :         // HHC00902 "%1d:%04X %s: ioctl '%s' failed for device '%s': '%s'"
; 3653 :         WRMSG(HHC00902, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3654 :                              "SIOCGIFMTU", pPTPBLK->szTUNIfName, strerror(errno) );
; 3655 :         return -1;
; 3656 :     }
; 3657 : 
; 3658 :     pPTPBLK->iMTU = hifr.hifr_mtu;
; 3659 :     snprintf( pPTPBLK->szMTU, sizeof(pPTPBLK->szMTU), "%d", hifr.hifr_mtu );
; 3660 : 
; 3661 : //  // HHC03953 "%1d:%04X PTP: IPv4: Drive %s/%s (%s): Guest %s"
; 3662 : //  WRMSG(HHC03953, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,
; 3663 : //      pPTPBLK->szDriveIPAddr4,
; 3664 : //      pPTPBLK->szDrivePfxSiz4,
; 3665 : //      pPTPBLK->szNetMask,
; 3666 : //      pPTPBLK->szGuestIPAddr4 );
; 3667 : //  // HHC03954 "%1d:%04X PTP: IPv6: Drive %s/%s %s/%s: Guest %s"
; 3668 : //  WRMSG(HHC03954, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,
; 3669 : //      pPTPBLK->szDriveLLAddr6,
; 3670 : //      pPTPBLK->szDriveLLxSiz6,
; 3671 : //      pPTPBLK->szDriveIPAddr6,
; 3672 : //      pPTPBLK->szDrivePfxSiz6,
; 3673 : //      pPTPBLK->szGuestIPAddr6 );
; 3674 : 
; 3675 : //  mpc_display_stuff( pDEVBLK, "sockaddr_in6", (BYTE*)sin6, sizeof(struct sockaddr_in6), ' ' );
; 3676 : //  mpc_display_stuff( pDEVBLK, "work6", (BYTE*)&work6, sizeof(struct in6_addr), ' ' );
; 3677 : //  mpc_display_stuff( pDEVBLK, "sin6_addr", (BYTE*)&sin6->sin6_addr, sizeof(addr6), ' ' );
; 3678 : 
; 3679 :     /* That's all folks. */
; 3680 :     return 0;
; 3681 : #endif /* defined(OPTION_W32_CTCI) */
; 3682 : }   /* End function  get_preconfigured_value() */

  000ba	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000be	c3		 ret	 0
get_preconfigured_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
j$ = 96
argv$ = 104
rc$ = 112
cpprfx$ = 120
iPfxSiz$ = 128
iWantFamily$ = 132
ilhost$ = 136
cphost$ = 144
iFirstFamily$ = 152
tv164 = 160
iDebugMask$ = 164
iMTU$ = 168
iKernBuff$ = 172
iIOBuff$ = 176
mask$ = 180
addr4$ = 184
c$1 = 188
tv962 = 192
ilprfx$ = 200
saw_conf$ = 208
tv262 = 212
tv266 = 216
tv304 = 220
tv308 = 224
tv366 = 228
tv370 = 232
tv394 = 236
tv398 = 240
tv419 = 244
tv423 = 248
tv448 = 252
tv452 = 256
tv485 = 260
tv489 = 264
tv650 = 268
tv654 = 272
tv709 = 276
tv713 = 280
tv729 = 284
tv733 = 288
tv749 = 292
tv753 = 296
tv782 = 300
tv786 = 304
tv837 = 308
tv841 = 312
tv891 = 316
tv895 = 320
tv915 = 324
tv919 = 328
tv1568 = 332
tv984 = 336
tv988 = 340
tv178 = 344
tv1012 = 348
tv182 = 352
tv201 = 356
tv205 = 360
tv1008 = 364
tv232 = 368
tv236 = 372
saw_if$ = 376
iOpt$2 = 380
tv412 = 384
tv1116 = 392
hrb$ = 400
addr6$ = 848
argn$ = 864
mac$ = 9056
tmp$3 = 9072
__$ArrayPad$ = 9328
pDEVBLK$ = 9376
pPTPBLK$ = 9384
argc$ = 9392
argx$ = 9400
parse_conf_stmt PROC

; 2538 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	b8 88 24 00 00	 mov	 eax, 9352		; 00002488H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 70
	24 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2539 :     MAC             mac;               /* Work area for MAC address */
; 2540 :     struct in_addr  addr4;             /* Work area for IPv4 addresses */
; 2541 : #if defined(ENABLE_IPV6)
; 2542 :     struct in6_addr addr6;             /* Work area for IPv6 addresses */
; 2543 : #endif /* defined(ENABLE_IPV6) */
; 2544 :     int             iPfxSiz;           /* Work area for prefix size */
; 2545 : //  int             iMaxBfru;
; 2546 :     int             iMTU;
; 2547 :     int             iDebugMask;
; 2548 :     char            *cphost, *cpprfx;
; 2549 :     size_t          ilhost, ilprfx;
; 2550 :     uint32_t        mask;
; 2551 :     int             iWantFamily;
; 2552 :     int             iFirstFamily[2];
; 2553 :     int             j;
; 2554 :     int             rc;
; 2555 : #if defined(OPTION_W32_CTCI)
; 2556 :     int             iKernBuff;
; 2557 :     int             iIOBuff;
; 2558 : #endif /* defined(OPTION_W32_CTCI) */
; 2559 :     HRB             hrb;
; 2560 :     char            *argn[MAX_ARGS];
; 2561 :     char            **argv = argn;

  00035	48 8d 84 24 60
	03 00 00	 lea	 rax, QWORD PTR argn$[rsp]
  0003d	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 2562 :     int             saw_if = 0;        /* -x (or --if) specified */

  00042	c7 84 24 78 01
	00 00 00 00 00
	00		 mov	 DWORD PTR saw_if$[rsp], 0

; 2563 :     int             saw_conf = 0;      /* Other configuration flags present */

  0004d	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 0

; 2564 : 
; 2565 : 
; 2566 :     // Build a copy of the argv list.
; 2567 :     // getopt() and getopt_long() expect argv[0] to be a program name.
; 2568 :     // We need to shift the arguments and insert a dummy argv[0].
; 2569 :     if (argc > (MAX_ARGS-1))

  00058	81 bc 24 b0 24
	00 00 ff 03 00
	00		 cmp	 DWORD PTR argc$[rsp], 1023 ; 000003ffH
  00063	7e 0b		 jle	 SHORT $LN16@parse_conf

; 2570 :         argc = (MAX_ARGS-1);

  00065	c7 84 24 b0 24
	00 00 ff 03 00
	00		 mov	 DWORD PTR argc$[rsp], 1023 ; 000003ffH
$LN16@parse_conf:

; 2571 :     for( j = 0; j < argc; j++ )

  00070	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00078	eb 0a		 jmp	 SHORT $LN4@parse_conf
$LN2@parse_conf:
  0007a	8b 44 24 60	 mov	 eax, DWORD PTR j$[rsp]
  0007e	ff c0		 inc	 eax
  00080	89 44 24 60	 mov	 DWORD PTR j$[rsp], eax
$LN4@parse_conf:
  00084	8b 84 24 b0 24
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0008b	39 44 24 60	 cmp	 DWORD PTR j$[rsp], eax
  0008f	7d 24		 jge	 SHORT $LN3@parse_conf

; 2572 :         argn[j+1] = argx[j];

  00091	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  00096	8b 4c 24 60	 mov	 ecx, DWORD PTR j$[rsp]
  0009a	ff c1		 inc	 ecx
  0009c	48 63 c9	 movsxd	 rcx, ecx
  0009f	48 8b 94 24 b8
	24 00 00	 mov	 rdx, QWORD PTR argx$[rsp]
  000a7	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  000ab	48 89 84 cc 60
	03 00 00	 mov	 QWORD PTR argn$[rsp+rcx*8], rax
  000b3	eb c5		 jmp	 SHORT $LN2@parse_conf
$LN3@parse_conf:

; 2573 :     argc++;

  000b5	8b 84 24 b0 24
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000bc	ff c0		 inc	 eax
  000be	89 84 24 b0 24
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 2574 :     argn[0] = pDEVBLK->typname;

  000c5	b8 08 00 00 00	 mov	 eax, 8
  000ca	48 6b c0 00	 imul	 rax, rax, 0
  000ce	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000d6	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000da	48 89 8c 04 60
	03 00 00	 mov	 QWORD PTR argn$[rsp+rax], rcx

; 2575 : 
; 2576 : //  // Display the copied argv.
; 2577 : //  {
; 2578 : //      char    tmp[256];
; 2579 : //      int     i;
; 2580 : //      snprintf( (char*)tmp, 256, "Number of arguments: %d", argc );
; 2581 : //      WRMSG(HHC03991, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, tmp );
; 2582 : //      for( i = 0; i < argc; i++ )
; 2583 : //      {
; 2584 : //          snprintf( (char*)tmp, 256, "argv[%d]: %s", i, argv[i] );
; 2585 : //          WRMSG(HHC03991, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, tmp );
; 2586 : //      }
; 2587 : //  }
; 2588 : 
; 2589 :     // Housekeeping
; 2590 :     memset( &addr4, 0, sizeof( struct in_addr  ));

  000e2	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR addr4$[rsp]
  000ea	48 8b f8	 mov	 rdi, rax
  000ed	33 c0		 xor	 eax, eax
  000ef	b9 04 00 00 00	 mov	 ecx, 4
  000f4	f3 aa		 rep stosb

; 2591 :     memset( &mac,   0, sizeof(      MAC        ));

  000f6	48 8d 84 24 60
	23 00 00	 lea	 rax, QWORD PTR mac$[rsp]
  000fe	48 8b f8	 mov	 rdi, rax
  00101	33 c0		 xor	 eax, eax
  00103	b9 06 00 00 00	 mov	 ecx, 6
  00108	f3 aa		 rep stosb

; 2592 : #if defined( ENABLE_IPV6 )
; 2593 :     memset( &addr6, 0, sizeof( struct in6_addr ));

  0010a	48 8d 84 24 50
	03 00 00	 lea	 rax, QWORD PTR addr6$[rsp]
  00112	48 8b f8	 mov	 rdi, rax
  00115	33 c0		 xor	 eax, eax
  00117	b9 10 00 00 00	 mov	 ecx, 16
  0011c	f3 aa		 rep stosb

; 2594 : #endif
; 2595 : 
; 2596 :     // Set some initial defaults
; 2597 :     STRLCPY( pPTPBLK->szTUNCharDevName, DEF_NETDEV );

  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_sysblk_netdev
  00124	48 8b 8c 24 a8
	24 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0012c	48 83 c1 7c	 add	 rcx, 124		; 0000007cH
  00130	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00136	48 8b d0	 mov	 rdx, rax
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2598 : #if defined( OPTION_W32_CTCI )
; 2599 :     pPTPBLK->iKernBuff = DEF_CAPTURE_BUFFSIZE;

  0013f	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00147	c7 40 70 00 00
	10 00		 mov	 DWORD PTR [rax+112], 1048576 ; 00100000H

; 2600 :     pPTPBLK->iIOBuff   = DEF_PACKET_BUFFSIZE;

  0014e	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00156	c7 40 74 00 00
	01 00		 mov	 DWORD PTR [rax+116], 65536 ; 00010000H

; 2601 : #endif
; 2602 : #if defined( ENABLE_IPV6 )
; 2603 :     pPTPBLK->iAFamily = AF_UNSPEC;

  0015d	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00165	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0

; 2604 : #else
; 2605 :     pPTPBLK->iAFamily = AF_INET;
; 2606 : #endif
; 2607 :     STRLCPY( pPTPBLK->szMaxBfru, "5" );

  0016c	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00174	48 05 8c 01 00
	00		 add	 rax, 396		; 0000018cH
  0017a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00180	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171138
  00187	48 8b c8	 mov	 rcx, rax
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2608 :     pPTPBLK->iMaxBfru = 5;

  00190	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00198	c7 80 d0 02 00
	00 05 00 00 00	 mov	 DWORD PTR [rax+720], 5

; 2609 :     STRLCPY( pPTPBLK->szMTU, "1500" );

  001a2	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001aa	48 05 94 01 00
	00		 add	 rax, 404		; 00000194H
  001b0	41 b8 08 00 00
	00		 mov	 r8d, 8
  001b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171139
  001bd	48 8b c8	 mov	 rcx, rax
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2610 :     pPTPBLK->iMTU = 1500;

  001c6	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001ce	c7 80 d4 02 00
	00 dc 05 00 00	 mov	 DWORD PTR [rax+724], 1500 ; 000005dcH

; 2611 :     STRLCPY( pPTPBLK->szDrivePfxSiz4, "32" );

  001d8	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001e0	48 05 d0 01 00
	00		 add	 rax, 464		; 000001d0H
  001e6	41 b8 08 00 00
	00		 mov	 r8d, 8
  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171140
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2612 :     STRLCPY( pPTPBLK->szNetMask, "255.255.255.255" );

  001fc	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00204	48 05 d8 01 00
	00		 add	 rax, 472		; 000001d8H
  0020a	41 b8 14 00 00
	00		 mov	 r8d, 20
  00210	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171141
  00217	48 8b c8	 mov	 rcx, rax
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2613 : #if defined( ENABLE_IPV6 )
; 2614 :     STRLCPY( pPTPBLK->szDrivePfxSiz6, "128" );

  00220	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00228	48 05 30 02 00
	00		 add	 rax, 560		; 00000230H
  0022e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171142
  0023b	48 8b c8	 mov	 rcx, rax
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2615 :     STRLCPY( pPTPBLK->szDriveLLxSiz6, "64" );

  00244	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0024c	48 05 98 02 00
	00		 add	 rax, 664		; 00000298H
  00252	41 b8 08 00 00
	00		 mov	 r8d, 8
  00258	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171143
  0025f	48 8b c8	 mov	 rcx, rax
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2616 : #endif
; 2617 : 
; 2618 :     // Initialize getopt's counter. This is necessary in the case
; 2619 :     // that getopt was used previously for another device.
; 2620 :     OPTRESET();
; 2621 :     optind = 0;

  00268	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  0026f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN5@parse_conf:

; 2622 : 
; 2623 :     // Parse any optional arguments
; 2624 :     while( 1 )

  00275	33 c0		 xor	 eax, eax
  00277	83 f8 01	 cmp	 eax, 1
  0027a	0f 84 78 09 00
	00		 je	 $LN6@parse_conf

; 2625 :     {
; 2626 :         int     c;
; 2627 : 
; 2628 : #if defined(OPTION_W32_CTCI)
; 2629 :   #define  PTP_OPTSTRING  "n:t:d::46m:k:i:"
; 2630 : #else /* defined(OPTION_W32_CTCI) */
; 2631 :   #define  PTP_OPTSTRING  "n:x:t:d::46"
; 2632 : #endif /* defined(OPTION_W32_CTCI) */
; 2633 : 
; 2634 : #if defined(HAVE_GETOPT_LONG)
; 2635 :         int     iOpt;
; 2636 : 
; 2637 :         static struct option options[] =
; 2638 :         {
; 2639 :             { "dev",     required_argument, NULL, 'n' },
; 2640 : #if !defined(OPTION_W32_CTCI)
; 2641 :             { "if",      required_argument, NULL, 'x' },
; 2642 : #endif /* !defined(OPTION_W32_CTCI) */
; 2643 :             { "mtu",     required_argument, NULL, 't' },
; 2644 :             { "debug",   optional_argument, NULL, 'd' },
; 2645 :             { "inet",    no_argument,       NULL, '4' },
; 2646 :             { "inet6",   no_argument,       NULL, '6' },
; 2647 : #if defined(OPTION_W32_CTCI)
; 2648 :             { "mac",     required_argument, NULL, 'm' },
; 2649 :             { "kbuff",   required_argument, NULL, 'k' },
; 2650 :             { "ibuff",   required_argument, NULL, 'i' },
; 2651 : #endif /* defined(OPTION_W32_CTCI) */
; 2652 :             { NULL,      0,                 NULL,  0  }
; 2653 :         };
; 2654 : 
; 2655 :         c = getopt_long( argc, argv, PTP_OPTSTRING, options, &iOpt );

  00280	48 8d 84 24 7c
	01 00 00	 lea	 rax, QWORD PTR iOpt$2[rsp]
  00288	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?options@?3??parse_conf_stmt@@9@9
  00294	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171152
  0029b	48 8b 54 24 68	 mov	 rdx, QWORD PTR argv$[rsp]
  002a0	8b 8c 24 b0 24
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getopt_long
  002ad	89 84 24 bc 00
	00 00		 mov	 DWORD PTR c$1[rsp], eax

; 2656 : #else /* defined(HAVE_GETOPT_LONG) */
; 2657 :         c = getopt( argc, argv, PTP_OPTSTRING );
; 2658 : #endif /* defined(HAVE_GETOPT_LONG) */
; 2659 : 
; 2660 :         if (c == -1 ) // No more options found

  002b4	83 bc 24 bc 00
	00 00 ff	 cmp	 DWORD PTR c$1[rsp], -1
  002bc	75 05		 jne	 SHORT $LN17@parse_conf

; 2661 :             break;

  002be	e9 35 09 00 00	 jmp	 $LN6@parse_conf
$LN17@parse_conf:

; 2662 : 
; 2663 :         switch( c )

  002c3	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR c$1[rsp]
  002ca	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv164[rsp], eax
  002d1	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv164[rsp]
  002d8	83 e8 34	 sub	 eax, 52			; 00000034H
  002db	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv164[rsp], eax
  002e2	83 bc 24 a0 00
	00 00 40	 cmp	 DWORD PTR tv164[rsp], 64 ; 00000040H
  002ea	0f 87 38 08 00
	00		 ja	 $LN41@parse_conf
  002f0	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR tv164[rsp]
  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002ff	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN92@parse_conf[rcx+rax]
  00307	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN93@parse_conf[rcx+rax*4]
  0030e	48 03 c1	 add	 rax, rcx
  00311	ff e0		 jmp	 rax
$LN18@parse_conf:

; 2664 :         {
; 2665 : 
; 2666 :         case 'n':     // Network Device
; 2667 : 
; 2668 : #if defined( OPTION_W32_CTCI )
; 2669 : 
; 2670 :             // This could be the IP or MAC address of the
; 2671 :             // host ethernet adapter.
; 2672 :             if (inet_aton( optarg, &addr4 ) == 0)

  00313	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR addr4$[rsp]
  0031b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00322	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  0032b	85 c0		 test	 eax, eax
  0032d	0f 85 da 00 00
	00		 jne	 $LN19@parse_conf

; 2673 :             {
; 2674 :                 // Not an IP address, check for valid MAC
; 2675 :                 if (ParseMAC( optarg, mac ) != 0)

  00333	48 8d 94 24 60
	23 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  0033b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00342	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00345	e8 00 00 00 00	 call	 ParseMAC
  0034a	85 c0		 test	 eax, eax
  0034c	0f 84 bb 00 00
	00		 je	 $LN20@parse_conf

; 2676 :                 {
; 2677 :                     // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2678 :                     WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00352	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0035a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0035e	89 84 24 58 01
	00 00		 mov	 DWORD PTR tv178[rsp], eax
  00365	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0036d	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00371	d1 f9		 sar	 ecx, 1
  00373	89 8c 24 60 01
	00 00		 mov	 DWORD PTR tv182[rsp], ecx
  0037a	b9 01 00 00 00	 mov	 ecx, 1
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00385	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  0038c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0038f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00394	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171157
  0039b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003a0	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003a8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  003ac	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003b1	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  003b8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003bc	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR tv182[rsp]
  003c3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171158
  003ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171159
  003da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171160
  003f1	ba 77 0a 00 00	 mov	 edx, 2679		; 00000a77H
  003f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171161
  003fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2679 :                           "adapter address", optarg );
; 2680 :                     return -1;

  00403	b8 ff ff ff ff	 mov	 eax, -1
  00408	e9 fa 1a 00 00	 jmp	 $LN1@parse_conf
$LN20@parse_conf:
$LN19@parse_conf:

; 2681 :                 }
; 2682 :             }
; 2683 : #endif
; 2684 :             // This is the file name of the special TUN/TAP character device
; 2685 :             if (strlen( optarg ) > sizeof( pPTPBLK->szTUNCharDevName )-1)

  0040d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00414	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00417	e8 00 00 00 00	 call	 strlen
  0041c	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  00422	0f 86 bb 00 00
	00		 jbe	 $LN21@parse_conf

; 2686 :             {
; 2687 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2688 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  00428	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00430	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00434	89 84 24 64 01
	00 00		 mov	 DWORD PTR tv201[rsp], eax
  0043b	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00443	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00447	d1 f9		 sar	 ecx, 1
  00449	89 8c 24 68 01
	00 00		 mov	 DWORD PTR tv205[rsp], ecx
  00450	b9 01 00 00 00	 mov	 ecx, 1
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0045b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00462	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00465	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0046a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171163
  00471	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00476	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0047e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00482	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00487	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR tv201[rsp]
  0048e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00492	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR tv205[rsp]
  00499	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0049d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171164
  004a4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171165
  004b0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ba	41 b9 03 00 00
	00		 mov	 r9d, 3
  004c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171166
  004c7	ba 81 0a 00 00	 mov	 edx, 2689		; 00000a81H
  004cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171167
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2689 :                     pDEVBLK->devnum, pDEVBLK->typname, "device name", optarg );
; 2690 :                 return -1;

  004d9	b8 ff ff ff ff	 mov	 eax, -1
  004de	e9 24 1a 00 00	 jmp	 $LN1@parse_conf
$LN21@parse_conf:

; 2691 :             }
; 2692 : 
; 2693 :             STRLCPY( pPTPBLK->szTUNCharDevName, optarg );

  004e3	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004eb	48 83 c0 7c	 add	 rax, 124		; 0000007cH
  004ef	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  004f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  004fc	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  004ff	48 8b c8	 mov	 rcx, rax
  00502	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2694 :             break;

  00508	e9 e6 06 00 00	 jmp	 $LN7@parse_conf
$LN22@parse_conf:

; 2695 : 
; 2696 : #if !defined( OPTION_W32_CTCI )
; 2697 : 
; 2698 :         case 'x':     // TUN network interface name
; 2699 : 
; 2700 :             if (strlen( optarg ) > sizeof( pPTPBLK->szTUNIfName )-1)
; 2701 :             {
; 2702 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2703 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),
; 2704 :                     pDEVBLK->devnum, pDEVBLK->typname, "TUN device name", optarg );
; 2705 :                 return -1;
; 2706 :             }
; 2707 : 
; 2708 :             STRLCPY( pPTPBLK->szTUNIfName, optarg );
; 2709 :             saw_if = 1;
; 2710 :             break;
; 2711 : 
; 2712 : #endif
; 2713 : 
; 2714 :         case 't':     // MTU of link (ignored if Windows) (default 1500).
; 2715 : 
; 2716 :             // Note: The largest MTU supported by MPCPTP or MPCPTP6
; 2717 :             // devices is 59392, based on the MAXBFRU specified in the
; 2718 :             // TRLE definition. The smallest MTU supported is equal to
; 2719 :             // DEFAULTSIZE, which is 576 for IPv4 and 1280 for IPv6. See
; 2720 :             // the manual 'z/OS Communication Server: IP Configuration
; 2721 :             // Reference'.
; 2722 :             //   MAXBFRU value  Actual MTU value
; 2723 :             //   -------------  ----------------------------------
; 2724 :             //       5            14336  ( ( 4 * 4096 ) - 2048 )
; 2725 :             //      16            59392  ( ( 15 * 4096 ) - 2048 )
; 2726 :             // This side will report a MAXBFRU value of 5 to the y-side,
; 2727 :             // from which the y-side will calculate an actual MTU value
; 2728 :             // of 14336. The MTU value that will be used for packets
; 2729 :             // sent from the y-side to this side will depend on the MTU
; 2730 :             // value specified on the y-side's route statement(s). If the
; 2731 :             // y-side's route statement(s) pecify an MTU value greater
; 2732 :             // than the actual MTU value the route statement value is
; 2733 :             // ignored and the actual MTU value is used. If the y-side's
; 2734 :             // route statement(s) specify an MTU value less than or equal
; 2735 :             // to the actual MTU value the route statement MTU value is
; 2736 :             // used. Hopefully the y-side's route statement(s) will match
; 2737 :             // the MTU value specified here!
; 2738 : 
; 2739 :             iMTU = atoi( optarg );

  0050d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00514	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00517	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0051d	89 84 24 a8 00
	00 00		 mov	 DWORD PTR iMTU$[rsp], eax

; 2740 :             if (iMTU < 576 || iMTU > 14336 ||

  00524	81 bc 24 a8 00
	00 00 40 02 00
	00		 cmp	 DWORD PTR iMTU$[rsp], 576 ; 00000240H
  0052f	7c 26		 jl	 SHORT $LN24@parse_conf
  00531	81 bc 24 a8 00
	00 00 00 38 00
	00		 cmp	 DWORD PTR iMTU$[rsp], 14336 ; 00003800H
  0053c	7f 19		 jg	 SHORT $LN24@parse_conf
  0053e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00545	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00548	e8 00 00 00 00	 call	 strlen
  0054d	48 83 f8 07	 cmp	 rax, 7
  00551	0f 86 bb 00 00
	00		 jbe	 $LN23@parse_conf
$LN24@parse_conf:

; 2741 :                 strlen(optarg) > sizeof(pPTPBLK->szMTU)-1)
; 2742 :             {
; 2743 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2744 :                 WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00557	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0055f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00563	89 84 24 70 01
	00 00		 mov	 DWORD PTR tv232[rsp], eax
  0056a	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00572	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00576	d1 f9		 sar	 ecx, 1
  00578	89 8c 24 74 01
	00 00		 mov	 DWORD PTR tv236[rsp], ecx
  0057f	b9 01 00 00 00	 mov	 ecx, 1
  00584	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0058a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00591	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00594	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00599	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171171
  005a0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005a5	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005ad	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  005b1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005b6	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR tv232[rsp]
  005bd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005c1	8b 8c 24 74 01
	00 00		 mov	 ecx, DWORD PTR tv236[rsp]
  005c8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171172
  005d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171173
  005df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  005ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171174
  005f6	ba b9 0a 00 00	 mov	 edx, 2745		; 00000ab9H
  005fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171175
  00602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2745 :                       "MTU size", optarg );
; 2746 :                 return -1;

  00608	b8 ff ff ff ff	 mov	 eax, -1
  0060d	e9 f5 18 00 00	 jmp	 $LN1@parse_conf
$LN23@parse_conf:

; 2747 :             }
; 2748 :             STRLCPY( pPTPBLK->szMTU, optarg );

  00612	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0061a	48 05 94 01 00
	00		 add	 rax, 404		; 00000194H
  00620	41 b8 08 00 00
	00		 mov	 r8d, 8
  00626	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  0062d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00630	48 8b c8	 mov	 rcx, rax
  00633	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2749 :             pPTPBLK->iMTU = iMTU;

  00639	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00641	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR iMTU$[rsp]
  00648	89 88 d4 02 00
	00		 mov	 DWORD PTR [rax+724], ecx

; 2750 :             saw_conf = 1;

  0064e	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 1

; 2751 :             break;

  00659	e9 95 05 00 00	 jmp	 $LN7@parse_conf
$LN25@parse_conf:

; 2752 : 
; 2753 : //      case ' ':     // Maximum buffers to use (default 5).
; 2754 : //
; 2755 : //          // The number of 4K pages used by VTAM to receive data. The
; 2756 : //          // resulting buffer size is number_of_pages multiplied by
; 2757 : //          // 4096, minus 4 bytes for an eye-catcher of 'WrHP'. VTAM
; 2758 : //          // automatically substitues a value of 16 for any coded
; 2759 : //          // value higher than 16 without issuing a warning message.
; 2760 : //          // Note: Empirical evidence suggests that VTAM ignores any
; 2761 : //          // coded value lower than 5 and substitutes a value of 5
; 2762 : //          // (the default value) without issuing a warning message. Is
; 2763 : //          // this a bug, or a feature?
; 2764 : //
; 2765 : //          iMaxBfru = atoi( optarg );
; 2766 : //
; 2767 : //          if ( strlen(optarg) > sizeof(pPTPBLK->szMaxBfru)-1 )
; 2768 : //          {
; 2769 : //              // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2770 : //              WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 2771 : //                    "MaxBfru number", optarg );
; 2772 : //              return -1;
; 2773 : //          }
; 2774 : //
; 2775 : //          if (iMaxBfru < 5)
; 2776 : //          {
; 2777 : //              STRLCPY( pPTPBLK->szMaxBfru, "5" );
; 2778 : //              pPTPBLK->iMaxBfru = 5;
; 2779 : //          }
; 2780 : //          else if (iMaxBfru > 16)
; 2781 : //          {
; 2782 : //              STRLCPY( pPTPBLK->szMaxBfru, "16" );
; 2783 : //              pPTPBLK->iMaxBfru = 16;
; 2784 : //          }
; 2785 : //          else
; 2786 : //          {
; 2787 : //              STRLCPY( pPTPBLK->szMaxBfru, optarg );
; 2788 : //              pPTPBLK->iMaxBfru = iMaxBfru;
; 2789 : //          }
; 2790 : //
; 2791 : //          break;
; 2792 : 
; 2793 :         case 'd':     // Diagnostics
; 2794 : 
; 2795 :             if (optarg)

  0065e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00665	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00669	0f 84 02 01 00
	00		 je	 $LN26@parse_conf

; 2796 :             {
; 2797 :                 iDebugMask = atoi( optarg );

  0066f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00676	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00679	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0067f	89 84 24 a4 00
	00 00		 mov	 DWORD PTR iDebugMask$[rsp], eax

; 2798 :                 if (iDebugMask < 1 || iDebugMask > 255)

  00686	83 bc 24 a4 00
	00 00 01	 cmp	 DWORD PTR iDebugMask$[rsp], 1
  0068e	7c 11		 jl	 SHORT $LN29@parse_conf
  00690	81 bc 24 a4 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR iDebugMask$[rsp], 255 ; 000000ffH
  0069b	0f 8e bc 00 00
	00		 jle	 $LN28@parse_conf
$LN29@parse_conf:

; 2799 :                 {
; 2800 :                     // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2801 :                     WRMSG( HHC00916, "W", SSID_TO_LCSS( pDEVBLK->ssid ),

  006a1	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006a9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006ad	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv262[rsp], eax
  006b4	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006bc	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  006c0	d1 f9		 sar	 ecx, 1
  006c2	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv266[rsp], ecx
  006c9	b9 01 00 00 00	 mov	 ecx, 1
  006ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  006db	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006de	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171181
  006ea	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006ef	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006f7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  006fb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00700	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv262[rsp]
  00707	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0070b	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv266[rsp]
  00712	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00716	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171182
  0071d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171183
  00729	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0072e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00733	41 b9 03 00 00
	00		 mov	 r9d, 3
  00739	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171184
  00740	ba f2 0a 00 00	 mov	 edx, 2802		; 00000af2H
  00745	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171185
  0074c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2802 :                         pDEVBLK->devnum, pDEVBLK->typname, "debug mask", optarg );
; 2803 :                     iDebugMask = DBGPTPPACKET;

  00752	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR iDebugMask$[rsp], 1
$LN28@parse_conf:

; 2804 :                 }
; 2805 :                 pPTPBLK->uDebugMask = iDebugMask;

  0075d	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00765	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR iDebugMask$[rsp]
  0076c	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 2806 :             }

  0076f	eb 0f		 jmp	 SHORT $LN27@parse_conf
$LN26@parse_conf:

; 2807 :             else
; 2808 :             {
; 2809 :                 pPTPBLK->uDebugMask = DBGPTPPACKET;

  00771	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00779	c7 40 68 01 00
	00 00		 mov	 DWORD PTR [rax+104], 1
$LN27@parse_conf:

; 2810 :             }
; 2811 :             break;

  00780	e9 6e 04 00 00	 jmp	 $LN7@parse_conf
$LN30@parse_conf:

; 2812 : 
; 2813 :         case '4':     // Address family.
; 2814 : 
; 2815 : #if defined( ENABLE_IPV6 )
; 2816 :             pPTPBLK->iAFamily = AF_INET;

  00785	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0078d	c7 40 78 02 00
	00 00		 mov	 DWORD PTR [rax+120], 2

; 2817 : #endif
; 2818 :             break;

  00794	e9 5a 04 00 00	 jmp	 $LN7@parse_conf
$LN31@parse_conf:

; 2819 : 
; 2820 :         case '6':     // Address family.
; 2821 : 
; 2822 : #if defined( ENABLE_IPV6 )
; 2823 :             pPTPBLK->iAFamily = AF_INET6;

  00799	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007a1	c7 40 78 17 00
	00 00		 mov	 DWORD PTR [rax+120], 23

; 2824 : #endif
; 2825 :             break;

  007a8	e9 46 04 00 00	 jmp	 $LN7@parse_conf
$LN32@parse_conf:

; 2826 : 
; 2827 : #if defined( OPTION_W32_CTCI )
; 2828 : 
; 2829 :         case 'm':
; 2830 : 
; 2831 :             if (0
; 2832 :                 || strlen(optarg) > sizeof(pPTPBLK->szMACAddress)-1
; 2833 :                 || ParseMAC( optarg, mac ) != 0 // (invalid format)
; 2834 :                 || !(mac[0] & 0x02)             // (locally assigned MAC bit not ON)
; 2835 :                 ||  (mac[0] & 0x01)             // (broadcast bit is ON)

  007ad	33 c0		 xor	 eax, eax
  007af	85 c0		 test	 eax, eax
  007b1	75 64		 jne	 SHORT $LN34@parse_conf
  007b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  007ba	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007bd	e8 00 00 00 00	 call	 strlen
  007c2	48 83 f8 1f	 cmp	 rax, 31
  007c6	77 4f		 ja	 SHORT $LN34@parse_conf
  007c8	48 8d 94 24 60
	23 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  007d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  007d7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007da	e8 00 00 00 00	 call	 ParseMAC
  007df	85 c0		 test	 eax, eax
  007e1	75 34		 jne	 SHORT $LN34@parse_conf
  007e3	b8 01 00 00 00	 mov	 eax, 1
  007e8	48 6b c0 00	 imul	 rax, rax, 0
  007ec	0f b6 84 04 60
	23 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  007f4	83 e0 02	 and	 eax, 2
  007f7	85 c0		 test	 eax, eax
  007f9	74 1c		 je	 SHORT $LN34@parse_conf
  007fb	b8 01 00 00 00	 mov	 eax, 1
  00800	48 6b c0 00	 imul	 rax, rax, 0
  00804	0f b6 84 04 60
	23 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  0080c	83 e0 01	 and	 eax, 1
  0080f	85 c0		 test	 eax, eax
  00811	0f 84 bb 00 00
	00		 je	 $LN33@parse_conf
$LN34@parse_conf:

; 2836 :             )
; 2837 :             {
; 2838 :                 // "%1d:%04X %s: Option %s value %s invalid"
; 2839 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  00817	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0081f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00823	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv304[rsp], eax
  0082a	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00832	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00836	d1 f9		 sar	 ecx, 1
  00838	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR tv308[rsp], ecx
  0083f	b9 01 00 00 00	 mov	 ecx, 1
  00844	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0084a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00851	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00854	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00859	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171191
  00860	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00865	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0086d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00871	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00876	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv304[rsp]
  0087d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00881	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv308[rsp]
  00888	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0088c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171192
  00893	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00898	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171193
  0089f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  008af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171194
  008b6	ba 18 0b 00 00	 mov	 edx, 2840		; 00000b18H
  008bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171195
  008c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2840 :                     pDEVBLK->devnum, pDEVBLK->typname, "MAC address", optarg );
; 2841 :                 return -1;

  008c8	b8 ff ff ff ff	 mov	 eax, -1
  008cd	e9 35 16 00 00	 jmp	 $LN1@parse_conf
$LN33@parse_conf:

; 2842 :             }
; 2843 : 
; 2844 :             STRLCPY( pPTPBLK->szMACAddress, optarg );

  008d2	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  008da	48 05 9c 01 00
	00		 add	 rax, 412		; 0000019cH
  008e0	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  008e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  008ed	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  008f0	48 8b c8	 mov	 rcx, rax
  008f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2845 :             break;

  008f9	e9 f5 02 00 00	 jmp	 $LN7@parse_conf
$LN35@parse_conf:

; 2846 : 
; 2847 :         case 'k':     // Kernel Buffer Size (Windows only)
; 2848 : 
; 2849 :             iKernBuff = atoi( optarg );

  008fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00905	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00908	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0090e	89 84 24 ac 00
	00 00		 mov	 DWORD PTR iKernBuff$[rsp], eax

; 2850 : 
; 2851 :             if (iKernBuff * 1024 < MIN_CAPTURE_BUFFSIZE ||

  00915	69 84 24 ac 00
	00 00 00 04 00
	00		 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  00920	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00925	7c 16		 jl	 SHORT $LN37@parse_conf
  00927	69 84 24 ac 00
	00 00 00 04 00
	00		 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  00932	3d 00 00 00 01	 cmp	 eax, 16777216		; 01000000H
  00937	0f 8e bb 00 00
	00		 jle	 $LN36@parse_conf
$LN37@parse_conf:

; 2852 :                 iKernBuff * 1024 > MAX_CAPTURE_BUFFSIZE)
; 2853 :             {
; 2854 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2855 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  0093d	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00945	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00949	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv366[rsp], eax
  00950	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00958	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0095c	d1 f9		 sar	 ecx, 1
  0095e	89 8c 24 e8 00
	00 00		 mov	 DWORD PTR tv370[rsp], ecx
  00965	b9 01 00 00 00	 mov	 ecx, 1
  0096a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00970	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00977	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0097a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0097f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171199
  00986	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0098b	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00993	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00997	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0099c	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv366[rsp]
  009a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009a7	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv370[rsp]
  009ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171200
  009b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171201
  009c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  009d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171202
  009dc	ba 28 0b 00 00	 mov	 edx, 2856		; 00000b28H
  009e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171203
  009e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2856 :                     pDEVBLK->devnum, pDEVBLK->typname, "kernel buffer size", optarg );
; 2857 :                 return -1;

  009ee	b8 ff ff ff ff	 mov	 eax, -1
  009f3	e9 0f 15 00 00	 jmp	 $LN1@parse_conf
$LN36@parse_conf:

; 2858 :             }
; 2859 : 
; 2860 :             pPTPBLK->iKernBuff = iKernBuff * 1024;

  009f8	69 84 24 ac 00
	00 00 00 04 00
	00		 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  00a03	48 8b 8c 24 a8
	24 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00a0b	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 2861 :             break;

  00a0e	e9 e0 01 00 00	 jmp	 $LN7@parse_conf
$LN38@parse_conf:

; 2862 : 
; 2863 :         case 'i':     // I/O Buffer Size (Windows only)
; 2864 : 
; 2865 :             iIOBuff = atoi( optarg );

  00a13	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00a1a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00a1d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00a23	89 84 24 b0 00
	00 00		 mov	 DWORD PTR iIOBuff$[rsp], eax

; 2866 : 
; 2867 :             if (iIOBuff * 1024 < MIN_PACKET_BUFFSIZE ||

  00a2a	69 84 24 b0 00
	00 00 00 04 00
	00		 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  00a35	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00a3a	7c 16		 jl	 SHORT $LN40@parse_conf
  00a3c	69 84 24 b0 00
	00 00 00 04 00
	00		 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  00a47	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  00a4c	0f 8e bb 00 00
	00		 jle	 $LN39@parse_conf
$LN40@parse_conf:

; 2868 :                 iIOBuff * 1024 > MAX_PACKET_BUFFSIZE)
; 2869 :             {
; 2870 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2871 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  00a52	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a5a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a5e	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv394[rsp], eax
  00a65	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a6d	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00a71	d1 f9		 sar	 ecx, 1
  00a73	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR tv398[rsp], ecx
  00a7a	b9 01 00 00 00	 mov	 ecx, 1
  00a7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a85	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00a8c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00a8f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00a94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171207
  00a9b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00aa0	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00aa8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00aac	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ab1	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv394[rsp]
  00ab8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00abc	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv398[rsp]
  00ac3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ac7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171208
  00ace	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ad3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171209
  00ada	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00adf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ae4	41 b9 03 00 00
	00		 mov	 r9d, 3
  00aea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171210
  00af1	ba 38 0b 00 00	 mov	 edx, 2872		; 00000b38H
  00af6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171211
  00afd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2872 :                     pDEVBLK->devnum, pDEVBLK->typname, "dll i/o buffer size", optarg );
; 2873 :                 return -1;

  00b03	b8 ff ff ff ff	 mov	 eax, -1
  00b08	e9 fa 13 00 00	 jmp	 $LN1@parse_conf
$LN39@parse_conf:

; 2874 :             }
; 2875 : 
; 2876 :             pPTPBLK->iIOBuff = iIOBuff * 1024;

  00b0d	69 84 24 b0 00
	00 00 00 04 00
	00		 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  00b18	48 8b 8c 24 a8
	24 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00b20	89 41 74	 mov	 DWORD PTR [rcx+116], eax

; 2877 :             break;

  00b23	e9 cb 00 00 00	 jmp	 $LN7@parse_conf
$LN41@parse_conf:

; 2878 : 
; 2879 : #endif /* defined(OPTION_W32_CTCI) */
; 2880 : 
; 2881 :         default:  /*  Note: the variable c has a value that
; 2882 :                       makes default: equivalent to case '?':  */
; 2883 : 
; 2884 :             // HHC00918 "%1d:%04X %s: option %s unknown or specified incorrectly"
; 2885 :             WRMSG( HHC00918, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  00b28	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00b2f	8b 00		 mov	 eax, DWORD PTR [rax]
  00b31	ff c8		 dec	 eax
  00b33	48 98		 cdqe
  00b35	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv412[rsp], rax
  00b3d	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00b45	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00b49	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR tv419[rsp], ecx
  00b50	48 8b 94 24 a0
	24 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00b58	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00b5c	d1 fa		 sar	 edx, 1
  00b5e	89 94 24 f8 00
	00 00		 mov	 DWORD PTR tv423[rsp], edx
  00b65	b9 01 00 00 00	 mov	 ecx, 1
  00b6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b70	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00b75	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR tv412[rsp]
  00b7d	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00b81	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b86	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00b8e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00b92	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b97	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv419[rsp]
  00b9e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ba2	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv423[rsp]
  00ba9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00bad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171213
  00bb4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bb9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171214
  00bc0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bc5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bca	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bd0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171215
  00bd7	ba 46 0b 00 00	 mov	 edx, 2886		; 00000b46H
  00bdc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171216
  00be3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2886 :                 pDEVBLK->devnum, pDEVBLK->typname, argv[optind-1]);
; 2887 :             return -1;

  00be9	b8 ff ff ff ff	 mov	 eax, -1
  00bee	e9 14 13 00 00	 jmp	 $LN1@parse_conf
$LN7@parse_conf:

; 2888 :         }
; 2889 :     }

  00bf3	e9 7d f6 ff ff	 jmp	 $LN5@parse_conf
$LN6@parse_conf:

; 2890 : 
; 2891 :     // Shift past any options
; 2892 :     argc -= optind;

  00bf8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00bff	8b 00		 mov	 eax, DWORD PTR [rax]
  00c01	8b 8c 24 b0 24
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00c08	2b c8		 sub	 ecx, eax
  00c0a	8b c1		 mov	 eax, ecx
  00c0c	89 84 24 b0 24
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 2893 :     argv += optind;

  00c13	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00c1a	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00c1d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00c22	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00c26	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 2894 : 
; 2895 :     // Check for correct number of arguments.
; 2896 :     // For *nix, there can be either:-
; 2897 :     // a) Two parameters (a pair of IPv4 or IPv6 addresses), or four
; 2898 :     //    parameters (a pair of IPv4 addresses and a pair of IPv6
; 2899 :     //    addresses). If the -x option has not been specified, PTP
; 2900 :     //    will use a TUN interface whose name is allocated by the
; 2901 :     //    kernel (e.g. tun0), that is configured by PTP. If the -x
; 2902 :     //    option has been specified, PTP will use a pre-named TUN
; 2903 :     //    interface. The TUN interface may have been created before
; 2904 :     //    PTP was started, or it may be created by PTP, but in either
; 2905 :     //    case the TUN interface is configured by PTP.
; 2906 :     // b) One parameter when the -x option has not been specified.
; 2907 :     //    The single parameter specifies the name of a pre-configured
; 2908 :     //    TUN inferface that PTP will use.
; 2909 :     // c) Zero parameters when the -x option has been specified. The
; 2910 :     //    The -x option specified the name of a pre-configured TUN
; 2911 :     //    inferface that PTP will use..
; 2912 :     // For Windows there can be:-
; 2913 :     // a) Two parameters (a pair of IPv4 or IPv6 addresses), or four
; 2914 :     //    parameters (a pair of IPv4 addresses and a pair of IPv6
; 2915 :     //    addresses).
; 2916 : //  {
; 2917 : //      char    tmp[256];
; 2918 : //      snprintf( (char*)tmp, 256, "argc %d  saw_if %d  saw_conf %d", argc, saw_if, saw_conf );
; 2919 : //      WRMSG( HHC03991, "I", SSID_TO_LCSS( pDEVBLK->ssid ),
; 2920 : //          pDEVBLK->devnum, pDEVBLK->typname, tmp );
; 2921 : //  }
; 2922 :     if (argc == 2
; 2923 : #if defined( ENABLE_IPV6 )
; 2924 :         || argc == 4

  00c2b	83 bc 24 b0 24
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00c33	74 0a		 je	 SHORT $LN44@parse_conf
  00c35	83 bc 24 b0 24
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  00c3d	75 1e		 jne	 SHORT $LN42@parse_conf
$LN44@parse_conf:

; 2925 : #endif
; 2926 :     ) /* Not pre-configured, but possibly pre-named */
; 2927 :     {
; 2928 :         pPTPBLK->fPreconfigured = FALSE;

  00c3f	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00c47	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00c4a	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00c4d	48 8b 8c 24 a8
	24 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00c55	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 2929 :     }

  00c58	e9 a0 00 00 00	 jmp	 $LN43@parse_conf
$LN42@parse_conf:

; 2930 : 
; 2931 : #if !defined( OPTION_W32_CTCI )
; 2932 : 
; 2933 :     else if (argc == 1 && !saw_if && !saw_conf) /* Pre-configured using name */
; 2934 :     {
; 2935 :         if (strlen( argv[0] ) > sizeof(pPTPBLK->szTUNIfName)-1)
; 2936 :         {
; 2937 :             // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 2938 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 2939 :                   "TUN device name", argv[0] );
; 2940 :             return -1;
; 2941 :         }
; 2942 :         STRLCPY( pPTPBLK->szTUNIfName, argv[0] );
; 2943 :         argc--; argv++;
; 2944 :         pPTPBLK->fPreconfigured = TRUE;
; 2945 :     }
; 2946 :     else if (argc == 0 && saw_if && !saw_conf) /* Pre-configured using -x option */
; 2947 :     {
; 2948 :         pPTPBLK->fPreconfigured = TRUE;
; 2949 :     }
; 2950 : 
; 2951 : #endif /* !defined(OPTION_W32_CTCI) */
; 2952 : 
; 2953 :     else
; 2954 :     {
; 2955 :         // HHC00915 "%1d:%04X %s: incorrect number of parameters"
; 2956 :         WRMSG(HHC00915, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname );

  00c5d	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c65	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c69	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv448[rsp], eax
  00c70	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c78	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00c7c	d1 f9		 sar	 ecx, 1
  00c7e	89 8c 24 00 01
	00 00		 mov	 DWORD PTR tv452[rsp], ecx
  00c85	b9 01 00 00 00	 mov	 ecx, 1
  00c8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c90	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c98	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00c9c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ca1	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv448[rsp]
  00ca8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cac	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv452[rsp]
  00cb3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cb7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171220
  00cbe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cc3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171221
  00cca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ccf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cd4	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cda	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171222
  00ce1	ba 8c 0b 00 00	 mov	 edx, 2956		; 00000b8cH
  00ce6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171223
  00ced	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2957 :         return -1;

  00cf3	b8 ff ff ff ff	 mov	 eax, -1
  00cf8	e9 0a 12 00 00	 jmp	 $LN1@parse_conf
$LN43@parse_conf:

; 2958 :     }
; 2959 : 
; 2960 : #if defined( __APPLE__ ) || defined( FREEBSD_OR_NETBSD )
; 2961 : 
; 2962 :     if (pPTPBLK->fPreconfigured == TRUE)
; 2963 :     {
; 2964 :         /*  Need to append the interface number to the
; 2965 :          *  character device name to open the requested interface.
; 2966 :          */
; 2967 :         char* s = pPTPBLK->szTUNIfName + strlen( pPTPBLK->szTUNIfName );
; 2968 : 
; 2969 :         while (isdigit( s[-1] ))
; 2970 :             s--;
; 2971 : 
; 2972 :         STRLCAT( pPTPBLK->szTUNCharDevName, s );
; 2973 :     }
; 2974 : #endif // defined( __APPLE__ ) || defined( FREEBSD_OR_NETBSD )
; 2975 : 
; 2976 :     //
; 2977 :     iWantFamily = pPTPBLK->iAFamily;

  00cfd	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00d05	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00d08	89 84 24 84 00
	00 00		 mov	 DWORD PTR iWantFamily$[rsp], eax

; 2978 :     iFirstFamily[0] = AF_UNSPEC;

  00d0f	b8 04 00 00 00	 mov	 eax, 4
  00d14	48 6b c0 00	 imul	 rax, rax, 0
  00d18	c7 84 04 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR iFirstFamily$[rsp+rax], 0

; 2979 :     iFirstFamily[1] = AF_UNSPEC;

  00d23	b8 04 00 00 00	 mov	 eax, 4
  00d28	48 6b c0 01	 imul	 rax, rax, 1
  00d2c	c7 84 04 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR iFirstFamily$[rsp+rax], 0

; 2980 :     j = 0;

  00d37	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
$LN9@parse_conf:

; 2981 : 
; 2982 :     // Process the remaining parameters.
; 2983 :     while (argc > 0)

  00d3f	83 bc 24 b0 24
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00d47	0f 8e f9 0f 00
	00		 jle	 $LN10@parse_conf

; 2984 :     {
; 2985 :         // Guest IPv4 address.
; 2986 :         //  e.g. 192.168.1.1
; 2987 : 
; 2988 :         // Guest IPv6 address.
; 2989 :         //  e.g. 2001:db8:3003:1::543:210f
; 2990 : 
; 2991 :         cphost = *argv;                      // point to host name/IP address

  00d4d	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00d52	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d55	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cphost$[rsp], rax

; 2992 :         ilhost = strlen( *argv );            // calculate size of name/address (assume no prefix size)

  00d5d	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00d62	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00d65	e8 00 00 00 00	 call	 strlen
  00d6a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ilhost$[rsp], rax

; 2993 :         cpprfx = strchr( *argv, '/' );       // Point to slash character

  00d72	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00d77	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00d7c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00d7f	e8 00 00 00 00	 call	 strchr
  00d84	48 89 44 24 78	 mov	 QWORD PTR cpprfx$[rsp], rax

; 2994 :         ilprfx = 0;                          // no prefix size

  00d89	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ilprfx$[rsp], 0

; 2995 :         if (cpprfx)                          // If there is a slash

  00d95	48 83 7c 24 78
	00		 cmp	 QWORD PTR cpprfx$[rsp], 0
  00d9b	74 3a		 je	 SHORT $LN45@parse_conf

; 2996 :         {
; 2997 :             ilhost = cpprfx - cphost;        // calculate length of name/address

  00d9d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cphost$[rsp]
  00da5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cpprfx$[rsp]
  00daa	48 2b c8	 sub	 rcx, rax
  00dad	48 8b c1	 mov	 rax, rcx
  00db0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ilhost$[rsp], rax

; 2998 :             cpprfx++;                        // point to prefix size

  00db8	48 8b 44 24 78	 mov	 rax, QWORD PTR cpprfx$[rsp]
  00dbd	48 ff c0	 inc	 rax
  00dc0	48 89 44 24 78	 mov	 QWORD PTR cpprfx$[rsp], rax

; 2999 :             ilprfx = strlen( cpprfx );       // calculate length of prefix size

  00dc5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cpprfx$[rsp]
  00dca	e8 00 00 00 00	 call	 strlen
  00dcf	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR ilprfx$[rsp], rax
$LN45@parse_conf:

; 3000 :         }
; 3001 :         if (ilhost > (size_t)(sizeof(hrb.host)-1))

  00dd7	48 81 bc 24 88
	00 00 00 ff 00
	00 00		 cmp	 QWORD PTR ilhost$[rsp], 255 ; 000000ffH
  00de3	0f 86 b9 00 00
	00		 jbe	 $LN46@parse_conf

; 3002 :         {
; 3003 :             // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3004 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00de9	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00df1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00df5	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv485[rsp], eax
  00dfc	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e04	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00e08	d1 f9		 sar	 ecx, 1
  00e0a	89 8c 24 08 01
	00 00		 mov	 DWORD PTR tv489[rsp], ecx
  00e11	b9 01 00 00 00	 mov	 ecx, 1
  00e16	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e1c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00e21	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00e24	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00e29	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171226
  00e30	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e35	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e3d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00e41	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e46	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv485[rsp]
  00e4d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e51	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv489[rsp]
  00e58	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171227
  00e63	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171228
  00e6f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e74	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e79	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e7f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171229
  00e86	ba bd 0b 00 00	 mov	 edx, 3005		; 00000bbdH
  00e8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171230
  00e92	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3005 :                   "IP address", *argv );
; 3006 :             return -1;

  00e98	b8 ff ff ff ff	 mov	 eax, -1
  00e9d	e9 65 10 00 00	 jmp	 $LN1@parse_conf
$LN46@parse_conf:

; 3007 :         }
; 3008 : 
; 3009 :         // Check whether a numeric IPv4 address has been specified.
; 3010 :         memset( &hrb, 0, sizeof(hrb) );

  00ea2	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR hrb$[rsp]
  00eaa	48 8b f8	 mov	 rdi, rax
  00ead	33 c0		 xor	 eax, eax
  00eaf	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  00eb4	f3 aa		 rep stosb

; 3011 :         hrb.wantafam = AF_INET;

  00eb6	c7 84 24 f8 02
	00 00 02 00 00
	00		 mov	 DWORD PTR hrb$[rsp+360], 2

; 3012 :         hrb.numeric = TRUE;

  00ec1	c7 84 24 f4 02
	00 00 01 00 00
	00		 mov	 DWORD PTR hrb$[rsp+356], 1

; 3013 :         memcpy( hrb.host, cphost, ilhost );

  00ecc	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR hrb$[rsp]
  00ed4	48 8b f8	 mov	 rdi, rax
  00ed7	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR cphost$[rsp]
  00edf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ilhost$[rsp]
  00ee7	f3 a4		 rep movsb

; 3014 :         rc = resolve_host( &hrb);

  00ee9	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR hrb$[rsp]
  00ef1	e8 00 00 00 00	 call	 resolve_host
  00ef6	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 3015 :         if (rc == 0)

  00efa	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00eff	75 4f		 jne	 SHORT $LN47@parse_conf

; 3016 :         {
; 3017 :             // OK, a numeric IPv4 address has been specified.
; 3018 :             iFirstFamily[j] = AF_INET;

  00f01	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  00f06	c7 84 84 98 00
	00 00 02 00 00
	00		 mov	 DWORD PTR iFirstFamily$[rsp+rax*4], 2

; 3019 :             STRLCPY( pPTPBLK->szGuestIPAddr4, hrb.ipaddr );

  00f11	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00f19	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  00f1f	41 b8 14 00 00
	00		 mov	 r8d, 20
  00f25	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR hrb$[rsp+256]
  00f2d	48 8b c8	 mov	 rcx, rax
  00f30	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3020 :             memcpy( &pPTPBLK->iaGuestIPAddr4, &hrb.sa.in.sin_addr, sizeof(pPTPBLK->iaGuestIPAddr4) );

  00f36	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00f3e	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR hrb$[rsp+328]
  00f45	89 88 dc 02 00
	00		 mov	 DWORD PTR [rax+732], ecx

; 3021 :         }

  00f4b	e9 dc 02 00 00	 jmp	 $LN48@parse_conf
$LN47@parse_conf:

; 3022 :         else
; 3023 :         {
; 3024 :             // A numeric IPv4 address has not been specified.
; 3025 : #if defined(ENABLE_IPV6)
; 3026 :             // Check whether a numeric IPv6 address has been specified.
; 3027 :             memset( &hrb, 0, sizeof(hrb) );

  00f50	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR hrb$[rsp]
  00f58	48 8b f8	 mov	 rdi, rax
  00f5b	33 c0		 xor	 eax, eax
  00f5d	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  00f62	f3 aa		 rep stosb

; 3028 :             hrb.wantafam = AF_INET6;

  00f64	c7 84 24 f8 02
	00 00 17 00 00
	00		 mov	 DWORD PTR hrb$[rsp+360], 23

; 3029 :             hrb.numeric = TRUE;

  00f6f	c7 84 24 f4 02
	00 00 01 00 00
	00		 mov	 DWORD PTR hrb$[rsp+356], 1

; 3030 :             if (cphost[0] == '[' && cphost[ilhost-1] == ']')

  00f7a	b8 01 00 00 00	 mov	 eax, 1
  00f7f	48 6b c0 00	 imul	 rax, rax, 0
  00f83	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cphost$[rsp]
  00f8b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00f8f	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00f92	75 4b		 jne	 SHORT $LN49@parse_conf
  00f94	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ilhost$[rsp]
  00f9c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cphost$[rsp]
  00fa4	48 03 c8	 add	 rcx, rax
  00fa7	48 8b c1	 mov	 rax, rcx
  00faa	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  00fae	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  00fb1	75 2c		 jne	 SHORT $LN49@parse_conf

; 3031 :             {
; 3032 :                 memcpy( hrb.host, cphost+1, ilhost-2 );

  00fb3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ilhost$[rsp]
  00fbb	48 83 e8 02	 sub	 rax, 2
  00fbf	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cphost$[rsp]
  00fc7	48 ff c1	 inc	 rcx
  00fca	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR hrb$[rsp]
  00fd2	48 8b fa	 mov	 rdi, rdx
  00fd5	48 8b f1	 mov	 rsi, rcx
  00fd8	48 8b c8	 mov	 rcx, rax
  00fdb	f3 a4		 rep movsb

; 3033 :             }

  00fdd	eb 1d		 jmp	 SHORT $LN50@parse_conf
$LN49@parse_conf:

; 3034 :             else
; 3035 :             {
; 3036 :                 memcpy( hrb.host, cphost, ilhost );

  00fdf	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR hrb$[rsp]
  00fe7	48 8b f8	 mov	 rdi, rax
  00fea	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR cphost$[rsp]
  00ff2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ilhost$[rsp]
  00ffa	f3 a4		 rep movsb
$LN50@parse_conf:

; 3037 :             }
; 3038 :             rc = resolve_host( &hrb);

  00ffc	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR hrb$[rsp]
  01004	e8 00 00 00 00	 call	 resolve_host
  01009	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 3039 :             if (rc == 0)

  0100d	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  01012	75 5b		 jne	 SHORT $LN51@parse_conf

; 3040 :             {
; 3041 :                 // OK, a numeric IPv6 address has been specified.
; 3042 :                 iFirstFamily[j] = AF_INET6;

  01014	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  01019	c7 84 84 98 00
	00 00 17 00 00
	00		 mov	 DWORD PTR iFirstFamily$[rsp+rax*4], 23

; 3043 :                 STRLCPY( pPTPBLK->szGuestIPAddr6, hrb.ipaddr );

  01024	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0102c	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  01032	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  01038	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR hrb$[rsp+256]
  01040	48 8b c8	 mov	 rcx, rax
  01043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3044 :                 memcpy( &pPTPBLK->iaGuestIPAddr6, &hrb.sa.in6.sin6_addr, sizeof(pPTPBLK->iaGuestIPAddr6) );

  01049	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01051	48 8d 8c 24 dc
	02 00 00	 lea	 rcx, QWORD PTR hrb$[rsp+332]
  01059	48 8d b8 f0 02
	00 00		 lea	 rdi, QWORD PTR [rax+752]
  01060	48 8b f1	 mov	 rsi, rcx
  01063	b9 10 00 00 00	 mov	 ecx, 16
  01068	f3 a4		 rep movsb

; 3045 :             }

  0106a	e9 bd 01 00 00	 jmp	 $LN52@parse_conf
$LN51@parse_conf:

; 3046 :             else
; 3047 :             {
; 3048 :                 // A numeric IPv6 address has not been specified.
; 3049 : #endif /* defined(ENABLE_IPV6) */
; 3050 :                 // Check whether a host name that resolves to the required
; 3051 :                 // address family has been specified.
; 3052 :                 memset( &hrb, 0, sizeof(hrb) );

  0106f	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR hrb$[rsp]
  01077	48 8b f8	 mov	 rdi, rax
  0107a	33 c0		 xor	 eax, eax
  0107c	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  01081	f3 aa		 rep stosb

; 3053 :                 hrb.wantafam = iWantFamily;

  01083	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR iWantFamily$[rsp]
  0108a	89 84 24 f8 02
	00 00		 mov	 DWORD PTR hrb$[rsp+360], eax

; 3054 :                 memcpy( hrb.host, cphost, ilhost );

  01091	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR hrb$[rsp]
  01099	48 8b f8	 mov	 rdi, rax
  0109c	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR cphost$[rsp]
  010a4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ilhost$[rsp]
  010ac	f3 a4		 rep movsb

; 3055 :                 rc = resolve_host( &hrb);

  010ae	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR hrb$[rsp]
  010b6	e8 00 00 00 00	 call	 resolve_host
  010bb	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 3056 :                 if (rc == 0)

  010bf	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  010c4	0f 85 a9 00 00
	00		 jne	 $LN53@parse_conf

; 3057 :                 {
; 3058 :                     // OK, a host name that resolves to the required address
; 3059 :                     // family has been specified. If no family was specified
; 3060 :                     // (the -4/-6 options) whichever family was first in the
; 3061 :                     // resolve result is being used.
; 3062 :                     iFirstFamily[j] = hrb.afam;

  010ca	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  010cf	8b 8c 24 f0 02
	00 00		 mov	 ecx, DWORD PTR hrb$[rsp+352]
  010d6	89 8c 84 98 00
	00 00		 mov	 DWORD PTR iFirstFamily$[rsp+rax*4], ecx

; 3063 :                     if (iFirstFamily[j] == AF_INET)

  010dd	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  010e2	83 bc 84 98 00
	00 00 02	 cmp	 DWORD PTR iFirstFamily$[rsp+rax*4], 2
  010ea	75 3c		 jne	 SHORT $LN55@parse_conf

; 3064 :                     {
; 3065 :                         STRLCPY( pPTPBLK->szGuestIPAddr4, hrb.ipaddr );

  010ec	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  010f4	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  010fa	41 b8 14 00 00
	00		 mov	 r8d, 20
  01100	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR hrb$[rsp+256]
  01108	48 8b c8	 mov	 rcx, rax
  0110b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3066 :                         memcpy( &pPTPBLK->iaGuestIPAddr4, &hrb.sa.in.sin_addr, sizeof(pPTPBLK->iaGuestIPAddr4) );

  01111	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01119	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR hrb$[rsp+328]
  01120	89 88 dc 02 00
	00		 mov	 DWORD PTR [rax+732], ecx

; 3067 :                     }

  01126	eb 46		 jmp	 SHORT $LN56@parse_conf
$LN55@parse_conf:

; 3068 : #if defined(ENABLE_IPV6)
; 3069 :                     else
; 3070 :                     {
; 3071 :                         STRLCPY( pPTPBLK->szGuestIPAddr6, hrb.ipaddr );

  01128	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01130	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  01136	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  0113c	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR hrb$[rsp+256]
  01144	48 8b c8	 mov	 rcx, rax
  01147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3072 :                         memcpy( &pPTPBLK->iaGuestIPAddr6, &hrb.sa.in6.sin6_addr, sizeof(pPTPBLK->iaGuestIPAddr6) );

  0114d	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01155	48 8d 8c 24 dc
	02 00 00	 lea	 rcx, QWORD PTR hrb$[rsp+332]
  0115d	48 8d b8 f0 02
	00 00		 lea	 rdi, QWORD PTR [rax+752]
  01164	48 8b f1	 mov	 rsi, rcx
  01167	b9 10 00 00 00	 mov	 ecx, 16
  0116c	f3 a4		 rep movsb
$LN56@parse_conf:

; 3073 :                     }
; 3074 : #endif /* defined(ENABLE_IPV6) */
; 3075 :                 }

  0116e	e9 b9 00 00 00	 jmp	 $LN54@parse_conf
$LN53@parse_conf:

; 3076 :                 else
; 3077 :                 {
; 3078 :                     // Something that isn't very useful has been specifed..
; 3079 :                     // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3080 :                     WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  01173	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0117b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0117f	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv650[rsp], eax
  01186	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0118e	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01192	d1 f9		 sar	 ecx, 1
  01194	89 8c 24 10 01
	00 00		 mov	 DWORD PTR tv654[rsp], ecx
  0119b	b9 01 00 00 00	 mov	 ecx, 1
  011a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  011ab	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  011ae	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  011b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171241
  011ba	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  011bf	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  011c7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  011cb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  011d0	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv650[rsp]
  011d7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011db	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv654[rsp]
  011e2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  011e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171242
  011ed	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171243
  011f9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01203	41 b9 03 00 00
	00		 mov	 r9d, 3
  01209	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171244
  01210	ba 09 0c 00 00	 mov	 edx, 3081		; 00000c09H
  01215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171245
  0121c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3081 :                          "IP address", *argv );
; 3082 :                     return -1;

  01222	b8 ff ff ff ff	 mov	 eax, -1
  01227	e9 db 0c 00 00	 jmp	 $LN1@parse_conf
$LN54@parse_conf:
$LN52@parse_conf:
$LN48@parse_conf:

; 3083 :                 }
; 3084 : #if defined(ENABLE_IPV6)
; 3085 :             }
; 3086 : #endif /* defined(ENABLE_IPV6) */
; 3087 :         }
; 3088 : 
; 3089 :         if (cpprfx)

  0122c	48 83 7c 24 78
	00		 cmp	 QWORD PTR cpprfx$[rsp], 0
  01232	0f 84 47 02 00
	00		 je	 $LN57@parse_conf

; 3090 :         {
; 3091 :             if (iFirstFamily[j] == AF_INET)

  01238	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  0123d	83 bc 84 98 00
	00 00 02	 cmp	 DWORD PTR iFirstFamily$[rsp+rax*4], 2
  01245	0f 85 7b 01 00
	00		 jne	 $LN58@parse_conf

; 3092 :             {
; 3093 :                 // Hmm... the Guest IPv4 address was specified with a prefix size.
; 3094 :                 {
; 3095 :                   char    tmp[256];
; 3096 :                   MSGBUF( tmp, "Prefix size specification moved from guest to drive" );

  0124b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171249
  01252	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  01257	48 8d 8c 24 70
	23 00 00	 lea	 rcx, QWORD PTR tmp$3[rsp]
  0125f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3097 :                   WRMSG(HHC03991, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, tmp );

  01265	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0126d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01271	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv709[rsp], eax
  01278	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01280	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01284	d1 f9		 sar	 ecx, 1
  01286	89 8c 24 18 01
	00 00		 mov	 DWORD PTR tv713[rsp], ecx
  0128d	b9 01 00 00 00	 mov	 ecx, 1
  01292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01298	48 8d 8c 24 70
	23 00 00	 lea	 rcx, QWORD PTR tmp$3[rsp]
  012a0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  012a5	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  012ad	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  012b1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  012b6	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv709[rsp]
  012bd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  012c1	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv713[rsp]
  012c8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  012cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171250
  012d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171251
  012df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  012ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171252
  012f6	ba 19 0c 00 00	 mov	 edx, 3097		; 00000c19H
  012fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171253
  01302	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3098 :                 }
; 3099 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3100 :                 WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  01308	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01310	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01314	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv729[rsp], eax
  0131b	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01323	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01327	d1 f9		 sar	 ecx, 1
  01329	89 8c 24 20 01
	00 00		 mov	 DWORD PTR tv733[rsp], ecx
  01330	b9 01 00 00 00	 mov	 ecx, 1
  01335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0133b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01340	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01343	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01348	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171254
  0134f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01354	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0135c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01360	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01365	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR tv729[rsp]
  0136c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01370	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv733[rsp]
  01377	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0137b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171255
  01382	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01387	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171256
  0138e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01393	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01398	41 b9 03 00 00
	00		 mov	 r9d, 3
  0139e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171257
  013a5	ba 1d 0c 00 00	 mov	 edx, 3101		; 00000c1dH
  013aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171258
  013b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3101 :                      "IP address", *argv );
; 3102 :                 return -1;

  013b7	b8 ff ff ff ff	 mov	 eax, -1
  013bc	e9 46 0b 00 00	 jmp	 $LN1@parse_conf

; 3103 :             }

  013c1	e9 b9 00 00 00	 jmp	 $LN59@parse_conf
$LN58@parse_conf:

; 3104 : #if defined(ENABLE_IPV6)
; 3105 :             else
; 3106 :             {
; 3107 :                 // Hmm... the Guest IPv6 address was specified with a prefix size.
; 3108 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3109 :                 WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  013c6	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  013ce	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  013d2	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv749[rsp], eax
  013d9	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  013e1	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  013e5	d1 f9		 sar	 ecx, 1
  013e7	89 8c 24 28 01
	00 00		 mov	 DWORD PTR tv753[rsp], ecx
  013ee	b9 01 00 00 00	 mov	 ecx, 1
  013f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013f9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  013fe	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01401	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01406	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171259
  0140d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01412	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0141a	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0141e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01423	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv749[rsp]
  0142a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0142e	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv753[rsp]
  01435	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01439	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171260
  01440	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01445	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171261
  0144c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01451	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01456	41 b9 03 00 00
	00		 mov	 r9d, 3
  0145c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171262
  01463	ba 26 0c 00 00	 mov	 edx, 3110		; 00000c26H
  01468	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171263
  0146f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3110 :                      "IP address", *argv );
; 3111 :                 return -1;

  01475	b8 ff ff ff ff	 mov	 eax, -1
  0147a	e9 88 0a 00 00	 jmp	 $LN1@parse_conf
$LN59@parse_conf:
$LN57@parse_conf:

; 3112 :             }
; 3113 : #endif /* defined(ENABLE_IPV6) */
; 3114 :         }
; 3115 : 
; 3116 :         argc--; argv++;

  0147f	8b 84 24 b0 24
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  01486	ff c8		 dec	 eax
  01488	89 84 24 b0 24
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0148f	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  01494	48 83 c0 08	 add	 rax, 8
  01498	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 3117 : 
; 3118 :         // Driver IPv4 address and prefix size in CIDR notation.
; 3119 :         //  e.g. 192.168.1.1/24
; 3120 :         // If the prefix size is not specified a value of 32 is assumed,
; 3121 :         // which is equivalent to a netmask of 255.255.255.255. If the
; 3122 :         // prefix size is specified it can have a value from 0 to 32.
; 3123 :         // The value is used to produce the equivalent netmask. For example,
; 3124 :         // a value of 0 will produce a netmask of 0.0.0.0, while a value of
; 3125 :         // 26 will produce a netmask of 255.255.255.192.
; 3126 : 
; 3127 :         // Driver IPv6 address and prefix size in CIDR notation.
; 3128 :         //  e.g. 2001:db8:3003:1::543:210f/48
; 3129 :         // If the prefix size is not specified a value of 128 is
; 3130 :         // assumed. If the prefix size is specified it can have a
; 3131 :         // value from 0 to 128.
; 3132 : 
; 3133 :         cphost = *argv;                      // point to host name/IP address

  0149d	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  014a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  014a5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cphost$[rsp], rax

; 3134 :         ilhost = strlen( *argv );            // calculate size of name/address (assume no prefix)

  014ad	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  014b2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  014b5	e8 00 00 00 00	 call	 strlen
  014ba	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ilhost$[rsp], rax

; 3135 :         cpprfx = strchr( *argv, '/' );       // Point to slash character

  014c2	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  014c7	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  014cc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  014cf	e8 00 00 00 00	 call	 strchr
  014d4	48 89 44 24 78	 mov	 QWORD PTR cpprfx$[rsp], rax

; 3136 :         ilprfx = 0;                          // no prefix size

  014d9	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ilprfx$[rsp], 0

; 3137 :         if (cpprfx)                          // If there is a slash

  014e5	48 83 7c 24 78
	00		 cmp	 QWORD PTR cpprfx$[rsp], 0
  014eb	74 3a		 je	 SHORT $LN60@parse_conf

; 3138 :         {
; 3139 :             ilhost = cpprfx - cphost;        // calculate length of name/address

  014ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cphost$[rsp]
  014f5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cpprfx$[rsp]
  014fa	48 2b c8	 sub	 rcx, rax
  014fd	48 8b c1	 mov	 rax, rcx
  01500	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ilhost$[rsp], rax

; 3140 :             cpprfx++;                        // point to prefix size

  01508	48 8b 44 24 78	 mov	 rax, QWORD PTR cpprfx$[rsp]
  0150d	48 ff c0	 inc	 rax
  01510	48 89 44 24 78	 mov	 QWORD PTR cpprfx$[rsp], rax

; 3141 :             ilprfx = strlen( cpprfx );       // calculate length of prefix size

  01515	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cpprfx$[rsp]
  0151a	e8 00 00 00 00	 call	 strlen
  0151f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR ilprfx$[rsp], rax
$LN60@parse_conf:

; 3142 :         }
; 3143 :         if (ilhost > (size_t)(sizeof(hrb.host)-1))

  01527	48 81 bc 24 88
	00 00 00 ff 00
	00 00		 cmp	 QWORD PTR ilhost$[rsp], 255 ; 000000ffH
  01533	0f 86 b9 00 00
	00		 jbe	 $LN61@parse_conf

; 3144 :         {
; 3145 :             // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3146 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  01539	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01541	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01545	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv782[rsp], eax
  0154c	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01554	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01558	d1 f9		 sar	 ecx, 1
  0155a	89 8c 24 30 01
	00 00		 mov	 DWORD PTR tv786[rsp], ecx
  01561	b9 01 00 00 00	 mov	 ecx, 1
  01566	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0156c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01571	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01574	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01579	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171266
  01580	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01585	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0158d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01591	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01596	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv782[rsp]
  0159d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  015a1	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv786[rsp]
  015a8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  015ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171267
  015b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  015b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171268
  015bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  015cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171269
  015d6	ba 4b 0c 00 00	 mov	 edx, 3147		; 00000c4bH
  015db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171270
  015e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3147 :                   "IP address", *argv );
; 3148 :             return -1;

  015e8	b8 ff ff ff ff	 mov	 eax, -1
  015ed	e9 15 09 00 00	 jmp	 $LN1@parse_conf
$LN61@parse_conf:

; 3149 :         }
; 3150 : 
; 3151 :         memset( &hrb, 0, sizeof(hrb) );

  015f2	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR hrb$[rsp]
  015fa	48 8b f8	 mov	 rdi, rax
  015fd	33 c0		 xor	 eax, eax
  015ff	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  01604	f3 aa		 rep stosb

; 3152 :         hrb.wantafam = iFirstFamily[j];

  01606	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  0160b	8b 84 84 98 00
	00 00		 mov	 eax, DWORD PTR iFirstFamily$[rsp+rax*4]
  01612	89 84 24 f8 02
	00 00		 mov	 DWORD PTR hrb$[rsp+360], eax

; 3153 : #if defined(ENABLE_IPV6)
; 3154 :         if (iFirstFamily[j] == AF_INET6 &&
; 3155 :             cphost[0] == '[' && cphost[ilhost-1] == ']')

  01619	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  0161e	83 bc 84 98 00
	00 00 17	 cmp	 DWORD PTR iFirstFamily$[rsp+rax*4], 23
  01626	75 70		 jne	 SHORT $LN62@parse_conf
  01628	b8 01 00 00 00	 mov	 eax, 1
  0162d	48 6b c0 00	 imul	 rax, rax, 0
  01631	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cphost$[rsp]
  01639	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0163d	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  01640	75 56		 jne	 SHORT $LN62@parse_conf
  01642	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ilhost$[rsp]
  0164a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cphost$[rsp]
  01652	48 03 c8	 add	 rcx, rax
  01655	48 8b c1	 mov	 rax, rcx
  01658	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  0165c	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  0165f	75 37		 jne	 SHORT $LN62@parse_conf

; 3156 :         {
; 3157 :             hrb.numeric = TRUE;

  01661	c7 84 24 f4 02
	00 00 01 00 00
	00		 mov	 DWORD PTR hrb$[rsp+356], 1

; 3158 :             memcpy( hrb.host, cphost+1, ilhost-2 );

  0166c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ilhost$[rsp]
  01674	48 83 e8 02	 sub	 rax, 2
  01678	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cphost$[rsp]
  01680	48 ff c1	 inc	 rcx
  01683	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR hrb$[rsp]
  0168b	48 8b fa	 mov	 rdi, rdx
  0168e	48 8b f1	 mov	 rsi, rcx
  01691	48 8b c8	 mov	 rcx, rax
  01694	f3 a4		 rep movsb

; 3159 :         }

  01696	eb 1d		 jmp	 SHORT $LN63@parse_conf
$LN62@parse_conf:

; 3160 :         else
; 3161 :         {
; 3162 : #endif /* defined(ENABLE_IPV6) */
; 3163 :             memcpy( hrb.host, cphost, ilhost );

  01698	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR hrb$[rsp]
  016a0	48 8b f8	 mov	 rdi, rax
  016a3	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR cphost$[rsp]
  016ab	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ilhost$[rsp]
  016b3	f3 a4		 rep movsb
$LN63@parse_conf:

; 3164 : #if defined(ENABLE_IPV6)
; 3165 :         }
; 3166 : #endif /* defined(ENABLE_IPV6) */
; 3167 :         rc = resolve_host( &hrb);

  016b5	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR hrb$[rsp]
  016bd	e8 00 00 00 00	 call	 resolve_host
  016c2	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 3168 :         if (rc != 0)

  016c6	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  016cb	0f 84 b9 00 00
	00		 je	 $LN64@parse_conf

; 3169 :         {
; 3170 :             // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3171 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  016d1	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  016d9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  016dd	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv837[rsp], eax
  016e4	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  016ec	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  016f0	d1 f9		 sar	 ecx, 1
  016f2	89 8c 24 38 01
	00 00		 mov	 DWORD PTR tv841[rsp], ecx
  016f9	b9 01 00 00 00	 mov	 ecx, 1
  016fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01704	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01709	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0170c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01711	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171274
  01718	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0171d	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01725	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01729	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0172e	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv837[rsp]
  01735	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01739	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv841[rsp]
  01740	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01744	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171275
  0174b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01750	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171276
  01757	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0175c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01761	41 b9 03 00 00
	00		 mov	 r9d, 3
  01767	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171277
  0176e	ba 64 0c 00 00	 mov	 edx, 3172		; 00000c64H
  01773	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171278
  0177a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3172 :                   "IP address", *argv );
; 3173 :             return -1;

  01780	b8 ff ff ff ff	 mov	 eax, -1
  01785	e9 7d 07 00 00	 jmp	 $LN1@parse_conf
$LN64@parse_conf:

; 3174 :         }
; 3175 : 
; 3176 :         if (iFirstFamily[j] == AF_INET)

  0178a	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  0178f	83 bc 84 98 00
	00 00 02	 cmp	 DWORD PTR iFirstFamily$[rsp+rax*4], 2
  01797	75 3c		 jne	 SHORT $LN65@parse_conf

; 3177 :         {
; 3178 :             STRLCPY( pPTPBLK->szDriveIPAddr4, hrb.ipaddr );

  01799	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  017a1	48 05 bc 01 00
	00		 add	 rax, 444		; 000001bcH
  017a7	41 b8 14 00 00
	00		 mov	 r8d, 20
  017ad	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR hrb$[rsp+256]
  017b5	48 8b c8	 mov	 rcx, rax
  017b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3179 :             memcpy( &pPTPBLK->iaDriveIPAddr4, &hrb.sa.in.sin_addr, sizeof(pPTPBLK->iaDriveIPAddr4) );

  017be	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  017c6	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR hrb$[rsp+328]
  017cd	89 88 d8 02 00
	00		 mov	 DWORD PTR [rax+728], ecx

; 3180 :         }

  017d3	eb 46		 jmp	 SHORT $LN66@parse_conf
$LN65@parse_conf:

; 3181 : #if defined(ENABLE_IPV6)
; 3182 :         else
; 3183 :         {
; 3184 :             STRLCPY( pPTPBLK->szDriveIPAddr6, hrb.ipaddr );

  017d5	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  017dd	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  017e3	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  017e9	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR hrb$[rsp+256]
  017f1	48 8b c8	 mov	 rcx, rax
  017f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3185 :             memcpy( &pPTPBLK->iaDriveIPAddr6, &hrb.sa.in6.sin6_addr, sizeof(pPTPBLK->iaDriveIPAddr6) );

  017fa	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01802	48 8d 8c 24 dc
	02 00 00	 lea	 rcx, QWORD PTR hrb$[rsp+332]
  0180a	48 8d b8 e0 02
	00 00		 lea	 rdi, QWORD PTR [rax+736]
  01811	48 8b f1	 mov	 rsi, rcx
  01814	b9 10 00 00 00	 mov	 ecx, 16
  01819	f3 a4		 rep movsb
$LN66@parse_conf:

; 3186 :         }
; 3187 : #endif /* defined(ENABLE_IPV6) */
; 3188 : 
; 3189 :         if (cpprfx)

  0181b	48 83 7c 24 78
	00		 cmp	 QWORD PTR cpprfx$[rsp], 0
  01821	0f 84 5a 04 00
	00		 je	 $LN67@parse_conf

; 3190 :         {
; 3191 :             if (iFirstFamily[j] == AF_INET)

  01827	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  0182c	83 bc 84 98 00
	00 00 02	 cmp	 DWORD PTR iFirstFamily$[rsp+rax*4], 2
  01834	0f 85 77 02 00
	00		 jne	 $LN68@parse_conf

; 3192 :             {
; 3193 :                 if (ilprfx > (size_t)sizeof(pPTPBLK->szDrivePfxSiz4)-1)

  0183a	48 83 bc 24 c8
	00 00 00 07	 cmp	 QWORD PTR ilprfx$[rsp], 7
  01843	0f 86 b9 00 00
	00		 jbe	 $LN70@parse_conf

; 3194 :                 {
; 3195 :                     // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3196 :                     WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  01849	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01851	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01855	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv891[rsp], eax
  0185c	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01864	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01868	d1 f9		 sar	 ecx, 1
  0186a	89 8c 24 40 01
	00 00		 mov	 DWORD PTR tv895[rsp], ecx
  01871	b9 01 00 00 00	 mov	 ecx, 1
  01876	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0187c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01881	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01884	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01889	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171285
  01890	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01895	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0189d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  018a1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  018a6	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv891[rsp]
  018ad	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  018b1	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv895[rsp]
  018b8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  018bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171286
  018c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  018c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171287
  018cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  018d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  018df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171288
  018e6	ba 7d 0c 00 00	 mov	 edx, 3197		; 00000c7dH
  018eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171289
  018f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3197 :                           "prefix size", *argv );
; 3198 :                     return -1;

  018f8	b8 ff ff ff ff	 mov	 eax, -1
  018fd	e9 05 06 00 00	 jmp	 $LN1@parse_conf
$LN70@parse_conf:

; 3199 :                 }
; 3200 :                 iPfxSiz = atoi( cpprfx );

  01902	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cpprfx$[rsp]
  01907	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0190d	89 84 24 80 00
	00 00		 mov	 DWORD PTR iPfxSiz$[rsp], eax

; 3201 :                 if (( iPfxSiz < 0 ) || ( iPfxSiz > 32 ))

  01914	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR iPfxSiz$[rsp], 0
  0191c	7c 0e		 jl	 SHORT $LN72@parse_conf
  0191e	83 bc 24 80 00
	00 00 20	 cmp	 DWORD PTR iPfxSiz$[rsp], 32 ; 00000020H
  01926	0f 8e b9 00 00
	00		 jle	 $LN71@parse_conf
$LN72@parse_conf:

; 3202 :                 {
; 3203 :                     // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3204 :                     WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0192c	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01934	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01938	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv915[rsp], eax
  0193f	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01947	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0194b	d1 f9		 sar	 ecx, 1
  0194d	89 8c 24 48 01
	00 00		 mov	 DWORD PTR tv919[rsp], ecx
  01954	b9 01 00 00 00	 mov	 ecx, 1
  01959	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0195f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01964	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01967	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0196c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171292
  01973	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01978	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01980	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01984	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01989	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv915[rsp]
  01990	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01994	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv919[rsp]
  0199b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0199f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171293
  019a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171294
  019b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  019b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  019c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171295
  019c9	ba 85 0c 00 00	 mov	 edx, 3205		; 00000c85H
  019ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171296
  019d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3205 :                           "prefix size", *argv );
; 3206 :                     return -1;

  019db	b8 ff ff ff ff	 mov	 eax, -1
  019e0	e9 22 05 00 00	 jmp	 $LN1@parse_conf
$LN71@parse_conf:

; 3207 :                 }
; 3208 : 
; 3209 :                 STRLCPY( pPTPBLK->szDrivePfxSiz4, cpprfx );

  019e5	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  019ed	48 05 d0 01 00
	00		 add	 rax, 464		; 000001d0H
  019f3	41 b8 08 00 00
	00		 mov	 r8d, 8
  019f9	48 8b 54 24 78	 mov	 rdx, QWORD PTR cpprfx$[rsp]
  019fe	48 8b c8	 mov	 rcx, rax
  01a01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3210 : 
; 3211 :                 switch( iPfxSiz )

  01a07	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR iPfxSiz$[rsp]
  01a0e	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv962[rsp], eax
  01a15	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv962[rsp], 0
  01a1d	74 0c		 je	 SHORT $LN73@parse_conf
  01a1f	83 bc 24 c0 00
	00 00 20	 cmp	 DWORD PTR tv962[rsp], 32 ; 00000020H
  01a27	74 0f		 je	 SHORT $LN74@parse_conf
  01a29	eb 1a		 jmp	 SHORT $LN75@parse_conf
$LN73@parse_conf:

; 3212 :                 {
; 3213 :                 case 0:
; 3214 :                     mask = 0x00000000;

  01a2b	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR mask$[rsp], 0

; 3215 :                     break;

  01a36	eb 36		 jmp	 SHORT $LN11@parse_conf
$LN74@parse_conf:

; 3216 :                 case 32:
; 3217 :                     mask = 0xFFFFFFFF;

  01a38	c7 84 24 b4 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR mask$[rsp], -1 ; ffffffffH

; 3218 :                     break;

  01a43	eb 29		 jmp	 SHORT $LN11@parse_conf
$LN75@parse_conf:

; 3219 :                 default:
; 3220 :                     mask = 0xFFFFFFFF ^ ( 0xFFFFFFFF >> iPfxSiz );

  01a45	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR iPfxSiz$[rsp]
  01a4c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  01a51	89 8c 24 4c 01
	00 00		 mov	 DWORD PTR tv1568[rsp], ecx
  01a58	0f b6 c8	 movzx	 ecx, al
  01a5b	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR tv1568[rsp]
  01a62	d3 e8		 shr	 eax, cl
  01a64	83 f0 ff	 xor	 eax, -1			; ffffffffH
  01a67	89 84 24 b4 00
	00 00		 mov	 DWORD PTR mask$[rsp], eax
$LN11@parse_conf:

; 3221 :                     break;
; 3222 :                 }
; 3223 :                 addr4.s_addr = htonl(mask);

  01a6e	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR mask$[rsp]
  01a75	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  01a7b	89 84 24 b8 00
	00 00		 mov	 DWORD PTR addr4$[rsp], eax

; 3224 : 
; 3225 :                 hinet_ntop( AF_INET, &addr4, pPTPBLK->szNetMask,

  01a82	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01a8a	48 05 d8 01 00
	00		 add	 rax, 472		; 000001d8H
  01a90	41 b9 14 00 00
	00		 mov	 r9d, 20
  01a96	4c 8b c0	 mov	 r8, rax
  01a99	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR addr4$[rsp]
  01aa1	b9 02 00 00 00	 mov	 ecx, 2
  01aa6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 3226 :                                              sizeof(pPTPBLK->szNetMask) );
; 3227 :             }

  01aac	e9 d0 01 00 00	 jmp	 $LN69@parse_conf
$LN68@parse_conf:

; 3228 : #if defined(ENABLE_IPV6)
; 3229 :             else
; 3230 :             {
; 3231 :                 if (ilprfx > (size_t)sizeof(pPTPBLK->szDrivePfxSiz6)-1)

  01ab1	48 83 bc 24 c8
	00 00 00 07	 cmp	 QWORD PTR ilprfx$[rsp], 7
  01aba	0f 86 b9 00 00
	00		 jbe	 $LN76@parse_conf

; 3232 :                 {
; 3233 :                     // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3234 :                     WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  01ac0	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01ac8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01acc	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv984[rsp], eax
  01ad3	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01adb	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01adf	d1 f9		 sar	 ecx, 1
  01ae1	89 8c 24 54 01
	00 00		 mov	 DWORD PTR tv988[rsp], ecx
  01ae8	b9 01 00 00 00	 mov	 ecx, 1
  01aed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01af3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01af8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01afb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01b00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171301
  01b07	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01b0c	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01b14	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01b18	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01b1d	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR tv984[rsp]
  01b24	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01b28	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR tv988[rsp]
  01b2f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01b33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171302
  01b3a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171303
  01b46	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b4b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b50	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b56	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171304
  01b5d	ba a3 0c 00 00	 mov	 edx, 3235		; 00000ca3H
  01b62	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171305
  01b69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3235 :                           "prefix size", *argv );
; 3236 :                     return -1;

  01b6f	b8 ff ff ff ff	 mov	 eax, -1
  01b74	e9 8e 03 00 00	 jmp	 $LN1@parse_conf
$LN76@parse_conf:

; 3237 :                 }
; 3238 :                 iPfxSiz = atoi( cpprfx );

  01b79	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cpprfx$[rsp]
  01b7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01b84	89 84 24 80 00
	00 00		 mov	 DWORD PTR iPfxSiz$[rsp], eax

; 3239 :                 if (( iPfxSiz < 0 ) || ( iPfxSiz > 128 ))

  01b8b	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR iPfxSiz$[rsp], 0
  01b93	7c 11		 jl	 SHORT $LN78@parse_conf
  01b95	81 bc 24 80 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR iPfxSiz$[rsp], 128 ; 00000080H
  01ba0	0f 8e b9 00 00
	00		 jle	 $LN77@parse_conf
$LN78@parse_conf:

; 3240 :                 {
; 3241 :                     // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 3242 :                     WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  01ba6	48 8b 84 24 a0
	24 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01bae	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01bb2	89 84 24 6c 01
	00 00		 mov	 DWORD PTR tv1008[rsp], eax
  01bb9	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01bc1	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01bc5	d1 f9		 sar	 ecx, 1
  01bc7	89 8c 24 5c 01
	00 00		 mov	 DWORD PTR tv1012[rsp], ecx
  01bce	b9 01 00 00 00	 mov	 ecx, 1
  01bd3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01bd9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01bde	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01be1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01be6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171308
  01bed	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01bf2	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01bfa	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01bfe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01c03	8b 8c 24 6c 01
	00 00		 mov	 ecx, DWORD PTR tv1008[rsp]
  01c0a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01c0e	8b 8c 24 5c 01
	00 00		 mov	 ecx, DWORD PTR tv1012[rsp]
  01c15	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01c19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171309
  01c20	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01c25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171310
  01c2c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c31	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c36	41 b9 03 00 00
	00		 mov	 r9d, 3
  01c3c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171311
  01c43	ba ab 0c 00 00	 mov	 edx, 3243		; 00000cabH
  01c48	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171312
  01c4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3243 :                           "prefix size", *argv );
; 3244 :                     return -1;

  01c55	b8 ff ff ff ff	 mov	 eax, -1
  01c5a	e9 a8 02 00 00	 jmp	 $LN1@parse_conf
$LN77@parse_conf:

; 3245 :                 }
; 3246 :                 STRLCPY( pPTPBLK->szDrivePfxSiz6, cpprfx );

  01c5f	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01c67	48 05 30 02 00
	00		 add	 rax, 560		; 00000230H
  01c6d	41 b8 08 00 00
	00		 mov	 r8d, 8
  01c73	48 8b 54 24 78	 mov	 rdx, QWORD PTR cpprfx$[rsp]
  01c78	48 8b c8	 mov	 rcx, rax
  01c7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN69@parse_conf:
$LN67@parse_conf:

; 3247 :             }
; 3248 : #endif /* defined(ENABLE_IPV6) */
; 3249 :         }
; 3250 : 
; 3251 :         argc--; argv++;

  01c81	8b 84 24 b0 24
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  01c88	ff c8		 dec	 eax
  01c8a	89 84 24 b0 24
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  01c91	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  01c96	48 83 c0 08	 add	 rax, 8
  01c9a	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 3252 : 
; 3253 :         // Remember whether IPv4 or IPv6 addresses were specified.
; 3254 :         if (iFirstFamily[j] == AF_INET)

  01c9f	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  01ca4	83 bc 84 98 00
	00 00 02	 cmp	 DWORD PTR iFirstFamily$[rsp+rax*4], 2
  01cac	75 1b		 jne	 SHORT $LN79@parse_conf

; 3255 :             pPTPBLK->fIPv4Spec = TRUE;

  01cae	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01cb6	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01cb9	83 c8 01	 or	 eax, 1
  01cbc	48 8b 8c 24 a8
	24 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01cc4	89 41 6c	 mov	 DWORD PTR [rcx+108], eax
  01cc7	eb 19		 jmp	 SHORT $LN80@parse_conf
$LN79@parse_conf:

; 3256 : #if defined(ENABLE_IPV6)
; 3257 :         else
; 3258 :             pPTPBLK->fIPv6Spec = TRUE;

  01cc9	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01cd1	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01cd4	83 c8 02	 or	 eax, 2
  01cd7	48 8b 8c 24 a8
	24 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01cdf	89 41 6c	 mov	 DWORD PTR [rcx+108], eax
$LN80@parse_conf:

; 3259 : #endif /* defined(ENABLE_IPV6) */
; 3260 : 
; 3261 :         // Decide what address family the next pair of IP addresses should be.
; 3262 : #if defined(ENABLE_IPV6)
; 3263 :         if (iWantFamily == AF_INET)

  01ce2	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR iWantFamily$[rsp], 2
  01cea	75 0d		 jne	 SHORT $LN81@parse_conf

; 3264 :             iWantFamily = AF_INET6;

  01cec	c7 84 24 84 00
	00 00 17 00 00
	00		 mov	 DWORD PTR iWantFamily$[rsp], 23
  01cf7	eb 3e		 jmp	 SHORT $LN82@parse_conf
$LN81@parse_conf:

; 3265 :         else if (iWantFamily == AF_INET6)

  01cf9	83 bc 24 84 00
	00 00 17	 cmp	 DWORD PTR iWantFamily$[rsp], 23
  01d01	75 0d		 jne	 SHORT $LN83@parse_conf

; 3266 :             iWantFamily = AF_INET;

  01d03	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR iWantFamily$[rsp], 2
  01d0e	eb 27		 jmp	 SHORT $LN84@parse_conf
$LN83@parse_conf:

; 3267 :         else
; 3268 :         {
; 3269 :             if (iFirstFamily[j] == AF_INET)

  01d10	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$[rsp]
  01d15	83 bc 84 98 00
	00 00 02	 cmp	 DWORD PTR iFirstFamily$[rsp+rax*4], 2
  01d1d	75 0d		 jne	 SHORT $LN85@parse_conf

; 3270 :                 iWantFamily = AF_INET6;

  01d1f	c7 84 24 84 00
	00 00 17 00 00
	00		 mov	 DWORD PTR iWantFamily$[rsp], 23
  01d2a	eb 0b		 jmp	 SHORT $LN86@parse_conf
$LN85@parse_conf:

; 3271 :             else
; 3272 : #endif /* defined(ENABLE_IPV6) */
; 3273 :                 iWantFamily = AF_INET;

  01d2c	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR iWantFamily$[rsp], 2
$LN86@parse_conf:
$LN84@parse_conf:
$LN82@parse_conf:

; 3274 : #if defined(ENABLE_IPV6)
; 3275 :         }
; 3276 : #endif /* defined(ENABLE_IPV6) */
; 3277 : 
; 3278 :         j++;

  01d37	8b 44 24 60	 mov	 eax, DWORD PTR j$[rsp]
  01d3b	ff c0		 inc	 eax
  01d3d	89 44 24 60	 mov	 DWORD PTR j$[rsp], eax

; 3279 :     }   /* while( argc > 0 ) */

  01d41	e9 f9 ef ff ff	 jmp	 $LN9@parse_conf
$LN10@parse_conf:

; 3280 : 
; 3281 :     // Good, the configuration statement had no obvious errors.
; 3282 :     if (pPTPBLK->fPreconfigured)

  01d46	48 8b 84 24 a8
	24 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01d4e	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01d51	c1 e8 06	 shr	 eax, 6
  01d54	83 e0 01	 and	 eax, 1
  01d57	85 c0		 test	 eax, eax
  01d59	74 1b		 je	 SHORT $LN87@parse_conf

; 3283 :         rc = get_preconfigured_value(pDEVBLK, pPTPBLK);

  01d5b	48 8b 94 24 a8
	24 00 00	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  01d63	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01d6b	e8 00 00 00 00	 call	 get_preconfigured_value
  01d70	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  01d74	eb 19		 jmp	 SHORT $LN88@parse_conf
$LN87@parse_conf:

; 3284 :     else
; 3285 :         rc = check_specified_value(pDEVBLK, pPTPBLK);

  01d76	48 8b 94 24 a8
	24 00 00	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  01d7e	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01d86	e8 00 00 00 00	 call	 check_specified_value
  01d8b	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
$LN88@parse_conf:

; 3286 :     if (rc != 0)

  01d8f	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  01d94	74 0a		 je	 SHORT $LN89@parse_conf

; 3287 :         return -1;

  01d96	b8 ff ff ff ff	 mov	 eax, -1
  01d9b	e9 67 01 00 00	 jmp	 $LN1@parse_conf
$LN89@parse_conf:

; 3288 : 
; 3289 : #if defined(OPTION_W32_CTCI)
; 3290 :     // If the MAC address was not specified in the configuration
; 3291 :     // statement, create a MAC address using pseudo-random numbers.
; 3292 :     if (!pPTPBLK->szMACAddress[0])

  01da0	b8 01 00 00 00	 mov	 eax, 1
  01da5	48 6b c0 00	 imul	 rax, rax, 0
  01da9	48 8b 8c 24 a8
	24 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  01db1	0f be 84 01 9c
	01 00 00	 movsx	 eax, BYTE PTR [rcx+rax+412]
  01db9	85 c0		 test	 eax, eax
  01dbb	0f 85 44 01 00
	00		 jne	 $LN90@parse_conf

; 3293 :     {
; 3294 :         for( j = 0; j < 6; j++ )

  01dc1	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  01dc9	eb 0a		 jmp	 SHORT $LN15@parse_conf
$LN13@parse_conf:
  01dcb	8b 44 24 60	 mov	 eax, DWORD PTR j$[rsp]
  01dcf	ff c0		 inc	 eax
  01dd1	89 44 24 60	 mov	 DWORD PTR j$[rsp], eax
$LN15@parse_conf:
  01dd5	83 7c 24 60 06	 cmp	 DWORD PTR j$[rsp], 6
  01dda	7d 2c		 jge	 SHORT $LN14@parse_conf

; 3295 :             mac[j] = (int)((rand()/(RAND_MAX+1.0))*256);

  01ddc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  01de2	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  01de6	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  01dee	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4070000000000000
  01df6	f2 0f 2c c0	 cvttsd2si eax, xmm0
  01dfa	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR j$[rsp]
  01dff	88 84 0c 60 23
	00 00		 mov	 BYTE PTR mac$[rsp+rcx], al
  01e06	eb c3		 jmp	 SHORT $LN13@parse_conf
$LN14@parse_conf:

; 3296 :         mac[0] &= 0xFE;  /* Clear multicast bit. */

  01e08	b8 01 00 00 00	 mov	 eax, 1
  01e0d	48 6b c0 00	 imul	 rax, rax, 0
  01e11	0f b6 84 04 60
	23 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  01e19	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  01e1e	b9 01 00 00 00	 mov	 ecx, 1
  01e23	48 6b c9 00	 imul	 rcx, rcx, 0
  01e27	88 84 0c 60 23
	00 00		 mov	 BYTE PTR mac$[rsp+rcx], al

; 3297 :         mac[0] |= 0x02;  /* Set local assignment bit. */

  01e2e	b8 01 00 00 00	 mov	 eax, 1
  01e33	48 6b c0 00	 imul	 rax, rax, 0
  01e37	0f b6 84 04 60
	23 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  01e3f	83 c8 02	 or	 eax, 2
  01e42	b9 01 00 00 00	 mov	 ecx, 1
  01e47	48 6b c9 00	 imul	 rcx, rcx, 0
  01e4b	88 84 0c 60 23
	00 00		 mov	 BYTE PTR mac$[rsp+rcx], al

; 3298 : 
; 3299 :         MSGBUF

  01e52	b8 01 00 00 00	 mov	 eax, 1
  01e57	48 6b c0 05	 imul	 rax, rax, 5
  01e5b	0f b6 84 04 60
	23 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  01e63	b9 01 00 00 00	 mov	 ecx, 1
  01e68	48 6b c9 04	 imul	 rcx, rcx, 4
  01e6c	0f b6 8c 0c 60
	23 00 00	 movzx	 ecx, BYTE PTR mac$[rsp+rcx]
  01e74	ba 01 00 00 00	 mov	 edx, 1
  01e79	48 6b d2 03	 imul	 rdx, rdx, 3
  01e7d	0f b6 94 14 60
	23 00 00	 movzx	 edx, BYTE PTR mac$[rsp+rdx]
  01e85	bf 01 00 00 00	 mov	 edi, 1
  01e8a	48 6b ff 02	 imul	 rdi, rdi, 2
  01e8e	0f b6 bc 3c 60
	23 00 00	 movzx	 edi, BYTE PTR mac$[rsp+rdi]
  01e96	be 01 00 00 00	 mov	 esi, 1
  01e9b	48 6b f6 01	 imul	 rsi, rsi, 1
  01e9f	0f b6 b4 34 60
	23 00 00	 movzx	 esi, BYTE PTR mac$[rsp+rsi]
  01ea7	41 b8 01 00 00
	00		 mov	 r8d, 1
  01ead	4d 6b c0 00	 imul	 r8, r8, 0
  01eb1	46 0f b6 84 04
	60 23 00 00	 movzx	 r8d, BYTE PTR mac$[rsp+r8]
  01eba	4c 8b 8c 24 a8
	24 00 00	 mov	 r9, QWORD PTR pPTPBLK$[rsp]
  01ec2	49 81 c1 9c 01
	00 00		 add	 r9, 412			; 0000019cH
  01ec9	4c 89 8c 24 88
	01 00 00	 mov	 QWORD PTR tv1116[rsp], r9
  01ed1	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  01ed5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01ed9	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  01edd	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  01ee1	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  01ee5	45 8b c8	 mov	 r9d, r8d
  01ee8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171325
  01eef	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  01ef4	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR tv1116[rsp]
  01efc	48 8b c8	 mov	 rcx, rax
  01eff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN90@parse_conf:

; 3300 :         (
; 3301 :             pPTPBLK->szMACAddress,
; 3302 :             "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
; 3303 :             mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]
; 3304 :         );
; 3305 :     }
; 3306 : #endif /* defined(OPTION_W32_CTCI) */
; 3307 : 
; 3308 :     // That's all folks.
; 3309 :     return 0;

  01f05	33 c0		 xor	 eax, eax
$LN1@parse_conf:

; 3310 : }   /* End function  parse_conf_stmt() */

  01f07	48 8b 8c 24 70
	24 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01f0f	48 33 cc	 xor	 rcx, rsp
  01f12	e8 00 00 00 00	 call	 __security_check_cookie
  01f17	48 81 c4 88 24
	00 00		 add	 rsp, 9352		; 00002488H
  01f1e	5f		 pop	 rdi
  01f1f	5e		 pop	 rsi
  01f20	c3		 ret	 0
  01f21	0f 1f 00	 npad	 3
$LN93@parse_conf:
  01f24	00 00 00 00	 DD	 $LN30@parse_conf
  01f28	00 00 00 00	 DD	 $LN31@parse_conf
  01f2c	00 00 00 00	 DD	 $LN25@parse_conf
  01f30	00 00 00 00	 DD	 $LN38@parse_conf
  01f34	00 00 00 00	 DD	 $LN35@parse_conf
  01f38	00 00 00 00	 DD	 $LN32@parse_conf
  01f3c	00 00 00 00	 DD	 $LN18@parse_conf
  01f40	00 00 00 00	 DD	 $LN22@parse_conf
  01f44	00 00 00 00	 DD	 $LN41@parse_conf
$LN92@parse_conf:
  01f48	00		 DB	 0
  01f49	08		 DB	 8
  01f4a	01		 DB	 1
  01f4b	08		 DB	 8
  01f4c	08		 DB	 8
  01f4d	08		 DB	 8
  01f4e	08		 DB	 8
  01f4f	08		 DB	 8
  01f50	08		 DB	 8
  01f51	08		 DB	 8
  01f52	08		 DB	 8
  01f53	08		 DB	 8
  01f54	08		 DB	 8
  01f55	08		 DB	 8
  01f56	08		 DB	 8
  01f57	08		 DB	 8
  01f58	08		 DB	 8
  01f59	08		 DB	 8
  01f5a	08		 DB	 8
  01f5b	08		 DB	 8
  01f5c	08		 DB	 8
  01f5d	08		 DB	 8
  01f5e	08		 DB	 8
  01f5f	08		 DB	 8
  01f60	08		 DB	 8
  01f61	08		 DB	 8
  01f62	08		 DB	 8
  01f63	08		 DB	 8
  01f64	08		 DB	 8
  01f65	08		 DB	 8
  01f66	08		 DB	 8
  01f67	08		 DB	 8
  01f68	08		 DB	 8
  01f69	08		 DB	 8
  01f6a	08		 DB	 8
  01f6b	08		 DB	 8
  01f6c	08		 DB	 8
  01f6d	08		 DB	 8
  01f6e	08		 DB	 8
  01f6f	08		 DB	 8
  01f70	08		 DB	 8
  01f71	08		 DB	 8
  01f72	08		 DB	 8
  01f73	08		 DB	 8
  01f74	08		 DB	 8
  01f75	08		 DB	 8
  01f76	08		 DB	 8
  01f77	08		 DB	 8
  01f78	02		 DB	 2
  01f79	08		 DB	 8
  01f7a	08		 DB	 8
  01f7b	08		 DB	 8
  01f7c	08		 DB	 8
  01f7d	03		 DB	 3
  01f7e	08		 DB	 8
  01f7f	04		 DB	 4
  01f80	08		 DB	 8
  01f81	05		 DB	 5
  01f82	06		 DB	 6
  01f83	08		 DB	 8
  01f84	08		 DB	 8
  01f85	08		 DB	 8
  01f86	08		 DB	 8
  01f87	08		 DB	 8
  01f88	07		 DB	 7
parse_conf_stmt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
iStorLen$ = 96
tv83 = 100
tv87 = 104
pStorPtr$ = 112
tv71 = 120
tv132 = 128
etext$ = 136
__$ArrayPad$ = 176
pDEVBLK$ = 208
iSize$ = 216
alloc_storage PROC

; 2505 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2506 : 
; 2507 :     void*      pStorPtr;               // Storage pointer
; 2508 :     int        iStorLen;               // Storage length
; 2509 :     char       etext[40];              // malloc error text
; 2510 : 
; 2511 : 
; 2512 :     // Allocate the storage.
; 2513 :     iStorLen = iSize;

  00023	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR iSize$[rsp]
  0002a	89 44 24 60	 mov	 DWORD PTR iStorLen$[rsp], eax

; 2514 :     pStorPtr = malloc( iStorLen );     // Allocate the storage

  0002e	48 63 44 24 60	 movsxd	 rax, DWORD PTR iStorLen$[rsp]
  00033	48 8b c8	 mov	 rcx, rax
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003c	48 89 44 24 70	 mov	 QWORD PTR pStorPtr$[rsp], rax

; 2515 :     if (!pStorPtr)                     // if the allocate was not successful...

  00041	48 83 7c 24 70
	00		 cmp	 QWORD PTR pStorPtr$[rsp], 0
  00047	0f 85 d7 00 00
	00		 jne	 $LN2@alloc_stor

; 2516 :     {
; 2517 :         // Report the bad news.
; 2518 :         MSGBUF( etext, "malloc(%n)", &iStorLen );

  0004d	4c 8d 4c 24 60	 lea	 r9, QWORD PTR iStorLen$[rsp]
  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171064
  00059	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0005e	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2519 :         // HHC00900 "%1d:%04X %s: error in function %s: %s"
; 2520 :         WRMSG(HHC00900, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00072	8b 08		 mov	 ecx, DWORD PTR [rax]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0007a	48 89 44 24 78	 mov	 QWORD PTR tv71[rsp], rax
  0007f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00087	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0008b	89 4c 24 64	 mov	 DWORD PTR tv83[rsp], ecx
  0008f	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00097	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0009b	d1 fa		 sar	 edx, 1
  0009d	89 54 24 68	 mov	 DWORD PTR tv87[rsp], edx
  000a1	b9 01 00 00 00	 mov	 ecx, 1
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ac	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv71[rsp]
  000b1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000b6	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  000be	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000c3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000cb	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000cf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d4	8b 4c 24 64	 mov	 ecx, DWORD PTR tv83[rsp]
  000d8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000dc	8b 4c 24 68	 mov	 ecx, DWORD PTR tv87[rsp]
  000e0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171065
  000eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171066
  000f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00101	41 b9 03 00 00
	00		 mov	 r9d, 3
  00107	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171067
  0010e	ba d9 09 00 00	 mov	 edx, 2521		; 000009d9H
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171068
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2521 :                              etext, strerror(errno) );
; 2522 :         return NULL;

  00120	33 c0		 xor	 eax, eax
  00122	eb 23		 jmp	 SHORT $LN1@alloc_stor
$LN2@alloc_stor:

; 2523 :     }
; 2524 : 
; 2525 :     // Clear the storage.
; 2526 :     memset( pStorPtr, 0, iStorLen );

  00124	48 63 44 24 60	 movsxd	 rax, DWORD PTR iStorLen$[rsp]
  00129	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  00131	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pStorPtr$[rsp]
  00136	33 c0		 xor	 eax, eax
  00138	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  00140	f3 aa		 rep stosb

; 2527 : 
; 2528 :     return pStorPtr;

  00142	48 8b 44 24 70	 mov	 rax, QWORD PTR pStorPtr$[rsp]
$LN1@alloc_stor:

; 2529 : }

  00147	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014f	48 33 cc	 xor	 rcx, rsp
  00152	e8 00 00 00 00	 call	 __security_check_cookie
  00157	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  0015e	5f		 pop	 rdi
  0015f	c3		 ret	 0
alloc_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
iBufLen$ = 96
pPTPHDR$ = 104
tv86 = 112
tv90 = 116
tv74 = 120
tv135 = 128
etext$ = 136
__$ArrayPad$ = 176
pDEVBLK$ = 208
iSize$ = 216
alloc_ptp_buffer PROC

; 2472 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2473 : 
; 2474 :     PTPHDR*    pPTPHDR;                // PTPHDR
; 2475 :     int        iBufLen;                // Buffer length
; 2476 :     char       etext[40];              // malloc error text
; 2477 : 
; 2478 : 
; 2479 :     // Allocate the buffer.
; 2480 :     iBufLen = SIZE_HDR + iSize;

  00023	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR iSize$[rsp]
  0002b	48 83 c0 10	 add	 rax, 16
  0002f	89 44 24 60	 mov	 DWORD PTR iBufLen$[rsp], eax

; 2481 :     pPTPHDR = malloc( iBufLen );       // Allocate the buffer

  00033	48 63 44 24 60	 movsxd	 rax, DWORD PTR iBufLen$[rsp]
  00038	48 8b c8	 mov	 rcx, rax
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00041	48 89 44 24 68	 mov	 QWORD PTR pPTPHDR$[rsp], rax

; 2482 :     if (!pPTPHDR)                      // if the allocate was not successful...

  00046	48 83 7c 24 68
	00		 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  0004c	0f 85 d7 00 00
	00		 jne	 $LN2@alloc_ptp_

; 2483 :     {
; 2484 :         // Report the bad news.
; 2485 :         MSGBUF( etext, "malloc(%n)", &iBufLen );

  00052	4c 8d 4c 24 60	 lea	 r9, QWORD PTR iBufLen$[rsp]
  00057	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171049
  0005e	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00063	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2486 :         // HHC00900 "%1d:%04X %s: error in function %s: %s"
; 2487 :         WRMSG(HHC00900, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00077	8b 08		 mov	 ecx, DWORD PTR [rax]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0007f	48 89 44 24 78	 mov	 QWORD PTR tv74[rsp], rax
  00084	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0008c	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00090	89 4c 24 70	 mov	 DWORD PTR tv86[rsp], ecx
  00094	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0009c	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  000a0	d1 fa		 sar	 edx, 1
  000a2	89 54 24 74	 mov	 DWORD PTR tv90[rsp], edx
  000a6	b9 01 00 00 00	 mov	 ecx, 1
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv74[rsp]
  000b6	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000bb	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  000c3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000c8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000d0	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000d4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d9	8b 4c 24 70	 mov	 ecx, DWORD PTR tv86[rsp]
  000dd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e1	8b 4c 24 74	 mov	 ecx, DWORD PTR tv90[rsp]
  000e5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171050
  000f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171051
  000fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00101	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00106	41 b9 03 00 00
	00		 mov	 r9d, 3
  0010c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171052
  00113	ba b8 09 00 00	 mov	 edx, 2488		; 000009b8H
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171053
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2488 :                              etext, strerror(errno) );
; 2489 :         return NULL;

  00125	33 c0		 xor	 eax, eax
  00127	eb 32		 jmp	 SHORT $LN1@alloc_ptp_
$LN2@alloc_ptp_:

; 2490 :     }
; 2491 : 
; 2492 :     // Clear the buffer.
; 2493 :     memset( pPTPHDR, 0, iBufLen );

  00129	48 63 44 24 60	 movsxd	 rax, DWORD PTR iBufLen$[rsp]
  0012e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  00136	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pPTPHDR$[rsp]
  0013b	33 c0		 xor	 eax, eax
  0013d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv135[rsp]
  00145	f3 aa		 rep stosb

; 2494 :     pPTPHDR->iAreaLen = iSize;

  00147	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  0014c	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR iSize$[rsp]
  00153	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 2495 : 
; 2496 :     return pPTPHDR;

  00156	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
$LN1@alloc_ptp_:

; 2497 : }

  0015b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00163	48 33 cc	 xor	 rcx, rsp
  00166	e8 00 00 00 00	 call	 __security_check_cookie
  0016b	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00172	5f		 pop	 rdi
  00173	c3		 ret	 0
alloc_ptp_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPHDR$ = 32
pPTPATH$ = 64
remove_and_free_any_buffers_on_chain PROC

; 2439 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2440 : 
; 2441 :     PTPHDR*    pPTPHDR;                                // PTPHDR
; 2442 : 
; 2443 :     // Obtain the path chain lock.
; 2444 :     obtain_lock( &pPTPATH->ChainLock );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0000e	48 83 c0 10	 add	 rax, 16
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171036
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@remove_and:

; 2445 : 
; 2446 :     // Remove and free the first PTPHDR on the chain, if there is one...
; 2447 :     while( pPTPATH->pFirstPTPHDR != NULL )

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00027	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0002c	74 2c		 je	 SHORT $LN3@remove_and

; 2448 :     {
; 2449 :         pPTPHDR = pPTPATH->pFirstPTPHDR;               // Pointer to first PTPHDR

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00033	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00037	48 89 44 24 20	 mov	 QWORD PTR pPTPHDR$[rsp], rax

; 2450 :         pPTPATH->pFirstPTPHDR = pPTPHDR->pNextPTPHDR;  // Make the next the first PTPHDR

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00046	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00049	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2451 :         free( pPTPHDR );                               // Free the message buffer

  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2452 :     }

  00058	eb c8		 jmp	 SHORT $LN2@remove_and
$LN3@remove_and:

; 2453 : 
; 2454 :     // Reset the chain pointers.
; 2455 :     pPTPATH->pFirstPTPHDR = NULL;                      // Clear

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0005f	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 2456 :     pPTPATH->pLastPTPHDR = NULL;                       // the chain

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0006c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 2457 :     pPTPATH->iNumPTPHDR = 0;                           // pointers and count

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00079	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 2458 : 
; 2459 :     // Release the path chain lock.
; 2460 :     release_lock( &pPTPATH->ChainLock );

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00085	48 83 c0 10	 add	 rax, 16
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171037
  00090	48 8b c8	 mov	 rcx, rax
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2461 : 
; 2462 :     return NULL;

  00099	33 c0		 xor	 eax, eax

; 2463 : 
; 2464 : }

  0009b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009f	c3		 ret	 0
remove_and_free_any_buffers_on_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPHDR$ = 32
pPTPATH$ = 64
remove_buffer_from_chain PROC

; 2404 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2405 : 
; 2406 :     PTPHDR*    pPTPHDR;                                // PTPHDR
; 2407 : 
; 2408 :     // Obtain the path chain lock.
; 2409 :     obtain_lock( &pPTPATH->ChainLock );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0000e	48 83 c0 10	 add	 rax, 16
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171021
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2410 : 
; 2411 :     // Point to first PTPHDR on the chain.
; 2412 :     pPTPHDR = pPTPATH->pFirstPTPHDR;                   // Pointer to first PTPHDR

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00027	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002b	48 89 44 24 20	 mov	 QWORD PTR pPTPHDR$[rsp], rax

; 2413 : 
; 2414 :     // Remove the first PTPHDR from the chain, if there is one...
; 2415 :     if (pPTPHDR)                                       // If there is a PTPHDR

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  00036	74 54		 je	 SHORT $LN2@remove_buf

; 2416 :     {
; 2417 :         pPTPATH->pFirstPTPHDR = pPTPHDR->pNextPTPHDR;  // Make the next the first PTPHDR

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00042	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00045	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2418 :         pPTPATH->iNumPTPHDR--;                         // Decrement number of PTPHDRs

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0004e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00051	ff c8		 dec	 eax
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00058	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 2419 :         pPTPHDR->pNextPTPHDR = NULL;                   // Clear the pointer to next PTPHDR

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00060	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2420 :         if (!pPTPATH->pFirstPTPHDR)                    // if there are no more PTPHDRs

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0006c	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00071	75 19		 jne	 SHORT $LN3@remove_buf

; 2421 :         {
; 2422 : //          pPTPATH->pFirstPTPHDR = NULL;              // Clear
; 2423 :             pPTPATH->pLastPTPHDR = NULL;               // the chain

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00078	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 2424 :             pPTPATH->iNumPTPHDR = 0;                   // pointers and count

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00085	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0
$LN3@remove_buf:
$LN2@remove_buf:

; 2425 :         }
; 2426 :     }
; 2427 : 
; 2428 :     // Release the path chain lock.
; 2429 :     release_lock( &pPTPATH->ChainLock );

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00091	48 83 c0 10	 add	 rax, 16
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171024
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2430 : 
; 2431 :     return pPTPHDR;

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPHDR$[rsp]

; 2432 : }

  000aa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ae	c3		 ret	 0
remove_buffer_from_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPATH$ = 48
pPTPHDR$ = 56
add_buffer_to_chain PROC

; 2369 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2370 : 
; 2371 :     // Prepare PTPHDR for adding to chain.
; 2372 :     if (!pPTPHDR)                                      // Any PTPHDR been passed?

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  00014	75 07		 jne	 SHORT $LN2@add_buffer

; 2373 :         return NULL;

  00016	33 c0		 xor	 eax, eax
  00018	e9 a7 00 00 00	 jmp	 $LN1@add_buffer
$LN2@add_buffer:

; 2374 :     pPTPHDR->pNextPTPHDR = NULL;                       // Clear the pointer to next PTPHDR

  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00022	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2375 : 
; 2376 :     // Obtain the path chain lock.
; 2377 :     obtain_lock( &pPTPATH->ChainLock );

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0002e	48 83 c0 10	 add	 rax, 16
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171011
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2378 : 
; 2379 :     // Add PTPHDR to end of chain.
; 2380 :     if (pPTPATH->pFirstPTPHDR)                         // if there are already PTPHDRs

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00047	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0004c	74 33		 je	 SHORT $LN3@add_buffer

; 2381 :     {
; 2382 :         pPTPATH->pLastPTPHDR->pNextPTPHDR = pPTPHDR;   // Add the PTPHDR to

  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00053	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00057	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  0005c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2383 :         pPTPATH->pLastPTPHDR = pPTPHDR;                // the end of the chain

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00064	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00069	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2384 :         pPTPATH->iNumPTPHDR++;                         // Increment number of PTPHDRs

  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00072	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00075	ff c0		 inc	 eax
  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  0007c	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 2385 :     }

  0007f	eb 28		 jmp	 SHORT $LN4@add_buffer
$LN3@add_buffer:

; 2386 :     else
; 2387 :     {
; 2388 :         pPTPATH->pFirstPTPHDR = pPTPHDR;               // Make the PTPHDR

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00086	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  0008b	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2389 :         pPTPATH->pLastPTPHDR = pPTPHDR;                // the only PTPHDR

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00094	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00099	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2390 :         pPTPATH->iNumPTPHDR = 1;                       // on the chain

  0009d	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000a2	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [rax+40], 1
$LN4@add_buffer:

; 2391 :     }
; 2392 : 
; 2393 :     // Release the path chain lock.
; 2394 :     release_lock( &pPTPATH->ChainLock );

  000a9	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000ae	48 83 c0 10	 add	 rax, 16
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171014
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2395 : 
; 2396 :     return NULL;

  000c2	33 c0		 xor	 eax, eax
$LN1@add_buffer:

; 2397 : }

  000c4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c8	c3		 ret	 0
add_buffer_to_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPBLK$ = 32
pPTPATH$ = 64
pPTPHDR$ = 72
add_buffer_to_chain_and_signal_event PROC

; 2328 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2329 :     PTPBLK*  pPTPBLK = pPTPATH->pPTPBLK;               // PTPBLK

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 20	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 2330 : 
; 2331 :     // Prepare PTPHDR for adding to chain.
; 2332 :     if (!pPTPHDR)                                      // Any PTPHDR been passed?

  0001b	48 83 7c 24 48
	00		 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  00021	75 07		 jne	 SHORT $LN2@add_buffer

; 2333 :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	e9 f2 00 00 00	 jmp	 $LN1@add_buffer
$LN2@add_buffer:

; 2334 :     pPTPHDR->pNextPTPHDR = NULL;                       // Clear the pointer to next PTPHDR

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  0002f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2335 : 
; 2336 :     // Obtain the path chain lock.
; 2337 :     obtain_lock( &pPTPATH->ChainLock );

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003b	48 83 c0 10	 add	 rax, 16
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170995
  00046	48 8b c8	 mov	 rcx, rax
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2338 : 
; 2339 :     // Add PTPHDR to end of chain.
; 2340 :     if (pPTPATH->pFirstPTPHDR)                         // if there are already PTPHDRs

  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00054	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00059	74 33		 je	 SHORT $LN3@add_buffer

; 2341 :     {
; 2342 :         pPTPATH->pLastPTPHDR->pNextPTPHDR = pPTPHDR;   // Add the PTPHDR to

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00060	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00064	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00069	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2343 :         pPTPATH->pLastPTPHDR = pPTPHDR;                // the end of the chain

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00071	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00076	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2344 :         pPTPATH->iNumPTPHDR++;                         // Increment number of PTPHDRs

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0007f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00082	ff c0		 inc	 eax
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00089	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 2345 :     }

  0008c	eb 28		 jmp	 SHORT $LN4@add_buffer
$LN3@add_buffer:

; 2346 :     else
; 2347 :     {
; 2348 :         pPTPATH->pFirstPTPHDR = pPTPHDR;               // Make the PTPHDR

  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00093	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00098	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2349 :         pPTPATH->pLastPTPHDR = pPTPHDR;                // the only PTPHDR

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  000a6	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2350 :         pPTPATH->iNumPTPHDR = 1;                       // on the chain

  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000af	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [rax+40], 1
$LN4@add_buffer:

; 2351 :     }
; 2352 : 
; 2353 :     // Release the path chain lock.
; 2354 :     release_lock( &pPTPATH->ChainLock );

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000bb	48 83 c0 10	 add	 rax, 16
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170998
  000c6	48 8b c8	 mov	 rcx, rax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2355 : 
; 2356 :     //
; 2357 :     obtain_lock( &pPTPBLK->ReadEventLock );

  000cf	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000d4	48 83 c0 40	 add	 rax, 64			; 00000040H
  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170999
  000df	48 8b c8	 mov	 rcx, rax
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2358 :     signal_condition( &pPTPBLK->ReadEvent );

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000ed	48 83 c0 48	 add	 rax, 72			; 00000048H
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171000
  000f8	48 8b c8	 mov	 rcx, rax
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2359 :     release_lock( &pPTPBLK->ReadEventLock );

  00101	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00106	48 83 c0 40	 add	 rax, 64			; 00000040H
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171001
  00111	48 8b c8	 mov	 rcx, rax
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2360 : 
; 2361 :     return NULL;

  0011a	33 c0		 xor	 eax, eax
$LN1@add_buffer:

; 2362 : }

  0011c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00120	c3		 ret	 0
add_buffer_to_chain_and_signal_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
iLength$ = 112
iTraceLen$ = 116
pPTPBLK$ = 120
pDEVBLK$ = 128
uPayLen$ = 136
pTunBuf$ = 144
iPktLen$ = 152
rc$1 = 156
iPktVer$ = 160
pPTPHDR$ = 168
iTunLen$ = 176
tv205 = 180
tv211 = 184
tv215 = 188
tv256 = 192
tv260 = 196
tv272 = 200
tv278 = 204
tv282 = 208
tv336 = 212
tv342 = 216
tv346 = 220
tv390 = 224
tv396 = 228
tv400 = 232
tv425 = 236
tv431 = 240
tv435 = 244
tv447 = 248
tv453 = 252
tv457 = 256
tv493 = 260
tv497 = 264
tv158 = 268
tv162 = 272
tv189 = 276
tv193 = 280
pPTPATH$ = 288
tv147 = 296
tv151 = 304
tv153 = 312
tv183 = 320
pIP4FRM$ = 328
pIP6FRM$ = 336
tv252 = 344
tv338 = 352
tv427 = 360
tv486 = 368
pMPC_TH$ = 376
pData$ = 384
cPktVer$ = 392
__$ArrayPad$ = 400
arg$ = 448
ptp_read_thread PROC

; 2037 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2038 :     PTPBLK*    pPTPBLK = (PTPBLK*) arg;

  00020	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00028	48 89 44 24 78	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 2039 :     PTPATH*    pPTPATH = pPTPBLK->pPTPATHRead; // PTPATH Read

  0002d	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 2040 :     DEVBLK*    pDEVBLK = pPTPATH->pDEVBLK;     // DEVBLK

  0003d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00045	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00049	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 2041 :     BYTE*      pTunBuf;                        // TUN read buffer address
; 2042 :     PIP4FRM    pIP4FRM;                        // IPv4 packet in TUN read buffer
; 2043 :     PIP6FRM    pIP6FRM;                        // IPv6 packet in TUN read buffer
; 2044 :     int        iTunLen;                        // TUN read length
; 2045 :     int        iLength;                        // Length of data in TUN read buffer
; 2046 :     PTPHDR*    pPTPHDR;                        // PTPHDR of the path read buffer
; 2047 :     MPC_TH*    pMPC_TH;                        // MPC_TH follows the PTPHDR
; 2048 : //  MPC_RRH*   pMPC_RRH;                       // MPC_RRH follows the MPC_TH
; 2049 : //  MPC_PH*    pMPC_PH;                        // MPC_PH follows the MPC_RRH
; 2050 :     BYTE*      pData;                          //
; 2051 :     U16        uPayLen;
; 2052 :     int        iPktVer;
; 2053 :     char       cPktVer[8];
; 2054 :     int        iPktLen;
; 2055 :     int        iTraceLen;
; 2056 : 
; 2057 : 
; 2058 :     // Allocate the TUN read buffer.
; 2059 :     iTunLen = pPTPBLK->iMTU;                      // Read length and buffer size

  00051	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00056	8b 80 d4 02 00
	00		 mov	 eax, DWORD PTR [rax+724]
  0005c	89 84 24 b0 00
	00 00		 mov	 DWORD PTR iTunLen$[rsp], eax

; 2060 :     pTunBuf = alloc_storage( pDEVBLK, iTunLen );  // equal to the MTU size

  00063	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR iTunLen$[rsp]
  0006a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00072	e8 00 00 00 00	 call	 alloc_storage
  00077	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pTunBuf$[rsp], rax

; 2061 :     if (!pTunBuf)                    // if the allocate failed...

  0007f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pTunBuf$[rsp], 0
  00088	0f 85 91 00 00
	00		 jne	 $LN23@ptp_read_t
$LN4@ptp_read_t:

; 2062 :     {
; 2063 :         // Close the TUN interface.
; 2064 :         VERIFY( pPTPBLK->fd == -1 || TUNTAP_Close( pPTPBLK->fd ) == 0 );

  0008e	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00093	83 78 20 ff	 cmp	 DWORD PTR [rax+32], -1
  00097	74 6d		 je	 SHORT $LN24@ptp_read_t
  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0009e	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  000a1	e8 00 00 00 00	 call	 tt32_close
  000a6	85 c0		 test	 eax, eax
  000a8	74 5c		 je	 SHORT $LN24@ptp_read_t
$LN7@ptp_read_t:
  000aa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170881
  000b1	41 b8 10 08 00
	00		 mov	 r8d, 2064		; 00000810H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170882
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170883
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000d1	85 c0		 test	 eax, eax
  000d3	74 20		 je	 SHORT $LN25@ptp_read_t
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170885
  000dc	41 b8 10 08 00
	00		 mov	 r8d, 2064		; 00000810H
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170886
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170887
  000f0	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@ptp_read_t:
  000f5	33 c0		 xor	 eax, eax
  000f7	85 c0		 test	 eax, eax
  000f9	75 af		 jne	 SHORT $LN7@ptp_read_t
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00101	85 c0		 test	 eax, eax
  00103	74 01		 je	 SHORT $LN26@ptp_read_t
  00105	cc		 int	 3
$LN26@ptp_read_t:
$LN24@ptp_read_t:
  00106	33 c0		 xor	 eax, eax
  00108	85 c0		 test	 eax, eax
  0010a	75 82		 jne	 SHORT $LN4@ptp_read_t

; 2065 :         pPTPBLK->fd = -1;

  0010c	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00111	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 2066 :         // Nothing else to be done.
; 2067 :         return NULL;

  00118	33 c0		 xor	 eax, eax
  0011a	e9 85 0e 00 00	 jmp	 $LN1@ptp_read_t
$LN23@ptp_read_t:

; 2068 :     }
; 2069 :     pIP6FRM = (PIP6FRM)pTunBuf;

  0011f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pTunBuf$[rsp]
  00127	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR pIP6FRM$[rsp], rax

; 2070 :     pIP4FRM = (PIP4FRM)pTunBuf;

  0012f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pTunBuf$[rsp]
  00137	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR pIP4FRM$[rsp], rax
$LN10@ptp_read_t:

; 2071 : 
; 2072 :     // ZZ FIXME: Try to avoid race condition at startup with hercifc
; 2073 :     SLEEP(10);

  0013f	c7 84 24 9c 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR rc$1[rsp], 10
$LN11@ptp_read_t:
  0014a	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00152	74 26		 je	 SHORT $LN12@ptp_read_t
  00154	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR rc$1[rsp]
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00161	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$1[rsp], eax
  00168	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00170	74 06		 je	 SHORT $LN27@ptp_read_t
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN27@ptp_read_t:
  00178	eb d0		 jmp	 SHORT $LN11@ptp_read_t
$LN12@ptp_read_t:
  0017a	33 c0		 xor	 eax, eax
  0017c	85 c0		 test	 eax, eax
  0017e	75 bf		 jne	 SHORT $LN10@ptp_read_t

; 2074 : 
; 2075 :     pPTPBLK->pid = getpid();

  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00186	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0018b	89 41 28	 mov	 DWORD PTR [rcx+40], eax
$LN62@ptp_read_t:
$LN61@ptp_read_t:
$LN60@ptp_read_t:
$LN13@ptp_read_t:

; 2076 : 
; 2077 :     // Keep going until we have to stop.
; 2078 :     while( pPTPBLK->fd != -1 && !pPTPBLK->fCloseInProgress )

  0018e	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00193	83 78 20 ff	 cmp	 DWORD PTR [rax+32], -1
  00197	0f 84 56 0d 00
	00		 je	 $LN14@ptp_read_t
  0019d	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001a2	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001a5	c1 e8 02	 shr	 eax, 2
  001a8	83 e0 01	 and	 eax, 1
  001ab	85 c0		 test	 eax, eax
  001ad	0f 85 40 0d 00
	00		 jne	 $LN14@ptp_read_t

; 2079 :     {
; 2080 : 
; 2081 :         // Read an IP packet from the TUN interface.
; 2082 :         iLength = TUNTAP_Read( pPTPBLK->fd, (void*)pTunBuf, iTunLen );

  001b3	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR iTunLen$[rsp]
  001bb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pTunBuf$[rsp]
  001c3	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001c8	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  001cb	e8 00 00 00 00	 call	 tt32_read
  001d0	89 44 24 70	 mov	 DWORD PTR iLength$[rsp], eax

; 2083 : 
; 2084 :         // Check for error conditions...
; 2085 :         if (iLength < 0)

  001d4	83 7c 24 70 00	 cmp	 DWORD PTR iLength$[rsp], 0
  001d9	0f 8d 14 01 00
	00		 jge	 $LN28@ptp_read_t

; 2086 :         {
; 2087 :             if (!pPTPBLK->fCloseInProgress)

  001df	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001e4	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001e7	c1 e8 02	 shr	 eax, 2
  001ea	83 e0 01	 and	 eax, 1
  001ed	85 c0		 test	 eax, eax
  001ef	0f 85 f9 00 00
	00		 jne	 $LN29@ptp_read_t

; 2088 :             {
; 2089 :                 // HHC00912 "%1d:%04X %s: error reading from device %s: %d %s"
; 2090 :                 WRMSG(HHC00912, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001fb	8b 08		 mov	 ecx, DWORD PTR [rax]
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00203	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv147[rsp], rax
  0020b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00211	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv151[rsp], rax
  00219	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0021e	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00225	48 89 8c 24 38
	01 00 00	 mov	 QWORD PTR tv153[rsp], rcx
  0022d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00235	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00239	89 94 24 0c 01
	00 00		 mov	 DWORD PTR tv158[rsp], edx
  00240	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  00248	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0024d	41 d1 f8	 sar	 r8d, 1
  00250	44 89 84 24 10
	01 00 00	 mov	 DWORD PTR tv162[rsp], r8d
  00258	b9 01 00 00 00	 mov	 ecx, 1
  0025d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00263	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv147[rsp]
  0026b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00270	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv151[rsp]
  00278	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0027a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0027e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv153[rsp]
  00286	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0028b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00293	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00297	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0029c	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv158[rsp]
  002a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a7	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv162[rsp]
  002ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170892
  002b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170893
  002c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170894
  002dc	ba 2b 08 00 00	 mov	 edx, 2091		; 0000082bH
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170895
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN29@ptp_read_t:

; 2091 :                                      pPTPBLK->szTUNIfName, errno, strerror( errno ) );
; 2092 :             }
; 2093 :             break;

  002ee	e9 00 0c 00 00	 jmp	 $LN14@ptp_read_t
$LN28@ptp_read_t:

; 2094 :         }
; 2095 : 
; 2096 :         if (iLength == 0)       // (probably EINTR; ignore)

  002f3	83 7c 24 70 00	 cmp	 DWORD PTR iLength$[rsp], 0
  002f8	75 05		 jne	 SHORT $LN30@ptp_read_t

; 2097 :             continue;

  002fa	e9 8f fe ff ff	 jmp	 $LN13@ptp_read_t
$LN30@ptp_read_t:

; 2098 : 
; 2099 :         // Check the IP packet version. The first 4-bits of the first
; 2100 :         // byte of the IP header contains the version number.
; 2101 :         iPktVer = ( ( pTunBuf[0] & 0xF0 ) >> 4 );

  002ff	b8 01 00 00 00	 mov	 eax, 1
  00304	48 6b c0 00	 imul	 rax, rax, 0
  00308	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pTunBuf$[rsp]
  00310	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00314	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00319	c1 f8 04	 sar	 eax, 4
  0031c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR iPktVer$[rsp], eax

; 2102 :         if (iPktVer == 4)

  00323	83 bc 24 a0 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  0032b	75 19		 jne	 SHORT $LN31@ptp_read_t

; 2103 :         {
; 2104 :             strcpy( cPktVer, " IPv4" );

  0032d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170899
  00334	48 8d 8c 24 88
	01 00 00	 lea	 rcx, QWORD PTR cPktVer$[rsp]
  0033c	e8 00 00 00 00	 call	 strcpy

; 2105 :         }

  00341	e9 e5 01 00 00	 jmp	 $LN32@ptp_read_t
$LN31@ptp_read_t:

; 2106 :         else if (iPktVer == 6)

  00346	83 bc 24 a0 00
	00 00 06	 cmp	 DWORD PTR iPktVer$[rsp], 6
  0034e	75 19		 jne	 SHORT $LN33@ptp_read_t

; 2107 :         {
; 2108 :             strcpy( cPktVer, " IPv6" );

  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170902
  00357	48 8d 8c 24 88
	01 00 00	 lea	 rcx, QWORD PTR cPktVer$[rsp]
  0035f	e8 00 00 00 00	 call	 strcpy

; 2109 :         }

  00364	e9 c2 01 00 00	 jmp	 $LN34@ptp_read_t
$LN33@ptp_read_t:

; 2110 :         else
; 2111 :         {
; 2112 :             // Err... not IPv4 or IPv6!
; 2113 :             // HHC03921 "%1d:%04X PTP: Packet of size %d bytes from device '%s' has an unknown IP version, packet dropped"
; 2114 :             WRMSG(HHC03921, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00369	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0036e	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  00374	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv183[rsp], rax
  0037c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00384	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00388	89 8c 24 14 01
	00 00		 mov	 DWORD PTR tv189[rsp], ecx
  0038f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00397	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0039b	d1 fa		 sar	 edx, 1
  0039d	89 94 24 18 01
	00 00		 mov	 DWORD PTR tv193[rsp], edx
  003a4	b9 01 00 00 00	 mov	 ecx, 1
  003a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003af	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv183[rsp]
  003b7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003bc	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  003c0	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  003c4	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  003cb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003cf	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv193[rsp]
  003d6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170903
  003e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170904
  003ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  003fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170905
  00404	ba 43 08 00 00	 mov	 edx, 2115		; 00000843H
  00409	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170906
  00410	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2115 :                                  iLength, pPTPBLK->szTUNIfName );
; 2116 :             iTraceLen = iLength;

  00416	8b 44 24 70	 mov	 eax, DWORD PTR iLength$[rsp]
  0041a	89 44 24 74	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 2117 :             if (iTraceLen > 128)

  0041e	81 7c 24 74 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  00426	0f 8e c4 00 00
	00		 jle	 $LN35@ptp_read_t

; 2118 :             {
; 2119 :                 iTraceLen = 128;

  0042c	c7 44 24 74 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 2120 :                 // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 2121 :                 WRMSG(HHC00980, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00434	8b 44 24 74	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  00438	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  0043c	2b c8		 sub	 ecx, eax
  0043e	8b c1		 mov	 eax, ecx
  00440	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv205[rsp], eax
  00447	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0044f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00453	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv211[rsp], ecx
  0045a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00462	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00466	d1 fa		 sar	 edx, 1
  00468	89 94 24 bc 00
	00 00		 mov	 DWORD PTR tv215[rsp], edx
  0046f	b9 01 00 00 00	 mov	 ecx, 1
  00474	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0047a	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv205[rsp]
  00481	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00485	8b 4c 24 74	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00489	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0048d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00495	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00499	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0049e	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv211[rsp]
  004a5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004a9	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv215[rsp]
  004b0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170908
  004bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170909
  004c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  004d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170910
  004de	ba 4a 08 00 00	 mov	 edx, 2122		; 0000084aH
  004e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170911
  004ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN35@ptp_read_t:

; 2122 :                                      iTraceLen, iLength - iTraceLen );
; 2123 :             }
; 2124 :             net_data_trace( pDEVBLK, (BYTE*)pTunBuf, iTraceLen, TO_GUEST, 'I', "data", 0 );

  004f0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  004f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170912
  004ff	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00504	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  00509	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  0050c	44 8b 44 24 74	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  00511	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pTunBuf$[rsp]
  00519	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00521	e8 00 00 00 00	 call	 net_data_trace

; 2125 :             continue;

  00526	e9 63 fc ff ff	 jmp	 $LN60@ptp_read_t
$LN34@ptp_read_t:
$LN32@ptp_read_t:

; 2126 :         }
; 2127 : 
; 2128 :         // Check that a whole IP packet has been read. If an incomplete
; 2129 :         // packet has been read it is dropped.
; 2130 :         if (iPktVer == 4)

  0052b	83 bc 24 a0 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  00533	75 49		 jne	 SHORT $LN36@ptp_read_t

; 2131 :         {
; 2132 :             if (iLength >= (int)sizeof(IP4FRM))   // Size of a minimal IPv4 header

  00535	83 7c 24 70 14	 cmp	 DWORD PTR iLength$[rsp], 20
  0053a	7c 35		 jl	 SHORT $LN38@ptp_read_t

; 2133 :             {
; 2134 :                 // Calculate the IPv4 packet length.
; 2135 :                 FETCH_HW( uPayLen, pIP4FRM->hwTotalLength );

  0053c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR pIP4FRM$[rsp]
  00544	48 83 c0 02	 add	 rax, 2
  00548	48 8b c8	 mov	 rcx, rax
  0054b	e8 00 00 00 00	 call	 fetch_hw_noswap
  00550	0f b7 c8	 movzx	 ecx, ax
  00553	e8 00 00 00 00	 call	 _byteswap_ushort
  00558	66 89 84 24 88
	00 00 00	 mov	 WORD PTR uPayLen$[rsp], ax

; 2136 :                 iPktLen = uPayLen;

  00560	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR uPayLen$[rsp]
  00568	89 84 24 98 00
	00 00		 mov	 DWORD PTR iPktLen$[rsp], eax

; 2137 :             }

  0056f	eb 0b		 jmp	 SHORT $LN39@ptp_read_t
$LN38@ptp_read_t:

; 2138 :             else
; 2139 :             {
; 2140 :                 iPktLen = -1;

  00571	c7 84 24 98 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR iPktLen$[rsp], -1
$LN39@ptp_read_t:

; 2141 :             }
; 2142 :         }

  0057c	eb 4b		 jmp	 SHORT $LN37@ptp_read_t
$LN36@ptp_read_t:

; 2143 :         else
; 2144 :         {
; 2145 :             if (iLength >= (int)sizeof(IP6FRM))   // Size of an IPv6 header

  0057e	83 7c 24 70 28	 cmp	 DWORD PTR iLength$[rsp], 40 ; 00000028H
  00583	7c 39		 jl	 SHORT $LN40@ptp_read_t

; 2146 :             {
; 2147 :                 // Calculate the IPv6 packet length.
; 2148 :                 FETCH_HW( uPayLen, pIP6FRM->bPayloadLength );

  00585	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pIP6FRM$[rsp]
  0058d	48 83 c0 04	 add	 rax, 4
  00591	48 8b c8	 mov	 rcx, rax
  00594	e8 00 00 00 00	 call	 fetch_hw_noswap
  00599	0f b7 c8	 movzx	 ecx, ax
  0059c	e8 00 00 00 00	 call	 _byteswap_ushort
  005a1	66 89 84 24 88
	00 00 00	 mov	 WORD PTR uPayLen$[rsp], ax

; 2149 :                 iPktLen = sizeof(IP6FRM) + uPayLen;

  005a9	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR uPayLen$[rsp]
  005b1	48 83 c0 28	 add	 rax, 40			; 00000028H
  005b5	89 84 24 98 00
	00 00		 mov	 DWORD PTR iPktLen$[rsp], eax

; 2150 :             }

  005bc	eb 0b		 jmp	 SHORT $LN41@ptp_read_t
$LN40@ptp_read_t:

; 2151 :             else
; 2152 :             {
; 2153 :                 iPktLen = -1;

  005be	c7 84 24 98 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR iPktLen$[rsp], -1
$LN41@ptp_read_t:
$LN37@ptp_read_t:

; 2154 :             }
; 2155 :         }
; 2156 :         if (iPktLen != iLength)

  005c9	8b 44 24 70	 mov	 eax, DWORD PTR iLength$[rsp]
  005cd	39 84 24 98 00
	00 00		 cmp	 DWORD PTR iPktLen$[rsp], eax
  005d4	0f 84 cd 01 00
	00		 je	 $LN42@ptp_read_t

; 2157 :         {
; 2158 :             // HHC03922 "%1d:%04X PTP: Packet of size %d bytes from device '%s' is not equal to the packet length of %d bytes, packet dropped"
; 2159 :             WRMSG(HHC03922, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  005da	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005df	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  005e5	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv252[rsp], rax
  005ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005f5	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  005f9	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv256[rsp], ecx
  00600	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00608	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0060c	d1 fa		 sar	 edx, 1
  0060e	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv260[rsp], edx
  00615	b9 01 00 00 00	 mov	 ecx, 1
  0061a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00620	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR iPktLen$[rsp]
  00627	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0062b	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv252[rsp]
  00633	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00638	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  0063c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00640	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv256[rsp]
  00647	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0064b	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv260[rsp]
  00652	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00656	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170920
  0065d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00662	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170921
  00669	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0066e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00673	41 b9 03 00 00
	00		 mov	 r9d, 3
  00679	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170922
  00680	ba 71 08 00 00	 mov	 edx, 2161		; 00000871H
  00685	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170923
  0068c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2160 :                                  iLength, pPTPBLK->szTUNIfName,
; 2161 :                                  iPktLen );
; 2162 :             iTraceLen = iLength;

  00692	8b 44 24 70	 mov	 eax, DWORD PTR iLength$[rsp]
  00696	89 44 24 74	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 2163 :             if (iTraceLen > 128)

  0069a	81 7c 24 74 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  006a2	0f 8e c4 00 00
	00		 jle	 $LN43@ptp_read_t

; 2164 :             {
; 2165 :                 iTraceLen = 128;

  006a8	c7 44 24 74 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 2166 :                 // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 2167 :                 WRMSG(HHC00980, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  006b0	8b 44 24 74	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  006b4	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  006b8	2b c8		 sub	 ecx, eax
  006ba	8b c1		 mov	 eax, ecx
  006bc	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv272[rsp], eax
  006c3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006cb	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  006cf	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv278[rsp], ecx
  006d6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  006de	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  006e2	d1 fa		 sar	 edx, 1
  006e4	89 94 24 d0 00
	00 00		 mov	 DWORD PTR tv282[rsp], edx
  006eb	b9 01 00 00 00	 mov	 ecx, 1
  006f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006f6	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv272[rsp]
  006fd	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00701	8b 4c 24 74	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00705	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00709	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00711	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00715	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0071a	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv278[rsp]
  00721	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00725	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv282[rsp]
  0072c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00730	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170925
  00737	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0073c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170926
  00743	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00748	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0074d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00753	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170927
  0075a	ba 78 08 00 00	 mov	 edx, 2168		; 00000878H
  0075f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170928
  00766	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN43@ptp_read_t:

; 2168 :                                      iTraceLen, iLength - iTraceLen );
; 2169 :             }
; 2170 :             net_data_trace( pDEVBLK, (BYTE*)pTunBuf, iTraceLen, TO_GUEST, 'I', "data", 0 );

  0076c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00774	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170929
  0077b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00780	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  00785	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  00788	44 8b 44 24 74	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  0078d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pTunBuf$[rsp]
  00795	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0079d	e8 00 00 00 00	 call	 net_data_trace

; 2171 :             continue;

  007a2	e9 e7 f9 ff ff	 jmp	 $LN61@ptp_read_t
$LN42@ptp_read_t:
$LN15@ptp_read_t:

; 2172 :         }
; 2173 : 
; 2174 :         // Enqueue IP packet.
; 2175 :         while( pPTPBLK->fd != -1 && !pPTPBLK->fCloseInProgress )

  007a7	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007ac	83 78 20 ff	 cmp	 DWORD PTR [rax+32], -1
  007b0	0f 84 38 07 00
	00		 je	 $LN16@ptp_read_t
  007b6	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007bb	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  007be	c1 e8 02	 shr	 eax, 2
  007c1	83 e0 01	 and	 eax, 1
  007c4	85 c0		 test	 eax, eax
  007c6	0f 85 22 07 00
	00		 jne	 $LN16@ptp_read_t

; 2176 :         {
; 2177 : 
; 2178 :             // Obtain the read buffer lock.
; 2179 :             obtain_lock( &pPTPBLK->ReadBufferLock );

  007cc	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007d1	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  007d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170930
  007dc	48 8b c8	 mov	 rcx, rax
  007df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2180 : 
; 2181 :             // Check whether the interface is ready for data from the TUN interface.
; 2182 :             if (iPktVer == 4)

  007e5	83 bc 24 a0 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  007ed	75 32		 jne	 SHORT $LN44@ptp_read_t

; 2183 :             {
; 2184 :                 if (!pPTPBLK->fActive4)

  007ef	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007f4	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  007f7	c1 e8 03	 shr	 eax, 3
  007fa	83 e0 01	 and	 eax, 1
  007fd	85 c0		 test	 eax, eax
  007ff	75 1e		 jne	 SHORT $LN46@ptp_read_t

; 2185 :                 {
; 2186 :                     // Release the read buffer lock.
; 2187 :                     release_lock( &pPTPBLK->ReadBufferLock );

  00801	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00806	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0080a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170934
  00811	48 8b c8	 mov	 rcx, rax
  00814	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2188 :                     break;

  0081a	e9 cf 06 00 00	 jmp	 $LN16@ptp_read_t
$LN46@ptp_read_t:

; 2189 :                 }
; 2190 :             }

  0081f	eb 30		 jmp	 SHORT $LN45@ptp_read_t
$LN44@ptp_read_t:

; 2191 :             else
; 2192 :             {
; 2193 :                 if (!pPTPBLK->fActive6)

  00821	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00826	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00829	c1 e8 04	 shr	 eax, 4
  0082c	83 e0 01	 and	 eax, 1
  0082f	85 c0		 test	 eax, eax
  00831	75 1e		 jne	 SHORT $LN47@ptp_read_t

; 2194 :                 {
; 2195 :                     // Release the read buffer lock.
; 2196 :                     release_lock( &pPTPBLK->ReadBufferLock );

  00833	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00838	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0083c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170936
  00843	48 8b c8	 mov	 rcx, rax
  00846	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2197 :                     break;

  0084c	e9 9d 06 00 00	 jmp	 $LN16@ptp_read_t
$LN47@ptp_read_t:
$LN45@ptp_read_t:

; 2198 :                 }
; 2199 :             }
; 2200 : 
; 2201 :             // Check that there is a read buffer.
; 2202 :             pPTPHDR = pPTPBLK->pReadBuffer;

  00851	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00856	48 8b 40 34	 mov	 rax, QWORD PTR [rax+52]
  0085a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pPTPHDR$[rsp], rax

; 2203 :             if (!pPTPHDR)

  00862	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  0086b	75 1e		 jne	 SHORT $LN48@ptp_read_t

; 2204 :             {
; 2205 :                 // Release the read buffer lock.
; 2206 :                 release_lock( &pPTPBLK->ReadBufferLock );

  0086d	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00872	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00876	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170938
  0087d	48 8b c8	 mov	 rcx, rax
  00880	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2207 :                 break;

  00886	e9 63 06 00 00	 jmp	 $LN16@ptp_read_t
$LN48@ptp_read_t:

; 2208 :             }
; 2209 : 
; 2210 :             // Check whether the IP packet is larger than y-side's actual MTU.
; 2211 :             // If it is then it is dropped.
; 2212 :             if (iLength > pPTPBLK->yActMTU)

  0088b	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00890	0f b7 80 78 03
	00 00		 movzx	 eax, WORD PTR [rax+888]
  00897	39 44 24 70	 cmp	 DWORD PTR iLength$[rsp], eax
  0089b	0f 8e fd 01 00
	00		 jle	 $LN49@ptp_read_t

; 2213 :             {
; 2214 :                 // Release the read buffer lock.
; 2215 :                 release_lock( &pPTPBLK->ReadBufferLock );

  008a1	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  008a6	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  008aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170940
  008b1	48 8b c8	 mov	 rcx, rax
  008b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2216 :                 // HHC03923 "%1d:%04X PTP: Packet of size %d bytes from device '%s' is larger than the guests actual MTU of %d bytes, packet dropped"
; 2217 :                 WRMSG(HHC03923, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  008ba	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  008bf	0f b7 80 78 03
	00 00		 movzx	 eax, WORD PTR [rax+888]
  008c6	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv336[rsp], eax
  008cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  008d2	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  008d9	48 89 8c 24 60
	01 00 00	 mov	 QWORD PTR tv338[rsp], rcx
  008e1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  008e9	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  008ed	89 94 24 d8 00
	00 00		 mov	 DWORD PTR tv342[rsp], edx
  008f4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  008fc	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00901	41 d1 f8	 sar	 r8d, 1
  00904	44 89 84 24 dc
	00 00 00	 mov	 DWORD PTR tv346[rsp], r8d
  0090c	b9 01 00 00 00	 mov	 ecx, 1
  00911	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00917	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv336[rsp]
  0091e	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00922	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv338[rsp]
  0092a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0092f	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  00933	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00937	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv342[rsp]
  0093e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00942	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv346[rsp]
  00949	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0094d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170941
  00954	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00959	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170942
  00960	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00965	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0096a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00970	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170943
  00977	ba ab 08 00 00	 mov	 edx, 2219		; 000008abH
  0097c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170944
  00983	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2218 :                                      iLength, pPTPBLK->szTUNIfName,
; 2219 :                                      (int)pPTPBLK->yActMTU );
; 2220 :                 iTraceLen = iLength;

  00989	8b 44 24 70	 mov	 eax, DWORD PTR iLength$[rsp]
  0098d	89 44 24 74	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 2221 :                 if (iTraceLen > 128)

  00991	81 7c 24 74 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  00999	0f 8e c4 00 00
	00		 jle	 $LN50@ptp_read_t

; 2222 :                 {
; 2223 :                     iTraceLen = 128;

  0099f	c7 44 24 74 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 2224 :                     // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 2225 :                     WRMSG(HHC00980, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  009a7	8b 44 24 74	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  009ab	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  009af	2b c8		 sub	 ecx, eax
  009b1	8b c1		 mov	 eax, ecx
  009b3	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv390[rsp], eax
  009ba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009c2	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  009c6	89 8c 24 e4 00
	00 00		 mov	 DWORD PTR tv396[rsp], ecx
  009cd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  009d5	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  009d9	d1 fa		 sar	 edx, 1
  009db	89 94 24 e8 00
	00 00		 mov	 DWORD PTR tv400[rsp], edx
  009e2	b9 01 00 00 00	 mov	 ecx, 1
  009e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009ed	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv390[rsp]
  009f4	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  009f8	8b 4c 24 74	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  009fc	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00a00	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a08	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00a0c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a11	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv396[rsp]
  00a18	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a1c	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv400[rsp]
  00a23	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a27	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170946
  00a2e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170947
  00a3a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a3f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a44	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a4a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170948
  00a51	ba b2 08 00 00	 mov	 edx, 2226		; 000008b2H
  00a56	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170949
  00a5d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN50@ptp_read_t:

; 2226 :                                          iTraceLen, iLength - iTraceLen );
; 2227 :                 }
; 2228 :                 net_data_trace( pDEVBLK, (BYTE*)pTunBuf, iTraceLen, TO_GUEST, 'I', "data", 0 );

  00a63	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00a6b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170950
  00a72	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a77	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  00a7c	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  00a7f	44 8b 44 24 74	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  00a84	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pTunBuf$[rsp]
  00a8c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a94	e8 00 00 00 00	 call	 net_data_trace

; 2229 :                 break;

  00a99	e9 50 04 00 00	 jmp	 $LN16@ptp_read_t
$LN49@ptp_read_t:

; 2230 :             }
; 2231 : 
; 2232 :             // Check whether the IP packet will ever fit into the read buffer.
; 2233 :             // If it will not then it is dropped.
; 2234 :             if (iLength > (pPTPHDR->iAreaLen - LEN_OF_PAGE_ONE))

  00a9e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00aa6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00aa9	2d fc 0f 00 00	 sub	 eax, 4092		; 00000ffcH
  00aae	39 44 24 70	 cmp	 DWORD PTR iLength$[rsp], eax
  00ab2	0f 8e 01 02 00
	00		 jle	 $LN51@ptp_read_t

; 2235 :             {
; 2236 :                 // Release the read buffer lock.
; 2237 :                 release_lock( &pPTPBLK->ReadBufferLock );

  00ab8	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00abd	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00ac1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170952
  00ac8	48 8b c8	 mov	 rcx, rax
  00acb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2238 :                 // HHC03924 "%1d:%04X PTP: Packet of size %d bytes from device '%s' is too large for read buffer area of %d bytes, packet dropped"
; 2239 :                 WRMSG(HHC03924, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00ad1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00ad9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00adc	2d fc 0f 00 00	 sub	 eax, 4092		; 00000ffcH
  00ae1	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv425[rsp], eax
  00ae8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00aed	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00af4	48 89 8c 24 68
	01 00 00	 mov	 QWORD PTR tv427[rsp], rcx
  00afc	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00b04	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00b08	89 94 24 f0 00
	00 00		 mov	 DWORD PTR tv431[rsp], edx
  00b0f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  00b17	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00b1c	41 d1 f8	 sar	 r8d, 1
  00b1f	44 89 84 24 f4
	00 00 00	 mov	 DWORD PTR tv435[rsp], r8d
  00b27	b9 01 00 00 00	 mov	 ecx, 1
  00b2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b32	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv425[rsp]
  00b39	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00b3d	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv427[rsp]
  00b45	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b4a	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  00b4e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00b52	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv431[rsp]
  00b59	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b5d	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv435[rsp]
  00b64	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170953
  00b6f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170954
  00b7b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b80	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b85	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b8b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170955
  00b92	ba c1 08 00 00	 mov	 edx, 2241		; 000008c1H
  00b97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170956
  00b9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2240 :                                      iLength, pPTPBLK->szTUNIfName,
; 2241 :                                      pPTPHDR->iAreaLen - LEN_OF_PAGE_ONE );
; 2242 :                 iTraceLen = iLength;

  00ba4	8b 44 24 70	 mov	 eax, DWORD PTR iLength$[rsp]
  00ba8	89 44 24 74	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 2243 :                 if (iTraceLen > 128)

  00bac	81 7c 24 74 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  00bb4	0f 8e c4 00 00
	00		 jle	 $LN52@ptp_read_t

; 2244 :                 {
; 2245 :                     iTraceLen = 128;

  00bba	c7 44 24 74 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 2246 :                     // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 2247 :                     WRMSG(HHC00980, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00bc2	8b 44 24 74	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  00bc6	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  00bca	2b c8		 sub	 ecx, eax
  00bcc	8b c1		 mov	 eax, ecx
  00bce	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv447[rsp], eax
  00bd5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00bdd	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00be1	89 8c 24 fc 00
	00 00		 mov	 DWORD PTR tv453[rsp], ecx
  00be8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00bf0	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00bf4	d1 fa		 sar	 edx, 1
  00bf6	89 94 24 00 01
	00 00		 mov	 DWORD PTR tv457[rsp], edx
  00bfd	b9 01 00 00 00	 mov	 ecx, 1
  00c02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c08	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv447[rsp]
  00c0f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00c13	8b 4c 24 74	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00c17	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00c1b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c23	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00c27	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c2c	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv453[rsp]
  00c33	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c37	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv457[rsp]
  00c3e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170958
  00c49	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170959
  00c55	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c5a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c5f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c65	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170960
  00c6c	ba c8 08 00 00	 mov	 edx, 2248		; 000008c8H
  00c71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170961
  00c78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN52@ptp_read_t:

; 2248 :                                          iTraceLen, iLength - iTraceLen );
; 2249 :                 }
; 2250 :                 net_data_trace( pDEVBLK, (BYTE*)pTunBuf, iTraceLen, TO_GUEST, 'I', "data", 0 );

  00c7e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00c86	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170962
  00c8d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00c92	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  00c97	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  00c9a	44 8b 44 24 74	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  00c9f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pTunBuf$[rsp]
  00ca7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00caf	e8 00 00 00 00	 call	 net_data_trace

; 2251 :                 break;

  00cb4	e9 35 02 00 00	 jmp	 $LN16@ptp_read_t
$LN51@ptp_read_t:

; 2252 :             }
; 2253 : 
; 2254 :             // Check whether the IP packet will fit into the read buffer.
; 2255 :             if (iLength > (pPTPHDR->iAreaLen - pPTPHDR->iDataLen))

  00cb9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00cc1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00cc9	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00ccc	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00ccf	2b c1		 sub	 eax, ecx
  00cd1	39 44 24 70	 cmp	 DWORD PTR iLength$[rsp], eax
  00cd5	7e 2e		 jle	 SHORT $LN53@ptp_read_t

; 2256 :             {
; 2257 :                 // The IP packet will not fit into the read buffer at the
; 2258 :                 // moment, presumably there are IP packets waiting to be read.
; 2259 : 
; 2260 :                 // Release the read buffer lock.
; 2261 :                 release_lock( &pPTPBLK->ReadBufferLock );

  00cd7	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00cdc	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00ce0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170965
  00ce7	48 8b c8	 mov	 rcx, rax
  00cea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2262 : 
; 2263 :                 // Don't use schedyield() here; use an actual non-dispatchable
; 2264 :                 // delay instead so as to allow another [possibly lower priority]
; 2265 :                 // thread to 'read' (remove) the packet(s) from the read buffer.
; 2266 :                 usleep( PTP_DELAY_USECS );  // (wait a bit before retrying...)

  00cf0	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00cf5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 2267 : 
; 2268 :                 continue;

  00cfb	e9 a7 fa ff ff	 jmp	 $LN15@ptp_read_t

; 2269 : 
; 2270 :             }

  00d00	e9 e4 01 00 00	 jmp	 $LN54@ptp_read_t
$LN53@ptp_read_t:

; 2271 :             else
; 2272 :             {
; 2273 :                 // The IP packet will fit into the read buffer.
; 2274 : 
; 2275 :                 // Display the IP packet just read, if the device group is being debugged.
; 2276 :                 if (pPTPBLK->uDebugMask & DBGPTPPACKET)

  00d05	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00d0a	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00d0d	83 e0 01	 and	 eax, 1
  00d10	85 c0		 test	 eax, eax
  00d12	0f 84 01 01 00
	00		 je	 $LN55@ptp_read_t

; 2277 :                 {
; 2278 :                     // HHC00913 "%1d:%04X %s: Receive%s packet of size %d bytes from device %s"
; 2279 :                     WRMSG(HHC00913, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00d18	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00d1d	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  00d23	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv486[rsp], rax
  00d2b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d33	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00d37	89 8c 24 04 01
	00 00		 mov	 DWORD PTR tv493[rsp], ecx
  00d3e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00d46	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00d4a	d1 fa		 sar	 edx, 1
  00d4c	89 94 24 08 01
	00 00		 mov	 DWORD PTR tv497[rsp], edx
  00d53	b9 01 00 00 00	 mov	 ecx, 1
  00d58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d5e	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv486[rsp]
  00d66	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00d6b	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  00d6f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00d73	48 8d 8c 24 88
	01 00 00	 lea	 rcx, QWORD PTR cPktVer$[rsp]
  00d7b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00d80	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d88	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00d8c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00d91	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv493[rsp]
  00d98	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d9c	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv497[rsp]
  00da3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00da7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170967
  00dae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00db3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170968
  00dba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dbf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dc4	41 b9 03 00 00
	00		 mov	 r9d, 3
  00dca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170969
  00dd1	ba e8 08 00 00	 mov	 edx, 2280		; 000008e8H
  00dd6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170970
  00ddd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2280 :                                          cPktVer, iLength, pPTPBLK->szTUNIfName );
; 2281 :                     net_data_trace( pDEVBLK, (BYTE*)pTunBuf, iLength, TO_GUEST, 'D', "packet", 0 );

  00de3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00deb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170971
  00df2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00df7	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00dfc	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  00dff	44 8b 44 24 70	 mov	 r8d, DWORD PTR iLength$[rsp]
  00e04	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pTunBuf$[rsp]
  00e0c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e14	e8 00 00 00 00	 call	 net_data_trace
$LN55@ptp_read_t:

; 2282 :                 }
; 2283 : 
; 2284 :                 // Fix-up various pointers
; 2285 :                 pMPC_TH = (MPC_TH*)((BYTE*)pPTPHDR + SIZE_HDR);

  00e19	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00e21	48 83 c0 10	 add	 rax, 16
  00e25	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR pMPC_TH$[rsp], rax

; 2286 :                 pData   = (BYTE*)pMPC_TH + pPTPHDR->iDataLen;

  00e2d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00e35	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00e39	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00e41	48 03 c8	 add	 rcx, rax
  00e44	48 8b c1	 mov	 rax, rcx
  00e47	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR pData$[rsp], rax

; 2287 : 
; 2288 :                 // Copy the IP packet from the TUN/TAP read buffer
; 2289 :                 memcpy( pData, pTunBuf, iLength );

  00e4f	48 63 44 24 70	 movsxd	 rax, DWORD PTR iLength$[rsp]
  00e54	48 8b bc 24 80
	01 00 00	 mov	 rdi, QWORD PTR pData$[rsp]
  00e5c	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR pTunBuf$[rsp]
  00e64	48 8b c8	 mov	 rcx, rax
  00e67	f3 a4		 rep movsb

; 2290 : 
; 2291 :                 // Increment length field in PTPHDR
; 2292 :                 pPTPHDR->iDataLen += iLength;

  00e69	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00e71	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00e74	03 44 24 70	 add	 eax, DWORD PTR iLength$[rsp]
  00e78	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  00e80	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 2293 : 
; 2294 :                 // Release the read buffer lock.
; 2295 :                 release_lock( &pPTPBLK->ReadBufferLock );

  00e83	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00e88	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00e8c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170972
  00e93	48 8b c8	 mov	 rcx, rax
  00e96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2296 : 
; 2297 :                 //
; 2298 :                 obtain_lock( &pPTPBLK->ReadEventLock );

  00e9c	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ea1	48 83 c0 40	 add	 rax, 64			; 00000040H
  00ea5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170973
  00eac	48 8b c8	 mov	 rcx, rax
  00eaf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2299 :                 signal_condition( &pPTPBLK->ReadEvent );

  00eb5	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00eba	48 83 c0 48	 add	 rax, 72			; 00000048H
  00ebe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170974
  00ec5	48 8b c8	 mov	 rcx, rax
  00ec8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2300 :                 release_lock( &pPTPBLK->ReadEventLock );

  00ece	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ed3	48 83 c0 40	 add	 rax, 64			; 00000040H
  00ed7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170975
  00ede	48 8b c8	 mov	 rcx, rax
  00ee1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2301 : 
; 2302 :                 break;

  00ee7	eb 05		 jmp	 SHORT $LN16@ptp_read_t
$LN54@ptp_read_t:

; 2303 : 
; 2304 :             }   /* if (iLength > (pPTPHDR->iAreaLen - pPTPHDR->iDataLen)) */
; 2305 : 
; 2306 :         }   /* while( pPTPBLK->fd != -1 && !pPTPBLK->fCloseInProgress ) */

  00ee9	e9 b9 f8 ff ff	 jmp	 $LN15@ptp_read_t
$LN16@ptp_read_t:

; 2307 : 
; 2308 :     }   /* while( pPTPBLK->fd != -1 && !pPTPBLK->fCloseInProgress ) */

  00eee	e9 9b f2 ff ff	 jmp	 $LN62@ptp_read_t
$LN14@ptp_read_t:
$LN19@ptp_read_t:

; 2309 : 
; 2310 :     // We must do the close since we were the one doing the i/o...
; 2311 :     VERIFY( pPTPBLK->fd == -1 || TUNTAP_Close( pPTPBLK->fd ) == 0 );

  00ef3	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ef8	83 78 20 ff	 cmp	 DWORD PTR [rax+32], -1
  00efc	74 6d		 je	 SHORT $LN56@ptp_read_t
  00efe	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00f03	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00f06	e8 00 00 00 00	 call	 tt32_close
  00f0b	85 c0		 test	 eax, eax
  00f0d	74 5c		 je	 SHORT $LN56@ptp_read_t
$LN22@ptp_read_t:
  00f0f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170977
  00f16	41 b8 07 09 00
	00		 mov	 r8d, 2311		; 00000907H
  00f1c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170978
  00f23	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170979
  00f2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00f30	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00f36	85 c0		 test	 eax, eax
  00f38	74 20		 je	 SHORT $LN57@ptp_read_t
  00f3a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170981
  00f41	41 b8 07 09 00
	00		 mov	 r8d, 2311		; 00000907H
  00f47	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170982
  00f4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170983
  00f55	e8 00 00 00 00	 call	 DebuggerTrace
$LN57@ptp_read_t:
  00f5a	33 c0		 xor	 eax, eax
  00f5c	85 c0		 test	 eax, eax
  00f5e	75 af		 jne	 SHORT $LN22@ptp_read_t
  00f60	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00f66	85 c0		 test	 eax, eax
  00f68	74 01		 je	 SHORT $LN58@ptp_read_t
  00f6a	cc		 int	 3
$LN58@ptp_read_t:
$LN56@ptp_read_t:
  00f6b	33 c0		 xor	 eax, eax
  00f6d	85 c0		 test	 eax, eax
  00f6f	75 82		 jne	 SHORT $LN19@ptp_read_t

; 2312 :     pPTPBLK->fd = -1;

  00f71	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00f76	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 2313 : 
; 2314 :     // Release the TUN read buffer.
; 2315 :     free( pTunBuf );

  00f7d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pTunBuf$[rsp]
  00f85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2316 :     pTunBuf = NULL;

  00f8b	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pTunBuf$[rsp], 0

; 2317 :     iTunLen = 0;

  00f97	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR iTunLen$[rsp], 0

; 2318 : 
; 2319 :     return NULL;

  00fa2	33 c0		 xor	 eax, eax
$LN1@ptp_read_t:

; 2320 : }   /* End function  ptp_read_thread() */

  00fa4	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00fac	48 33 cc	 xor	 rcx, rsp
  00faf	e8 00 00 00 00	 call	 __security_check_cookie
  00fb4	48 81 c4 a8 01
	00 00		 add	 rsp, 424		; 000001a8H
  00fbb	5f		 pop	 rdi
  00fbc	5e		 pop	 rsi
  00fbd	c3		 ret	 0
ptp_read_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPATH$ = 96
iDataLen$ = 104
iTraceLen$ = 108
tv79 = 112
uFirst4$ = 116
pMPC_TH$ = 120
tv130 = 128
tv134 = 132
tv156 = 136
tv160 = 140
tv172 = 144
tv178 = 148
tv182 = 152
rc$ = 156
pPTPBLK$ = 160
pDEVBLK$ = 208
uCount$ = 216
iCCWSeq$ = 224
pIOBuf$ = 232
pMore$ = 240
pUnitStat$ = 248
pResidual$ = 256
pPTPHDR$ = 264
read_chain_buffer PROC

; 1867 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1868 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;   // PTPATH

  0001c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00024	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0002b	48 89 44 24 60	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 1869 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;    // PTPBLK

  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 1870 :     MPC_TH*    pMPC_TH;                        // MPC_TH follows the PTPHDR
; 1871 :     int        iDataLen;
; 1872 :     int        iTraceLen;
; 1873 :     int        rc;
; 1874 :     U32        uFirst4;
; 1875 : 
; 1876 : 
; 1877 :     // Point to the data and get its length.
; 1878 :     pMPC_TH = (MPC_TH*)((BYTE*)pPTPHDR + SIZE_HDR);

  00040	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00048	48 83 c0 10	 add	 rax, 16
  0004c	48 89 44 24 78	 mov	 QWORD PTR pMPC_TH$[rsp], rax

; 1879 :     iDataLen = pPTPHDR->iDataLen;

  00051	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00059	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0005c	89 44 24 68	 mov	 DWORD PTR iDataLen$[rsp], eax

; 1880 : 
; 1881 :     // Get the first 4-bytes of the data.
; 1882 :     FETCH_FW( uFirst4, pMPC_TH->first4 );

  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 fetch_fw_noswap
  0006d	8b c8		 mov	 ecx, eax
  0006f	e8 00 00 00 00	 call	 _byteswap_ulong
  00074	89 44 24 74	 mov	 DWORD PTR uFirst4$[rsp], eax

; 1883 : 
; 1884 :     // Set the residual length and unit status.
; 1885 :     if (uCount >= (U32)iDataLen)

  00078	8b 44 24 68	 mov	 eax, DWORD PTR iDataLen$[rsp]
  0007c	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR uCount$[rsp], eax
  00083	72 26		 jb	 SHORT $LN2@read_chain

; 1886 :     {
; 1887 :         *pMore     = 0;

  00085	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  0008d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1888 :         *pResidual = uCount - (U32)iDataLen;

  00090	8b 44 24 68	 mov	 eax, DWORD PTR iDataLen$[rsp]
  00094	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  0009b	2b c8		 sub	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  000a7	89 01		 mov	 DWORD PTR [rcx], eax

; 1889 :     }

  000a9	eb 24		 jmp	 SHORT $LN3@read_chain
$LN2@read_chain:

; 1890 :     else
; 1891 :     {
; 1892 :         iDataLen   = uCount;

  000ab	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR uCount$[rsp]
  000b2	89 44 24 68	 mov	 DWORD PTR iDataLen$[rsp], eax

; 1893 :         *pMore     = 1;

  000b6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  000be	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1894 :         *pResidual = 0;

  000c1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  000c9	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@read_chain:

; 1895 :     }
; 1896 :     *pUnitStat = CSW_CE | CSW_DE;

  000cf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  000d7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1897 : 
; 1898 :     // Set the transmission header sequence number, if necessary.
; 1899 :     if (uFirst4 == MPC_TH_FIRST4)

  000da	81 7c 24 74 00
	00 e0 00	 cmp	 DWORD PTR uFirst4$[rsp], 14680064 ; 00e00000H
  000e2	75 33		 jne	 SHORT $LN4@read_chain

; 1900 :     {
; 1901 :         STORE_FW( pMPC_TH->seqnum, ++pPTPATH->uSeqNum );

  000e4	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000e9	8b 40 42	 mov	 eax, DWORD PTR [rax+66]
  000ec	ff c0		 inc	 eax
  000ee	89 44 24 70	 mov	 DWORD PTR tv79[rsp], eax
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000f7	8b 4c 24 70	 mov	 ecx, DWORD PTR tv79[rsp]
  000fb	89 48 42	 mov	 DWORD PTR [rax+66], ecx
  000fe	8b 4c 24 70	 mov	 ecx, DWORD PTR tv79[rsp]
  00102	e8 00 00 00 00	 call	 _byteswap_ulong
  00107	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  0010c	48 83 c1 04	 add	 rcx, 4
  00110	8b d0		 mov	 edx, eax
  00112	e8 00 00 00 00	 call	 store_fw_noswap
$LN4@read_chain:

; 1902 :     }
; 1903 : 
; 1904 :     // Copy the data to be read.
; 1905 :     memcpy( pIOBuf, pMPC_TH, iDataLen );

  00117	48 63 44 24 68	 movsxd	 rax, DWORD PTR iDataLen$[rsp]
  0011c	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  00124	48 8b 74 24 78	 mov	 rsi, QWORD PTR pMPC_TH$[rsp]
  00129	48 8b c8	 mov	 rcx, rax
  0012c	f3 a4		 rep movsb

; 1906 : 
; 1907 :     // Display TH etc. structured, if debug is active
; 1908 :     if (uFirst4 == MPC_TH_FIRST4 && (pPTPBLK->uDebugMask & DBGPTPEXPAND))

  0012e	81 7c 24 74 00
	00 e0 00	 cmp	 DWORD PTR uFirst4$[rsp], 14680064 ; 00e00000H
  00136	0f 85 d0 00 00
	00		 jne	 $LN5@read_chain
  0013c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00144	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00147	83 e0 04	 and	 eax, 4
  0014a	85 c0		 test	 eax, eax
  0014c	0f 84 ba 00 00
	00		 je	 $LN5@read_chain

; 1909 :     {
; 1910 :         // HHC00982 "%1d:%04X %s: Present data of size %d bytes to guest"
; 1911 :         WRMSG(HHC00982, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, iDataLen );

  00152	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0015a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0015e	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv130[rsp], eax
  00165	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0016d	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00171	d1 f9		 sar	 ecx, 1
  00173	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv134[rsp], ecx
  0017a	b9 01 00 00 00	 mov	 ecx, 1
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00185	8b 4c 24 68	 mov	 ecx, DWORD PTR iDataLen$[rsp]
  00189	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0018d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00195	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00199	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0019e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv130[rsp]
  001a5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001a9	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv134[rsp]
  001b0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170794
  001bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170795
  001c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170796
  001de	ba 77 07 00 00	 mov	 edx, 1911		; 00000777H
  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170797
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1912 :         mpc_display_ptp_th_etc( pDEVBLK, pMPC_TH, TO_GUEST, 64 );

  001f0	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  001f6	41 b0 3e	 mov	 r8b, 62			; 0000003eH
  001f9	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  001fe	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_ptp_th_etc
$LN5@read_chain:

; 1913 :     }
; 1914 : 
; 1915 :     // Display up to 256-bytes of the read data, if debug is active.
; 1916 :     if (pPTPBLK->uDebugMask & DBGPTPDATA)

  0020c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00214	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00217	83 e0 02	 and	 eax, 2
  0021a	85 c0		 test	 eax, eax
  0021c	0f 84 ae 01 00
	00		 je	 $LN6@read_chain

; 1917 :     {
; 1918 :         // HHC00982 "%1d:%04X %s: Present data of size %d bytes to guest"
; 1919 :         WRMSG(HHC00982, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, iDataLen );

  00222	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0022a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0022e	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv156[rsp], eax
  00235	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0023d	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00241	d1 f9		 sar	 ecx, 1
  00243	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv160[rsp], ecx
  0024a	b9 01 00 00 00	 mov	 ecx, 1
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00255	8b 4c 24 68	 mov	 ecx, DWORD PTR iDataLen$[rsp]
  00259	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0025d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00265	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00269	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0026e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv156[rsp]
  00275	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00279	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv160[rsp]
  00280	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170799
  0028b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170800
  00297	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170801
  002ae	ba 7f 07 00 00	 mov	 edx, 1919		; 0000077fH
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170802
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1920 :         iTraceLen = iDataLen;

  002c0	8b 44 24 68	 mov	 eax, DWORD PTR iDataLen$[rsp]
  002c4	89 44 24 6c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1921 :         if (iTraceLen > 256)

  002c8	81 7c 24 6c 00
	01 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 256 ; 00000100H
  002d0	0f 8e c4 00 00
	00		 jle	 $LN7@read_chain

; 1922 :         {
; 1923 :             iTraceLen = 256;

  002d6	c7 44 24 6c 00
	01 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 256 ; 00000100H

; 1924 :             // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1925 :             WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  002de	8b 44 24 6c	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  002e2	8b 4c 24 68	 mov	 ecx, DWORD PTR iDataLen$[rsp]
  002e6	2b c8		 sub	 ecx, eax
  002e8	8b c1		 mov	 eax, ecx
  002ea	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv172[rsp], eax
  002f1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002f9	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002fd	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv178[rsp], ecx
  00304	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0030c	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00310	d1 fa		 sar	 edx, 1
  00312	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv182[rsp], edx
  00319	b9 01 00 00 00	 mov	 ecx, 1
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00324	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv172[rsp]
  0032b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0032f	8b 4c 24 6c	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00333	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00337	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0033f	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00343	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00348	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  0034f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00353	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv182[rsp]
  0035a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0035e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170804
  00365	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170805
  00371	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00376	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00381	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170806
  00388	ba 86 07 00 00	 mov	 edx, 1926		; 00000786H
  0038d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170807
  00394	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@read_chain:

; 1926 :                                  iTraceLen, iDataLen - iTraceLen );
; 1927 :         }
; 1928 :         net_data_trace( pDEVBLK, pIOBuf, iTraceLen, TO_GUEST, 'D', "data", 0 );

  0039a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  003a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170808
  003a9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ae	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  003b3	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  003b6	44 8b 44 24 6c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  003bb	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  003c3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003cb	e8 00 00 00 00	 call	 net_data_trace
$LN6@read_chain:

; 1929 :     }
; 1930 : 
; 1931 :     // When we are handshaking the sixth CCW in the chain marks the
; 1932 :     // end of an exchange.
; 1933 :     if (pPTPATH->fHandshaking && iCCWSeq == 5)

  003d0	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  003d5	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  003d9	24 01		 and	 al, 1
  003db	0f b6 c0	 movzx	 eax, al
  003de	85 c0		 test	 eax, eax
  003e0	0f 84 d5 00 00
	00		 je	 $LN8@read_chain
  003e6	83 bc 24 e0 00
	00 00 05	 cmp	 DWORD PTR iCCWSeq$[rsp], 5
  003ee	0f 85 c7 00 00
	00		 jne	 $LN8@read_chain

; 1934 :     {
; 1935 :         if (pPTPATH->fHandshakeCur == HANDSHAKE_ONE)     // Handshake one in progress?

  003f4	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  003f9	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  003fd	83 f8 01	 cmp	 eax, 1
  00400	75 39		 jne	 SHORT $LN9@read_chain

; 1936 :         {
; 1937 :             // The end of the first exchange. The y-side VTAM will
; 1938 :             // now wait (for up to 90 seconds) for an Attention
; 1939 :             // interrupt, which indicates to the y-side that the
; 1940 :             // x-side has initiated the second exchange.
; 1941 :             // Raise an attention interrupt in one second.
; 1942 :             pPTPATH->bAttnCode = 0x17;

  00402	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00407	c6 40 40 17	 mov	 BYTE PTR [rax+64], 23

; 1943 :             rc = raise_unsol_int( pDEVBLK, CSW_ATTN, 1000 );

  0040b	41 b8 e8 03 00
	00		 mov	 r8d, 1000		; 000003e8H
  00411	b2 80		 mov	 dl, 128			; 00000080H
  00413	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0041b	e8 00 00 00 00	 call	 raise_unsol_int
  00420	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1944 :             if (rc)
; 1945 :             {
; 1946 :                 // Any bad news has already been reported.
; 1947 :                 // Hmm... the Attention interrupt to the y-side will not be
; 1948 :                 // raised. The y-side's VTAM will timeout in 90 seconds.
; 1949 :             }
; 1950 :             pPTPATH->fHandshakeFin |= HANDSHAKE_ONE;     // Handshake one finished

  00427	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0042c	0f b6 40 3f	 movzx	 eax, BYTE PTR [rax+63]
  00430	83 c8 01	 or	 eax, 1
  00433	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00438	88 41 3f	 mov	 BYTE PTR [rcx+63], al
$LN9@read_chain:

; 1951 :         }
; 1952 :         if (pPTPATH->fHandshakeCur == HANDSHAKE_TWO)     // Handshake two in progress?

  0043b	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00440	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  00444	83 f8 02	 cmp	 eax, 2
  00447	75 14		 jne	 SHORT $LN11@read_chain

; 1953 :         {
; 1954 :             pPTPATH->fHandshakeFin |= HANDSHAKE_TWO;     // Handshake two finished

  00449	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0044e	0f b6 40 3f	 movzx	 eax, BYTE PTR [rax+63]
  00452	83 c8 02	 or	 eax, 2
  00455	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  0045a	88 41 3f	 mov	 BYTE PTR [rcx+63], al
$LN11@read_chain:

; 1955 :         }
; 1956 :         if (pPTPATH->fHandshakeCur == HANDSHAKE_THREE)   // Handshake three in progress?

  0045d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00462	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  00466	83 f8 04	 cmp	 eax, 4
  00469	75 14		 jne	 SHORT $LN12@read_chain

; 1957 :         {
; 1958 :             pPTPATH->fHandshakeFin |= HANDSHAKE_THREE;   // Handshake three finished

  0046b	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00470	0f b6 40 3f	 movzx	 eax, BYTE PTR [rax+63]
  00474	83 c8 04	 or	 eax, 4
  00477	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  0047c	88 41 3f	 mov	 BYTE PTR [rcx+63], al
$LN12@read_chain:

; 1959 :         }
; 1960 :         // If all three exchanges have finished, handshaking is complete.
; 1961 :         if (pPTPATH->fHandshakeFin == HANDSHAKE_ALL)     // All handshakes finished?

  0047f	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00484	0f b6 40 3f	 movzx	 eax, BYTE PTR [rax+63]
  00488	83 f8 07	 cmp	 eax, 7
  0048b	75 2e		 jne	 SHORT $LN13@read_chain

; 1962 :         {
; 1963 :             pPTPATH->fHandshaking = FALSE;

  0048d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00492	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  00496	24 fe		 and	 al, 254			; 000000feH
  00498	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  0049d	88 41 3c	 mov	 BYTE PTR [rcx+60], al

; 1964 :             pPTPATH->fHandshakeCur = 0;

  004a0	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  004a5	c6 40 3d 00	 mov	 BYTE PTR [rax+61], 0

; 1965 :             pPTPATH->fHandshakeSta = 0;

  004a9	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  004ae	c6 40 3e 00	 mov	 BYTE PTR [rax+62], 0

; 1966 :             pPTPATH->fHandshakeFin = 0;

  004b2	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  004b7	c6 40 3f 00	 mov	 BYTE PTR [rax+63], 0
$LN13@read_chain:
$LN8@read_chain:

; 1967 :         }
; 1968 :     }
; 1969 : 
; 1970 :     return;
; 1971 : }   /* End function  read_chain_buffer() */

  004bb	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  004c2	5f		 pop	 rdi
  004c3	5e		 pop	 rsi
  004c4	c3		 ret	 0
read_chain_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
iLength2$ = 96
iLength1$ = 100
iDataLen$ = 104
iTraceLen$ = 108
pMPC_TH$ = 112
pMPC_RRH$ = 120
pMPC_PH$ = 128
iIOLen$ = 136
tv75 = 140
uTotalLen$ = 144
tv219 = 148
tv223 = 152
tv245 = 156
tv249 = 160
tv266 = 164
tv272 = 168
tv276 = 172
pPTPATH$ = 176
pPTPBLK$ = 184
pDEVBLK$ = 224
uCount$ = 232
iCCWSeq$ = 240
pIOBuf$ = 248
pMore$ = 256
pUnitStat$ = 264
pResidual$ = 272
pPTPHDR$ = 280
read_read_buffer PROC

; 1673 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1674 : 
; 1675 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;   // PTPATH

  0001c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00024	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0002b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 1676 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;    // PTPBLK

  00033	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pPTPBLK$[rsp], rax
$LN4@read_read_:

; 1677 :     MPC_TH*    pMPC_TH;                        // MPC_TH follows the PTPHDR
; 1678 :     MPC_RRH*   pMPC_RRH;                       // MPC_RRH follows the MPC_TH
; 1679 :     MPC_PH*    pMPC_PH;                        // MPC_PH follows the MPC_RRH
; 1680 :     int        iDataLen;
; 1681 :     int        iIOLen;
; 1682 :     int        iLength1;
; 1683 :     int        iLength2;
; 1684 :     U32        uTotalLen;
; 1685 :     int        iTraceLen;
; 1686 : 
; 1687 :     UNREFERENCED( iCCWSeq );

  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 fa		 jne	 SHORT $LN4@read_read_

; 1688 : 
; 1689 : 
; 1690 :     // Point to the data and get its length.
; 1691 :     pMPC_TH = (MPC_TH*)((BYTE*)pPTPHDR + SIZE_HDR);

  0004c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00054	48 83 c0 10	 add	 rax, 16
  00058	48 89 44 24 70	 mov	 QWORD PTR pMPC_TH$[rsp], rax

; 1692 :     pMPC_RRH = (MPC_RRH*)((BYTE*)pMPC_TH + SIZE_TH);

  0005d	48 8b 44 24 70	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00062	48 83 c0 14	 add	 rax, 20
  00066	48 89 44 24 78	 mov	 QWORD PTR pMPC_RRH$[rsp], rax

; 1693 :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + SIZE_RRH);

  0006b	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00070	48 83 c0 24	 add	 rax, 36			; 00000024H
  00074	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 1694 :     iDataLen = pPTPHDR->iDataLen - LEN_OF_PAGE_ONE;

  0007c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00084	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00087	2d fc 0f 00 00	 sub	 eax, 4092		; 00000ffcH
  0008c	89 44 24 68	 mov	 DWORD PTR iDataLen$[rsp], eax

; 1695 : 
; 1696 :     // Set the transmission header sequence number.
; 1697 :     STORE_FW( pMPC_TH->seqnum, ++pPTPATH->uSeqNum );

  00090	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00098	8b 40 42	 mov	 eax, DWORD PTR [rax+66]
  0009b	ff c0		 inc	 eax
  0009d	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv75[rsp], eax
  000a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  000ac	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv75[rsp]
  000b3	89 48 42	 mov	 DWORD PTR [rax+66], ecx
  000b6	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv75[rsp]
  000bd	e8 00 00 00 00	 call	 _byteswap_ulong
  000c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  000c7	48 83 c1 04	 add	 rcx, 4
  000cb	8b d0		 mov	 edx, eax
  000cd	e8 00 00 00 00	 call	 store_fw_noswap

; 1698 : 
; 1699 :     // Set the destination Token.
; 1700 :     pMPC_RRH->tokenx5 = MPC_TOKEN_X5;

  000d2	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000d7	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 1701 :     memcpy( pMPC_RRH->token, pPTPBLK->yTokenUlpConnection, MPC_TOKEN_LENGTH );

  000db	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000e0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  000e8	8b 89 70 03 00
	00		 mov	 ecx, DWORD PTR [rcx+880]
  000ee	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 1702 : 
; 1703 :     // Check whether all of the data that is currently in page two and
; 1704 :     // onwards will fit into page one.
; 1705 :     if (iDataLen <= (LEN_OF_PAGE_ONE - (int)(SIZE_TH + SIZE_RRH + SIZE_PH)))

  000f1	81 7c 24 68 bc
	0f 00 00	 cmp	 DWORD PTR iDataLen$[rsp], 4028 ; 00000fbcH
  000f9	0f 8f a4 01 00
	00		 jg	 $LN5@read_read_

; 1706 :     {
; 1707 : 
; 1708 :         // All of the data that is currently in page two and onwards
; 1709 :         // will fit into page one. Copy the headers and the data so
; 1710 :         // that the headers and the data are contiguous in the guests
; 1711 :         // read buffer, i.e. the layout is different to that set-up by
; 1712 :         // ptp_read_thread().
; 1713 : 
; 1714 :         // Set the residual length and unit status.
; 1715 :         if (uCount >= (U32)(SIZE_TH + SIZE_RRH + SIZE_PH + iDataLen))

  000ff	8b 44 24 68	 mov	 eax, DWORD PTR iDataLen$[rsp]
  00103	83 c0 40	 add	 eax, 64			; 00000040H
  00106	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR uCount$[rsp], eax
  0010d	72 3e		 jb	 SHORT $LN7@read_read_

; 1716 :         {
; 1717 :             iLength1 = (int)(SIZE_TH + SIZE_RRH + SIZE_PH);

  0010f	c7 44 24 64 40
	00 00 00	 mov	 DWORD PTR iLength1$[rsp], 64 ; 00000040H

; 1718 :             iLength2 = iDataLen;

  00117	8b 44 24 68	 mov	 eax, DWORD PTR iDataLen$[rsp]
  0011b	89 44 24 60	 mov	 DWORD PTR iLength2$[rsp], eax

; 1719 :             *pMore     = 0;

  0011f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00127	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1720 :             *pResidual = uCount - (U32)(iLength1 + iLength2);

  0012a	8b 44 24 60	 mov	 eax, DWORD PTR iLength2$[rsp]
  0012e	8b 4c 24 64	 mov	 ecx, DWORD PTR iLength1$[rsp]
  00132	03 c8		 add	 ecx, eax
  00134	8b c1		 mov	 eax, ecx
  00136	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  0013d	2b c8		 sub	 ecx, eax
  0013f	8b c1		 mov	 eax, ecx
  00141	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00149	89 01		 mov	 DWORD PTR [rcx], eax

; 1721 :         }

  0014b	eb 53		 jmp	 SHORT $LN8@read_read_
$LN7@read_read_:

; 1722 :         else
; 1723 :         {
; 1724 :             if (uCount >= (U32)(SIZE_TH + SIZE_RRH + SIZE_PH))

  0014d	83 bc 24 e8 00
	00 00 40	 cmp	 DWORD PTR uCount$[rsp], 64 ; 00000040H
  00155	72 1d		 jb	 SHORT $LN9@read_read_

; 1725 :             {
; 1726 :                 iLength1 = (int)(SIZE_TH + SIZE_RRH + SIZE_PH);

  00157	c7 44 24 64 40
	00 00 00	 mov	 DWORD PTR iLength1$[rsp], 64 ; 00000040H

; 1727 :                 iLength2 = (int)uCount - iLength1;

  0015f	8b 44 24 64	 mov	 eax, DWORD PTR iLength1$[rsp]
  00163	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  0016a	2b c8		 sub	 ecx, eax
  0016c	8b c1		 mov	 eax, ecx
  0016e	89 44 24 60	 mov	 DWORD PTR iLength2$[rsp], eax

; 1728 :             }

  00172	eb 13		 jmp	 SHORT $LN10@read_read_
$LN9@read_read_:

; 1729 :             else
; 1730 :             {
; 1731 :                 iLength1 = (int)uCount;

  00174	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR uCount$[rsp]
  0017b	89 44 24 64	 mov	 DWORD PTR iLength1$[rsp], eax

; 1732 :                 iLength2 = 0;

  0017f	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR iLength2$[rsp], 0
$LN10@read_read_:

; 1733 :             }
; 1734 :             *pMore     = 1;

  00187	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  0018f	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1735 :             *pResidual = 0;

  00192	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0019a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN8@read_read_:

; 1736 :         }
; 1737 :         *pUnitStat = CSW_CE | CSW_DE;

  001a0	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  001a8	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1738 : 
; 1739 :         // Set length field in MPC_TH
; 1740 :         STORE_FW( pMPC_TH->length, (U32)(iLength1 + iLength2) );

  001ab	8b 44 24 60	 mov	 eax, DWORD PTR iLength2$[rsp]
  001af	8b 4c 24 64	 mov	 ecx, DWORD PTR iLength1$[rsp]
  001b3	03 c8		 add	 ecx, eax
  001b5	8b c1		 mov	 eax, ecx
  001b7	8b c8		 mov	 ecx, eax
  001b9	e8 00 00 00 00	 call	 _byteswap_ulong
  001be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  001c3	48 83 c1 0c	 add	 rcx, 12
  001c7	8b d0		 mov	 edx, eax
  001c9	e8 00 00 00 00	 call	 store_fw_noswap

; 1741 : 
; 1742 :         // Set length fields in MPC_RRH
; 1743 :         STORE_HW( pMPC_RRH->lenfida, (U16)iLength2 );

  001ce	0f b7 4c 24 60	 movzx	 ecx, WORD PTR iLength2$[rsp]
  001d3	e8 00 00 00 00	 call	 _byteswap_ushort
  001d8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  001dd	48 83 c1 12	 add	 rcx, 18
  001e1	0f b7 d0	 movzx	 edx, ax
  001e4	e8 00 00 00 00	 call	 store_hw_noswap

; 1744 :         STORE_F3( pMPC_RRH->lenalda, (U32)iLength2 );

  001e9	8b 4c 24 60	 mov	 ecx, DWORD PTR iLength2$[rsp]
  001ed	e8 00 00 00 00	 call	 _byteswap_ulong
  001f2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  001f7	48 83 c1 14	 add	 rcx, 20
  001fb	8b d0		 mov	 edx, eax
  001fd	e8 00 00 00 00	 call	 store_f3_noswap

; 1745 : 
; 1746 :         // Prepare MPC_PH
; 1747 :         pMPC_PH->locdata = PH_LOC_1;

  00202	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  0020a	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1748 :         STORE_F3( pMPC_PH->lendata, (U32)iLength2 );

  0020d	8b 4c 24 60	 mov	 ecx, DWORD PTR iLength2$[rsp]
  00211	e8 00 00 00 00	 call	 _byteswap_ulong
  00216	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PH$[rsp]
  0021e	48 ff c1	 inc	 rcx
  00221	8b d0		 mov	 edx, eax
  00223	e8 00 00 00 00	 call	 store_f3_noswap

; 1749 :         STORE_FW( pMPC_PH->offdata, (U32)(SIZE_TH + SIZE_RRH + SIZE_PH) );

  00228	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0022d	e8 00 00 00 00	 call	 _byteswap_ulong
  00232	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PH$[rsp]
  0023a	48 83 c1 04	 add	 rcx, 4
  0023e	8b d0		 mov	 edx, eax
  00240	e8 00 00 00 00	 call	 store_fw_noswap

; 1750 : 
; 1751 :         // Copy the data to be read to the IO buffer.
; 1752 :         memcpy( pIOBuf, pMPC_TH, iLength1 );

  00245	48 63 44 24 64	 movsxd	 rax, DWORD PTR iLength1$[rsp]
  0024a	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  00252	48 8b 74 24 70	 mov	 rsi, QWORD PTR pMPC_TH$[rsp]
  00257	48 8b c8	 mov	 rcx, rax
  0025a	f3 a4		 rep movsb

; 1753 :         memcpy( pIOBuf + iLength1, (BYTE*)pMPC_TH + LEN_OF_PAGE_ONE, iLength2 );

  0025c	48 63 44 24 60	 movsxd	 rax, DWORD PTR iLength2$[rsp]
  00261	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00266	48 81 c1 fc 0f
	00 00		 add	 rcx, 4092		; 00000ffcH
  0026d	48 63 54 24 64	 movsxd	 rdx, DWORD PTR iLength1$[rsp]
  00272	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  0027a	48 03 fa	 add	 rdi, rdx
  0027d	48 8b d7	 mov	 rdx, rdi
  00280	48 8b fa	 mov	 rdi, rdx
  00283	48 8b f1	 mov	 rsi, rcx
  00286	48 8b c8	 mov	 rcx, rax
  00289	f3 a4		 rep movsb

; 1754 : 
; 1755 :         // Set the length of the data copied to the IO buffer.
; 1756 :         iIOLen =  iLength1 + iLength2;

  0028b	8b 44 24 60	 mov	 eax, DWORD PTR iLength2$[rsp]
  0028f	8b 4c 24 64	 mov	 ecx, DWORD PTR iLength1$[rsp]
  00293	03 c8		 add	 ecx, eax
  00295	8b c1		 mov	 eax, ecx
  00297	89 84 24 88 00
	00 00		 mov	 DWORD PTR iIOLen$[rsp], eax

; 1757 : 
; 1758 :     }

  0029e	e9 72 01 00 00	 jmp	 $LN6@read_read_
$LN5@read_read_:

; 1759 :     else
; 1760 :     {
; 1761 : 
; 1762 :         // All of the data that is currently in page two and onwards
; 1763 :         // will not fit into page one. Copy the headers and the data
; 1764 :         // so that the headers and the data are not contiguous in the
; 1765 :         // guests read buffer, i.e. the layout is the same as that
; 1766 :         // set-up by ptp_read_thread().
; 1767 : 
; 1768 :         // Set the residual length and unit status.
; 1769 :         if (uCount >= (U32)(LEN_OF_PAGE_ONE + iDataLen))

  002a3	8b 44 24 68	 mov	 eax, DWORD PTR iDataLen$[rsp]
  002a7	05 fc 0f 00 00	 add	 eax, 4092		; 00000ffcH
  002ac	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR uCount$[rsp], eax
  002b3	72 3e		 jb	 SHORT $LN11@read_read_

; 1770 :         {
; 1771 :             iLength1 = LEN_OF_PAGE_ONE;

  002b5	c7 44 24 64 fc
	0f 00 00	 mov	 DWORD PTR iLength1$[rsp], 4092 ; 00000ffcH

; 1772 :             iLength2 = iDataLen;

  002bd	8b 44 24 68	 mov	 eax, DWORD PTR iDataLen$[rsp]
  002c1	89 44 24 60	 mov	 DWORD PTR iLength2$[rsp], eax

; 1773 :             *pMore     = 0;

  002c5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  002cd	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1774 :             *pResidual = uCount - (U32)(iLength1 + iLength2);

  002d0	8b 44 24 60	 mov	 eax, DWORD PTR iLength2$[rsp]
  002d4	8b 4c 24 64	 mov	 ecx, DWORD PTR iLength1$[rsp]
  002d8	03 c8		 add	 ecx, eax
  002da	8b c1		 mov	 eax, ecx
  002dc	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  002e3	2b c8		 sub	 ecx, eax
  002e5	8b c1		 mov	 eax, ecx
  002e7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  002ef	89 01		 mov	 DWORD PTR [rcx], eax

; 1775 :         }

  002f1	eb 56		 jmp	 SHORT $LN12@read_read_
$LN11@read_read_:

; 1776 :         else
; 1777 :         {
; 1778 :             if (uCount >= (U32)LEN_OF_PAGE_ONE)

  002f3	81 bc 24 e8 00
	00 00 fc 0f 00
	00		 cmp	 DWORD PTR uCount$[rsp], 4092 ; 00000ffcH
  002fe	72 1d		 jb	 SHORT $LN13@read_read_

; 1779 :             {
; 1780 :                 iLength1 = LEN_OF_PAGE_ONE;

  00300	c7 44 24 64 fc
	0f 00 00	 mov	 DWORD PTR iLength1$[rsp], 4092 ; 00000ffcH

; 1781 :                 iLength2 = (int)uCount - iLength1;

  00308	8b 44 24 64	 mov	 eax, DWORD PTR iLength1$[rsp]
  0030c	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  00313	2b c8		 sub	 ecx, eax
  00315	8b c1		 mov	 eax, ecx
  00317	89 44 24 60	 mov	 DWORD PTR iLength2$[rsp], eax

; 1782 :             }

  0031b	eb 13		 jmp	 SHORT $LN14@read_read_
$LN13@read_read_:

; 1783 :             else
; 1784 :             {
; 1785 :                 iLength1 = (int)uCount;

  0031d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR uCount$[rsp]
  00324	89 44 24 64	 mov	 DWORD PTR iLength1$[rsp], eax

; 1786 :                 iLength2 = 0;

  00328	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR iLength2$[rsp], 0
$LN14@read_read_:

; 1787 :             }
; 1788 :             *pMore     = 1;

  00330	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00338	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1789 :             *pResidual = 0;

  0033b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00343	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN12@read_read_:

; 1790 :         }
; 1791 :         *pUnitStat = CSW_CE | CSW_DE;

  00349	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00351	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1792 : 
; 1793 :         // Set length field in MPC_TH
; 1794 :         STORE_FW( pMPC_TH->length, (U32)(SIZE_TH + SIZE_RRH + SIZE_PH) );

  00354	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00359	e8 00 00 00 00	 call	 _byteswap_ulong
  0035e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00363	48 83 c1 0c	 add	 rcx, 12
  00367	8b d0		 mov	 edx, eax
  00369	e8 00 00 00 00	 call	 store_fw_noswap

; 1795 : 
; 1796 :         // Set length fields in MPC_RRH
; 1797 :         STORE_HW( pMPC_RRH->lenfida, 0 );

  0036e	33 c9		 xor	 ecx, ecx
  00370	e8 00 00 00 00	 call	 _byteswap_ushort
  00375	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  0037a	48 83 c1 12	 add	 rcx, 18
  0037e	0f b7 d0	 movzx	 edx, ax
  00381	e8 00 00 00 00	 call	 store_hw_noswap

; 1798 :         STORE_F3( pMPC_RRH->lenalda, (U32)iLength2 );

  00386	8b 4c 24 60	 mov	 ecx, DWORD PTR iLength2$[rsp]
  0038a	e8 00 00 00 00	 call	 _byteswap_ulong
  0038f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00394	48 83 c1 14	 add	 rcx, 20
  00398	8b d0		 mov	 edx, eax
  0039a	e8 00 00 00 00	 call	 store_f3_noswap

; 1799 : 
; 1800 :         // Prepare MPC_PH
; 1801 :         pMPC_PH->locdata = PH_LOC_2;

  0039f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  003a7	c6 00 02	 mov	 BYTE PTR [rax], 2

; 1802 :         STORE_F3( pMPC_PH->lendata, (U32)iLength2 );

  003aa	8b 4c 24 60	 mov	 ecx, DWORD PTR iLength2$[rsp]
  003ae	e8 00 00 00 00	 call	 _byteswap_ulong
  003b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PH$[rsp]
  003bb	48 ff c1	 inc	 rcx
  003be	8b d0		 mov	 edx, eax
  003c0	e8 00 00 00 00	 call	 store_f3_noswap

; 1803 :         STORE_FW( pMPC_PH->offdata, (U32)(LEN_OF_PAGE_ONE) );

  003c5	b9 fc 0f 00 00	 mov	 ecx, 4092		; 00000ffcH
  003ca	e8 00 00 00 00	 call	 _byteswap_ulong
  003cf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PH$[rsp]
  003d7	48 83 c1 04	 add	 rcx, 4
  003db	8b d0		 mov	 edx, eax
  003dd	e8 00 00 00 00	 call	 store_fw_noswap

; 1804 : 
; 1805 :         // Copy the data to be read to the IO buffer.
; 1806 :         memcpy( pIOBuf, pMPC_TH, iLength1 + iLength2 );

  003e2	8b 44 24 60	 mov	 eax, DWORD PTR iLength2$[rsp]
  003e6	8b 4c 24 64	 mov	 ecx, DWORD PTR iLength1$[rsp]
  003ea	03 c8		 add	 ecx, eax
  003ec	8b c1		 mov	 eax, ecx
  003ee	48 98		 cdqe
  003f0	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  003f8	48 8b 74 24 70	 mov	 rsi, QWORD PTR pMPC_TH$[rsp]
  003fd	48 8b c8	 mov	 rcx, rax
  00400	f3 a4		 rep movsb

; 1807 : 
; 1808 :         // Set the length of the data copied to the IO buffer.
; 1809 :         iIOLen =  iLength1 + iLength2;

  00402	8b 44 24 60	 mov	 eax, DWORD PTR iLength2$[rsp]
  00406	8b 4c 24 64	 mov	 ecx, DWORD PTR iLength1$[rsp]
  0040a	03 c8		 add	 ecx, eax
  0040c	8b c1		 mov	 eax, ecx
  0040e	89 84 24 88 00
	00 00		 mov	 DWORD PTR iIOLen$[rsp], eax
$LN6@read_read_:

; 1810 : 
; 1811 :     }
; 1812 : 
; 1813 :     // Display TH etc. structured, if debug is active
; 1814 :     if (pPTPBLK->uDebugMask & DBGPTPEXPAND)

  00415	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0041d	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00420	83 e0 04	 and	 eax, 4
  00423	85 c0		 test	 eax, eax
  00425	0f 84 c0 00 00
	00		 je	 $LN15@read_read_

; 1815 :     {
; 1816 :         // HHC00982 "%1d:%04X %s: Present data of size %d bytes to guest"
; 1817 :         WRMSG(HHC00982, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, iIOLen );

  0042b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00433	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00437	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv219[rsp], eax
  0043e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00446	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0044a	d1 f9		 sar	 ecx, 1
  0044c	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv223[rsp], ecx
  00453	b9 01 00 00 00	 mov	 ecx, 1
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0045e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR iIOLen$[rsp]
  00465	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00469	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00471	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00475	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0047a	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv219[rsp]
  00481	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00485	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv223[rsp]
  0048c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00490	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170746
  00497	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170747
  004a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170748
  004ba	ba 19 07 00 00	 mov	 edx, 1817		; 00000719H
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170749
  004c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1818 :         mpc_display_ptp_th_etc( pDEVBLK, (MPC_TH*)pIOBuf, TO_GUEST, 64 );

  004cc	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  004d2	41 b0 3e	 mov	 r8b, 62			; 0000003eH
  004d5	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  004dd	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_ptp_th_etc
$LN15@read_read_:

; 1819 :     }
; 1820 : 
; 1821 :     // Display up to 256-bytes of the read data, if debug is active.
; 1822 :     if (pPTPBLK->uDebugMask & DBGPTPDATA)

  004eb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004f3	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  004f6	83 e0 02	 and	 eax, 2
  004f9	85 c0		 test	 eax, eax
  004fb	0f 84 d6 01 00
	00		 je	 $LN16@read_read_

; 1823 :     {
; 1824 :         // HHC00982 "%1d:%04X %s: Present data of size %d bytes to guest"
; 1825 :         WRMSG(HHC00982, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, iIOLen );

  00501	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00509	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0050d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  00514	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0051c	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00520	d1 f9		 sar	 ecx, 1
  00522	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv249[rsp], ecx
  00529	b9 01 00 00 00	 mov	 ecx, 1
  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00534	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR iIOLen$[rsp]
  0053b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0053f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00547	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0054b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00550	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  00557	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0055b	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv249[rsp]
  00562	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170751
  0056d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00572	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170752
  00579	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0057e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00583	41 b9 03 00 00
	00		 mov	 r9d, 3
  00589	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170753
  00590	ba 21 07 00 00	 mov	 edx, 1825		; 00000721H
  00595	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170754
  0059c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1826 :         FETCH_FW( uTotalLen, pMPC_TH->length );

  005a2	48 8b 44 24 70	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  005a7	48 83 c0 0c	 add	 rax, 12
  005ab	48 8b c8	 mov	 rcx, rax
  005ae	e8 00 00 00 00	 call	 fetch_fw_noswap
  005b3	8b c8		 mov	 ecx, eax
  005b5	e8 00 00 00 00	 call	 _byteswap_ulong
  005ba	89 84 24 90 00
	00 00		 mov	 DWORD PTR uTotalLen$[rsp], eax

; 1827 :         iTraceLen = uTotalLen;

  005c1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR uTotalLen$[rsp]
  005c8	89 44 24 6c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1828 :         if (iTraceLen > 256)

  005cc	81 7c 24 6c 00
	01 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 256 ; 00000100H
  005d4	0f 8e c7 00 00
	00		 jle	 $LN17@read_read_

; 1829 :         {
; 1830 :             iTraceLen = 256;

  005da	c7 44 24 6c 00
	01 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 256 ; 00000100H

; 1831 :             // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1832 :             WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  005e2	8b 44 24 6c	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  005e6	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR uTotalLen$[rsp]
  005ed	2b c8		 sub	 ecx, eax
  005ef	8b c1		 mov	 eax, ecx
  005f1	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv266[rsp], eax
  005f8	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00600	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00604	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv272[rsp], ecx
  0060b	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00613	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00617	d1 fa		 sar	 edx, 1
  00619	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv276[rsp], edx
  00620	b9 01 00 00 00	 mov	 ecx, 1
  00625	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0062b	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv266[rsp]
  00632	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00636	8b 4c 24 6c	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  0063a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0063e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00646	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0064a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0064f	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv272[rsp]
  00656	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0065a	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv276[rsp]
  00661	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00665	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170756
  0066c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00671	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170757
  00678	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0067d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00682	41 b9 03 00 00
	00		 mov	 r9d, 3
  00688	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170758
  0068f	ba 29 07 00 00	 mov	 edx, 1833		; 00000729H
  00694	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170759
  0069b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@read_read_:

; 1833 :                                  iTraceLen, (int)(uTotalLen - iTraceLen) );
; 1834 :         }
; 1835 :         net_data_trace( pDEVBLK, pIOBuf, iTraceLen, TO_GUEST, 'D', "data", 0 );

  006a1	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  006a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170760
  006b0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006b5	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  006ba	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  006bd	44 8b 44 24 6c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  006c2	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  006ca	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006d2	e8 00 00 00 00	 call	 net_data_trace
$LN16@read_read_:

; 1836 :     }
; 1837 : 
; 1838 :     // Reset length field in PTPHDR
; 1839 :     pPTPHDR->iDataLen = LEN_OF_PAGE_ONE;

  006d7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  006df	c7 40 0c fc 0f
	00 00		 mov	 DWORD PTR [rax+12], 4092 ; 00000ffcH

; 1840 : 
; 1841 :     // Clear length field in MPC_TH
; 1842 :     STORE_FW( pMPC_TH->length, 0 );

  006e6	33 c9		 xor	 ecx, ecx
  006e8	e8 00 00 00 00	 call	 _byteswap_ulong
  006ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  006f2	48 83 c1 0c	 add	 rcx, 12
  006f6	8b d0		 mov	 edx, eax
  006f8	e8 00 00 00 00	 call	 store_fw_noswap

; 1843 : 
; 1844 :     // Clear length fields in MPC_RRH
; 1845 :     STORE_HW( pMPC_RRH->lenfida, 0 );

  006fd	33 c9		 xor	 ecx, ecx
  006ff	e8 00 00 00 00	 call	 _byteswap_ushort
  00704	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00709	48 83 c1 12	 add	 rcx, 18
  0070d	0f b7 d0	 movzx	 edx, ax
  00710	e8 00 00 00 00	 call	 store_hw_noswap

; 1846 :     STORE_F3( pMPC_RRH->lenalda, 0 );

  00715	33 c9		 xor	 ecx, ecx
  00717	e8 00 00 00 00	 call	 _byteswap_ulong
  0071c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00721	48 83 c1 14	 add	 rcx, 20
  00725	8b d0		 mov	 edx, eax
  00727	e8 00 00 00 00	 call	 store_f3_noswap

; 1847 : 
; 1848 :     // Clear location, length and displacement fields in MPC_PH
; 1849 :     pMPC_PH->locdata = 0;

  0072c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  00734	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1850 :     STORE_F3( pMPC_PH->lendata, 0 );

  00737	33 c9		 xor	 ecx, ecx
  00739	e8 00 00 00 00	 call	 _byteswap_ulong
  0073e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PH$[rsp]
  00746	48 ff c1	 inc	 rcx
  00749	8b d0		 mov	 edx, eax
  0074b	e8 00 00 00 00	 call	 store_f3_noswap

; 1851 :     STORE_FW( pMPC_PH->offdata, 0 );

  00750	33 c9		 xor	 ecx, ecx
  00752	e8 00 00 00 00	 call	 _byteswap_ulong
  00757	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_PH$[rsp]
  0075f	48 83 c1 04	 add	 rcx, 4
  00763	8b d0		 mov	 edx, eax
  00765	e8 00 00 00 00	 call	 store_fw_noswap

; 1852 : 
; 1853 :     return;
; 1854 : }   /* End function  read_read_buffer() */

  0076a	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00771	5f		 pop	 rdi
  00772	5e		 pop	 rsi
  00773	c3		 ret	 0
read_read_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
haltorclear$ = 80
pPTPBLK$ = 88
pPTPHDR$ = 96
pPTPATH$ = 104
rc$ = 112
tv174 = 116
tv178 = 120
now$ = 128
tv203 = 136
waittime$ = 144
__$ArrayPad$ = 160
pDEVBLK$ = 192
uCount$ = 200
iCCWSeq$ = 208
pIOBuf$ = 216
pMore$ = 224
pUnitStat$ = 232
pResidual$ = 240
ptp_read PROC

; 1529 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1530 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;

  0002d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00035	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0003c	48 89 44 24 68	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 1531 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;

  00041	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 89 44 24 58	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 1532 :     PTPHDR*    pPTPHDR  = NULL;

  0004e	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pPTPHDR$[rsp], 0

; 1533 :     int        rc       = 0;

  00057	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 1534 :     struct timespec waittime;
; 1535 :     struct timeval  now;
; 1536 :     BYTE       haltorclear = FALSE;

  0005f	c6 44 24 50 00	 mov	 BYTE PTR haltorclear$[rsp], 0

; 1537 : 
; 1538 :     if (pPTPATH->bDLCtype == DLCTYPE_READ)     // Read from the y-side's Read path?

  00064	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00069	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0006d	83 f8 05	 cmp	 eax, 5
  00070	0f 85 10 03 00
	00		 jne	 $LN5@ptp_read
$LN2@ptp_read:

; 1539 :     {
; 1540 :         // The read is from the y-side's Read path.
; 1541 :         for (;;)
; 1542 :         {
; 1543 :             // Return the data from a chain buffer to the guest OS.
; 1544 :             // There will be chain buffers on the Read path during
; 1545 :             // handshaking, and just after the IPv6 connection has
; 1546 :             // become active.
; 1547 : 
; 1548 :             // Remove first buffer from chain.
; 1549 :             pPTPHDR = remove_buffer_from_chain( pPTPATH );

  00076	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  0007b	e8 00 00 00 00	 call	 remove_buffer_from_chain
  00080	48 89 44 24 60	 mov	 QWORD PTR pPTPHDR$[rsp], rax

; 1550 :             if (pPTPHDR)

  00085	48 83 7c 24 60
	00		 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  0008b	74 65		 je	 SHORT $LN7@ptp_read

; 1551 :             {
; 1552 :                 // Return the data to the guest OS.
; 1553 :                 read_chain_buffer( pDEVBLK, uCount, iCCWSeq, pIOBuf,

  0008d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00092	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00097	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0009f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000a4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  000ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  000b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000be	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  000c6	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  000ce	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  000d5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000dd	e8 00 00 00 00	 call	 read_chain_buffer

; 1554 :                                    pMore, pUnitStat, pResidual, pPTPHDR );
; 1555 : 
; 1556 :                 // Free the buffer.
; 1557 :                 free( pPTPHDR );

  000e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1558 :                 return;

  000ed	e9 57 03 00 00	 jmp	 $LN1@ptp_read
$LN7@ptp_read:

; 1559 :             }
; 1560 : 
; 1561 :             // Return the data from the read buffer to the guest OS.
; 1562 :             // There is a read buffer on the Read path, and the buffer
; 1563 :             // will contain data after the IPv4 and/or IPv6 connection
; 1564 :             // has become active.
; 1565 : 
; 1566 :             // Obtain the read buffer lock.
; 1567 :             obtain_lock( &pPTPBLK->ReadBufferLock );

  000f2	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  000f7	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170656
  00102	48 8b c8	 mov	 rcx, rax
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1568 : 
; 1569 :             pPTPHDR = pPTPBLK->pReadBuffer;

  0010b	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00110	48 8b 40 34	 mov	 rax, QWORD PTR [rax+52]
  00114	48 89 44 24 60	 mov	 QWORD PTR pPTPHDR$[rsp], rax

; 1570 :             if (pPTPHDR && pPTPHDR->iDataLen > LEN_OF_PAGE_ONE)

  00119	48 83 7c 24 60
	00		 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  0011f	0f 84 81 00 00
	00		 je	 $LN8@ptp_read
  00125	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  0012a	81 78 0c fc 0f
	00 00		 cmp	 DWORD PTR [rax+12], 4092 ; 00000ffcH
  00131	7e 73		 jle	 SHORT $LN8@ptp_read

; 1571 :             {
; 1572 :                 // Return the data to the guest OS.
; 1573 :                 read_read_buffer( pDEVBLK, uCount, iCCWSeq, pIOBuf,

  00133	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  00138	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0013d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00145	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0014a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00152	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00157	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  0015f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00164	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  0016c	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  00174	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  0017b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00183	e8 00 00 00 00	 call	 read_read_buffer

; 1574 :                                        pMore, pUnitStat, pResidual, pPTPHDR );
; 1575 : 
; 1576 :                 // Release the read buffer lock.
; 1577 :                 release_lock( &pPTPBLK->ReadBufferLock );

  00188	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0018d	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00191	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170658
  00198	48 8b c8	 mov	 rcx, rax
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1578 :                 return;

  001a1	e9 a3 02 00 00	 jmp	 $LN1@ptp_read
$LN8@ptp_read:

; 1579 :             }
; 1580 : 
; 1581 :             // Release the read buffer lock.
; 1582 :             release_lock( &pPTPBLK->ReadBufferLock );

  001a6	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001ab	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170659
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1583 : 
; 1584 :             // There is no data waiting to be read.
; 1585 :             // Calculate when to end the wait.
; 1586 :             gettimeofday( &now, NULL );

  001bf	33 d2		 xor	 edx, edx
  001c1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR now$[rsp]
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 1587 : 
; 1588 :             waittime.tv_sec  = now.tv_sec  + PTP_READ_TIMEOUT_SECS;

  001cf	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR now$[rsp]
  001d6	83 c0 05	 add	 eax, 5
  001d9	48 98		 cdqe
  001db	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR waittime$[rsp], rax

; 1589 :             waittime.tv_nsec = now.tv_usec * 1000;

  001e3	69 84 24 84 00
	00 00 e8 03 00
	00		 imul	 eax, DWORD PTR now$[rsp+4], 1000 ; 000003e8H
  001ee	89 84 24 98 00
	00 00		 mov	 DWORD PTR waittime$[rsp+8], eax

; 1590 : 
; 1591 :             // Obtain the event lock
; 1592 :             obtain_lock( &pPTPBLK->ReadEventLock );

  001f5	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001fa	48 83 c0 40	 add	 rax, 64			; 00000040H
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170660
  00205	48 8b c8	 mov	 rcx, rax
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1593 : 
; 1594 :             // Use a calculated wait
; 1595 :             pPTPBLK->fReadWaiting = 1;

  0020e	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00213	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00216	0f ba e8 08	 bts	 eax, 8
  0021a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0021f	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 1596 :             rc = timed_wait_condition( &pPTPBLK->ReadEvent,

  00222	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00227	48 83 c0 40	 add	 rax, 64			; 00000040H
  0022b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00230	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00234	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170661
  0023b	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR waittime$[rsp]
  00243	48 8b d0	 mov	 rdx, rax
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition
  0024c	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1597 :                                        &pPTPBLK->ReadEventLock,
; 1598 :                                        &waittime );
; 1599 :             pPTPBLK->fReadWaiting = 0;

  00250	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00255	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00258	0f ba f0 08	 btr	 eax, 8
  0025c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00261	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 1600 : 
; 1601 :             // check for halt condition
; 1602 :             if (pPTPBLK->fHaltOrClear)

  00264	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00269	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0026c	c1 e8 09	 shr	 eax, 9
  0026f	83 e0 01	 and	 eax, 1
  00272	85 c0		 test	 eax, eax
  00274	74 19		 je	 SHORT $LN9@ptp_read

; 1603 :             {
; 1604 :                 haltorclear = TRUE;

  00276	c6 44 24 50 01	 mov	 BYTE PTR haltorclear$[rsp], 1

; 1605 :                 pPTPBLK->fHaltOrClear = 0;

  0027b	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00280	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00283	0f ba f0 09	 btr	 eax, 9
  00287	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0028c	89 41 6c	 mov	 DWORD PTR [rcx+108], eax
$LN9@ptp_read:

; 1606 :             }
; 1607 : 
; 1608 :             // Release the event lock
; 1609 :             release_lock( &pPTPBLK->ReadEventLock );

  0028f	48 8b 44 24 58	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00294	48 83 c0 40	 add	 rax, 64			; 00000040H
  00298	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170663
  0029f	48 8b c8	 mov	 rcx, rax
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1610 : 
; 1611 :             // check for halt condition
; 1612 :             if (haltorclear)

  002a8	0f b6 44 24 50	 movzx	 eax, BYTE PTR haltorclear$[rsp]
  002ad	85 c0		 test	 eax, eax
  002af	0f 84 c7 00 00
	00		 je	 $LN10@ptp_read

; 1613 :             {
; 1614 :                 if (pDEVBLK->ccwtrace)

  002b5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002bd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002c3	c1 e8 0f	 shr	 eax, 15
  002c6	83 e0 01	 and	 eax, 1
  002c9	85 c0		 test	 eax, eax
  002cb	0f 84 8a 00 00
	00		 je	 $LN11@ptp_read

; 1615 :                 {
; 1616 :                     // HHC00904 "%1d:%04X %s: halt or clear recognized"
; 1617 :                     WRMSG(HHC00904, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname );

  002d1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002d9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002dd	89 44 24 74	 mov	 DWORD PTR tv174[rsp], eax
  002e1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002e9	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  002ed	d1 f9		 sar	 ecx, 1
  002ef	89 4c 24 78	 mov	 DWORD PTR tv178[rsp], ecx
  002f3	b9 01 00 00 00	 mov	 ecx, 1
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002fe	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00306	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0030a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0030f	8b 4c 24 74	 mov	 ecx, DWORD PTR tv174[rsp]
  00313	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00317	8b 4c 24 78	 mov	 ecx, DWORD PTR tv178[rsp]
  0031b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0031f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170666
  00326	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0032b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170667
  00332	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00337	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00342	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170668
  00349	ba 51 06 00 00	 mov	 edx, 1617		; 00000651H
  0034e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170669
  00355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN11@ptp_read:

; 1618 :                 }
; 1619 :                 *pUnitStat = CSW_CE | CSW_DE;

  0035b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00363	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1620 :                 *pResidual = uCount;

  00366	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0036e	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  00375	89 08		 mov	 DWORD PTR [rax], ecx

; 1621 :                 return;

  00377	e9 cd 00 00 00	 jmp	 $LN1@ptp_read
$LN10@ptp_read:

; 1622 :             }
; 1623 :         } /* for (;;) */

  0037c	e9 f5 fc ff ff	 jmp	 $LN2@ptp_read

; 1624 :     }

  00381	e9 c3 00 00 00	 jmp	 $LN6@ptp_read
$LN5@ptp_read:

; 1625 :     else
; 1626 :     {
; 1627 :         // The read is from the y-side's Write path. There should only
; 1628 :         // ever be reads from the y-side's Write path while the XID2
; 1629 :         // exchange is in progress during handshaking.
; 1630 : 
; 1631 :         // Remove first buffer from chain.
; 1632 :         pPTPHDR = remove_buffer_from_chain( pPTPATH );

  00386	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  0038b	e8 00 00 00 00	 call	 remove_buffer_from_chain
  00390	48 89 44 24 60	 mov	 QWORD PTR pPTPHDR$[rsp], rax

; 1633 :         if (pPTPHDR)

  00395	48 83 7c 24 60
	00		 cmp	 QWORD PTR pPTPHDR$[rsp], 0
  0039b	74 64		 je	 SHORT $LN12@ptp_read

; 1634 :         {
; 1635 :             // There is a buffer on the chain waiting to be read.
; 1636 :             read_chain_buffer( pDEVBLK, uCount, iCCWSeq, pIOBuf,

  0039d	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPHDR$[rsp]
  003a2	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  003a7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  003af	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003b4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  003bc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003c1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  003c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ce	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  003d6	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  003de	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  003e5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003ed	e8 00 00 00 00	 call	 read_chain_buffer

; 1637 :                                pMore, pUnitStat, pResidual, pPTPHDR );
; 1638 : 
; 1639 :             // Free the buffer.
; 1640 :             free( pPTPHDR );

  003f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPHDR$[rsp]
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1641 : 
; 1642 :             return;

  003fd	eb 4a		 jmp	 SHORT $LN1@ptp_read

; 1643 :         }

  003ff	eb 48		 jmp	 SHORT $LN13@ptp_read
$LN12@ptp_read:

; 1644 :         else
; 1645 :         {
; 1646 :             // There is no buffer on the chain waiting to be read. This
; 1647 :             // should not happen! Read a load of nulls.
; 1648 :             memset( pIOBuf, 0, (int)uCount );

  00401	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR uCount$[rsp]
  00409	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv203[rsp], rax
  00411	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  00419	33 c0		 xor	 eax, eax
  0041b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv203[rsp]
  00423	f3 aa		 rep stosb

; 1649 :             *pMore     = 0;

  00425	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  0042d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1650 :             *pResidual = 0;

  00430	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00438	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1651 :             *pUnitStat = CSW_CE | CSW_DE;

  0043e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00446	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN13@ptp_read:
$LN6@ptp_read:
$LN1@ptp_read:

; 1652 : 
; 1653 :             return;
; 1654 :         }
; 1655 : 
; 1656 :     }   /* if (pPTPATH->bDLCtype == DLCTYPE_READ ) */
; 1657 : 
; 1658 :     return;
; 1659 : }   /* End function  ptp_read() */

  00449	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00451	48 33 cc	 xor	 rcx, rsp
  00454	e8 00 00 00 00	 call	 __security_check_cookie
  00459	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00460	5f		 pop	 rdi
  00461	c3		 ret	 0
ptp_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPBLK$ = 32
pPTPATH$ = 40
pDEVBLK$ = 64
ptp_halt_or_clear PROC

; 1497 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1498 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00015	48 89 44 24 28	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 1499 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;

  0001a	48 8b 44 24 28	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 44 24 20	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 1500 :     obtain_lock( &pPTPBLK->ReadEventLock );

  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0002c	48 83 c0 40	 add	 rax, 64			; 00000040H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170619
  00037	48 8b c8	 mov	 rcx, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1501 :     {
; 1502 :         if (pPTPBLK->fReadWaiting)

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00045	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00048	c1 e8 08	 shr	 eax, 8
  0004b	83 e0 01	 and	 eax, 1
  0004e	85 c0		 test	 eax, eax
  00050	74 2d		 je	 SHORT $LN2@ptp_halt_o

; 1503 :         {
; 1504 :             pPTPBLK->fHaltOrClear = 1;

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00057	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0005a	0f ba e8 09	 bts	 eax, 9
  0005e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00063	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 1505 :             signal_condition( &pPTPBLK->ReadEvent );

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0006b	48 83 c0 48	 add	 rax, 72			; 00000048H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170621
  00076	48 8b c8	 mov	 rcx, rax
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN2@ptp_halt_o:

; 1506 :         }
; 1507 :     }
; 1508 :     release_lock( &pPTPBLK->ReadEventLock );

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00084	48 83 c0 40	 add	 rax, 64			; 00000040H
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170622
  0008f	48 8b c8	 mov	 rcx, rax
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1509 : }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
ptp_halt_or_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
iTraceLen$ = 112
iDataLen$ = 116
iPktLen$ = 120
uPayLen$ = 124
rv$ = 128
pData$ = 136
uNumPH$ = 144
pPTPBLK$ = 152
iPktVer$ = 160
uOffPH$ = 164
iForPH$ = 168
uOffData$ = 172
uLenData$ = 176
fWantPkt$ = 180
pMPC_PH$ = 184
pDataBuf$ = 192
tv198 = 200
tv238 = 204
tv242 = 208
tv254 = 212
tv260 = 216
tv264 = 220
tv287 = 224
tv291 = 228
tv303 = 232
tv309 = 236
tv313 = 240
tv351 = 244
tv355 = 248
tv422 = 252
tv172 = 256
tv176 = 260
tv188 = 264
tv194 = 268
pPTPATH$ = 272
pData1$ = 280
tv167 = 288
pIP4FRM$ = 296
pIP6FRM$ = 304
tv235 = 312
tv284 = 320
tv344 = 328
tv379 = 336
tv383 = 344
tv417 = 352
cPktVer$ = 360
__$ArrayPad$ = 368
pDEVBLK$ = 416
pMPC_TH$ = 424
pMPC_RRH$ = 432
write_rrh_8108 PROC

; 1262 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1263 :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;

  0002a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00032	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00039	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 1264 :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;

  00041	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 1265 :     MPC_PH*    pMPC_PH;
; 1266 :     BYTE*      pData;
; 1267 :     int        iDataLen;
; 1268 :     BYTE*      pDataBuf;
; 1269 :     U16        uNumPH;
; 1270 :     U16        uOffPH;
; 1271 :     int        iForPH;
; 1272 :     U32        uLenData;
; 1273 :     U32        uOffData;
; 1274 :     BYTE*      pData1;
; 1275 :     PIP4FRM    pIP4FRM;
; 1276 :     PIP6FRM    pIP6FRM;
; 1277 :     U16        uPayLen;
; 1278 :     int        iPktLen;
; 1279 :     u_int      fWantPkt;
; 1280 :     int        iPktVer;
; 1281 :     char       cPktVer[8];
; 1282 :     int        iTraceLen;
; 1283 :     int        rv;
; 1284 : 
; 1285 : 
; 1286 :     // Get the number of MPC_PHs and point to the first (or only) MPC_PH
; 1287 :     // following the MPC_RRH.
; 1288 :     FETCH_HW( uNumPH, pMPC_RRH->numph );

  00054	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0005c	48 83 c0 06	 add	 rax, 6
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 fetch_hw_noswap
  00068	0f b7 c8	 movzx	 ecx, ax
  0006b	e8 00 00 00 00	 call	 _byteswap_ushort
  00070	66 89 84 24 90
	00 00 00	 mov	 WORD PTR uNumPH$[rsp], ax

; 1289 :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00078	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00080	48 83 c0 10	 add	 rax, 16
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 fetch_hw_noswap
  0008c	0f b7 c8	 movzx	 ecx, ax
  0008f	e8 00 00 00 00	 call	 _byteswap_ushort
  00094	66 89 84 24 a4
	00 00 00	 mov	 WORD PTR uOffPH$[rsp], ax

; 1290 :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  0009c	0f b7 84 24 a4
	00 00 00	 movzx	 eax, WORD PTR uOffPH$[rsp]
  000a4	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 1291 : 
; 1292 :     // Get the length of and the pointer to the data referenced by the
; 1293 :     // first (or only) MPC_PH
; 1294 :     FETCH_F3( uLenData, pMPC_PH->lendata );

  000ba	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  000c2	48 ff c0	 inc	 rax
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 fetch_f3_noswap
  000cd	8b c8		 mov	 ecx, eax
  000cf	e8 00 00 00 00	 call	 _byteswap_ulong
  000d4	89 84 24 b0 00
	00 00		 mov	 DWORD PTR uLenData$[rsp], eax

; 1295 :     FETCH_FW( uOffData, pMPC_PH->offdata );

  000db	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  000e3	48 83 c0 04	 add	 rax, 4
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 fetch_fw_noswap
  000ef	8b c8		 mov	 ecx, eax
  000f1	e8 00 00 00 00	 call	 _byteswap_ulong
  000f6	89 84 24 ac 00
	00 00		 mov	 DWORD PTR uOffData$[rsp], eax

; 1296 :     pData = (BYTE*)pMPC_TH + uOffData;

  000fd	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR uOffData$[rsp]
  00104	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  0010c	48 03 c8	 add	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pData$[rsp], rax

; 1297 : 
; 1298 :     // Get the total length of the data referenced by all of the MPC_PHs.
; 1299 :     FETCH_F3( iDataLen, pMPC_RRH->lenalda );

  0011a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00122	48 83 c0 14	 add	 rax, 20
  00126	48 8b c8	 mov	 rcx, rax
  00129	e8 00 00 00 00	 call	 fetch_f3_noswap
  0012e	8b c8		 mov	 ecx, eax
  00130	e8 00 00 00 00	 call	 _byteswap_ulong
  00135	89 44 24 74	 mov	 DWORD PTR iDataLen$[rsp], eax

; 1300 : 
; 1301 :     // Check whether there is more than one MPC_PH.
; 1302 :     if (uNumPH == 1)

  00139	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR uNumPH$[rsp]
  00141	83 f8 01	 cmp	 eax, 1
  00144	75 11		 jne	 SHORT $LN7@write_rrh_

; 1303 :     {
; 1304 :         pDataBuf = NULL;

  00146	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pDataBuf$[rsp], 0

; 1305 :     }

  00152	e9 31 01 00 00	 jmp	 $LN8@write_rrh_
$LN7@write_rrh_:

; 1306 :     else
; 1307 :     {
; 1308 :         // More than one MPC_PH. Allocate a buffer in which all of
; 1309 :         // the data referenced by the MPC_PHs will be concatanated.
; 1310 :         pDataBuf = alloc_storage( pDEVBLK, iDataLen );   // Allocate buffer

  00157	8b 54 24 74	 mov	 edx, DWORD PTR iDataLen$[rsp]
  0015b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00163	e8 00 00 00 00	 call	 alloc_storage
  00168	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pDataBuf$[rsp], rax

; 1311 :         if (!pDataBuf)               // if the allocate was not successful...

  00170	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR pDataBuf$[rsp], 0
  00179	75 0a		 jne	 SHORT $LN9@write_rrh_

; 1312 :             return -1;

  0017b	b8 ff ff ff ff	 mov	 eax, -1
  00180	e9 a7 0a 00 00	 jmp	 $LN1@write_rrh_
$LN9@write_rrh_:

; 1313 : 
; 1314 :         // Copy and concatanate the data referenced by the MPC_PHs.
; 1315 :         pData = pDataBuf;

  00185	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDataBuf$[rsp]
  0018d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pData$[rsp], rax

; 1316 :         for( iForPH = 1; iForPH <= uNumPH; iForPH++ )

  00195	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR iForPH$[rsp], 1
  001a0	eb 10		 jmp	 SHORT $LN4@write_rrh_
$LN2@write_rrh_:
  001a2	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR iForPH$[rsp]
  001a9	ff c0		 inc	 eax
  001ab	89 84 24 a8 00
	00 00		 mov	 DWORD PTR iForPH$[rsp], eax
$LN4@write_rrh_:
  001b2	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR uNumPH$[rsp]
  001ba	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR iForPH$[rsp], eax
  001c1	0f 8f b1 00 00
	00		 jg	 $LN3@write_rrh_

; 1317 :         {
; 1318 :             FETCH_F3( uLenData, pMPC_PH->lendata );

  001c7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  001cf	48 ff c0	 inc	 rax
  001d2	48 8b c8	 mov	 rcx, rax
  001d5	e8 00 00 00 00	 call	 fetch_f3_noswap
  001da	8b c8		 mov	 ecx, eax
  001dc	e8 00 00 00 00	 call	 _byteswap_ulong
  001e1	89 84 24 b0 00
	00 00		 mov	 DWORD PTR uLenData$[rsp], eax

; 1319 :             FETCH_FW( uOffData, pMPC_PH->offdata );

  001e8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  001f0	48 83 c0 04	 add	 rax, 4
  001f4	48 8b c8	 mov	 rcx, rax
  001f7	e8 00 00 00 00	 call	 fetch_fw_noswap
  001fc	8b c8		 mov	 ecx, eax
  001fe	e8 00 00 00 00	 call	 _byteswap_ulong
  00203	89 84 24 ac 00
	00 00		 mov	 DWORD PTR uOffData$[rsp], eax

; 1320 :             pData1 = (BYTE*)pMPC_TH + uOffData;

  0020a	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR uOffData$[rsp]
  00211	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00219	48 03 c8	 add	 rcx, rax
  0021c	48 8b c1	 mov	 rax, rcx
  0021f	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR pData1$[rsp], rax

; 1321 : 
; 1322 :             memcpy( pData, pData1, uLenData );

  00227	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR uLenData$[rsp]
  0022e	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR pData$[rsp]
  00236	48 8b b4 24 18
	01 00 00	 mov	 rsi, QWORD PTR pData1$[rsp]
  0023e	8b c8		 mov	 ecx, eax
  00240	f3 a4		 rep movsb

; 1323 :             pData += uLenData;

  00242	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR uLenData$[rsp]
  00249	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pData$[rsp]
  00251	48 03 c8	 add	 rcx, rax
  00254	48 8b c1	 mov	 rax, rcx
  00257	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pData$[rsp], rax

; 1324 : 
; 1325 :             pMPC_PH = (MPC_PH*)((BYTE*)pMPC_PH + SIZE_PH);

  0025f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  00267	48 83 c0 08	 add	 rax, 8
  0026b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 1326 :         }

  00273	e9 2a ff ff ff	 jmp	 $LN2@write_rrh_
$LN3@write_rrh_:

; 1327 : 
; 1328 :         // Point to the copied and concatenated data.
; 1329 :         pData = pDataBuf;

  00278	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pDataBuf$[rsp]
  00280	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pData$[rsp], rax
$LN8@write_rrh_:
$LN5@write_rrh_:

; 1330 :     }
; 1331 : 
; 1332 :     // pData points to and iDataLen contains the length of a contiguous
; 1333 :     // lump of storage that contains the data in the message. The data
; 1334 :     // consists of one or more IP packets.
; 1335 :     while( iDataLen > 0 )

  00288	83 7c 24 74 00	 cmp	 DWORD PTR iDataLen$[rsp], 0
  0028d	0f 8e 79 09 00
	00		 jle	 $LN6@write_rrh_

; 1336 :     {
; 1337 :         pIP4FRM = (PIP4FRM)pData;

  00293	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pData$[rsp]
  0029b	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR pIP4FRM$[rsp], rax

; 1338 :         pIP6FRM = (PIP6FRM)pData;

  002a3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pData$[rsp]
  002ab	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR pIP6FRM$[rsp], rax

; 1339 : 
; 1340 :         // Check the IP packet version. The first 4-bits of the first
; 1341 :         // byte of the IP header contains the version number.
; 1342 :         iPktVer = ( ( pData[0] & 0xF0 ) >> 4 );

  002b3	b8 01 00 00 00	 mov	 eax, 1
  002b8	48 6b c0 00	 imul	 rax, rax, 0
  002bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pData$[rsp]
  002c4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c8	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  002cd	c1 f8 04	 sar	 eax, 4
  002d0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR iPktVer$[rsp], eax

; 1343 :         if (iPktVer == 4)

  002d7	83 bc 24 a0 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  002df	75 19		 jne	 SHORT $LN10@write_rrh_

; 1344 :         {
; 1345 :             strcpy( cPktVer, " IPv4" );

  002e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170554
  002e8	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR cPktVer$[rsp]
  002f0	e8 00 00 00 00	 call	 strcpy

; 1346 :         }

  002f5	e9 eb 01 00 00	 jmp	 $LN11@write_rrh_
$LN10@write_rrh_:

; 1347 :         else if (iPktVer == 6)

  002fa	83 bc 24 a0 00
	00 00 06	 cmp	 DWORD PTR iPktVer$[rsp], 6
  00302	75 19		 jne	 SHORT $LN12@write_rrh_

; 1348 :         {
; 1349 :             strcpy( cPktVer, " IPv6" );

  00304	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170557
  0030b	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR cPktVer$[rsp]
  00313	e8 00 00 00 00	 call	 strcpy

; 1350 :         }

  00318	e9 c8 01 00 00	 jmp	 $LN13@write_rrh_
$LN12@write_rrh_:

; 1351 :         else
; 1352 :         {
; 1353 :             // Err... not IPv4 or IPv6!
; 1354 :             // HHC03933 "%1d:%04X PTP: Accept data for device '%s' contains IP packet with unknown IP version, data dropped"
; 1355 :             WRMSG(HHC03933, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  0031d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00325	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  0032b	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv167[rsp], rax
  00333	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0033b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0033f	89 8c 24 00 01
	00 00		 mov	 DWORD PTR tv172[rsp], ecx
  00346	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0034e	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00352	d1 fa		 sar	 edx, 1
  00354	89 94 24 04 01
	00 00		 mov	 DWORD PTR tv176[rsp], edx
  0035b	b9 01 00 00 00	 mov	 ecx, 1
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00366	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv167[rsp]
  0036e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00373	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv172[rsp]
  0037a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0037e	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  00385	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170558
  00390	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170559
  0039c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a6	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170560
  003b3	ba 4c 05 00 00	 mov	 edx, 1356		; 0000054cH
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170561
  003bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1356 :                                  pPTPBLK->szTUNIfName );
; 1357 :             iTraceLen = iDataLen;

  003c5	8b 44 24 74	 mov	 eax, DWORD PTR iDataLen$[rsp]
  003c9	89 44 24 70	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1358 :             if (iTraceLen > 128)

  003cd	81 7c 24 70 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  003d5	0f 8e c4 00 00
	00		 jle	 $LN14@write_rrh_

; 1359 :             {
; 1360 :                 iTraceLen = 128;

  003db	c7 44 24 70 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 1361 :                 // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1362 :                 WRMSG(HHC00980, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  003e3	8b 44 24 70	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  003e7	8b 4c 24 74	 mov	 ecx, DWORD PTR iDataLen$[rsp]
  003eb	2b c8		 sub	 ecx, eax
  003ed	8b c1		 mov	 eax, ecx
  003ef	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv188[rsp], eax
  003f6	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003fe	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00402	89 8c 24 0c 01
	00 00		 mov	 DWORD PTR tv194[rsp], ecx
  00409	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00411	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00415	d1 fa		 sar	 edx, 1
  00417	89 94 24 c8 00
	00 00		 mov	 DWORD PTR tv198[rsp], edx
  0041e	b9 01 00 00 00	 mov	 ecx, 1
  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00429	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  00430	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00434	8b 4c 24 70	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00438	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0043c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00444	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00448	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0044d	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  00454	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00458	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  0045f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00463	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170563
  0046a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0046f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170564
  00476	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0047b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00480	41 b9 03 00 00
	00		 mov	 r9d, 3
  00486	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170565
  0048d	ba 53 05 00 00	 mov	 edx, 1363		; 00000553H
  00492	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170566
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@write_rrh_:

; 1363 :                                      iTraceLen, iDataLen - iTraceLen );
; 1364 :             }
; 1365 :             net_data_trace( pDEVBLK, pData, iTraceLen, FROM_GUEST, 'I', "data", 0 );

  0049f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  004a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170567
  004ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004b3	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  004b8	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  004bb	44 8b 44 24 70	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  004c0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pData$[rsp]
  004c8	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004d0	e8 00 00 00 00	 call	 net_data_trace

; 1366 :             rv = -2;

  004d5	c7 84 24 80 00
	00 00 fe ff ff
	ff		 mov	 DWORD PTR rv$[rsp], -2

; 1367 :             break;

  004e0	e9 27 07 00 00	 jmp	 $LN6@write_rrh_
$LN13@write_rrh_:
$LN11@write_rrh_:

; 1368 :         }
; 1369 : 
; 1370 :         // Check that there is a whole IP packet, and that
; 1371 :         // the IP packet is no larger than the TUN interface MTU.
; 1372 :         if (iPktVer == 4)

  004e5	83 bc 24 a0 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  004ed	75 3d		 jne	 SHORT $LN15@write_rrh_

; 1373 :         {
; 1374 :             if (iDataLen >= (int)sizeof(IP4FRM))   // Size of a minimal IPv4 header

  004ef	83 7c 24 74 14	 cmp	 DWORD PTR iDataLen$[rsp], 20
  004f4	7c 2c		 jl	 SHORT $LN17@write_rrh_

; 1375 :             {
; 1376 :                 // Calculate the IPv4 packet length.
; 1377 :                 FETCH_HW( uPayLen, pIP4FRM->hwTotalLength );

  004f6	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR pIP4FRM$[rsp]
  004fe	48 83 c0 02	 add	 rax, 2
  00502	48 8b c8	 mov	 rcx, rax
  00505	e8 00 00 00 00	 call	 fetch_hw_noswap
  0050a	0f b7 c8	 movzx	 ecx, ax
  0050d	e8 00 00 00 00	 call	 _byteswap_ushort
  00512	66 89 44 24 7c	 mov	 WORD PTR uPayLen$[rsp], ax

; 1378 :                 iPktLen = uPayLen;

  00517	0f b7 44 24 7c	 movzx	 eax, WORD PTR uPayLen$[rsp]
  0051c	89 44 24 78	 mov	 DWORD PTR iPktLen$[rsp], eax

; 1379 :             }

  00520	eb 08		 jmp	 SHORT $LN18@write_rrh_
$LN17@write_rrh_:

; 1380 :             else
; 1381 :             {
; 1382 :                 iPktLen = -1;

  00522	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR iPktLen$[rsp], -1
$LN18@write_rrh_:

; 1383 :             }
; 1384 :         }

  0052a	eb 3f		 jmp	 SHORT $LN16@write_rrh_
$LN15@write_rrh_:

; 1385 :         else
; 1386 :         {
; 1387 :             if (iDataLen >= (int)sizeof(IP6FRM))   // Size of an IPv6 header

  0052c	83 7c 24 74 28	 cmp	 DWORD PTR iDataLen$[rsp], 40 ; 00000028H
  00531	7c 30		 jl	 SHORT $LN19@write_rrh_

; 1388 :             {
; 1389 :                 // Calculate the IPv6 packet length.
; 1390 :                 FETCH_HW( uPayLen, pIP6FRM->bPayloadLength );

  00533	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pIP6FRM$[rsp]
  0053b	48 83 c0 04	 add	 rax, 4
  0053f	48 8b c8	 mov	 rcx, rax
  00542	e8 00 00 00 00	 call	 fetch_hw_noswap
  00547	0f b7 c8	 movzx	 ecx, ax
  0054a	e8 00 00 00 00	 call	 _byteswap_ushort
  0054f	66 89 44 24 7c	 mov	 WORD PTR uPayLen$[rsp], ax

; 1391 :                 iPktLen = sizeof(IP6FRM) + uPayLen;

  00554	0f b7 44 24 7c	 movzx	 eax, WORD PTR uPayLen$[rsp]
  00559	48 83 c0 28	 add	 rax, 40			; 00000028H
  0055d	89 44 24 78	 mov	 DWORD PTR iPktLen$[rsp], eax

; 1392 :             }

  00561	eb 08		 jmp	 SHORT $LN20@write_rrh_
$LN19@write_rrh_:

; 1393 :             else
; 1394 :             {
; 1395 :                 iPktLen = -1;

  00563	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR iPktLen$[rsp], -1
$LN20@write_rrh_:
$LN16@write_rrh_:

; 1396 :             }
; 1397 :         }
; 1398 :         if (iPktLen > iDataLen || iPktLen == -1)

  0056b	8b 44 24 74	 mov	 eax, DWORD PTR iDataLen$[rsp]
  0056f	39 44 24 78	 cmp	 DWORD PTR iPktLen$[rsp], eax
  00573	7f 0b		 jg	 SHORT $LN22@write_rrh_
  00575	83 7c 24 78 ff	 cmp	 DWORD PTR iPktLen$[rsp], -1
  0057a	0f 85 c8 01 00
	00		 jne	 $LN21@write_rrh_
$LN22@write_rrh_:

; 1399 :         {
; 1400 :             // HHC03934 "%1d:%04X PTP: Accept data for device '%s' contains incomplete IP packet, data dropped"
; 1401 :             WRMSG(HHC03934, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00580	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00588	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  0058e	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv235[rsp], rax
  00596	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0059e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  005a2	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv238[rsp], ecx
  005a9	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  005b1	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  005b5	d1 fa		 sar	 edx, 1
  005b7	89 94 24 d0 00
	00 00		 mov	 DWORD PTR tv242[rsp], edx
  005be	b9 01 00 00 00	 mov	 ecx, 1
  005c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005c9	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv235[rsp]
  005d1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005d6	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv238[rsp]
  005dd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005e1	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv242[rsp]
  005e8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170576
  005f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170577
  005ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00604	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00609	41 b9 03 00 00
	00		 mov	 r9d, 3
  0060f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170578
  00616	ba 7a 05 00 00	 mov	 edx, 1402		; 0000057aH
  0061b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170579
  00622	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1402 :                                  pPTPBLK->szTUNIfName );
; 1403 :             iTraceLen = iDataLen;

  00628	8b 44 24 74	 mov	 eax, DWORD PTR iDataLen$[rsp]
  0062c	89 44 24 70	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1404 :             if (iTraceLen > 128)

  00630	81 7c 24 70 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  00638	0f 8e c4 00 00
	00		 jle	 $LN23@write_rrh_

; 1405 :             {
; 1406 :                 iTraceLen = 128;

  0063e	c7 44 24 70 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 1407 :                 // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1408 :                 WRMSG(HHC00980, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00646	8b 44 24 70	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  0064a	8b 4c 24 74	 mov	 ecx, DWORD PTR iDataLen$[rsp]
  0064e	2b c8		 sub	 ecx, eax
  00650	8b c1		 mov	 eax, ecx
  00652	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv254[rsp], eax
  00659	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00661	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00665	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv260[rsp], ecx
  0066c	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00674	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00678	d1 fa		 sar	 edx, 1
  0067a	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv264[rsp], edx
  00681	b9 01 00 00 00	 mov	 ecx, 1
  00686	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0068c	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv254[rsp]
  00693	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00697	8b 4c 24 70	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  0069b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0069f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006a7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  006ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006b0	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv260[rsp]
  006b7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006bb	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv264[rsp]
  006c2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170581
  006cd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170582
  006d9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e3	41 b9 03 00 00
	00		 mov	 r9d, 3
  006e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170583
  006f0	ba 81 05 00 00	 mov	 edx, 1409		; 00000581H
  006f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170584
  006fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@write_rrh_:

; 1409 :                                      iTraceLen, iDataLen - iTraceLen );
; 1410 :             }
; 1411 :             net_data_trace( pDEVBLK, pData, iTraceLen, FROM_GUEST, 'I', "data", 0 );

  00702	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0070a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170585
  00711	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00716	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  0071b	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0071e	44 8b 44 24 70	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  00723	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pData$[rsp]
  0072b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00733	e8 00 00 00 00	 call	 net_data_trace

; 1412 :             rv = -2;

  00738	c7 84 24 80 00
	00 00 fe ff ff
	ff		 mov	 DWORD PTR rv$[rsp], -2

; 1413 :             break;

  00743	e9 c4 04 00 00	 jmp	 $LN6@write_rrh_
$LN21@write_rrh_:

; 1414 :         }
; 1415 :         if (iPktLen > pPTPBLK->iMTU)

  00748	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00750	8b 80 d4 02 00
	00		 mov	 eax, DWORD PTR [rax+724]
  00756	39 44 24 78	 cmp	 DWORD PTR iPktLen$[rsp], eax
  0075a	0f 8e c8 01 00
	00		 jle	 $LN24@write_rrh_

; 1416 :         {
; 1417 :             // HHC03935 "%1d:%04X PTP: Accept data for device '%s' contains IP packet larger than MTU, data dropped"
; 1418 :             WRMSG(HHC03935, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  00760	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00768	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  0076e	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv284[rsp], rax
  00776	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0077e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00782	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR tv287[rsp], ecx
  00789	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00791	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00795	d1 fa		 sar	 edx, 1
  00797	89 94 24 e4 00
	00 00		 mov	 DWORD PTR tv291[rsp], edx
  0079e	b9 01 00 00 00	 mov	 ecx, 1
  007a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007a9	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv284[rsp]
  007b1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007b6	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  007bd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007c1	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  007c8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170587
  007d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170588
  007df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  007ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170589
  007f6	ba 8b 05 00 00	 mov	 edx, 1419		; 0000058bH
  007fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170590
  00802	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1419 :                                  pPTPBLK->szTUNIfName );
; 1420 :             iTraceLen = iDataLen;

  00808	8b 44 24 74	 mov	 eax, DWORD PTR iDataLen$[rsp]
  0080c	89 44 24 70	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1421 :             if (iTraceLen > 128)

  00810	81 7c 24 70 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  00818	0f 8e c4 00 00
	00		 jle	 $LN25@write_rrh_

; 1422 :             {
; 1423 :                 iTraceLen = 128;

  0081e	c7 44 24 70 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 1424 :                 // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1425 :                 WRMSG(HHC00980, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00826	8b 44 24 70	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  0082a	8b 4c 24 74	 mov	 ecx, DWORD PTR iDataLen$[rsp]
  0082e	2b c8		 sub	 ecx, eax
  00830	8b c1		 mov	 eax, ecx
  00832	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv303[rsp], eax
  00839	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00841	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00845	89 8c 24 ec 00
	00 00		 mov	 DWORD PTR tv309[rsp], ecx
  0084c	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00854	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00858	d1 fa		 sar	 edx, 1
  0085a	89 94 24 f0 00
	00 00		 mov	 DWORD PTR tv313[rsp], edx
  00861	b9 01 00 00 00	 mov	 ecx, 1
  00866	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0086c	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv303[rsp]
  00873	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00877	8b 4c 24 70	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  0087b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0087f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00887	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0088b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00890	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv309[rsp]
  00897	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0089b	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv313[rsp]
  008a2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170592
  008ad	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170593
  008b9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008c3	41 b9 03 00 00
	00		 mov	 r9d, 3
  008c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170594
  008d0	ba 92 05 00 00	 mov	 edx, 1426		; 00000592H
  008d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170595
  008dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@write_rrh_:

; 1426 :                                      iTraceLen, iDataLen - iTraceLen );
; 1427 :             }
; 1428 :             net_data_trace( pDEVBLK, pData, iTraceLen, FROM_GUEST, 'I', "data", 0 );

  008e2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  008ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170596
  008f1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008f6	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  008fb	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  008fe	44 8b 44 24 70	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  00903	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pData$[rsp]
  0090b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00913	e8 00 00 00 00	 call	 net_data_trace

; 1429 :             rv = -2;

  00918	c7 84 24 80 00
	00 00 fe ff ff
	ff		 mov	 DWORD PTR rv$[rsp], -2

; 1430 :             break;

  00923	e9 e4 02 00 00	 jmp	 $LN6@write_rrh_
$LN24@write_rrh_:

; 1431 :         }
; 1432 : 
; 1433 :         // Check whether the TUN interface is ready for the IP packet.
; 1434 :         fWantPkt = TRUE;

  00928	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fWantPkt$[rsp], 1

; 1435 :         if (iPktVer == 4)

  00933	83 bc 24 a0 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  0093b	75 22		 jne	 SHORT $LN26@write_rrh_

; 1436 :         {
; 1437 :             if (!pPTPBLK->fActive4)

  0093d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00945	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00948	c1 e8 03	 shr	 eax, 3
  0094b	83 e0 01	 and	 eax, 1
  0094e	85 c0		 test	 eax, eax
  00950	75 0b		 jne	 SHORT $LN28@write_rrh_

; 1438 :             {
; 1439 :                 fWantPkt = FALSE;

  00952	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fWantPkt$[rsp], 0
$LN28@write_rrh_:

; 1440 :             }
; 1441 :         }

  0095d	eb 20		 jmp	 SHORT $LN27@write_rrh_
$LN26@write_rrh_:

; 1442 :         else
; 1443 :         {
; 1444 :             if (!pPTPBLK->fActive6)

  0095f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00967	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0096a	c1 e8 04	 shr	 eax, 4
  0096d	83 e0 01	 and	 eax, 1
  00970	85 c0		 test	 eax, eax
  00972	75 0b		 jne	 SHORT $LN29@write_rrh_

; 1445 :             {
; 1446 :                 fWantPkt = FALSE;

  00974	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fWantPkt$[rsp], 0
$LN29@write_rrh_:
$LN27@write_rrh_:

; 1447 :             }
; 1448 :         }
; 1449 : 
; 1450 :         //
; 1451 :         if (fWantPkt)

  0097f	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR fWantPkt$[rsp], 0
  00987	0f 84 44 02 00
	00		 je	 $LN30@write_rrh_

; 1452 :         {
; 1453 :             // Trace the IP packet before sending to TUN interface
; 1454 :             if (pPTPBLK->uDebugMask & DBGPTPPACKET)

  0098d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00995	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00998	83 e0 01	 and	 eax, 1
  0099b	85 c0		 test	 eax, eax
  0099d	0f 84 04 01 00
	00		 je	 $LN31@write_rrh_

; 1455 :             {
; 1456 :                 // HHC00910 "%1d:%04X %s: Send%s packet of size %d bytes to device %s"
; 1457 :                 WRMSG(HHC00910, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  009a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  009ab	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  009b1	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv344[rsp], rax
  009b9	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009c1	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  009c5	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR tv351[rsp], ecx
  009cc	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  009d4	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  009d8	d1 fa		 sar	 edx, 1
  009da	89 94 24 f8 00
	00 00		 mov	 DWORD PTR tv355[rsp], edx
  009e1	b9 01 00 00 00	 mov	 ecx, 1
  009e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009ec	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv344[rsp]
  009f4	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  009f9	8b 4c 24 78	 mov	 ecx, DWORD PTR iPktLen$[rsp]
  009fd	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00a01	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR cPktVer$[rsp]
  00a09	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a0e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a16	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00a1a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a1f	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv351[rsp]
  00a26	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a2a	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv355[rsp]
  00a31	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170603
  00a3c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a41	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170604
  00a48	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a4d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a52	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a58	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170605
  00a5f	ba b2 05 00 00	 mov	 edx, 1458		; 000005b2H
  00a64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170606
  00a6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1458 :                                      cPktVer, iPktLen, pPTPBLK->szTUNIfName );
; 1459 :                 net_data_trace( pDEVBLK, pData, iPktLen, FROM_GUEST, 'D', "packet", 0 );

  00a71	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00a79	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170607
  00a80	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a85	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00a8a	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00a8d	44 8b 44 24 78	 mov	 r8d, DWORD PTR iPktLen$[rsp]
  00a92	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pData$[rsp]
  00a9a	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00aa2	e8 00 00 00 00	 call	 net_data_trace
$LN31@write_rrh_:

; 1460 :             }
; 1461 : 
; 1462 :             // Write the IP packet to the TUN interface
; 1463 :             rv = TUNTAP_Write( pPTPBLK->fd, pData, iPktLen );

  00aa7	44 8b 44 24 78	 mov	 r8d, DWORD PTR iPktLen$[rsp]
  00aac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pData$[rsp]
  00ab4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00abc	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00abf	e8 00 00 00 00	 call	 tt32_write
  00ac4	89 84 24 80 00
	00 00		 mov	 DWORD PTR rv$[rsp], eax

; 1464 :             if (rv < 0)

  00acb	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rv$[rsp], 0
  00ad3	0f 8d f8 00 00
	00		 jge	 $LN32@write_rrh_

; 1465 :             {
; 1466 :                 // HHC00911 "%1d:%04X %s: error writing to device %s: %d %s"
; 1467 :                 WRMSG(HHC00911, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00ad9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00adf	8b 08		 mov	 ecx, DWORD PTR [rax]
  00ae1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ae7	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv379[rsp], rax
  00aef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00af5	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv383[rsp], rax
  00afd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00b05	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00b0c	48 89 8c 24 60
	01 00 00	 mov	 QWORD PTR tv417[rsp], rcx
  00b14	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00b1c	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00b20	89 94 24 fc 00
	00 00		 mov	 DWORD PTR tv422[rsp], edx
  00b27	48 8b bc 24 a0
	01 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  00b2f	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00b33	d1 ff		 sar	 edi, 1
  00b35	b9 01 00 00 00	 mov	 ecx, 1
  00b3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b40	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv379[rsp]
  00b48	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00b4d	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv383[rsp]
  00b55	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00b57	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00b5b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv417[rsp]
  00b63	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b68	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00b70	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00b74	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b79	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv422[rsp]
  00b80	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b84	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00b88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170609
  00b8f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170610
  00b9b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ba0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ba5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170611
  00bb2	ba bc 05 00 00	 mov	 edx, 1468		; 000005bcH
  00bb7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170612
  00bbe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1468 :                         pPTPBLK->szTUNIfName, errno, strerror( errno ) );
; 1469 :                 rv = -3;

  00bc4	c7 84 24 80 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR rv$[rsp], -3

; 1470 :                 break;

  00bcf	eb 3b		 jmp	 SHORT $LN6@write_rrh_
$LN32@write_rrh_:
$LN30@write_rrh_:

; 1471 :             }
; 1472 :         }
; 1473 : 
; 1474 :         rv = 0;

  00bd1	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rv$[rsp], 0

; 1475 : 
; 1476 :         // Point to the next IP packet, if there is one.
; 1477 :         pData += iPktLen;

  00bdc	48 63 44 24 78	 movsxd	 rax, DWORD PTR iPktLen$[rsp]
  00be1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pData$[rsp]
  00be9	48 03 c8	 add	 rcx, rax
  00bec	48 8b c1	 mov	 rax, rcx
  00bef	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pData$[rsp], rax

; 1478 :         iDataLen -= iPktLen;

  00bf7	8b 44 24 78	 mov	 eax, DWORD PTR iPktLen$[rsp]
  00bfb	8b 4c 24 74	 mov	 ecx, DWORD PTR iDataLen$[rsp]
  00bff	2b c8		 sub	 ecx, eax
  00c01	8b c1		 mov	 eax, ecx
  00c03	89 44 24 74	 mov	 DWORD PTR iDataLen$[rsp], eax

; 1479 : 
; 1480 :     }   /* while( iDataLen > 0 ) */

  00c07	e9 7c f6 ff ff	 jmp	 $LN5@write_rrh_
$LN6@write_rrh_:

; 1481 : 
; 1482 :     // Free the data buffer, if one was used.
; 1483 :     if (pDataBuf)

  00c0c	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR pDataBuf$[rsp], 0
  00c15	74 0e		 je	 SHORT $LN33@write_rrh_

; 1484 :         free( pDataBuf );

  00c17	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pDataBuf$[rsp]
  00c1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN33@write_rrh_:

; 1485 : 
; 1486 :     return rv;

  00c25	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp]
$LN1@write_rrh_:

; 1487 : }   /* End function  write_rrh_8108() */

  00c2c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c34	48 33 cc	 xor	 rcx, rsp
  00c37	e8 00 00 00 00	 call	 __security_check_cookie
  00c3c	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  00c43	5f		 pop	 rdi
  00c44	5e		 pop	 rsi
  00c45	c3		 ret	 0
write_rrh_8108 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
rv$ = 80
pMPC_RRH$ = 88
iWhat$ = 96
tv134 = 100
tv181 = 104
uNumRRH$ = 108
iForRRH$ = 112
pMPC_TH$ = 120
uOffRRH$ = 128
tv153 = 132
tv157 = 136
pDEVBLK$ = 160
uCount$ = 168
iCCWSeq$ = 176
pIOBuf$ = 184
pMore$ = 192
pUnitStat$ = 200
pResidual$ = 208
write_th PROC

; 1102 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1103 : 
; 1104 : //  PTPATH*    pPTPATH   = pDEVBLK->dev_data;
; 1105 : //  PTPBLK*    pPTPBLK   = pPTPATH->pPTPBLK;
; 1106 :     MPC_TH*    pMPC_TH   = (MPC_TH*)pIOBuf;     // MPC_TH at start of IObuf

  0001a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  00022	48 89 44 24 78	 mov	 QWORD PTR pMPC_TH$[rsp], rax

; 1107 :     MPC_RRH*   pMPC_RRH  = NULL;                // MPC_RRH

  00027	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR pMPC_RRH$[rsp], 0

; 1108 :     int        iForRRH;
; 1109 :     U32        uOffRRH;
; 1110 :     U16        uNumRRH;
; 1111 :     int        rv = 0;

  00030	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rv$[rsp], 0
$LN4@write_th:

; 1112 :     int        iWhat;
; 1113 : #define UNKNOWN_RRH   0
; 1114 : #define RRH_8108      1
; 1115 : #define RRH_C108      2
; 1116 : #define RRH_417E      3
; 1117 : #define RRH_C17E      4
; 1118 : 
; 1119 :     UNREFERENCED( uCount  );

  00038	33 c0		 xor	 eax, eax
  0003a	85 c0		 test	 eax, eax
  0003c	75 fa		 jne	 SHORT $LN4@write_th
$LN7@write_th:

; 1120 :     UNREFERENCED( iCCWSeq );

  0003e	33 c0		 xor	 eax, eax
  00040	85 c0		 test	 eax, eax
  00042	75 fa		 jne	 SHORT $LN7@write_th

; 1121 : 
; 1122 : 
; 1123 :     // Get the number of MPC_RRH and the displacement from the start
; 1124 :     // of the MPC_TH to the first (or only) MPC_RRH.
; 1125 :     FETCH_HW( uNumRRH, pMPC_TH->numrrh );

  00044	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00049	48 83 c0 12	 add	 rax, 18
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 fetch_hw_noswap
  00055	0f b7 c8	 movzx	 ecx, ax
  00058	e8 00 00 00 00	 call	 _byteswap_ushort
  0005d	66 89 44 24 6c	 mov	 WORD PTR uNumRRH$[rsp], ax

; 1126 :     FETCH_FW( uOffRRH, pMPC_TH->offrrh );

  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00067	48 83 c0 08	 add	 rax, 8
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00073	8b c8		 mov	 ecx, eax
  00075	e8 00 00 00 00	 call	 _byteswap_ulong
  0007a	89 84 24 80 00
	00 00		 mov	 DWORD PTR uOffRRH$[rsp], eax

; 1127 : 
; 1128 :     // Process each of the MPC_RRHs.
; 1129 :     for( iForRRH = 1; iForRRH <= uNumRRH; iForRRH++ )

  00081	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR iForRRH$[rsp], 1
  00089	eb 0a		 jmp	 SHORT $LN10@write_th
$LN8@write_th:
  0008b	8b 44 24 70	 mov	 eax, DWORD PTR iForRRH$[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 44 24 70	 mov	 DWORD PTR iForRRH$[rsp], eax
$LN10@write_th:
  00095	0f b7 44 24 6c	 movzx	 eax, WORD PTR uNumRRH$[rsp]
  0009a	39 44 24 70	 cmp	 DWORD PTR iForRRH$[rsp], eax
  0009e	0f 8f 2c 02 00
	00		 jg	 $LN9@write_th

; 1130 :     {
; 1131 : 
; 1132 :         // Point to the first or subsequent MPC_RRH.
; 1133 :         pMPC_RRH = (MPC_RRH*)((BYTE*)pMPC_TH + uOffRRH);

  000a4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR uOffRRH$[rsp]
  000ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  000b0	48 03 c8	 add	 rcx, rax
  000b3	48 8b c1	 mov	 rax, rcx
  000b6	48 89 44 24 58	 mov	 QWORD PTR pMPC_RRH$[rsp], rax

; 1134 : 
; 1135 :         // Decide what the RRH contains.
; 1136 :         iWhat = UNKNOWN_RRH;

  000bb	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 0

; 1137 :         if (pMPC_RRH->type == RRH_TYPE_CM)

  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000c8	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000cc	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  000d1	75 18		 jne	 SHORT $LN15@write_th

; 1138 :         {
; 1139 :             if (pMPC_RRH->proto == PROTOCOL_LAYER2)

  000d3	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000d8	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000dc	83 f8 08	 cmp	 eax, 8
  000df	75 08		 jne	 SHORT $LN17@write_th

; 1140 :             {
; 1141 :                 iWhat = RRH_8108;

  000e1	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 1
$LN17@write_th:

; 1142 :             }
; 1143 :         }

  000e9	eb 64		 jmp	 SHORT $LN16@write_th
$LN15@write_th:

; 1144 :         else if (pMPC_RRH->type == RRH_TYPE_ULP)

  000eb	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000f0	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000f4	83 f8 41	 cmp	 eax, 65			; 00000041H
  000f7	75 18		 jne	 SHORT $LN18@write_th

; 1145 :         {
; 1146 :             if (pMPC_RRH->proto == PROTOCOL_UNKNOWN)

  000f9	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000fe	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00102	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00105	75 08		 jne	 SHORT $LN20@write_th

; 1147 :             {
; 1148 :                 iWhat = RRH_417E;

  00107	c7 44 24 60 03
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 3
$LN20@write_th:

; 1149 :             }
; 1150 :         }

  0010f	eb 3e		 jmp	 SHORT $LN19@write_th
$LN18@write_th:

; 1151 :         else if (pMPC_RRH->type == RRH_TYPE_IPA)

  00111	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00116	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0011a	3d c1 00 00 00	 cmp	 eax, 193		; 000000c1H
  0011f	75 2e		 jne	 SHORT $LN21@write_th

; 1152 :         {
; 1153 :             if (pMPC_RRH->proto == PROTOCOL_LAYER2)

  00121	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00126	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0012a	83 f8 08	 cmp	 eax, 8
  0012d	75 0a		 jne	 SHORT $LN22@write_th

; 1154 :             {
; 1155 :                 iWhat = RRH_C108;

  0012f	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 2

; 1156 :             }

  00137	eb 16		 jmp	 SHORT $LN23@write_th
$LN22@write_th:

; 1157 :             else if (pMPC_RRH->proto == PROTOCOL_UNKNOWN)

  00139	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0013e	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00142	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00145	75 08		 jne	 SHORT $LN24@write_th

; 1158 :             {
; 1159 :                 iWhat = RRH_C17E;

  00147	c7 44 24 60 04
	00 00 00	 mov	 DWORD PTR iWhat$[rsp], 4
$LN24@write_th:
$LN23@write_th:
$LN21@write_th:
$LN19@write_th:
$LN16@write_th:

; 1160 :             }
; 1161 :         }
; 1162 : 
; 1163 :         // Process what the RRH contains.
; 1164 :         switch( iWhat )

  0014f	8b 44 24 60	 mov	 eax, DWORD PTR iWhat$[rsp]
  00153	89 44 24 64	 mov	 DWORD PTR tv134[rsp], eax
  00157	83 7c 24 64 01	 cmp	 DWORD PTR tv134[rsp], 1
  0015c	74 1a		 je	 SHORT $LN25@write_th
  0015e	83 7c 24 64 02	 cmp	 DWORD PTR tv134[rsp], 2
  00163	74 33		 je	 SHORT $LN26@write_th
  00165	83 7c 24 64 03	 cmp	 DWORD PTR tv134[rsp], 3
  0016a	74 4c		 je	 SHORT $LN27@write_th
  0016c	83 7c 24 64 04	 cmp	 DWORD PTR tv134[rsp], 4
  00171	74 65		 je	 SHORT $LN28@write_th
  00173	e9 80 00 00 00	 jmp	 $LN29@write_th
$LN25@write_th:

; 1165 :         {
; 1166 : 
; 1167 :         // IP packets
; 1168 :         case RRH_8108:
; 1169 :             rv = write_rrh_8108( pDEVBLK, pMPC_TH, pMPC_RRH );

  00178	4c 8b 44 24 58	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  0017d	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  00182	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0018a	e8 00 00 00 00	 call	 write_rrh_8108
  0018f	89 44 24 50	 mov	 DWORD PTR rv$[rsp], eax

; 1170 :             break;

  00193	e9 0f 01 00 00	 jmp	 $LN11@write_th
$LN26@write_th:

; 1171 : 
; 1172 :         // Exchange IP information
; 1173 :         case RRH_C108:
; 1174 :             rv = write_rrh_C108( pDEVBLK, pMPC_TH, pMPC_RRH );

  00198	4c 8b 44 24 58	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  0019d	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  001a2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001aa	e8 00 00 00 00	 call	 write_rrh_C108
  001af	89 44 24 50	 mov	 DWORD PTR rv$[rsp], eax

; 1175 :             break;

  001b3	e9 ef 00 00 00	 jmp	 $LN11@write_th
$LN27@write_th:

; 1176 : 
; 1177 :         // Establish connections
; 1178 :         case RRH_417E:
; 1179 :             rv = write_rrh_417E( pDEVBLK, pMPC_TH, pMPC_RRH );

  001b8	4c 8b 44 24 58	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  001bd	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  001c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001ca	e8 00 00 00 00	 call	 write_rrh_417E
  001cf	89 44 24 50	 mov	 DWORD PTR rv$[rsp], eax

; 1180 :             break;

  001d3	e9 cf 00 00 00	 jmp	 $LN11@write_th
$LN28@write_th:

; 1181 : 
; 1182 :         //
; 1183 :         case RRH_C17E:
; 1184 :             rv = write_rrh_C17E( pDEVBLK, pMPC_TH, pMPC_RRH );

  001d8	4c 8b 44 24 58	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  001dd	48 8b 54 24 78	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  001e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001ea	e8 00 00 00 00	 call	 write_rrh_C17E
  001ef	89 44 24 50	 mov	 DWORD PTR rv$[rsp], eax

; 1185 :             break;

  001f3	e9 af 00 00 00	 jmp	 $LN11@write_th
$LN29@write_th:

; 1186 : 
; 1187 :         // Unknown RRH
; 1188 :         default:
; 1189 :             // HHC03936 "%1d:%04X PTP: Accept data contains unknown %s"
; 1190 :             WRMSG(HHC03936, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "RRH" );

  001f8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00200	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00204	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv153[rsp], eax
  0020b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00213	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00217	d1 f9		 sar	 ecx, 1
  00219	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv157[rsp], ecx
  00220	b9 01 00 00 00	 mov	 ecx, 1
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170491
  00232	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00237	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  0023e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00242	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv157[rsp]
  00249	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0024d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170492
  00254	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00259	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170493
  00260	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00265	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00270	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170494
  00277	ba a6 04 00 00	 mov	 edx, 1190		; 000004a6H
  0027c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170495
  00283	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1191 :             mpc_display_rrh( pDEVBLK, pMPC_RRH, FROM_GUEST );

  00289	41 b0 3c	 mov	 r8b, 60			; 0000003cH
  0028c	48 8b 54 24 58	 mov	 rdx, QWORD PTR pMPC_RRH$[rsp]
  00291	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_rrh

; 1192 :             rv = -2;

  0029f	c7 44 24 50 fe
	ff ff ff	 mov	 DWORD PTR rv$[rsp], -2
$LN11@write_th:

; 1193 :             break;
; 1194 : 
; 1195 :         }
; 1196 : 
; 1197 :         // If the MPC_RRH processing was not sucessful, let's stop.
; 1198 :         if (rv != 0)

  002a7	83 7c 24 50 00	 cmp	 DWORD PTR rv$[rsp], 0
  002ac	74 02		 je	 SHORT $LN30@write_th

; 1199 :             break;

  002ae	eb 20		 jmp	 SHORT $LN9@write_th
$LN30@write_th:

; 1200 : 
; 1201 :         // Get the displacement from the start of the MPC_TH to the
; 1202 :         // next MPC_RRH. pMPC_RRH->offrrh will contain zero if this
; 1203 :         // is the last MPC_RRH.
; 1204 :         FETCH_FW( uOffRRH, pMPC_RRH->offrrh );

  002b0	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  002b5	48 8b c8	 mov	 rcx, rax
  002b8	e8 00 00 00 00	 call	 fetch_fw_noswap
  002bd	8b c8		 mov	 ecx, eax
  002bf	e8 00 00 00 00	 call	 _byteswap_ulong
  002c4	89 84 24 80 00
	00 00		 mov	 DWORD PTR uOffRRH$[rsp], eax

; 1205 : 
; 1206 :     }

  002cb	e9 bb fd ff ff	 jmp	 $LN8@write_th
$LN9@write_th:

; 1207 : 
; 1208 :     // Set the residual byte count and unit status depending on
; 1209 :     // whether the MPC_RRHs have been processed sucessfully or not.
; 1210 :     switch( rv )

  002d0	8b 44 24 50	 mov	 eax, DWORD PTR rv$[rsp]
  002d4	89 44 24 68	 mov	 DWORD PTR tv181[rsp], eax
  002d8	83 7c 24 68 fd	 cmp	 DWORD PTR tv181[rsp], -3
  002dd	74 3d		 je	 SHORT $LN34@write_th
  002df	83 7c 24 68 fe	 cmp	 DWORD PTR tv181[rsp], -2
  002e4	74 10		 je	 SHORT $LN33@write_th
  002e6	83 7c 24 68 ff	 cmp	 DWORD PTR tv181[rsp], -1
  002eb	74 09		 je	 SHORT $LN32@write_th
  002ed	83 7c 24 68 00	 cmp	 DWORD PTR tv181[rsp], 0
  002f2	74 02		 je	 SHORT $LN31@write_th
  002f4	eb 4a		 jmp	 SHORT $LN13@write_th
$LN31@write_th:
$LN32@write_th:
$LN33@write_th:

; 1211 :     {
; 1212 : 
; 1213 :     //    0   Successful
; 1214 :     //        All of the accepted data was sucessfully processed.
; 1215 :     //   -1   No storage available
; 1216 :     //   -2   Data problem (i.e. incomplete IP packet)
; 1217 :     //        None of the accepted data was sucessfully processed,
; 1218 :     //        or some of the accepted data may have been sucessfully
; 1219 :     //        processed. Either way there is some data that was not
; 1220 :     //        sucessfully processed, and it will now be dropped as
; 1221 :     //        though it never existed. Inform the guest that the
; 1222 :     //        data was sucessfully processed.
; 1223 :     case  0:
; 1224 :     case -1:
; 1225 :     case -2:
; 1226 :         *pMore     = 0;

  002f6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  002fe	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1227 :         *pResidual = 0;

  00301	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00309	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1228 :         *pUnitStat = CSW_CE | CSW_DE;

  0030f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00317	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1229 :         break;

  0031a	eb 24		 jmp	 SHORT $LN13@write_th
$LN34@write_th:

; 1230 : 
; 1231 :     //   -3   The TUNTAP_Write failed
; 1232 :     //        Hmm...
; 1233 :     case -3:
; 1234 :         pDEVBLK->sense[0] = SENSE_EC;

  0031c	b8 01 00 00 00	 mov	 eax, 1
  00321	48 6b c0 00	 imul	 rax, rax, 0
  00325	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0032d	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 1235 :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  00335	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0033d	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN13@write_th:

; 1236 :         break;
; 1237 : 
; 1238 :     }
; 1239 : 
; 1240 :     return;
; 1241 : }   /* End function  write_th() */

  00340	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00347	c3		 ret	 0
write_th ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
iTraceLen$ = 96
pPTPHX0$ = 104
tv78 = 112
tv82 = 116
tv94 = 120
tv132 = 124
tv136 = 128
uFirst4$ = 132
tv163 = 136
tv167 = 140
tv236 = 144
tv240 = 148
tv255 = 152
tv261 = 156
tv265 = 160
pPTPBLK$ = 168
pMPC_TH$ = 176
pPTPHX2$ = 184
pPTPATH$ = 192
pDEVBLK$ = 224
uCount$ = 232
iCCWSeq$ = 240
pIOBuf$ = 248
pMore$ = 256
pUnitStat$ = 264
pResidual$ = 272
ptp_write PROC

; 986  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 987  :     PTPATH*    pPTPATH  = pDEVBLK->dev_data;

  0001a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00022	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00029	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 988  :     PTPBLK*    pPTPBLK  = pPTPATH->pPTPBLK;

  00031	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 989  :     MPC_TH*    pMPC_TH  = (MPC_TH*)pIOBuf;

  00044	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  0004c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pMPC_TH$[rsp], rax

; 990  :     PTPHX0*    pPTPHX0  = (PTPHX0*)pIOBuf;

  00054	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  0005c	48 89 44 24 68	 mov	 QWORD PTR pPTPHX0$[rsp], rax

; 991  :     PTPHX2*    pPTPHX2  = (PTPHX2*)pIOBuf;

  00061	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  00069	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pPTPHX2$[rsp], rax

; 992  : 
; 993  :     int        iTraceLen;
; 994  :     U32        uFirst4;
; 995  : 
; 996  : 
; 997  :     // Get the first 4-bytes of what was writen by the guest.
; 998  :     FETCH_FW( uFirst4, pMPC_TH->first4 );

  00071	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00079	48 8b c8	 mov	 rcx, rax
  0007c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00081	8b c8		 mov	 ecx, eax
  00083	e8 00 00 00 00	 call	 _byteswap_ulong
  00088	89 84 24 84 00
	00 00		 mov	 DWORD PTR uFirst4$[rsp], eax

; 999  : 
; 1000 :     // Display up to 256-bytes of data, if debug is active
; 1001 :     if (pPTPBLK->uDebugMask & DBGPTPDATA)

  0008f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00097	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0009a	83 e0 02	 and	 eax, 2
  0009d	85 c0		 test	 eax, eax
  0009f	0f 84 9f 01 00
	00		 je	 $LN2@ptp_write

; 1002 :     {
; 1003 :         // HHC00981 "%1d:%04X %s: Accept data of size %d bytes from guest"
; 1004 :         WRMSG(HHC00981, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,  pDEVBLK->typname, (int)uCount );

  000a5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000ad	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000b1	89 44 24 70	 mov	 DWORD PTR tv78[rsp], eax
  000b5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000bd	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  000c1	d1 f9		 sar	 ecx, 1
  000c3	89 4c 24 74	 mov	 DWORD PTR tv82[rsp], ecx
  000c7	b9 01 00 00 00	 mov	 ecx, 1
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d2	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  000d9	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000dd	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000e5	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000e9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ee	8b 4c 24 70	 mov	 ecx, DWORD PTR tv78[rsp]
  000f2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f6	8b 4c 24 74	 mov	 ecx, DWORD PTR tv82[rsp]
  000fa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170403
  00105	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170404
  00111	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00116	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00121	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170405
  00128	ba ec 03 00 00	 mov	 edx, 1004		; 000003ecH
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170406
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1005 :         iTraceLen = uCount;

  0013a	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR uCount$[rsp]
  00141	89 44 24 60	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1006 :         if (iTraceLen > 256)

  00145	81 7c 24 60 00
	01 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 256 ; 00000100H
  0014d	0f 8e bb 00 00
	00		 jle	 $LN3@ptp_write

; 1007 :         {
; 1008 :             iTraceLen = 256;

  00153	c7 44 24 60 00
	01 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 256 ; 00000100H

; 1009 :             // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1010 :             WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0015b	8b 44 24 60	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  0015f	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  00166	2b c8		 sub	 ecx, eax
  00168	8b c1		 mov	 eax, ecx
  0016a	89 44 24 78	 mov	 DWORD PTR tv94[rsp], eax
  0016e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00176	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0017a	89 4c 24 7c	 mov	 DWORD PTR tv132[rsp], ecx
  0017e	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00186	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0018a	d1 fa		 sar	 edx, 1
  0018c	89 94 24 80 00
	00 00		 mov	 DWORD PTR tv136[rsp], edx
  00193	b9 01 00 00 00	 mov	 ecx, 1
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019e	8b 4c 24 78	 mov	 ecx, DWORD PTR tv94[rsp]
  001a2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  001a6	8b 4c 24 60	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  001aa	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  001ae	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001b6	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001bf	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv132[rsp]
  001c3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001c7	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv136[rsp]
  001ce	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170408
  001d9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170409
  001e5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ef	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170410
  001fc	ba f3 03 00 00	 mov	 edx, 1011		; 000003f3H
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170411
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@ptp_write:

; 1011 :                                  iTraceLen, (int)(uCount - iTraceLen) );
; 1012 :         }
; 1013 :         net_data_trace( pDEVBLK, pIOBuf, iTraceLen, FROM_GUEST, 'D', "data", 0 );

  0020e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00216	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170412
  0021d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00222	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00227	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0022a	44 8b 44 24 60	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  0022f	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  00237	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0023f	e8 00 00 00 00	 call	 net_data_trace
$LN2@ptp_write:

; 1014 :     }
; 1015 : 
; 1016 :     // Process depending on what was writen by the guest.
; 1017 :     if (uCount >= SIZE_TH &&

  00244	83 bc 24 e8 00
	00 00 14	 cmp	 DWORD PTR uCount$[rsp], 20
  0024c	0f 82 37 01 00
	00		 jb	 $LN4@ptp_write
  00252	81 bc 24 84 00
	00 00 00 00 e0
	00		 cmp	 DWORD PTR uFirst4$[rsp], 14680064 ; 00e00000H
  0025d	0f 85 26 01 00
	00		 jne	 $LN4@ptp_write

; 1018 :         uFirst4 == MPC_TH_FIRST4)
; 1019 :     {
; 1020 : 
; 1021 :         // Display TH etc. structured, if debug is active
; 1022 :         if (pPTPBLK->uDebugMask & DBGPTPEXPAND)

  00263	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0026b	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0026e	83 e0 04	 and	 eax, 4
  00271	85 c0		 test	 eax, eax
  00273	0f 84 c0 00 00
	00		 je	 $LN6@ptp_write

; 1023 :         {
; 1024 :             // HHC00981 "%1d:%04X %s: Accept data of size %d bytes from guest"
; 1025 :             WRMSG(HHC00981, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,  pDEVBLK->typname,(int)uCount );

  00279	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00281	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00285	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv163[rsp], eax
  0028c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00294	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00298	d1 f9		 sar	 ecx, 1
  0029a	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv167[rsp], ecx
  002a1	b9 01 00 00 00	 mov	 ecx, 1
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ac	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  002b3	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002b7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002bf	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002c3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c8	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv163[rsp]
  002cf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d3	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv167[rsp]
  002da	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170416
  002e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170417
  002f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00301	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170418
  00308	ba 01 04 00 00	 mov	 edx, 1025		; 00000401H
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170419
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1026 :             mpc_display_ptp_th_etc( pDEVBLK, pMPC_TH, FROM_GUEST, 64 );

  0031a	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00320	41 b0 3c	 mov	 r8b, 60			; 0000003cH
  00323	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  0032b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00333	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_ptp_th_etc
$LN6@ptp_write:

; 1027 :         }
; 1028 : 
; 1029 :         // Process the MPC_TH
; 1030 :         write_th( pDEVBLK, uCount, iCCWSeq, pIOBuf, pMore, pUnitStat, pResidual );

  00339	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00341	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00346	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0034e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00353	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  0035b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00360	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  00368	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  00370	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  00377	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0037f	e8 00 00 00 00	 call	 write_th

; 1031 : 
; 1032 :     }

  00384	e9 57 03 00 00	 jmp	 $LN5@ptp_write
$LN4@ptp_write:

; 1033 :     else if (uCount >= SIZE_HX0 &&
; 1034 :              pPTPHX0->TH_seg == 0x00 &&

  00389	83 bc 24 e8 00
	00 00 08	 cmp	 DWORD PTR uCount$[rsp], 8
  00391	72 69		 jb	 SHORT $LN7@ptp_write
  00393	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHX0$[rsp]
  00398	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0039b	85 c0		 test	 eax, eax
  0039d	75 5d		 jne	 SHORT $LN7@ptp_write
  0039f	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHX0$[rsp]
  003a4	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003a8	85 c0		 test	 eax, eax
  003aa	75 50		 jne	 SHORT $LN7@ptp_write

; 1035 :              pPTPHX0->TH_ch_flag == TH_CH_0x00)
; 1036 :     {
; 1037 : 
; 1038 :         // Process the PTPHX0 type 0x00
; 1039 :         write_hx0_00( pDEVBLK, uCount, iCCWSeq, pIOBuf, pMore, pUnitStat, pResidual );

  003ac	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  003b4	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003b9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  003c1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003c6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  003ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d3	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  003db	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  003e3	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  003ea	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003f2	e8 00 00 00 00	 call	 write_hx0_00

; 1040 : 
; 1041 :     }

  003f7	e9 e4 02 00 00	 jmp	 $LN8@ptp_write
$LN7@ptp_write:

; 1042 :     else if (uCount >= SIZE_HX0 &&
; 1043 :              pPTPHX0->TH_seg == 0x00 &&

  003fc	83 bc 24 e8 00
	00 00 08	 cmp	 DWORD PTR uCount$[rsp], 8
  00404	72 6a		 jb	 SHORT $LN9@ptp_write
  00406	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHX0$[rsp]
  0040b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0040e	85 c0		 test	 eax, eax
  00410	75 5e		 jne	 SHORT $LN9@ptp_write
  00412	48 8b 44 24 68	 mov	 rax, QWORD PTR pPTPHX0$[rsp]
  00417	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0041b	83 f8 01	 cmp	 eax, 1
  0041e	75 50		 jne	 SHORT $LN9@ptp_write

; 1044 :              pPTPHX0->TH_ch_flag == TH_CH_0x01)
; 1045 :     {
; 1046 : 
; 1047 :         // Process the PTPHX0 type 0x01
; 1048 :         write_hx0_01( pDEVBLK, uCount, iCCWSeq, pIOBuf, pMore, pUnitStat, pResidual );

  00420	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00428	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0042d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00435	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0043a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00442	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00447	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  0044f	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  00457	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  0045e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00466	e8 00 00 00 00	 call	 write_hx0_01

; 1049 : 
; 1050 :     }

  0046b	e9 70 02 00 00	 jmp	 $LN10@ptp_write
$LN9@ptp_write:

; 1051 :     else if (uCount >= (SIZE_HX2 + SIZE_HSV) &&
; 1052 :              ( pPTPHX2->Ft & XID2_FORMAT_MASK ) == 0x20 &&

  00470	83 bc 24 e8 00
	00 00 45	 cmp	 DWORD PTR uCount$[rsp], 69 ; 00000045H
  00478	0f 82 82 00 00
	00		 jb	 $LN11@ptp_write
  0047e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPHX2$[rsp]
  00486	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00489	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0048e	83 f8 20	 cmp	 eax, 32			; 00000020H
  00491	75 6d		 jne	 SHORT $LN11@ptp_write
  00493	b8 01 00 00 00	 mov	 eax, 1
  00498	48 6b c0 00	 imul	 rax, rax, 0
  0049c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pPTPHX2$[rsp]
  004a4	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  004a9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  004ae	75 50		 jne	 SHORT $LN11@ptp_write

; 1053 :              pPTPHX2->NodeID[0] == 0xFF )
; 1054 :     {
; 1055 : 
; 1056 :         // Process the PTPHX2
; 1057 :         write_hx2( pDEVBLK, uCount, iCCWSeq, pIOBuf, pMore, pUnitStat, pResidual );

  004b0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  004b8	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  004bd	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  004c5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004ca	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  004d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d7	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  004df	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  004e7	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  004ee	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004f6	e8 00 00 00 00	 call	 write_hx2

; 1058 : 
; 1059 :     }

  004fb	e9 e0 01 00 00	 jmp	 $LN12@ptp_write
$LN11@ptp_write:

; 1060 :     else
; 1061 :     {
; 1062 : 
; 1063 :         // HHC03931 "%1d:%04X PTP: Accept data of size %d bytes contains unknown data"
; 1064 :         WRMSG(HHC03931, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, (int)uCount );

  00500	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00508	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0050c	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv236[rsp], eax
  00513	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0051b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0051f	d1 f9		 sar	 ecx, 1
  00521	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv240[rsp], ecx
  00528	b9 01 00 00 00	 mov	 ecx, 1
  0052d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00533	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  0053a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0053e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv236[rsp]
  00545	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00549	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv240[rsp]
  00550	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00554	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170426
  0055b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00560	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170427
  00567	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0056c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00571	41 b9 03 00 00
	00		 mov	 r9d, 3
  00577	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170428
  0057e	ba 28 04 00 00	 mov	 edx, 1064		; 00000428H
  00583	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170429
  0058a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1065 : 
; 1066 :         // Display up to 128-bytes of data, if debug is not active.
; 1067 :         // If debug is active, the data has already been diplayed.
; 1068 :         if (!(pPTPBLK->uDebugMask & DBGPTPDATA))

  00590	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00598	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0059b	83 e0 02	 and	 eax, 2
  0059e	85 c0		 test	 eax, eax
  005a0	0f 85 16 01 00
	00		 jne	 $LN13@ptp_write

; 1069 :         {
; 1070 :             iTraceLen = uCount;

  005a6	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR uCount$[rsp]
  005ad	89 44 24 60	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1071 :             if (iTraceLen > 128)

  005b1	81 7c 24 60 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  005b9	0f 8e c7 00 00
	00		 jle	 $LN14@ptp_write

; 1072 :             {
; 1073 :                 iTraceLen = 128;

  005bf	c7 44 24 60 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 1074 :                 // HHC00980 "%1d:%04X PTP: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1075 :                 WRMSG(HHC00980, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  005c7	8b 44 24 60	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  005cb	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  005d2	2b c8		 sub	 ecx, eax
  005d4	8b c1		 mov	 eax, ecx
  005d6	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv255[rsp], eax
  005dd	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005e5	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  005e9	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv261[rsp], ecx
  005f0	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  005f8	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  005fc	d1 fa		 sar	 edx, 1
  005fe	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv265[rsp], edx
  00605	b9 01 00 00 00	 mov	 ecx, 1
  0060a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00610	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv255[rsp]
  00617	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0061b	8b 4c 24 60	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  0061f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00623	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0062b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0062f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00634	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv261[rsp]
  0063b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0063f	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv265[rsp]
  00646	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0064a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170432
  00651	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00656	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170433
  0065d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00662	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00667	41 b9 03 00 00
	00		 mov	 r9d, 3
  0066d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170434
  00674	ba 34 04 00 00	 mov	 edx, 1076		; 00000434H
  00679	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170435
  00680	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@ptp_write:

; 1076 :                                      iTraceLen, (int)(uCount - iTraceLen) );
; 1077 :             }
; 1078 :             net_data_trace( pDEVBLK, pIOBuf, iTraceLen, FROM_GUEST, 'I', "data", 0 );

  00686	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0068e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170436
  00695	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0069a	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  0069f	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  006a2	44 8b 44 24 60	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  006a7	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  006af	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006b7	e8 00 00 00 00	 call	 net_data_trace
$LN13@ptp_write:

; 1079 :         }
; 1080 : 
; 1081 :         // None of the accepted data was sucessfully processed, and it will
; 1082 :         // now be dropped as though it never existed. Inform the guest that
; 1083 :         // the data was sucessfully processed.
; 1084 :         *pMore     = 0;

  006bc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  006c4	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1085 :         *pResidual = 0;

  006c7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  006cf	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1086 :         *pUnitStat = CSW_CE | CSW_DE;

  006d5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  006dd	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN12@ptp_write:
$LN10@ptp_write:
$LN8@ptp_write:
$LN5@ptp_write:

; 1087 : 
; 1088 :     }
; 1089 : 
; 1090 :     return;
; 1091 : }   /* End function  ptp_write() */

  006e0	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006e7	c3		 ret	 0
ptp_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPBLK$ = 96
pDriveIP4$ = 104
pGuestIP4$ = 112
pDriveIP6$ = 120
pGuestIP6$ = 128
$T1 = 136
pPTPATH$ = 144
tv161 = 152
tv183 = 160
tv200 = 168
filename$ = 176
__$ArrayPad$ = 448
pDEVBLK$ = 480
ppszClass$ = 488
iBufLen$ = 496
pBuffer$ = 504
ptp_query PROC

; 882  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 883  :     char filename[ PATH_MAX + 1 ];      /* full path or just name    */
; 884  : 
; 885  :     PTPATH*   pPTPATH;
; 886  :     PTPBLK*   pPTPBLK;
; 887  :     char*     pGuestIP4;
; 888  :     char*     pDriveIP4;
; 889  : #if defined(ENABLE_IPV6)
; 890  :     char*     pGuestIP6;
; 891  :     char*     pDriveIP6;
; 892  : #endif
; 893  : 
; 894  :     BEGIN_DEVICE_CLASS_QUERY( "CTCA", pDEVBLK, ppszClass, iBufLen, pBuffer );

  0002d	48 83 bc 24 e8
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@ptp_query
  00038	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR ppszClass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170338
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@ptp_query:
  0004a	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@ptp_query
  00055	48 83 bc 24 e8
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@ptp_query
  00060	83 bc 24 f0 01
	00 00 00	 cmp	 DWORD PTR iBufLen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@ptp_query
  0006a	48 83 bc 24 f8
	01 00 00 00	 cmp	 QWORD PTR pBuffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@ptp_query
$LN4@ptp_query:
  00075	e9 33 04 00 00	 jmp	 $LN1@ptp_query
$LN3@ptp_query:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 7e		 je	 SHORT $LN5@ptp_query
  00091	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170344
  000c6	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000ce	e8 00 00 00 00	 call	 strcmp
  000d3	85 c0		 test	 eax, eax
  000d5	75 36		 jne	 SHORT $LN7@ptp_query
  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 6b c0 00	 imul	 rax, rax, 0
  000e0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  000e8	48 81 bc 24 88
	00 00 00 05 01
	00 00		 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000f4	73 02		 jae	 SHORT $LN22@ptp_query
  000f6	eb 05		 jmp	 SHORT $LN23@ptp_query
$LN22@ptp_query:
  000f8	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN23@ptp_query:
  000fd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00105	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@ptp_query:
  0010d	eb 25		 jmp	 SHORT $LN6@ptp_query
$LN5@ptp_query:
  0010f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00117	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0011d	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00123	48 8b d0	 mov	 rdx, rax
  00126	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@ptp_query:

; 895  : 
; 896  :     pPTPATH = pDEVBLK->dev_data;

  00134	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0013c	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00143	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 897  : 
; 898  :     if (!pPTPATH)

  0014b	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pPTPATH$[rsp], 0
  00154	75 25		 jne	 SHORT $LN8@ptp_query

; 899  :     {
; 900  :         strlcpy(pBuffer,"*Uninitialized",iBufLen);

  00156	48 63 84 24 f0
	01 00 00	 movsxd	 rax, DWORD PTR iBufLen$[rsp]
  0015e	4c 8b c0	 mov	 r8, rax
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170346
  00168	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 901  :         return;

  00176	e9 32 03 00 00	 jmp	 $LN1@ptp_query
$LN8@ptp_query:

; 902  :     }
; 903  : 
; 904  :     pPTPBLK = pPTPATH->pPTPBLK;

  0017b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  00183	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00186	48 89 44 24 60	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 905  : 
; 906  :     if (strlen( pPTPBLK->szGuestIPAddr4 ))

  0018b	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00190	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  00196	48 8b c8	 mov	 rcx, rax
  00199	e8 00 00 00 00	 call	 strlen
  0019e	48 85 c0	 test	 rax, rax
  001a1	74 12		 je	 SHORT $LN9@ptp_query

; 907  :        pGuestIP4 = pPTPBLK->szGuestIPAddr4;

  001a3	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001a8	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  001ae	48 89 44 24 70	 mov	 QWORD PTR pGuestIP4$[rsp], rax
  001b3	eb 0c		 jmp	 SHORT $LN10@ptp_query
$LN9@ptp_query:

; 908  :     else
; 909  :        pGuestIP4 = "-";

  001b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170349
  001bc	48 89 44 24 70	 mov	 QWORD PTR pGuestIP4$[rsp], rax
$LN10@ptp_query:

; 910  : 
; 911  :     if (strlen( pPTPBLK->szDriveIPAddr4 ))

  001c1	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001c6	48 05 bc 01 00
	00		 add	 rax, 444		; 000001bcH
  001cc	48 8b c8	 mov	 rcx, rax
  001cf	e8 00 00 00 00	 call	 strlen
  001d4	48 85 c0	 test	 rax, rax
  001d7	74 12		 je	 SHORT $LN11@ptp_query

; 912  :        pDriveIP4 = pPTPBLK->szDriveIPAddr4;

  001d9	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001de	48 05 bc 01 00
	00		 add	 rax, 444		; 000001bcH
  001e4	48 89 44 24 68	 mov	 QWORD PTR pDriveIP4$[rsp], rax
  001e9	eb 0c		 jmp	 SHORT $LN12@ptp_query
$LN11@ptp_query:

; 913  :     else
; 914  :        pDriveIP4 = "-";

  001eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170352
  001f2	48 89 44 24 68	 mov	 QWORD PTR pDriveIP4$[rsp], rax
$LN12@ptp_query:

; 915  : 
; 916  : #if defined(ENABLE_IPV6)
; 917  :     if (strlen( pPTPBLK->szGuestIPAddr6 ))

  001f7	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001fc	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  00202	48 8b c8	 mov	 rcx, rax
  00205	e8 00 00 00 00	 call	 strlen
  0020a	48 85 c0	 test	 rax, rax
  0020d	74 15		 je	 SHORT $LN13@ptp_query

; 918  :        pGuestIP6 = pPTPBLK->szGuestIPAddr6;

  0020f	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00214	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  0021a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pGuestIP6$[rsp], rax
  00222	eb 0f		 jmp	 SHORT $LN14@ptp_query
$LN13@ptp_query:

; 919  :     else
; 920  :        pGuestIP6 = "-";

  00224	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170355
  0022b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pGuestIP6$[rsp], rax
$LN14@ptp_query:

; 921  : 
; 922  :     if (strlen( pPTPBLK->szDriveIPAddr6 ))

  00233	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00238	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  0023e	48 8b c8	 mov	 rcx, rax
  00241	e8 00 00 00 00	 call	 strlen
  00246	48 85 c0	 test	 rax, rax
  00249	74 12		 je	 SHORT $LN15@ptp_query

; 923  :        pDriveIP6 = pPTPBLK->szDriveIPAddr6;

  0024b	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00250	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  00256	48 89 44 24 78	 mov	 QWORD PTR pDriveIP6$[rsp], rax
  0025b	eb 0c		 jmp	 SHORT $LN16@ptp_query
$LN15@ptp_query:

; 924  :     else
; 925  :        pDriveIP6 = "-";

  0025d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170358
  00264	48 89 44 24 78	 mov	 QWORD PTR pDriveIP6$[rsp], rax
$LN16@ptp_query:

; 926  : 
; 927  :     if (pPTPBLK->fIPv4Spec && pPTPBLK->fIPv6Spec)

  00269	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0026e	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00271	83 e0 01	 and	 eax, 1
  00274	85 c0		 test	 eax, eax
  00276	0f 84 cb 00 00
	00		 je	 $LN17@ptp_query
  0027c	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00281	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00284	d1 e8		 shr	 eax, 1
  00286	83 e0 01	 and	 eax, 1
  00289	85 c0		 test	 eax, eax
  0028b	0f 84 b6 00 00
	00		 je	 $LN17@ptp_query

; 928  :     {
; 929  :         snprintf( pBuffer, iBufLen, "%s %s/%s %s/%s (%s)%s IO[%"PRIu64"]",

  00291	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00296	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  0029a	74 11		 je	 SHORT $LN24@ptp_query
  0029c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170361
  002a3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv161[rsp], rax
  002ab	eb 0f		 jmp	 SHORT $LN25@ptp_query
$LN24@ptp_query:
  002ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170362
  002b4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv161[rsp], rax
$LN25@ptp_query:
  002bc	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002c1	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  002c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  002cc	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002d0	48 63 94 24 f0
	01 00 00	 movsxd	 rdx, DWORD PTR iBufLen$[rsp]
  002d8	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  002e0	4d 8b 80 00 06
	00 00		 mov	 r8, QWORD PTR [r8+1536]
  002e7	4c 89 44 24 50	 mov	 QWORD PTR [rsp+80], r8
  002ec	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR tv161[rsp]
  002f4	4c 89 44 24 48	 mov	 QWORD PTR [rsp+72], r8
  002f9	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  002fe	48 8b 44 24 78	 mov	 rax, QWORD PTR pDriveIP6$[rsp]
  00303	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00308	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pGuestIP6$[rsp]
  00310	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00315	48 8b 44 24 68	 mov	 rax, QWORD PTR pDriveIP4$[rsp]
  0031a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0031f	48 8b 44 24 70	 mov	 rax, QWORD PTR pGuestIP4$[rsp]
  00324	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00329	4c 8b 49 50	 mov	 r9, QWORD PTR [rcx+80]
  0032d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170363
  00334	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  0033c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 930  :                   pPTPBLK->pDEVBLKRead->typname,
; 931  :                   pGuestIP4,
; 932  :                   pDriveIP4,
; 933  :                   pGuestIP6,
; 934  :                   pDriveIP6,
; 935  :                   pPTPBLK->szTUNIfName,
; 936  :                   pPTPBLK->uDebugMask ? " -d" : "",
; 937  :                   pDEVBLK->excps );
; 938  :     }

  00342	e9 4f 01 00 00	 jmp	 $LN18@ptp_query
$LN17@ptp_query:

; 939  :     else if (pPTPBLK->fIPv4Spec)

  00347	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0034c	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0034f	83 e0 01	 and	 eax, 1
  00352	85 c0		 test	 eax, eax
  00354	0f 84 9f 00 00
	00		 je	 $LN19@ptp_query

; 940  :     {
; 941  : #endif /* defined(ENABLE_IPV6) */
; 942  :         snprintf( pBuffer, iBufLen, "%s %s/%s (%s)%s IO[%"PRIu64"]",

  0035a	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0035f	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00363	74 11		 je	 SHORT $LN26@ptp_query
  00365	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170366
  0036c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
  00374	eb 0f		 jmp	 SHORT $LN27@ptp_query
$LN26@ptp_query:
  00376	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170367
  0037d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
$LN27@ptp_query:
  00385	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0038a	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  00390	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00395	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00399	48 63 94 24 f0
	01 00 00	 movsxd	 rdx, DWORD PTR iBufLen$[rsp]
  003a1	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  003a9	4d 8b 80 00 06
	00 00		 mov	 r8, QWORD PTR [r8+1536]
  003b0	4c 89 44 24 40	 mov	 QWORD PTR [rsp+64], r8
  003b5	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR tv183[rsp]
  003bd	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  003c2	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003c7	48 8b 44 24 68	 mov	 rax, QWORD PTR pDriveIP4$[rsp]
  003cc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003d1	48 8b 44 24 70	 mov	 rax, QWORD PTR pGuestIP4$[rsp]
  003d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003db	4c 8b 49 50	 mov	 r9, QWORD PTR [rcx+80]
  003df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170368
  003e6	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  003ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 943  :                   pPTPBLK->pDEVBLKRead->typname,
; 944  :                   pGuestIP4,
; 945  :                   pDriveIP4,
; 946  :                   pPTPBLK->szTUNIfName,
; 947  :                   pPTPBLK->uDebugMask ? " -d" : "",
; 948  :                   pDEVBLK->excps );
; 949  : #if defined(ENABLE_IPV6)
; 950  :     }

  003f4	e9 9d 00 00 00	 jmp	 $LN20@ptp_query
$LN19@ptp_query:

; 951  :     else
; 952  :     {
; 953  :         snprintf( pBuffer, iBufLen, "%s %s/%s (%s)%s IO[%"PRIu64"]",

  003f9	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003fe	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00402	74 11		 je	 SHORT $LN28@ptp_query
  00404	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170369
  0040b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv200[rsp], rax
  00413	eb 0f		 jmp	 SHORT $LN29@ptp_query
$LN28@ptp_query:
  00415	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170370
  0041c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv200[rsp], rax
$LN29@ptp_query:
  00424	48 8b 44 24 60	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00429	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  0042f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00434	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00438	48 63 94 24 f0
	01 00 00	 movsxd	 rdx, DWORD PTR iBufLen$[rsp]
  00440	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  00448	4d 8b 80 00 06
	00 00		 mov	 r8, QWORD PTR [r8+1536]
  0044f	4c 89 44 24 40	 mov	 QWORD PTR [rsp+64], r8
  00454	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR tv200[rsp]
  0045c	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  00461	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00466	48 8b 44 24 78	 mov	 rax, QWORD PTR pDriveIP6$[rsp]
  0046b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00470	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pGuestIP6$[rsp]
  00478	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047d	4c 8b 49 50	 mov	 r9, QWORD PTR [rcx+80]
  00481	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170371
  00488	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  00490	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN20@ptp_query:
$LN18@ptp_query:

; 954  :                   pPTPBLK->pDEVBLKRead->typname,
; 955  :                   pGuestIP6,
; 956  :                   pDriveIP6,
; 957  :                   pPTPBLK->szTUNIfName,
; 958  :                   pPTPBLK->uDebugMask ? " -d" : "",
; 959  :                   pDEVBLK->excps );
; 960  :     }
; 961  : #endif /* defined(ENABLE_IPV6) */
; 962  :     pBuffer[iBufLen-1] = '\0';

  00496	8b 84 24 f0 01
	00 00		 mov	 eax, DWORD PTR iBufLen$[rsp]
  0049d	ff c8		 dec	 eax
  0049f	48 98		 cdqe
  004a1	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  004a9	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN1@ptp_query:
$LN21@ptp_query:

; 963  : 
; 964  :     return;
; 965  : }   /* End function  ptp_query() */

  004ad	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004b5	48 33 cc	 xor	 rcx, rsp
  004b8	e8 00 00 00 00	 call	 __security_check_cookie
  004bd	48 81 c4 d8 01
	00 00		 add	 rsp, 472		; 000001d8H
  004c4	c3		 ret	 0
ptp_query ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
tid$1 = 32
pPTPBLK$ = 40
pPTPATH$ = 48
pDEVBLK$ = 80
ptp_close PROC

; 832  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 833  :     PTPATH*   pPTPATH  = pDEVBLK->dev_data;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00015	48 89 44 24 30	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 834  :     PTPBLK*   pPTPBLK  = pPTPATH->pPTPBLK;

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 44 24 28	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 835  : 
; 836  : 
; 837  :     // Close the device file (if not already closed)
; 838  :     if (pPTPBLK->fd >= 0)

  00027	48 8b 44 24 28	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0002c	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00030	7c 43		 jl	 SHORT $LN2@ptp_close

; 839  :     {
; 840  :         // PROGRAMMING NOTE: there's currently no way to interrupt
; 841  :         // the "ptp_read_thread"s TUNTAP_Read of the adapter. Thus
; 842  :         // we must simply wait for ptp_read_thread to eventually
; 843  :         // notice that we're doing a close (via our setting of the
; 844  :         // fCloseInProgress flag). Its TUNTAP_Read will eventually
; 845  :         // timeout after a few seconds (currently 5, which is dif-
; 846  :         // ferent than the PTP_READ_TIMEOUT_SECS timeout value the
; 847  :         // ptp_read function uses) and will then do the close of
; 848  :         // the adapter for us (TUNTAP_Close) so we don't have to.
; 849  :         // All we need to do is ask it to exit (via our setting of
; 850  :         // the fCloseInProgress flag) and then wait for it to exit
; 851  :         // (which, as stated, could take up to a max of 5 seconds).
; 852  : 
; 853  :         // All of this is simply because it's poor form to close a
; 854  :         // device from one thread while another thread is reading
; 855  :         // from it. Attempting to do so could trip a race condition
; 856  :         // wherein the internal i/o buffers used to process the
; 857  :         // read request could have been freed (by the close call)
; 858  :         // by the time the read request eventually gets serviced.
; 859  : 
; 860  :         TID tid = pPTPBLK->tid;

  00032	48 8b 44 24 28	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00037	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0003a	89 44 24 20	 mov	 DWORD PTR tid$1[rsp], eax

; 861  :         pPTPBLK->fCloseInProgress = 1;  // (ask read thread to exit)

  0003e	48 8b 44 24 28	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00043	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00046	83 c8 04	 or	 eax, 4
  00049	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0004e	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 862  : #if defined(_MSVC_)
; 863  :         join_thread( tid, NULL );       // (wait for thread to end)

  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170318
  00058	33 d2		 xor	 edx, edx
  0005a	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$1[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_join_thread

; 864  : #endif
; 865  :         detach_thread( tid );           // (wait for thread to end)

  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170319
  0006b	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$1[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_detach_thread
$LN2@ptp_close:

; 866  :     }
; 867  : 
; 868  :     pDEVBLK->fd = -1;           // indicate we're now closed

  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0007a	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 869  : 
; 870  :     return 0;

  00084	33 c0		 xor	 eax, eax

; 871  : }   /* End function  ptp_close() */

  00086	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008a	c3		 ret	 0
ptp_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
iNum$ = 128
tv138 = 132
tv160 = 136
tv179 = 140
tv78 = 144
tv80 = 148
tv83 = 152
tv85 = 156
tv90 = 160
tv94 = 164
tv198 = 168
tv201 = 172
tv206 = 176
pPTPATH$ = 184
pPTPBLK$ = 192
pDEVBLK$ = 240
bCode$ = 248
bFlags$ = 256
bChained$ = 264
uCount$ = 272
bPrevCode$ = 280
iCCWSeq$ = 288
pIOBuf$ = 296
pMore$ = 304
pUnitStat$ = 312
pResidual$ = 320
ptp_execute_ccw PROC

; 653  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 654  : 
; 655  :     PTPATH*   pPTPATH  = pDEVBLK->dev_data;

  0001c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00024	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0002b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pPTPATH$[rsp], rax

; 656  :     PTPBLK*   pPTPBLK  = pPTPATH->pPTPBLK;

  00033	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pPTPBLK$[rsp], rax
$LN4@ptp_execut:

; 657  :     int       iNum;                          // Number of bytes to move
; 658  : 
; 659  :     UNREFERENCED( bFlags    );

  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 fa		 jne	 SHORT $LN4@ptp_execut
$LN7@ptp_execut:

; 660  :     UNREFERENCED( bChained  );

  0004c	33 c0		 xor	 eax, eax
  0004e	85 c0		 test	 eax, eax
  00050	75 fa		 jne	 SHORT $LN7@ptp_execut
$LN10@ptp_execut:

; 661  :     UNREFERENCED( bPrevCode );

  00052	33 c0		 xor	 eax, eax
  00054	85 c0		 test	 eax, eax
  00056	75 fa		 jne	 SHORT $LN10@ptp_execut

; 662  : 
; 663  : 
; 664  :     // Intervention required if the device file is not open
; 665  :     if (pDEVBLK->fd < 0)

  00058	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00060	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00067	7d 29		 jge	 SHORT $LN13@ptp_execut

; 666  :     {
; 667  :         pDEVBLK->sense[0] = SENSE_IR;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	48 6b c0 00	 imul	 rax, rax, 0
  00072	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0007a	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 668  :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  00082	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0008a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 669  :         return;

  0008d	e9 4f 05 00 00	 jmp	 $LN1@ptp_execut
$LN13@ptp_execut:

; 670  :     }
; 671  : 
; 672  :     // Display various information, maybe
; 673  :     if (pPTPBLK->uDebugMask & DBGPTPCCW)

  00092	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0009a	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0009d	83 e0 20	 and	 eax, 32			; 00000020H
  000a0	85 c0		 test	 eax, eax
  000a2	0f 84 1b 01 00
	00		 je	 $LN14@ptp_execut

; 674  :     {
; 675  :         // HHC03992 "%1d:%04X %s: Code %02X: Flags %02X: Count %08X: Chained %02X: PrevCode %02X: CCWseq %d"
; 676  :         WRMSG(HHC03992, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  000a8	0f b6 84 24 18
	01 00 00	 movzx	 eax, BYTE PTR bPrevCode$[rsp]
  000b0	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv78[rsp], eax
  000b7	0f b6 8c 24 08
	01 00 00	 movzx	 ecx, BYTE PTR bChained$[rsp]
  000bf	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv80[rsp], ecx
  000c6	0f b6 94 24 00
	01 00 00	 movzx	 edx, BYTE PTR bFlags$[rsp]
  000ce	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv83[rsp], edx
  000d5	44 0f b6 84 24
	f8 00 00 00	 movzx	 r8d, BYTE PTR bCode$[rsp]
  000de	44 89 84 24 9c
	00 00 00	 mov	 DWORD PTR tv85[rsp], r8d
  000e6	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR pDEVBLK$[rsp]
  000ee	45 0f b7 49 48	 movzx	 r9d, WORD PTR [r9+72]
  000f3	44 89 8c 24 a0
	00 00 00	 mov	 DWORD PTR tv90[rsp], r9d
  000fb	4c 8b 94 24 f0
	00 00 00	 mov	 r10, QWORD PTR pDEVBLK$[rsp]
  00103	45 0f b7 52 44	 movzx	 r10d, WORD PTR [r10+68]
  00108	41 d1 fa	 sar	 r10d, 1
  0010b	44 89 94 24 a4
	00 00 00	 mov	 DWORD PTR tv94[rsp], r10d
  00113	b9 01 00 00 00	 mov	 ecx, 1
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0011e	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR iCCWSeq$[rsp]
  00125	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00129	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv78[rsp]
  00130	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00134	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv80[rsp]
  0013b	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0013f	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  00146	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0014a	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv83[rsp]
  00151	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00155	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv85[rsp]
  0015c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00160	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00168	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0016c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00171	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv90[rsp]
  00178	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0017c	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv94[rsp]
  00183	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170288
  0018e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170289
  0019a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170290
  001b1	ba a5 02 00 00	 mov	 edx, 677		; 000002a5H
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170291
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@ptp_execut:

; 677  :             bCode, bFlags, uCount, bChained, bPrevCode, iCCWSeq );
; 678  :     }
; 679  : 
; 680  :     // Process depending on CCW bCode
; 681  :     switch (bCode)

  001c3	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  001cb	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv138[rsp], eax
  001d2	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv138[rsp]
  001d9	ff c8		 dec	 eax
  001db	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv138[rsp], eax
  001e2	81 bc 24 84 00
	00 00 e3 00 00
	00		 cmp	 DWORD PTR tv138[rsp], 227 ; 000000e3H
  001ed	0f 87 e4 02 00
	00		 ja	 $LN27@ptp_execut
  001f3	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv138[rsp]
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00202	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN34@ptp_execut[rcx+rax]
  0020a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN35@ptp_execut[rcx+rax*4]
  00211	48 03 c1	 add	 rax, rcx
  00214	ff e0		 jmp	 rax
$LN15@ptp_execut:

; 682  :     {
; 683  :     case 0x01:  // 0MMMMM01  WRITE
; 684  :         //------------------------------------------------------------
; 685  :         // WRITE
; 686  :         //------------------------------------------------------------
; 687  : 
; 688  :         // Return normal status if CCW count is zero
; 689  :         if (uCount == 0)

  00216	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR uCount$[rsp], 0
  0021e	75 10		 jne	 SHORT $LN16@ptp_execut

; 690  :         {
; 691  :             *pUnitStat = CSW_CE | CSW_DE;

  00220	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00228	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 692  :             break;

  0022b	e9 cb 02 00 00	 jmp	 $LN11@ptp_execut
$LN16@ptp_execut:

; 693  :         }
; 694  : 
; 695  :         // Process the Write data
; 696  :         ptp_write( pDEVBLK, uCount, iCCWSeq, pIOBuf, pMore, pUnitStat, pResidual );

  00230	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00238	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0023d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00245	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0024a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00252	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00257	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  0025f	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  00267	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  0026e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00276	e8 00 00 00 00	 call	 ptp_write

; 697  : 
; 698  :         break;

  0027b	e9 7b 02 00 00	 jmp	 $LN11@ptp_execut
$LN17@ptp_execut:

; 699  : 
; 700  :     case 0x02:  // MMMMMM10  READ
; 701  :         /* ---------------------------------------------------------- */
; 702  :         /* READ                                                       */
; 703  :         /* ---------------------------------------------------------- */
; 704  : 
; 705  :         // Process the Read depending on the current State
; 706  :         ptp_read( pDEVBLK, uCount, iCCWSeq, pIOBuf, pMore, pUnitStat, pResidual );

  00280	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00288	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0028d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00295	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0029a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  002a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a7	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR pIOBuf$[rsp]
  002af	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR iCCWSeq$[rsp]
  002b7	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR uCount$[rsp]
  002be	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002c6	e8 00 00 00 00	 call	 ptp_read

; 707  : 
; 708  :         break;

  002cb	e9 2b 02 00 00	 jmp	 $LN11@ptp_execut
$LN18@ptp_execut:

; 709  : 
; 710  :     case 0xE3:  // 11100011  PREPARE
; 711  :         /* ---------------------------------------------------------- */
; 712  :         /* PREPARE                                                    */
; 713  :         /* ---------------------------------------------------------- */
; 714  : 
; 715  :         *pUnitStat = CSW_CE | CSW_DE;

  002d0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  002d8	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 716  : 
; 717  :         break;

  002db	e9 1b 02 00 00	 jmp	 $LN11@ptp_execut
$LN19@ptp_execut:

; 718  : 
; 719  :     case 0x17:  // MMMMM111  CONTROL
; 720  :         /* ---------------------------------------------------------- */
; 721  :         /* CONTROL                                                    */
; 722  :         /* ---------------------------------------------------------- */
; 723  : 
; 724  :         *pUnitStat = CSW_CE | CSW_DE;

  002e0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  002e8	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 725  : 
; 726  :         break;

  002eb	e9 0b 02 00 00	 jmp	 $LN11@ptp_execut
$LN20@ptp_execut:

; 727  : 
; 728  :     case 0x14:  // XXX10100  SENSE COMMAND BYTE
; 729  :         /* ---------------------------------------------------------- */
; 730  :         /* SENSE COMMAND BYTE                                         */
; 731  :         /* ---------------------------------------------------------- */
; 732  : 
; 733  :         // We will assume that we (i.e. the x-side) raised an Attention
; 734  :         // interrupt earlier and that the y-side is determining why.
; 735  :         // Normally this will only occur during the handshke sequence.
; 736  :         // Return CCW opcode, residual byte count and unit status.
; 737  :         *pIOBuf = pPTPATH->bAttnCode;

  002f0	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  002f8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pPTPATH$[rsp]
  00300	0f b6 49 40	 movzx	 ecx, BYTE PTR [rcx+64]
  00304	88 08		 mov	 BYTE PTR [rax], cl

; 738  :         *pResidual = uCount - 1;

  00306	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR uCount$[rsp]
  0030d	ff c8		 dec	 eax
  0030f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00317	89 01		 mov	 DWORD PTR [rcx], eax

; 739  :         *pUnitStat = CSW_CE | CSW_DE;

  00319	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00321	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 740  : 
; 741  :         // Clear the CCW opcode.
; 742  :         pPTPATH->bAttnCode = 0x00;

  00324	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pPTPATH$[rsp]
  0032c	c6 40 40 00	 mov	 BYTE PTR [rax+64], 0

; 743  : 
; 744  :         break;

  00330	e9 c6 01 00 00	 jmp	 $LN11@ptp_execut
$LN21@ptp_execut:

; 745  : 
; 746  :     case 0x04:  // 00000100  SENSE ADAPTOR STATE
; 747  :         /* ---------------------------------------------------------- */
; 748  :         /* SENSE ADAPTER STATE                                        */
; 749  :         /* ---------------------------------------------------------- */
; 750  : 
; 751  :         // Calculate residual byte count
; 752  :         iNum = ( uCount < pDEVBLK->numsense ) ? uCount : pDEVBLK->numsense;

  00335	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0033d	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00343	39 84 24 10 01
	00 00		 cmp	 DWORD PTR uCount$[rsp], eax
  0034a	73 10		 jae	 SHORT $LN30@ptp_execut
  0034c	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR uCount$[rsp]
  00353	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv160[rsp], eax
  0035a	eb 15		 jmp	 SHORT $LN31@ptp_execut
$LN30@ptp_execut:
  0035c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00364	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  0036a	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv160[rsp], eax
$LN31@ptp_execut:
  00371	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv160[rsp]
  00378	89 84 24 80 00
	00 00		 mov	 DWORD PTR iNum$[rsp], eax

; 753  : 
; 754  :         *pResidual = uCount - iNum;

  0037f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR iNum$[rsp]
  00386	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  0038d	2b c8		 sub	 ecx, eax
  0038f	8b c1		 mov	 eax, ecx
  00391	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00399	89 01		 mov	 DWORD PTR [rcx], eax

; 755  : 
; 756  :         if (uCount < pDEVBLK->numsense)

  0039b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003a3	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  003a9	39 84 24 10 01
	00 00		 cmp	 DWORD PTR uCount$[rsp], eax
  003b0	73 0b		 jae	 SHORT $LN22@ptp_execut

; 757  :             *pMore = 1;

  003b2	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  003ba	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN22@ptp_execut:

; 758  : 
; 759  :         // Copy device sense bytes to channel I/O buffer
; 760  :         memcpy( pIOBuf, pDEVBLK->sense, iNum );

  003bd	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR iNum$[rsp]
  003c5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003cd	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  003d4	48 8b bc 24 28
	01 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  003dc	48 8b f1	 mov	 rsi, rcx
  003df	48 8b c8	 mov	 rcx, rax
  003e2	f3 a4		 rep movsb

; 761  : 
; 762  :         // Clear the device sense bytes
; 763  :         memset( pDEVBLK->sense, 0, sizeof(pDEVBLK->sense) );

  003e4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003ec	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  003f2	48 8b f8	 mov	 rdi, rax
  003f5	33 c0		 xor	 eax, eax
  003f7	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  003fc	f3 aa		 rep stosb

; 764  : 
; 765  :         // Return unit status
; 766  :         *pUnitStat = CSW_CE | CSW_DE;

  003fe	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00406	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 767  : 
; 768  :         break;

  00409	e9 ed 00 00 00	 jmp	 $LN11@ptp_execut
$LN23@ptp_execut:

; 769  : 
; 770  :     case 0xE4:  //  11100100  SENSE ID
; 771  :         /* ---------------------------------------------------------- */
; 772  :         /* SENSE ID                                                   */
; 773  :         /* ---------------------------------------------------------- */
; 774  : 
; 775  :         // Calculate residual byte count
; 776  :         iNum = ( uCount < pDEVBLK->numdevid ) ? uCount : pDEVBLK->numdevid;

  0040e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00416	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0041c	39 84 24 10 01
	00 00		 cmp	 DWORD PTR uCount$[rsp], eax
  00423	73 10		 jae	 SHORT $LN32@ptp_execut
  00425	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR uCount$[rsp]
  0042c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
  00433	eb 15		 jmp	 SHORT $LN33@ptp_execut
$LN32@ptp_execut:
  00435	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0043d	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00443	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
$LN33@ptp_execut:
  0044a	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv179[rsp]
  00451	89 84 24 80 00
	00 00		 mov	 DWORD PTR iNum$[rsp], eax

; 777  : 
; 778  :         *pResidual = uCount - iNum;

  00458	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR iNum$[rsp]
  0045f	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR uCount$[rsp]
  00466	2b c8		 sub	 ecx, eax
  00468	8b c1		 mov	 eax, ecx
  0046a	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00472	89 01		 mov	 DWORD PTR [rcx], eax

; 779  : 
; 780  :         if (uCount < pDEVBLK->numdevid)

  00474	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0047c	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00482	39 84 24 10 01
	00 00		 cmp	 DWORD PTR uCount$[rsp], eax
  00489	73 0b		 jae	 SHORT $LN24@ptp_execut

; 781  :             *pMore = 1;

  0048b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00493	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN24@ptp_execut:

; 782  : 
; 783  :         // Copy device identifier bytes to channel I/O buffer
; 784  :         memcpy( pIOBuf, pDEVBLK->devid, iNum );

  00496	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR iNum$[rsp]
  0049e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004a6	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  004ad	48 8b bc 24 28
	01 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  004b5	48 8b f1	 mov	 rsi, rcx
  004b8	48 8b c8	 mov	 rcx, rax
  004bb	f3 a4		 rep movsb

; 785  : 
; 786  :         // Return unit status
; 787  :         *pUnitStat = CSW_CE | CSW_DE;

  004bd	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  004c5	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 788  : 
; 789  :         break;

  004c8	eb 31		 jmp	 SHORT $LN11@ptp_execut
$LN25@ptp_execut:
$LN26@ptp_execut:

; 790  : 
; 791  :     case 0x03:  // M0MMM011  NO OPERATION
; 792  :     case 0xC3:  // 11000011  SET EXTENDED MODE
; 793  :         /* ---------------------------------------------------------- */
; 794  :         /* NO OPERATON & SET EXTENDED MODE                            */
; 795  :         /* ---------------------------------------------------------- */
; 796  : 
; 797  :         // Return unit status
; 798  :         *pUnitStat = CSW_CE | CSW_DE;

  004ca	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  004d2	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 799  : 
; 800  :         break;

  004d5	eb 24		 jmp	 SHORT $LN11@ptp_execut
$LN27@ptp_execut:

; 801  : 
; 802  :     default:
; 803  :         /* ---------------------------------------------------------- */
; 804  :         /* INVALID OPERATION                                          */
; 805  :         /* ---------------------------------------------------------- */
; 806  : 
; 807  :         // Set command reject sense byte, and unit check status
; 808  :         pDEVBLK->sense[0] = SENSE_CR;

  004d7	b8 01 00 00 00	 mov	 eax, 1
  004dc	48 6b c0 00	 imul	 rax, rax, 0
  004e0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004e8	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 809  :         *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  004f0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  004f8	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN11@ptp_execut:

; 810  : 
; 811  :         break;
; 812  : 
; 813  :     }
; 814  : 
; 815  :     // Display various information, maybe
; 816  :     if (pPTPBLK->uDebugMask & DBGPTPCCW)

  004fb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00503	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00506	83 e0 20	 and	 eax, 32			; 00000020H
  00509	85 c0		 test	 eax, eax
  0050b	0f 84 d0 00 00
	00		 je	 $LN28@ptp_execut

; 817  :     {
; 818  :         // HHC03993 "%1d:%04X %s: Status %02X: Residual %08X: More %02X"
; 819  :         WRMSG(HHC03993, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00511	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00519	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0051c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv198[rsp], eax
  00523	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR pUnitStat$[rsp]
  0052b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0052e	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv201[rsp], ecx
  00535	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0053d	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00541	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv206[rsp], edx
  00548	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  00550	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00554	d1 ff		 sar	 edi, 1
  00556	b9 01 00 00 00	 mov	 ecx, 1
  0055b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00561	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  00568	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0056c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00574	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00576	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0057a	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv201[rsp]
  00581	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00585	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0058d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00591	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00596	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  0059d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005a1	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  005a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170306
  005ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170307
  005b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  005c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170308
  005cf	ba 34 03 00 00	 mov	 edx, 820		; 00000334H
  005d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170309
  005db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN28@ptp_execut:
$LN1@ptp_execut:

; 820  :             *pUnitStat, *pResidual, *pMore );
; 821  :     }
; 822  : 
; 823  :     return;
; 824  : }   /* End function  ptp_execute_ccw() */

  005e1	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  005e8	5f		 pop	 rdi
  005e9	5e		 pop	 rsi
  005ea	c3		 ret	 0
  005eb	90		 npad	 1
$LN35@ptp_execut:
  005ec	00 00 00 00	 DD	 $LN15@ptp_execut
  005f0	00 00 00 00	 DD	 $LN17@ptp_execut
  005f4	00 00 00 00	 DD	 $LN25@ptp_execut
  005f8	00 00 00 00	 DD	 $LN21@ptp_execut
  005fc	00 00 00 00	 DD	 $LN20@ptp_execut
  00600	00 00 00 00	 DD	 $LN19@ptp_execut
  00604	00 00 00 00	 DD	 $LN26@ptp_execut
  00608	00 00 00 00	 DD	 $LN18@ptp_execut
  0060c	00 00 00 00	 DD	 $LN23@ptp_execut
  00610	00 00 00 00	 DD	 $LN27@ptp_execut
$LN34@ptp_execut:
  00614	00		 DB	 0
  00615	01		 DB	 1
  00616	02		 DB	 2
  00617	03		 DB	 3
  00618	09		 DB	 9
  00619	09		 DB	 9
  0061a	09		 DB	 9
  0061b	09		 DB	 9
  0061c	09		 DB	 9
  0061d	09		 DB	 9
  0061e	09		 DB	 9
  0061f	09		 DB	 9
  00620	09		 DB	 9
  00621	09		 DB	 9
  00622	09		 DB	 9
  00623	09		 DB	 9
  00624	09		 DB	 9
  00625	09		 DB	 9
  00626	09		 DB	 9
  00627	04		 DB	 4
  00628	09		 DB	 9
  00629	09		 DB	 9
  0062a	05		 DB	 5
  0062b	09		 DB	 9
  0062c	09		 DB	 9
  0062d	09		 DB	 9
  0062e	09		 DB	 9
  0062f	09		 DB	 9
  00630	09		 DB	 9
  00631	09		 DB	 9
  00632	09		 DB	 9
  00633	09		 DB	 9
  00634	09		 DB	 9
  00635	09		 DB	 9
  00636	09		 DB	 9
  00637	09		 DB	 9
  00638	09		 DB	 9
  00639	09		 DB	 9
  0063a	09		 DB	 9
  0063b	09		 DB	 9
  0063c	09		 DB	 9
  0063d	09		 DB	 9
  0063e	09		 DB	 9
  0063f	09		 DB	 9
  00640	09		 DB	 9
  00641	09		 DB	 9
  00642	09		 DB	 9
  00643	09		 DB	 9
  00644	09		 DB	 9
  00645	09		 DB	 9
  00646	09		 DB	 9
  00647	09		 DB	 9
  00648	09		 DB	 9
  00649	09		 DB	 9
  0064a	09		 DB	 9
  0064b	09		 DB	 9
  0064c	09		 DB	 9
  0064d	09		 DB	 9
  0064e	09		 DB	 9
  0064f	09		 DB	 9
  00650	09		 DB	 9
  00651	09		 DB	 9
  00652	09		 DB	 9
  00653	09		 DB	 9
  00654	09		 DB	 9
  00655	09		 DB	 9
  00656	09		 DB	 9
  00657	09		 DB	 9
  00658	09		 DB	 9
  00659	09		 DB	 9
  0065a	09		 DB	 9
  0065b	09		 DB	 9
  0065c	09		 DB	 9
  0065d	09		 DB	 9
  0065e	09		 DB	 9
  0065f	09		 DB	 9
  00660	09		 DB	 9
  00661	09		 DB	 9
  00662	09		 DB	 9
  00663	09		 DB	 9
  00664	09		 DB	 9
  00665	09		 DB	 9
  00666	09		 DB	 9
  00667	09		 DB	 9
  00668	09		 DB	 9
  00669	09		 DB	 9
  0066a	09		 DB	 9
  0066b	09		 DB	 9
  0066c	09		 DB	 9
  0066d	09		 DB	 9
  0066e	09		 DB	 9
  0066f	09		 DB	 9
  00670	09		 DB	 9
  00671	09		 DB	 9
  00672	09		 DB	 9
  00673	09		 DB	 9
  00674	09		 DB	 9
  00675	09		 DB	 9
  00676	09		 DB	 9
  00677	09		 DB	 9
  00678	09		 DB	 9
  00679	09		 DB	 9
  0067a	09		 DB	 9
  0067b	09		 DB	 9
  0067c	09		 DB	 9
  0067d	09		 DB	 9
  0067e	09		 DB	 9
  0067f	09		 DB	 9
  00680	09		 DB	 9
  00681	09		 DB	 9
  00682	09		 DB	 9
  00683	09		 DB	 9
  00684	09		 DB	 9
  00685	09		 DB	 9
  00686	09		 DB	 9
  00687	09		 DB	 9
  00688	09		 DB	 9
  00689	09		 DB	 9
  0068a	09		 DB	 9
  0068b	09		 DB	 9
  0068c	09		 DB	 9
  0068d	09		 DB	 9
  0068e	09		 DB	 9
  0068f	09		 DB	 9
  00690	09		 DB	 9
  00691	09		 DB	 9
  00692	09		 DB	 9
  00693	09		 DB	 9
  00694	09		 DB	 9
  00695	09		 DB	 9
  00696	09		 DB	 9
  00697	09		 DB	 9
  00698	09		 DB	 9
  00699	09		 DB	 9
  0069a	09		 DB	 9
  0069b	09		 DB	 9
  0069c	09		 DB	 9
  0069d	09		 DB	 9
  0069e	09		 DB	 9
  0069f	09		 DB	 9
  006a0	09		 DB	 9
  006a1	09		 DB	 9
  006a2	09		 DB	 9
  006a3	09		 DB	 9
  006a4	09		 DB	 9
  006a5	09		 DB	 9
  006a6	09		 DB	 9
  006a7	09		 DB	 9
  006a8	09		 DB	 9
  006a9	09		 DB	 9
  006aa	09		 DB	 9
  006ab	09		 DB	 9
  006ac	09		 DB	 9
  006ad	09		 DB	 9
  006ae	09		 DB	 9
  006af	09		 DB	 9
  006b0	09		 DB	 9
  006b1	09		 DB	 9
  006b2	09		 DB	 9
  006b3	09		 DB	 9
  006b4	09		 DB	 9
  006b5	09		 DB	 9
  006b6	09		 DB	 9
  006b7	09		 DB	 9
  006b8	09		 DB	 9
  006b9	09		 DB	 9
  006ba	09		 DB	 9
  006bb	09		 DB	 9
  006bc	09		 DB	 9
  006bd	09		 DB	 9
  006be	09		 DB	 9
  006bf	09		 DB	 9
  006c0	09		 DB	 9
  006c1	09		 DB	 9
  006c2	09		 DB	 9
  006c3	09		 DB	 9
  006c4	09		 DB	 9
  006c5	09		 DB	 9
  006c6	09		 DB	 9
  006c7	09		 DB	 9
  006c8	09		 DB	 9
  006c9	09		 DB	 9
  006ca	09		 DB	 9
  006cb	09		 DB	 9
  006cc	09		 DB	 9
  006cd	09		 DB	 9
  006ce	09		 DB	 9
  006cf	09		 DB	 9
  006d0	09		 DB	 9
  006d1	09		 DB	 9
  006d2	09		 DB	 9
  006d3	09		 DB	 9
  006d4	09		 DB	 9
  006d5	09		 DB	 9
  006d6	06		 DB	 6
  006d7	09		 DB	 9
  006d8	09		 DB	 9
  006d9	09		 DB	 9
  006da	09		 DB	 9
  006db	09		 DB	 9
  006dc	09		 DB	 9
  006dd	09		 DB	 9
  006de	09		 DB	 9
  006df	09		 DB	 9
  006e0	09		 DB	 9
  006e1	09		 DB	 9
  006e2	09		 DB	 9
  006e3	09		 DB	 9
  006e4	09		 DB	 9
  006e5	09		 DB	 9
  006e6	09		 DB	 9
  006e7	09		 DB	 9
  006e8	09		 DB	 9
  006e9	09		 DB	 9
  006ea	09		 DB	 9
  006eb	09		 DB	 9
  006ec	09		 DB	 9
  006ed	09		 DB	 9
  006ee	09		 DB	 9
  006ef	09		 DB	 9
  006f0	09		 DB	 9
  006f1	09		 DB	 9
  006f2	09		 DB	 9
  006f3	09		 DB	 9
  006f4	09		 DB	 9
  006f5	09		 DB	 9
  006f6	07		 DB	 7
  006f7	08		 DB	 8
ptp_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ptp.c
_TEXT	SEGMENT
pPTPBLK$ = 112
pPTPATHre$ = 120
pPTPATHwr$ = 128
i$ = 136
rc$ = 140
tv291 = 144
tv296 = 148
tv350 = 152
tv417 = 156
nIFFlags$ = 160
tv736 = 164
tv740 = 168
tv763 = 172
tv767 = 176
tv793 = 180
tv797 = 184
tv271 = 192
tv284 = 200
tv826 = 208
tv333 = 216
tv337 = 224
tv820 = 232
tv368 = 240
tv372 = 248
tv817 = 256
tv520 = 264
tv542 = 272
tv650 = 280
tv733 = 288
tv754 = 296
tv756 = 304
tv758 = 312
tv782 = 320
tv784 = 328
tv786 = 336
tv790 = 344
tt32ctl$1 = 352
thread_name$ = 376
__$ArrayPad$ = 408
pDEVBLK$ = 432
argc$ = 440
argv$ = 448
ptp_init PROC

; 320  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 321  :     PTPBLK*    pPTPBLK;                // PTPBLK
; 322  :     PTPATH*    pPTPATHre;              // PTPATH Read
; 323  :     PTPATH*    pPTPATHwr;              // PTPATH Write
; 324  : //  int        nIFType;                // Interface type
; 325  :     int        nIFFlags;               // Interface flags
; 326  :     int        rc = 0;                 // Return code

  00028	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$[rsp], 0

; 327  :     int        i;
; 328  :     char       thread_name[32];        // ptp_read_thread
; 329  : 
; 330  : 
; 331  : //  nIFType =               // Interface type
; 332  : //      0
; 333  : //      | IFF_TUN           // ("TUN", not "tap")
; 334  : //      | IFF_NO_PI         // (no packet info)
; 335  : //      ;
; 336  : 
; 337  :     nIFFlags =              // Interface flags

  00033	c7 84 24 a0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR nIFFlags$[rsp], 3

; 338  :         0
; 339  :         | IFF_UP            // (interface is being enabled)
; 340  :         | IFF_BROADCAST     // (interface broadcast addr is valid)
; 341  :         ;
; 342  : 
; 343  : #if defined( TUNTAP_IFF_RUNNING_NEEDED )
; 344  : 
; 345  :     nIFFlags |=             // ADDITIONAL Interface flags
; 346  :         0
; 347  :         | IFF_RUNNING       // (interface is ALSO operational)
; 348  :         ;
; 349  : 
; 350  : #endif /* defined( TUNTAP_IFF_RUNNING_NEEDED ) */
; 351  : 
; 352  :     // Initialize fields in the DEVBLK that are referenced by commands.
; 353  :     pDEVBLK->devtype = 0x3088;

  0003e	b8 88 30 00 00	 mov	 eax, 12424		; 00003088H
  00043	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0004b	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax

; 354  :     pDEVBLK->excps = 0;

  0004f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00057	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 355  : 
; 356  :     // Initialize locking for the tokens, if necessary.
; 357  :     if (!TokenLockInitialized)

  00062	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR TokenLockInitialized, 0
  00069	75 25		 jne	 SHORT $LN59@ptp_init

; 358  :     {
; 359  :         TokenLockInitialized = TRUE;

  0006b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR TokenLockInitialized, 1

; 360  :         initialize_lock( &TokenLock );

  00075	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170099
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170100
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock
$LN59@ptp_init:

; 361  :     }
; 362  : 
; 363  :     // PTP is a group device, with two devices in the group. The first
; 364  :     // device is deemed to be the read device, the second device is deemed
; 365  :     // to be the write device. (Function group_device() is in config.c)
; 366  :     if (!group_device( pDEVBLK, PTP_GROUP_SIZE ))

  00090	ba 02 00 00 00	 mov	 edx, 2
  00095	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_group_device
  000a3	85 c0		 test	 eax, eax
  000a5	75 07		 jne	 SHORT $LN60@ptp_init

; 367  :         return 0;

  000a7	33 c0		 xor	 eax, eax
  000a9	e9 2d 13 00 00	 jmp	 $LN1@ptp_init
$LN60@ptp_init:

; 368  : 
; 369  :     // Allocate the PTPBLK.
; 370  :     pPTPBLK = alloc_storage( pDEVBLK, (int)sizeof(PTPBLK) );

  000ae	ba 8a 03 00 00	 mov	 edx, 906		; 0000038aH
  000b3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000bb	e8 00 00 00 00	 call	 alloc_storage
  000c0	48 89 44 24 70	 mov	 QWORD PTR pPTPBLK$[rsp], rax

; 371  :     if (!pPTPBLK)

  000c5	48 83 7c 24 70
	00		 cmp	 QWORD PTR pPTPBLK$[rsp], 0
  000cb	75 0a		 jne	 SHORT $LN61@ptp_init

; 372  :         return -1;

  000cd	b8 ff ff ff ff	 mov	 eax, -1
  000d2	e9 04 13 00 00	 jmp	 $LN1@ptp_init
$LN61@ptp_init:

; 373  : 
; 374  :     // Allocate the PTPATH Read.
; 375  :     pPTPATHre = alloc_storage( pDEVBLK, (int)sizeof(PTPATH) );

  000d7	ba 46 00 00 00	 mov	 edx, 70			; 00000046H
  000dc	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000e4	e8 00 00 00 00	 call	 alloc_storage
  000e9	48 89 44 24 78	 mov	 QWORD PTR pPTPATHre$[rsp], rax

; 376  :     if (!pPTPATHre)

  000ee	48 83 7c 24 78
	00		 cmp	 QWORD PTR pPTPATHre$[rsp], 0
  000f4	75 15		 jne	 SHORT $LN62@ptp_init

; 377  :     {
; 378  :         free( pPTPBLK );

  000f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 379  :         return -1;

  00101	b8 ff ff ff ff	 mov	 eax, -1
  00106	e9 d0 12 00 00	 jmp	 $LN1@ptp_init
$LN62@ptp_init:

; 380  :     }
; 381  : 
; 382  :     // Allocate the PTPATH Write.
; 383  :     pPTPATHwr = alloc_storage( pDEVBLK, (int)sizeof(PTPATH) );

  0010b	ba 46 00 00 00	 mov	 edx, 70			; 00000046H
  00110	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00118	e8 00 00 00 00	 call	 alloc_storage
  0011d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pPTPATHwr$[rsp], rax

; 384  :     if (!pPTPATHwr)

  00125	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pPTPATHwr$[rsp], 0
  0012e	75 20		 jne	 SHORT $LN63@ptp_init

; 385  :     {
; 386  :         free( pPTPATHre );

  00130	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 387  :         free( pPTPBLK );

  0013b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 388  :         return -1;

  00146	b8 ff ff ff ff	 mov	 eax, -1
  0014b	e9 8b 12 00 00	 jmp	 $LN1@ptp_init
$LN63@ptp_init:

; 389  :     }
; 390  : 
; 391  :     // Parse configuration file statement.
; 392  :     if (parse_conf_stmt( pDEVBLK, pPTPBLK, argc, (char**) argv ) != 0)

  00150	4c 8b 8c 24 c0
	01 00 00	 mov	 r9, QWORD PTR argv$[rsp]
  00158	44 8b 84 24 b8
	01 00 00	 mov	 r8d, DWORD PTR argc$[rsp]
  00160	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  00165	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0016d	e8 00 00 00 00	 call	 parse_conf_stmt
  00172	85 c0		 test	 eax, eax
  00174	74 2e		 je	 SHORT $LN64@ptp_init

; 393  :     {
; 394  :         free( pPTPATHwr );

  00176	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHwr$[rsp]
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 395  :         free( pPTPATHre );

  00184	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 396  :         free( pPTPBLK );

  0018f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 397  :         return -1;

  0019a	b8 ff ff ff ff	 mov	 eax, -1
  0019f	e9 37 12 00 00	 jmp	 $LN1@ptp_init
$LN64@ptp_init:

; 398  :     }
; 399  : 
; 400  :     // Connect the DEVBLKs, the PTPATHs and the PTPBLK together.
; 401  :     pPTPBLK->pPTPATHRead = pPTPATHre;                   // Make the PTPBLK point

  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  001ae	48 89 08	 mov	 QWORD PTR [rax], rcx

; 402  :     pPTPBLK->pPTPATHWrite = pPTPATHwr;                  // to the two PTPATHs.

  001b1	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  001b6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHwr$[rsp]
  001be	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 403  : 
; 404  :     pPTPBLK->pDEVBLKRead = pDEVBLK->group->memdev[0];   // Make the PTPBLK point

  001c2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001ca	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001ce	b9 08 00 00 00	 mov	 ecx, 8
  001d3	48 6b c9 00	 imul	 rcx, rcx, 0
  001d7	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  001dc	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  001e1	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 405  :     pPTPBLK->pDEVBLKWrite = pDEVBLK->group->memdev[1];  // to the two DEVBLKs.

  001e5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001ed	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001f1	b9 08 00 00 00	 mov	 ecx, 8
  001f6	48 6b c9 01	 imul	 rcx, rcx, 1
  001fa	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  001ff	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  00204	48 89 42 18	 mov	 QWORD PTR [rdx+24], rax

; 406  : 
; 407  :     pPTPATHre->pPTPBLK = pPTPBLK;                       // Make each PTPATH point

  00208	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATHre$[rsp]
  0020d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00212	48 89 08	 mov	 QWORD PTR [rax], rcx

; 408  :     pPTPATHwr->pPTPBLK = pPTPBLK;                       // to the PTPBLK.

  00215	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pPTPATHwr$[rsp]
  0021d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00222	48 89 08	 mov	 QWORD PTR [rax], rcx

; 409  : 
; 410  :     pPTPATHre->pDEVBLK = pPTPBLK->pDEVBLKRead;          // Make each PTPATH point

  00225	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATHre$[rsp]
  0022a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0022f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00233	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 411  :     pPTPATHwr->pDEVBLK = pPTPBLK->pDEVBLKWrite;         // to the apprpriate DEVBLK

  00237	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pPTPATHwr$[rsp]
  0023f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00244	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00248	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 412  : 
; 413  :     pPTPBLK->pDEVBLKRead->dev_data = pPTPATHre;         // Make each DEVBLK point

  0024c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00251	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00255	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  0025a	48 89 88 08 06
	00 00		 mov	 QWORD PTR [rax+1544], rcx

; 414  :     pPTPBLK->pDEVBLKWrite->dev_data = pPTPATHwr;        // to the appropriate PTPATH.

  00261	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00266	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0026a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHwr$[rsp]
  00272	48 89 88 08 06
	00 00		 mov	 QWORD PTR [rax+1544], rcx

; 415  : 
; 416  :     pDEVBLK->group->grp_data = pPTPBLK;                 // Make DEVGRP point to PTPBLK

  00279	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00281	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00285	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0028a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 417  : 
; 418  :     // Initialize various fields in the DEVBLKs.
; 419  :     SetSIDInfo( pPTPBLK->pDEVBLKRead, 0x3088, 0x08, 0x3088, 0x01 );

  0028e	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00293	66 41 b9 88 30	 mov	 r9w, 12424		; 00003088H
  00298	41 b0 08	 mov	 r8b, 8
  0029b	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  0029f	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002a4	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  002a8	e8 00 00 00 00	 call	 SetSIDInfo

; 420  :     SetSIDInfo( pPTPBLK->pDEVBLKWrite, 0x3088, 0x08, 0x3088, 0x01 );

  002ad	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  002b2	66 41 b9 88 30	 mov	 r9w, 12424		; 00003088H
  002b7	41 b0 08	 mov	 r8b, 8
  002ba	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  002be	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002c3	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  002c7	e8 00 00 00 00	 call	 SetSIDInfo

; 421  : 
; 422  :     pPTPBLK->pDEVBLKRead->ctctype  = CTC_PTP;

  002cc	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002d1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002d5	c6 80 1c 07 00
	00 03		 mov	 BYTE PTR [rax+1820], 3

; 423  :     pPTPBLK->pDEVBLKRead->ctcxmode = 1;

  002dc	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  002e1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002e5	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  002eb	83 c8 01	 or	 eax, 1
  002ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  002f3	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002f7	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 424  : 
; 425  :     pPTPBLK->pDEVBLKWrite->ctctype  = CTC_PTP;

  002fd	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00302	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00306	c6 80 1c 07 00
	00 03		 mov	 BYTE PTR [rax+1820], 3

; 426  :     pPTPBLK->pDEVBLKWrite->ctcxmode = 1;

  0030d	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00312	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00316	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0031c	83 c8 01	 or	 eax, 1
  0031f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00324	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00328	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 427  : 
; 428  :     strlcpy( pPTPBLK->pDEVBLKRead->filename,

  0032e	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00333	48 83 c0 7c	 add	 rax, 124		; 0000007cH
  00337	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0033c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00340	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00347	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0034d	48 8b d0	 mov	 rdx, rax
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 429  :              pPTPBLK->szTUNCharDevName,
; 430  :              sizeof(pPTPBLK->pDEVBLKRead->filename) );
; 431  :     strlcpy( pPTPBLK->pDEVBLKWrite->filename,

  00356	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0035b	48 83 c0 7c	 add	 rax, 124		; 0000007cH
  0035f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00364	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00368	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0036f	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00375	48 8b d0	 mov	 rdx, rax
  00378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 432  :              pPTPBLK->szTUNCharDevName,
; 433  :              sizeof(pPTPBLK->pDEVBLKWrite->filename) );
; 434  : 
; 435  :     // Initialize various fields in the PTPATHs.
; 436  :     pPTPATHre->bDLCtype = DLCTYPE_READ;      // Read path

  0037e	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATHre$[rsp]
  00383	c6 40 41 05	 mov	 BYTE PTR [rax+65], 5

; 437  :     pPTPATHwr->bDLCtype = DLCTYPE_WRITE;    // write path

  00387	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pPTPATHwr$[rsp]
  0038f	c6 40 41 04	 mov	 BYTE PTR [rax+65], 4

; 438  : 
; 439  :     // Initialize various fields in the PTPBLK.
; 440  :     pPTPBLK->fd = -1;

  00393	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00398	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 441  : 
; 442  :     pPTPBLK->xDataLen1 = XDATALEN1;                        // !!! //

  0039f	b8 fc 0f 00 00	 mov	 eax, 4092		; 00000ffcH
  003a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003a9	66 89 81 51 03
	00 00		 mov	 WORD PTR [rcx+849], ax

; 443  : 
; 444  :     pPTPBLK->xMaxReadLen = ( pPTPBLK->iMaxBfru * 4096 ) - 4;

  003b0	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003b5	69 80 d0 02 00
	00 00 10 00 00	 imul	 eax, DWORD PTR [rax+720], 4096 ; 00001000H
  003bf	83 e8 04	 sub	 eax, 4
  003c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003c7	66 89 81 53 03
	00 00		 mov	 WORD PTR [rcx+851], ax

; 445  :     //       xMaxReadLen = 20476 (0x4FFC) when iMaxBfru = 5
; 446  :     //       xMaxReadLen = 65532 (0xFFFC) when iMaxBfru = 16
; 447  : 
; 448  :     pPTPBLK->xActMTU = ( ( pPTPBLK->iMaxBfru - 1 ) * 4096 ) - 2048;

  003ce	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003d3	8b 80 d0 02 00
	00		 mov	 eax, DWORD PTR [rax+720]
  003d9	ff c8		 dec	 eax
  003db	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  003e1	2d 00 08 00 00	 sub	 eax, 2048		; 00000800H
  003e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  003eb	66 89 81 55 03
	00 00		 mov	 WORD PTR [rcx+853], ax

; 449  :     //       xActMTU = 14336 (0x3800) when iMaxBfru = 5
; 450  :     //       xActMTU = 59392 (0xE800) when iMaxBfru = 16
; 451  : 
; 452  :     ptp_get_tod_clock( pPTPBLK->xStartTime );    // x-side's start time

  003f2	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  003f7	48 05 24 03 00
	00		 add	 rax, 804		; 00000324H
  003fd	48 8b c8	 mov	 rcx, rax
  00400	e8 00 00 00 00	 call	 ptp_get_tod_clock

; 453  : 
; 454  :     for( i = 0; i <= 7; i++ )

  00405	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00410	eb 10		 jmp	 SHORT $LN4@ptp_init
$LN2@ptp_init:
  00412	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00419	ff c0		 inc	 eax
  0041b	89 84 24 88 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@ptp_init:
  00422	83 bc 24 88 00
	00 00 07	 cmp	 DWORD PTR i$[rsp], 7
  0042a	7f 30		 jg	 SHORT $LN3@ptp_init

; 455  :         pPTPBLK->xFirstCsvSID2[i] = pPTPBLK->xStartTime[i] ^ 0xAA;

  0042c	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00434	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00439	0f b6 84 01 24
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+804]
  00441	35 aa 00 00 00	 xor	 eax, 170		; 000000aaH
  00446	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0044e	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  00453	88 84 0a 2c 03
	00 00		 mov	 BYTE PTR [rdx+rcx+812], al
  0045a	eb b6		 jmp	 SHORT $LN2@ptp_init
$LN3@ptp_init:

; 456  : 
; 457  :     get_subarea_address( pPTPBLK->xSAaddress );  // x-side's subarea address

  0045c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00461	48 05 20 03 00
	00		 add	 rax, 800		; 00000320H
  00467	48 8b c8	 mov	 rcx, rax
  0046a	e8 00 00 00 00	 call	 get_subarea_address

; 458  : 
; 459  :     // Initialize locking and event mechanisms in the PTPBLK and the PTPATHs.
; 460  :     initialize_lock( &pPTPBLK->ReadBufferLock );

  0046f	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00474	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00478	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170106
  0047f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170107
  00486	48 8b c8	 mov	 rcx, rax
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 461  :     initialize_lock( &pPTPBLK->ReadEventLock );

  0048f	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00494	48 83 c0 40	 add	 rax, 64			; 00000040H
  00498	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170108
  0049f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170109
  004a6	48 8b c8	 mov	 rcx, rax
  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 462  :     initialize_condition( &pPTPBLK->ReadEvent );

  004af	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004b4	48 83 c0 48	 add	 rax, 72			; 00000048H
  004b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170110
  004bf	48 8b c8	 mov	 rcx, rax
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 463  :     initialize_lock( &pPTPBLK->UnsolListLock );

  004c8	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004cd	48 83 c0 50	 add	 rax, 80			; 00000050H
  004d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170111
  004d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170112
  004df	48 8b c8	 mov	 rcx, rax
  004e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 464  :     initialize_lock( &pPTPBLK->UpdateLock );

  004e8	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  004ed	48 83 c0 60	 add	 rax, 96			; 00000060H
  004f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170113
  004f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170114
  004ff	48 8b c8	 mov	 rcx, rax
  00502	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 465  : 
; 466  :     initialize_lock( &pPTPATHre->ChainLock );

  00508	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATHre$[rsp]
  0050d	48 83 c0 10	 add	 rax, 16
  00511	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170115
  00518	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170116
  0051f	48 8b c8	 mov	 rcx, rax
  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 467  :     initialize_lock( &pPTPATHre->UnsolEventLock );

  00528	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATHre$[rsp]
  0052d	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00531	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170117
  00538	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170118
  0053f	48 8b c8	 mov	 rcx, rax
  00542	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 468  :     initialize_condition( &pPTPATHre->UnsolEvent );

  00548	48 8b 44 24 78	 mov	 rax, QWORD PTR pPTPATHre$[rsp]
  0054d	48 83 c0 34	 add	 rax, 52			; 00000034H
  00551	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170119
  00558	48 8b c8	 mov	 rcx, rax
  0055b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 469  : 
; 470  :     initialize_lock( &pPTPATHwr->ChainLock );

  00561	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pPTPATHwr$[rsp]
  00569	48 83 c0 10	 add	 rax, 16
  0056d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170120
  00574	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170121
  0057b	48 8b c8	 mov	 rcx, rax
  0057e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 471  :     initialize_lock( &pPTPATHwr->UnsolEventLock );

  00584	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pPTPATHwr$[rsp]
  0058c	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00590	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170122
  00597	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170123
  0059e	48 8b c8	 mov	 rcx, rax
  005a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 472  :     initialize_condition( &pPTPATHwr->UnsolEvent );

  005a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pPTPATHwr$[rsp]
  005af	48 83 c0 34	 add	 rax, 52			; 00000034H
  005b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170124
  005ba	48 8b c8	 mov	 rcx, rax
  005bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 473  : 
; 474  :     // Create the TUN interface.
; 475  :     rc = TUNTAP_CreateInterface( pPTPBLK->szTUNCharDevName,

  005c3	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  005c8	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  005ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  005d3	48 83 c1 20	 add	 rcx, 32			; 00000020H
  005d7	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  005dc	48 83 c2 7c	 add	 rdx, 124		; 0000007cH
  005e0	48 89 94 24 c0
	00 00 00	 mov	 QWORD PTR tv271[rsp], rdx
  005e8	4c 8b c8	 mov	 r9, rax
  005eb	4c 8b c1	 mov	 r8, rcx
  005ee	ba 01 10 00 00	 mov	 edx, 4097		; 00001001H
  005f3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv271[rsp]
  005fb	48 8b c8	 mov	 rcx, rax
  005fe	e8 00 00 00 00	 call	 TUNTAP_CreateInterface
  00603	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 476  : #if defined(BUILD_HERCIFC)
; 477  :                                  (pPTPBLK->fPreconfigured ? IFF_NO_HERCIFC : 0) |
; 478  : #endif //defined(BUILD_HERCIFC)
; 479  :                                  IFF_TUN | IFF_NO_PI,
; 480  :                                  &pPTPBLK->fd,
; 481  :                                  pPTPBLK->szTUNIfName );
; 482  :     if (rc < 0)

  0060a	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00612	7d 6a		 jge	 SHORT $LN65@ptp_init

; 483  :     {
; 484  :         // Disconnect the DEVGRP from the PTPBLK.
; 485  :         pDEVBLK->group->grp_data = NULL;

  00614	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0061c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00620	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 486  :         // Disconnect the DEVBLKs from the PTPATHs.
; 487  :         pPTPBLK->pDEVBLKRead->dev_data = NULL;

  00628	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0062d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00631	48 c7 80 08 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1544], 0

; 488  :         pPTPBLK->pDEVBLKWrite->dev_data = NULL;

  0063c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00641	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00645	48 c7 80 08 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1544], 0

; 489  :         // Free the PTPATHs and PTPBLK
; 490  :         free( pPTPATHwr );

  00650	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHwr$[rsp]
  00658	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 491  :         free( pPTPATHre );

  0065e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  00663	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 492  :         free( pPTPBLK );

  00669	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0066e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 493  :         return -1;

  00674	b8 ff ff ff ff	 mov	 eax, -1
  00679	e9 5d 0d 00 00	 jmp	 $LN1@ptp_init
$LN65@ptp_init:

; 494  :     }
; 495  :     // HHC00901 "%1d:%04X %s: interface %s, type %s opened"
; 496  :     WRMSG(HHC00901, "I", SSID_TO_LCSS(pPTPBLK->pDEVBLKRead->ssid), pPTPBLK->pDEVBLKRead->devnum,

  0067e	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00683	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  00689	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv284[rsp], rax
  00691	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00696	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0069a	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR tv826[rsp], rcx
  006a2	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  006a7	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  006ab	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  006af	89 94 24 90 00
	00 00		 mov	 DWORD PTR tv291[rsp], edx
  006b6	4c 8b 44 24 70	 mov	 r8, QWORD PTR pPTPBLK$[rsp]
  006bb	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  006bf	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  006c4	41 d1 f8	 sar	 r8d, 1
  006c7	44 89 84 24 94
	00 00 00	 mov	 DWORD PTR tv296[rsp], r8d
  006cf	b9 01 00 00 00	 mov	 ecx, 1
  006d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170126
  006e1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006e6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv284[rsp]
  006ee	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006f3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv826[rsp]
  006fb	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  006ff	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00704	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  0070b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0070f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv296[rsp]
  00716	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0071a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170127
  00721	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00726	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170128
  0072d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00732	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00737	41 b9 03 00 00
	00		 mov	 r9d, 3
  0073d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170129
  00744	ba f1 01 00 00	 mov	 edx, 497		; 000001f1H
  00749	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170130
  00750	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 497  :                          pPTPBLK->pDEVBLKRead->typname, pPTPBLK->szTUNIfName, "TUN" );
; 498  : 
; 499  :     // Copy the fd to make panel.c happy
; 500  :     pPTPBLK->pDEVBLKRead->fd =

  00756	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0075b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0075f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00764	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00767	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
  0076d	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00772	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00776	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0077b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0077f	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  00785	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 501  :     pPTPBLK->pDEVBLKWrite->fd = pPTPBLK->fd;
; 502  : 
; 503  :     /* */
; 504  :     if (!pPTPBLK->fPreconfigured) {

  0078b	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00790	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00793	c1 e8 06	 shr	 eax, 6
  00796	83 e0 01	 and	 eax, 1
  00799	85 c0		 test	 eax, eax
  0079b	0f 85 1f 07 00
	00		 jne	 $LN66@ptp_init

; 505  : 
; 506  :         // Set various values for the TUN interface.
; 507  : #if defined(OPTION_W32_CTCI)
; 508  :         {
; 509  :             struct tt32ctl tt32ctl;
; 510  : 
; 511  :             memset( &tt32ctl, 0, sizeof(tt32ctl) );

  007a1	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR tt32ctl$1[rsp]
  007a9	48 8b f8	 mov	 rdi, rax
  007ac	33 c0		 xor	 eax, eax
  007ae	b9 14 00 00 00	 mov	 ecx, 20
  007b3	f3 aa		 rep stosb

; 512  :             STRLCPY( tt32ctl.tt32ctl_name, pPTPBLK->szTUNIfName );

  007b5	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007ba	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  007c0	41 b8 10 00 00
	00		 mov	 r8d, 16
  007c6	48 8b d0	 mov	 rdx, rax
  007c9	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR tt32ctl$1[rsp]
  007d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 513  : 
; 514  :             // Set the specified driver/dll i/o buffer sizes..
; 515  :             tt32ctl.tt32ctl_devbuffsize = pPTPBLK->iKernBuff;

  007d7	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007dc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  007df	89 84 24 70 01
	00 00		 mov	 DWORD PTR tt32ctl$1[rsp+16], eax

; 516  :             if (TUNTAP_IOCtl( pPTPBLK->fd, TT32SDEVBUFF, (char*)&tt32ctl ) != 0)

  007e6	4c 8d 84 24 60
	01 00 00	 lea	 r8, QWORD PTR tt32ctl$1[rsp]
  007ee	ba dc 54 04 80	 mov	 edx, -2147199780	; ffffffff800454dcH
  007f3	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  007f8	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  007fb	e8 00 00 00 00	 call	 tt32_ioctl
  00800	85 c0		 test	 eax, eax
  00802	0f 84 ee 00 00
	00		 je	 $LN67@ptp_init

; 517  :             {
; 518  :                 // HHC00902 "%1d:%04X %s: ioctl '%s' failed for device '%s': '%s'"
; 519  :                 WRMSG(HHC00902, "W", SSID_TO_LCSS(pPTPBLK->pDEVBLKRead->ssid),

  00808	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0080e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00810	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00816	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv333[rsp], rax
  0081e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00823	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  0082a	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv337[rsp], rcx
  00832	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  00837	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0083b	48 89 94 24 e8
	00 00 00	 mov	 QWORD PTR tv820[rsp], rdx
  00843	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pPTPBLK$[rsp]
  00848	48 8b 7f 10	 mov	 rdi, QWORD PTR [rdi+16]
  0084c	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  00850	4c 8b 44 24 70	 mov	 r8, QWORD PTR pPTPBLK$[rsp]
  00855	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  00859	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0085e	41 d1 f8	 sar	 r8d, 1
  00861	44 89 84 24 98
	00 00 00	 mov	 DWORD PTR tv350[rsp], r8d
  00869	b9 01 00 00 00	 mov	 ecx, 1
  0086e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00874	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv333[rsp]
  0087c	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00881	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv337[rsp]
  00889	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0088e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170133
  00895	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0089a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv820[rsp]
  008a2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  008a6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008ab	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  008af	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv350[rsp]
  008b6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170134
  008c1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170135
  008cd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008d7	41 b9 03 00 00
	00		 mov	 r9d, 3
  008dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170136
  008e4	ba 09 02 00 00	 mov	 edx, 521		; 00000209H
  008e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170137
  008f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN67@ptp_init:

; 520  :                                 pPTPBLK->pDEVBLKRead->devnum, pPTPBLK->pDEVBLKRead->typname,
; 521  :                                 "TT32SDEVBUFF", pPTPBLK->szTUNIfName, strerror( errno ) );
; 522  :             }
; 523  : 
; 524  :             tt32ctl.tt32ctl_iobuffsize = pPTPBLK->iIOBuff;

  008f6	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  008fb	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  008fe	89 84 24 70 01
	00 00		 mov	 DWORD PTR tt32ctl$1[rsp+16], eax

; 525  :             if (TUNTAP_IOCtl( pPTPBLK->fd, TT32SIOBUFF, (char*)&tt32ctl ) != 0)

  00905	4c 8d 84 24 60
	01 00 00	 lea	 r8, QWORD PTR tt32ctl$1[rsp]
  0090d	ba dd 54 04 80	 mov	 edx, -2147199779	; ffffffff800454ddH
  00912	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00917	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  0091a	e8 00 00 00 00	 call	 tt32_ioctl
  0091f	85 c0		 test	 eax, eax
  00921	0f 84 ee 00 00
	00		 je	 $LN68@ptp_init

; 526  :             {
; 527  :                 // HHC00902 "%1d:%04X %s: ioctl '%s' failed for device '%s': '%s'"
; 528  :                 WRMSG(HHC00902, "W", SSID_TO_LCSS(pPTPBLK->pDEVBLKRead->ssid),

  00927	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0092d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0092f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00935	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv368[rsp], rax
  0093d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00942	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00949	48 89 8c 24 f8
	00 00 00	 mov	 QWORD PTR tv372[rsp], rcx
  00951	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  00956	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0095a	48 89 94 24 00
	01 00 00	 mov	 QWORD PTR tv817[rsp], rdx
  00962	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pPTPBLK$[rsp]
  00967	48 8b 7f 10	 mov	 rdi, QWORD PTR [rdi+16]
  0096b	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  0096f	4c 8b 44 24 70	 mov	 r8, QWORD PTR pPTPBLK$[rsp]
  00974	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  00978	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0097d	41 d1 f8	 sar	 r8d, 1
  00980	44 89 84 24 9c
	00 00 00	 mov	 DWORD PTR tv417[rsp], r8d
  00988	b9 01 00 00 00	 mov	 ecx, 1
  0098d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00993	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv368[rsp]
  0099b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  009a0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv372[rsp]
  009a8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  009ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170139
  009b4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009b9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv817[rsp]
  009c1	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  009c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009ca	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  009ce	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv417[rsp]
  009d5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170140
  009e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170141
  009ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009f6	41 b9 03 00 00
	00		 mov	 r9d, 3
  009fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170142
  00a03	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  00a08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170143
  00a0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN68@ptp_init:
$LN7@ptp_init:

; 529  :                                 pPTPBLK->pDEVBLKRead->devnum, pPTPBLK->pDEVBLKRead->typname,
; 530  :                                 "TT32SIOBUFF", pPTPBLK->szTUNIfName, strerror( errno ) );
; 531  :             }
; 532  :         }
; 533  : 
; 534  : #ifdef OPTION_TUNTAP_SETMACADDR
; 535  :         VERIFY( TUNTAP_SetMACAddr( pPTPBLK->szTUNIfName, pPTPBLK->szMACAddress  ) == 0 );

  00a15	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00a1a	48 05 9c 01 00
	00		 add	 rax, 412		; 0000019cH
  00a20	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00a25	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00a2c	48 8b d0	 mov	 rdx, rax
  00a2f	e8 00 00 00 00	 call	 TUNTAP_SetMACAddr
  00a34	85 c0		 test	 eax, eax
  00a36	74 5c		 je	 SHORT $LN69@ptp_init
$LN10@ptp_init:
  00a38	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170145
  00a3f	41 b8 17 02 00
	00		 mov	 r8d, 535		; 00000217H
  00a45	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170146
  00a4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170147
  00a53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00a59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00a5f	85 c0		 test	 eax, eax
  00a61	74 20		 je	 SHORT $LN70@ptp_init
  00a63	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170149
  00a6a	41 b8 17 02 00
	00		 mov	 r8d, 535		; 00000217H
  00a70	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170150
  00a77	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170151
  00a7e	e8 00 00 00 00	 call	 DebuggerTrace
$LN70@ptp_init:
  00a83	33 c0		 xor	 eax, eax
  00a85	85 c0		 test	 eax, eax
  00a87	75 af		 jne	 SHORT $LN10@ptp_init
  00a89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00a8f	85 c0		 test	 eax, eax
  00a91	74 01		 je	 SHORT $LN71@ptp_init
  00a93	cc		 int	 3
$LN71@ptp_init:
$LN69@ptp_init:
  00a94	33 c0		 xor	 eax, eax
  00a96	85 c0		 test	 eax, eax
  00a98	0f 85 77 ff ff
	ff		 jne	 $LN7@ptp_init

; 536  : #endif /* OPTION_TUNTAP_SETMACADDR */
; 537  : 
; 538  : #ifdef OPTION_TUNTAP_CLRIPADDR
; 539  :         VERIFY( TUNTAP_ClrIPAddr ( pPTPBLK->szTUNIfName ) == 0 );
; 540  : #endif /* OPTION_TUNTAP_CLRIPADDR */
; 541  : #endif /* defined(OPTION_W32_CTCI) */
; 542  : 
; 543  :         if (pPTPBLK->fIPv4Spec)

  00a9e	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00aa3	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00aa6	83 e0 01	 and	 eax, 1
  00aa9	85 c0		 test	 eax, eax
  00aab	0f 84 9b 01 00
	00		 je	 $LN72@ptp_init
$LN13@ptp_init:

; 544  :         {
; 545  :             VERIFY( TUNTAP_SetIPAddr( pPTPBLK->szTUNIfName, pPTPBLK->szDriveIPAddr4 ) == 0 );

  00ab1	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ab6	48 05 bc 01 00
	00		 add	 rax, 444		; 000001bcH
  00abc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00ac1	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00ac8	48 8b d0	 mov	 rdx, rax
  00acb	e8 00 00 00 00	 call	 TUNTAP_SetIPAddr
  00ad0	85 c0		 test	 eax, eax
  00ad2	74 5c		 je	 SHORT $LN73@ptp_init
$LN16@ptp_init:
  00ad4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170155
  00adb	41 b8 21 02 00
	00		 mov	 r8d, 545		; 00000221H
  00ae1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170156
  00ae8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170157
  00aef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00af5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00afb	85 c0		 test	 eax, eax
  00afd	74 20		 je	 SHORT $LN74@ptp_init
  00aff	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170159
  00b06	41 b8 21 02 00
	00		 mov	 r8d, 545		; 00000221H
  00b0c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170160
  00b13	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170161
  00b1a	e8 00 00 00 00	 call	 DebuggerTrace
$LN74@ptp_init:
  00b1f	33 c0		 xor	 eax, eax
  00b21	85 c0		 test	 eax, eax
  00b23	75 af		 jne	 SHORT $LN16@ptp_init
  00b25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00b2b	85 c0		 test	 eax, eax
  00b2d	74 01		 je	 SHORT $LN75@ptp_init
  00b2f	cc		 int	 3
$LN75@ptp_init:
$LN73@ptp_init:
  00b30	33 c0		 xor	 eax, eax
  00b32	85 c0		 test	 eax, eax
  00b34	0f 85 77 ff ff
	ff		 jne	 $LN13@ptp_init
$LN19@ptp_init:

; 546  : 
; 547  :             VERIFY( TUNTAP_SetDestAddr( pPTPBLK->szTUNIfName, pPTPBLK->szGuestIPAddr4 ) == 0 );

  00b3a	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00b3f	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  00b45	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00b4a	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00b51	48 8b d0	 mov	 rdx, rax
  00b54	e8 00 00 00 00	 call	 TUNTAP_SetDestAddr
  00b59	85 c0		 test	 eax, eax
  00b5b	74 5c		 je	 SHORT $LN76@ptp_init
$LN22@ptp_init:
  00b5d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170164
  00b64	41 b8 23 02 00
	00		 mov	 r8d, 547		; 00000223H
  00b6a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170165
  00b71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170166
  00b78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00b7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00b84	85 c0		 test	 eax, eax
  00b86	74 20		 je	 SHORT $LN77@ptp_init
  00b88	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170168
  00b8f	41 b8 23 02 00
	00		 mov	 r8d, 547		; 00000223H
  00b95	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170169
  00b9c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170170
  00ba3	e8 00 00 00 00	 call	 DebuggerTrace
$LN77@ptp_init:
  00ba8	33 c0		 xor	 eax, eax
  00baa	85 c0		 test	 eax, eax
  00bac	75 af		 jne	 SHORT $LN22@ptp_init
  00bae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00bb4	85 c0		 test	 eax, eax
  00bb6	74 01		 je	 SHORT $LN78@ptp_init
  00bb8	cc		 int	 3
$LN78@ptp_init:
$LN76@ptp_init:
  00bb9	33 c0		 xor	 eax, eax
  00bbb	85 c0		 test	 eax, eax
  00bbd	0f 85 77 ff ff
	ff		 jne	 $LN19@ptp_init
$LN25@ptp_init:

; 548  : 
; 549  : #ifdef OPTION_TUNTAP_SETNETMASK
; 550  :             VERIFY( TUNTAP_SetNetMask( pPTPBLK->szTUNIfName, pPTPBLK->szNetMask ) == 0 );

  00bc3	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00bc8	48 05 d8 01 00
	00		 add	 rax, 472		; 000001d8H
  00bce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00bd3	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00bda	48 8b d0	 mov	 rdx, rax
  00bdd	e8 00 00 00 00	 call	 TUNTAP_SetNetMask
  00be2	85 c0		 test	 eax, eax
  00be4	74 5c		 je	 SHORT $LN79@ptp_init
$LN28@ptp_init:
  00be6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170173
  00bed	41 b8 26 02 00
	00		 mov	 r8d, 550		; 00000226H
  00bf3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170174
  00bfa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170175
  00c01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00c07	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c0d	85 c0		 test	 eax, eax
  00c0f	74 20		 je	 SHORT $LN80@ptp_init
  00c11	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170177
  00c18	41 b8 26 02 00
	00		 mov	 r8d, 550		; 00000226H
  00c1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170178
  00c25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170179
  00c2c	e8 00 00 00 00	 call	 DebuggerTrace
$LN80@ptp_init:
  00c31	33 c0		 xor	 eax, eax
  00c33	85 c0		 test	 eax, eax
  00c35	75 af		 jne	 SHORT $LN28@ptp_init
  00c37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c3d	85 c0		 test	 eax, eax
  00c3f	74 01		 je	 SHORT $LN81@ptp_init
  00c41	cc		 int	 3
$LN81@ptp_init:
$LN79@ptp_init:
  00c42	33 c0		 xor	 eax, eax
  00c44	85 c0		 test	 eax, eax
  00c46	0f 85 77 ff ff
	ff		 jne	 $LN25@ptp_init
$LN72@ptp_init:

; 551  : #endif /* OPTION_TUNTAP_SETNETMASK */
; 552  :         }
; 553  : 
; 554  : #if defined(ENABLE_IPV6)
; 555  :         if (pPTPBLK->fIPv6Spec)

  00c4c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00c51	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00c54	d1 e8		 shr	 eax, 1
  00c56	83 e0 01	 and	 eax, 1
  00c59	85 c0		 test	 eax, eax
  00c5b	0f 84 56 01 00
	00		 je	 $LN82@ptp_init
$LN31@ptp_init:

; 556  :         {
; 557  :             VERIFY( TUNTAP_SetIPAddr6( pPTPBLK->szTUNIfName,

  00c61	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00c66	48 05 98 02 00
	00		 add	 rax, 664		; 00000298H
  00c6c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00c71	48 81 c1 68 02
	00 00		 add	 rcx, 616		; 00000268H
  00c78	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  00c7d	48 81 c2 7c 01
	00 00		 add	 rdx, 380		; 0000017cH
  00c84	48 89 94 24 08
	01 00 00	 mov	 QWORD PTR tv520[rsp], rdx
  00c8c	4c 8b c0	 mov	 r8, rax
  00c8f	48 8b d1	 mov	 rdx, rcx
  00c92	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv520[rsp]
  00c9a	48 8b c8	 mov	 rcx, rax
  00c9d	e8 00 00 00 00	 call	 TUNTAP_SetIPAddr6
  00ca2	85 c0		 test	 eax, eax
  00ca4	74 5c		 je	 SHORT $LN83@ptp_init
$LN34@ptp_init:
  00ca6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170183
  00cad	41 b8 2f 02 00
	00		 mov	 r8d, 559		; 0000022fH
  00cb3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170184
  00cba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170185
  00cc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00cc7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00ccd	85 c0		 test	 eax, eax
  00ccf	74 20		 je	 SHORT $LN84@ptp_init
  00cd1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170187
  00cd8	41 b8 2f 02 00
	00		 mov	 r8d, 559		; 0000022fH
  00cde	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170188
  00ce5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170189
  00cec	e8 00 00 00 00	 call	 DebuggerTrace
$LN84@ptp_init:
  00cf1	33 c0		 xor	 eax, eax
  00cf3	85 c0		 test	 eax, eax
  00cf5	75 af		 jne	 SHORT $LN34@ptp_init
  00cf7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00cfd	85 c0		 test	 eax, eax
  00cff	74 01		 je	 SHORT $LN85@ptp_init
  00d01	cc		 int	 3
$LN85@ptp_init:
$LN83@ptp_init:
  00d02	33 c0		 xor	 eax, eax
  00d04	85 c0		 test	 eax, eax
  00d06	0f 85 55 ff ff
	ff		 jne	 $LN31@ptp_init
$LN37@ptp_init:

; 558  :                                        pPTPBLK->szDriveLLAddr6,
; 559  :                                        pPTPBLK->szDriveLLxSiz6 ) == 0 );
; 560  : 
; 561  :             VERIFY( TUNTAP_SetIPAddr6( pPTPBLK->szTUNIfName,

  00d0c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00d11	48 05 30 02 00
	00		 add	 rax, 560		; 00000230H
  00d17	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00d1c	48 81 c1 00 02
	00 00		 add	 rcx, 512		; 00000200H
  00d23	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  00d28	48 81 c2 7c 01
	00 00		 add	 rdx, 380		; 0000017cH
  00d2f	48 89 94 24 10
	01 00 00	 mov	 QWORD PTR tv542[rsp], rdx
  00d37	4c 8b c0	 mov	 r8, rax
  00d3a	48 8b d1	 mov	 rdx, rcx
  00d3d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv542[rsp]
  00d45	48 8b c8	 mov	 rcx, rax
  00d48	e8 00 00 00 00	 call	 TUNTAP_SetIPAddr6
  00d4d	85 c0		 test	 eax, eax
  00d4f	74 5c		 je	 SHORT $LN86@ptp_init
$LN40@ptp_init:
  00d51	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170192
  00d58	41 b8 33 02 00
	00		 mov	 r8d, 563		; 00000233H
  00d5e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170193
  00d65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170194
  00d6c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00d72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00d78	85 c0		 test	 eax, eax
  00d7a	74 20		 je	 SHORT $LN87@ptp_init
  00d7c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170196
  00d83	41 b8 33 02 00
	00		 mov	 r8d, 563		; 00000233H
  00d89	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170197
  00d90	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170198
  00d97	e8 00 00 00 00	 call	 DebuggerTrace
$LN87@ptp_init:
  00d9c	33 c0		 xor	 eax, eax
  00d9e	85 c0		 test	 eax, eax
  00da0	75 af		 jne	 SHORT $LN40@ptp_init
  00da2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00da8	85 c0		 test	 eax, eax
  00daa	74 01		 je	 SHORT $LN88@ptp_init
  00dac	cc		 int	 3
$LN88@ptp_init:
$LN86@ptp_init:
  00dad	33 c0		 xor	 eax, eax
  00daf	85 c0		 test	 eax, eax
  00db1	0f 85 55 ff ff
	ff		 jne	 $LN37@ptp_init
$LN82@ptp_init:
$LN43@ptp_init:

; 562  :                                        pPTPBLK->szDriveIPAddr6,
; 563  :                                        pPTPBLK->szDrivePfxSiz6 ) == 0 );
; 564  :         }
; 565  : #endif /* defined(ENABLE_IPV6) */
; 566  : 
; 567  :         VERIFY( TUNTAP_SetMTU( pPTPBLK->szTUNIfName, pPTPBLK->szMTU ) == 0 );

  00db7	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00dbc	48 05 94 01 00
	00		 add	 rax, 404		; 00000194H
  00dc2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00dc7	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  00dce	48 8b d0	 mov	 rdx, rax
  00dd1	e8 00 00 00 00	 call	 TUNTAP_SetMTU
  00dd6	85 c0		 test	 eax, eax
  00dd8	74 5c		 je	 SHORT $LN89@ptp_init
$LN46@ptp_init:
  00dda	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170201
  00de1	41 b8 37 02 00
	00		 mov	 r8d, 567		; 00000237H
  00de7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170202
  00dee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170203
  00df5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00dfb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00e01	85 c0		 test	 eax, eax
  00e03	74 20		 je	 SHORT $LN90@ptp_init
  00e05	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170205
  00e0c	41 b8 37 02 00
	00		 mov	 r8d, 567		; 00000237H
  00e12	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170206
  00e19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170207
  00e20	e8 00 00 00 00	 call	 DebuggerTrace
$LN90@ptp_init:
  00e25	33 c0		 xor	 eax, eax
  00e27	85 c0		 test	 eax, eax
  00e29	75 af		 jne	 SHORT $LN46@ptp_init
  00e2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00e31	85 c0		 test	 eax, eax
  00e33	74 01		 je	 SHORT $LN91@ptp_init
  00e35	cc		 int	 3
$LN91@ptp_init:
$LN89@ptp_init:
  00e36	33 c0		 xor	 eax, eax
  00e38	85 c0		 test	 eax, eax
  00e3a	0f 85 77 ff ff
	ff		 jne	 $LN43@ptp_init
$LN49@ptp_init:

; 568  : 
; 569  :         VERIFY( TUNTAP_SetFlags( pPTPBLK->szTUNIfName, nIFFlags ) == 0 );

  00e40	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00e45	48 05 7c 01 00
	00		 add	 rax, 380		; 0000017cH
  00e4b	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR nIFFlags$[rsp]
  00e52	48 8b c8	 mov	 rcx, rax
  00e55	e8 00 00 00 00	 call	 TUNTAP_SetFlags
  00e5a	85 c0		 test	 eax, eax
  00e5c	74 5c		 je	 SHORT $LN92@ptp_init
$LN52@ptp_init:
  00e5e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170210
  00e65	41 b8 39 02 00
	00		 mov	 r8d, 569		; 00000239H
  00e6b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170211
  00e72	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170212
  00e79	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00e7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00e85	85 c0		 test	 eax, eax
  00e87	74 20		 je	 SHORT $LN93@ptp_init
  00e89	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170214
  00e90	41 b8 39 02 00
	00		 mov	 r8d, 569		; 00000239H
  00e96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170215
  00e9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170216
  00ea4	e8 00 00 00 00	 call	 DebuggerTrace
$LN93@ptp_init:
  00ea9	33 c0		 xor	 eax, eax
  00eab	85 c0		 test	 eax, eax
  00ead	75 af		 jne	 SHORT $LN52@ptp_init
  00eaf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00eb5	85 c0		 test	 eax, eax
  00eb7	74 01		 je	 SHORT $LN94@ptp_init
  00eb9	cc		 int	 3
$LN94@ptp_init:
$LN92@ptp_init:
  00eba	33 c0		 xor	 eax, eax
  00ebc	85 c0		 test	 eax, eax
  00ebe	75 80		 jne	 SHORT $LN49@ptp_init
$LN66@ptp_init:

; 570  : 
; 571  :     }
; 572  : 
; 573  :     // Create the read thread.
; 574  :     MSGBUF( thread_name, "%s %4.4X ReadThread",

  00ec0	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00ec5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00ec9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ecd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00ed2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00ed6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00eda	4c 8b 49 50	 mov	 r9, QWORD PTR [rcx+80]
  00ede	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170218
  00ee5	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00eea	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR thread_name$[rsp]
  00ef2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 575  :                          pPTPBLK->pDEVBLKRead->typname,
; 576  :                          pPTPBLK->pDEVBLKRead->devnum);
; 577  :     rc = create_thread( &pPTPBLK->tid, JOINABLE, ptp_read_thread, pPTPBLK, thread_name );

  00ef8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00eff	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00f05	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  00f0a	48 83 c1 24	 add	 rcx, 36			; 00000024H
  00f0e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170219
  00f15	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00f1a	48 8d 94 24 78
	01 00 00	 lea	 rdx, QWORD PTR thread_name$[rsp]
  00f22	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00f27	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pPTPBLK$[rsp]
  00f2c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ptp_read_thread
  00f33	48 8b d0	 mov	 rdx, rax
  00f36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00f3c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 578  :     if (rc)

  00f43	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00f4b	0f 84 5d 01 00
	00		 je	 $LN95@ptp_init

; 579  :     {
; 580  :         // Report the bad news.
; 581  :         // HHC00102 "Error in function create_thread(): %s"
; 582  :         WRMSG(HHC00102, "E", strerror(rc));

  00f51	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  00f58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00f5e	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv650[rsp], rax
  00f66	b9 01 00 00 00	 mov	 ecx, 1
  00f6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f71	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv650[rsp]
  00f79	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f7e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170221
  00f85	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f8a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170222
  00f91	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f96	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f9b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fa1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170223
  00fa8	ba 46 02 00 00	 mov	 edx, 582		; 00000246H
  00fad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170224
  00fb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@ptp_init:

; 583  :         // Close the TUN interface.
; 584  :         VERIFY( pPTPBLK->fd == -1 || TUNTAP_Close( pPTPBLK->fd ) == 0 );

  00fba	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00fbf	83 78 20 ff	 cmp	 DWORD PTR [rax+32], -1
  00fc3	74 6d		 je	 SHORT $LN96@ptp_init
  00fc5	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  00fca	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00fcd	e8 00 00 00 00	 call	 tt32_close
  00fd2	85 c0		 test	 eax, eax
  00fd4	74 5c		 je	 SHORT $LN96@ptp_init
$LN58@ptp_init:
  00fd6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170226
  00fdd	41 b8 48 02 00
	00		 mov	 r8d, 584		; 00000248H
  00fe3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170227
  00fea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170228
  00ff1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00ff7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00ffd	85 c0		 test	 eax, eax
  00fff	74 20		 je	 SHORT $LN97@ptp_init
  01001	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170230
  01008	41 b8 48 02 00
	00		 mov	 r8d, 584		; 00000248H
  0100e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170231
  01015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170232
  0101c	e8 00 00 00 00	 call	 DebuggerTrace
$LN97@ptp_init:
  01021	33 c0		 xor	 eax, eax
  01023	85 c0		 test	 eax, eax
  01025	75 af		 jne	 SHORT $LN58@ptp_init
  01027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0102d	85 c0		 test	 eax, eax
  0102f	74 01		 je	 SHORT $LN98@ptp_init
  01031	cc		 int	 3
$LN98@ptp_init:
$LN96@ptp_init:
  01032	33 c0		 xor	 eax, eax
  01034	85 c0		 test	 eax, eax
  01036	75 82		 jne	 SHORT $LN55@ptp_init

; 585  :         pPTPBLK->fd = -1;

  01038	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0103d	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 586  :         // Disconnect the DEVGRP from the PTPBLK.
; 587  :         pDEVBLK->group->grp_data = NULL;

  01044	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0104c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01050	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 588  :         // Disconnect the DEVBLKs from the PTPATHs.
; 589  :         pPTPBLK->pDEVBLKRead->dev_data = NULL;

  01058	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0105d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01061	48 c7 80 08 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1544], 0

; 590  :         pPTPBLK->pDEVBLKWrite->dev_data = NULL;

  0106c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  01071	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01075	48 c7 80 08 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1544], 0

; 591  :         // Free the PTPATHs and PTPBLK
; 592  :         free( pPTPATHwr );

  01080	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pPTPATHwr$[rsp]
  01088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 593  :         free( pPTPATHre );

  0108e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pPTPATHre$[rsp]
  01093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 594  :         free( pPTPBLK );

  01099	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  0109e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 595  :         return -1;

  010a4	b8 ff ff ff ff	 mov	 eax, -1
  010a9	e9 2d 03 00 00	 jmp	 $LN1@ptp_init
$LN95@ptp_init:

; 596  :     }
; 597  :     pPTPBLK->pDEVBLKRead->tid = pPTPBLK->tid;

  010ae	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  010b3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  010b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  010bc	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  010bf	89 88 14 02 00
	00		 mov	 DWORD PTR [rax+532], ecx

; 598  :     pPTPBLK->pDEVBLKWrite->tid = pPTPBLK->tid;

  010c5	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  010ca	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  010ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  010d3	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  010d6	89 88 14 02 00
	00		 mov	 DWORD PTR [rax+532], ecx

; 599  : 
; 600  :     // Display various information, maybe
; 601  :     if (pPTPBLK->uDebugMask & DBGPTPCONFVALUE)

  010dc	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  010e1	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  010e4	25 80 00 00 00	 and	 eax, 128		; 00000080H
  010e9	85 c0		 test	 eax, eax
  010eb	0f 84 e8 02 00
	00		 je	 $LN99@ptp_init

; 602  :     {
; 603  : #if defined(OPTION_W32_CTCI)
; 604  :         // HHC03952 "%1d:%04X PTP: MAC: %s"
; 605  :         WRMSG(HHC03952, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  010f1	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  010f6	48 05 9c 01 00
	00		 add	 rax, 412		; 0000019cH
  010fc	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv733[rsp], rax
  01104	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0110c	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01110	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv736[rsp], ecx
  01117	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0111f	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  01123	d1 fa		 sar	 edx, 1
  01125	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv740[rsp], edx
  0112c	b9 01 00 00 00	 mov	 ecx, 1
  01131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01137	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv733[rsp]
  0113f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01144	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv736[rsp]
  0114b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0114f	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv740[rsp]
  01156	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0115a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170235
  01161	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170236
  0116d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01172	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01177	41 b9 03 00 00
	00		 mov	 r9d, 3
  0117d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170237
  01184	ba 5e 02 00 00	 mov	 edx, 606		; 0000025eH
  01189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170238
  01190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 606  :             pPTPBLK->szMACAddress );
; 607  : #endif /* defined(OPTION_W32_CTCI) */
; 608  : #if defined(ENABLE_IPV6)
; 609  :         if (pPTPBLK->fIPv4Spec)

  01196	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  0119b	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0119e	83 e0 01	 and	 eax, 1
  011a1	85 c0		 test	 eax, eax
  011a3	0f 84 fd 00 00
	00		 je	 $LN100@ptp_init

; 610  :         {
; 611  : #endif /* defined(ENABLE_IPV6) */
; 612  :             // HHC03953 "%1d:%04X PTP: IPv4: Drive %s/%s (%s): Guest %s"
; 613  :             WRMSG(HHC03953, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  011a9	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  011ae	48 05 ec 01 00
	00		 add	 rax, 492		; 000001ecH
  011b4	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv754[rsp], rax
  011bc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  011c1	48 81 c1 d8 01
	00 00		 add	 rcx, 472		; 000001d8H
  011c8	48 89 8c 24 30
	01 00 00	 mov	 QWORD PTR tv756[rsp], rcx
  011d0	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  011d5	48 81 c2 d0 01
	00 00		 add	 rdx, 464		; 000001d0H
  011dc	48 89 94 24 38
	01 00 00	 mov	 QWORD PTR tv758[rsp], rdx
  011e4	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pPTPBLK$[rsp]
  011e9	48 81 c7 bc 01
	00 00		 add	 rdi, 444		; 000001bcH
  011f0	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  011f8	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  011fd	44 89 84 24 ac
	00 00 00	 mov	 DWORD PTR tv763[rsp], r8d
  01205	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR pDEVBLK$[rsp]
  0120d	45 0f b7 49 44	 movzx	 r9d, WORD PTR [r9+68]
  01212	41 d1 f9	 sar	 r9d, 1
  01215	44 89 8c 24 b0
	00 00 00	 mov	 DWORD PTR tv767[rsp], r9d
  0121d	b9 01 00 00 00	 mov	 ecx, 1
  01222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01228	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv754[rsp]
  01230	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01235	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv756[rsp]
  0123d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01242	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv758[rsp]
  0124a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0124f	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  01254	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv763[rsp]
  0125b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0125f	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv767[rsp]
  01266	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0126a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170240
  01271	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170241
  0127d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01282	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01287	41 b9 03 00 00
	00		 mov	 r9d, 3
  0128d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170242
  01294	ba 69 02 00 00	 mov	 edx, 617		; 00000269H
  01299	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170243
  012a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN100@ptp_init:

; 614  :                 pPTPBLK->szDriveIPAddr4,
; 615  :                 pPTPBLK->szDrivePfxSiz4,
; 616  :                 pPTPBLK->szNetMask,
; 617  :                 pPTPBLK->szGuestIPAddr4 );
; 618  : #if defined(ENABLE_IPV6)
; 619  :         }
; 620  :         if (pPTPBLK->fIPv6Spec)

  012a6	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  012ab	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  012ae	d1 e8		 shr	 eax, 1
  012b0	83 e0 01	 and	 eax, 1
  012b3	85 c0		 test	 eax, eax
  012b5	0f 84 1e 01 00
	00		 je	 $LN101@ptp_init

; 621  :         {
; 622  :             // HHC03954 "%1d:%04X PTP: IPv6: Drive %s/%s %s/%s: Guest %s"
; 623  :             WRMSG(HHC03954, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  012bb	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTPBLK$[rsp]
  012c0	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  012c6	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv782[rsp], rax
  012ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPTPBLK$[rsp]
  012d3	48 81 c1 30 02
	00 00		 add	 rcx, 560		; 00000230H
  012da	48 89 8c 24 48
	01 00 00	 mov	 QWORD PTR tv784[rsp], rcx
  012e2	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPTPBLK$[rsp]
  012e7	48 81 c2 00 02
	00 00		 add	 rdx, 512		; 00000200H
  012ee	48 89 94 24 50
	01 00 00	 mov	 QWORD PTR tv786[rsp], rdx
  012f6	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pPTPBLK$[rsp]
  012fb	48 81 c7 98 02
	00 00		 add	 rdi, 664		; 00000298H
  01302	4c 8b 44 24 70	 mov	 r8, QWORD PTR pPTPBLK$[rsp]
  01307	49 81 c0 68 02
	00 00		 add	 r8, 616			; 00000268H
  0130e	4c 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv790[rsp], r8
  01316	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR pDEVBLK$[rsp]
  0131e	45 0f b7 49 48	 movzx	 r9d, WORD PTR [r9+72]
  01323	44 89 8c 24 b4
	00 00 00	 mov	 DWORD PTR tv793[rsp], r9d
  0132b	4c 8b 94 24 b0
	01 00 00	 mov	 r10, QWORD PTR pDEVBLK$[rsp]
  01333	45 0f b7 52 44	 movzx	 r10d, WORD PTR [r10+68]
  01338	41 d1 fa	 sar	 r10d, 1
  0133b	44 89 94 24 b8
	00 00 00	 mov	 DWORD PTR tv797[rsp], r10d
  01343	b9 01 00 00 00	 mov	 ecx, 1
  01348	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0134e	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv782[rsp]
  01356	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0135b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv784[rsp]
  01363	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01368	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv786[rsp]
  01370	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01375	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0137a	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv790[rsp]
  01382	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01387	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv793[rsp]
  0138e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01392	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv797[rsp]
  01399	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0139d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170245
  013a4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170246
  013b0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013ba	41 b9 03 00 00
	00		 mov	 r9d, 3
  013c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170247
  013c7	ba 74 02 00 00	 mov	 edx, 628		; 00000274H
  013cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170248
  013d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN101@ptp_init:
$LN99@ptp_init:

; 624  :                 pPTPBLK->szDriveLLAddr6,
; 625  :                 pPTPBLK->szDriveLLxSiz6,
; 626  :                 pPTPBLK->szDriveIPAddr6,
; 627  :                 pPTPBLK->szDrivePfxSiz6,
; 628  :                 pPTPBLK->szGuestIPAddr6 );
; 629  :         }
; 630  : #endif /* defined(ENABLE_IPV6) */
; 631  :     }
; 632  : 
; 633  :     return 0;

  013d9	33 c0		 xor	 eax, eax
$LN1@ptp_init:

; 634  : }   /* End function  ptp_init() */

  013db	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  013e3	48 33 cc	 xor	 rcx, rsp
  013e6	e8 00 00 00 00	 call	 __security_check_cookie
  013eb	48 81 c4 a0 01
	00 00		 add	 rsp, 416		; 000001a0H
  013f2	5f		 pop	 rdi
  013f3	c3		 ret	 0
ptp_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.h
_TEXT	SEGMENT
pSIDInfo$ = 0
pDEVBLK$ = 32
wCUType$ = 40
bCUMod$ = 48
wDevType$ = 56
bDevMod$ = 64
SetSIDInfo PROC

; 1343 : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	57		 push	 rdi
  00016	48 83 ec 10	 sub	 rsp, 16

; 1344 :     BYTE* pSIDInfo = pDEVBLK->devid;

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001f	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  00025	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1345 : 
; 1346 :     memset( pSIDInfo, 0, sizeof(pDEVBLK->devid) );

  00029	48 8b 3c 24	 mov	 rdi, QWORD PTR pSIDInfo$[rsp]
  0002d	33 c0		 xor	 eax, eax
  0002f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00034	f3 aa		 rep stosb

; 1347 : 
; 1348 :     *pSIDInfo++ = 0x0FF;

  00036	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0003a	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  0003d	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00041	48 ff c0	 inc	 rax
  00044	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1349 :     *pSIDInfo++ = (BYTE)(( wCUType >> 8 ) & 0x00FF );

  00048	0f b7 44 24 28	 movzx	 eax, WORD PTR wCUType$[rsp]
  0004d	c1 f8 08	 sar	 eax, 8
  00050	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00055	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00059	88 01		 mov	 BYTE PTR [rcx], al
  0005b	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0005f	48 ff c0	 inc	 rax
  00062	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1350 :     *pSIDInfo++ = (BYTE)( wCUType & 0x00FF );

  00066	0f b7 44 24 28	 movzx	 eax, WORD PTR wCUType$[rsp]
  0006b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00070	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00074	88 01		 mov	 BYTE PTR [rcx], al
  00076	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0007a	48 ff c0	 inc	 rax
  0007d	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1351 :     *pSIDInfo++ = bCUMod;

  00081	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00085	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR bCUMod$[rsp]
  0008a	88 08		 mov	 BYTE PTR [rax], cl
  0008c	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1352 :     *pSIDInfo++ = (BYTE)(( wDevType >> 8 ) & 0x00FF );

  00097	0f b7 44 24 38	 movzx	 eax, WORD PTR wDevType$[rsp]
  0009c	c1 f8 08	 sar	 eax, 8
  0009f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a4	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000a8	88 01		 mov	 BYTE PTR [rcx], al
  000aa	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000ae	48 ff c0	 inc	 rax
  000b1	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1353 :     *pSIDInfo++ = (BYTE)( wDevType & 0x00FF );

  000b5	0f b7 44 24 38	 movzx	 eax, WORD PTR wDevType$[rsp]
  000ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bf	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000c3	88 01		 mov	 BYTE PTR [rcx], al
  000c5	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000c9	48 ff c0	 inc	 rax
  000cc	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1354 :     *pSIDInfo++ = bDevMod;

  000d0	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000d4	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR bDevMod$[rsp]
  000d9	88 08		 mov	 BYTE PTR [rax], cl
  000db	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000df	48 ff c0	 inc	 rax
  000e2	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1355 :     *pSIDInfo++ = 0x00;

  000e6	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000ea	c6 00 00	 mov	 BYTE PTR [rax], 0
  000ed	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000f1	48 ff c0	 inc	 rax
  000f4	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1356 : 
; 1357 :     pDEVBLK->numdevid = 7;

  000f8	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000fd	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 1358 : }

  00107	48 83 c4 10	 add	 rsp, 16
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
SetSIDInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_f3_noswap
_TEXT	SEGMENT
ptr$ = 24
value$ = 32
store_f3_noswap PROC					; COMDAT

; 799  :     inline void store_f3_noswap(void *ptr, U32 value) {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi

; 800  :       value >>= 8;

  0000b	8b 44 24 20	 mov	 eax, DWORD PTR value$[rsp]
  0000f	c1 e8 08	 shr	 eax, 8
  00012	89 44 24 20	 mov	 DWORD PTR value$[rsp], eax

; 801  :       memcpy((BYTE *)ptr, ((BYTE *)&value), 3);

  00016	48 8d 44 24 20	 lea	 rax, QWORD PTR value$[rsp]
  0001b	48 8b 7c 24 18	 mov	 rdi, QWORD PTR ptr$[rsp]
  00020	48 8b f0	 mov	 rsi, rax
  00023	b9 03 00 00 00	 mov	 ecx, 3
  00028	f3 a4		 rep movsb

; 802  :     }

  0002a	5f		 pop	 rdi
  0002b	5e		 pop	 rsi
  0002c	c3		 ret	 0
store_f3_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_f3_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 48
fetch_f3_noswap PROC					; COMDAT

; 780  :     inline U32 fetch_f3_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 18	 sub	 rsp, 24

; 781  :       U32 value;
; 782  :       memcpy(((BYTE *)&value), (BYTE *)ptr, 3);

  0000b	48 8d 04 24	 lea	 rax, QWORD PTR value$[rsp]
  0000f	48 8b f8	 mov	 rdi, rax
  00012	48 8b 74 24 30	 mov	 rsi, QWORD PTR ptr$[rsp]
  00017	b9 03 00 00 00	 mov	 ecx, 3
  0001c	f3 a4		 rep movsb

; 783  :       value <<= 8;

  0001e	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]
  00021	c1 e0 08	 shl	 eax, 8
  00024	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 784  :       return value;

  00027	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 785  :     }

  0002a	48 83 c4 18	 add	 rsp, 24
  0002e	5f		 pop	 rdi
  0002f	5e		 pop	 rsi
  00030	c3		 ret	 0
fetch_f3_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
ETOD$ = 8
ETOD2TOD PROC

; 205  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 206  :     return ((ETOD.high << 8) | (ETOD.low >> (64-8)));

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0000e	48 c1 e0 08	 shl	 rax, 8
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  0001e	48 0b c1	 or	 rax, rcx

; 207  : }

  00021	c3		 ret	 0
ETOD2TOD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
