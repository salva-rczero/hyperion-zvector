; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	gen_dasd_serial
PUBLIC	build_vol1
PUBLIC	data_dump
PUBLIC	data_dump_ascii
PUBLIC	data_dump_offset
PUBLIC	data_dump_offset_ascii
PUBLIC	read_track
PUBLIC	read_block
PUBLIC	search_key_equal
PUBLIC	convert_tt
PUBLIC	open_ckd_image
PUBLIC	open_fba_image
PUBLIC	close_ckd_image
PUBLIC	build_extent_array
PUBLIC	capacity_calc
PUBLIC	create_ckd
PUBLIC	create_fba
PUBLIC	create_compressed_fba
PUBLIC	set_verbose_util
PUBLIC	is_verbose_util
PUBLIC	next_util_devnum
PUBLIC	valid_dsname
PUBLIC	ckd_tracklen
PUBLIC	dh_devid_str
PUBLIC	dh_devid_typ
PUBLIC	is_dh_devid_typ
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	__imp_isprint:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strrchr:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp__chsize_s:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_convert_to_ebcdic:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	dasd_lookup:PROC
EXTRN	cckd_def_opt_bigend:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	open_ckd64_image:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	ckd_dasd_device_hndinfo:BYTE
EXTRN	fba_dasd_device_hndinfo:BYTE
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
verbose	DB	01H DUP (?)
	ALIGN	4

nextnum	DD	01H DUP (?)
?prev@?1??gen_dasd_serial@@9@9 DB 0dH DUP (?)		; `gen_dasd_serial'::`2'::prev
	ALIGN	4

$SG168670 DB	01H DUP (?)
	ALIGN	4

$SG168671 DB	01H DUP (?)
	ALIGN	4

$SG168672 DB	01H DUP (?)
	ALIGN	4

$SG168673 DB	01H DUP (?)
	ALIGN	4

$SG168674 DB	01H DUP (?)
	ALIGN	4

$SG169684 DB	01H DUP (?)
	ALIGN	4

$SG169710 DB	01H DUP (?)
	ALIGN	4

$SG169788 DB	01H DUP (?)
	ALIGN	4

$SG169961 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$gen_dasd_serial DD imagerel $LN11
	DD	imagerel $LN11+225
	DD	imagerel $unwind$gen_dasd_serial
$pdata$build_vol1 DD imagerel $LN6
	DD	imagerel $LN6+565
	DD	imagerel $unwind$build_vol1
$pdata$data_dump DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$data_dump
$pdata$data_dump_ascii DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$data_dump_ascii
$pdata$data_dump_offset DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$data_dump_offset
$pdata$data_dump_offset_ascii DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$data_dump_offset_ascii
$pdata$read_track DD imagerel $LN9
	DD	imagerel $LN9+1123
	DD	imagerel $unwind$read_track
$pdata$read_block DD imagerel $LN12
	DD	imagerel $LN12+377
	DD	imagerel $unwind$read_block
$pdata$search_key_equal DD imagerel $LN17
	DD	imagerel $LN17+1808
	DD	imagerel $unwind$search_key_equal
$pdata$convert_tt DD imagerel $LN7
	DD	imagerel $LN7+675
	DD	imagerel $unwind$convert_tt
$pdata$open_ckd_image DD imagerel $LN38
	DD	imagerel $LN38+3205
	DD	imagerel $unwind$open_ckd_image
$pdata$open_fba_image DD imagerel $LN15
	DD	imagerel $LN15+1488
	DD	imagerel $unwind$open_fba_image
$pdata$close_ckd_image DD imagerel $LN7
	DD	imagerel $LN7+593
	DD	imagerel $unwind$close_ckd_image
$pdata$build_extent_array DD imagerel $LN17
	DD	imagerel $LN17+3643
	DD	imagerel $unwind$build_extent_array
$pdata$capacity_calc DD imagerel $LN35
	DD	imagerel $LN35+1655
	DD	imagerel $unwind$capacity_calc
$pdata$create_ckd DD imagerel $LN33
	DD	imagerel $LN33+2383
	DD	imagerel $unwind$create_ckd
$pdata$create_fba DD imagerel $LN28
	DD	imagerel $LN28+2433
	DD	imagerel $unwind$create_fba
$pdata$create_compressed_fba DD imagerel $LN37
	DD	imagerel $LN37+3911
	DD	imagerel $unwind$create_compressed_fba
$pdata$next_util_devnum DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$next_util_devnum
$pdata$valid_dsname DD imagerel $LN24
	DD	imagerel $LN24+246
	DD	imagerel $unwind$valid_dsname
$pdata$ckd_tracklen DD imagerel $LN5
	DD	imagerel $LN5+212
	DD	imagerel $unwind$ckd_tracklen
$pdata$dh_devid_typ DD imagerel $LN13
	DD	imagerel $LN13+377
	DD	imagerel $unwind$dh_devid_typ
$pdata$is_dh_devid_typ DD imagerel $LN16
	DD	imagerel $LN16+879
	DD	imagerel $unwind$is_dh_devid_typ
$pdata$same_as_above DD imagerel same_as_above
	DD	imagerel same_as_above+151
	DD	imagerel $unwind$same_as_above
$pdata$do_data_dump DD imagerel do_data_dump
	DD	imagerel do_data_dump+800
	DD	imagerel $unwind$do_data_dump
$pdata$create_ckd_file DD imagerel create_ckd_file
	DD	imagerel create_ckd_file+7995
	DD	imagerel $unwind$create_ckd_file
pdata	ENDS
_DATA	SEGMENT
$SG168667 DB	'** HERCULES **', 00H
	ORG $+1
$SG168690 DB	'Line %4.4X same as above', 0aH, 00H
	ORG $+2
$SG168777 DB	'I', 00H
	ORG $+2
$SG168691 DB	'Lines %4.4X to %4.4X same as above', 0aH, 00H
$SG168782 DB	'E', 00H
	ORG $+2
$SG168692 DB	'+%4.4X %s %s', 0aH, 00H
	ORG $+2
$SG168730 DB	'%2.2X', 00H
	ORG $+2
$SG168737 DB	'Lines %4.4X to %4.4X suppressed', 0aH, 00H
	ORG $+3
$SG168787 DB	'I', 00H
	ORG $+2
$SG168778 DB	'HHC00445%s %1d:%04X CKD file %s: updating cyl %d head %d'
	DB	0aH, 00H
	ORG $+2
$SG168792 DB	'E', 00H
	ORG $+2
$SG168779 DB	'read_track', 00H
	ORG $+1
$SG168881 DB	'I', 00H
	ORG $+2
$SG168780 DB	'dasdutil.c', 00H
	ORG $+5
$SG168793 DB	'HHC00448%s %1d:%04X CKD file %s: read track error: stat '
	DB	'%2.2X', 0aH, 00H
	ORG $+1
$SG168883 DB	'search_key_equal', 00H
	ORG $+7
$SG168783 DB	'HHC00446%s %1d:%04X CKD file %s: write track error: stat'
	DB	' %2.2X', 0aH, 00H
$SG168784 DB	'read_track', 00H
	ORG $+1
$SG168893 DB	'I', 00H
	ORG $+2
$SG168785 DB	'dasdutil.c', 00H
	ORG $+1
$SG168923 DB	'E', 00H
	ORG $+2
$SG168788 DB	'HHC00447%s %1d:%04X CKD file %s: reading cyl %d head %d', 0aH
	DB	00H
	ORG $+3
$SG168990 DB	'E', 00H
	ORG $+2
$SG168789 DB	'read_track', 00H
	ORG $+1
$SG169004 DB	'_1', 00H
	ORG $+1
$SG168790 DB	'dasdutil.c', 00H
	ORG $+1
$SG169007 DB	'_1', 00H
	ORG $+1
$SG168794 DB	'read_track', 00H
	ORG $+1
$SG169011 DB	'E', 00H
	ORG $+2
$SG168795 DB	'dasdutil.c', 00H
	ORG $+5
$SG168882 DB	'HHC00449%s %1d:%04X CKD file %s: searching extent %d beg'
	DB	'in %d,%d end %d,%d', 0aH, 00H
$SG169019 DB	'E', 00H
	ORG $+2
$SG168884 DB	'dasdutil.c', 00H
	ORG $+5
$SG168894 DB	'HHC00449%s %1d:%04X CKD file %s: searching extent %d beg'
	DB	'in %d,%d end %d,%d', 0aH, 00H
$SG169026 DB	'E', 00H
	ORG $+2
$SG168895 DB	'search_key_equal', 00H
	ORG $+3
$SG169010 DB	'open()', 00H
	ORG $+1
$SG169031 DB	'E', 00H
	ORG $+2
$SG168896 DB	'dasdutil.c', 00H
	ORG $+1
$SG169039 DB	'E', 00H
	ORG $+2
$SG168924 DB	'HHC00450%s Track %d not found in extent table', 0aH, 00H
	ORG $+1
$SG168925 DB	'convert_tt', 00H
	ORG $+1
$SG169045 DB	'I', 00H
	ORG $+2
$SG168926 DB	'dasdutil.c', 00H
	ORG $+1
$SG169060 DB	'I', 00H
	ORG $+2
$SG168989 DB	'calloc(1,%d)', 00H
	ORG $+3
$SG168991 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169065 DB	'E', 00H
	ORG $+2
$SG168992 DB	'open_ckd_image', 00H
	ORG $+1
$SG168993 DB	'dasdutil.c', 00H
	ORG $+1
$SG169101 DB	'E', 00H
	ORG $+2
$SG169012 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169107 DB	'E', 00H
	ORG $+2
$SG169013 DB	'open_ckd_image', 00H
	ORG $+1
$SG169014 DB	'dasdutil.c', 00H
	ORG $+1
$SG169018 DB	'read()', 00H
	ORG $+1
$SG169114 DB	'E', 00H
	ORG $+2
$SG169020 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169119 DB	'I', 00H
	ORG $+2
$SG169021 DB	'open_ckd_image', 00H
	ORG $+1
$SG169022 DB	'dasdutil.c', 00H
	ORG $+1
$SG169158 DB	'E', 00H
	ORG $+2
$SG169027 DB	'HHC00406%s %1d:%04X CKD file %s: ckd header invalid', 0aH
	DB	00H
	ORG $+3
$SG169028 DB	'open_ckd_image', 00H
	ORG $+1
$SG169029 DB	'dasdutil.c', 00H
	ORG $+5
$SG169032 DB	'HHC00451%s %1d:%04X CKD file %s: DASD table entry not fo'
	DB	'und for devtype 0x%2.2X', 0aH, 00H
	ORG $+3
$SG169035 DB	'%4.4X', 00H
	ORG $+2
$SG169038 DB	'(null)', 00H
	ORG $+1
$SG169163 DB	'I', 00H
	ORG $+2
$SG169033 DB	'open_ckd_image', 00H
	ORG $+1
$SG169034 DB	'dasdutil.c', 00H
	ORG $+1
$SG169170 DB	'E', 00H
	ORG $+2
$SG169040 DB	'HHC00452%s %1d:%04X CKD file %s: initialization failed', 0aH
	DB	00H
$SG169041 DB	'open_ckd_image', 00H
	ORG $+1
$SG169042 DB	'dasdutil.c', 00H
	ORG $+1
$SG169175 DB	'I', 00H
	ORG $+2
$SG169046 DB	'HHC00453%s %1d:%04X CKD file %s: heads %d trklen %d', 0aH
	DB	00H
	ORG $+3
$SG169047 DB	'open_ckd_image', 00H
	ORG $+1
$SG169048 DB	'dasdutil.c', 00H
	ORG $+1
$SG169181 DB	'E', 00H
	ORG $+2
$SG169061 DB	'HHC00445%s %1d:%04X CKD file %s: updating cyl %d head %d'
	DB	0aH, 00H
	ORG $+2
$SG169113 DB	'(null)', 00H
	ORG $+1
$SG169186 DB	'I', 00H
	ORG $+2
$SG169062 DB	'close_ckd_image', 00H
$SG169063 DB	'dasdutil.c', 00H
	ORG $+5
$SG169066 DB	'HHC00446%s %1d:%04X CKD file %s: write track error: stat'
	DB	' %2.2X', 0aH, 00H
$SG169067 DB	'close_ckd_image', 00H
$SG169068 DB	'dasdutil.c', 00H
	ORG $+1
$SG169193 DB	'E', 00H
	ORG $+2
$SG169100 DB	'calloc(1,%d)', 00H
	ORG $+3
$SG169102 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169201 DB	'E', 00H
	ORG $+2
$SG169103 DB	'open_fba_image', 00H
	ORG $+1
$SG169104 DB	'dasdutil.c', 00H
	ORG $+5
$SG169108 DB	'HHC00451%s %1d:%04X CKD file %s: DASD table entry not fo'
	DB	'und for devtype 0x%2.2X', 0aH, 00H
	ORG $+3
$SG169169 DB	'F4DSCB', 00H
	ORG $+1
$SG169480 DB	'E', 00H
	ORG $+2
$SG169109 DB	'open_fba_image', 00H
	ORG $+1
$SG169110 DB	'dasdutil.c', 00H
	ORG $+1
$SG169493 DB	'E', 00H
	ORG $+2
$SG169115 DB	'HHC00452%s %1d:%04X CKD file %s: initialization failed', 0aH
	DB	00H
$SG169116 DB	'open_fba_image', 00H
	ORG $+1
$SG169117 DB	'dasdutil.c', 00H
	ORG $+1
$SG169502 DB	'E', 00H
	ORG $+2
$SG169120 DB	'HHC00454%s %1d:%04X FBA file %s: sectors %d size %d', 0aH
	DB	00H
	ORG $+3
$SG169121 DB	'open_fba_image', 00H
	ORG $+1
$SG169122 DB	'dasdutil.c', 00H
	ORG $+1
$SG169157 DB	'VOL1', 00H
	ORG $+3
$SG169192 DB	'F1DSCB', 00H
	ORG $+1
$SG169511 DB	'E', 00H
	ORG $+2
$SG169159 DB	'HHC00455%s %1d:%04X CKD file %s: %s record not found', 0aH
	DB	00H
	ORG $+2
$SG169160 DB	'build_extent_array', 00H
	ORG $+1
$SG169517 DB	'E', 00H
	ORG $+2
$SG169161 DB	'dasdutil.c', 00H
	ORG $+5
$SG169164 DB	'HHC00456%s %1d:%04X CKD file %s: VOLSER %s VTOC %4.4X%4.'
	DB	'4X%2.2X', 0aH, 00H
	ORG $+3
$SG169200 DB	'F3DSCB', 00H
	ORG $+1
$SG169524 DB	'E', 00H
	ORG $+2
$SG169165 DB	'build_extent_array', 00H
	ORG $+1
$SG169531 DB	'E', 00H
	ORG $+2
$SG169166 DB	'dasdutil.c', 00H
	ORG $+1
$SG169562 DB	'E', 00H
	ORG $+2
$SG169171 DB	'HHC00455%s %1d:%04X CKD file %s: %s record not found', 0aH
	DB	00H
	ORG $+2
$SG169172 DB	'build_extent_array', 00H
	ORG $+1
$SG169571 DB	'E', 00H
	ORG $+2
$SG169173 DB	'dasdutil.c', 00H
	ORG $+5
$SG169177 DB	'build_extent_array', 00H
	ORG $+5
$SG169176 DB	'HHC00457%s %1d:%04X CKD file %s: VTOC start %2.2X%2.2X%2'
	DB	'.2X%2.2X end %2.2X%2.2X%2.2X%2.2X', 0aH, 00H
	ORG $+1
$SG169578 DB	'E', 00H
	ORG $+2
$SG169178 DB	'dasdutil.c', 00H
	ORG $+1
$SG169584 DB	'E', 00H
	ORG $+2
$SG169182 DB	'HHC00458%s %1d:%04X CKD file %s: dataset %s not found in'
	DB	' VTOC', 0aH, 00H
	ORG $+1
$SG169183 DB	'build_extent_array', 00H
	ORG $+1
$SG169591 DB	'E', 00H
	ORG $+2
$SG169184 DB	'dasdutil.c', 00H
	ORG $+5
$SG169188 DB	'build_extent_array', 00H
	ORG $+5
$SG169187 DB	'HHC00459%s %1d:%04X CKD file %s: DSNAME %s F1DSCB CCHHR='
	DB	'%4.4X%4.4X%2.2X', 0aH, 00H
	ORG $+3
$SG169492 DB	'open()', 00H
	ORG $+1
$SG169597 DB	'E', 00H
	ORG $+2
$SG169189 DB	'dasdutil.c', 00H
	ORG $+1
$SG169602 DB	'I', 00H
	ORG $+2
$SG169194 DB	'HHC00455%s %1d:%04X CKD file %s: %s record not found', 0aH
	DB	00H
	ORG $+2
$SG169195 DB	'build_extent_array', 00H
	ORG $+1
$SG169677 DB	'W', 00H
	ORG $+2
$SG169196 DB	'dasdutil.c', 00H
	ORG $+1
$SG169686 DB	'W', 00H
	ORG $+2
$SG169202 DB	'HHC00455%s %1d:%04X CKD file %s: %s record not found', 0aH
	DB	00H
	ORG $+2
$SG169203 DB	'build_extent_array', 00H
	ORG $+1
$SG169695 DB	'I', 00H
	ORG $+2
$SG169204 DB	'dasdutil.c', 00H
	ORG $+5
$SG169482 DB	'create_ckd_file', 00H
$SG169501 DB	'write()', 00H
$SG169481 DB	'HHC00415%s %1d:%04X CKD file %s: device type %4.4X not f'
	DB	'ound in dasd table', 0aH, 00H
$SG169700 DB	'E', 00H
	ORG $+2
$SG169483 DB	'dasdutil.c', 00H
	ORG $+1
$SG169706 DB	'E', 00H
	ORG $+2
$SG169494 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169711 DB	'I', 00H
	ORG $+2
$SG169495 DB	'create_ckd_file', 00H
$SG169496 DB	'dasdutil.c', 00H
	ORG $+1
$SG169721 DB	'_1', 00H
	ORG $+1
$SG169500 DB	'incomplete', 00H
	ORG $+1
$SG169724 DB	'_1', 00H
	ORG $+1
$SG169503 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169773 DB	'W', 00H
	ORG $+2
$SG169504 DB	'create_ckd_file', 00H
$SG169505 DB	'dasdutil.c', 00H
	ORG $+1
$SG169778 DB	'E', 00H
	ORG $+2
$SG169509 DB	'incomplete', 00H
	ORG $+1
$SG169784 DB	'E', 00H
	ORG $+2
$SG169510 DB	'write()', 00H
$SG169512 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169789 DB	'I', 00H
	ORG $+2
$SG169513 DB	'create_ckd_file', 00H
$SG169514 DB	'dasdutil.c', 00H
	ORG $+1
$SG169796 DB	'E', 00H
	ORG $+2
$SG169516 DB	'calloc(%d,%d)', 00H
	ORG $+2
$SG169518 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169802 DB	'I', 00H
	ORG $+2
$SG169519 DB	'create_ckd_file', 00H
$SG169520 DB	'dasdutil.c', 00H
	ORG $+1
$SG169808 DB	'E', 00H
	ORG $+2
$SG169522 DB	'incomplete', 00H
	ORG $+1
$SG169822 DB	'E', 00H
	ORG $+2
$SG169523 DB	'write()', 00H
$SG169525 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169828 DB	'E', 00H
	ORG $+2
$SG169526 DB	'create_ckd_file', 00H
$SG169527 DB	'dasdutil.c', 00H
	ORG $+1
$SG169833 DB	'I', 00H
	ORG $+2
$SG169529 DB	'incomplete', 00H
	ORG $+1
$SG169950 DB	'E', 00H
	ORG $+2
$SG169530 DB	'write()', 00H
$SG169532 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169957 DB	'E', 00H
	ORG $+2
$SG169533 DB	'create_ckd_file', 00H
$SG169534 DB	'dasdutil.c', 00H
	ORG $+1
$SG169962 DB	'I', 00H
	ORG $+2
$SG169540 DB	'CYL=%u', 0aH, 00H
$SG169541 DB	'Writing cylinder %u', 0dH, 00H
	ORG $+3
$SG169544 DB	'IPL1', 00H
	ORG $+3
$SG169547 DB	'IPL2', 00H
	ORG $+3
$SG169548 DB	'VOL1', 00H
	ORG $+3
$SG169560 DB	'incomplete', 00H
	ORG $+1
$SG169969 DB	'E', 00H
	ORG $+2
$SG169561 DB	'write()', 00H
$SG169563 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169977 DB	'E', 00H
	ORG $+2
$SG169564 DB	'create_ckd_file', 00H
$SG169565 DB	'dasdutil.c', 00H
	ORG $+1
$SG169984 DB	'E', 00H
	ORG $+2
$SG169570 DB	'lseek()', 00H
$SG169572 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169991 DB	'E', 00H
	ORG $+2
$SG169573 DB	'create_ckd_file', 00H
$SG169574 DB	'dasdutil.c', 00H
	ORG $+1
$SG169999 DB	'E', 00H
	ORG $+2
$SG169576 DB	'incomplete', 00H
	ORG $+1
$SG170005 DB	'E', 00H
	ORG $+2
$SG169577 DB	'write()', 00H
$SG169579 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170012 DB	'E', 00H
	ORG $+2
$SG169580 DB	'create_ckd_file', 00H
$SG169581 DB	'dasdutil.c', 00H
	ORG $+1
$SG170018 DB	'E', 00H
	ORG $+2
$SG169583 DB	'lseek()', 00H
$SG169585 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170025 DB	'E', 00H
	ORG $+2
$SG169586 DB	'create_ckd_file', 00H
$SG169587 DB	'dasdutil.c', 00H
	ORG $+1
$SG170031 DB	'E', 00H
	ORG $+2
$SG169589 DB	'incomplete', 00H
	ORG $+1
$SG170036 DB	'I', 00H
	ORG $+2
$SG169590 DB	'write()', 00H
$SG169592 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169593 DB	'create_ckd_file', 00H
$SG169594 DB	'dasdutil.c', 00H
	ORG $+5
$SG169596 DB	'close()', 00H
$SG169598 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169599 DB	'create_ckd_file', 00H
$SG169600 DB	'dasdutil.c', 00H
	ORG $+5
$SG169601 DB	'cylinders', 00H
	ORG $+6
$SG169603 DB	'HHC00460%s %1d:%04X CKD file %s: %u %s successfully writ'
	DB	'ten', 0aH, 00H
	ORG $+3
$SG169604 DB	'create_ckd_file', 00H
$SG169605 DB	'dasdutil.c', 00H
	ORG $+5
$SG169676 DB	'cylinders', 00H
	ORG $+6
$SG169678 DB	'HHC00467%s Maximum %s supported is %u', 0aH, 00H
	ORG $+1
$SG169679 DB	'create_ckd', 00H
	ORG $+5
$SG169680 DB	'dasdutil.c', 00H
	ORG $+5
$SG169685 DB	'cylinders', 00H
	ORG $+6
$SG169687 DB	'HHC00466%s Maximum of %u %s in %u 2GB file(s) is support'
	DB	'ed', 0aH, 00H
	ORG $+4
$SG169688 DB	'create_ckd', 00H
	ORG $+5
$SG169689 DB	'dasdutil.c', 00H
	ORG $+5
$SG169692 DB	'related options', 00H
$SG169693 DB	'option', 00H
	ORG $+1
$SG169694 DB	'-lfs%s %s', 00H
	ORG $+6
$SG169696 DB	'HHC00468%s For larger capacity DASD volumes, use %s', 0aH
	DB	00H
	ORG $+3
$SG169697 DB	'create_ckd', 00H
	ORG $+5
$SG169698 DB	'dasdutil.c', 00H
	ORG $+5
$SG169699 DB	'cylinder', 00H
	ORG $+7
$SG169702 DB	'create_ckd', 00H
	ORG $+5
$SG169772 DB	'sectors', 00H
$SG169701 DB	'HHC00461%s %1d:%04X CKD file %s: %s count %u is outside '
	DB	'range %u-%u', 0aH, 00H
	ORG $+3
$SG169703 DB	'dasdutil.c', 00H
	ORG $+5
$SG169705 DB	'malloc(%u)', 00H
	ORG $+5
$SG169707 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169708 DB	'create_ckd', 00H
	ORG $+5
$SG169709 DB	'dasdutil.c', 00H
	ORG $+1
$SG169777 DB	'sector', 00H
	ORG $+5
$SG169712 DB	'HHC00462%s %1d:%04X CKD file %s: creating %4.4X volume %'
	DB	's: %u cyls, %u trks/cyl, %u bytes/track', 0aH, 00H
	ORG $+7
$SG169713 DB	'create_ckd', 00H
	ORG $+5
$SG169714 DB	'dasdutil.c', 00H
	ORG $+5
$SG169774 DB	'HHC00521%s Maximum of %u %s in a 2GB file', 0aH, 00H
	ORG $+5
$SG169775 DB	'create_fba', 00H
	ORG $+5
$SG169776 DB	'dasdutil.c', 00H
	ORG $+1
$SG169795 DB	'open()', 00H
	ORG $+5
$SG169779 DB	'HHC00461%s %1d:%04X CKD file %s: %s count %u is outside '
	DB	'range %u-%u', 0aH, 00H
	ORG $+3
$SG169780 DB	'create_fba', 00H
	ORG $+5
$SG169781 DB	'dasdutil.c', 00H
	ORG $+5
$SG169783 DB	'malloc(%u)', 00H
	ORG $+5
$SG169785 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169786 DB	'create_fba', 00H
	ORG $+5
$SG169787 DB	'dasdutil.c', 00H
	ORG $+5
$SG169803 DB	'HHC00475%s This might take a while... Please wait...', 0aH
	DB	00H
	ORG $+2
$SG169790 DB	'HHC00463%s %1d:%04X FBA file %s: creating %4.4X volume %'
	DB	's: %u sectors, %u bytes/sector', 0aH, 00H
$SG169791 DB	'create_fba', 00H
	ORG $+5
$SG169792 DB	'dasdutil.c', 00H
	ORG $+5
$SG169797 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169798 DB	'create_fba', 00H
	ORG $+5
$SG169799 DB	'dasdutil.c', 00H
	ORG $+5
$SG169804 DB	'create_fba', 00H
	ORG $+5
$SG169805 DB	'dasdutil.c', 00H
	ORG $+5
$SG169807 DB	'ftruncate()', 00H
	ORG $+4
$SG169809 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169810 DB	'create_fba', 00H
	ORG $+5
$SG169811 DB	'dasdutil.c', 00H
	ORG $+1
$SG169813 DB	'VOL1', 00H
	ORG $+7
$SG169817 DB	'BLK=%u', 0aH, 00H
$SG169818 DB	'Writing sector %u', 0dH, 00H
	ORG $+5
$SG169820 DB	'incomplete', 00H
	ORG $+5
$SG169821 DB	'write()', 00H
$SG169823 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169824 DB	'create_fba', 00H
	ORG $+5
$SG169825 DB	'dasdutil.c', 00H
	ORG $+5
$SG169827 DB	'close()', 00H
$SG169829 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169830 DB	'create_fba', 00H
	ORG $+5
$SG169831 DB	'dasdutil.c', 00H
	ORG $+5
$SG169832 DB	'sectors', 00H
$SG169834 DB	'HHC00460%s %1d:%04X CKD file %s: %u %s successfully writ'
	DB	'ten', 0aH, 00H
	ORG $+3
$SG169835 DB	'create_fba', 00H
	ORG $+5
$SG169836 DB	'dasdutil.c', 00H
	ORG $+5
$SG169952 DB	'create_compressed_fba', 00H
	ORG $+2
$SG169951 DB	'HHC00464%s %1d:%04X CKD file %s: file size too large: %l'
	DB	'lu [%d]', 0aH, 00H
	ORG $+7
$SG169953 DB	'dasdutil.c', 00H
	ORG $+1
$SG169956 DB	'open()', 00H
	ORG $+5
$SG169958 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169959 DB	'create_compressed_fba', 00H
	ORG $+2
$SG169960 DB	'dasdutil.c', 00H
	ORG $+5
$SG169964 DB	'create_compressed_fba', 00H
	ORG $+2
$SG169963 DB	'HHC00465%s %1d:%04X FBA file %s: creating %4.4X compress'
	DB	'ed volume %s: %u sectors, %u bytes/sector', 0aH, 00H
	ORG $+5
$SG169965 DB	'dasdutil.c', 00H
	ORG $+5
$SG169967 DB	'incomplete', 00H
	ORG $+5
$SG169968 DB	'write()', 00H
$SG169970 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169971 DB	'create_compressed_fba', 00H
	ORG $+2
$SG169972 DB	'dasdutil.c', 00H
	ORG $+5
$SG169975 DB	'incomplete', 00H
	ORG $+5
$SG169976 DB	'write()', 00H
$SG169978 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169979 DB	'create_compressed_fba', 00H
	ORG $+2
$SG169980 DB	'dasdutil.c', 00H
	ORG $+5
$SG169982 DB	'incomplete', 00H
	ORG $+5
$SG169983 DB	'write()', 00H
$SG169985 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169986 DB	'create_compressed_fba', 00H
	ORG $+2
$SG169987 DB	'dasdutil.c', 00H
	ORG $+5
$SG169989 DB	'incomplete', 00H
	ORG $+5
$SG169990 DB	'write()', 00H
$SG169992 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169993 DB	'create_compressed_fba', 00H
	ORG $+2
$SG169994 DB	'dasdutil.c', 00H
	ORG $+5
$SG169997 DB	'incomplete', 00H
	ORG $+5
$SG169998 DB	'write()', 00H
$SG170000 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG170001 DB	'create_compressed_fba', 00H
	ORG $+2
$SG170002 DB	'dasdutil.c', 00H
	ORG $+5
$SG170004 DB	'lseek()', 00H
$SG170006 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG170007 DB	'create_compressed_fba', 00H
	ORG $+2
$SG170008 DB	'dasdutil.c', 00H
	ORG $+5
$SG170010 DB	'incomplete', 00H
	ORG $+5
$SG170011 DB	'write()', 00H
$SG170013 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG170014 DB	'create_compressed_fba', 00H
	ORG $+2
$SG170015 DB	'dasdutil.c', 00H
	ORG $+5
$SG170017 DB	'lseek()', 00H
$SG170019 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG170020 DB	'create_compressed_fba', 00H
	ORG $+2
$SG170021 DB	'dasdutil.c', 00H
	ORG $+5
$SG170023 DB	'incomplete', 00H
	ORG $+5
$SG170024 DB	'write()', 00H
$SG170026 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG170027 DB	'create_compressed_fba', 00H
	ORG $+2
$SG170028 DB	'dasdutil.c', 00H
	ORG $+5
$SG170030 DB	'close()', 00H
$SG170032 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG170033 DB	'create_compressed_fba', 00H
	ORG $+2
$SG170034 DB	'dasdutil.c', 00H
	ORG $+5
$SG170035 DB	'sectors', 00H
$SG170037 DB	'HHC00460%s %1d:%04X CKD file %s: %u %s successfully writ'
	DB	'ten', 0aH, 00H
	ORG $+3
$SG170038 DB	'create_compressed_fba', 00H
	ORG $+2
$SG170039 DB	'dasdutil.c', 00H
	ORG $+5
$SG170095 DB	'CKD_P370', 00H
	ORG $+7
$SG170097 DB	'CKD_C370', 00H
	ORG $+7
$SG170099 DB	'CKD_S370', 00H
	ORG $+7
$SG170101 DB	'FBA_C370', 00H
	ORG $+7
$SG170103 DB	'FBA_S370', 00H
	ORG $+7
$SG170105 DB	'CKD_P064', 00H
	ORG $+7
$SG170107 DB	'CKD_C064', 00H
	ORG $+7
$SG170109 DB	'CKD_S064', 00H
	ORG $+7
$SG170111 DB	'FBA_C064', 00H
	ORG $+7
$SG170113 DB	'FBA_S064', 00H
	ORG $+7
$SG170118 DB	'CKD_P370', 00H
	ORG $+7
$SG170120 DB	'CKD_C370', 00H
	ORG $+7
$SG170122 DB	'CKD_S370', 00H
	ORG $+7
$SG170124 DB	'FBA_C370', 00H
	ORG $+7
$SG170126 DB	'FBA_S370', 00H
	ORG $+7
$SG170128 DB	'CKD_P064', 00H
	ORG $+7
$SG170130 DB	'CKD_C064', 00H
	ORG $+7
$SG170132 DB	'CKD_S064', 00H
	ORG $+7
$SG170134 DB	'FBA_C064', 00H
	ORG $+7
$SG170136 DB	'FBA_S064', 00H
	ORG $+7
$SG170143 DB	'CKD_P370', 00H
	ORG $+7
$SG170145 DB	'CKD_C370', 00H
	ORG $+7
$SG170147 DB	'CKD_S370', 00H
	ORG $+7
$SG170149 DB	'FBA_C370', 00H
	ORG $+7
$SG170151 DB	'FBA_S370', 00H
	ORG $+7
$SG170153 DB	'CKD_P064', 00H
	ORG $+7
$SG170155 DB	'CKD_C064', 00H
	ORG $+7
$SG170157 DB	'CKD_S064', 00H
	ORG $+7
$SG170159 DB	'FBA_C064', 00H
	ORG $+7
$SG170161 DB	'FBA_S064', 00H
	ORG $+7
$SG170165 DB	'CKD_P370', 00H
	ORG $+7
$SG170166 DB	'CKD_C370', 00H
	ORG $+7
$SG170167 DB	'CKD_S370', 00H
	ORG $+7
$SG170168 DB	'FBA_C370', 00H
	ORG $+7
$SG170169 DB	'FBA_S370', 00H
	ORG $+7
$SG170170 DB	'CKD_P064', 00H
	ORG $+7
$SG170171 DB	'CKD_C064', 00H
	ORG $+7
$SG170172 DB	'CKD_S064', 00H
	ORG $+7
$SG170173 DB	'FBA_C064', 00H
	ORG $+7
$SG170174 DB	'FBA_S064', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:create_ckd_file
	DD	027H
	DD	01f21H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:do_data_dump
	DD	025H
	DD	0307H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:create_compressed_fba
	DD	02cH
	DD	0f2eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:create_fba
	DD	026H
	DD	0968H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:create_ckd
	DD	026H
	DD	0936H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_extent_array
	DD	028H
	DD	0e20H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:open_fba_image
	DD	025H
	DD	05b8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:open_ckd_image
	DD	025H
	DD	0c6dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:gen_dasd_serial
	DD	015H
	DD	0cdH
voltbl	ENDS
xdata	SEGMENT
$unwind$gen_dasd_serial DD 031a19H
	DD	07007a20bH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$build_vol1 DD 011801H
	DD	06218H
$unwind$data_dump DD 010d01H
	DD	0420dH
$unwind$data_dump_ascii DD 010d01H
	DD	0420dH
$unwind$data_dump_offset DD 011201H
	DD	04212H
$unwind$data_dump_offset_ascii DD 011201H
	DD	04212H
$unwind$read_track DD 021501H
	DD	0170115H
$unwind$read_block DD 011701H
	DD	08217H
$unwind$search_key_equal DD 021b01H
	DD	01b011bH
$unwind$convert_tt DD 011601H
	DD	0e216H
$unwind$open_ckd_image DD 022d19H
	DD	0db011bH
	DD	imagerel __GSHandlerCheck
	DD	06c0H
$unwind$open_fba_image DD 022d19H
	DD	021011bH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$close_ckd_image DD 020c01H
	DD	013010cH
$unwind$build_extent_array DD 053019H
	DD	02e011eH
	DD	060167017H
	DD	03015H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$capacity_calc DD 021a01H
	DD	015011aH
$unwind$create_ckd DD 032e19H
	DD	05c011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02d0H
$unwind$create_fba DD 032e19H
	DD	046011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$create_compressed_fba DD 033419H
	DD	021ca0122H
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	010e40H
$unwind$next_util_devnum DD 010401H
	DD	02204H
$unwind$valid_dsname DD 010901H
	DD	06209H
$unwind$ckd_tracklen DD 010e01H
	DD	0820eH
$unwind$dh_devid_typ DD 010901H
	DD	04209H
$unwind$is_dh_devid_typ DD 010d01H
	DD	0420dH
$unwind$same_as_above DD 011801H
	DD	04218H
$unwind$do_data_dump DD 032d19H
	DD	022011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$create_ckd_file DD 042f19H
	DD	01d7011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0ea0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
r$ = 96
pos$ = 104
rechdr$ = 112
cyl$ = 120
rc$ = 124
head$ = 128
fd$ = 132
i$ = 136
keylen$ = 140
trk$ = 144
trks$ = 148
len$ = 152
cpos$ = 156
fileseq$ = 160
highcyl$ = 164
l1$ = 168
x$ = 176
rec0len$ = 180
ipl1len$ = 184
ipl2len$ = 188
vol1len$ = 192
tv727 = 196
tv760 = 200
tv765 = 204
tv770 = 208
tv71 = 212
n$ = 216
tv1156 = 220
trkhdr$ = 224
rcoff$ = 232
tv252 = 240
tv306 = 248
tv405 = 256
tv434 = 264
ckdtab$ = 272
tv977 = 280
tv1033 = 288
tv1115 = 296
tv173 = 304
tv361 = 312
tv507 = 320
tv1006 = 328
tv1088 = 336
tv1138 = 344
cdevhdr$ = 352
devhdr$ = 864
l2$ = 1376
buf$1 = 3424
pathname$ = 3472
__$ArrayPad$ = 3744
fname$ = 3792
fseqn$ = 3800
devtype$ = 3808
heads$ = 3816
trksize$ = 3824
buf$ = 3832
start$ = 3840
end$ = 3848
volcyls$ = 3856
serial$ = 3864
volser$ = 3872
comp$ = 3880
dasdcopy$ = 3888
nullfmt$ = 3896
rawflag$ = 3904
flagECmode$ = 3912
flagMachinecheck$ = 3920
create_ckd_file PROC

; 1210 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec b8 0e
	00 00		 sub	 rsp, 3768		; 00000eb8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 a0
	0e 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1211 : int             rc;                     /* Return code               */
; 1212 : off_t           rcoff;                  /* Return value from lseek() */
; 1213 : int             fd;                     /* File descriptor           */
; 1214 : int             i;                      /* Loop counter              */
; 1215 : int             n;                      /* Loop delimiter            */
; 1216 : CKD_DEVHDR      devhdr;                 /* Device header             */
; 1217 : CCKD_DEVHDR     cdevhdr;                /* Compressed device header  */
; 1218 : CCKD_L1ENT     *l1=NULL;                /* -> Primary lookup table   */

  0002f	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR l1$[rsp], 0

; 1219 : CCKD_L2ENT      l2[256];                /* Secondary lookup table    */
; 1220 : CKD_TRKHDR     *trkhdr;                 /* -> Track header           */
; 1221 : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 1222 : U32             cyl;                    /* Cylinder number           */
; 1223 : U32             head;                   /* Head number               */
; 1224 : U32             trk = 0;                /* Track number              */

  0003b	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR trk$[rsp], 0

; 1225 : U32             trks;                   /* Total number tracks       */
; 1226 : BYTE            r;                      /* Record number             */
; 1227 : BYTE           *pos;                    /* -> Next position in buffer*/
; 1228 : U32             cpos = 0;               /* Offset into cckd file     */

  00046	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cpos$[rsp], 0

; 1229 : u_int           len = 0;                /* Length used in track      */

  00051	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR len$[rsp], 0

; 1230 : u_int           keylen = 4;             /* Length of keys            */

  0005c	c7 84 24 8c 00
	00 00 04 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 4

; 1231 : u_int           ipl1len = 24;           /* Length of IPL1 data       */

  00067	c7 84 24 b8 00
	00 00 18 00 00
	00		 mov	 DWORD PTR ipl1len$[rsp], 24

; 1232 : u_int           ipl2len = 144;          /* Length of IPL2 data       */

  00072	c7 84 24 bc 00
	00 00 90 00 00
	00		 mov	 DWORD PTR ipl2len$[rsp], 144 ; 00000090H

; 1233 : u_int           vol1len = 80;           /* Length of VOL1 data       */

  0007d	c7 84 24 c0 00
	00 00 50 00 00
	00		 mov	 DWORD PTR vol1len$[rsp], 80 ; 00000050H

; 1234 : u_int           rec0len = 8;            /* Length of R0 data         */

  00088	c7 84 24 b4 00
	00 00 08 00 00
	00		 mov	 DWORD PTR rec0len$[rsp], 8

; 1235 : u_int           fileseq;                /* CKD header sequence number*/
; 1236 : u_int           highcyl;                /* CKD header high cyl number*/
; 1237 : int             x=O_EXCL;               /* Open option               */

  00093	c7 84 24 b0 00
	00 00 00 04 00
	00		 mov	 DWORD PTR x$[rsp], 1024	; 00000400H

; 1238 : CKDDEV         *ckdtab;                 /* -> CKD table entry        */
; 1239 : char            pathname[MAX_PATH];     /* file path in host format  */
; 1240 : 
; 1241 :     /* Locate the CKD dasd table entry */
; 1242 :     ckdtab = dasd_lookup (DASD_CKDDEV, NULL, devtype, 0);

  0009e	0f b7 84 24 e0
	0e 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  000a6	45 33 c9	 xor	 r9d, r9d
  000a9	44 8b c0	 mov	 r8d, eax
  000ac	33 d2		 xor	 edx, edx
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	e8 00 00 00 00	 call	 dasd_lookup
  000b8	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ckdtab$[rsp], rax

; 1243 :     if (ckdtab == NULL)

  000c0	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR ckdtab$[rsp], 0
  000c9	0f 85 8a 00 00
	00		 jne	 $LN17@create_ckd

; 1244 :     {
; 1245 :         FWRMSG( stderr, HHC00415, "E", 0, 0, fname, devtype );

  000cf	0f b7 84 24 e0
	0e 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  000d7	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv71[rsp], eax
  000de	b9 02 00 00 00	 mov	 ecx, 2
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e9	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv71[rsp]
  000f0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000f4	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000fc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00101	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0010a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169480
  0011a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169481
  00126	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00130	41 b9 03 00 00
	00		 mov	 r9d, 3
  00136	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169482
  0013d	ba dd 04 00 00	 mov	 edx, 1245		; 000004ddH
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169483
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1246 :         return -1;

  0014f	b8 ff ff ff ff	 mov	 eax, -1
  00154	e9 c8 1d 00 00	 jmp	 $LN1@create_ckd
$LN17@create_ckd:

; 1247 :     }
; 1248 : 
; 1249 :     /* Set file sequence number to zero if this is the only file */
; 1250 :     if (fseqn == 1 && end + 1 == volcyls)

  00159	83 bc 24 d8 0e
	00 00 01	 cmp	 DWORD PTR fseqn$[rsp], 1
  00161	75 1f		 jne	 SHORT $LN18@create_ckd
  00163	8b 84 24 08 0f
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  0016a	ff c0		 inc	 eax
  0016c	3b 84 24 10 0f
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  00173	75 0d		 jne	 SHORT $LN18@create_ckd

; 1251 :         fileseq = 0;

  00175	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fileseq$[rsp], 0
  00180	eb 0e		 jmp	 SHORT $LN19@create_ckd
$LN18@create_ckd:

; 1252 :     else
; 1253 :         fileseq = fseqn;

  00182	8b 84 24 d8 0e
	00 00		 mov	 eax, DWORD PTR fseqn$[rsp]
  00189	89 84 24 a0 00
	00 00		 mov	 DWORD PTR fileseq$[rsp], eax
$LN19@create_ckd:

; 1254 : 
; 1255 :     /* Set high cylinder number to zero if this is the last file */
; 1256 :     if (end + 1 == volcyls)

  00190	8b 84 24 08 0f
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00197	ff c0		 inc	 eax
  00199	3b 84 24 10 0f
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  001a0	75 0d		 jne	 SHORT $LN20@create_ckd

; 1257 :         highcyl = 0;

  001a2	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR highcyl$[rsp], 0
  001ad	eb 0e		 jmp	 SHORT $LN21@create_ckd
$LN20@create_ckd:

; 1258 :     else
; 1259 :         highcyl = end;

  001af	8b 84 24 08 0f
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  001b6	89 84 24 a4 00
	00 00		 mov	 DWORD PTR highcyl$[rsp], eax
$LN21@create_ckd:

; 1260 :     cyl = end - start + 1;

  001bd	8b 84 24 00 0f
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  001c4	8b 8c 24 08 0f
	00 00		 mov	 ecx, DWORD PTR end$[rsp]
  001cb	2b c8		 sub	 ecx, eax
  001cd	8b c1		 mov	 eax, ecx
  001cf	ff c0		 inc	 eax
  001d1	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax

; 1261 : 
; 1262 :     /* Special processing for ckd and dasdcopy */
; 1263 :     if (comp == 0xFF && dasdcopy)

  001d5	0f b6 84 24 28
	0f 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  001dd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001e2	75 35		 jne	 SHORT $LN22@create_ckd
  001e4	83 bc 24 30 0f
	00 00 00	 cmp	 DWORD PTR dasdcopy$[rsp], 0
  001ec	74 2b		 je	 SHORT $LN22@create_ckd

; 1264 :     {
; 1265 :         highcyl = end;

  001ee	8b 84 24 08 0f
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  001f5	89 84 24 a4 00
	00 00		 mov	 DWORD PTR highcyl$[rsp], eax

; 1266 :         if (end + 1 == volcyls)

  001fc	8b 84 24 08 0f
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00203	ff c0		 inc	 eax
  00205	3b 84 24 10 0f
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  0020c	75 0b		 jne	 SHORT $LN23@create_ckd

; 1267 :             fileseq = 0xff;

  0020e	c7 84 24 a0 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR fileseq$[rsp], 255 ; 000000ffH
$LN23@create_ckd:
$LN22@create_ckd:

; 1268 :     }
; 1269 : 
; 1270 :     trks = volcyls * heads;

  00219	8b 84 24 10 0f
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  00220	0f af 84 24 e8
	0e 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  00228	89 84 24 94 00
	00 00		 mov	 DWORD PTR trks$[rsp], eax

; 1271 : 
; 1272 :     /* if `dasdcopy' > 1 then we can replace the existing file */
; 1273 :     if (dasdcopy > 1) x = 0;

  0022f	83 bc 24 30 0f
	00 00 01	 cmp	 DWORD PTR dasdcopy$[rsp], 1
  00237	7e 0b		 jle	 SHORT $LN24@create_ckd
  00239	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$[rsp], 0
$LN24@create_ckd:

; 1274 : 
; 1275 :     /* Create the DASD image file */
; 1276 :     hostpath(pathname, fname, sizeof(pathname));

  00244	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0024a	48 8b 94 24 d0
	0e 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00252	48 8d 8c 24 90
	0d 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 1277 :     fd = HOPEN (pathname, O_WRONLY | O_CREAT | x | O_BINARY,

  00260	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00267	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  0026c	0f ba e8 0f	 bts	 eax, 15
  00270	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00276	8b d0		 mov	 edx, eax
  00278	48 8d 8c 24 90
	0d 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00286	89 84 24 84 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax

; 1278 :                 S_IRUSR | S_IWUSR | S_IRGRP);
; 1279 :     if (fd < 0)

  0028d	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  00295	0f 8d 9f 00 00
	00		 jge	 $LN25@create_ckd

; 1280 :     {
; 1281 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname, "open()", strerror( errno ));

  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a1	8b 08		 mov	 ecx, DWORD PTR [rax]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002a9	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv173[rsp], rax
  002b1	b9 02 00 00 00	 mov	 ecx, 2
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002bc	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  002c4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169492
  002d0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002d5	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  002dd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002e2	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  002eb	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  002f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169493
  002fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169494
  00307	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0030c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00311	41 b9 03 00 00
	00		 mov	 r9d, 3
  00317	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169495
  0031e	ba 01 05 00 00	 mov	 edx, 1281		; 00000501H
  00323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169496
  0032a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1282 :         return -1;

  00330	b8 ff ff ff ff	 mov	 eax, -1
  00335	e9 e7 1b 00 00	 jmp	 $LN1@create_ckd
$LN25@create_ckd:

; 1283 :     }
; 1284 : 
; 1285 :     /* Create the device header */
; 1286 :     memset( &devhdr, 0, CKD_DEVHDR_SIZE );

  0033a	48 8d 84 24 60
	03 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  00342	48 8b f8	 mov	 rdi, rax
  00345	33 c0		 xor	 eax, eax
  00347	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0034c	f3 aa		 rep stosb

; 1287 :     memcpy( devhdr.dh_serial, serial, sizeof( devhdr.dh_serial ));

  0034e	48 8d 84 24 74
	03 00 00	 lea	 rax, QWORD PTR devhdr$[rsp+20]
  00356	48 8b f8	 mov	 rdi, rax
  00359	48 8b b4 24 18
	0f 00 00	 mov	 rsi, QWORD PTR serial$[rsp]
  00361	b9 0c 00 00 00	 mov	 ecx, 12
  00366	f3 a4		 rep movsb

; 1288 : 
; 1289 :     if (comp == 0xff) memcpy( devhdr.dh_devid, dh_devid_str( CKD_P370_TYP ), 8 );

  00368	0f b6 84 24 28
	0f 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00370	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00375	75 17		 jne	 SHORT $LN26@create_ckd
  00377	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0037c	e8 00 00 00 00	 call	 dh_devid_str
  00381	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00384	48 89 84 24 60
	03 00 00	 mov	 QWORD PTR devhdr$[rsp], rax
  0038c	eb 15		 jmp	 SHORT $LN27@create_ckd
$LN26@create_ckd:

; 1290 :     else              memcpy( devhdr.dh_devid, dh_devid_str( CKD_C370_TYP ), 8 );

  0038e	b9 00 00 00 40	 mov	 ecx, 1073741824		; 40000000H
  00393	e8 00 00 00 00	 call	 dh_devid_str
  00398	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0039b	48 89 84 24 60
	03 00 00	 mov	 QWORD PTR devhdr$[rsp], rax
$LN27@create_ckd:

; 1291 : 
; 1292 :     STORE_LE_FW( devhdr.dh_heads,   heads   );

  003a3	8b 8c 24 e8 0e
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  003aa	e8 00 00 00 00	 call	 _byteswap_ulong
  003af	8b c8		 mov	 ecx, eax
  003b1	e8 00 00 00 00	 call	 _byteswap_ulong
  003b6	8b d0		 mov	 edx, eax
  003b8	48 8d 8c 24 68
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  003c0	e8 00 00 00 00	 call	 store_fw_noswap

; 1293 :     STORE_LE_FW( devhdr.dh_trksize, trksize );

  003c5	8b 8c 24 f0 0e
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  003cc	e8 00 00 00 00	 call	 _byteswap_ulong
  003d1	8b c8		 mov	 ecx, eax
  003d3	e8 00 00 00 00	 call	 _byteswap_ulong
  003d8	8b d0		 mov	 edx, eax
  003da	48 8d 8c 24 6c
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  003e2	e8 00 00 00 00	 call	 store_fw_noswap

; 1294 : 
; 1295 :     devhdr.dh_devtyp  = devtype & 0xFF;

  003e7	0f b7 84 24 e0
	0e 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  003ef	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003f4	88 84 24 70 03
	00 00		 mov	 BYTE PTR devhdr$[rsp+16], al

; 1296 :     devhdr.dh_fileseq = fileseq;

  003fb	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR fileseq$[rsp]
  00403	88 84 24 71 03
	00 00		 mov	 BYTE PTR devhdr$[rsp+17], al

; 1297 : 
; 1298 :     STORE_LE_HW( devhdr.dh_highcyl, highcyl );

  0040a	0f b7 8c 24 a4
	00 00 00	 movzx	 ecx, WORD PTR highcyl$[rsp]
  00412	e8 00 00 00 00	 call	 _byteswap_ushort
  00417	0f b7 c8	 movzx	 ecx, ax
  0041a	e8 00 00 00 00	 call	 _byteswap_ushort
  0041f	0f b7 d0	 movzx	 edx, ax
  00422	48 8d 8c 24 72
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  0042a	e8 00 00 00 00	 call	 store_hw_noswap

; 1299 : 
; 1300 :     /* Write the device header */
; 1301 :     rc = write (fd, &devhdr, CKD_DEVHDR_SIZE);

  0042f	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00435	48 8d 94 24 60
	03 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  0043d	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0044a	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1302 :     if (rc < (int)CKD_DEVHDR_SIZE)

  0044e	81 7c 24 7c 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  00456	0f 8d bb 00 00
	00		 jge	 $LN28@create_ckd

; 1303 :     {
; 1304 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname, "write()",

  0045c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00462	83 38 00	 cmp	 DWORD PTR [rax], 0
  00465	74 18		 je	 SHORT $LN64@create_ckd
  00467	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0046d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0046f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00475	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv252[rsp], rax
  0047d	eb 0f		 jmp	 SHORT $LN65@create_ckd
$LN64@create_ckd:
  0047f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169500
  00486	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv252[rsp], rax
$LN65@create_ckd:
  0048e	b9 02 00 00 00	 mov	 ecx, 2
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00499	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv252[rsp]
  004a1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  004a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169501
  004ad	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004b2	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  004ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004bf	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  004c8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  004d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169502
  004d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169503
  004e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  004f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169504
  004fb	ba 19 05 00 00	 mov	 edx, 1305		; 00000519H
  00500	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169505
  00507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1305 :                 errno ? strerror( errno ) : "incomplete" );
; 1306 :         return -1;

  0050d	b8 ff ff ff ff	 mov	 eax, -1
  00512	e9 0a 1a 00 00	 jmp	 $LN1@create_ckd
$LN28@create_ckd:

; 1307 :     }
; 1308 : 
; 1309 :     /* Build a compressed CKD file */
; 1310 :     if (comp != 0xff)

  00517	0f b6 84 24 28
	0f 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0051f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00524	0f 84 09 05 00
	00		 je	 $LN29@create_ckd

; 1311 :     {
; 1312 :         /* Create the compressed device header */
; 1313 :         memset( &cdevhdr, 0, CCKD_DEVHDR_SIZE );

  0052a	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR cdevhdr$[rsp]
  00532	48 8b f8	 mov	 rdi, rax
  00535	33 c0		 xor	 eax, eax
  00537	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0053c	f3 aa		 rep stosb

; 1314 : 
; 1315 :         cdevhdr.cdh_vrm[0] = CCKD_VERSION;

  0053e	b8 01 00 00 00	 mov	 eax, 1
  00543	48 6b c0 00	 imul	 rax, rax, 0
  00547	c6 84 04 60 01
	00 00 00	 mov	 BYTE PTR cdevhdr$[rsp+rax], 0

; 1316 :         cdevhdr.cdh_vrm[1] = CCKD_RELEASE;

  0054f	b8 01 00 00 00	 mov	 eax, 1
  00554	48 6b c0 01	 imul	 rax, rax, 1
  00558	c6 84 04 60 01
	00 00 03	 mov	 BYTE PTR cdevhdr$[rsp+rax], 3

; 1317 :         cdevhdr.cdh_vrm[2] = CCKD_MODLVL;

  00560	b8 01 00 00 00	 mov	 eax, 1
  00565	48 6b c0 02	 imul	 rax, rax, 2
  00569	c6 84 04 60 01
	00 00 01	 mov	 BYTE PTR cdevhdr$[rsp+rax], 1

; 1318 : 
; 1319 :         if (cckd_def_opt_bigend())

  00571	e8 00 00 00 00	 call	 cckd_def_opt_bigend
  00576	85 c0		 test	 eax, eax
  00578	74 12		 je	 SHORT $LN30@create_ckd

; 1320 :             cdevhdr.cdh_opts |= CCKD_OPT_BIGEND;

  0057a	0f b6 84 24 63
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00582	83 c8 02	 or	 eax, 2
  00585	88 84 24 63 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+3], al
$LN30@create_ckd:

; 1321 : 
; 1322 :         cdevhdr.cdh_opts     |= CCKD_OPT_OPENRW;

  0058c	0f b6 84 24 63
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00594	83 c8 40	 or	 eax, 64			; 00000040H
  00597	88 84 24 63 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+3], al

; 1323 :         cdevhdr.num_L1tab = (volcyls * heads + 255) / 256;

  0059e	8b 84 24 10 0f
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  005a5	0f af 84 24 e8
	0e 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  005ad	05 ff 00 00 00	 add	 eax, 255		; 000000ffH
  005b2	33 d2		 xor	 edx, edx
  005b4	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  005b9	f7 f1		 div	 ecx
  005bb	89 84 24 64 01
	00 00		 mov	 DWORD PTR cdevhdr$[rsp+4], eax

; 1324 :         cdevhdr.num_L2tab = 256;

  005c2	c7 84 24 68 01
	00 00 00 01 00
	00		 mov	 DWORD PTR cdevhdr$[rsp+8], 256 ; 00000100H

; 1325 : 
; 1326 :         STORE_LE_FW( cdevhdr.cdh_cyls, volcyls );

  005cd	8b 8c 24 10 0f
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  005d4	e8 00 00 00 00	 call	 _byteswap_ulong
  005d9	8b c8		 mov	 ecx, eax
  005db	e8 00 00 00 00	 call	 _byteswap_ulong
  005e0	8b d0		 mov	 edx, eax
  005e2	48 8d 8c 24 88
	01 00 00	 lea	 rcx, QWORD PTR cdevhdr$[rsp+40]
  005ea	e8 00 00 00 00	 call	 store_fw_noswap

; 1327 : 
; 1328 :         cdevhdr.cmp_algo    = comp;

  005ef	0f b6 84 24 28
	0f 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  005f7	88 84 24 8d 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+45], al

; 1329 :         cdevhdr.cmp_parm    = -1;

  005fe	b8 ff ff ff ff	 mov	 eax, -1
  00603	66 89 84 24 8e
	01 00 00	 mov	 WORD PTR cdevhdr$[rsp+46], ax

; 1330 :         cdevhdr.cdh_nullfmt = nullfmt;

  0060b	0f b6 84 24 38
	0f 00 00	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  00613	88 84 24 8c 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+44], al

; 1331 : 
; 1332 :         /* Write the compressed device header */
; 1333 :         rc = write (fd, &cdevhdr, CCKD_DEVHDR_SIZE);

  0061a	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00620	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  00628	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0062f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00635	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1334 :         if (rc < (int)            CCKD_DEVHDR_SIZE)

  00639	81 7c 24 7c 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  00641	0f 8d bb 00 00
	00		 jge	 $LN31@create_ckd

; 1335 :         {
; 1336 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00647	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0064d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00650	74 18		 je	 SHORT $LN66@create_ckd
  00652	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00658	8b 08		 mov	 ecx, DWORD PTR [rax]
  0065a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00660	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv306[rsp], rax
  00668	eb 0f		 jmp	 SHORT $LN67@create_ckd
$LN66@create_ckd:
  0066a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169509
  00671	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv306[rsp], rax
$LN67@create_ckd:
  00679	b9 02 00 00 00	 mov	 ecx, 2
  0067e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00684	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv306[rsp]
  0068c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00691	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169510
  00698	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0069d	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  006a5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006aa	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  006b3	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  006bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169511
  006c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169512
  006cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  006df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169513
  006e6	ba 39 05 00 00	 mov	 edx, 1337		; 00000539H
  006eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169514
  006f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1337 :                     "write()", errno ? strerror( errno ) : "incomplete" );
; 1338 :             return -1;

  006f8	b8 ff ff ff ff	 mov	 eax, -1
  006fd	e9 1f 18 00 00	 jmp	 $LN1@create_ckd
$LN31@create_ckd:

; 1339 :         }
; 1340 : 
; 1341 :         /* Create the primary lookup table */
; 1342 :         l1 = calloc (cdevhdr.num_L1tab, CCKD_L1ENT_SIZE);

  00702	48 63 84 24 64
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+4]
  0070a	ba 04 00 00 00	 mov	 edx, 4
  0070f	48 8b c8	 mov	 rcx, rax
  00712	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00718	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR l1$[rsp], rax

; 1343 :         if (l1 == NULL)

  00720	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR l1$[rsp], 0
  00729	0f 85 ca 00 00
	00		 jne	 $LN32@create_ckd

; 1344 :         {
; 1345 :             char buf[40];
; 1346 :             MSGBUF( buf, "calloc(%d,%d)", (int)cdevhdr.num_L1tab, (int)CCKD_L1ENT_SIZE);

  0072f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00737	44 8b 8c 24 64
	01 00 00	 mov	 r9d, DWORD PTR cdevhdr$[rsp+4]
  0073f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169516
  00746	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0074b	48 8d 8c 24 60
	0d 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00753	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1347 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname, buf, strerror( errno ));

  00759	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0075f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00761	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00767	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv361[rsp], rax
  0076f	b9 02 00 00 00	 mov	 ecx, 2
  00774	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0077a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv361[rsp]
  00782	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00787	48 8d 8c 24 60
	0d 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0078f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00794	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0079c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007a1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  007aa	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  007b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169517
  007ba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169518
  007c6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d0	41 b9 03 00 00
	00		 mov	 r9d, 3
  007d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169519
  007dd	ba 43 05 00 00	 mov	 edx, 1347		; 00000543H
  007e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169520
  007e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1348 :             return -1;

  007ef	b8 ff ff ff ff	 mov	 eax, -1
  007f4	e9 28 17 00 00	 jmp	 $LN1@create_ckd
$LN32@create_ckd:

; 1349 :         }
; 1350 :         l1[0] = CCKD_L1TAB_POS + cdevhdr.num_L1tab * CCKD_L1ENT_SIZE;

  007f9	48 63 84 24 64
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+4]
  00801	48 8d 04 85 00
	04 00 00	 lea	 rax, QWORD PTR [rax*4+1024]
  00809	b9 04 00 00 00	 mov	 ecx, 4
  0080e	48 6b c9 00	 imul	 rcx, rcx, 0
  00812	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l1$[rsp]
  0081a	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1351 : 
; 1352 :         /* Write the primary lookup table */
; 1353 :         rc = write (fd, l1, cdevhdr.num_L1tab * CCKD_L1ENT_SIZE);

  0081d	48 63 84 24 64
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+4]
  00825	48 c1 e0 02	 shl	 rax, 2
  00829	44 8b c0	 mov	 r8d, eax
  0082c	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l1$[rsp]
  00834	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0083b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00841	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1354 :         if (rc < (int)     (cdevhdr.num_L1tab * CCKD_L1ENT_SIZE))

  00845	48 63 84 24 64
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+4]
  0084d	48 c1 e0 02	 shl	 rax, 2
  00851	39 44 24 7c	 cmp	 DWORD PTR rc$[rsp], eax
  00855	0f 8d bb 00 00
	00		 jge	 $LN33@create_ckd

; 1355 :         {
; 1356 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0085b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00861	83 38 00	 cmp	 DWORD PTR [rax], 0
  00864	74 18		 je	 SHORT $LN68@create_ckd
  00866	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0086c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0086e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00874	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv405[rsp], rax
  0087c	eb 0f		 jmp	 SHORT $LN69@create_ckd
$LN68@create_ckd:
  0087e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169522
  00885	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv405[rsp], rax
$LN69@create_ckd:
  0088d	b9 02 00 00 00	 mov	 ecx, 2
  00892	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00898	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv405[rsp]
  008a0	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  008a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169523
  008ac	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  008b1	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  008b9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008be	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  008c7	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  008d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169524
  008d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169525
  008e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  008f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169526
  008fa	ba 4d 05 00 00	 mov	 edx, 1357		; 0000054dH
  008ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169527
  00906	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1357 :                     "write()", errno ? strerror( errno ) : "incomplete" );
; 1358 :             return -1;

  0090c	b8 ff ff ff ff	 mov	 eax, -1
  00911	e9 0b 16 00 00	 jmp	 $LN1@create_ckd
$LN33@create_ckd:

; 1359 :         }
; 1360 : 
; 1361 :         /* Create the secondary lookup table */
; 1362 :         memset (&l2, 0, CCKD_L2TAB_SIZE);

  00916	48 8d 84 24 60
	05 00 00	 lea	 rax, QWORD PTR l2$[rsp]
  0091e	48 8b f8	 mov	 rdi, rax
  00921	33 c0		 xor	 eax, eax
  00923	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00928	f3 aa		 rep stosb

; 1363 : 
; 1364 :         /* Write the seondary lookup table */
; 1365 :         rc = write (fd, &l2, CCKD_L2TAB_SIZE);

  0092a	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00930	48 8d 94 24 60
	05 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  00938	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0093f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00945	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1366 :         if (rc < (int)       CCKD_L2TAB_SIZE)

  00949	81 7c 24 7c 00
	08 00 00	 cmp	 DWORD PTR rc$[rsp], 2048 ; 00000800H
  00951	0f 8d bb 00 00
	00		 jge	 $LN34@create_ckd

; 1367 :         {
; 1368 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00957	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0095d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00960	74 18		 je	 SHORT $LN70@create_ckd
  00962	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00968	8b 08		 mov	 ecx, DWORD PTR [rax]
  0096a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00970	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv434[rsp], rax
  00978	eb 0f		 jmp	 SHORT $LN71@create_ckd
$LN70@create_ckd:
  0097a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169529
  00981	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv434[rsp], rax
$LN71@create_ckd:
  00989	b9 02 00 00 00	 mov	 ecx, 2
  0098e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00994	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv434[rsp]
  0099c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  009a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169530
  009a8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009ad	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  009b5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009ba	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  009c3	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  009cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169531
  009d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169532
  009df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  009ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169533
  009f6	ba 59 05 00 00	 mov	 edx, 1369		; 00000559H
  009fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169534
  00a02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1369 :                     "write()", errno ? strerror( errno ) : "incomplete" );
; 1370 :             return -1;

  00a08	b8 ff ff ff ff	 mov	 eax, -1
  00a0d	e9 0f 15 00 00	 jmp	 $LN1@create_ckd
$LN34@create_ckd:

; 1371 :         }
; 1372 : 
; 1373 :         cpos = l1[0] + CCKD_L2TAB_SIZE;

  00a12	b8 04 00 00 00	 mov	 eax, 4
  00a17	48 6b c0 00	 imul	 rax, rax, 0
  00a1b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR l1$[rsp]
  00a23	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00a26	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00a2c	89 84 24 9c 00
	00 00		 mov	 DWORD PTR cpos$[rsp], eax
$LN29@create_ckd:

; 1374 :     }
; 1375 : 
; 1376 :     if (!dasdcopy)

  00a33	83 bc 24 30 0f
	00 00 00	 cmp	 DWORD PTR dasdcopy$[rsp], 0
  00a3b	0f 85 aa 0f 00
	00		 jne	 $LN35@create_ckd

; 1377 :     {
; 1378 :         /* Write each cylinder */
; 1379 :         for (cyl = start; cyl <= end; cyl++)

  00a41	8b 84 24 00 0f
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  00a48	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax
  00a4c	eb 0a		 jmp	 SHORT $LN4@create_ckd
$LN2@create_ckd:
  00a4e	8b 44 24 78	 mov	 eax, DWORD PTR cyl$[rsp]
  00a52	ff c0		 inc	 eax
  00a54	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax
$LN4@create_ckd:
  00a58	8b 84 24 08 0f
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00a5f	39 44 24 78	 cmp	 DWORD PTR cyl$[rsp], eax
  00a63	0f 87 80 0f 00
	00		 ja	 $LN3@create_ckd

; 1380 :         {
; 1381 :             /* Display progress message every 10 cylinders */
; 1382 :             if (cyl && !(cyl % 10))

  00a69	83 7c 24 78 00	 cmp	 DWORD PTR cyl$[rsp], 0
  00a6e	74 61		 je	 SHORT $LN37@create_ckd
  00a70	33 d2		 xor	 edx, edx
  00a72	8b 44 24 78	 mov	 eax, DWORD PTR cyl$[rsp]
  00a76	b9 0a 00 00 00	 mov	 ecx, 10
  00a7b	f7 f1		 div	 ecx
  00a7d	8b c2		 mov	 eax, edx
  00a7f	85 c0		 test	 eax, eax
  00a81	75 4e		 jne	 SHORT $LN37@create_ckd

; 1383 :             {
; 1384 :                 if (extgui)

  00a83	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00a8a	83 38 00	 cmp	 DWORD PTR [rax], 0
  00a8d	74 22		 je	 SHORT $LN38@create_ckd

; 1385 :                     fprintf( stderr, "CYL=%u\n", cyl );

  00a8f	b9 02 00 00 00	 mov	 ecx, 2
  00a94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a9a	44 8b 44 24 78	 mov	 r8d, DWORD PTR cyl$[rsp]
  00a9f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169540
  00aa6	48 8b c8	 mov	 rcx, rax
  00aa9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
  00aaf	eb 20		 jmp	 SHORT $LN39@create_ckd
$LN38@create_ckd:

; 1386 :                 else
; 1387 :                     fprintf( stderr, "Writing cylinder %u\r", cyl );

  00ab1	b9 02 00 00 00	 mov	 ecx, 2
  00ab6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00abc	44 8b 44 24 78	 mov	 r8d, DWORD PTR cyl$[rsp]
  00ac1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169541
  00ac8	48 8b c8	 mov	 rcx, rax
  00acb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN39@create_ckd:
$LN37@create_ckd:

; 1388 :             }
; 1389 : 
; 1390 :             for (head = 0; head < heads; head++)

  00ad1	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR head$[rsp], 0
  00adc	eb 10		 jmp	 SHORT $LN7@create_ckd
$LN5@create_ckd:
  00ade	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00ae5	ff c0		 inc	 eax
  00ae7	89 84 24 80 00
	00 00		 mov	 DWORD PTR head$[rsp], eax
$LN7@create_ckd:
  00aee	8b 84 24 e8 0e
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00af5	39 84 24 80 00
	00 00		 cmp	 DWORD PTR head$[rsp], eax
  00afc	0f 83 d1 0e 00
	00		 jae	 $LN6@create_ckd

; 1391 :             {
; 1392 :                 /* Clear the track to zeroes */
; 1393 :                 memset (buf, 0, trksize);

  00b02	8b 84 24 f0 0e
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  00b09	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv507[rsp], rax
  00b11	48 8b bc 24 f8
	0e 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00b19	33 c0		 xor	 eax, eax
  00b1b	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv507[rsp]
  00b23	f3 aa		 rep stosb

; 1394 : 
; 1395 :                 /* Build the track header */
; 1396 :                 trkhdr = (CKD_TRKHDR*)buf;

  00b25	48 8b 84 24 f8
	0e 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00b2d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR trkhdr$[rsp], rax

; 1397 :                 trkhdr->bin = 0;

  00b35	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR trkhdr$[rsp]
  00b3d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1398 :                 store_hw(&trkhdr->cyl, cyl);

  00b40	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00b45	e8 00 00 00 00	 call	 _byteswap_ushort
  00b4a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00b52	48 ff c1	 inc	 rcx
  00b55	0f b7 d0	 movzx	 edx, ax
  00b58	e8 00 00 00 00	 call	 store_hw_noswap

; 1399 :                 store_hw(&trkhdr->head, head);

  00b5d	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00b65	e8 00 00 00 00	 call	 _byteswap_ushort
  00b6a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00b72	48 83 c1 03	 add	 rcx, 3
  00b76	0f b7 d0	 movzx	 edx, ax
  00b79	e8 00 00 00 00	 call	 store_hw_noswap

; 1400 :                 pos = buf + CKD_TRKHDR_SIZE;

  00b7e	48 8b 84 24 f8
	0e 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00b86	48 83 c0 05	 add	 rax, 5
  00b8a	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1401 : 
; 1402 :                 /* Build record zero */
; 1403 :                 r = 0;

  00b8f	c6 44 24 60 00	 mov	 BYTE PTR r$[rsp], 0

; 1404 :                 rechdr = (CKD_RECHDR*)pos;

  00b94	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00b99	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1405 :                 pos += CKD_RECHDR_SIZE;

  00b9e	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00ba3	48 83 c0 08	 add	 rax, 8
  00ba7	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1406 :                 store_hw(&rechdr->cyl, cyl);

  00bac	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00bb1	e8 00 00 00 00	 call	 _byteswap_ushort
  00bb6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00bbb	0f b7 d0	 movzx	 edx, ax
  00bbe	e8 00 00 00 00	 call	 store_hw_noswap

; 1407 :                 store_hw(&rechdr->head, head);

  00bc3	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00bcb	e8 00 00 00 00	 call	 _byteswap_ushort
  00bd0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00bd5	48 83 c1 02	 add	 rcx, 2
  00bd9	0f b7 d0	 movzx	 edx, ax
  00bdc	e8 00 00 00 00	 call	 store_hw_noswap

; 1408 :                 rechdr->rec = r;

  00be1	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00be6	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  00beb	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1409 :                 rechdr->klen = 0;

  00bee	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00bf3	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 1410 :                 store_hw(&rechdr->dlen, rec0len);

  00bf7	0f b7 8c 24 b4
	00 00 00	 movzx	 ecx, WORD PTR rec0len$[rsp]
  00bff	e8 00 00 00 00	 call	 _byteswap_ushort
  00c04	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00c09	48 83 c1 06	 add	 rcx, 6
  00c0d	0f b7 d0	 movzx	 edx, ax
  00c10	e8 00 00 00 00	 call	 store_hw_noswap

; 1411 :                 pos += rec0len;

  00c15	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR rec0len$[rsp]
  00c1c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00c21	48 03 c8	 add	 rcx, rax
  00c24	48 8b c1	 mov	 rax, rcx
  00c27	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1412 :                 r++;

  00c2c	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  00c31	fe c0		 inc	 al
  00c33	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1413 : 
; 1414 :                 /* Track 0 contains IPL records and volume label */
; 1415 :                 if (!rawflag && fseqn == 1 && trk == 0)

  00c37	83 bc 24 40 0f
	00 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  00c3f	0f 85 08 04 00
	00		 jne	 $LN40@create_ckd
  00c45	83 bc 24 d8 0e
	00 00 01	 cmp	 DWORD PTR fseqn$[rsp], 1
  00c4d	0f 85 fa 03 00
	00		 jne	 $LN40@create_ckd
  00c53	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR trk$[rsp], 0
  00c5b	0f 85 ec 03 00
	00		 jne	 $LN40@create_ckd

; 1416 :                 {
; 1417 :                     /* Build the IPL1 record */
; 1418 :                     rechdr = (CKD_RECHDR*)pos;

  00c61	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00c66	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1419 :                     pos += CKD_RECHDR_SIZE;

  00c6b	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00c70	48 83 c0 08	 add	 rax, 8
  00c74	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1420 : 
; 1421 :                     store_hw(&rechdr->cyl, cyl);

  00c79	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00c7e	e8 00 00 00 00	 call	 _byteswap_ushort
  00c83	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00c88	0f b7 d0	 movzx	 edx, ax
  00c8b	e8 00 00 00 00	 call	 store_hw_noswap

; 1422 :                     store_hw(&rechdr->head, head);

  00c90	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00c98	e8 00 00 00 00	 call	 _byteswap_ushort
  00c9d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00ca2	48 83 c1 02	 add	 rcx, 2
  00ca6	0f b7 d0	 movzx	 edx, ax
  00ca9	e8 00 00 00 00	 call	 store_hw_noswap

; 1423 :                     rechdr->rec = r;

  00cae	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00cb3	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  00cb8	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1424 :                     rechdr->klen = keylen;

  00cbb	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00cc0	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  00cc8	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 1425 :                     store_hw(&rechdr->dlen, ipl1len);

  00ccb	0f b7 8c 24 b8
	00 00 00	 movzx	 ecx, WORD PTR ipl1len$[rsp]
  00cd3	e8 00 00 00 00	 call	 _byteswap_ushort
  00cd8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00cdd	48 83 c1 06	 add	 rcx, 6
  00ce1	0f b7 d0	 movzx	 edx, ax
  00ce4	e8 00 00 00 00	 call	 store_hw_noswap

; 1426 :                     r++;

  00ce9	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  00cee	fe c0		 inc	 al
  00cf0	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1427 : 
; 1428 :                     convert_to_ebcdic (pos, keylen, "IPL1");

  00cf4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169544
  00cfb	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR keylen$[rsp]
  00d02	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00d07	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 1429 :                     pos += keylen;

  00d0d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  00d14	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00d19	48 03 c8	 add	 rcx, rax
  00d1c	48 8b c1	 mov	 rax, rcx
  00d1f	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1430 : 
; 1431 :                     /* Copy model IPL PSW and CCWs */
; 1432 :                     memcpy (pos, noiplpsw, 8);

  00d24	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d29	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplpsw
  00d30	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1433 :                     memcpy (pos+8, noiplccw1, 8);

  00d33	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d38	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplccw1
  00d3f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1434 :                     memcpy (pos+16, noiplccw2, 8);

  00d43	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d48	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplccw2
  00d4f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1435 : 
; 1436 :                     /* Set EC mode flag in wait PSW if requested */
; 1437 :                     if (flagECmode)

  00d53	83 bc 24 48 0f
	00 00 00	 cmp	 DWORD PTR flagECmode$[rsp], 0
  00d5b	74 14		 je	 SHORT $LN42@create_ckd

; 1438 :                     {
; 1439 :                         *(pos+1) = 0x08 | *(pos+1);

  00d5d	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d62	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00d66	83 c8 08	 or	 eax, 8
  00d69	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00d6e	88 41 01	 mov	 BYTE PTR [rcx+1], al
$LN42@create_ckd:

; 1440 :                     }
; 1441 : 
; 1442 :                     /* Set machine-check-enabled mask in PSW if requested */
; 1443 :                     if (flagMachinecheck)

  00d71	83 bc 24 50 0f
	00 00 00	 cmp	 DWORD PTR flagMachinecheck$[rsp], 0
  00d79	74 14		 je	 SHORT $LN43@create_ckd

; 1444 :                     {
; 1445 :                         *(pos+1) = 0x04 | *(pos+1);

  00d7b	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d80	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00d84	83 c8 04	 or	 eax, 4
  00d87	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00d8c	88 41 01	 mov	 BYTE PTR [rcx+1], al
$LN43@create_ckd:

; 1446 :                     }
; 1447 : 
; 1448 :                     pos += ipl1len;

  00d8f	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR ipl1len$[rsp]
  00d96	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00d9b	48 03 c8	 add	 rcx, rax
  00d9e	48 8b c1	 mov	 rax, rcx
  00da1	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1449 : 
; 1450 :                     /* Build the IPL2 record */
; 1451 :                     rechdr = (CKD_RECHDR*)pos;

  00da6	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00dab	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1452 :                     pos += CKD_RECHDR_SIZE;

  00db0	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00db5	48 83 c0 08	 add	 rax, 8
  00db9	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1453 : 
; 1454 :                     store_hw(&rechdr->cyl, cyl);

  00dbe	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00dc3	e8 00 00 00 00	 call	 _byteswap_ushort
  00dc8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00dcd	0f b7 d0	 movzx	 edx, ax
  00dd0	e8 00 00 00 00	 call	 store_hw_noswap

; 1455 :                     store_hw(&rechdr->head, head);

  00dd5	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00ddd	e8 00 00 00 00	 call	 _byteswap_ushort
  00de2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00de7	48 83 c1 02	 add	 rcx, 2
  00deb	0f b7 d0	 movzx	 edx, ax
  00dee	e8 00 00 00 00	 call	 store_hw_noswap

; 1456 :                     rechdr->rec = r;

  00df3	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00df8	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  00dfd	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1457 :                     rechdr->klen = keylen;

  00e00	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00e05	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  00e0d	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 1458 :                     store_hw(&rechdr->dlen, ipl2len);

  00e10	0f b7 8c 24 bc
	00 00 00	 movzx	 ecx, WORD PTR ipl2len$[rsp]
  00e18	e8 00 00 00 00	 call	 _byteswap_ushort
  00e1d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00e22	48 83 c1 06	 add	 rcx, 6
  00e26	0f b7 d0	 movzx	 edx, ax
  00e29	e8 00 00 00 00	 call	 store_hw_noswap

; 1459 :                     r++;

  00e2e	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  00e33	fe c0		 inc	 al
  00e35	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1460 : 
; 1461 :                     convert_to_ebcdic (pos, keylen, "IPL2");

  00e39	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169547
  00e40	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR keylen$[rsp]
  00e47	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00e4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 1462 :                     pos += keylen;

  00e52	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  00e59	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00e5e	48 03 c8	 add	 rcx, rax
  00e61	48 8b c1	 mov	 rax, rcx
  00e64	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1463 : 
; 1464 :                     pos += ipl2len;

  00e69	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR ipl2len$[rsp]
  00e70	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00e75	48 03 c8	 add	 rcx, rax
  00e78	48 8b c1	 mov	 rax, rcx
  00e7b	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1465 : 
; 1466 :                     /* Build the VOL1 record */
; 1467 :                     rechdr = (CKD_RECHDR*)pos;

  00e80	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00e85	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1468 :                     pos += CKD_RECHDR_SIZE;

  00e8a	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00e8f	48 83 c0 08	 add	 rax, 8
  00e93	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1469 : 
; 1470 :                     store_hw(&rechdr->cyl, cyl);

  00e98	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00e9d	e8 00 00 00 00	 call	 _byteswap_ushort
  00ea2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00ea7	0f b7 d0	 movzx	 edx, ax
  00eaa	e8 00 00 00 00	 call	 store_hw_noswap

; 1471 :                     store_hw(&rechdr->head, head);

  00eaf	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00eb7	e8 00 00 00 00	 call	 _byteswap_ushort
  00ebc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00ec1	48 83 c1 02	 add	 rcx, 2
  00ec5	0f b7 d0	 movzx	 edx, ax
  00ec8	e8 00 00 00 00	 call	 store_hw_noswap

; 1472 :                     rechdr->rec = r;

  00ecd	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00ed2	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  00ed7	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1473 :                     rechdr->klen = keylen;

  00eda	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00edf	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  00ee7	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 1474 :                     store_hw(&rechdr->dlen, vol1len);

  00eea	0f b7 8c 24 c0
	00 00 00	 movzx	 ecx, WORD PTR vol1len$[rsp]
  00ef2	e8 00 00 00 00	 call	 _byteswap_ushort
  00ef7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00efc	48 83 c1 06	 add	 rcx, 6
  00f00	0f b7 d0	 movzx	 edx, ax
  00f03	e8 00 00 00 00	 call	 store_hw_noswap

; 1475 :                     r++;

  00f08	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  00f0d	fe c0		 inc	 al
  00f0f	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1476 : 
; 1477 :                     convert_to_ebcdic (pos, keylen, "VOL1");

  00f13	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169548
  00f1a	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR keylen$[rsp]
  00f21	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00f26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 1478 :                     pos += keylen;

  00f2c	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  00f33	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00f38	48 03 c8	 add	 rcx, rax
  00f3b	48 8b c1	 mov	 rax, rcx
  00f3e	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1479 : 
; 1480 :                     /* Build the VOL1 label */
; 1481 :                     build_vol1( pos, volser, NULL, true );

  00f43	41 b1 01	 mov	 r9b, 1
  00f46	45 33 c0	 xor	 r8d, r8d
  00f49	48 8b 94 24 20
	0f 00 00	 mov	 rdx, QWORD PTR volser$[rsp]
  00f51	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00f56	e8 00 00 00 00	 call	 build_vol1

; 1482 :                     pos += vol1len;

  00f5b	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR vol1len$[rsp]
  00f62	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00f67	48 03 c8	 add	 rcx, rax
  00f6a	48 8b c1	 mov	 rax, rcx
  00f6d	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1483 : 
; 1484 :                     /* 9 4096 data blocks for linux volume */
; 1485 :                     if (nullfmt == CKD_NULLTRK_FMT2)

  00f72	83 bc 24 38 0f
	00 00 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  00f7a	0f 85 c8 00 00
	00		 jne	 $LN44@create_ckd

; 1486 :                     {
; 1487 :                         for (i = 0; i < 9; i++)

  00f80	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00f8b	eb 10		 jmp	 SHORT $LN10@create_ckd
$LN8@create_ckd:
  00f8d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00f94	ff c0		 inc	 eax
  00f96	89 84 24 88 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@create_ckd:
  00f9d	83 bc 24 88 00
	00 00 09	 cmp	 DWORD PTR i$[rsp], 9
  00fa5	0f 8d 9d 00 00
	00		 jge	 $LN9@create_ckd

; 1488 :                         {
; 1489 :                             rechdr = (CKD_RECHDR*)pos;

  00fab	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00fb0	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1490 :                             pos += CKD_RECHDR_SIZE;

  00fb5	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00fba	48 83 c0 08	 add	 rax, 8
  00fbe	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1491 : 
; 1492 :                             store_hw(&rechdr->cyl, cyl);

  00fc3	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00fc8	e8 00 00 00 00	 call	 _byteswap_ushort
  00fcd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00fd2	0f b7 d0	 movzx	 edx, ax
  00fd5	e8 00 00 00 00	 call	 store_hw_noswap

; 1493 :                             store_hw(&rechdr->head, head);

  00fda	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00fe2	e8 00 00 00 00	 call	 _byteswap_ushort
  00fe7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00fec	48 83 c1 02	 add	 rcx, 2
  00ff0	0f b7 d0	 movzx	 edx, ax
  00ff3	e8 00 00 00 00	 call	 store_hw_noswap

; 1494 :                             rechdr->rec = r;

  00ff8	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00ffd	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  01002	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1495 :                             rechdr->klen = 0;

  01005	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  0100a	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 1496 :                             store_hw(&rechdr->dlen, 4096);

  0100e	66 b9 00 10	 mov	 cx, 4096		; 00001000H
  01012	e8 00 00 00 00	 call	 _byteswap_ushort
  01017	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0101c	48 83 c1 06	 add	 rcx, 6
  01020	0f b7 d0	 movzx	 edx, ax
  01023	e8 00 00 00 00	 call	 store_hw_noswap

; 1497 :                             pos += 4096;

  01028	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0102d	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  01033	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1498 :                             r++;

  01038	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  0103d	fe c0		 inc	 al
  0103f	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1499 :                         }

  01043	e9 45 ff ff ff	 jmp	 $LN8@create_ckd
$LN9@create_ckd:
$LN44@create_ckd:

; 1500 :                     }
; 1501 :                 } /* end if(trk == 0) */

  01048	e9 b7 07 00 00	 jmp	 $LN41@create_ckd
$LN40@create_ckd:

; 1502 : 
; 1503 :                 /* Track 1 for linux contains an empty VTOC */
; 1504 :                 else if (fseqn == 1 && trk == 1 && nullfmt == CKD_NULLTRK_FMT2)

  0104d	83 bc 24 d8 0e
	00 00 01	 cmp	 DWORD PTR fseqn$[rsp], 1
  01055	0f 85 3a 06 00
	00		 jne	 $LN45@create_ckd
  0105b	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR trk$[rsp], 1
  01063	0f 85 2c 06 00
	00		 jne	 $LN45@create_ckd
  01069	83 bc 24 38 0f
	00 00 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  01071	0f 85 1e 06 00
	00		 jne	 $LN45@create_ckd

; 1505 :                 {
; 1506 :                     /* build format 4 dscb */
; 1507 :                     rechdr = (CKD_RECHDR*)pos;

  01077	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0107c	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1508 :                     pos += CKD_RECHDR_SIZE;

  01081	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01086	48 83 c0 08	 add	 rax, 8
  0108a	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1509 : 
; 1510 :                     /* track 1 record 1 count */
; 1511 :                     store_hw(&rechdr->cyl, cyl);

  0108f	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  01094	e8 00 00 00 00	 call	 _byteswap_ushort
  01099	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0109e	0f b7 d0	 movzx	 edx, ax
  010a1	e8 00 00 00 00	 call	 store_hw_noswap

; 1512 :                     store_hw(&rechdr->head, head);

  010a6	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  010ae	e8 00 00 00 00	 call	 _byteswap_ushort
  010b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  010b8	48 83 c1 02	 add	 rcx, 2
  010bc	0f b7 d0	 movzx	 edx, ax
  010bf	e8 00 00 00 00	 call	 store_hw_noswap

; 1513 :                     rechdr->rec = r;

  010c4	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  010c9	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  010ce	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1514 :                     rechdr->klen = 44;

  010d1	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  010d6	c6 40 05 2c	 mov	 BYTE PTR [rax+5], 44	; 0000002cH

; 1515 :                     store_hw(&rechdr->dlen, 96);

  010da	66 b9 60 00	 mov	 cx, 96			; 00000060H
  010de	e8 00 00 00 00	 call	 _byteswap_ushort
  010e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  010e8	48 83 c1 06	 add	 rcx, 6
  010ec	0f b7 d0	 movzx	 edx, ax
  010ef	e8 00 00 00 00	 call	 store_hw_noswap

; 1516 :                     r++;

  010f4	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  010f9	fe c0		 inc	 al
  010fb	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1517 : 
; 1518 :                     /* track 1 record 1 key */
; 1519 :                     memset (pos, 0x04, 44);

  010ff	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  01104	b8 04 00 00 00	 mov	 eax, 4
  01109	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0110e	f3 aa		 rep stosb

; 1520 :                     pos += 44;

  01110	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01115	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  01119	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1521 : 
; 1522 :                     /* track 1 record 1 data */
; 1523 :                     memset (pos, 0, 96);

  0111e	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  01123	33 c0		 xor	 eax, eax
  01125	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0112a	f3 aa		 rep stosb

; 1524 :                     pos[0] = 0xf4;                            // DS4IDFMT

  0112c	b8 01 00 00 00	 mov	 eax, 1
  01131	48 6b c0 00	 imul	 rax, rax, 0
  01135	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0113a	c6 04 01 f4	 mov	 BYTE PTR [rcx+rax], 244	; 000000f4H

; 1525 :                     store_hw(pos + 6, 10);                    // DS4DSREC

  0113e	66 b9 0a 00	 mov	 cx, 10
  01142	e8 00 00 00 00	 call	 _byteswap_ushort
  01147	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0114c	48 83 c1 06	 add	 rcx, 6
  01150	0f b7 d0	 movzx	 edx, ax
  01153	e8 00 00 00 00	 call	 store_hw_noswap

; 1526 :                     pos[14] = trks > 65535 ? 0xa0 : 0;        // DS4VTOCI

  01158	81 bc 24 94 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  01163	76 0d		 jbe	 SHORT $LN72@create_ckd
  01165	c7 84 24 c4 00
	00 00 a0 00 00
	00		 mov	 DWORD PTR tv727[rsp], 160 ; 000000a0H
  01170	eb 0b		 jmp	 SHORT $LN73@create_ckd
$LN72@create_ckd:
  01172	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv727[rsp], 0
$LN73@create_ckd:
  0117d	b8 01 00 00 00	 mov	 eax, 1
  01182	48 6b c0 0e	 imul	 rax, rax, 14
  01186	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0118b	0f b6 94 24 c4
	00 00 00	 movzx	 edx, BYTE PTR tv727[rsp]
  01193	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1527 :                     pos[15] = 1;                              // DS4NOEXT

  01196	b8 01 00 00 00	 mov	 eax, 1
  0119b	48 6b c0 0f	 imul	 rax, rax, 15
  0119f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  011a4	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 1528 :                     store_hw(pos+18, volcyls);                // DS4DSCYL

  011a8	0f b7 8c 24 10
	0f 00 00	 movzx	 ecx, WORD PTR volcyls$[rsp]
  011b0	e8 00 00 00 00	 call	 _byteswap_ushort
  011b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  011ba	48 83 c1 12	 add	 rcx, 18
  011be	0f b7 d0	 movzx	 edx, ax
  011c1	e8 00 00 00 00	 call	 store_hw_noswap

; 1529 :                     store_hw(pos+20, heads);                  // DS4DSTRK

  011c6	0f b7 8c 24 e8
	0e 00 00	 movzx	 ecx, WORD PTR heads$[rsp]
  011ce	e8 00 00 00 00	 call	 _byteswap_ushort
  011d3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  011d8	48 83 c1 14	 add	 rcx, 20
  011dc	0f b7 d0	 movzx	 edx, ax
  011df	e8 00 00 00 00	 call	 store_hw_noswap

; 1530 :                     store_hw(pos+22, ckdtab->len);            // DS4DEVTK

  011e4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ckdtab$[rsp]
  011ec	0f b7 48 1a	 movzx	 ecx, WORD PTR [rax+26]
  011f0	e8 00 00 00 00	 call	 _byteswap_ushort
  011f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  011fa	48 83 c1 16	 add	 rcx, 22
  011fe	0f b7 d0	 movzx	 edx, ax
  01201	e8 00 00 00 00	 call	 store_hw_noswap

; 1531 :                     pos[27] = 0x30;                           // DS4DEVFG

  01206	b8 01 00 00 00	 mov	 eax, 1
  0120b	48 6b c0 1b	 imul	 rax, rax, 27
  0120f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01214	c6 04 01 30	 mov	 BYTE PTR [rcx+rax], 48	; 00000030H

; 1532 :                     pos[30] = 0x0c;                           // DS4DEVDT

  01218	b8 01 00 00 00	 mov	 eax, 1
  0121d	48 6b c0 1e	 imul	 rax, rax, 30
  01221	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01226	c6 04 01 0c	 mov	 BYTE PTR [rcx+rax], 12

; 1533 :                     pos[61] = 0x01;                           // DS4VTOCE + 00

  0122a	b8 01 00 00 00	 mov	 eax, 1
  0122f	48 6b c0 3d	 imul	 rax, rax, 61		; 0000003dH
  01233	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01238	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 1534 :                     pos[66] = 0x01;                           // DS4VTOCE + 05

  0123c	b8 01 00 00 00	 mov	 eax, 1
  01241	48 6b c0 42	 imul	 rax, rax, 66		; 00000042H
  01245	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0124a	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 1535 :                     pos[70] = 0x01;                           // DS4VTOCE + 09

  0124e	b8 01 00 00 00	 mov	 eax, 1
  01253	48 6b c0 46	 imul	 rax, rax, 70		; 00000046H
  01257	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0125c	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 1536 :                     pos[81] = trks > 65535 ? 7 : 0;           // DS4EFLVL

  01260	81 bc 24 94 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  0126b	76 0d		 jbe	 SHORT $LN74@create_ckd
  0126d	c7 84 24 c8 00
	00 00 07 00 00
	00		 mov	 DWORD PTR tv760[rsp], 7
  01278	eb 0b		 jmp	 SHORT $LN75@create_ckd
$LN74@create_ckd:
  0127a	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv760[rsp], 0
$LN75@create_ckd:
  01285	b8 01 00 00 00	 mov	 eax, 1
  0128a	48 6b c0 51	 imul	 rax, rax, 81		; 00000051H
  0128e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01293	0f b6 94 24 c8
	00 00 00	 movzx	 edx, BYTE PTR tv760[rsp]
  0129b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1537 :                     pos[85] = trks > 65535 ? 1 : 0;           // DS4EFPTR + 03

  0129e	81 bc 24 94 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  012a9	76 0d		 jbe	 SHORT $LN76@create_ckd
  012ab	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv765[rsp], 1
  012b6	eb 0b		 jmp	 SHORT $LN77@create_ckd
$LN76@create_ckd:
  012b8	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv765[rsp], 0
$LN77@create_ckd:
  012c3	b8 01 00 00 00	 mov	 eax, 1
  012c8	48 6b c0 55	 imul	 rax, rax, 85		; 00000055H
  012cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  012d1	0f b6 94 24 cc
	00 00 00	 movzx	 edx, BYTE PTR tv765[rsp]
  012d9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1538 :                     pos[86] = trks > 65535 ? 3 : 0;           // DS4EFPTR + 04

  012dc	81 bc 24 94 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  012e7	76 0d		 jbe	 SHORT $LN78@create_ckd
  012e9	c7 84 24 d0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv770[rsp], 3
  012f4	eb 0b		 jmp	 SHORT $LN79@create_ckd
$LN78@create_ckd:
  012f6	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv770[rsp], 0
$LN79@create_ckd:
  01301	b8 01 00 00 00	 mov	 eax, 1
  01306	48 6b c0 56	 imul	 rax, rax, 86		; 00000056H
  0130a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0130f	0f b6 94 24 d0
	00 00 00	 movzx	 edx, BYTE PTR tv770[rsp]
  01317	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1539 :                     pos += 96;

  0131a	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0131f	48 83 c0 60	 add	 rax, 96			; 00000060H
  01323	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1540 : 
; 1541 :                     /* build format 5 dscb */
; 1542 :                     rechdr = (CKD_RECHDR*)pos;

  01328	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0132d	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1543 :                     pos += CKD_RECHDR_SIZE;

  01332	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01337	48 83 c0 08	 add	 rax, 8
  0133b	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1544 : 
; 1545 :                     /* track 1 record 1 count */
; 1546 :                     store_hw(&rechdr->cyl, cyl);

  01340	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  01345	e8 00 00 00 00	 call	 _byteswap_ushort
  0134a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0134f	0f b7 d0	 movzx	 edx, ax
  01352	e8 00 00 00 00	 call	 store_hw_noswap

; 1547 :                     store_hw(&rechdr->head, head);

  01357	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  0135f	e8 00 00 00 00	 call	 _byteswap_ushort
  01364	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  01369	48 83 c1 02	 add	 rcx, 2
  0136d	0f b7 d0	 movzx	 edx, ax
  01370	e8 00 00 00 00	 call	 store_hw_noswap

; 1548 :                     rechdr->rec = r;

  01375	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  0137a	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  0137f	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1549 :                     rechdr->klen = 44;

  01382	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  01387	c6 40 05 2c	 mov	 BYTE PTR [rax+5], 44	; 0000002cH

; 1550 :                     store_hw(&rechdr->dlen, 96);

  0138b	66 b9 60 00	 mov	 cx, 96			; 00000060H
  0138f	e8 00 00 00 00	 call	 _byteswap_ushort
  01394	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  01399	48 83 c1 06	 add	 rcx, 6
  0139d	0f b7 d0	 movzx	 edx, ax
  013a0	e8 00 00 00 00	 call	 store_hw_noswap

; 1551 :                     r++;

  013a5	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  013aa	fe c0		 inc	 al
  013ac	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1552 : 
; 1553 :                     /* track 1 record 2 key */
; 1554 :                     memset (pos, 0x05, 4);                    // DS5KEYID

  013b0	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  013b5	b8 05 00 00 00	 mov	 eax, 5
  013ba	b9 04 00 00 00	 mov	 ecx, 4
  013bf	f3 aa		 rep stosb

; 1555 :                     memset (pos+4, 0, 40);

  013c1	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  013c6	48 83 c0 04	 add	 rax, 4
  013ca	48 8b f8	 mov	 rdi, rax
  013cd	33 c0		 xor	 eax, eax
  013cf	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  013d4	f3 aa		 rep stosb

; 1556 :                     if (trks <= 65535)

  013d6	81 bc 24 94 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  013e1	77 57		 ja	 SHORT $LN47@create_ckd

; 1557 :                     {
; 1558 :                         store_hw(pos+4, 2);                   // DS5AVEXT + 00

  013e3	66 b9 02 00	 mov	 cx, 2
  013e7	e8 00 00 00 00	 call	 _byteswap_ushort
  013ec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  013f1	48 83 c1 04	 add	 rcx, 4
  013f5	0f b7 d0	 movzx	 edx, ax
  013f8	e8 00 00 00 00	 call	 store_hw_noswap

; 1559 :                         store_hw(pos+6, volcyls - 1);         // DS5AVEXT + 02

  013fd	8b 84 24 10 0f
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  01404	ff c8		 dec	 eax
  01406	0f b7 c8	 movzx	 ecx, ax
  01409	e8 00 00 00 00	 call	 _byteswap_ushort
  0140e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01413	48 83 c1 06	 add	 rcx, 6
  01417	0f b7 d0	 movzx	 edx, ax
  0141a	e8 00 00 00 00	 call	 store_hw_noswap

; 1560 :                         pos[8] = heads - 2;                   // DS5AVEXT + 04

  0141f	8b 84 24 e8 0e
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  01426	83 e8 02	 sub	 eax, 2
  01429	b9 01 00 00 00	 mov	 ecx, 1
  0142e	48 6b c9 08	 imul	 rcx, rcx, 8
  01432	48 8b 54 24 68	 mov	 rdx, QWORD PTR pos$[rsp]
  01437	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN47@create_ckd:

; 1561 :                     }
; 1562 :                     pos += 44;

  0143a	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0143f	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  01443	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1563 : 
; 1564 :                     /* track 1 record 2 data */
; 1565 :                     memset (pos, 0, 96);

  01448	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  0144d	33 c0		 xor	 eax, eax
  0144f	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  01454	f3 aa		 rep stosb

; 1566 :                     pos[0] = 0xf5;                            // DS5FMTID

  01456	b8 01 00 00 00	 mov	 eax, 1
  0145b	48 6b c0 00	 imul	 rax, rax, 0
  0145f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01464	c6 04 01 f5	 mov	 BYTE PTR [rcx+rax], 245	; 000000f5H

; 1567 :                     pos += 96;

  01468	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0146d	48 83 c0 60	 add	 rax, 96			; 00000060H
  01471	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1568 : 
; 1569 :                     /* build format 7 dscb */
; 1570 :                     if (trks > 65535)

  01476	81 bc 24 94 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  01481	0f 86 24 01 00
	00		 jbe	 $LN48@create_ckd

; 1571 :                     {
; 1572 :                         rechdr = (CKD_RECHDR*)pos;

  01487	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0148c	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1573 :                         pos += CKD_RECHDR_SIZE;

  01491	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01496	48 83 c0 08	 add	 rax, 8
  0149a	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1574 : 
; 1575 :                         /* track 1 record 3 count */
; 1576 :                         store_hw(&rechdr->cyl, cyl);

  0149f	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  014a4	e8 00 00 00 00	 call	 _byteswap_ushort
  014a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  014ae	0f b7 d0	 movzx	 edx, ax
  014b1	e8 00 00 00 00	 call	 store_hw_noswap

; 1577 :                         store_hw(&rechdr->head, head);

  014b6	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  014be	e8 00 00 00 00	 call	 _byteswap_ushort
  014c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  014c8	48 83 c1 02	 add	 rcx, 2
  014cc	0f b7 d0	 movzx	 edx, ax
  014cf	e8 00 00 00 00	 call	 store_hw_noswap

; 1578 :                         rechdr->rec = r;

  014d4	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  014d9	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  014de	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1579 :                         rechdr->klen = 44;

  014e1	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  014e6	c6 40 05 2c	 mov	 BYTE PTR [rax+5], 44	; 0000002cH

; 1580 :                         store_hw(&rechdr->dlen, 96);

  014ea	66 b9 60 00	 mov	 cx, 96			; 00000060H
  014ee	e8 00 00 00 00	 call	 _byteswap_ushort
  014f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  014f8	48 83 c1 06	 add	 rcx, 6
  014fc	0f b7 d0	 movzx	 edx, ax
  014ff	e8 00 00 00 00	 call	 store_hw_noswap

; 1581 :                         r++;

  01504	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  01509	fe c0		 inc	 al
  0150b	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1582 : 
; 1583 :                         /* track 1 record 2 key */
; 1584 :                         memset (pos, 0x07, 4);                // DS7KEYID

  0150f	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  01514	b8 07 00 00 00	 mov	 eax, 7
  01519	b9 04 00 00 00	 mov	 ecx, 4
  0151e	f3 aa		 rep stosb

; 1585 :                         memset (pos+4, 0, 40);

  01520	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01525	48 83 c0 04	 add	 rax, 4
  01529	48 8b f8	 mov	 rdi, rax
  0152c	33 c0		 xor	 eax, eax
  0152e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  01533	f3 aa		 rep stosb

; 1586 :                         store_fw(pos+4, 2);                   // DS7EXTNT + 00

  01535	b9 02 00 00 00	 mov	 ecx, 2
  0153a	e8 00 00 00 00	 call	 _byteswap_ulong
  0153f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01544	48 83 c1 04	 add	 rcx, 4
  01548	8b d0		 mov	 edx, eax
  0154a	e8 00 00 00 00	 call	 store_fw_noswap

; 1587 :                         store_fw(pos+8, trks - 1);            // DS7EXTNT + 04

  0154f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR trks$[rsp]
  01556	ff c8		 dec	 eax
  01558	8b c8		 mov	 ecx, eax
  0155a	e8 00 00 00 00	 call	 _byteswap_ulong
  0155f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01564	48 83 c1 08	 add	 rcx, 8
  01568	8b d0		 mov	 edx, eax
  0156a	e8 00 00 00 00	 call	 store_fw_noswap

; 1588 :                         pos += 44;

  0156f	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01574	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  01578	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1589 : 
; 1590 :                         /* track 1 record 2 data */
; 1591 :                         memset (pos, 0, 96);

  0157d	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  01582	33 c0		 xor	 eax, eax
  01584	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  01589	f3 aa		 rep stosb

; 1592 :                         pos[0] = 0xf7;                        // DS7FMTID

  0158b	b8 01 00 00 00	 mov	 eax, 1
  01590	48 6b c0 00	 imul	 rax, rax, 0
  01594	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01599	c6 04 01 f7	 mov	 BYTE PTR [rcx+rax], 247	; 000000f7H

; 1593 :                         pos += 96;

  0159d	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  015a2	48 83 c0 60	 add	 rax, 96			; 00000060H
  015a6	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax
$LN48@create_ckd:

; 1594 :                     }
; 1595 : 
; 1596 :                     n = 12 - r + 1;

  015ab	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  015b0	b9 0c 00 00 00	 mov	 ecx, 12
  015b5	2b c8		 sub	 ecx, eax
  015b7	8b c1		 mov	 eax, ecx
  015b9	ff c0		 inc	 eax
  015bb	89 84 24 d8 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 1597 :                     for (i = 0; i < n; i++)

  015c2	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  015cd	eb 10		 jmp	 SHORT $LN13@create_ckd
$LN11@create_ckd:
  015cf	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  015d6	ff c0		 inc	 eax
  015d8	89 84 24 88 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN13@create_ckd:
  015df	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  015e6	39 84 24 88 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  015ed	0f 8d 9d 00 00
	00		 jge	 $LN12@create_ckd

; 1598 :                     {
; 1599 :                         rechdr = (CKD_RECHDR*)pos;

  015f3	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  015f8	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1600 :                         pos += CKD_RECHDR_SIZE;

  015fd	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01602	48 83 c0 08	 add	 rax, 8
  01606	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1601 : 
; 1602 :                         store_hw(&rechdr->cyl, cyl);

  0160b	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  01610	e8 00 00 00 00	 call	 _byteswap_ushort
  01615	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0161a	0f b7 d0	 movzx	 edx, ax
  0161d	e8 00 00 00 00	 call	 store_hw_noswap

; 1603 :                         store_hw(&rechdr->head, head);

  01622	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  0162a	e8 00 00 00 00	 call	 _byteswap_ushort
  0162f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  01634	48 83 c1 02	 add	 rcx, 2
  01638	0f b7 d0	 movzx	 edx, ax
  0163b	e8 00 00 00 00	 call	 store_hw_noswap

; 1604 :                         rechdr->rec = r;

  01640	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  01645	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  0164a	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1605 :                         rechdr->klen = 44;

  0164d	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  01652	c6 40 05 2c	 mov	 BYTE PTR [rax+5], 44	; 0000002cH

; 1606 :                         store_hw(&rechdr->dlen, 96);

  01656	66 b9 60 00	 mov	 cx, 96			; 00000060H
  0165a	e8 00 00 00 00	 call	 _byteswap_ushort
  0165f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  01664	48 83 c1 06	 add	 rcx, 6
  01668	0f b7 d0	 movzx	 edx, ax
  0166b	e8 00 00 00 00	 call	 store_hw_noswap

; 1607 :                         pos += 140;

  01670	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01675	48 05 8c 00 00
	00		 add	 rax, 140		; 0000008cH
  0167b	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1608 :                         r++;

  01680	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  01685	fe c0		 inc	 al
  01687	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1609 :                     }

  0168b	e9 3f ff ff ff	 jmp	 $LN11@create_ckd
$LN12@create_ckd:

; 1610 :                 }

  01690	e9 6f 01 00 00	 jmp	 $LN46@create_ckd
$LN45@create_ckd:

; 1611 : 
; 1612 :                 /* Specific null track formatting */
; 1613 :                 else if (nullfmt == CKD_NULLTRK_FMT0)

  01695	83 bc 24 38 0f
	00 00 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  0169d	0f 85 8b 00 00
	00		 jne	 $LN49@create_ckd

; 1614 :                 {
; 1615 :                     rechdr = (CKD_RECHDR*)pos;

  016a3	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  016a8	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1616 :                     pos += CKD_RECHDR_SIZE;

  016ad	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  016b2	48 83 c0 08	 add	 rax, 8
  016b6	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1617 : 
; 1618 :                     store_hw(&rechdr->cyl, cyl);

  016bb	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  016c0	e8 00 00 00 00	 call	 _byteswap_ushort
  016c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  016ca	0f b7 d0	 movzx	 edx, ax
  016cd	e8 00 00 00 00	 call	 store_hw_noswap

; 1619 :                     store_hw(&rechdr->head, head);

  016d2	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  016da	e8 00 00 00 00	 call	 _byteswap_ushort
  016df	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  016e4	48 83 c1 02	 add	 rcx, 2
  016e8	0f b7 d0	 movzx	 edx, ax
  016eb	e8 00 00 00 00	 call	 store_hw_noswap

; 1620 :                     rechdr->rec = r;

  016f0	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  016f5	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  016fa	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1621 :                     rechdr->klen = 0;

  016fd	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  01702	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 1622 :                     store_hw(&rechdr->dlen, 0);

  01706	33 c9		 xor	 ecx, ecx
  01708	e8 00 00 00 00	 call	 _byteswap_ushort
  0170d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  01712	48 83 c1 06	 add	 rcx, 6
  01716	0f b7 d0	 movzx	 edx, ax
  01719	e8 00 00 00 00	 call	 store_hw_noswap

; 1623 :                     r++;

  0171e	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  01723	fe c0		 inc	 al
  01725	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1624 :                 }

  01729	e9 d6 00 00 00	 jmp	 $LN50@create_ckd
$LN49@create_ckd:

; 1625 :                 else if (nullfmt == CKD_NULLTRK_FMT2)

  0172e	83 bc 24 38 0f
	00 00 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  01736	0f 85 c8 00 00
	00		 jne	 $LN51@create_ckd

; 1626 :                 {
; 1627 :                     /* Other linux tracks have 12 4096 data records */
; 1628 :                     for (i = 0; i < 12; i++)

  0173c	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01747	eb 10		 jmp	 SHORT $LN16@create_ckd
$LN14@create_ckd:
  01749	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01750	ff c0		 inc	 eax
  01752	89 84 24 88 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN16@create_ckd:
  01759	83 bc 24 88 00
	00 00 0c	 cmp	 DWORD PTR i$[rsp], 12
  01761	0f 8d 9d 00 00
	00		 jge	 $LN15@create_ckd

; 1629 :                     {
; 1630 :                         rechdr = (CKD_RECHDR*)pos;

  01767	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0176c	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 1631 :                         pos += CKD_RECHDR_SIZE;

  01771	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01776	48 83 c0 08	 add	 rax, 8
  0177a	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1632 :                         store_hw(&rechdr->cyl, cyl);

  0177f	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  01784	e8 00 00 00 00	 call	 _byteswap_ushort
  01789	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0178e	0f b7 d0	 movzx	 edx, ax
  01791	e8 00 00 00 00	 call	 store_hw_noswap

; 1633 :                         store_hw(&rechdr->head, head);

  01796	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  0179e	e8 00 00 00 00	 call	 _byteswap_ushort
  017a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  017a8	48 83 c1 02	 add	 rcx, 2
  017ac	0f b7 d0	 movzx	 edx, ax
  017af	e8 00 00 00 00	 call	 store_hw_noswap

; 1634 :                         rechdr->rec = r;

  017b4	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  017b9	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  017be	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1635 :                         rechdr->klen = 0;

  017c1	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  017c6	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 1636 :                         store_hw(&rechdr->dlen, 4096);

  017ca	66 b9 00 10	 mov	 cx, 4096		; 00001000H
  017ce	e8 00 00 00 00	 call	 _byteswap_ushort
  017d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  017d8	48 83 c1 06	 add	 rcx, 6
  017dc	0f b7 d0	 movzx	 edx, ax
  017df	e8 00 00 00 00	 call	 store_hw_noswap

; 1637 :                         pos += 4096;

  017e4	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  017e9	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  017ef	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1638 :                         r++;

  017f4	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  017f9	fe c0		 inc	 al
  017fb	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 1639 :                     }

  017ff	e9 45 ff ff ff	 jmp	 $LN14@create_ckd
$LN15@create_ckd:
$LN51@create_ckd:
$LN50@create_ckd:
$LN46@create_ckd:
$LN41@create_ckd:

; 1640 :                 }
; 1641 : 
; 1642 :                 /* End-of-track marker */
; 1643 :                 memcpy( pos, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  01804	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01809	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  01810	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1644 :                 pos += 8;

  01813	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01818	48 83 c0 08	 add	 rax, 8
  0181c	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 1645 : 
; 1646 :                 /* Calculate length to write */
; 1647 :                 if (comp == 0xff)

  01821	0f b6 84 24 28
	0f 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  01829	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0182e	75 10		 jne	 SHORT $LN52@create_ckd

; 1648 :                     len = (int)trksize;

  01830	8b 84 24 f0 0e
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  01837	89 84 24 98 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  0183e	eb 76		 jmp	 SHORT $LN53@create_ckd
$LN52@create_ckd:

; 1649 :                 else
; 1650 :                 {
; 1651 :                     len = (int)(pos - buf);

  01840	48 8b 84 24 f8
	0e 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  01848	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0184d	48 2b c8	 sub	 rcx, rax
  01850	48 8b c1	 mov	 rax, rcx
  01853	89 84 24 98 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1652 :                     l2[trk].L2_trkoff = cpos;

  0185a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  01861	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR cpos$[rsp]
  01868	89 8c c4 60 05
	00 00		 mov	 DWORD PTR l2$[rsp+rax*8], ecx

; 1653 :                     l2[trk].L2_len    = l2[trk].L2_size  = len;

  0186f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  01876	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR len$[rsp]
  0187e	66 89 8c c4 66
	05 00 00	 mov	 WORD PTR l2$[rsp+rax*8+6], cx
  01886	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0188d	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR len$[rsp]
  01895	66 89 8c c4 64
	05 00 00	 mov	 WORD PTR l2$[rsp+rax*8+4], cx

; 1654 :                     cpos += len;

  0189d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  018a4	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR cpos$[rsp]
  018ab	03 c8		 add	 ecx, eax
  018ad	8b c1		 mov	 eax, ecx
  018af	89 84 24 9c 00
	00 00		 mov	 DWORD PTR cpos$[rsp], eax
$LN53@create_ckd:

; 1655 :                 }
; 1656 : 
; 1657 :                 /* Write the track to the file */
; 1658 :                 rc = write (fd, buf, len);

  018b6	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  018be	48 8b 94 24 f8
	0e 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  018c6	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  018cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  018d3	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1659 :                 if (rc != (int)len)

  018d7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  018de	39 44 24 7c	 cmp	 DWORD PTR rc$[rsp], eax
  018e2	0f 84 bb 00 00
	00		 je	 $LN54@create_ckd

; 1660 :                 {
; 1661 :                     FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  018e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  018ee	83 38 00	 cmp	 DWORD PTR [rax], 0
  018f1	74 18		 je	 SHORT $LN80@create_ckd
  018f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  018f9	8b 08		 mov	 ecx, DWORD PTR [rax]
  018fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01901	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv977[rsp], rax
  01909	eb 0f		 jmp	 SHORT $LN81@create_ckd
$LN80@create_ckd:
  0190b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169560
  01912	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv977[rsp], rax
$LN81@create_ckd:
  0191a	b9 02 00 00 00	 mov	 ecx, 2
  0191f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01925	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv977[rsp]
  0192d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01932	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169561
  01939	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0193e	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01946	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0194b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01954	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0195d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169562
  01964	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01969	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169563
  01970	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01975	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0197a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01980	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169564
  01987	ba 7e 06 00 00	 mov	 edx, 1662		; 0000067eH
  0198c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169565
  01993	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1662 :                             "write()", errno ? strerror( errno ) : "incomplete" );
; 1663 :                     return -1;

  01999	b8 ff ff ff ff	 mov	 eax, -1
  0199e	e9 7e 05 00 00	 jmp	 $LN1@create_ckd
$LN54@create_ckd:

; 1664 :                 }
; 1665 : 
; 1666 :                 /* Exit if compressed disk and current track is 1 */
; 1667 :                 if (comp != 0xff && trk == 1) break;

  019a3	0f b6 84 24 28
	0f 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  019ab	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  019b0	74 0c		 je	 SHORT $LN55@create_ckd
  019b2	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR trk$[rsp], 1
  019ba	75 02		 jne	 SHORT $LN55@create_ckd
  019bc	eb 15		 jmp	 SHORT $LN6@create_ckd
$LN55@create_ckd:

; 1668 : 
; 1669 :                 trk++;

  019be	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  019c5	ff c0		 inc	 eax
  019c7	89 84 24 90 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 1670 : 
; 1671 :             } /* end for(head) */

  019ce	e9 0b f1 ff ff	 jmp	 $LN5@create_ckd
$LN6@create_ckd:

; 1672 : 
; 1673 :             /* Exit if compressed disk */
; 1674 :             if (comp != 0xff) break;

  019d3	0f b6 84 24 28
	0f 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  019db	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  019e0	74 02		 je	 SHORT $LN56@create_ckd
  019e2	eb 05		 jmp	 SHORT $LN3@create_ckd
$LN56@create_ckd:

; 1675 : 
; 1676 :         } /* end for(cyl) */

  019e4	e9 65 f0 ff ff	 jmp	 $LN2@create_ckd
$LN3@create_ckd:

; 1677 : 
; 1678 :     } /* `dasdcopy' bit is off */

  019e9	eb 0d		 jmp	 SHORT $LN36@create_ckd
$LN35@create_ckd:

; 1679 :     else
; 1680 :         cyl = end + 1;

  019eb	8b 84 24 08 0f
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  019f2	ff c0		 inc	 eax
  019f4	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax
$LN36@create_ckd:

; 1681 : 
; 1682 :     /* Complete building the compressed file */
; 1683 :     if (comp != 0xff)

  019f8	0f b6 84 24 28
	0f 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  01a00	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01a05	0f 84 c6 03 00
	00		 je	 $LN57@create_ckd

; 1684 :     {
; 1685 :         cdevhdr.cdh_size = cdevhdr.cdh_used = cpos;

  01a0b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR cpos$[rsp]
  01a12	89 84 24 70 01
	00 00		 mov	 DWORD PTR cdevhdr$[rsp+16], eax
  01a19	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR cdevhdr$[rsp+16]
  01a20	89 84 24 6c 01
	00 00		 mov	 DWORD PTR cdevhdr$[rsp+12], eax

; 1686 : 
; 1687 :         /* Rewrite the compressed device header */
; 1688 :         rcoff = lseek (fd, CKD_DEVHDR_SIZE, SEEK_SET);

  01a27	45 33 c0	 xor	 r8d, r8d
  01a2a	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  01a2f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01a36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01a3c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR rcoff$[rsp], rax

; 1689 :         if (rcoff == -1)

  01a44	48 83 bc 24 e8
	00 00 00 ff	 cmp	 QWORD PTR rcoff$[rsp], -1
  01a4d	0f 85 9f 00 00
	00		 jne	 $LN58@create_ckd

; 1690 :         {
; 1691 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01a53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01a59	8b 08		 mov	 ecx, DWORD PTR [rax]
  01a5b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01a61	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv1006[rsp], rax
  01a69	b9 02 00 00 00	 mov	 ecx, 2
  01a6e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a74	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv1006[rsp]
  01a7c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01a81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169570
  01a88	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01a8d	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01a95	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01a9a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01aa3	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01aac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169571
  01ab3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01ab8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169572
  01abf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01ac4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ac9	41 b9 03 00 00
	00		 mov	 r9d, 3
  01acf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169573
  01ad6	ba 9c 06 00 00	 mov	 edx, 1692		; 0000069cH
  01adb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169574
  01ae2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1692 :                     "lseek()", strerror( errno ));
; 1693 :             return -1;

  01ae8	b8 ff ff ff ff	 mov	 eax, -1
  01aed	e9 2f 04 00 00	 jmp	 $LN1@create_ckd
$LN58@create_ckd:

; 1694 :         }
; 1695 :         rc = write (fd, &cdevhdr, CCKD_DEVHDR_SIZE);

  01af2	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  01af8	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  01b00	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01b07	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  01b0d	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1696 :         if (rc < (int)            CCKD_DEVHDR_SIZE)

  01b11	81 7c 24 7c 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  01b19	0f 8d bb 00 00
	00		 jge	 $LN59@create_ckd

; 1697 :         {
; 1698 :           FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01b1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01b25	83 38 00	 cmp	 DWORD PTR [rax], 0
  01b28	74 18		 je	 SHORT $LN82@create_ckd
  01b2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01b30	8b 08		 mov	 ecx, DWORD PTR [rax]
  01b32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01b38	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv1033[rsp], rax
  01b40	eb 0f		 jmp	 SHORT $LN83@create_ckd
$LN82@create_ckd:
  01b42	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169576
  01b49	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv1033[rsp], rax
$LN83@create_ckd:
  01b51	b9 02 00 00 00	 mov	 ecx, 2
  01b56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b5c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv1033[rsp]
  01b64	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01b69	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169577
  01b70	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01b75	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01b7d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01b82	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01b8b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01b94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169578
  01b9b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01ba0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169579
  01ba7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01bac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bb1	41 b9 03 00 00
	00		 mov	 r9d, 3
  01bb7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169580
  01bbe	ba a3 06 00 00	 mov	 edx, 1699		; 000006a3H
  01bc3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169581
  01bca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1699 :                   "write()", errno ? strerror( errno ) : "incomplete" );
; 1700 :             return -1;

  01bd0	b8 ff ff ff ff	 mov	 eax, -1
  01bd5	e9 47 03 00 00	 jmp	 $LN1@create_ckd
$LN59@create_ckd:

; 1701 :         }
; 1702 : 
; 1703 :         /* Rewrite the secondary lookup table */
; 1704 :         rcoff = lseek (fd, (off_t)l1[0], SEEK_SET);

  01bda	b8 04 00 00 00	 mov	 eax, 4
  01bdf	48 6b c0 00	 imul	 rax, rax, 0
  01be3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR l1$[rsp]
  01beb	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  01bee	45 33 c0	 xor	 r8d, r8d
  01bf1	8b d0		 mov	 edx, eax
  01bf3	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01bfa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01c00	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR rcoff$[rsp], rax

; 1705 :         if (rcoff == -1)

  01c08	48 83 bc 24 e8
	00 00 00 ff	 cmp	 QWORD PTR rcoff$[rsp], -1
  01c11	0f 85 9f 00 00
	00		 jne	 $LN60@create_ckd

; 1706 :         {
; 1707 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01c17	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01c1d	8b 08		 mov	 ecx, DWORD PTR [rax]
  01c1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01c25	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv1088[rsp], rax
  01c2d	b9 02 00 00 00	 mov	 ecx, 2
  01c32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01c38	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv1088[rsp]
  01c40	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01c45	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169583
  01c4c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01c51	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01c59	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01c5e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01c67	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01c70	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169584
  01c77	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01c7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169585
  01c83	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c88	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c8d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01c93	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169586
  01c9a	ba ac 06 00 00	 mov	 edx, 1708		; 000006acH
  01c9f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169587
  01ca6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1708 :                     "lseek()", strerror( errno ));
; 1709 :             return -1;

  01cac	b8 ff ff ff ff	 mov	 eax, -1
  01cb1	e9 6b 02 00 00	 jmp	 $LN1@create_ckd
$LN60@create_ckd:

; 1710 :         }
; 1711 :         rc = write (fd, &l2, CCKD_L2TAB_SIZE);

  01cb6	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  01cbc	48 8d 94 24 60
	05 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  01cc4	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01ccb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  01cd1	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1712 :         if (rc < (int)       CCKD_L2TAB_SIZE)

  01cd5	81 7c 24 7c 00
	08 00 00	 cmp	 DWORD PTR rc$[rsp], 2048 ; 00000800H
  01cdd	0f 8d bb 00 00
	00		 jge	 $LN61@create_ckd

; 1713 :         {
; 1714 :           FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01ce3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01ce9	83 38 00	 cmp	 DWORD PTR [rax], 0
  01cec	74 18		 je	 SHORT $LN84@create_ckd
  01cee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01cf4	8b 08		 mov	 ecx, DWORD PTR [rax]
  01cf6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01cfc	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv1115[rsp], rax
  01d04	eb 0f		 jmp	 SHORT $LN85@create_ckd
$LN84@create_ckd:
  01d06	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169589
  01d0d	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv1115[rsp], rax
$LN85@create_ckd:
  01d15	b9 02 00 00 00	 mov	 ecx, 2
  01d1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01d20	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv1115[rsp]
  01d28	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01d2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169590
  01d34	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01d39	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01d41	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01d46	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01d4f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01d58	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169591
  01d5f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01d64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169592
  01d6b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01d70	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d75	41 b9 03 00 00
	00		 mov	 r9d, 3
  01d7b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169593
  01d82	ba b3 06 00 00	 mov	 edx, 1715		; 000006b3H
  01d87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169594
  01d8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1715 :                   "write()", errno ? strerror( errno ) : "incomplete" );
; 1716 :             return -1;

  01d94	b8 ff ff ff ff	 mov	 eax, -1
  01d99	e9 83 01 00 00	 jmp	 $LN1@create_ckd
$LN61@create_ckd:

; 1717 :         }
; 1718 :         rc = ftruncate(fd, (off_t)cdevhdr.cdh_size);

  01d9e	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR cdevhdr$[rsp+12]
  01da5	8b d0		 mov	 edx, eax
  01da7	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01dae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  01db4	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1719 : 
; 1720 :         free (l1);

  01db8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR l1$[rsp]
  01dc0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1721 :         cyl = volcyls;

  01dc6	8b 84 24 10 0f
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  01dcd	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax
$LN57@create_ckd:

; 1722 :     }
; 1723 : 
; 1724 :     /* Close the DASD image file */
; 1725 :     rc = close (fd);

  01dd1	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01dd8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  01dde	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1726 :     if (rc < 0)

  01de2	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  01de7	0f 8d 9f 00 00
	00		 jge	 $LN62@create_ckd

; 1727 :     {
; 1728 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01ded	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01df3	8b 08		 mov	 ecx, DWORD PTR [rax]
  01df5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01dfb	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv1138[rsp], rax
  01e03	b9 02 00 00 00	 mov	 ecx, 2
  01e08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01e0e	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv1138[rsp]
  01e16	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01e1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169596
  01e22	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01e27	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01e2f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01e34	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01e3d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01e46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169597
  01e4d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169598
  01e59	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e5e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e63	41 b9 03 00 00
	00		 mov	 r9d, 3
  01e69	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169599
  01e70	ba c1 06 00 00	 mov	 edx, 1729		; 000006c1H
  01e75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169600
  01e7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1729 :                 "close()", strerror( errno ));
; 1730 :         return -1;

  01e82	b8 ff ff ff ff	 mov	 eax, -1
  01e87	e9 95 00 00 00	 jmp	 $LN1@create_ckd
$LN62@create_ckd:

; 1731 :     }
; 1732 : 
; 1733 :     /* Display completion message */
; 1734 :     // "%1d:%04X CKD file %s: %u %s successfully written"
; 1735 :     FWRMSG( stdout, HHC00460, "I", 0, 0, fname,

  01e8c	8b 84 24 00 0f
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  01e93	8b 4c 24 78	 mov	 ecx, DWORD PTR cyl$[rsp]
  01e97	2b c8		 sub	 ecx, eax
  01e99	8b c1		 mov	 eax, ecx
  01e9b	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv1156[rsp], eax
  01ea2	b9 01 00 00 00	 mov	 ecx, 1
  01ea7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01ead	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169601
  01eb4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01eb9	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv1156[rsp]
  01ec0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01ec4	48 8b 8c 24 d0
	0e 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01ecc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01ed1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01eda	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01ee3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169602
  01eea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01eef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169603
  01ef6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01efb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01f00	41 b9 03 00 00
	00		 mov	 r9d, 3
  01f06	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169604
  01f0d	ba c8 06 00 00	 mov	 edx, 1736		; 000006c8H
  01f12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169605
  01f19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1736 :             cyl - start, "cylinders" );
; 1737 :     return 0;

  01f1f	33 c0		 xor	 eax, eax
$LN1@create_ckd:

; 1738 : 
; 1739 : } /* end function create_ckd_file */

  01f21	48 8b 8c 24 a0
	0e 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01f29	48 33 cc	 xor	 rcx, rsp
  01f2c	e8 00 00 00 00	 call	 __security_check_cookie
  01f31	48 81 c4 b8 0e
	00 00		 add	 rsp, 3768		; 00000eb8H
  01f38	5f		 pop	 rdi
  01f39	5e		 pop	 rsi
  01f3a	c3		 ret	 0
create_ckd_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
c$ = 48
offset$ = 52
xi$ = 56
i$ = 60
lineoff$ = 64
firstsame$ = 68
lastsame$ = 72
tv65 = 76
pchar$ = 80
maxoffset$ = 88
$T1 = 96
print_chars$ = 104
hex_chars$ = 128
prev_hex$ = 192
__$ArrayPad$ = 256
ascii$ = 288
addr$ = 296
len$ = 304
begoffset$ = 312
do_data_dump PROC

; 122  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	57		 push	 rdi
  00014	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 123  :     #define  DD_BPL      16     // bytes per line
; 124  :     #define  MAX_DD    2048     // must be multiple of DD_BPL
; 125  : 
; 126  :     CASSERT( MAX_DD == ROUND_UP( MAX_DD, DD_BPL ), dasdutil_c );
; 127  : 
; 128  :     unsigned int  maxoffset = len > MAX_DD ? MAX_DD : len;

  0002d	81 bc 24 30 01
	00 00 00 08 00
	00		 cmp	 DWORD PTR len$[rsp], 2048 ; 00000800H
  00038	76 0a		 jbe	 SHORT $LN20@do_data_du
  0003a	c7 44 24 4c 00
	08 00 00	 mov	 DWORD PTR tv65[rsp], 2048 ; 00000800H
  00042	eb 0b		 jmp	 SHORT $LN21@do_data_du
$LN20@do_data_du:
  00044	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0004b	89 44 24 4c	 mov	 DWORD PTR tv65[rsp], eax
$LN21@do_data_du:
  0004f	8b 44 24 4c	 mov	 eax, DWORD PTR tv65[rsp]
  00053	89 44 24 58	 mov	 DWORD PTR maxoffset$[rsp], eax

; 129  :     unsigned int  i, xi, offset, lineoff = begoffset;

  00057	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR begoffset$[rsp]
  0005e	89 44 24 40	 mov	 DWORD PTR lineoff$[rsp], eax

; 130  : 
; 131  :     int   firstsame = 0, lastsame = 0;

  00062	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR firstsame$[rsp], 0
  0006a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR lastsame$[rsp], 0

; 132  :     BYTE  c = 0, *pchar = NULL;

  00072	c6 44 24 30 00	 mov	 BYTE PTR c$[rsp], 0
  00077	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR pchar$[rsp], 0

; 133  : 
; 134  :     char  print_chars [ DD_BPL + 1 ]  = {0};

  00080	48 8d 44 24 68	 lea	 rax, QWORD PTR print_chars$[rsp]
  00085	48 8b f8	 mov	 rdi, rax
  00088	33 c0		 xor	 eax, eax
  0008a	b9 11 00 00 00	 mov	 ecx, 17
  0008f	f3 aa		 rep stosb

; 135  :     char  hex_chars   [ DD_BPL * 4 ]  = {0};

  00091	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hex_chars$[rsp]
  00099	48 8b f8	 mov	 rdi, rax
  0009c	33 c0		 xor	 eax, eax
  0009e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000a3	f3 aa		 rep stosb

; 136  :     char  prev_hex    [ DD_BPL * 4 ]  = {0};

  000a5	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR prev_hex$[rsp]
  000ad	48 8b f8	 mov	 rdi, rax
  000b0	33 c0		 xor	 eax, eax
  000b2	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000b7	f3 aa		 rep stosb

; 137  : 
; 138  :     pchar = (BYTE*)addr;    /* init pointer to char being processed */

  000b9	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000c1	48 89 44 24 50	 mov	 QWORD PTR pchar$[rsp], rax

; 139  : 
; 140  :     for (offset = begoffset; offset < maxoffset; )

  000c6	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR begoffset$[rsp]
  000cd	89 44 24 34	 mov	 DWORD PTR offset$[rsp], eax
$LN2@do_data_du:
  000d1	8b 44 24 58	 mov	 eax, DWORD PTR maxoffset$[rsp]
  000d5	39 44 24 34	 cmp	 DWORD PTR offset$[rsp], eax
  000d9	0f 83 c5 01 00
	00		 jae	 $LN3@do_data_du

; 141  :     {
; 142  :         if (offset > begoffset) /* (only if NOT first time) */

  000df	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR begoffset$[rsp]
  000e6	39 44 24 34	 cmp	 DWORD PTR offset$[rsp], eax
  000ea	76 74		 jbe	 SHORT $LN8@do_data_du

; 143  :         {
; 144  :             /* Current line same as previous line? */
; 145  :             if (strcmp( hex_chars, prev_hex ) == 0)

  000ec	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR prev_hex$[rsp]
  000f4	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR hex_chars$[rsp]
  000fc	e8 00 00 00 00	 call	 strcmp
  00101	85 c0		 test	 eax, eax
  00103	75 19		 jne	 SHORT $LN9@do_data_du

; 146  :             {
; 147  :                 /* Save offset of first same line */
; 148  :                 if (!firstsame)

  00105	83 7c 24 44 00	 cmp	 DWORD PTR firstsame$[rsp], 0
  0010a	75 08		 jne	 SHORT $LN11@do_data_du

; 149  :                     firstsame = lineoff;

  0010c	8b 44 24 40	 mov	 eax, DWORD PTR lineoff$[rsp]
  00110	89 44 24 44	 mov	 DWORD PTR firstsame$[rsp], eax
$LN11@do_data_du:

; 150  : 
; 151  :                 /* Update offset of last same line */
; 152  :                 lastsame = lineoff;

  00114	8b 44 24 40	 mov	 eax, DWORD PTR lineoff$[rsp]
  00118	89 44 24 48	 mov	 DWORD PTR lastsame$[rsp], eax

; 153  :             }

  0011c	eb 42		 jmp	 SHORT $LN10@do_data_du
$LN9@do_data_du:

; 154  :             else /* This line is different */
; 155  :             {
; 156  :                 same_as_above( &firstsame, &lastsame, lineoff, hex_chars, print_chars );

  0011e	48 8d 44 24 68	 lea	 rax, QWORD PTR print_chars$[rsp]
  00123	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00128	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR hex_chars$[rsp]
  00130	44 8b 44 24 40	 mov	 r8d, DWORD PTR lineoff$[rsp]
  00135	48 8d 54 24 48	 lea	 rdx, QWORD PTR lastsame$[rsp]
  0013a	48 8d 4c 24 44	 lea	 rcx, QWORD PTR firstsame$[rsp]
  0013f	e8 00 00 00 00	 call	 same_as_above

; 157  :                 STRLCPY( prev_hex, hex_chars );

  00144	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0014a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR hex_chars$[rsp]
  00152	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR prev_hex$[rsp]
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN10@do_data_du:
$LN8@do_data_du:

; 158  :             }
; 159  :         }
; 160  : 
; 161  :         /* Format next print line into hex_chars and print_chars */
; 162  : 
; 163  :         memset( print_chars,  0,   sizeof( print_chars ));

  00160	48 8d 44 24 68	 lea	 rax, QWORD PTR print_chars$[rsp]
  00165	48 8b f8	 mov	 rdi, rax
  00168	33 c0		 xor	 eax, eax
  0016a	b9 11 00 00 00	 mov	 ecx, 17
  0016f	f3 aa		 rep stosb

; 164  :         memset( hex_chars,  SPACE, sizeof( hex_chars   ));

  00171	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hex_chars$[rsp]
  00179	48 8b f8	 mov	 rdi, rax
  0017c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00181	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00186	f3 aa		 rep stosb

; 165  : 
; 166  :         lineoff = offset;   /* save this line's offset */

  00188	8b 44 24 34	 mov	 eax, DWORD PTR offset$[rsp]
  0018c	89 44 24 40	 mov	 DWORD PTR lineoff$[rsp], eax

; 167  : 
; 168  :         for (xi=0, i=0; i < DD_BPL; i++)

  00190	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR xi$[rsp], 0
  00198	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001a0	eb 0a		 jmp	 SHORT $LN7@do_data_du
$LN5@do_data_du:
  001a2	8b 44 24 3c	 mov	 eax, DWORD PTR i$[rsp]
  001a6	ff c0		 inc	 eax
  001a8	89 44 24 3c	 mov	 DWORD PTR i$[rsp], eax
$LN7@do_data_du:
  001ac	83 7c 24 3c 10	 cmp	 DWORD PTR i$[rsp], 16
  001b1	0f 83 c3 00 00
	00		 jae	 $LN6@do_data_du

; 169  :         {
; 170  :             c = *pchar++;

  001b7	48 8b 44 24 50	 mov	 rax, QWORD PTR pchar$[rsp]
  001bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001bf	88 44 24 30	 mov	 BYTE PTR c$[rsp], al
  001c3	48 8b 44 24 50	 mov	 rax, QWORD PTR pchar$[rsp]
  001c8	48 ff c0	 inc	 rax
  001cb	48 89 44 24 50	 mov	 QWORD PTR pchar$[rsp], rax

; 171  : 
; 172  :             if (offset < len)

  001d0	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001d7	39 44 24 34	 cmp	 DWORD PTR offset$[rsp], eax
  001db	73 62		 jae	 SHORT $LN12@do_data_du

; 173  :             {
; 174  :                 sprintf( hex_chars+xi, "%2.2X", c );

  001dd	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  001e2	8b 4c 24 38	 mov	 ecx, DWORD PTR xi$[rsp]
  001e6	48 8d 8c 0c 80
	00 00 00	 lea	 rcx, QWORD PTR hex_chars$[rsp+rcx]
  001ee	44 8b c0	 mov	 r8d, eax
  001f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168730
  001f8	e8 00 00 00 00	 call	 sprintf

; 175  :                 print_chars[i] = '.';

  001fd	8b 44 24 3c	 mov	 eax, DWORD PTR i$[rsp]
  00201	c6 44 04 68 2e	 mov	 BYTE PTR print_chars$[rsp+rax], 46 ; 0000002eH

; 176  : 
; 177  :                 if (!ascii)

  00206	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR ascii$[rsp]
  0020e	85 c0		 test	 eax, eax
  00210	75 0f		 jne	 SHORT $LN13@do_data_du

; 178  :                     c = guest_to_host(c);

  00212	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR c$[rsp]
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  0021d	88 44 24 30	 mov	 BYTE PTR c$[rsp], al
$LN13@do_data_du:

; 179  : 
; 180  :                 if (isprint(c))

  00221	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  00226	8b c8		 mov	 ecx, eax
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  0022e	85 c0		 test	 eax, eax
  00230	74 0d		 je	 SHORT $LN14@do_data_du

; 181  :                     print_chars[i] = c;

  00232	8b 44 24 3c	 mov	 eax, DWORD PTR i$[rsp]
  00236	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR c$[rsp]
  0023b	88 4c 04 68	 mov	 BYTE PTR print_chars$[rsp+rax], cl
$LN14@do_data_du:
$LN12@do_data_du:

; 182  :             }
; 183  : 
; 184  :             offset++;

  0023f	8b 44 24 34	 mov	 eax, DWORD PTR offset$[rsp]
  00243	ff c0		 inc	 eax
  00245	89 44 24 34	 mov	 DWORD PTR offset$[rsp], eax

; 185  :             xi += 2;

  00249	8b 44 24 38	 mov	 eax, DWORD PTR xi$[rsp]
  0024d	83 c0 02	 add	 eax, 2
  00250	89 44 24 38	 mov	 DWORD PTR xi$[rsp], eax

; 186  :             hex_chars[xi] = SPACE;

  00254	8b 44 24 38	 mov	 eax, DWORD PTR xi$[rsp]
  00258	c6 84 04 80 00
	00 00 20	 mov	 BYTE PTR hex_chars$[rsp+rax], 32 ; 00000020H

; 187  : 
; 188  :             if ((offset & 3) == 0)

  00260	8b 44 24 34	 mov	 eax, DWORD PTR offset$[rsp]
  00264	83 e0 03	 and	 eax, 3
  00267	85 c0		 test	 eax, eax
  00269	75 0a		 jne	 SHORT $LN15@do_data_du

; 189  :                 xi++;

  0026b	8b 44 24 38	 mov	 eax, DWORD PTR xi$[rsp]
  0026f	ff c0		 inc	 eax
  00271	89 44 24 38	 mov	 DWORD PTR xi$[rsp], eax
$LN15@do_data_du:

; 190  :         }

  00275	e9 28 ff ff ff	 jmp	 $LN5@do_data_du
$LN6@do_data_du:

; 191  : 
; 192  :         hex_chars[xi] = '\0';

  0027a	8b 44 24 38	 mov	 eax, DWORD PTR xi$[rsp]
  0027e	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  00283	48 83 7c 24 60
	40		 cmp	 QWORD PTR $T1[rsp], 64	; 00000040H
  00289	73 02		 jae	 SHORT $LN22@do_data_du
  0028b	eb 05		 jmp	 SHORT $LN23@do_data_du
$LN22@do_data_du:
  0028d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN23@do_data_du:
  00292	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  00297	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR hex_chars$[rsp+rax], 0

; 193  :     }

  0029f	e9 2d fe ff ff	 jmp	 $LN2@do_data_du
$LN3@do_data_du:

; 194  : 
; 195  :     if (firstsame || len <= MAX_DD)

  002a4	83 7c 24 44 00	 cmp	 DWORD PTR firstsame$[rsp], 0
  002a9	75 0d		 jne	 SHORT $LN17@do_data_du
  002ab	81 bc 24 30 01
	00 00 00 08 00
	00		 cmp	 DWORD PTR len$[rsp], 2048 ; 00000800H
  002b6	77 26		 ja	 SHORT $LN16@do_data_du
$LN17@do_data_du:

; 196  :         same_as_above( &firstsame, &lastsame, lineoff, hex_chars, print_chars );

  002b8	48 8d 44 24 68	 lea	 rax, QWORD PTR print_chars$[rsp]
  002bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c2	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR hex_chars$[rsp]
  002ca	44 8b 44 24 40	 mov	 r8d, DWORD PTR lineoff$[rsp]
  002cf	48 8d 54 24 48	 lea	 rdx, QWORD PTR lastsame$[rsp]
  002d4	48 8d 4c 24 44	 lea	 rcx, QWORD PTR firstsame$[rsp]
  002d9	e8 00 00 00 00	 call	 same_as_above
$LN16@do_data_du:

; 197  : 
; 198  :     if (len > MAX_DD)

  002de	81 bc 24 30 01
	00 00 00 08 00
	00		 cmp	 DWORD PTR len$[rsp], 2048 ; 00000800H
  002e9	76 1c		 jbe	 SHORT $LN18@do_data_du

; 199  :         printf( "Lines %4.4X to %4.4X suppressed\n", offset, len-1 );

  002eb	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002f2	ff c8		 dec	 eax
  002f4	44 8b c0	 mov	 r8d, eax
  002f7	8b 54 24 34	 mov	 edx, DWORD PTR offset$[rsp]
  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168737
  00302	e8 00 00 00 00	 call	 printf
$LN18@do_data_du:
$LN19@do_data_du:

; 200  : 
; 201  : } /* end function data_dump */

  00307	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030f	48 33 cc	 xor	 rcx, rsp
  00312	e8 00 00 00 00	 call	 __security_check_cookie
  00317	48 81 c4 10 01
	00 00		 add	 rsp, 272		; 00000110H
  0031e	5f		 pop	 rdi
  0031f	c3		 ret	 0
do_data_dump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
firstsame$ = 48
lastsame$ = 56
lineoff$ = 64
hex_chars$ = 72
print_chars$ = 80
same_as_above PROC

; 105  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 106  :     if (*firstsame)

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR firstsame$[rsp]
  0001d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00020	74 56		 je	 SHORT $LN2@same_as_ab

; 107  :     {
; 108  :         if (*lastsame == *firstsame)

  00022	48 8b 44 24 38	 mov	 rax, QWORD PTR lastsame$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR firstsame$[rsp]
  0002c	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0002e	39 08		 cmp	 DWORD PTR [rax], ecx
  00030	75 15		 jne	 SHORT $LN3@same_as_ab

; 109  :             printf( "Line %4.4X same as above\n", *firstsame );

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR firstsame$[rsp]
  00037	8b 10		 mov	 edx, DWORD PTR [rax]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168690
  00040	e8 00 00 00 00	 call	 printf
  00045	eb 1b		 jmp	 SHORT $LN4@same_as_ab
$LN3@same_as_ab:

; 110  :         else
; 111  :             printf( "Lines %4.4X to %4.4X same as above\n", *firstsame, *lastsame );

  00047	48 8b 44 24 38	 mov	 rax, QWORD PTR lastsame$[rsp]
  0004c	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR firstsame$[rsp]
  00054	8b 10		 mov	 edx, DWORD PTR [rax]
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168691
  0005d	e8 00 00 00 00	 call	 printf
$LN4@same_as_ab:

; 112  : 
; 113  :         *firstsame = *lastsame = 0;

  00062	48 8b 44 24 38	 mov	 rax, QWORD PTR lastsame$[rsp]
  00067	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR firstsame$[rsp]
  00072	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN2@same_as_ab:

; 114  :     }
; 115  :     printf( "+%4.4X %s %s\n", lineoff, hex_chars, print_chars );

  00078	4c 8b 4c 24 50	 mov	 r9, QWORD PTR print_chars$[rsp]
  0007d	4c 8b 44 24 48	 mov	 r8, QWORD PTR hex_chars$[rsp]
  00082	8b 54 24 40	 mov	 edx, DWORD PTR lineoff$[rsp]
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168692
  0008d	e8 00 00 00 00	 call	 printf

; 116  : }

  00092	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00096	c3		 ret	 0
same_as_above ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
dh_devid$ = 48
typmsk$ = 56
is_dh_devid_typ PROC

; 2509 : {

$LN16:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2510 : #define RETURN_IS_DEVHDRID( typ )               \
; 2511 :                                                 \
; 2512 :     if (1                                       \
; 2513 :         && typmsk & typ ## _TYP                 \
; 2514 :         && memcmp( dh_devid, #typ, 8 ) == 0     \
; 2515 :     )                                           \
; 2516 :         return true
; 2517 : 
; 2518 :     RETURN_IS_DEVHDRID( CKD_P370 );     // "CKD_P370" (P=Normal)

  0000d	33 c0		 xor	 eax, eax
  0000f	83 f8 01	 cmp	 eax, 1
  00012	74 2f		 je	 SHORT $LN2@is_dh_devi
  00014	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  00018	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0001d	85 c0		 test	 eax, eax
  0001f	74 22		 je	 SHORT $LN2@is_dh_devi
  00021	41 b8 08 00 00
	00		 mov	 r8d, 8
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170143
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00033	e8 00 00 00 00	 call	 memcmp
  00038	85 c0		 test	 eax, eax
  0003a	75 07		 jne	 SHORT $LN2@is_dh_devi
  0003c	b0 01		 mov	 al, 1
  0003e	e9 27 03 00 00	 jmp	 $LN1@is_dh_devi
$LN2@is_dh_devi:

; 2519 :     RETURN_IS_DEVHDRID( CKD_C370 );     // "CKD_C370" (C=Compressed)

  00043	33 c0		 xor	 eax, eax
  00045	83 f8 01	 cmp	 eax, 1
  00048	74 2f		 je	 SHORT $LN3@is_dh_devi
  0004a	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  0004e	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00053	85 c0		 test	 eax, eax
  00055	74 22		 je	 SHORT $LN3@is_dh_devi
  00057	41 b8 08 00 00
	00		 mov	 r8d, 8
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170145
  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00069	e8 00 00 00 00	 call	 memcmp
  0006e	85 c0		 test	 eax, eax
  00070	75 07		 jne	 SHORT $LN3@is_dh_devi
  00072	b0 01		 mov	 al, 1
  00074	e9 f1 02 00 00	 jmp	 $LN1@is_dh_devi
$LN3@is_dh_devi:

; 2520 :     RETURN_IS_DEVHDRID( CKD_S370 );     // "CKD_S370" (S=Shadow)

  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 01	 cmp	 eax, 1
  0007e	74 2f		 je	 SHORT $LN4@is_dh_devi
  00080	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  00084	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00089	85 c0		 test	 eax, eax
  0008b	74 22		 je	 SHORT $LN4@is_dh_devi
  0008d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170147
  0009a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  0009f	e8 00 00 00 00	 call	 memcmp
  000a4	85 c0		 test	 eax, eax
  000a6	75 07		 jne	 SHORT $LN4@is_dh_devi
  000a8	b0 01		 mov	 al, 1
  000aa	e9 bb 02 00 00	 jmp	 $LN1@is_dh_devi
$LN4@is_dh_devi:

; 2521 : 
; 2522 : //  RETURN_IS_DEVHDRID( FBA_P370 );     // "FBA_P370" (same for FBA)
; 2523 :     RETURN_IS_DEVHDRID( FBA_C370 );     // "FBA_C370"        "

  000af	33 c0		 xor	 eax, eax
  000b1	83 f8 01	 cmp	 eax, 1
  000b4	74 2f		 je	 SHORT $LN5@is_dh_devi
  000b6	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  000ba	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  000bf	85 c0		 test	 eax, eax
  000c1	74 22		 je	 SHORT $LN5@is_dh_devi
  000c3	41 b8 08 00 00
	00		 mov	 r8d, 8
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170149
  000d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  000d5	e8 00 00 00 00	 call	 memcmp
  000da	85 c0		 test	 eax, eax
  000dc	75 07		 jne	 SHORT $LN5@is_dh_devi
  000de	b0 01		 mov	 al, 1
  000e0	e9 85 02 00 00	 jmp	 $LN1@is_dh_devi
$LN5@is_dh_devi:

; 2524 :     RETURN_IS_DEVHDRID( FBA_S370 );     // "FBA_S370"        "

  000e5	33 c0		 xor	 eax, eax
  000e7	83 f8 01	 cmp	 eax, 1
  000ea	74 2f		 je	 SHORT $LN6@is_dh_devi
  000ec	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  000f0	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  000f5	85 c0		 test	 eax, eax
  000f7	74 22		 je	 SHORT $LN6@is_dh_devi
  000f9	41 b8 08 00 00
	00		 mov	 r8d, 8
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170151
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  0010b	e8 00 00 00 00	 call	 memcmp
  00110	85 c0		 test	 eax, eax
  00112	75 07		 jne	 SHORT $LN6@is_dh_devi
  00114	b0 01		 mov	 al, 1
  00116	e9 4f 02 00 00	 jmp	 $LN1@is_dh_devi
$LN6@is_dh_devi:

; 2525 : 
; 2526 :     RETURN_IS_DEVHDRID( CKD_P064 );     // "CKD_P064" (64-bit filesize)

  0011b	33 c0		 xor	 eax, eax
  0011d	83 f8 01	 cmp	 eax, 1
  00120	74 2f		 je	 SHORT $LN7@is_dh_devi
  00122	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  00126	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  0012b	85 c0		 test	 eax, eax
  0012d	74 22		 je	 SHORT $LN7@is_dh_devi
  0012f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170153
  0013c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00141	e8 00 00 00 00	 call	 memcmp
  00146	85 c0		 test	 eax, eax
  00148	75 07		 jne	 SHORT $LN7@is_dh_devi
  0014a	b0 01		 mov	 al, 1
  0014c	e9 19 02 00 00	 jmp	 $LN1@is_dh_devi
$LN7@is_dh_devi:

; 2527 :     RETURN_IS_DEVHDRID( CKD_C064 );     // "CKD_C064"        "

  00151	33 c0		 xor	 eax, eax
  00153	83 f8 01	 cmp	 eax, 1
  00156	74 2f		 je	 SHORT $LN8@is_dh_devi
  00158	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  0015c	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00161	85 c0		 test	 eax, eax
  00163	74 22		 je	 SHORT $LN8@is_dh_devi
  00165	41 b8 08 00 00
	00		 mov	 r8d, 8
  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170155
  00172	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00177	e8 00 00 00 00	 call	 memcmp
  0017c	85 c0		 test	 eax, eax
  0017e	75 07		 jne	 SHORT $LN8@is_dh_devi
  00180	b0 01		 mov	 al, 1
  00182	e9 e3 01 00 00	 jmp	 $LN1@is_dh_devi
$LN8@is_dh_devi:

; 2528 :     RETURN_IS_DEVHDRID( CKD_S064 );     // "CKD_S064"        "

  00187	33 c0		 xor	 eax, eax
  00189	83 f8 01	 cmp	 eax, 1
  0018c	74 2f		 je	 SHORT $LN9@is_dh_devi
  0018e	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  00192	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00197	85 c0		 test	 eax, eax
  00199	74 22		 je	 SHORT $LN9@is_dh_devi
  0019b	41 b8 08 00 00
	00		 mov	 r8d, 8
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170157
  001a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  001ad	e8 00 00 00 00	 call	 memcmp
  001b2	85 c0		 test	 eax, eax
  001b4	75 07		 jne	 SHORT $LN9@is_dh_devi
  001b6	b0 01		 mov	 al, 1
  001b8	e9 ad 01 00 00	 jmp	 $LN1@is_dh_devi
$LN9@is_dh_devi:

; 2529 : 
; 2530 : //  RETURN_IS_DEVHDRID( FBA_P064 );     // "FBA_P064" (same for FBA)
; 2531 :     RETURN_IS_DEVHDRID( FBA_C064 );     // "FBA_C064"        "

  001bd	33 c0		 xor	 eax, eax
  001bf	83 f8 01	 cmp	 eax, 1
  001c2	74 2d		 je	 SHORT $LN10@is_dh_devi
  001c4	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  001c8	83 e0 40	 and	 eax, 64			; 00000040H
  001cb	85 c0		 test	 eax, eax
  001cd	74 22		 je	 SHORT $LN10@is_dh_devi
  001cf	41 b8 08 00 00
	00		 mov	 r8d, 8
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170159
  001dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  001e1	e8 00 00 00 00	 call	 memcmp
  001e6	85 c0		 test	 eax, eax
  001e8	75 07		 jne	 SHORT $LN10@is_dh_devi
  001ea	b0 01		 mov	 al, 1
  001ec	e9 79 01 00 00	 jmp	 $LN1@is_dh_devi
$LN10@is_dh_devi:

; 2532 :     RETURN_IS_DEVHDRID( FBA_S064 );     // "FBA_S064"        "

  001f1	33 c0		 xor	 eax, eax
  001f3	83 f8 01	 cmp	 eax, 1
  001f6	74 2d		 je	 SHORT $LN11@is_dh_devi
  001f8	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  001fc	83 e0 20	 and	 eax, 32			; 00000020H
  001ff	85 c0		 test	 eax, eax
  00201	74 22		 je	 SHORT $LN11@is_dh_devi
  00203	41 b8 08 00 00
	00		 mov	 r8d, 8
  00209	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170161
  00210	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00215	e8 00 00 00 00	 call	 memcmp
  0021a	85 c0		 test	 eax, eax
  0021c	75 07		 jne	 SHORT $LN11@is_dh_devi
  0021e	b0 01		 mov	 al, 1
  00220	e9 45 01 00 00	 jmp	 $LN1@is_dh_devi
$LN11@is_dh_devi:

; 2533 : 
; 2534 :     // Since normal FBA/FBA64 images do not have device headers,
; 2535 :     // if they're asking whether the passed devid matches that
; 2536 :     // of an FBA type, we must first check to see whether it matches
; 2537 :     // the devid of any of the OTHER known types first, before we're
; 2538 :     // able to positively conclude whether it's an FBA type or not.
; 2539 :     //
; 2540 :     // If it matches any of the other known types, then it obviously
; 2541 :     // is NOT an FBA type. Otherwise, if it's NOT any of the other
; 2542 :     // known types, we must unfortunately presume it's an FBA type.
; 2543 : 
; 2544 :     if (0
; 2545 :         || !(typmsk & (FBA_P370_TYP | FBA_P064_TYP))
; 2546 :         || memcmp( dh_devid, "CKD_P370", 8 ) == 0
; 2547 :         || memcmp( dh_devid, "CKD_C370", 8 ) == 0
; 2548 :         || memcmp( dh_devid, "CKD_S370", 8 ) == 0
; 2549 : 
; 2550 : //      || memcmp( dh_devid, "FBA_P370", 8 ) == 0
; 2551 :         || memcmp( dh_devid, "FBA_C370", 8 ) == 0
; 2552 :         || memcmp( dh_devid, "FBA_S370", 8 ) == 0
; 2553 : 
; 2554 :         || memcmp( dh_devid, "CKD_P064", 8 ) == 0
; 2555 :         || memcmp( dh_devid, "CKD_C064", 8 ) == 0
; 2556 :         || memcmp( dh_devid, "CKD_S064", 8 ) == 0
; 2557 : 
; 2558 : //      || memcmp( dh_devid, "FBA_P064", 8 ) == 0
; 2559 :         || memcmp( dh_devid, "FBA_C064", 8 ) == 0
; 2560 :         || memcmp( dh_devid, "FBA_S064", 8 ) == 0

  00225	33 c0		 xor	 eax, eax
  00227	85 c0		 test	 eax, eax
  00229	0f 85 33 01 00
	00		 jne	 $LN14@is_dh_devi
  0022f	8b 44 24 38	 mov	 eax, DWORD PTR typmsk$[rsp]
  00233	25 80 80 00 00	 and	 eax, 32896		; 00008080H
  00238	85 c0		 test	 eax, eax
  0023a	0f 84 22 01 00
	00		 je	 $LN14@is_dh_devi
  00240	41 b8 08 00 00
	00		 mov	 r8d, 8
  00246	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170165
  0024d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00252	e8 00 00 00 00	 call	 memcmp
  00257	85 c0		 test	 eax, eax
  00259	0f 84 03 01 00
	00		 je	 $LN14@is_dh_devi
  0025f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00265	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170166
  0026c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00271	e8 00 00 00 00	 call	 memcmp
  00276	85 c0		 test	 eax, eax
  00278	0f 84 e4 00 00
	00		 je	 $LN14@is_dh_devi
  0027e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170167
  0028b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00290	e8 00 00 00 00	 call	 memcmp
  00295	85 c0		 test	 eax, eax
  00297	0f 84 c5 00 00
	00		 je	 $LN14@is_dh_devi
  0029d	41 b8 08 00 00
	00		 mov	 r8d, 8
  002a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170168
  002aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  002af	e8 00 00 00 00	 call	 memcmp
  002b4	85 c0		 test	 eax, eax
  002b6	0f 84 a6 00 00
	00		 je	 $LN14@is_dh_devi
  002bc	41 b8 08 00 00
	00		 mov	 r8d, 8
  002c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170169
  002c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  002ce	e8 00 00 00 00	 call	 memcmp
  002d3	85 c0		 test	 eax, eax
  002d5	0f 84 87 00 00
	00		 je	 $LN14@is_dh_devi
  002db	41 b8 08 00 00
	00		 mov	 r8d, 8
  002e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170170
  002e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  002ed	e8 00 00 00 00	 call	 memcmp
  002f2	85 c0		 test	 eax, eax
  002f4	74 6c		 je	 SHORT $LN14@is_dh_devi
  002f6	41 b8 08 00 00
	00		 mov	 r8d, 8
  002fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170171
  00303	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00308	e8 00 00 00 00	 call	 memcmp
  0030d	85 c0		 test	 eax, eax
  0030f	74 51		 je	 SHORT $LN14@is_dh_devi
  00311	41 b8 08 00 00
	00		 mov	 r8d, 8
  00317	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170172
  0031e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00323	e8 00 00 00 00	 call	 memcmp
  00328	85 c0		 test	 eax, eax
  0032a	74 36		 je	 SHORT $LN14@is_dh_devi
  0032c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00332	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170173
  00339	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  0033e	e8 00 00 00 00	 call	 memcmp
  00343	85 c0		 test	 eax, eax
  00345	74 1b		 je	 SHORT $LN14@is_dh_devi
  00347	41 b8 08 00 00
	00		 mov	 r8d, 8
  0034d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170174
  00354	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00359	e8 00 00 00 00	 call	 memcmp
  0035e	85 c0		 test	 eax, eax
  00360	75 06		 jne	 SHORT $LN12@is_dh_devi
$LN14@is_dh_devi:

; 2561 :     )
; 2562 :         return false;   // (definitely NOT their requested type)

  00362	32 c0		 xor	 al, al
  00364	eb 04		 jmp	 SHORT $LN1@is_dh_devi
  00366	eb 02		 jmp	 SHORT $LN13@is_dh_devi
$LN12@is_dh_devi:

; 2563 :     else
; 2564 :         return true;    // (PRESUMED to be a normal FBA device)

  00368	b0 01		 mov	 al, 1
$LN13@is_dh_devi:
$LN1@is_dh_devi:

; 2565 : }

  0036a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0036e	c3		 ret	 0
is_dh_devid_typ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
dh_devid$ = 48
dh_devid_typ PROC

; 2476 : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2477 : #define RETURN_DEVHDRID_TYP( typ )          \
; 2478 :                                             \
; 2479 :     if (memcmp( dh_devid, #typ, 8 ) == 0)   \
; 2480 :         return typ ## _TYP
; 2481 : 
; 2482 :     RETURN_DEVHDRID_TYP( CKD_P370 );    // "CKD_P370" (P=Normal)

  00009	41 b8 08 00 00
	00		 mov	 r8d, 8
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170118
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  0001b	e8 00 00 00 00	 call	 memcmp
  00020	85 c0		 test	 eax, eax
  00022	75 0a		 jne	 SHORT $LN2@dh_devid_t
  00024	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00029	e9 46 01 00 00	 jmp	 $LN1@dh_devid_t
$LN2@dh_devid_t:

; 2483 :     RETURN_DEVHDRID_TYP( CKD_C370 );    // "CKD_C370" (C=Compressed)

  0002e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170120
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00040	e8 00 00 00 00	 call	 memcmp
  00045	85 c0		 test	 eax, eax
  00047	75 0a		 jne	 SHORT $LN3@dh_devid_t
  00049	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  0004e	e9 21 01 00 00	 jmp	 $LN1@dh_devid_t
$LN3@dh_devid_t:

; 2484 :     RETURN_DEVHDRID_TYP( CKD_S370 );    // "CKD_S370" (S=Shadow)

  00053	41 b8 08 00 00
	00		 mov	 r8d, 8
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170122
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  00065	e8 00 00 00 00	 call	 memcmp
  0006a	85 c0		 test	 eax, eax
  0006c	75 0a		 jne	 SHORT $LN4@dh_devid_t
  0006e	b8 00 00 00 20	 mov	 eax, 536870912		; 20000000H
  00073	e9 fc 00 00 00	 jmp	 $LN1@dh_devid_t
$LN4@dh_devid_t:

; 2485 : 
; 2486 : //  RETURN_DEVHDRID_TYP( FBA_P370 );    // "FBA_P370" (same for FBA)
; 2487 :     RETURN_DEVHDRID_TYP( FBA_C370 );    // "FBA_C370"        "

  00078	41 b8 08 00 00
	00		 mov	 r8d, 8
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170124
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  0008a	e8 00 00 00 00	 call	 memcmp
  0008f	85 c0		 test	 eax, eax
  00091	75 0a		 jne	 SHORT $LN5@dh_devid_t
  00093	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  00098	e9 d7 00 00 00	 jmp	 $LN1@dh_devid_t
$LN5@dh_devid_t:

; 2488 :     RETURN_DEVHDRID_TYP( FBA_S370 );    // "FBA_S370"        "

  0009d	41 b8 08 00 00
	00		 mov	 r8d, 8
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170126
  000aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  000af	e8 00 00 00 00	 call	 memcmp
  000b4	85 c0		 test	 eax, eax
  000b6	75 0a		 jne	 SHORT $LN6@dh_devid_t
  000b8	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  000bd	e9 b2 00 00 00	 jmp	 $LN1@dh_devid_t
$LN6@dh_devid_t:

; 2489 : 
; 2490 :     RETURN_DEVHDRID_TYP( CKD_P064 );    // "CKD_P064" (64-bit filesize)

  000c2	41 b8 08 00 00
	00		 mov	 r8d, 8
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170128
  000cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  000d4	e8 00 00 00 00	 call	 memcmp
  000d9	85 c0		 test	 eax, eax
  000db	75 0a		 jne	 SHORT $LN7@dh_devid_t
  000dd	b8 00 00 80 00	 mov	 eax, 8388608		; 00800000H
  000e2	e9 8d 00 00 00	 jmp	 $LN1@dh_devid_t
$LN7@dh_devid_t:

; 2491 :     RETURN_DEVHDRID_TYP( CKD_C064 );    // "CKD_C064"        "

  000e7	41 b8 08 00 00
	00		 mov	 r8d, 8
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170130
  000f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  000f9	e8 00 00 00 00	 call	 memcmp
  000fe	85 c0		 test	 eax, eax
  00100	75 07		 jne	 SHORT $LN8@dh_devid_t
  00102	b8 00 00 40 00	 mov	 eax, 4194304		; 00400000H
  00107	eb 6b		 jmp	 SHORT $LN1@dh_devid_t
$LN8@dh_devid_t:

; 2492 :     RETURN_DEVHDRID_TYP( CKD_S064 );    // "CKD_S064"        "

  00109	41 b8 08 00 00
	00		 mov	 r8d, 8
  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170132
  00116	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  0011b	e8 00 00 00 00	 call	 memcmp
  00120	85 c0		 test	 eax, eax
  00122	75 07		 jne	 SHORT $LN9@dh_devid_t
  00124	b8 00 00 20 00	 mov	 eax, 2097152		; 00200000H
  00129	eb 49		 jmp	 SHORT $LN1@dh_devid_t
$LN9@dh_devid_t:

; 2493 : 
; 2494 : //  RETURN_DEVHDRID_TYP( FBA_P064 );    // "FBA_P064" (same for FBA)
; 2495 :     RETURN_DEVHDRID_TYP( FBA_C064 );    // "FBA_C064"        "

  0012b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00131	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170134
  00138	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  0013d	e8 00 00 00 00	 call	 memcmp
  00142	85 c0		 test	 eax, eax
  00144	75 07		 jne	 SHORT $LN10@dh_devid_t
  00146	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0014b	eb 27		 jmp	 SHORT $LN1@dh_devid_t
$LN10@dh_devid_t:

; 2496 :     RETURN_DEVHDRID_TYP( FBA_S064 );    // "FBA_S064"        "

  0014d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170136
  0015a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dh_devid$[rsp]
  0015f	e8 00 00 00 00	 call	 memcmp
  00164	85 c0		 test	 eax, eax
  00166	75 07		 jne	 SHORT $LN11@dh_devid_t
  00168	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0016d	eb 05		 jmp	 SHORT $LN1@dh_devid_t
$LN11@dh_devid_t:

; 2497 : 
; 2498 :     // Since normal FBA/FBA64 images do not have device headers,
; 2499 :     // if the pased dh_devid doesn't match any of the above, we
; 2500 :     // presume it is a normal FBA dasd image type.
; 2501 : 
; 2502 :     return FBA_P370_TYP;  // (presumed if none of the above)

  0016f	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
$LN1@dh_devid_t:

; 2503 : }

  00174	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00178	c3		 ret	 0
dh_devid_typ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
typmsk$ = 8
dh_devid_str PROC

; 2443 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 2444 : #define RETURN_DEVHDRID_STR( typ )      \
; 2445 :                                         \
; 2446 :     if (typ ## _TYP == typmsk)          \
; 2447 :         return #typ
; 2448 : 
; 2449 :     RETURN_DEVHDRID_STR( CKD_P370 );    // "CKD_P370" (P=Normal)

  00004	81 7c 24 08 00
	00 00 80	 cmp	 DWORD PTR typmsk$[rsp], -2147483648 ; 80000000H
  0000c	75 0c		 jne	 SHORT $LN2@dh_devid_s
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170095
  00015	e9 ad 00 00 00	 jmp	 $LN1@dh_devid_s
$LN2@dh_devid_s:

; 2450 :     RETURN_DEVHDRID_STR( CKD_C370 );    // "CKD_C370" (C=Compressed)

  0001a	81 7c 24 08 00
	00 00 40	 cmp	 DWORD PTR typmsk$[rsp], 1073741824 ; 40000000H
  00022	75 0c		 jne	 SHORT $LN3@dh_devid_s
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170097
  0002b	e9 97 00 00 00	 jmp	 $LN1@dh_devid_s
$LN3@dh_devid_s:

; 2451 :     RETURN_DEVHDRID_STR( CKD_S370 );    // "CKD_S370" (S=Shadow)

  00030	81 7c 24 08 00
	00 00 20	 cmp	 DWORD PTR typmsk$[rsp], 536870912 ; 20000000H
  00038	75 0c		 jne	 SHORT $LN4@dh_devid_s
  0003a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170099
  00041	e9 81 00 00 00	 jmp	 $LN1@dh_devid_s
$LN4@dh_devid_s:

; 2452 : 
; 2453 : //  RETURN_DEVHDRID_STR( FBA_P370 );    // "FBA_P370" (same for FBA)
; 2454 :     RETURN_DEVHDRID_STR( FBA_C370 );    // "FBA_C370"        "

  00046	81 7c 24 08 00
	40 00 00	 cmp	 DWORD PTR typmsk$[rsp], 16384 ; 00004000H
  0004e	75 09		 jne	 SHORT $LN5@dh_devid_s
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170101
  00057	eb 6e		 jmp	 SHORT $LN1@dh_devid_s
$LN5@dh_devid_s:

; 2455 :     RETURN_DEVHDRID_STR( FBA_S370 );    // "FBA_S370"        "

  00059	81 7c 24 08 00
	20 00 00	 cmp	 DWORD PTR typmsk$[rsp], 8192 ; 00002000H
  00061	75 09		 jne	 SHORT $LN6@dh_devid_s
  00063	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170103
  0006a	eb 5b		 jmp	 SHORT $LN1@dh_devid_s
$LN6@dh_devid_s:

; 2456 : 
; 2457 :     RETURN_DEVHDRID_STR( CKD_P064 );    // "CKD_P064" (64-bit filesize)

  0006c	81 7c 24 08 00
	00 80 00	 cmp	 DWORD PTR typmsk$[rsp], 8388608 ; 00800000H
  00074	75 09		 jne	 SHORT $LN7@dh_devid_s
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170105
  0007d	eb 48		 jmp	 SHORT $LN1@dh_devid_s
$LN7@dh_devid_s:

; 2458 :     RETURN_DEVHDRID_STR( CKD_C064 );    // "CKD_C064"        "

  0007f	81 7c 24 08 00
	00 40 00	 cmp	 DWORD PTR typmsk$[rsp], 4194304 ; 00400000H
  00087	75 09		 jne	 SHORT $LN8@dh_devid_s
  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170107
  00090	eb 35		 jmp	 SHORT $LN1@dh_devid_s
$LN8@dh_devid_s:

; 2459 :     RETURN_DEVHDRID_STR( CKD_S064 );    // "CKD_S064"        "

  00092	81 7c 24 08 00
	00 20 00	 cmp	 DWORD PTR typmsk$[rsp], 2097152 ; 00200000H
  0009a	75 09		 jne	 SHORT $LN9@dh_devid_s
  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170109
  000a3	eb 22		 jmp	 SHORT $LN1@dh_devid_s
$LN9@dh_devid_s:

; 2460 : 
; 2461 : //  RETURN_DEVHDRID_STR( FBA_P064 );    // "FBA_P064" (same for FBA)
; 2462 :     RETURN_DEVHDRID_STR( FBA_C064 );    // "FBA_C064"        "

  000a5	83 7c 24 08 40	 cmp	 DWORD PTR typmsk$[rsp], 64 ; 00000040H
  000aa	75 09		 jne	 SHORT $LN10@dh_devid_s
  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170111
  000b3	eb 12		 jmp	 SHORT $LN1@dh_devid_s
$LN10@dh_devid_s:

; 2463 :     RETURN_DEVHDRID_STR( FBA_S064 );    // "FBA_S064"        "

  000b5	83 7c 24 08 20	 cmp	 DWORD PTR typmsk$[rsp], 32 ; 00000020H
  000ba	75 09		 jne	 SHORT $LN11@dh_devid_s
  000bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170113
  000c3	eb 02		 jmp	 SHORT $LN1@dh_devid_s
$LN11@dh_devid_s:

; 2464 : 
; 2465 :     // Normal FBA images do not have device headers, so
; 2466 :     // if they asked us to return them an FBA devid string,
; 2467 :     // then that's an error since there is no such thing!
; 2468 : 
; 2469 :     return NULL;  // (unknown or invalid typmsk passed)

  000c5	33 c0		 xor	 eax, eax
$LN1@dh_devid_s:

; 2470 : }

  000c7	c3		 ret	 0
dh_devid_str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
sz$ = 32
rechdr$ = 40
tv82 = 48
dev$ = 80
buf$ = 88
ckd_tracklen PROC

; 2414 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2415 : int          sz;                        /* Size so far               */
; 2416 : CKD_RECHDR*  rechdr;                    /* Pointer to record header  */
; 2417 : 
; 2418 :     sz = CKD_TRKHDR_SIZE;

  0000e	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR sz$[rsp], 5
$LN2@ckd_trackl:

; 2419 : 
; 2420 :     while (1
; 2421 :         && memcmp( buf + sz, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) != 0
; 2422 :         && sz <= dev->ckdtrksz      -     CKD_ENDTRK_SIZE

  00016	33 c0		 xor	 eax, eax
  00018	83 f8 01	 cmp	 eax, 1
  0001b	0f 84 9d 00 00
	00		 je	 $LN3@ckd_trackl
  00021	48 63 44 24 20	 movsxd	 rax, DWORD PTR sz$[rsp]
  00026	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0002b	48 03 c8	 add	 rcx, rax
  0002e	48 8b c1	 mov	 rax, rcx
  00031	41 b8 08 00 00
	00		 mov	 r8d, 8
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 memcmp
  00046	85 c0		 test	 eax, eax
  00048	74 74		 je	 SHORT $LN3@ckd_trackl
  0004a	48 63 44 24 20	 movsxd	 rax, DWORD PTR sz$[rsp]
  0004f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00054	48 63 89 c4 12
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4804]
  0005b	48 83 e9 08	 sub	 rcx, 8
  0005f	48 3b c1	 cmp	 rax, rcx
  00062	7f 5a		 jg	 SHORT $LN3@ckd_trackl

; 2423 :     )
; 2424 :     {
; 2425 :         /* add length of count, key, and data fields */
; 2426 :         rechdr = (CKD_RECHDR*) (buf + sz);

  00064	48 63 44 24 20	 movsxd	 rax, DWORD PTR sz$[rsp]
  00069	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0006e	48 03 c8	 add	 rcx, rax
  00071	48 8b c1	 mov	 rax, rcx
  00074	48 89 44 24 28	 mov	 QWORD PTR rechdr$[rsp], rax

; 2427 : 
; 2428 :         sz += CKD_RECHDR_SIZE

  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR rechdr$[rsp]
  0007e	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00082	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  00087	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0008c	48 83 c1 06	 add	 rcx, 6
  00090	e8 00 00 00 00	 call	 fetch_hw_noswap
  00095	0f b7 c8	 movzx	 ecx, ax
  00098	e8 00 00 00 00	 call	 _byteswap_ushort
  0009d	0f b7 c0	 movzx	 eax, ax
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv82[rsp]
  000a5	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000aa	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR sz$[rsp]
  000af	48 03 c8	 add	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 2429 :            +  rechdr->klen
; 2430 :            +  fetch_hw( rechdr->dlen );
; 2431 :     }

  000b9	e9 58 ff ff ff	 jmp	 $LN2@ckd_trackl
$LN3@ckd_trackl:

; 2432 : 
; 2433 :     /* add length for end-of-track indicator */
; 2434 :     sz += CKD_ENDTRK_SIZE;

  000be	48 63 44 24 20	 movsxd	 rax, DWORD PTR sz$[rsp]
  000c3	48 83 c0 08	 add	 rax, 8
  000c7	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 2435 : 
; 2436 :     return sz;

  000cb	8b 44 24 20	 mov	 eax, DWORD PTR sz$[rsp]

; 2437 : }

  000cf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d3	c3		 ret	 0
ckd_tracklen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
c$1 = 32
i$ = 36
iLen$ = 40
pszdsname$ = 64
valid_dsname PROC

; 2379 : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2380 :     int i;
; 2381 :     int iLen = (int)strlen(pszdsname);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pszdsname$[rsp]
  0000e	e8 00 00 00 00	 call	 strlen
  00013	89 44 24 28	 mov	 DWORD PTR iLen$[rsp], eax

; 2382 : 
; 2383 :     if ( iLen > 44 || iLen == 0 ) return FALSE;

  00017	83 7c 24 28 2c	 cmp	 DWORD PTR iLen$[rsp], 44 ; 0000002cH
  0001c	7f 07		 jg	 SHORT $LN6@valid_dsna
  0001e	83 7c 24 28 00	 cmp	 DWORD PTR iLen$[rsp], 0
  00023	75 07		 jne	 SHORT $LN5@valid_dsna
$LN6@valid_dsna:
  00025	33 c0		 xor	 eax, eax
  00027	e9 c5 00 00 00	 jmp	 $LN1@valid_dsna
$LN5@valid_dsna:

; 2384 : 
; 2385 :     for ( i = 0; i < iLen; i++ )

  0002c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00034	eb 0a		 jmp	 SHORT $LN4@valid_dsna
$LN2@valid_dsna:
  00036	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0003a	ff c0		 inc	 eax
  0003c	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@valid_dsna:
  00040	8b 44 24 28	 mov	 eax, DWORD PTR iLen$[rsp]
  00044	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00048	0f 8d 9e 00 00
	00		 jge	 $LN3@valid_dsna

; 2386 :     {
; 2387 :         BYTE c = pszdsname[i];

  0004e	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pszdsname$[rsp]
  00058	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005c	88 44 24 20	 mov	 BYTE PTR c$1[rsp], al

; 2388 :         if ( isalnum( c ) )

  00060	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  00065	8b c8		 mov	 ecx, eax
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  0006d	85 c0		 test	 eax, eax
  0006f	74 04		 je	 SHORT $LN7@valid_dsna

; 2389 :             continue;

  00071	eb c3		 jmp	 SHORT $LN2@valid_dsna
  00073	eb 72		 jmp	 SHORT $LN8@valid_dsna
$LN7@valid_dsna:

; 2390 :         else if ( c == '$' )

  00075	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  0007a	83 f8 24	 cmp	 eax, 36			; 00000024H
  0007d	75 04		 jne	 SHORT $LN9@valid_dsna

; 2391 :             continue;

  0007f	eb b5		 jmp	 SHORT $LN2@valid_dsna
  00081	eb 64		 jmp	 SHORT $LN10@valid_dsna
$LN9@valid_dsna:

; 2392 :         else if ( c == '@' )

  00083	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  00088	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008b	75 04		 jne	 SHORT $LN11@valid_dsna

; 2393 :             continue;

  0008d	eb a7		 jmp	 SHORT $LN2@valid_dsna
  0008f	eb 56		 jmp	 SHORT $LN12@valid_dsna
$LN11@valid_dsna:

; 2394 :         else if ( c == '#' )

  00091	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  00096	83 f8 23	 cmp	 eax, 35			; 00000023H
  00099	75 04		 jne	 SHORT $LN13@valid_dsna

; 2395 :             continue;

  0009b	eb 99		 jmp	 SHORT $LN2@valid_dsna
  0009d	eb 48		 jmp	 SHORT $LN14@valid_dsna
$LN13@valid_dsna:

; 2396 :         else if ( c == '-' )

  0009f	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  000a4	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000a7	75 04		 jne	 SHORT $LN15@valid_dsna

; 2397 :             continue;

  000a9	eb 8b		 jmp	 SHORT $LN2@valid_dsna
  000ab	eb 3a		 jmp	 SHORT $LN16@valid_dsna
$LN15@valid_dsna:

; 2398 :         else if ( c == '.' )

  000ad	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  000b2	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  000b5	75 07		 jne	 SHORT $LN17@valid_dsna

; 2399 :             continue;

  000b7	e9 7a ff ff ff	 jmp	 $LN2@valid_dsna
  000bc	eb 29		 jmp	 SHORT $LN18@valid_dsna
$LN17@valid_dsna:

; 2400 :         else if ( c == '{' )

  000be	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  000c3	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  000c6	75 07		 jne	 SHORT $LN19@valid_dsna

; 2401 :             continue;

  000c8	e9 69 ff ff ff	 jmp	 $LN2@valid_dsna
  000cd	eb 18		 jmp	 SHORT $LN20@valid_dsna
$LN19@valid_dsna:

; 2402 :         else if ( i > 1 && c == '\0' )

  000cf	83 7c 24 24 01	 cmp	 DWORD PTR i$[rsp], 1
  000d4	7e 0d		 jle	 SHORT $LN21@valid_dsna
  000d6	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	75 04		 jne	 SHORT $LN21@valid_dsna

; 2403 :             break;

  000df	eb 0b		 jmp	 SHORT $LN3@valid_dsna
  000e1	eb 04		 jmp	 SHORT $LN22@valid_dsna
$LN21@valid_dsna:

; 2404 :         else
; 2405 :             return FALSE;

  000e3	33 c0		 xor	 eax, eax
  000e5	eb 0a		 jmp	 SHORT $LN1@valid_dsna
$LN22@valid_dsna:
$LN20@valid_dsna:
$LN18@valid_dsna:
$LN16@valid_dsna:
$LN14@valid_dsna:
$LN12@valid_dsna:
$LN10@valid_dsna:
$LN8@valid_dsna:

; 2406 :     }

  000e7	e9 4a ff ff ff	 jmp	 $LN2@valid_dsna
$LN3@valid_dsna:

; 2407 :     return TRUE;

  000ec	b8 01 00 00 00	 mov	 eax, 1
$LN1@valid_dsna:

; 2408 : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
valid_dsname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
tv65 = 0
next_util_devnum PROC

; 2376 : DLL_EXPORT int  next_util_devnum()         { return nextnum++;   }

$LN3:
  00000	48 83 ec 18	 sub	 rsp, 24
  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nextnum
  0000a	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  0000d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nextnum
  00013	ff c0		 inc	 eax
  00015	89 05 00 00 00
	00		 mov	 DWORD PTR nextnum, eax
  0001b	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]
  0001e	48 83 c4 18	 add	 rsp, 24
  00022	c3		 ret	 0
next_util_devnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
is_verbose_util PROC

; 2375 : DLL_EXPORT bool is_verbose_util()          { return verbose;     }

  00000	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR verbose
  00007	c3		 ret	 0
is_verbose_util ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
v$ = 8
set_verbose_util PROC

; 2374 : DLL_EXPORT void set_verbose_util( bool v ) {        verbose = v; }

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	0f b6 44 24 08	 movzx	 eax, BYTE PTR v$[rsp]
  00009	88 05 00 00 00
	00		 mov	 BYTE PTR verbose, al
  0000f	c3		 ret	 0
set_verbose_util ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
rc$ = 112
fd$ = 116
l1tabsz$ = 120
len2$ = 124
num_L1tab$ = 128
x$ = 132
blkgrps$ = 136
tv154 = 140
l1$ = 144
blkghdr$ = 152
rcoff$ = 160
tv152 = 168
tv213 = 176
tv294 = 184
tv329 = 192
tv365 = 200
tv450 = 208
tv472 = 216
tv513 = 224
tv562 = 232
tv75 = 240
tv132 = 248
tv311 = 256
fbavol1$1 = 264
tv486 = 272
tv535 = 280
tv612 = 288
cdevhdr$ = 304
devhdr$ = 816
l2$ = 1328
pathname$ = 3376
buf$ = 3648
__$ArrayPad$ = 69184
fname$ = 69216
devtype$ = 69224
sectsz$ = 69232
sectors$ = 69240
volser$ = 69248
comp$ = 69256
lfs$ = 69264
dasdcopy$ = 69272
rawflag$ = 69280
create_compressed_fba PROC

; 2103 : {

$LN37:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	b8 50 0e 01 00	 mov	 eax, 69200		; 00010e50H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 40
	0e 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2104 :     int              rc;                /* Return code               */
; 2105 :     off_t            rcoff;             /* Return value from lseek() */
; 2106 :     int              fd;                /* File descriptor           */
; 2107 :     CKD_DEVHDR       devhdr;            /* Device header             */
; 2108 :     CCKD_DEVHDR      cdevhdr;           /* Compressed device header  */
; 2109 :     FBA_BKGHDR*      blkghdr;           /* Block Group Header        */
; 2110 :     int              blkgrps;           /* Number block groups       */
; 2111 :     int              num_L1tab, l1tabsz;/* Level 1 entries, size     */
; 2112 :     CCKD_L1ENT*      l1;                /* Level 1 table pointer     */
; 2113 :     CCKD_L2ENT       l2[256];           /* Level 2 table             */
; 2114 :     unsigned long    len2;              /* Compressed buffer length  */
; 2115 : #if defined( HAVE_ZLIB )
; 2116 :     BYTE             buf2[256];         /* Compressed buffer         */
; 2117 : #endif
; 2118 :     BYTE             buf[65536];        /* Buffer                    */
; 2119 :     int              x = O_EXCL;        /* Open option               */

  00034	c7 84 24 84 00
	00 00 00 04 00
	00		 mov	 DWORD PTR x$[rsp], 1024	; 00000400H
$LN4@create_com:

; 2120 :     char             pathname[MAX_PATH];/* file path in host format  */
; 2121 : 
; 2122 :     UNREFERENCED( lfs );

  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 fa		 jne	 SHORT $LN4@create_com

; 2123 : 
; 2124 :     /* Calculate the size of the level 1 table */
; 2125 :     blkgrps = (sectors / CFBA_BLKS_PER_GRP) + 1;

  00045	33 d2		 xor	 edx, edx
  00047	8b 84 24 78 0e
	01 00		 mov	 eax, DWORD PTR sectors$[rsp]
  0004e	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00053	f7 f1		 div	 ecx
  00055	ff c0		 inc	 eax
  00057	89 84 24 88 00
	00 00		 mov	 DWORD PTR blkgrps$[rsp], eax

; 2126 :     num_L1tab = (blkgrps + 255) / 256;

  0005e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR blkgrps$[rsp]
  00065	05 ff 00 00 00	 add	 eax, 255		; 000000ffH
  0006a	99		 cdq
  0006b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00071	03 c2		 add	 eax, edx
  00073	c1 f8 08	 sar	 eax, 8
  00076	89 84 24 80 00
	00 00		 mov	 DWORD PTR num_L1tab$[rsp], eax

; 2127 :     l1tabsz = num_L1tab * CCKD_L1ENT_SIZE;

  0007d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00085	48 c1 e0 02	 shl	 rax, 2
  00089	89 44 24 78	 mov	 DWORD PTR l1tabsz$[rsp], eax

; 2128 : 
; 2129 :     if (l1tabsz > 65536)

  0008d	81 7c 24 78 00
	00 01 00	 cmp	 DWORD PTR l1tabsz$[rsp], 65536 ; 00010000H
  00095	0f 8e a1 00 00
	00		 jle	 $LN5@create_com

; 2130 :     {
; 2131 :         // "%1d:%04X CKD file %s: file size too large: %"PRIu64" [%d]"
; 2132 :         FWRMSG( stderr, HHC00464, "E", 0, 0, fname,

  0009b	8b 84 24 78 0e
	01 00		 mov	 eax, DWORD PTR sectors$[rsp]
  000a2	0f af 84 24 70
	0e 01 00	 imul	 eax, DWORD PTR sectsz$[rsp]
  000aa	8b c0		 mov	 eax, eax
  000ac	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  000b4	b9 02 00 00 00	 mov	 ecx, 2
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000bf	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR num_L1tab$[rsp]
  000c6	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  000ca	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  000d2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000d7	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000df	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e4	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  000ed	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169950
  000fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169951
  00109	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00113	41 b9 03 00 00
	00		 mov	 r9d, 3
  00119	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169952
  00120	ba 55 08 00 00	 mov	 edx, 2133		; 00000855H
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169953
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2133 :                 (U64)(sectors * sectsz), num_L1tab );
; 2134 :         return -1;

  00132	b8 ff ff ff ff	 mov	 eax, -1
  00137	e9 f2 0d 00 00	 jmp	 $LN1@create_com
$LN5@create_com:

; 2135 :     }
; 2136 : 
; 2137 :     /* if 'dasdcopy' > 1 then we can replace the existing file */
; 2138 :     if (dasdcopy > 1)

  0013c	83 bc 24 98 0e
	01 00 01	 cmp	 DWORD PTR dasdcopy$[rsp], 1
  00144	7e 0b		 jle	 SHORT $LN6@create_com

; 2139 :         x = 0;

  00146	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$[rsp], 0
$LN6@create_com:

; 2140 : 
; 2141 :     /* Create the DASD image file */
; 2142 :     hostpath( pathname, fname, sizeof( pathname ));

  00151	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00157	48 8b 94 24 60
	0e 01 00	 mov	 rdx, QWORD PTR fname$[rsp]
  0015f	48 8d 8c 24 30
	0d 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 2143 :     fd = HOPEN( pathname,

  0016d	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00174	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  00179	0f ba e8 0f	 bts	 eax, 15
  0017d	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00183	8b d0		 mov	 edx, eax
  00185	48 8d 8c 24 30
	0d 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00193	89 44 24 74	 mov	 DWORD PTR fd$[rsp], eax

; 2144 :         0
; 2145 :             | O_WRONLY
; 2146 :             | O_CREAT
; 2147 :             | x
; 2148 :             | O_BINARY
; 2149 :         ,
; 2150 :         0
; 2151 :             | S_IRUSR
; 2152 :             | S_IWUSR
; 2153 :             | S_IRGRP
; 2154 :     );
; 2155 : 
; 2156 :     if (fd < 0)

  00197	83 7c 24 74 00	 cmp	 DWORD PTR fd$[rsp], 0
  0019c	0f 8d 9f 00 00
	00		 jge	 $LN7@create_com

; 2157 :     {
; 2158 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2159 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001a8	8b 08		 mov	 ecx, DWORD PTR [rax]
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001b0	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  001b8	b9 02 00 00 00	 mov	 ecx, 2
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  001cb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169956
  001d7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001dc	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001e4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001e9	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  001f2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169957
  00202	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169958
  0020e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00213	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00218	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169959
  00225	ba 70 08 00 00	 mov	 edx, 2160		; 00000870H
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169960
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2160 :             "open()", strerror( errno ));
; 2161 :         return -1;

  00237	b8 ff ff ff ff	 mov	 eax, -1
  0023c	e9 ed 0c 00 00	 jmp	 $LN1@create_com
$LN7@create_com:

; 2162 :     }
; 2163 : 
; 2164 :     /* Display progress message */
; 2165 :     // "%1d:%04X FBA file %s: creating %4.4X compressed volume %s: %u sectors, %u bytes/sector"
; 2166 :     FWRMSG( stdout, HHC00465, "I", 0, 0, fname,

  00241	83 bc 24 a0 0e
	01 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  00249	74 11		 je	 SHORT $LN21@create_com
  0024b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169961
  00252	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
  0025a	eb 10		 jmp	 SHORT $LN22@create_com
$LN21@create_com:
  0025c	48 8b 84 24 80
	0e 01 00	 mov	 rax, QWORD PTR volser$[rsp]
  00264	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
$LN22@create_com:
  0026c	0f b7 84 24 68
	0e 01 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00274	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
  0027b	b9 01 00 00 00	 mov	 ecx, 1
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00286	8b 8c 24 70 0e
	01 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  0028d	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00291	8b 8c 24 78 0e
	01 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  00298	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0029c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  002a4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002a9	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv154[rsp]
  002b0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002b4	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  002bc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  002ca	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  002d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169962
  002da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169963
  002e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169964
  002fd	ba 77 08 00 00	 mov	 edx, 2167		; 00000877H
  00302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169965
  00309	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2167 :         devtype, rawflag ? "" : volser, sectors, sectsz );
; 2168 : 
; 2169 :     /* Create the device header */
; 2170 :     memset( &devhdr, 0, CKD_DEVHDR_SIZE );

  0030f	48 8d 84 24 30
	03 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  00317	48 8b f8	 mov	 rdi, rax
  0031a	33 c0		 xor	 eax, eax
  0031c	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00321	f3 aa		 rep stosb

; 2171 :     gen_dasd_serial( devhdr.dh_serial );

  00323	48 8d 8c 24 44
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+20]
  0032b	e8 00 00 00 00	 call	 gen_dasd_serial

; 2172 :     memcpy(  devhdr.dh_devid, dh_devid_str( FBA_C370_TYP ), 8 );

  00330	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  00335	e8 00 00 00 00	 call	 dh_devid_str
  0033a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0033d	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR devhdr$[rsp], rax

; 2173 : 
; 2174 :     STORE_LE_FW( devhdr.dh_heads,   sectors );

  00345	8b 8c 24 78 0e
	01 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  0034c	e8 00 00 00 00	 call	 _byteswap_ulong
  00351	8b c8		 mov	 ecx, eax
  00353	e8 00 00 00 00	 call	 _byteswap_ulong
  00358	8b d0		 mov	 edx, eax
  0035a	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  00362	e8 00 00 00 00	 call	 store_fw_noswap

; 2175 :     STORE_LE_FW( devhdr.dh_trksize, sectsz  );

  00367	8b 8c 24 70 0e
	01 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  0036e	e8 00 00 00 00	 call	 _byteswap_ulong
  00373	8b c8		 mov	 ecx, eax
  00375	e8 00 00 00 00	 call	 _byteswap_ulong
  0037a	8b d0		 mov	 edx, eax
  0037c	48 8d 8c 24 3c
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  00384	e8 00 00 00 00	 call	 store_fw_noswap

; 2176 : 
; 2177 :     devhdr.dh_devtyp  = devtype & 0xFF;

  00389	0f b7 84 24 68
	0e 01 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00391	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00396	88 84 24 40 03
	00 00		 mov	 BYTE PTR devhdr$[rsp+16], al

; 2178 :     devhdr.dh_fileseq = 0;

  0039d	c6 84 24 41 03
	00 00 00	 mov	 BYTE PTR devhdr$[rsp+17], 0

; 2179 : 
; 2180 :     STORE_LE_HW( devhdr.dh_highcyl, 0 );

  003a5	33 c9		 xor	 ecx, ecx
  003a7	e8 00 00 00 00	 call	 _byteswap_ushort
  003ac	0f b7 c8	 movzx	 ecx, ax
  003af	e8 00 00 00 00	 call	 _byteswap_ushort
  003b4	0f b7 d0	 movzx	 edx, ax
  003b7	48 8d 8c 24 42
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  003bf	e8 00 00 00 00	 call	 store_hw_noswap

; 2181 : 
; 2182 :     /* Write the device header */
; 2183 :     rc = write( fd, &devhdr, CKD_DEVHDR_SIZE );

  003c4	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  003ca	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  003d2	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  003d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  003dc	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2184 :     if (rc < (int) CKD_DEVHDR_SIZE)

  003e0	81 7c 24 70 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  003e8	0f 8d bb 00 00
	00		 jge	 $LN8@create_com

; 2185 :     {
; 2186 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2187 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  003ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003f4	83 38 00	 cmp	 DWORD PTR [rax], 0
  003f7	74 18		 je	 SHORT $LN23@create_com
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003ff	8b 08		 mov	 ecx, DWORD PTR [rax]
  00401	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00407	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv213[rsp], rax
  0040f	eb 0f		 jmp	 SHORT $LN24@create_com
$LN23@create_com:
  00411	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169967
  00418	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv213[rsp], rax
$LN24@create_com:
  00420	b9 02 00 00 00	 mov	 ecx, 2
  00425	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0042b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv213[rsp]
  00433	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00438	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169968
  0043f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00444	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0044c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00451	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0045a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00463	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169969
  0046a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0046f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169970
  00476	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0047b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00480	41 b9 03 00 00
	00		 mov	 r9d, 3
  00486	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169971
  0048d	ba 8c 08 00 00	 mov	 edx, 2188		; 0000088cH
  00492	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169972
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2188 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 2189 :         return -1;

  0049f	b8 ff ff ff ff	 mov	 eax, -1
  004a4	e9 85 0a 00 00	 jmp	 $LN1@create_com
$LN8@create_com:

; 2190 :     }
; 2191 : 
; 2192 :     /* Build and Write the compressed device header */
; 2193 :     memset( &cdevhdr, 0, CCKD_DEVHDR_SIZE );

  004a9	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR cdevhdr$[rsp]
  004b1	48 8b f8	 mov	 rdi, rax
  004b4	33 c0		 xor	 eax, eax
  004b6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  004bb	f3 aa		 rep stosb

; 2194 : 
; 2195 :     cdevhdr.cdh_vrm[0] = CCKD_VERSION;

  004bd	b8 01 00 00 00	 mov	 eax, 1
  004c2	48 6b c0 00	 imul	 rax, rax, 0
  004c6	c6 84 04 30 01
	00 00 00	 mov	 BYTE PTR cdevhdr$[rsp+rax], 0

; 2196 :     cdevhdr.cdh_vrm[1] = CCKD_RELEASE;

  004ce	b8 01 00 00 00	 mov	 eax, 1
  004d3	48 6b c0 01	 imul	 rax, rax, 1
  004d7	c6 84 04 30 01
	00 00 03	 mov	 BYTE PTR cdevhdr$[rsp+rax], 3

; 2197 :     cdevhdr.cdh_vrm[2] = CCKD_MODLVL;

  004df	b8 01 00 00 00	 mov	 eax, 1
  004e4	48 6b c0 02	 imul	 rax, rax, 2
  004e8	c6 84 04 30 01
	00 00 01	 mov	 BYTE PTR cdevhdr$[rsp+rax], 1

; 2198 : 
; 2199 :     if (cckd_def_opt_bigend())

  004f0	e8 00 00 00 00	 call	 cckd_def_opt_bigend
  004f5	85 c0		 test	 eax, eax
  004f7	74 12		 je	 SHORT $LN9@create_com

; 2200 :         cdevhdr.cdh_opts |= CCKD_OPT_BIGEND;

  004f9	0f b6 84 24 33
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00501	83 c8 02	 or	 eax, 2
  00504	88 84 24 33 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+3], al
$LN9@create_com:

; 2201 : 
; 2202 :     cdevhdr.cdh_opts     |= CCKD_OPT_OPENRW;

  0050b	0f b6 84 24 33
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00513	83 c8 40	 or	 eax, 64			; 00000040H
  00516	88 84 24 33 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+3], al

; 2203 :     cdevhdr.num_L1tab = num_L1tab;

  0051d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR num_L1tab$[rsp]
  00524	89 84 24 34 01
	00 00		 mov	 DWORD PTR cdevhdr$[rsp+4], eax

; 2204 :     cdevhdr.num_L2tab = 256;

  0052b	c7 84 24 38 01
	00 00 00 01 00
	00		 mov	 DWORD PTR cdevhdr$[rsp+8], 256 ; 00000100H

; 2205 : 
; 2206 :     STORE_LE_FW( cdevhdr.cdh_cyls, sectors );

  00536	8b 8c 24 78 0e
	01 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  0053d	e8 00 00 00 00	 call	 _byteswap_ulong
  00542	8b c8		 mov	 ecx, eax
  00544	e8 00 00 00 00	 call	 _byteswap_ulong
  00549	8b d0		 mov	 edx, eax
  0054b	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR cdevhdr$[rsp+40]
  00553	e8 00 00 00 00	 call	 store_fw_noswap

; 2207 : 
; 2208 :     cdevhdr.cmp_algo  = comp;

  00558	0f b6 84 24 88
	0e 01 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00560	88 84 24 5d 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+45], al

; 2209 :     cdevhdr.cmp_parm  = -1;

  00567	b8 ff ff ff ff	 mov	 eax, -1
  0056c	66 89 84 24 5e
	01 00 00	 mov	 WORD PTR cdevhdr$[rsp+46], ax

; 2210 : 
; 2211 :     rc = write( fd, &cdevhdr, CCKD_DEVHDR_SIZE);

  00574	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0057a	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  00582	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00586	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0058c	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2212 :     if (rc < (int)            CCKD_DEVHDR_SIZE)

  00590	81 7c 24 70 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  00598	0f 8d bb 00 00
	00		 jge	 $LN10@create_com

; 2213 :     {
; 2214 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2215 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0059e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005a4	83 38 00	 cmp	 DWORD PTR [rax], 0
  005a7	74 18		 je	 SHORT $LN25@create_com
  005a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005af	8b 08		 mov	 ecx, DWORD PTR [rax]
  005b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  005b7	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv294[rsp], rax
  005bf	eb 0f		 jmp	 SHORT $LN26@create_com
$LN25@create_com:
  005c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169975
  005c8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv294[rsp], rax
$LN26@create_com:
  005d0	b9 02 00 00 00	 mov	 ecx, 2
  005d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005db	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv294[rsp]
  005e3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169976
  005ef	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005f4	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  005fc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00601	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0060a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00613	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169977
  0061a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0061f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169978
  00626	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0062b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00630	41 b9 03 00 00
	00		 mov	 r9d, 3
  00636	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169979
  0063d	ba a8 08 00 00	 mov	 edx, 2216		; 000008a8H
  00642	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169980
  00649	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2216 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 2217 :         return -1;

  0064f	b8 ff ff ff ff	 mov	 eax, -1
  00654	e9 d5 08 00 00	 jmp	 $LN1@create_com
$LN10@create_com:

; 2218 :     }
; 2219 : 
; 2220 :     /* Build and Write the level 1 table */
; 2221 :     l1 = (CCKD_L1ENT*) &buf;

  00659	48 8d 84 24 40
	0e 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00661	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR l1$[rsp], rax

; 2222 :     memset( l1, 0, l1tabsz );

  00669	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  0066e	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv311[rsp], rax
  00676	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR l1$[rsp]
  0067e	33 c0		 xor	 eax, eax
  00680	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv311[rsp]
  00688	f3 aa		 rep stosb

; 2223 :     l1[0] = CKD_DEVHDR_SIZE + CCKD_DEVHDR_SIZE + l1tabsz;

  0068a	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  0068f	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  00695	b9 04 00 00 00	 mov	 ecx, 4
  0069a	48 6b c9 00	 imul	 rcx, rcx, 0
  0069e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR l1$[rsp]
  006a6	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2224 :     rc = write( fd, l1, l1tabsz );

  006a9	44 8b 44 24 78	 mov	 r8d, DWORD PTR l1tabsz$[rsp]
  006ae	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR l1$[rsp]
  006b6	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  006ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  006c0	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2225 :     if (rc < l1tabsz)

  006c4	8b 44 24 78	 mov	 eax, DWORD PTR l1tabsz$[rsp]
  006c8	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  006cc	0f 8d bb 00 00
	00		 jge	 $LN11@create_com

; 2226 :     {
; 2227 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2228 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  006d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006d8	83 38 00	 cmp	 DWORD PTR [rax], 0
  006db	74 18		 je	 SHORT $LN27@create_com
  006dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006e3	8b 08		 mov	 ecx, DWORD PTR [rax]
  006e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  006eb	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
  006f3	eb 0f		 jmp	 SHORT $LN28@create_com
$LN27@create_com:
  006f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169982
  006fc	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
$LN28@create_com:
  00704	b9 02 00 00 00	 mov	 ecx, 2
  00709	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0070f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv329[rsp]
  00717	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0071c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169983
  00723	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00728	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00730	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00735	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0073e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00747	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169984
  0074e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00753	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169985
  0075a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0075f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00764	41 b9 03 00 00
	00		 mov	 r9d, 3
  0076a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169986
  00771	ba b5 08 00 00	 mov	 edx, 2229		; 000008b5H
  00776	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169987
  0077d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2229 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 2230 :         return -1;

  00783	b8 ff ff ff ff	 mov	 eax, -1
  00788	e9 a1 07 00 00	 jmp	 $LN1@create_com
$LN11@create_com:

; 2231 :     }
; 2232 : 
; 2233 :     /* Build and Write the 1st level 2 table */
; 2234 :     memset( &l2, 0, CCKD_L2TAB_SIZE );

  0078d	48 8d 84 24 30
	05 00 00	 lea	 rax, QWORD PTR l2$[rsp]
  00795	48 8b f8	 mov	 rdi, rax
  00798	33 c0		 xor	 eax, eax
  0079a	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0079f	f3 aa		 rep stosb

; 2235 :     l2[0].L2_trkoff = CKD_DEVHDR_SIZE + CCKD_DEVHDR_SIZE

  007a1	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  007a6	48 05 00 0c 00
	00		 add	 rax, 3072		; 00000c00H
  007ac	b9 08 00 00 00	 mov	 ecx, 8
  007b1	48 6b c9 00	 imul	 rcx, rcx, 0
  007b5	89 84 0c 30 05
	00 00		 mov	 DWORD PTR l2$[rsp+rcx], eax

; 2236 :         + l1tabsz + CCKD_L2TAB_SIZE;
; 2237 :     rc = write( fd, &l2, CCKD_L2TAB_SIZE);

  007bc	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  007c2	48 8d 94 24 30
	05 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  007ca	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  007ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  007d4	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2238 :     if (rc < (int)       CCKD_L2TAB_SIZE)

  007d8	81 7c 24 70 00
	08 00 00	 cmp	 DWORD PTR rc$[rsp], 2048 ; 00000800H
  007e0	0f 8d bb 00 00
	00		 jge	 $LN12@create_com

; 2239 :     {
; 2240 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2241 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  007e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  007ec	83 38 00	 cmp	 DWORD PTR [rax], 0
  007ef	74 18		 je	 SHORT $LN29@create_com
  007f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  007f7	8b 08		 mov	 ecx, DWORD PTR [rax]
  007f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  007ff	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv365[rsp], rax
  00807	eb 0f		 jmp	 SHORT $LN30@create_com
$LN29@create_com:
  00809	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169989
  00810	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv365[rsp], rax
$LN30@create_com:
  00818	b9 02 00 00 00	 mov	 ecx, 2
  0081d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00823	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv365[rsp]
  0082b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00830	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169990
  00837	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0083c	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00844	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00849	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00852	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0085b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169991
  00862	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00867	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169992
  0086e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00873	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00878	41 b9 03 00 00
	00		 mov	 r9d, 3
  0087e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169993
  00885	ba c2 08 00 00	 mov	 edx, 2242		; 000008c2H
  0088a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169994
  00891	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2242 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 2243 :         return -1;

  00897	b8 ff ff ff ff	 mov	 eax, -1
  0089c	e9 8d 06 00 00	 jmp	 $LN1@create_com
$LN12@create_com:

; 2244 :     }
; 2245 : 
; 2246 :     /* Clear the first block group's image data to binary zeros */
; 2247 :     memset( &buf, 0, FBA_BKGHDR_SIZE + CFBA_BLKGRP_SIZE );

  008a1	48 8d 84 24 40
	0e 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  008a9	48 8b f8	 mov	 rdi, rax
  008ac	33 c0		 xor	 eax, eax
  008ae	b9 05 f0 00 00	 mov	 ecx, 61445		; 0000f005H
  008b3	f3 aa		 rep stosb

; 2248 : 
; 2249 :     /* Build the "Track Header" (FBA Block Group Header) */
; 2250 :     blkghdr = (FBA_BKGHDR*) &buf[0]; /* (--> block group header) */

  008b5	b8 01 00 00 00	 mov	 eax, 1
  008ba	48 6b c0 00	 imul	 rax, rax, 0
  008be	48 8d 84 04 40
	0e 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  008c6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR blkghdr$[rsp], rax

; 2251 :     blkghdr->cmp = CCKD_COMPRESS_NONE;   /* (until we know for sure) */

  008ce	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR blkghdr$[rsp]
  008d6	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2252 :     store_fw( blkghdr->blknum, 0 );      /* (group's starting block) */

  008d9	33 c9		 xor	 ecx, ecx
  008db	e8 00 00 00 00	 call	 _byteswap_ulong
  008e0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR blkghdr$[rsp]
  008e8	48 ff c1	 inc	 rcx
  008eb	8b d0		 mov	 edx, eax
  008ed	e8 00 00 00 00	 call	 store_fw_noswap

; 2253 : 
; 2254 :     /* Build the VOL1 label if requested */
; 2255 :     if (!rawflag)

  008f2	83 bc 24 a0 0e
	01 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  008fa	75 32		 jne	 SHORT $LN13@create_com

; 2256 :     {
; 2257 :         /* The VOL1 label is at physical sector number 1 */
; 2258 :         VOL1_FBA* fbavol1 = (VOL1_FBA*) &buf[ FBA_BKGHDR_SIZE + sectsz ];

  008fc	8b 84 24 70 0e
	01 00		 mov	 eax, DWORD PTR sectsz$[rsp]
  00903	48 8d 84 04 45
	0e 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax+5]
  0090b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR fbavol1$1[rsp], rax

; 2259 :         build_vol1( fbavol1, volser, NULL, false );

  00913	45 33 c9	 xor	 r9d, r9d
  00916	45 33 c0	 xor	 r8d, r8d
  00919	48 8b 94 24 80
	0e 01 00	 mov	 rdx, QWORD PTR volser$[rsp]
  00921	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR fbavol1$1[rsp]
  00929	e8 00 00 00 00	 call	 build_vol1
$LN13@create_com:

; 2260 :     }
; 2261 : 
; 2262 :     /* Write the 1st block group */
; 2263 : #if defined( HAVE_ZLIB )
; 2264 :     len2 = sizeof( buf2 );
; 2265 :     if (1
; 2266 :         && CCKD_COMPRESS_ZLIB == (comp & CCKD_COMPRESS_MASK)
; 2267 :         && Z_OK == (rc = compress2( &buf2[0], &len2, &buf[ FBA_BKGHDR_SIZE ],
; 2268 :                                     CFBA_BLKGRP_SIZE, Z_DEFAULT_COMPRESSION ))
; 2269 :     )
; 2270 :     {
; 2271 :         blkghdr->cmp = CCKD_COMPRESS_ZLIB;
; 2272 : 
; 2273 :         /* Write out the FBA Block Group Header separately (since it
; 2274 :            was NOT compressed) followed by the compressed block group
; 2275 :            data (which WAS compressed)
; 2276 :         */
; 2277 :         rc = write( fd, &buf, FBA_BKGHDR_SIZE );
; 2278 :         if (rc < (int) FBA_BKGHDR_SIZE)
; 2279 :         {
; 2280 :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 2281 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,
; 2282 :                 "write()", errno ? strerror( errno ) : "incomplete" );
; 2283 :             return -1;
; 2284 :         }
; 2285 : 
; 2286 :         /* Now write out the compressed block group data (the sectors) */
; 2287 :         rc = write( fd, &buf2, len2 );
; 2288 :         if (rc < (int) len2)
; 2289 :         {
; 2290 :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 2291 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,
; 2292 :                 "write()", errno ? strerror( errno ) : "incomplete" );
; 2293 :             return -1;
; 2294 :         }
; 2295 :     }
; 2296 :     else
; 2297 : #endif // defined( HAVE_ZLIB )
; 2298 :     {
; 2299 :         len2 = CFBA_BLKGRP_SIZE;

  0092e	c7 44 24 7c 00
	f0 00 00	 mov	 DWORD PTR len2$[rsp], 61440 ; 0000f000H

; 2300 :         blkghdr->cmp = CCKD_COMPRESS_NONE;

  00936	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR blkghdr$[rsp]
  0093e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2301 : 
; 2302 :         /* Write out both the FBA Block Group Header and the Block Group
; 2303 :            Data itself (i.e. all of the block group sectors) in one I/O.
; 2304 :         */
; 2305 :         rc = write( fd, &buf, FBA_BKGHDR_SIZE + len2 );

  00941	8b 44 24 7c	 mov	 eax, DWORD PTR len2$[rsp]
  00945	48 83 c0 05	 add	 rax, 5
  00949	44 8b c0	 mov	 r8d, eax
  0094c	48 8d 94 24 40
	0e 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00954	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00958	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0095e	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2306 :         if (rc < (int)(FBA_BKGHDR_SIZE + len2))

  00962	8b 44 24 7c	 mov	 eax, DWORD PTR len2$[rsp]
  00966	48 83 c0 05	 add	 rax, 5
  0096a	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  0096e	0f 8d bb 00 00
	00		 jge	 $LN14@create_com

; 2307 :         {
; 2308 :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 2309 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00974	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0097a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0097d	74 18		 je	 SHORT $LN31@create_com
  0097f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00985	8b 08		 mov	 ecx, DWORD PTR [rax]
  00987	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0098d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv450[rsp], rax
  00995	eb 0f		 jmp	 SHORT $LN32@create_com
$LN31@create_com:
  00997	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169997
  0099e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv450[rsp], rax
$LN32@create_com:
  009a6	b9 02 00 00 00	 mov	 ecx, 2
  009ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009b1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv450[rsp]
  009b9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  009be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169998
  009c5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009ca	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  009d2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009d7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  009e0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  009e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169999
  009f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170000
  009fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a01	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a06	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a0c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170001
  00a13	ba 06 09 00 00	 mov	 edx, 2310		; 00000906H
  00a18	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170002
  00a1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2310 :                 "write()", errno ? strerror( errno ) : "incomplete" );
; 2311 :             return -1;

  00a25	b8 ff ff ff ff	 mov	 eax, -1
  00a2a	e9 ff 04 00 00	 jmp	 $LN1@create_com
$LN14@create_com:

; 2312 :         }
; 2313 :     }
; 2314 : 
; 2315 :     /* Update the L2 table entry for this block group */
; 2316 :     l2[0].L2_len = l2[0].L2_size = (U16)(FBA_BKGHDR_SIZE + len2);

  00a2f	8b 44 24 7c	 mov	 eax, DWORD PTR len2$[rsp]
  00a33	48 83 c0 05	 add	 rax, 5
  00a37	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv472[rsp], rax
  00a3f	b8 08 00 00 00	 mov	 eax, 8
  00a44	48 6b c0 00	 imul	 rax, rax, 0
  00a48	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR tv472[rsp]
  00a50	66 89 8c 04 36
	05 00 00	 mov	 WORD PTR l2$[rsp+rax+6], cx
  00a58	b8 08 00 00 00	 mov	 eax, 8
  00a5d	48 6b c0 00	 imul	 rax, rax, 0
  00a61	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR tv472[rsp]
  00a69	66 89 8c 04 34
	05 00 00	 mov	 WORD PTR l2$[rsp+rax+4], cx

; 2317 : 
; 2318 :     /* Update compressed device header too */
; 2319 :     cdevhdr.cdh_size = cdevhdr.cdh_used = CKD_DEVHDR_SIZE +

  00a71	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  00a76	8b 4c 24 7c	 mov	 ecx, DWORD PTR len2$[rsp]
  00a7a	48 8d 84 08 05
	0c 00 00	 lea	 rax, QWORD PTR [rax+rcx+3077]
  00a82	89 84 24 40 01
	00 00		 mov	 DWORD PTR cdevhdr$[rsp+16], eax
  00a89	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR cdevhdr$[rsp+16]
  00a90	89 84 24 3c 01
	00 00		 mov	 DWORD PTR cdevhdr$[rsp+12], eax

; 2320 :                    CCKD_DEVHDR_SIZE + l1tabsz + CCKD_L2TAB_SIZE +
; 2321 :                    FBA_BKGHDR_SIZE + len2;
; 2322 : 
; 2323 :     /* Re-write the compressed device header */
; 2324 :     if ((rcoff = lseek( fd, CKD_DEVHDR_SIZE, SEEK_SET )) < 0)

  00a97	45 33 c0	 xor	 r8d, r8d
  00a9a	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00a9f	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00aa3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00aa9	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rcoff$[rsp], rax
  00ab1	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rcoff$[rsp], 0
  00aba	0f 8d 9f 00 00
	00		 jge	 $LN15@create_com

; 2325 :     {
; 2326 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2327 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00ac0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00ac6	8b 08		 mov	 ecx, DWORD PTR [rax]
  00ac8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ace	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv486[rsp], rax
  00ad6	b9 02 00 00 00	 mov	 ecx, 2
  00adb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ae1	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv486[rsp]
  00ae9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00aee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170004
  00af5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00afa	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00b02	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b07	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00b10	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00b19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170005
  00b20	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170006
  00b2c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b31	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b36	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b3c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170007
  00b43	ba 18 09 00 00	 mov	 edx, 2328		; 00000918H
  00b48	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170008
  00b4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2328 :                 "lseek()", strerror( errno ));
; 2329 :         return -1;

  00b55	b8 ff ff ff ff	 mov	 eax, -1
  00b5a	e9 cf 03 00 00	 jmp	 $LN1@create_com
$LN15@create_com:

; 2330 :     }
; 2331 :     rc = write( fd, &cdevhdr, CCKD_DEVHDR_SIZE);

  00b5f	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00b65	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  00b6d	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00b71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00b77	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2332 :     if (rc < (int)            CCKD_DEVHDR_SIZE)

  00b7b	81 7c 24 70 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  00b83	0f 8d bb 00 00
	00		 jge	 $LN16@create_com

; 2333 :     {
; 2334 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2335 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00b89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b8f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00b92	74 18		 je	 SHORT $LN33@create_com
  00b94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b9a	8b 08		 mov	 ecx, DWORD PTR [rax]
  00b9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ba2	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv513[rsp], rax
  00baa	eb 0f		 jmp	 SHORT $LN34@create_com
$LN33@create_com:
  00bac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170010
  00bb3	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv513[rsp], rax
$LN34@create_com:
  00bbb	b9 02 00 00 00	 mov	 ecx, 2
  00bc0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bc6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv513[rsp]
  00bce	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00bd3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170011
  00bda	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00bdf	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00be7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00bec	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00bf5	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00bfe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170012
  00c05	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170013
  00c11	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c16	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c1b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c21	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170014
  00c28	ba 20 09 00 00	 mov	 edx, 2336		; 00000920H
  00c2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170015
  00c34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2336 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 2337 :         return -1;

  00c3a	b8 ff ff ff ff	 mov	 eax, -1
  00c3f	e9 ea 02 00 00	 jmp	 $LN1@create_com
$LN16@create_com:

; 2338 :     }
; 2339 : 
; 2340 :     /* Re-write the 1st level 2 table */
; 2341 :     if ((rcoff = lseek( fd, CKD_DEVHDR_SIZE + CCKD_DEVHDR_SIZE + l1tabsz, SEEK_SET )) < 0)

  00c44	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  00c49	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  00c4f	45 33 c0	 xor	 r8d, r8d
  00c52	48 8b d0	 mov	 rdx, rax
  00c55	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00c59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00c5f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rcoff$[rsp], rax
  00c67	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rcoff$[rsp], 0
  00c70	0f 8d 9f 00 00
	00		 jge	 $LN17@create_com

; 2342 :     {
; 2343 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2344 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00c76	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00c7c	8b 08		 mov	 ecx, DWORD PTR [rax]
  00c7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00c84	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv535[rsp], rax
  00c8c	b9 02 00 00 00	 mov	 ecx, 2
  00c91	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c97	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv535[rsp]
  00c9f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ca4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170017
  00cab	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00cb0	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00cb8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cbd	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00cc6	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00ccf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170018
  00cd6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cdb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170019
  00ce2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ce7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cec	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cf2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170020
  00cf9	ba 29 09 00 00	 mov	 edx, 2345		; 00000929H
  00cfe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170021
  00d05	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2345 :             "lseek()", strerror( errno ));
; 2346 :         return -1;

  00d0b	b8 ff ff ff ff	 mov	 eax, -1
  00d10	e9 19 02 00 00	 jmp	 $LN1@create_com
$LN17@create_com:

; 2347 :     }
; 2348 :     rc = write( fd, &l2, CCKD_L2TAB_SIZE);

  00d15	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00d1b	48 8d 94 24 30
	05 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  00d23	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00d27	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00d2d	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2349 :     if (rc < (int)       CCKD_L2TAB_SIZE)

  00d31	81 7c 24 70 00
	08 00 00	 cmp	 DWORD PTR rc$[rsp], 2048 ; 00000800H
  00d39	0f 8d bb 00 00
	00		 jge	 $LN18@create_com

; 2350 :     {
; 2351 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2352 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00d3f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d45	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d48	74 18		 je	 SHORT $LN35@create_com
  00d4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d50	8b 08		 mov	 ecx, DWORD PTR [rax]
  00d52	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00d58	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv562[rsp], rax
  00d60	eb 0f		 jmp	 SHORT $LN36@create_com
$LN35@create_com:
  00d62	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170023
  00d69	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv562[rsp], rax
$LN36@create_com:
  00d71	b9 02 00 00 00	 mov	 ecx, 2
  00d76	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d7c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv562[rsp]
  00d84	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00d89	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170024
  00d90	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00d95	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00d9d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00da2	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00dab	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00db4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170025
  00dbb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170026
  00dc7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dcc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dd1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00dd7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170027
  00dde	ba 31 09 00 00	 mov	 edx, 2353		; 00000931H
  00de3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170028
  00dea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2353 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 2354 :         return -1;

  00df0	b8 ff ff ff ff	 mov	 eax, -1
  00df5	e9 34 01 00 00	 jmp	 $LN1@create_com
$LN18@create_com:

; 2355 :     }
; 2356 : 
; 2357 :     /* Close the DASD image file */
; 2358 :     if ((rc = close( fd )) < 0)

  00dfa	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00dfe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  00e04	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  00e08	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e0d	0f 8d 9c 00 00
	00		 jge	 $LN19@create_com

; 2359 :     {
; 2360 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 2361 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00e13	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00e19	8b 08		 mov	 ecx, DWORD PTR [rax]
  00e1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00e21	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv612[rsp], rax
  00e29	b9 02 00 00 00	 mov	 ecx, 2
  00e2e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e34	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv612[rsp]
  00e3c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00e41	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170030
  00e48	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e4d	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00e55	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e5a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00e63	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00e6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170031
  00e73	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170032
  00e7f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e84	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e89	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e8f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170033
  00e96	ba 3a 09 00 00	 mov	 edx, 2362		; 0000093aH
  00e9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170034
  00ea2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2362 :             "close()", strerror( errno ));
; 2363 :         return -1;

  00ea8	b8 ff ff ff ff	 mov	 eax, -1
  00ead	eb 7f		 jmp	 SHORT $LN1@create_com
$LN19@create_com:

; 2364 :     }
; 2365 : 
; 2366 :     /* Display completion message */
; 2367 :     // "%1d:%04X CKD file %s: %u %s successfully written"
; 2368 :     FWRMSG( stdout, HHC00460, "I", 0, 0, fname,

  00eaf	b9 01 00 00 00	 mov	 ecx, 1
  00eb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00eba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170035
  00ec1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ec6	8b 8c 24 78 0e
	01 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  00ecd	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00ed1	48 8b 8c 24 60
	0e 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00ed9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ede	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00ee7	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00ef0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170036
  00ef7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00efc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170037
  00f03	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f08	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f0d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f13	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170038
  00f1a	ba 41 09 00 00	 mov	 edx, 2369		; 00000941H
  00f1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170039
  00f26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2369 :         sectors, "sectors" );
; 2370 :     return 0;

  00f2c	33 c0		 xor	 eax, eax
$LN1@create_com:

; 2371 : } /* end function create_compressed_fba */

  00f2e	48 8b 8c 24 40
	0e 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00f36	48 33 cc	 xor	 rcx, rsp
  00f39	e8 00 00 00 00	 call	 __security_check_cookie
  00f3e	48 81 c4 50 0e
	01 00		 add	 rsp, 69200		; 00010e50H
  00f45	5f		 pop	 rdi
  00f46	c3		 ret	 0
create_compressed_fba ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
sectnum$ = 112
rc$ = 116
fd$ = 120
maxsect$ = 124
buf$ = 128
minsect$ = 136
x$ = 140
sz$1 = 144
tv173 = 152
tv171 = 160
tv223 = 168
tv325 = 176
tv147 = 184
tv198 = 192
tv237 = 200
tv290 = 208
tv343 = 216
buf$2 = 224
pathname$ = 272
__$ArrayPad$ = 544
fname$ = 576
devtype$ = 584
sectsz$ = 592
sectors$ = 600
volser$ = 608
comp$ = 616
lfs$ = 624
dasdcopy$ = 632
rawflag$ = 640
create_fba PROC

; 1955 : {

$LN28:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1956 : int             rc;                     /* Return code               */
; 1957 : int             fd;                     /* File descriptor           */
; 1958 : U32             sectnum;                /* Sector number             */
; 1959 : BYTE           *buf;                    /* -> Sector data buffer     */
; 1960 : U32             minsect;                /* Minimum sector count      */
; 1961 : U32             maxsect;                /* Maximum sector count      */
; 1962 : int             x=O_EXCL;               /* Open option               */

  0002e	c7 84 24 8c 00
	00 00 00 04 00
	00		 mov	 DWORD PTR x$[rsp], 1024	; 00000400H

; 1963 : char            pathname[MAX_PATH];     /* file path in host format  */
; 1964 : 
; 1965 :     /* Special processing for compressed fba */
; 1966 :     if (comp != 0xff)

  00039	0f b6 84 24 68
	02 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00041	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00046	74 6c		 je	 SHORT $LN5@create_fba

; 1967 :     {
; 1968 :         rc = create_compressed_fba (fname, devtype, sectsz, sectors,

  00048	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR rawflag$[rsp]
  0004f	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00053	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR dasdcopy$[rsp]
  0005a	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0005e	8b 84 24 70 02
	00 00		 mov	 eax, DWORD PTR lfs$[rsp]
  00065	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00069	0f b6 84 24 68
	02 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00071	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00075	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  0007d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00082	44 8b 8c 24 58
	02 00 00	 mov	 r9d, DWORD PTR sectors$[rsp]
  0008a	44 8b 84 24 50
	02 00 00	 mov	 r8d, DWORD PTR sectsz$[rsp]
  00092	0f b7 94 24 48
	02 00 00	 movzx	 edx, WORD PTR devtype$[rsp]
  0009a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000a2	e8 00 00 00 00	 call	 create_compressed_fba
  000a7	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 1969 :                                     volser, comp, lfs, dasdcopy, rawflag);
; 1970 :         return rc;

  000ab	8b 44 24 74	 mov	 eax, DWORD PTR rc$[rsp]
  000af	e9 b4 08 00 00	 jmp	 $LN1@create_fba
$LN5@create_fba:

; 1971 :     }
; 1972 : 
; 1973 :     /* Compute minimum and maximum number of sectors */
; 1974 :     minsect = 64;

  000b4	c7 84 24 88 00
	00 00 40 00 00
	00		 mov	 DWORD PTR minsect$[rsp], 64 ; 00000040H

; 1975 :     maxsect = 0x80000000 / sectsz;

  000bf	33 d2		 xor	 edx, edx
  000c1	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  000c6	f7 b4 24 50 02
	00 00		 div	 DWORD PTR sectsz$[rsp]
  000cd	89 44 24 7c	 mov	 DWORD PTR maxsect$[rsp], eax

; 1976 : 
; 1977 :     /* Check for valid number of sectors */
; 1978 :     if (sectors < minsect || (!lfs && sectors > maxsect))

  000d1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR minsect$[rsp]
  000d8	39 84 24 58 02
	00 00		 cmp	 DWORD PTR sectors$[rsp], eax
  000df	72 1f		 jb	 SHORT $LN7@create_fba
  000e1	83 bc 24 70 02
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  000e9	0f 85 10 01 00
	00		 jne	 $LN6@create_fba
  000ef	8b 44 24 7c	 mov	 eax, DWORD PTR maxsect$[rsp]
  000f3	39 84 24 58 02
	00 00		 cmp	 DWORD PTR sectors$[rsp], eax
  000fa	0f 86 ff 00 00
	00		 jbe	 $LN6@create_fba
$LN7@create_fba:

; 1979 :     {
; 1980 :         if (!lfs)

  00100	83 bc 24 70 02
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00108	75 5b		 jne	 SHORT $LN8@create_fba

; 1981 :             FWRMSG( stderr, HHC00521, "W", maxsect, "sectors" );

  0010a	b9 02 00 00 00	 mov	 ecx, 2
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169772
  0011c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00121	8b 4c 24 7c	 mov	 ecx, DWORD PTR maxsect$[rsp]
  00125	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169773
  00130	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169774
  0013c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00141	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00146	41 b9 03 00 00
	00		 mov	 r9d, 3
  0014c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169775
  00153	ba bd 07 00 00	 mov	 edx, 1981		; 000007bdH
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169776
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@create_fba:

; 1982 : 
; 1983 :         FWRMSG( stderr, HHC00461, "E", 0, 0, fname,

  00165	b9 02 00 00 00	 mov	 ecx, 2
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00170	8b 4c 24 7c	 mov	 ecx, DWORD PTR maxsect$[rsp]
  00174	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00178	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR minsect$[rsp]
  0017f	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00183	8b 8c 24 58 02
	00 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  0018a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169777
  00195	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0019a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001a2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001a7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  001b0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169778
  001c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169779
  001cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169780
  001e3	ba c0 07 00 00	 mov	 edx, 1984		; 000007c0H
  001e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169781
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1984 :                 "sector", sectors, minsect, maxsect );
; 1985 :         return -1;

  001f5	b8 ff ff ff ff	 mov	 eax, -1
  001fa	e9 69 07 00 00	 jmp	 $LN1@create_fba
$LN6@create_fba:

; 1986 :     }
; 1987 : 
; 1988 :     /* Obtain sector data buffer */
; 1989 :     buf = malloc(sectsz);

  001ff	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR sectsz$[rsp]
  00206	8b c8		 mov	 ecx, eax
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0020e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1990 :     if (buf == NULL)

  00216	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  0021f	0f 85 c2 00 00
	00		 jne	 $LN9@create_fba

; 1991 :     {
; 1992 :         char buf[40];
; 1993 :         MSGBUF( buf, "malloc(%u)", sectsz);

  00225	44 8b 8c 24 50
	02 00 00	 mov	 r9d, DWORD PTR sectsz$[rsp]
  0022d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169783
  00234	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00239	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1994 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0024d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00255	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv147[rsp], rax
  0025d	b9 02 00 00 00	 mov	 ecx, 2
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00268	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv147[rsp]
  00270	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00275	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0027d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00282	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0028a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0028f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00298	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169784
  002a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169785
  002b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002be	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169786
  002cb	ba cb 07 00 00	 mov	 edx, 1995		; 000007cbH
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169787
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1995 :                 buf, strerror( errno ));
; 1996 :         return -1;

  002dd	b8 ff ff ff ff	 mov	 eax, -1
  002e2	e9 81 06 00 00	 jmp	 $LN1@create_fba
$LN9@create_fba:

; 1997 :     }
; 1998 : 
; 1999 :     /* Display progress message */
; 2000 :     // "%1d:%04X FBA file %s: creating %4.4X volume %s: %u sectors, %u bytes/sector"
; 2001 :     FWRMSG( stdout, HHC00463, "I", 0, 0, fname,

  002e7	83 bc 24 80 02
	00 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  002ef	74 11		 je	 SHORT $LN22@create_fba
  002f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169788
  002f8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
  00300	eb 10		 jmp	 SHORT $LN23@create_fba
$LN22@create_fba:
  00302	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  0030a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
$LN23@create_fba:
  00312	0f b7 84 24 48
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  0031a	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv173[rsp], eax
  00321	b9 01 00 00 00	 mov	 ecx, 1
  00326	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0032c	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  00333	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00337	8b 8c 24 58 02
	00 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  0033e	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00342	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv171[rsp]
  0034a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0034f	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv173[rsp]
  00356	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0035a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00362	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00367	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00370	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00379	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169789
  00380	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169790
  0038c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00391	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00396	41 b9 03 00 00
	00		 mov	 r9d, 3
  0039c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169791
  003a3	ba d2 07 00 00	 mov	 edx, 2002		; 000007d2H
  003a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169792
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2002 :             devtype, rawflag ? "" : volser, sectors, sectsz );
; 2003 : 
; 2004 :     /* if `dasdcopy' > 1 then we can replace the existing file */
; 2005 :     if (dasdcopy > 1) x = 0;

  003b5	83 bc 24 78 02
	00 00 01	 cmp	 DWORD PTR dasdcopy$[rsp], 1
  003bd	7e 0b		 jle	 SHORT $LN10@create_fba
  003bf	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$[rsp], 0
$LN10@create_fba:

; 2006 : 
; 2007 :     /* Create the DASD image file */
; 2008 :     hostpath(pathname, fname, sizeof(pathname));

  003ca	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  003d0	48 8b 94 24 40
	02 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  003d8	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  003e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 2009 :     fd = HOPEN (pathname, O_WRONLY | O_CREAT | x | O_BINARY,

  003e6	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  003ed	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  003f2	0f ba e8 0f	 bts	 eax, 15
  003f6	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  003fc	8b d0		 mov	 edx, eax
  003fe	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0040c	89 44 24 78	 mov	 DWORD PTR fd$[rsp], eax

; 2010 :                 S_IRUSR | S_IWUSR | S_IRGRP);
; 2011 :     if (fd < 0)

  00410	83 7c 24 78 00	 cmp	 DWORD PTR fd$[rsp], 0
  00415	0f 8d 9f 00 00
	00		 jge	 $LN11@create_fba

; 2012 :     {
; 2013 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00421	8b 08		 mov	 ecx, DWORD PTR [rax]
  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00429	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  00431	b9 02 00 00 00	 mov	 ecx, 2
  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0043c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  00444	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00449	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169795
  00450	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00455	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0045d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00462	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0046b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169796
  0047b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00480	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169797
  00487	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0048c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00491	41 b9 03 00 00
	00		 mov	 r9d, 3
  00497	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169798
  0049e	ba de 07 00 00	 mov	 edx, 2014		; 000007deH
  004a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169799
  004aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2014 :                 "open()", strerror( errno ));
; 2015 :         return -1;

  004b0	b8 ff ff ff ff	 mov	 eax, -1
  004b5	e9 ae 04 00 00	 jmp	 $LN1@create_fba
$LN11@create_fba:

; 2016 :     }
; 2017 : 
; 2018 :     /* If the `dasdcopy' bit is on then simply allocate the space */
; 2019 :     if (dasdcopy)

  004ba	83 bc 24 78 02
	00 00 00	 cmp	 DWORD PTR dasdcopy$[rsp], 0
  004c2	0f 84 76 01 00
	00		 je	 $LN12@create_fba

; 2020 :     {
; 2021 :         off_t sz = (off_t)((S64)sectors * sectsz);

  004c8	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR sectors$[rsp]
  004cf	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  004d6	48 0f af c1	 imul	 rax, rcx
  004da	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sz$1[rsp], rax

; 2022 :         sz = ROUND_UP( sz, CFBA_BLKGRP_SIZE );

  004e2	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR sz$1[rsp], 0
  004eb	74 29		 je	 SHORT $LN24@create_fba
  004ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sz$1[rsp]
  004f5	48 05 ff ef 00
	00		 add	 rax, 61439		; 0000efffH
  004fb	48 99		 cdq
  004fd	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  00502	48 f7 f9	 idiv	 rcx
  00505	48 69 c0 00 f0
	00 00		 imul	 rax, rax, 61440		; 0000f000H
  0050c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
  00514	eb 0c		 jmp	 SHORT $LN25@create_fba
$LN24@create_fba:
  00516	48 c7 84 24 a8
	00 00 00 00 f0
	00 00		 mov	 QWORD PTR tv223[rsp], 61440 ; 0000f000H
$LN25@create_fba:
  00522	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv223[rsp]
  0052a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sz$1[rsp], rax

; 2023 :         // "This might take a while... Please wait..."
; 2024 :         FWRMSG( stdout, HHC00475, "I" );

  00532	b9 01 00 00 00	 mov	 ecx, 1
  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0053d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169802
  00544	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00549	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169803
  00550	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00555	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0055a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00560	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169804
  00567	ba e8 07 00 00	 mov	 edx, 2024		; 000007e8H
  0056c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169805
  00573	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2025 :         rc = ftruncate (fd, sz);

  00579	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR sz$1[rsp]
  00581	8b 4c 24 78	 mov	 ecx, DWORD PTR fd$[rsp]
  00585	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  0058b	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 2026 :         if (rc < 0)

  0058f	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  00594	0f 8d 9f 00 00
	00		 jge	 $LN14@create_fba

; 2027 :         {
; 2028 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0059a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005a0	8b 08		 mov	 ecx, DWORD PTR [rax]
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  005a8	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv237[rsp], rax
  005b0	b9 02 00 00 00	 mov	 ecx, 2
  005b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv237[rsp]
  005c3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169807
  005cf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005d4	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  005dc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005e1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  005ea	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  005f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169808
  005fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169809
  00606	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0060b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00610	41 b9 03 00 00
	00		 mov	 r9d, 3
  00616	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169810
  0061d	ba ed 07 00 00	 mov	 edx, 2029		; 000007edH
  00622	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169811
  00629	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2029 :                 "ftruncate()", strerror( errno ));
; 2030 :             return -1;

  0062f	b8 ff ff ff ff	 mov	 eax, -1
  00634	e9 2f 03 00 00	 jmp	 $LN1@create_fba
$LN14@create_fba:

; 2031 :         }
; 2032 :     }

  00639	e9 e5 01 00 00	 jmp	 $LN13@create_fba
$LN12@create_fba:

; 2033 :     /* Write each sector */
; 2034 :     else
; 2035 :     {
; 2036 :         for (sectnum = 0; sectnum < sectors; sectnum++)

  0063e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR sectnum$[rsp], 0
  00646	eb 0a		 jmp	 SHORT $LN4@create_fba
$LN2@create_fba:
  00648	8b 44 24 70	 mov	 eax, DWORD PTR sectnum$[rsp]
  0064c	ff c0		 inc	 eax
  0064e	89 44 24 70	 mov	 DWORD PTR sectnum$[rsp], eax
$LN4@create_fba:
  00652	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR sectors$[rsp]
  00659	39 44 24 70	 cmp	 DWORD PTR sectnum$[rsp], eax
  0065d	0f 83 c0 01 00
	00		 jae	 $LN3@create_fba

; 2037 :         {
; 2038 :             /* Clear the sector to zeroes */
; 2039 :             memset (buf, 0, sectsz);

  00663	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR sectsz$[rsp]
  0066a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv290[rsp], rax
  00672	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  0067a	33 c0		 xor	 eax, eax
  0067c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv290[rsp]
  00684	f3 aa		 rep stosb

; 2040 : 
; 2041 :             /* Sector 1 contains the volume label */
; 2042 :             if (!rawflag && sectnum == 1)

  00686	83 bc 24 80 02
	00 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  0068e	75 43		 jne	 SHORT $LN15@create_fba
  00690	83 7c 24 70 01	 cmp	 DWORD PTR sectnum$[rsp], 1
  00695	75 3c		 jne	 SHORT $LN15@create_fba

; 2043 :             {
; 2044 :                 convert_to_ebcdic (buf, 4, "VOL1");

  00697	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169813
  0069e	ba 04 00 00 00	 mov	 edx, 4
  006a3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  006ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 2045 :                 convert_to_ebcdic (buf+4, 6, volser);

  006b1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  006b9	48 83 c0 04	 add	 rax, 4
  006bd	4c 8b 84 24 60
	02 00 00	 mov	 r8, QWORD PTR volser$[rsp]
  006c5	ba 06 00 00 00	 mov	 edx, 6
  006ca	48 8b c8	 mov	 rcx, rax
  006cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic
$LN15@create_fba:

; 2046 :             } /* end if(sectnum==1) */
; 2047 : 
; 2048 :             /* Display progress message every 100 sectors */
; 2049 :             if ((sectnum % 100) == 0)

  006d3	33 d2		 xor	 edx, edx
  006d5	8b 44 24 70	 mov	 eax, DWORD PTR sectnum$[rsp]
  006d9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  006de	f7 f1		 div	 ecx
  006e0	8b c2		 mov	 eax, edx
  006e2	85 c0		 test	 eax, eax
  006e4	75 4e		 jne	 SHORT $LN16@create_fba

; 2050 :             {
; 2051 :                 if (extgui)

  006e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  006ed	83 38 00	 cmp	 DWORD PTR [rax], 0
  006f0	74 22		 je	 SHORT $LN17@create_fba

; 2052 :                     fprintf( stderr, "BLK=%u\n", sectnum );

  006f2	b9 02 00 00 00	 mov	 ecx, 2
  006f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006fd	44 8b 44 24 70	 mov	 r8d, DWORD PTR sectnum$[rsp]
  00702	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169817
  00709	48 8b c8	 mov	 rcx, rax
  0070c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
  00712	eb 20		 jmp	 SHORT $LN18@create_fba
$LN17@create_fba:

; 2053 :                 else
; 2054 :                     fprintf( stderr, "Writing sector %u\r", sectnum );

  00714	b9 02 00 00 00	 mov	 ecx, 2
  00719	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0071f	44 8b 44 24 70	 mov	 r8d, DWORD PTR sectnum$[rsp]
  00724	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169818
  0072b	48 8b c8	 mov	 rcx, rax
  0072e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN18@create_fba:
$LN16@create_fba:

; 2055 :             }
; 2056 : 
; 2057 :             /* Write the sector to the file */
; 2058 :             rc = write (fd, buf, sectsz);

  00734	44 8b 84 24 50
	02 00 00	 mov	 r8d, DWORD PTR sectsz$[rsp]
  0073c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00744	8b 4c 24 78	 mov	 ecx, DWORD PTR fd$[rsp]
  00748	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0074e	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 2059 :             if (rc < (int)sectsz)

  00752	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR sectsz$[rsp]
  00759	39 44 24 74	 cmp	 DWORD PTR rc$[rsp], eax
  0075d	0f 8d bb 00 00
	00		 jge	 $LN19@create_fba

; 2060 :             {
; 2061 :                 FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00763	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00769	83 38 00	 cmp	 DWORD PTR [rax], 0
  0076c	74 18		 je	 SHORT $LN26@create_fba
  0076e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00774	8b 08		 mov	 ecx, DWORD PTR [rax]
  00776	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0077c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv325[rsp], rax
  00784	eb 0f		 jmp	 SHORT $LN27@create_fba
$LN26@create_fba:
  00786	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169820
  0078d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv325[rsp], rax
$LN27@create_fba:
  00795	b9 02 00 00 00	 mov	 ecx, 2
  0079a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007a0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv325[rsp]
  007a8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  007ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169821
  007b4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007b9	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  007c1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007c6	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  007cf	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  007d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169822
  007df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169823
  007eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  007fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169824
  00802	ba 0e 08 00 00	 mov	 edx, 2062		; 0000080eH
  00807	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169825
  0080e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2062 :                         "write()", errno ? strerror( errno ) : "incomplete" );
; 2063 :                 return -1;

  00814	b8 ff ff ff ff	 mov	 eax, -1
  00819	e9 4a 01 00 00	 jmp	 $LN1@create_fba
$LN19@create_fba:

; 2064 :             }
; 2065 :         } /* end for(sectnum) */

  0081e	e9 25 fe ff ff	 jmp	 $LN2@create_fba
$LN3@create_fba:
$LN13@create_fba:

; 2066 :     } /* `dasdcopy' bit is off */
; 2067 : 
; 2068 :     /* Close the DASD image file */
; 2069 :     rc = close (fd);

  00823	8b 4c 24 78	 mov	 ecx, DWORD PTR fd$[rsp]
  00827	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  0082d	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 2070 :     if (rc < 0)

  00831	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  00836	0f 8d 9f 00 00
	00		 jge	 $LN20@create_fba

; 2071 :     {
; 2072 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0083c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00842	8b 08		 mov	 ecx, DWORD PTR [rax]
  00844	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0084a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv343[rsp], rax
  00852	b9 02 00 00 00	 mov	 ecx, 2
  00857	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0085d	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv343[rsp]
  00865	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0086a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169827
  00871	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00876	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0087e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00883	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0088c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00895	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169828
  0089c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169829
  008a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169830
  008bf	ba 19 08 00 00	 mov	 edx, 2073		; 00000819H
  008c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169831
  008cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2073 :                 "close()", strerror( errno ));
; 2074 :         return -1;

  008d1	b8 ff ff ff ff	 mov	 eax, -1
  008d6	e9 8d 00 00 00	 jmp	 $LN1@create_fba
$LN20@create_fba:

; 2075 :     }
; 2076 : 
; 2077 :     /* Release data buffer */
; 2078 :     free (buf);

  008db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  008e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2079 : 
; 2080 :     /* Display completion message */
; 2081 :     // "%1d:%04X CKD file %s: %u %s successfully written"
; 2082 :     FWRMSG( stdout, HHC00460, "I", 0, 0, fname, sectors, "sectors" );

  008e9	b9 01 00 00 00	 mov	 ecx, 1
  008ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169832
  008fb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00900	8b 8c 24 58 02
	00 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  00907	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0090b	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00913	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00918	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00921	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0092a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169833
  00931	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00936	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169834
  0093d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00942	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00947	41 b9 03 00 00
	00		 mov	 r9d, 3
  0094d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169835
  00954	ba 22 08 00 00	 mov	 edx, 2082		; 00000822H
  00959	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169836
  00960	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2083 : 
; 2084 :     return 0;

  00966	33 c0		 xor	 eax, eax
$LN1@create_fba:

; 2085 : } /* end function create_fba */

  00968	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00970	48 33 cc	 xor	 rcx, rsp
  00973	e8 00 00 00 00	 call	 __security_check_cookie
  00978	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  0097f	5f		 pop	 rdi
  00980	c3		 ret	 0
create_fba ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
maxcyls$ = 144
trksize$ = 148
i$ = 152
maxcpif$ = 156
cyl$ = 160
fileseq$ = 164
s$ = 168
suffix$ = 176
tv79 = 184
mincyls$ = 188
endcyl$ = 192
rec0len$ = 196
cylsize$ = 200
tv220 = 204
rc$ = 208
buf$ = 216
pszopt$1 = 224
pszcomp$2 = 232
tv218 = 240
tv85 = 248
tv192 = 256
serial$ = 264
buf$3 = 280
sfname$ = 320
msgbuf$4 = 592
__$ArrayPad$ = 720
fname$ = 752
devtype$ = 760
heads$ = 768
maxdlen$ = 776
volcyls$ = 784
volser$ = 792
comp$ = 800
lfs$ = 808
dasdcopy$ = 816
nullfmt$ = 824
rawflag$ = 832
flagECmode$ = 840
flagMachinecheck$ = 848
create_ckd PROC

; 1773 : {

$LN33:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 02
	00 00		 sub	 rsp, 736		; 000002e0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1774 : int             i;                      /* Array subscript           */
; 1775 : int             rc;                     /* Return code               */
; 1776 : char            *s;                     /* String pointer            */
; 1777 : u_int           fileseq;                /* File sequence number      */
; 1778 : char            sfname[FILENAME_MAX];   /* Suffixed name of this file*/
; 1779 : char            *suffix;                /* -> Suffix character       */
; 1780 : U32             endcyl;                 /* Last cylinder of this file*/
; 1781 : U32             cyl;                    /* Cylinder number           */
; 1782 : U32             cylsize;                /* Cylinder size in bytes    */
; 1783 : BYTE           *buf;                    /* -> Track data buffer      */
; 1784 : U32             mincyls;                /* Minimum cylinder count    */
; 1785 : U32             maxcyls;                /* Maximum cylinder count    */
; 1786 : U32             maxcpif;                /* Maximum number of cylinders
; 1787 :                                            in each CKD image file    */
; 1788 : u_int           rec0len = 8;            /* Length of R0 data         */

  0002e	c7 84 24 c4 00
	00 00 08 00 00
	00		 mov	 DWORD PTR rec0len$[rsp], 8

; 1789 : U32             trksize;                /* DASD image track length   */
; 1790 : char            serial[ sizeof_member( CKD_DEVHDR, dh_serial ) + 1 ] = {0};

  00039	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR serial$[rsp]
  00041	48 8b f8	 mov	 rdi, rax
  00044	33 c0		 xor	 eax, eax
  00046	b9 0d 00 00 00	 mov	 ecx, 13
  0004b	f3 aa		 rep stosb

; 1791 : 
; 1792 :     /* Compute the DASD image track length */
; 1793 :     trksize = CKD_TRKHDR_SIZE

  0004d	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rec0len$[rsp]
  00054	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR maxdlen$[rsp]
  0005b	48 8d 44 08 1d	 lea	 rax, QWORD PTR [rax+rcx+29]
  00060	89 84 24 94 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 1794 :             + CKD_RECHDR_SIZE + rec0len
; 1795 :             + CKD_RECHDR_SIZE + maxdlen
; 1796 :             + CKD_ENDTRK_SIZE;
; 1797 :     trksize = ROUND_UP( trksize, 512 );

  00067	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR trksize$[rsp], 0
  0006f	74 24		 je	 SHORT $LN29@create_ckd
  00071	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  00078	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  0007d	33 d2		 xor	 edx, edx
  0007f	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00084	f7 f1		 div	 ecx
  00086	69 c0 00 02 00
	00		 imul	 eax, eax, 512		; 00000200H
  0008c	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv79[rsp], eax
  00093	eb 0b		 jmp	 SHORT $LN30@create_ckd
$LN29@create_ckd:
  00095	c7 84 24 b8 00
	00 00 00 02 00
	00		 mov	 DWORD PTR tv79[rsp], 512 ; 00000200H
$LN30@create_ckd:
  000a0	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv79[rsp]
  000a7	89 84 24 94 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 1798 : 
; 1799 :     /* Compute minimum and maximum number of cylinders */
; 1800 :     cylsize = trksize * heads;

  000ae	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  000b5	0f af 84 24 00
	03 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  000bd	89 84 24 c8 00
	00 00		 mov	 DWORD PTR cylsize$[rsp], eax

; 1801 :     mincyls = 1;

  000c4	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR mincyls$[rsp], 1

; 1802 :     if (comp == 0xff && !lfs)

  000cf	0f b6 84 24 20
	03 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  000d7	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000dc	75 45		 jne	 SHORT $LN5@create_ckd
  000de	0f b6 84 24 28
	03 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  000e6	85 c0		 test	 eax, eax
  000e8	75 39		 jne	 SHORT $LN5@create_ckd

; 1803 :     {
; 1804 :         maxcpif = (0x7fffffff - CKD_DEVHDR_SIZE + 1) / cylsize;

  000ea	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR cylsize$[rsp]
  000f1	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv85[rsp], rax
  000f9	b8 00 fe ff 7f	 mov	 eax, 2147483136		; 7ffffe00H
  000fe	48 99		 cdq
  00100	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv85[rsp]
  00108	48 f7 f9	 idiv	 rcx
  0010b	89 84 24 9c 00
	00 00		 mov	 DWORD PTR maxcpif$[rsp], eax

; 1805 :         maxcyls = maxcpif * CKD_MAXFILES;

  00112	6b 84 24 9c 00
	00 00 1b	 imul	 eax, DWORD PTR maxcpif$[rsp], 27
  0011a	89 84 24 90 00
	00 00		 mov	 DWORD PTR maxcyls$[rsp], eax

; 1806 :     }

  00121	eb 1c		 jmp	 SHORT $LN6@create_ckd
$LN5@create_ckd:

; 1807 :     else
; 1808 :         maxcpif = maxcyls = volcyls;

  00123	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  0012a	89 84 24 90 00
	00 00		 mov	 DWORD PTR maxcyls$[rsp], eax
  00131	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR maxcyls$[rsp]
  00138	89 84 24 9c 00
	00 00		 mov	 DWORD PTR maxcpif$[rsp], eax
$LN6@create_ckd:

; 1809 : 
; 1810 :     if (maxcyls > 65536)

  0013f	81 bc 24 90 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR maxcyls$[rsp], 65536 ; 00010000H
  0014a	76 69		 jbe	 SHORT $LN7@create_ckd

; 1811 :     {
; 1812 :         maxcyls = 65536;

  0014c	c7 84 24 90 00
	00 00 00 00 01
	00		 mov	 DWORD PTR maxcyls$[rsp], 65536 ; 00010000H

; 1813 :         FWRMSG( stderr, HHC00467, "W", "cylinders", maxcyls );

  00157	b9 02 00 00 00	 mov	 ecx, 2
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00162	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR maxcyls$[rsp]
  00169	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169676
  00174	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169677
  00180	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169678
  0018c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00191	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00196	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169679
  001a3	ba 15 07 00 00	 mov	 edx, 1813		; 00000715H
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169680
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@create_ckd:

; 1814 :     }
; 1815 : 
; 1816 :     /* Check for valid number of cylinders */
; 1817 :     if (volcyls < mincyls || volcyls > maxcyls)

  001b5	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR mincyls$[rsp]
  001bc	39 84 24 10 03
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  001c3	72 14		 jb	 SHORT $LN9@create_ckd
  001c5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR maxcyls$[rsp]
  001cc	39 84 24 10 03
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  001d3	0f 86 ea 01 00
	00		 jbe	 $LN8@create_ckd
$LN9@create_ckd:

; 1818 :     {
; 1819 :         if (comp == 0xff && !lfs)

  001d9	0f b6 84 24 20
	03 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  001e1	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001e6	0f 85 3a 01 00
	00		 jne	 $LN10@create_ckd
  001ec	0f b6 84 24 28
	03 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  001f4	85 c0		 test	 eax, eax
  001f6	0f 85 2a 01 00
	00		 jne	 $LN10@create_ckd

; 1820 :         {
; 1821 :             char    msgbuf[128];
; 1822 : 
; 1823 : #if defined( HAVE_ZLIB ) && defined( CCKD_BZIP2 )
; 1824 :             char   *pszcomp     = " or zlib/bzip2 compression";
; 1825 : #elif defined( HAVE_ZLIB )
; 1826 :             char   *pszcomp     = " or zlib compression";
; 1827 : #elif defined( CCKD_BZIP2 )
; 1828 :             char   *pszcomp     = " or bzip2 compression";
; 1829 : #else
; 1830 :             char   *pszcomp     = "";

  001fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169684
  00203	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pszcomp$2[rsp], rax

; 1831 : #endif
; 1832 :             char   *pszopt;
; 1833 : 
; 1834 :             FWRMSG( stderr, HHC00466, "W", maxcyls, "cylinders", CKD_MAXFILES );

  0020b	b9 02 00 00 00	 mov	 ecx, 2
  00210	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00216	c7 44 24 48 1b
	00 00 00	 mov	 DWORD PTR [rsp+72], 27
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169685
  00225	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0022a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR maxcyls$[rsp]
  00231	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169686
  0023c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169687
  00248	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00252	41 b9 03 00 00
	00		 mov	 r9d, 3
  00258	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169688
  0025f	ba 2a 07 00 00	 mov	 edx, 1834		; 0000072aH
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169689
  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1835 : 
; 1836 :             if ( strlen(pszcomp) > 0 )

  00271	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pszcomp$2[rsp]
  00279	e8 00 00 00 00	 call	 strlen
  0027e	48 85 c0	 test	 rax, rax
  00281	76 11		 jbe	 SHORT $LN11@create_ckd

; 1837 :                 pszopt = "related options";

  00283	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169692
  0028a	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pszopt$1[rsp], rax
  00292	eb 0f		 jmp	 SHORT $LN12@create_ckd
$LN11@create_ckd:

; 1838 :             else
; 1839 :                 pszopt = "option";

  00294	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169693
  0029b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pszopt$1[rsp], rax
$LN12@create_ckd:

; 1840 : 
; 1841 :             MSGBUF(msgbuf, "-lfs%s %s", pszcomp, pszopt );

  002a3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pszopt$1[rsp]
  002ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b0	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR pszcomp$2[rsp]
  002b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169694
  002bf	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  002c4	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$4[rsp]
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1842 :             FWRMSG( stderr, HHC00468, "I", msgbuf );

  002d2	b9 02 00 00 00	 mov	 ecx, 2
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002dd	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$4[rsp]
  002e5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169695
  002f1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169696
  002fd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00302	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00307	41 b9 03 00 00
	00		 mov	 r9d, 3
  0030d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169697
  00314	ba 32 07 00 00	 mov	 edx, 1842		; 00000732H
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169698
  00320	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@create_ckd:

; 1843 :         }
; 1844 : 
; 1845 :         FWRMSG( stderr, HHC00461, "E", 0, 0, fname,

  00326	b9 02 00 00 00	 mov	 ecx, 2
  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00331	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR maxcyls$[rsp]
  00338	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0033c	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR mincyls$[rsp]
  00343	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00347	8b 8c 24 10 03
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  0034e	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169699
  00359	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0035e	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00366	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0036b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00374	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0037d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169700
  00384	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169701
  00390	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00395	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0039a	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169702
  003a7	ba 36 07 00 00	 mov	 edx, 1846		; 00000736H
  003ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169703
  003b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1846 :                 "cylinder", volcyls, mincyls, maxcyls );
; 1847 :         return -1;

  003b9	b8 ff ff ff ff	 mov	 eax, -1
  003be	e9 73 05 00 00	 jmp	 $LN1@create_ckd
$LN8@create_ckd:

; 1848 :     }
; 1849 : 
; 1850 :     /* Obtain track data buffer */
; 1851 :     buf = malloc(trksize);

  003c3	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  003ca	8b c8		 mov	 ecx, eax
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  003d2	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1852 :     if (buf == NULL)

  003da	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  003e3	0f 85 c2 00 00
	00		 jne	 $LN13@create_ckd

; 1853 :     {
; 1854 :         char buf[40];
; 1855 :         MSGBUF( buf, "malloc(%u)", trksize);

  003e9	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR trksize$[rsp]
  003f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169705
  003f8	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  003fd	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00405	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1856 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0040b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00411	8b 08		 mov	 ecx, DWORD PTR [rax]
  00413	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00419	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv192[rsp], rax
  00421	b9 02 00 00 00	 mov	 ecx, 2
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0042c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv192[rsp]
  00434	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00439	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00441	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00446	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0044e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00453	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0045c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00465	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169706
  0046c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00471	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169707
  00478	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0047d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00482	41 b9 03 00 00
	00		 mov	 r9d, 3
  00488	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169708
  0048f	ba 41 07 00 00	 mov	 edx, 1857		; 00000741H
  00494	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169709
  0049b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1857 :                 buf, strerror( errno ));
; 1858 :         return -1;

  004a1	b8 ff ff ff ff	 mov	 eax, -1
  004a6	e9 8b 04 00 00	 jmp	 $LN1@create_ckd
$LN13@create_ckd:

; 1859 :     }
; 1860 : 
; 1861 :     /* Display progress message */
; 1862 :     // "%1d:%04X CKD file %s: creating %4.4X volume %s: %u cyls, %u trks/cyl, %u bytes/track"
; 1863 :     FWRMSG( stdout, HHC00462, "I", 0, 0, fname,

  004ab	0f b6 84 24 40
	03 00 00	 movzx	 eax, BYTE PTR rawflag$[rsp]
  004b3	85 c0		 test	 eax, eax
  004b5	74 11		 je	 SHORT $LN31@create_ckd
  004b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169710
  004be	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv218[rsp], rax
  004c6	eb 10		 jmp	 SHORT $LN32@create_ckd
$LN31@create_ckd:
  004c8	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  004d0	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv218[rsp], rax
$LN32@create_ckd:
  004d8	0f b7 84 24 f8
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  004e0	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv220[rsp], eax
  004e7	b9 01 00 00 00	 mov	 ecx, 1
  004ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004f2	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  004f9	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  004fd	8b 8c 24 00 03
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  00504	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00508	8b 8c 24 10 03
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  0050f	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00513	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv218[rsp]
  0051b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00520	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv220[rsp]
  00527	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0052b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00533	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00538	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00541	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0054a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169711
  00551	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00556	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169712
  0055d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00562	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00567	41 b9 03 00 00
	00		 mov	 r9d, 3
  0056d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169713
  00574	ba 48 07 00 00	 mov	 edx, 1864		; 00000748H
  00579	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169714
  00580	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1864 :             devtype, rawflag ? "" : volser, volcyls, heads, trksize );
; 1865 : 
; 1866 :     /* Copy the unsuffixed DASD image file name */
; 1867 :     STRLCPY( sfname, fname );

  00586	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0058c	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00594	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  0059c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1868 :     suffix = NULL;

  005a2	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR suffix$[rsp], 0

; 1869 : 
; 1870 :     /* Create the suffixed file name if volume will exceed 2GB */
; 1871 :     if (volcyls > maxcpif)

  005ae	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  005b5	39 84 24 10 03
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  005bc	0f 86 9b 01 00
	00		 jbe	 $LN14@create_ckd

; 1872 :     {
; 1873 :         /* Look for last slash marking end of directory name */
; 1874 :         s = strrchr( fname, PATHSEPC);

  005c2	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  005c7	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  005cf	e8 00 00 00 00	 call	 strrchr
  005d4	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1875 :         if (s == NULL) s = fname;

  005dc	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  005e5	75 10		 jne	 SHORT $LN15@create_ckd
  005e7	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  005ef	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN15@create_ckd:

; 1876 : 
; 1877 :         /* Insert suffix before first dot in file name, or
; 1878 :            append suffix to file name if there is no dot.
; 1879 :            If the filename already has a place for the suffix
; 1880 :            then use that. */
; 1881 :         s = strchr (s, '.');

  005f7	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  005fc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00604	e8 00 00 00 00	 call	 strchr
  00609	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1882 :         if (s != NULL)

  00611	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  0061a	0f 84 d8 00 00
	00		 je	 $LN16@create_ckd

; 1883 :         {
; 1884 :             i = (int)(s - fname);

  00620	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  00628	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00630	48 2b c8	 sub	 rcx, rax
  00633	48 8b c1	 mov	 rax, rcx
  00636	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax

; 1885 :             if (i > 2 && fname[i-2] == '_')

  0063d	83 bc 24 98 00
	00 00 02	 cmp	 DWORD PTR i$[rsp], 2
  00645	7e 37		 jle	 SHORT $LN18@create_ckd
  00647	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0064e	83 e8 02	 sub	 eax, 2
  00651	48 98		 cdqe
  00653	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0065b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0065f	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00662	75 1a		 jne	 SHORT $LN18@create_ckd

; 1886 :                 suffix = sfname + i - 1;

  00664	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0066c	48 8d 84 04 3f
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax-1]
  00674	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax
  0067c	eb 78		 jmp	 SHORT $LN19@create_ckd
$LN18@create_ckd:

; 1887 :             else
; 1888 :             {
; 1889 :                 strlcpy( sfname + i, "_1", sizeof(sfname)-(size_t)i );

  0067e	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00686	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  0068b	48 2b c8	 sub	 rcx, rax
  0068e	48 8b c1	 mov	 rax, rcx
  00691	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00699	48 8d 8c 0c 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp+rcx]
  006a1	4c 8b c0	 mov	 r8, rax
  006a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169721
  006ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1890 :                 STRLCAT( sfname, fname + i );

  006b1	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  006b9	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  006c1	48 03 c8	 add	 rcx, rax
  006c4	48 8b c1	 mov	 rax, rcx
  006c7	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  006cd	48 8b d0	 mov	 rdx, rax
  006d0	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  006d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 1891 :                 suffix = sfname + i + 1;

  006de	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  006e6	48 8d 84 04 41
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax+1]
  006ee	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax
$LN19@create_ckd:

; 1892 :             }
; 1893 :         }

  006f6	eb 65		 jmp	 SHORT $LN17@create_ckd
$LN16@create_ckd:

; 1894 :         else
; 1895 :         {
; 1896 :             if (strlen(sfname) < 2 || sfname[strlen(sfname)-2] == '_')

  006f8	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00700	e8 00 00 00 00	 call	 strlen
  00705	48 83 f8 02	 cmp	 rax, 2
  00709	72 1a		 jb	 SHORT $LN21@create_ckd
  0070b	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00713	e8 00 00 00 00	 call	 strlen
  00718	0f be 84 04 3e
	01 00 00	 movsx	 eax, BYTE PTR sfname$[rsp+rax-2]
  00720	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00723	75 1b		 jne	 SHORT $LN20@create_ckd
$LN21@create_ckd:

; 1897 :                 STRLCAT( sfname, "_1" );

  00725	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0072b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169724
  00732	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  0073a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN20@create_ckd:

; 1898 :             suffix = sfname + strlen(sfname) - 1;

  00740	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00748	e8 00 00 00 00	 call	 strlen
  0074d	48 8d 84 04 3f
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax-1]
  00755	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax
$LN17@create_ckd:
$LN14@create_ckd:

; 1899 :         }
; 1900 :     }
; 1901 : 
; 1902 :     /* Generate a random serial number for this new dasd */
; 1903 :     gen_dasd_serial( serial );

  0075d	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR serial$[rsp]
  00765	e8 00 00 00 00	 call	 gen_dasd_serial

; 1904 : 
; 1905 :     /* Create the DASD image files */
; 1906 :     for (cyl = 0, fileseq = 1; cyl < volcyls;

  0076a	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cyl$[rsp], 0
  00775	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fileseq$[rsp], 1
  00780	eb 29		 jmp	 SHORT $LN4@create_ckd
$LN2@create_ckd:

; 1907 :             cyl += maxcpif, fileseq++)

  00782	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  00789	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00790	03 c8		 add	 ecx, eax
  00792	8b c1		 mov	 eax, ecx
  00794	89 84 24 a0 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax
  0079b	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  007a2	ff c0		 inc	 eax
  007a4	89 84 24 a4 00
	00 00		 mov	 DWORD PTR fileseq$[rsp], eax
$LN4@create_ckd:

; 1904 : 
; 1905 :     /* Create the DASD image files */
; 1906 :     for (cyl = 0, fileseq = 1; cyl < volcyls;

  007ab	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  007b2	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR cyl$[rsp], eax
  007b9	0f 83 67 01 00
	00		 jae	 $LN3@create_ckd

; 1908 :     {
; 1909 :         /* Insert the file sequence number in the file name */
; 1910 :         if (suffix)

  007bf	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR suffix$[rsp], 0
  007c8	74 34		 je	 SHORT $LN22@create_ckd

; 1911 :         {
; 1912 :             if ( fileseq <= 9 )

  007ca	83 bc 24 a4 00
	00 00 09	 cmp	 DWORD PTR fileseq$[rsp], 9
  007d2	77 16		 ja	 SHORT $LN23@create_ckd

; 1913 :                 *suffix = '0' + fileseq;

  007d4	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  007db	83 c0 30	 add	 eax, 48			; 00000030H
  007de	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR suffix$[rsp]
  007e6	88 01		 mov	 BYTE PTR [rcx], al
  007e8	eb 14		 jmp	 SHORT $LN24@create_ckd
$LN23@create_ckd:

; 1914 :             else
; 1915 :                 *suffix = 'A' - 10 + fileseq;

  007ea	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  007f1	83 c0 37	 add	 eax, 55			; 00000037H
  007f4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR suffix$[rsp]
  007fc	88 01		 mov	 BYTE PTR [rcx], al
$LN24@create_ckd:
$LN22@create_ckd:

; 1916 :         }
; 1917 : 
; 1918 :         /* Calculate the ending cylinder for this file */
; 1919 :         if (cyl + maxcpif < volcyls)

  007fe	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  00805	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  0080c	03 c8		 add	 ecx, eax
  0080e	8b c1		 mov	 eax, ecx
  00810	3b 84 24 10 03
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  00817	73 1b		 jae	 SHORT $LN25@create_ckd

; 1920 :             endcyl = cyl + maxcpif - 1;

  00819	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  00820	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR maxcpif$[rsp]
  00827	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0082b	89 84 24 c0 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax
  00832	eb 10		 jmp	 SHORT $LN26@create_ckd
$LN25@create_ckd:

; 1921 :         else
; 1922 :             endcyl = volcyls - 1;

  00834	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  0083b	ff c8		 dec	 eax
  0083d	89 84 24 c0 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax
$LN26@create_ckd:

; 1923 : 
; 1924 :         /* Create a CKD DASD image file */
; 1925 :         rc = create_ckd_file (sfname, fileseq, devtype, heads,

  00844	0f b6 84 24 50
	03 00 00	 movzx	 eax, BYTE PTR flagMachinecheck$[rsp]
  0084c	0f b6 8c 24 48
	03 00 00	 movzx	 ecx, BYTE PTR flagECmode$[rsp]
  00854	0f b6 94 24 40
	03 00 00	 movzx	 edx, BYTE PTR rawflag$[rsp]
  0085c	0f b6 bc 24 38
	03 00 00	 movzx	 edi, BYTE PTR nullfmt$[rsp]
  00864	44 0f b6 84 24
	30 03 00 00	 movzx	 r8d, BYTE PTR dasdcopy$[rsp]
  0086d	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  00874	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00878	89 54 24 70	 mov	 DWORD PTR [rsp+112], edx
  0087c	89 7c 24 68	 mov	 DWORD PTR [rsp+104], edi
  00880	44 89 44 24 60	 mov	 DWORD PTR [rsp+96], r8d
  00885	0f b6 84 24 20
	03 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0088d	88 44 24 58	 mov	 BYTE PTR [rsp+88], al
  00891	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  00899	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0089e	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR serial$[rsp]
  008a6	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  008ab	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  008b2	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  008b6	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR endcyl$[rsp]
  008bd	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  008c1	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  008c8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  008cc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  008d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008d9	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  008e0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  008e4	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR heads$[rsp]
  008ec	44 0f b7 84 24
	f8 02 00 00	 movzx	 r8d, WORD PTR devtype$[rsp]
  008f5	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR fileseq$[rsp]
  008fc	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00904	e8 00 00 00 00	 call	 create_ckd_file
  00909	89 84 24 d0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1926 :                     trksize, buf, cyl, endcyl, volcyls, serial, volser,
; 1927 :                     comp, dasdcopy, nullfmt, rawflag,
; 1928 :                     flagECmode, flagMachinecheck);
; 1929 :         if (rc < 0) return -1;

  00910	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00918	7d 07		 jge	 SHORT $LN27@create_ckd
  0091a	b8 ff ff ff ff	 mov	 eax, -1
  0091f	eb 15		 jmp	 SHORT $LN1@create_ckd
$LN27@create_ckd:

; 1930 :     }

  00921	e9 5c fe ff ff	 jmp	 $LN2@create_ckd
$LN3@create_ckd:

; 1931 : 
; 1932 :     /* Release data buffer */
; 1933 :     free (buf);

  00926	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0092e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1934 : 
; 1935 :     return 0;

  00934	33 c0		 xor	 eax, eax
$LN1@create_ckd:

; 1936 : } /* end function create_ckd */

  00936	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0093e	48 33 cc	 xor	 rcx, rsp
  00941	e8 00 00 00 00	 call	 __security_check_cookie
  00946	48 81 c4 e0 02
	00 00		 add	 rsp, 736		; 000002e0H
  0094d	5f		 pop	 rdi
  0094e	c3		 ret	 0
create_ckd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
devfg$ = 0
trklen$ = 4
f1$ = 8
b2$ = 12
c$ = 16
ckd$ = 24
heads$ = 32
fl2$ = 36
fl1$ = 40
x$ = 44
b1$ = 48
tv72 = 52
f5$ = 56
f6$ = 60
devi$ = 64
devl$ = 68
devk$ = 72
nrecs$ = 76
devtl$ = 80
maxlen$ = 84
f2$ = 88
f3$ = 92
tv83 = 96
tv89 = 100
d2$ = 104
d1$ = 108
tv137 = 112
tv153 = 116
f4$ = 120
tv232 = 124
tv273 = 128
tv129 = 132
int1$ = 136
int2$ = 140
cyls$ = 144
cif$ = 176
used$ = 184
keylen$ = 192
datalen$ = 200
newused$ = 208
trkbaln$ = 216
physlen$ = 224
kbconst$ = 232
lbconst$ = 240
nkconst$ = 248
devflag$ = 256
tolfact$ = 264
maxdlen$ = 272
numrecs$ = 280
numhead$ = 288
numcyls$ = 296
capacity_calc PROC

; 1075 : {

$LN35:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1076 : CKDDEV         *ckd;                    /* -> CKD device table entry */
; 1077 : U8              heads;                  /* Number of tracks/cylinder */
; 1078 : U32             cyls;                   /* Number of cyls/volume     */
; 1079 : U16             trklen;                 /* Physical track length     */
; 1080 : U16             maxlen;                 /* Maximum data length       */
; 1081 : int             devi, devl, devk;       /* Overhead fields for VTOC  */
; 1082 : BYTE            devfg;                  /* Flag field for VTOC       */
; 1083 : int             devtl;                  /* Tolerance field for VTOC  */
; 1084 : int             b1;                     /* Bytes used by new record
; 1085 :                                            when last record on track */
; 1086 : int             b2;                     /* Bytes used by new record
; 1087 :                                            when not last on track    */
; 1088 : int             nrecs;                  /* Number of record/track    */
; 1089 : int             c, d1, d2, x;           /* 23xx/3330/3350 factors    */
; 1090 : int             f1, f2, f3, f4, f5, f6; /* 3380/3390/9345 factors    */
; 1091 : int             fl1, fl2, int1, int2;   /* 3380/3390/9345 calculation*/
; 1092 : 
; 1093 :     ckd = cif->devblk.ckdtab;

  0001a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00022	48 8b 80 d0 12
	00 00		 mov	 rax, QWORD PTR [rax+4816]
  00029	48 89 44 24 18	 mov	 QWORD PTR ckd$[rsp], rax

; 1094 :     trklen = ckd->len;

  0002e	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  00033	0f b7 40 1a	 movzx	 eax, WORD PTR [rax+26]
  00037	66 89 44 24 04	 mov	 WORD PTR trklen$[rsp], ax

; 1095 :     maxlen = ckd->r1;

  0003c	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  00041	0f b7 40 16	 movzx	 eax, WORD PTR [rax+22]
  00045	66 89 44 24 54	 mov	 WORD PTR maxlen$[rsp], ax

; 1096 :     heads = (U8)ckd->heads;

  0004a	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  0004f	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  00053	88 44 24 20	 mov	 BYTE PTR heads$[rsp], al

; 1097 :     cyls = ckd->cyls;

  00057	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  0005c	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  00060	89 84 24 90 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax

; 1098 : 
; 1099 :     switch (ckd->formula) {

  00067	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  0006c	0f bf 40 20	 movsx	 eax, WORD PTR [rax+32]
  00070	89 44 24 34	 mov	 DWORD PTR tv72[rsp], eax
  00074	83 7c 24 34 fe	 cmp	 DWORD PTR tv72[rsp], -2
  00079	74 26		 je	 SHORT $LN4@capacity_c
  0007b	83 7c 24 34 ff	 cmp	 DWORD PTR tv72[rsp], -1
  00080	0f 84 2f 01 00
	00		 je	 $LN5@capacity_c
  00086	83 7c 24 34 01	 cmp	 DWORD PTR tv72[rsp], 1
  0008b	0f 84 c7 01 00
	00		 je	 $LN6@capacity_c
  00091	83 7c 24 34 02	 cmp	 DWORD PTR tv72[rsp], 2
  00096	0f 84 a8 02 00
	00		 je	 $LN7@capacity_c
  0009c	e9 27 04 00 00	 jmp	 $LN8@capacity_c
$LN4@capacity_c:

; 1100 : 
; 1101 :     case -2:  /* 2311, 2314 */
; 1102 :         c = ckd->f1; x = ckd->f2; d1 = ckd->f3; d2 = ckd->f4;

  000a1	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  000a6	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  000aa	89 44 24 10	 mov	 DWORD PTR c$[rsp], eax
  000ae	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  000b3	0f b7 40 24	 movzx	 eax, WORD PTR [rax+36]
  000b7	89 44 24 2c	 mov	 DWORD PTR x$[rsp], eax
  000bb	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  000c0	0f b7 40 26	 movzx	 eax, WORD PTR [rax+38]
  000c4	89 44 24 6c	 mov	 DWORD PTR d1$[rsp], eax
  000c8	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  000cd	0f b7 40 28	 movzx	 eax, WORD PTR [rax+40]
  000d1	89 44 24 68	 mov	 DWORD PTR d2$[rsp], eax

; 1103 :         b1 = keylen + datalen + (keylen == 0 ? 0 : c);

  000d5	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR keylen$[rsp], 0
  000dd	75 0a		 jne	 SHORT $LN23@capacity_c
  000df	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000e7	eb 08		 jmp	 SHORT $LN24@capacity_c
$LN23@capacity_c:
  000e9	8b 44 24 10	 mov	 eax, DWORD PTR c$[rsp]
  000ed	89 44 24 60	 mov	 DWORD PTR tv83[rsp], eax
$LN24@capacity_c:
  000f1	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  000f8	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  000ff	03 c8		 add	 ecx, eax
  00101	8b c1		 mov	 eax, ecx
  00103	03 44 24 60	 add	 eax, DWORD PTR tv83[rsp]
  00107	89 44 24 30	 mov	 DWORD PTR b1$[rsp], eax

; 1104 :         b2 = ((keylen + datalen) * d1 / d2)

  0010b	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR keylen$[rsp], 0
  00113	75 0a		 jne	 SHORT $LN25@capacity_c
  00115	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
  0011d	eb 08		 jmp	 SHORT $LN26@capacity_c
$LN25@capacity_c:
  0011f	8b 44 24 10	 mov	 eax, DWORD PTR c$[rsp]
  00123	89 44 24 64	 mov	 DWORD PTR tv89[rsp], eax
$LN26@capacity_c:
  00127	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  0012e	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00135	03 c8		 add	 ecx, eax
  00137	8b c1		 mov	 eax, ecx
  00139	0f af 44 24 6c	 imul	 eax, DWORD PTR d1$[rsp]
  0013e	99		 cdq
  0013f	f7 7c 24 68	 idiv	 DWORD PTR d2$[rsp]
  00143	03 44 24 64	 add	 eax, DWORD PTR tv89[rsp]
  00147	03 44 24 2c	 add	 eax, DWORD PTR x$[rsp]
  0014b	89 44 24 0c	 mov	 DWORD PTR b2$[rsp], eax

; 1105 :                 + (keylen == 0 ? 0 : c) + x;
; 1106 :         nrecs = (trklen - b1)/b2 + 1;

  0014f	0f b7 44 24 04	 movzx	 eax, WORD PTR trklen$[rsp]
  00154	2b 44 24 30	 sub	 eax, DWORD PTR b1$[rsp]
  00158	99		 cdq
  00159	f7 7c 24 0c	 idiv	 DWORD PTR b2$[rsp]
  0015d	ff c0		 inc	 eax
  0015f	89 44 24 4c	 mov	 DWORD PTR nrecs$[rsp], eax

; 1107 :         devi = c + x; devl = c; devk = c; devtl = d1 / (d2/512);

  00163	8b 44 24 2c	 mov	 eax, DWORD PTR x$[rsp]
  00167	8b 4c 24 10	 mov	 ecx, DWORD PTR c$[rsp]
  0016b	03 c8		 add	 ecx, eax
  0016d	8b c1		 mov	 eax, ecx
  0016f	89 44 24 40	 mov	 DWORD PTR devi$[rsp], eax
  00173	8b 44 24 10	 mov	 eax, DWORD PTR c$[rsp]
  00177	89 44 24 44	 mov	 DWORD PTR devl$[rsp], eax
  0017b	8b 44 24 10	 mov	 eax, DWORD PTR c$[rsp]
  0017f	89 44 24 48	 mov	 DWORD PTR devk$[rsp], eax
  00183	8b 44 24 68	 mov	 eax, DWORD PTR d2$[rsp]
  00187	99		 cdq
  00188	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0018e	03 c2		 add	 eax, edx
  00190	c1 f8 09	 sar	 eax, 9
  00193	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
  0019a	8b 44 24 6c	 mov	 eax, DWORD PTR d1$[rsp]
  0019e	99		 cdq
  0019f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv129[rsp]
  001a6	f7 f9		 idiv	 ecx
  001a8	89 44 24 50	 mov	 DWORD PTR devtl$[rsp], eax

; 1108 :         devfg = 0x01;

  001ac	c6 04 24 01	 mov	 BYTE PTR devfg$[rsp], 1

; 1109 :         break;

  001b0	e9 1d 03 00 00	 jmp	 $LN2@capacity_c
$LN5@capacity_c:

; 1110 : 
; 1111 :     case -1:  /* 3330, 3340, 3350 */
; 1112 :         c = ckd->f1; x = ckd->f2;

  001b5	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  001ba	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  001be	89 44 24 10	 mov	 DWORD PTR c$[rsp], eax
  001c2	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  001c7	0f b7 40 24	 movzx	 eax, WORD PTR [rax+36]
  001cb	89 44 24 2c	 mov	 DWORD PTR x$[rsp], eax

; 1113 :         b1 = b2 = keylen + datalen + (keylen == 0 ? 0 : c) + x;

  001cf	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR keylen$[rsp], 0
  001d7	75 0a		 jne	 SHORT $LN27@capacity_c
  001d9	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
  001e1	eb 08		 jmp	 SHORT $LN28@capacity_c
$LN27@capacity_c:
  001e3	8b 44 24 10	 mov	 eax, DWORD PTR c$[rsp]
  001e7	89 44 24 70	 mov	 DWORD PTR tv137[rsp], eax
$LN28@capacity_c:
  001eb	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  001f2	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  001f9	03 c8		 add	 ecx, eax
  001fb	8b c1		 mov	 eax, ecx
  001fd	03 44 24 70	 add	 eax, DWORD PTR tv137[rsp]
  00201	03 44 24 2c	 add	 eax, DWORD PTR x$[rsp]
  00205	89 44 24 0c	 mov	 DWORD PTR b2$[rsp], eax
  00209	8b 44 24 0c	 mov	 eax, DWORD PTR b2$[rsp]
  0020d	89 44 24 30	 mov	 DWORD PTR b1$[rsp], eax

; 1114 :         nrecs = trklen / b2;

  00211	0f b7 44 24 04	 movzx	 eax, WORD PTR trklen$[rsp]
  00216	99		 cdq
  00217	f7 7c 24 0c	 idiv	 DWORD PTR b2$[rsp]
  0021b	89 44 24 4c	 mov	 DWORD PTR nrecs$[rsp], eax

; 1115 :         devi = c + x; devl = c + x; devk = c; devtl = 512;

  0021f	8b 44 24 2c	 mov	 eax, DWORD PTR x$[rsp]
  00223	8b 4c 24 10	 mov	 ecx, DWORD PTR c$[rsp]
  00227	03 c8		 add	 ecx, eax
  00229	8b c1		 mov	 eax, ecx
  0022b	89 44 24 40	 mov	 DWORD PTR devi$[rsp], eax
  0022f	8b 44 24 2c	 mov	 eax, DWORD PTR x$[rsp]
  00233	8b 4c 24 10	 mov	 ecx, DWORD PTR c$[rsp]
  00237	03 c8		 add	 ecx, eax
  00239	8b c1		 mov	 eax, ecx
  0023b	89 44 24 44	 mov	 DWORD PTR devl$[rsp], eax
  0023f	8b 44 24 10	 mov	 eax, DWORD PTR c$[rsp]
  00243	89 44 24 48	 mov	 DWORD PTR devk$[rsp], eax
  00247	c7 44 24 50 00
	02 00 00	 mov	 DWORD PTR devtl$[rsp], 512 ; 00000200H

; 1116 :         devfg = 0x01;

  0024f	c6 04 24 01	 mov	 BYTE PTR devfg$[rsp], 1

; 1117 :         break;

  00253	e9 7a 02 00 00	 jmp	 $LN2@capacity_c
$LN6@capacity_c:

; 1118 : 
; 1119 :     case 1:  /* 3375, 3380 */
; 1120 :         f1 = ckd->f1; f2 = ckd->f2; f3 = ckd->f3;

  00258	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  0025d	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  00261	89 44 24 08	 mov	 DWORD PTR f1$[rsp], eax
  00265	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  0026a	0f b7 40 24	 movzx	 eax, WORD PTR [rax+36]
  0026e	89 44 24 58	 mov	 DWORD PTR f2$[rsp], eax
  00272	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  00277	0f b7 40 26	 movzx	 eax, WORD PTR [rax+38]
  0027b	89 44 24 5c	 mov	 DWORD PTR f3$[rsp], eax

; 1121 :         fl1 = datalen + f2;

  0027f	8b 44 24 58	 mov	 eax, DWORD PTR f2$[rsp]
  00283	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR datalen$[rsp]
  0028a	03 c8		 add	 ecx, eax
  0028c	8b c1		 mov	 eax, ecx
  0028e	89 44 24 28	 mov	 DWORD PTR fl1$[rsp], eax

; 1122 :         fl2 = (keylen == 0 ? 0 : keylen + f3);

  00292	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR keylen$[rsp], 0
  0029a	75 0a		 jne	 SHORT $LN29@capacity_c
  0029c	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
  002a4	eb 13		 jmp	 SHORT $LN30@capacity_c
$LN29@capacity_c:
  002a6	8b 44 24 5c	 mov	 eax, DWORD PTR f3$[rsp]
  002aa	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  002b1	03 c8		 add	 ecx, eax
  002b3	8b c1		 mov	 eax, ecx
  002b5	89 44 24 74	 mov	 DWORD PTR tv153[rsp], eax
$LN30@capacity_c:
  002b9	8b 44 24 74	 mov	 eax, DWORD PTR tv153[rsp]
  002bd	89 44 24 24	 mov	 DWORD PTR fl2$[rsp], eax

; 1123 :         fl1 = ((fl1 + f1 - 1) / f1) * f1;

  002c1	8b 44 24 28	 mov	 eax, DWORD PTR fl1$[rsp]
  002c5	8b 4c 24 08	 mov	 ecx, DWORD PTR f1$[rsp]
  002c9	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002cd	99		 cdq
  002ce	f7 7c 24 08	 idiv	 DWORD PTR f1$[rsp]
  002d2	0f af 44 24 08	 imul	 eax, DWORD PTR f1$[rsp]
  002d7	89 44 24 28	 mov	 DWORD PTR fl1$[rsp], eax

; 1124 :         fl2 = ((fl2 + f1 - 1) / f1) * f1;

  002db	8b 44 24 24	 mov	 eax, DWORD PTR fl2$[rsp]
  002df	8b 4c 24 08	 mov	 ecx, DWORD PTR f1$[rsp]
  002e3	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002e7	99		 cdq
  002e8	f7 7c 24 08	 idiv	 DWORD PTR f1$[rsp]
  002ec	0f af 44 24 08	 imul	 eax, DWORD PTR f1$[rsp]
  002f1	89 44 24 24	 mov	 DWORD PTR fl2$[rsp], eax

; 1125 :         b1 = b2 = fl1 + fl2;

  002f5	8b 44 24 24	 mov	 eax, DWORD PTR fl2$[rsp]
  002f9	8b 4c 24 28	 mov	 ecx, DWORD PTR fl1$[rsp]
  002fd	03 c8		 add	 ecx, eax
  002ff	8b c1		 mov	 eax, ecx
  00301	89 44 24 0c	 mov	 DWORD PTR b2$[rsp], eax
  00305	8b 44 24 0c	 mov	 eax, DWORD PTR b2$[rsp]
  00309	89 44 24 30	 mov	 DWORD PTR b1$[rsp], eax

; 1126 :         nrecs = trklen / b2;

  0030d	0f b7 44 24 04	 movzx	 eax, WORD PTR trklen$[rsp]
  00312	99		 cdq
  00313	f7 7c 24 0c	 idiv	 DWORD PTR b2$[rsp]
  00317	89 44 24 4c	 mov	 DWORD PTR nrecs$[rsp], eax

; 1127 :         devi = 0; devl = 0; devk = 0; devtl = 0; devfg = 0x30;

  0031b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR devi$[rsp], 0
  00323	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR devl$[rsp], 0
  0032b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR devk$[rsp], 0
  00333	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR devtl$[rsp], 0
  0033b	c6 04 24 30	 mov	 BYTE PTR devfg$[rsp], 48 ; 00000030H

; 1128 :         break;

  0033f	e9 8e 01 00 00	 jmp	 $LN2@capacity_c
$LN7@capacity_c:

; 1129 : 
; 1130 :     case 2:  /* 3390, 9345 */
; 1131 :         f1 = ckd->f1; f2 = ckd->f2; f3 = ckd->f3;

  00344	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  00349	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  0034d	89 44 24 08	 mov	 DWORD PTR f1$[rsp], eax
  00351	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  00356	0f b7 40 24	 movzx	 eax, WORD PTR [rax+36]
  0035a	89 44 24 58	 mov	 DWORD PTR f2$[rsp], eax
  0035e	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  00363	0f b7 40 26	 movzx	 eax, WORD PTR [rax+38]
  00367	89 44 24 5c	 mov	 DWORD PTR f3$[rsp], eax

; 1132 :         f4 = ckd->f4; f5 = ckd->f5; f6 = ckd->f6;

  0036b	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  00370	0f b7 40 28	 movzx	 eax, WORD PTR [rax+40]
  00374	89 44 24 78	 mov	 DWORD PTR f4$[rsp], eax
  00378	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  0037d	0f b7 40 2a	 movzx	 eax, WORD PTR [rax+42]
  00381	89 44 24 38	 mov	 DWORD PTR f5$[rsp], eax
  00385	48 8b 44 24 18	 mov	 rax, QWORD PTR ckd$[rsp]
  0038a	0f b7 40 2c	 movzx	 eax, WORD PTR [rax+44]
  0038e	89 44 24 3c	 mov	 DWORD PTR f6$[rsp], eax

; 1133 :         int1 = ((datalen + f6) + (f5*2-1)) / (f5*2);

  00392	8b 44 24 3c	 mov	 eax, DWORD PTR f6$[rsp]
  00396	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR datalen$[rsp]
  0039d	03 c8		 add	 ecx, eax
  0039f	8b c1		 mov	 eax, ecx
  003a1	8b 4c 24 38	 mov	 ecx, DWORD PTR f5$[rsp]
  003a5	8d 44 48 ff	 lea	 eax, DWORD PTR [rax+rcx*2-1]
  003a9	8b 4c 24 38	 mov	 ecx, DWORD PTR f5$[rsp]
  003ad	03 c9		 add	 ecx, ecx
  003af	99		 cdq
  003b0	f7 f9		 idiv	 ecx
  003b2	89 84 24 88 00
	00 00		 mov	 DWORD PTR int1$[rsp], eax

; 1134 :         int2 = ((keylen + f6) + (f5*2-1)) / (f5*2);

  003b9	8b 44 24 3c	 mov	 eax, DWORD PTR f6$[rsp]
  003bd	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  003c4	03 c8		 add	 ecx, eax
  003c6	8b c1		 mov	 eax, ecx
  003c8	8b 4c 24 38	 mov	 ecx, DWORD PTR f5$[rsp]
  003cc	8d 44 48 ff	 lea	 eax, DWORD PTR [rax+rcx*2-1]
  003d0	8b 4c 24 38	 mov	 ecx, DWORD PTR f5$[rsp]
  003d4	d1 e1		 shl	 ecx, 1
  003d6	99		 cdq
  003d7	f7 f9		 idiv	 ecx
  003d9	89 84 24 8c 00
	00 00		 mov	 DWORD PTR int2$[rsp], eax

; 1135 :         fl1 = (f1 * f2) + datalen + f6 + f4*int1;

  003e0	8b 44 24 08	 mov	 eax, DWORD PTR f1$[rsp]
  003e4	0f af 44 24 58	 imul	 eax, DWORD PTR f2$[rsp]
  003e9	03 84 24 c8 00
	00 00		 add	 eax, DWORD PTR datalen$[rsp]
  003f0	03 44 24 3c	 add	 eax, DWORD PTR f6$[rsp]
  003f4	8b 4c 24 78	 mov	 ecx, DWORD PTR f4$[rsp]
  003f8	0f af 8c 24 88
	00 00 00	 imul	 ecx, DWORD PTR int1$[rsp]
  00400	03 c1		 add	 eax, ecx
  00402	89 44 24 28	 mov	 DWORD PTR fl1$[rsp], eax

; 1136 :         fl2 = (keylen == 0 ? 0 : (f1 * f3) + keylen + f6 + f4*int2);

  00406	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR keylen$[rsp], 0
  0040e	75 0a		 jne	 SHORT $LN31@capacity_c
  00410	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
  00418	eb 26		 jmp	 SHORT $LN32@capacity_c
$LN31@capacity_c:
  0041a	8b 44 24 08	 mov	 eax, DWORD PTR f1$[rsp]
  0041e	0f af 44 24 5c	 imul	 eax, DWORD PTR f3$[rsp]
  00423	03 84 24 c0 00
	00 00		 add	 eax, DWORD PTR keylen$[rsp]
  0042a	03 44 24 3c	 add	 eax, DWORD PTR f6$[rsp]
  0042e	8b 4c 24 78	 mov	 ecx, DWORD PTR f4$[rsp]
  00432	0f af 8c 24 8c
	00 00 00	 imul	 ecx, DWORD PTR int2$[rsp]
  0043a	03 c1		 add	 eax, ecx
  0043c	89 44 24 7c	 mov	 DWORD PTR tv232[rsp], eax
$LN32@capacity_c:
  00440	8b 44 24 7c	 mov	 eax, DWORD PTR tv232[rsp]
  00444	89 44 24 24	 mov	 DWORD PTR fl2$[rsp], eax

; 1137 :         fl1 = ((fl1 + f1 - 1) / f1) * f1;

  00448	8b 44 24 28	 mov	 eax, DWORD PTR fl1$[rsp]
  0044c	8b 4c 24 08	 mov	 ecx, DWORD PTR f1$[rsp]
  00450	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00454	99		 cdq
  00455	f7 7c 24 08	 idiv	 DWORD PTR f1$[rsp]
  00459	0f af 44 24 08	 imul	 eax, DWORD PTR f1$[rsp]
  0045e	89 44 24 28	 mov	 DWORD PTR fl1$[rsp], eax

; 1138 :         fl2 = ((fl2 + f1 - 1) / f1) * f1;

  00462	8b 44 24 24	 mov	 eax, DWORD PTR fl2$[rsp]
  00466	8b 4c 24 08	 mov	 ecx, DWORD PTR f1$[rsp]
  0046a	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0046e	99		 cdq
  0046f	f7 7c 24 08	 idiv	 DWORD PTR f1$[rsp]
  00473	0f af 44 24 08	 imul	 eax, DWORD PTR f1$[rsp]
  00478	89 44 24 24	 mov	 DWORD PTR fl2$[rsp], eax

; 1139 :         b1 = b2 = fl1 + fl2;

  0047c	8b 44 24 24	 mov	 eax, DWORD PTR fl2$[rsp]
  00480	8b 4c 24 28	 mov	 ecx, DWORD PTR fl1$[rsp]
  00484	03 c8		 add	 ecx, eax
  00486	8b c1		 mov	 eax, ecx
  00488	89 44 24 0c	 mov	 DWORD PTR b2$[rsp], eax
  0048c	8b 44 24 0c	 mov	 eax, DWORD PTR b2$[rsp]
  00490	89 44 24 30	 mov	 DWORD PTR b1$[rsp], eax

; 1140 :         nrecs = trklen / b2;

  00494	0f b7 44 24 04	 movzx	 eax, WORD PTR trklen$[rsp]
  00499	99		 cdq
  0049a	f7 7c 24 0c	 idiv	 DWORD PTR b2$[rsp]
  0049e	89 44 24 4c	 mov	 DWORD PTR nrecs$[rsp], eax

; 1141 :         devi = 0; devl = 0; devk = 0; devtl = 0; devfg = 0x30;

  004a2	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR devi$[rsp], 0
  004aa	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR devl$[rsp], 0
  004b2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR devk$[rsp], 0
  004ba	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR devtl$[rsp], 0
  004c2	c6 04 24 30	 mov	 BYTE PTR devfg$[rsp], 48 ; 00000030H

; 1142 :         break;

  004c6	eb 0a		 jmp	 SHORT $LN2@capacity_c
$LN8@capacity_c:

; 1143 : 
; 1144 :     default:
; 1145 :         return -1;

  004c8	b8 ff ff ff ff	 mov	 eax, -1
  004cd	e9 9d 01 00 00	 jmp	 $LN1@capacity_c
$LN2@capacity_c:

; 1146 :     } /* end switch(ckd->formula) */
; 1147 : 
; 1148 :     /* Return VTOC fields and maximum data length */
; 1149 :     if (physlen != NULL) *physlen = trklen;

  004d2	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR physlen$[rsp], 0
  004db	74 0f		 je	 SHORT $LN9@capacity_c
  004dd	0f b7 44 24 04	 movzx	 eax, WORD PTR trklen$[rsp]
  004e2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR physlen$[rsp]
  004ea	89 01		 mov	 DWORD PTR [rcx], eax
$LN9@capacity_c:

; 1150 :     if (kbconst != NULL) *kbconst = devi;

  004ec	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR kbconst$[rsp], 0
  004f5	74 0e		 je	 SHORT $LN10@capacity_c
  004f7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR kbconst$[rsp]
  004ff	8b 4c 24 40	 mov	 ecx, DWORD PTR devi$[rsp]
  00503	89 08		 mov	 DWORD PTR [rax], ecx
$LN10@capacity_c:

; 1151 :     if (lbconst != NULL) *lbconst = devl;

  00505	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR lbconst$[rsp], 0
  0050e	74 0e		 je	 SHORT $LN11@capacity_c
  00510	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR lbconst$[rsp]
  00518	8b 4c 24 44	 mov	 ecx, DWORD PTR devl$[rsp]
  0051c	89 08		 mov	 DWORD PTR [rax], ecx
$LN11@capacity_c:

; 1152 :     if (nkconst != NULL) *nkconst = devk;

  0051e	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR nkconst$[rsp], 0
  00527	74 0e		 je	 SHORT $LN12@capacity_c
  00529	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR nkconst$[rsp]
  00531	8b 4c 24 48	 mov	 ecx, DWORD PTR devk$[rsp]
  00535	89 08		 mov	 DWORD PTR [rax], ecx
$LN12@capacity_c:

; 1153 :     if (devflag != NULL) *devflag = devfg;

  00537	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR devflag$[rsp], 0
  00540	74 0e		 je	 SHORT $LN13@capacity_c
  00542	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR devflag$[rsp]
  0054a	0f b6 0c 24	 movzx	 ecx, BYTE PTR devfg$[rsp]
  0054e	88 08		 mov	 BYTE PTR [rax], cl
$LN13@capacity_c:

; 1154 :     if (tolfact != NULL) *tolfact = devtl;

  00550	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR tolfact$[rsp], 0
  00559	74 0e		 je	 SHORT $LN14@capacity_c
  0055b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tolfact$[rsp]
  00563	8b 4c 24 50	 mov	 ecx, DWORD PTR devtl$[rsp]
  00567	89 08		 mov	 DWORD PTR [rax], ecx
$LN14@capacity_c:

; 1155 :     if (maxdlen != NULL) *maxdlen = maxlen;

  00569	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR maxdlen$[rsp], 0
  00572	74 0f		 je	 SHORT $LN15@capacity_c
  00574	0f b7 44 24 54	 movzx	 eax, WORD PTR maxlen$[rsp]
  00579	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR maxdlen$[rsp]
  00581	89 01		 mov	 DWORD PTR [rcx], eax
$LN15@capacity_c:

; 1156 : 
; 1157 :     /* Return number of records per track */
; 1158 :     if (numrecs != NULL) *numrecs = nrecs;

  00583	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR numrecs$[rsp], 0
  0058c	74 0e		 je	 SHORT $LN16@capacity_c
  0058e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR numrecs$[rsp]
  00596	8b 4c 24 4c	 mov	 ecx, DWORD PTR nrecs$[rsp]
  0059a	89 08		 mov	 DWORD PTR [rax], ecx
$LN16@capacity_c:

; 1159 : 
; 1160 :     /* Return number of tracks per cylinder
; 1161 :        and usual number of cylinders per volume */
; 1162 :     if (numhead != NULL) *numhead = heads;

  0059c	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR numhead$[rsp], 0
  005a5	74 0f		 je	 SHORT $LN17@capacity_c
  005a7	0f b6 44 24 20	 movzx	 eax, BYTE PTR heads$[rsp]
  005ac	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR numhead$[rsp]
  005b4	89 01		 mov	 DWORD PTR [rcx], eax
$LN17@capacity_c:

; 1163 :     if (numcyls != NULL) *numcyls = cyls;

  005b6	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR numcyls$[rsp], 0
  005bf	74 11		 je	 SHORT $LN18@capacity_c
  005c1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR numcyls$[rsp]
  005c9	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  005d0	89 08		 mov	 DWORD PTR [rax], ecx
$LN18@capacity_c:

; 1164 : 
; 1165 :     /* Return if record will not fit on the track */
; 1166 :     if (used + b1 > trklen)

  005d2	8b 44 24 30	 mov	 eax, DWORD PTR b1$[rsp]
  005d6	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR used$[rsp]
  005dd	03 c8		 add	 ecx, eax
  005df	8b c1		 mov	 eax, ecx
  005e1	0f b7 4c 24 04	 movzx	 ecx, WORD PTR trklen$[rsp]
  005e6	3b c1		 cmp	 eax, ecx
  005e8	7e 07		 jle	 SHORT $LN19@capacity_c

; 1167 :         return +1;

  005ea	b8 01 00 00 00	 mov	 eax, 1
  005ef	eb 7e		 jmp	 SHORT $LN1@capacity_c
$LN19@capacity_c:

; 1168 : 
; 1169 :     /* Calculate number of bytes used and track balance */
; 1170 :     if (newused != NULL)

  005f1	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR newused$[rsp], 0
  005fa	74 19		 je	 SHORT $LN20@capacity_c

; 1171 :         *newused = used + b2;

  005fc	8b 44 24 0c	 mov	 eax, DWORD PTR b2$[rsp]
  00600	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR used$[rsp]
  00607	03 c8		 add	 ecx, eax
  00609	8b c1		 mov	 eax, ecx
  0060b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR newused$[rsp]
  00613	89 01		 mov	 DWORD PTR [rcx], eax
$LN20@capacity_c:

; 1172 :     if (trkbaln != NULL)

  00615	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR trkbaln$[rsp], 0
  0061e	74 4d		 je	 SHORT $LN21@capacity_c

; 1173 :         *trkbaln = (used + b2 > trklen) ? 0 : trklen - used - b2;

  00620	8b 44 24 0c	 mov	 eax, DWORD PTR b2$[rsp]
  00624	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR used$[rsp]
  0062b	03 c8		 add	 ecx, eax
  0062d	8b c1		 mov	 eax, ecx
  0062f	0f b7 4c 24 04	 movzx	 ecx, WORD PTR trklen$[rsp]
  00634	3b c1		 cmp	 eax, ecx
  00636	7e 0d		 jle	 SHORT $LN33@capacity_c
  00638	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv273[rsp], 0
  00643	eb 17		 jmp	 SHORT $LN34@capacity_c
$LN33@capacity_c:
  00645	0f b7 44 24 04	 movzx	 eax, WORD PTR trklen$[rsp]
  0064a	2b 84 24 b8 00
	00 00		 sub	 eax, DWORD PTR used$[rsp]
  00651	2b 44 24 0c	 sub	 eax, DWORD PTR b2$[rsp]
  00655	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv273[rsp], eax
$LN34@capacity_c:
  0065c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR trkbaln$[rsp]
  00664	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  0066b	89 08		 mov	 DWORD PTR [rax], ecx
$LN21@capacity_c:

; 1174 : 
; 1175 :     return 0;

  0066d	33 c0		 xor	 eax, eax
$LN1@capacity_c:

; 1176 : } /* end function capacity_calc */

  0066f	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00676	c3		 ret	 0
capacity_calc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
rec$ = 144
head$ = 145
rc$ = 148
keylen$ = 152
cyl$ = 156
f3dscb$ = 160
f1dscb$ = 168
f4dscb$ = 176
vol1data$ = 184
tv158 = 192
tv165 = 196
tv169 = 200
tv195 = 204
tv199 = 208
tv216 = 212
tv221 = 216
tv226 = 220
tv231 = 224
tv236 = 228
tv241 = 232
tv256 = 236
tv287 = 240
tv291 = 244
tv305 = 248
tv307 = 252
tv314 = 256
tv344 = 260
tv348 = 264
tv415 = 268
tv419 = 272
len$ = 276
tv82 = 280
tv86 = 284
tv156 = 288
volser$ = 292
dsname$ = 304
__$ArrayPad$ = 352
cif$ = 400
dsnama$ = 408
extent$ = 416
noext$ = 424
build_extent_array PROC

; 908  : {

$LN17:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	48 81 ec 70 01
	00 00		 sub	 rsp, 368		; 00000170H
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00025	48 33 c4	 xor	 rax, rsp
  00028	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 909  : int             rc;                     /* Return code               */
; 910  : U16             len;                    /* Record length             */
; 911  : U8              keylen;                 /* Key length                */
; 912  : U32             cyl;                    /* Cylinder number           */
; 913  : U8              head;                   /* Head number               */
; 914  : U8              rec;                    /* Record number             */
; 915  : BYTE           *vol1data;               /* -> Volume label           */
; 916  : FORMAT1_DSCB   *f1dscb;                 /* -> Format 1 DSCB          */
; 917  : FORMAT3_DSCB   *f3dscb;                 /* -> Format 3 DSCB          */
; 918  : FORMAT4_DSCB   *f4dscb;                 /* -> Format 4 DSCB          */
; 919  : BYTE            dsname[44];             /* Dataset name (EBCDIC)     */
; 920  : char            volser[7];              /* Volume serial (ASCIIZ)    */
; 921  : 
; 922  :     /* Convert the dataset name to EBCDIC */
; 923  :     convert_to_ebcdic (dsname, sizeof(dsname), dsnama);

  00030	4c 8b 84 24 98
	01 00 00	 mov	 r8, QWORD PTR dsnama$[rsp]
  00038	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  0003d	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR dsname$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 924  : 
; 925  :     /* Read the volume label */
; 926  :     rc = read_block (cif, 0, 0, 3, NULL, NULL, &vol1data, &len);

  0004b	48 8d 84 24 14
	01 00 00	 lea	 rax, QWORD PTR len$[rsp]
  00053	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00058	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR vol1data$[rsp]
  00060	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00065	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0006e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00077	41 b1 03	 mov	 r9b, 3
  0007a	45 33 c0	 xor	 r8d, r8d
  0007d	33 d2		 xor	 edx, edx
  0007f	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00087	e8 00 00 00 00	 call	 read_block
  0008c	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 927  :     if (rc < 0) return -1;

  00093	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0009b	7d 0a		 jge	 SHORT $LN2@build_exte
  0009d	b8 ff ff ff ff	 mov	 eax, -1
  000a2	e9 79 0d 00 00	 jmp	 $LN1@build_exte
$LN2@build_exte:

; 928  :     if (rc > 0)

  000a7	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  000af	0f 8e ab 00 00
	00		 jle	 $LN3@build_exte

; 929  :     {
; 930  :         FWRMSG( stderr, HHC00455, "E", SSID_TO_LCSS(cif->devblk.ssid),

  000b5	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  000bd	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  000c1	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000c8	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000d0	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  000d4	d1 f9		 sar	 ecx, 1
  000d6	89 8c 24 1c 01
	00 00		 mov	 DWORD PTR tv86[rsp], ecx
  000dd	b9 02 00 00 00	 mov	 ecx, 2
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169157
  000ef	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000f4	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000fc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ff	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00104	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  0010b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0010f	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  00116	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169158
  00121	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169159
  0012d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00132	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00137	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169160
  00144	ba a3 03 00 00	 mov	 edx, 931		; 000003a3H
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169161
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 931  :             cif->devblk.devnum, cif->fname, "VOL1" );
; 932  :         return -1;

  00156	b8 ff ff ff ff	 mov	 eax, -1
  0015b	e9 c0 0c 00 00	 jmp	 $LN1@build_exte
$LN3@build_exte:

; 933  :     }
; 934  : 
; 935  :     /* Extract the volume serial and the CCHHR of the format 4 DSCB */
; 936  :     make_asciiz (volser, sizeof(volser), vol1data+4, 6);

  00160	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vol1data$[rsp]
  00168	48 83 c0 04	 add	 rax, 4
  0016c	41 b9 06 00 00
	00		 mov	 r9d, 6
  00172	4c 8b c0	 mov	 r8, rax
  00175	ba 07 00 00 00	 mov	 edx, 7
  0017a	48 8d 8c 24 24
	01 00 00	 lea	 rcx, QWORD PTR volser$[rsp]
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 937  :     cyl = (vol1data[11] << 8) | vol1data[12];

  00188	b8 01 00 00 00	 mov	 eax, 1
  0018d	48 6b c0 0b	 imul	 rax, rax, 11
  00191	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR vol1data$[rsp]
  00199	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0019d	c1 e0 08	 shl	 eax, 8
  001a0	b9 01 00 00 00	 mov	 ecx, 1
  001a5	48 6b c9 0c	 imul	 rcx, rcx, 12
  001a9	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR vol1data$[rsp]
  001b1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001b5	0b c1		 or	 eax, ecx
  001b7	89 84 24 9c 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax

; 938  :     head = (vol1data[13] << 8) | vol1data[14];

  001be	b8 01 00 00 00	 mov	 eax, 1
  001c3	48 6b c0 0d	 imul	 rax, rax, 13
  001c7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR vol1data$[rsp]
  001cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d3	c1 e0 08	 shl	 eax, 8
  001d6	b9 01 00 00 00	 mov	 ecx, 1
  001db	48 6b c9 0e	 imul	 rcx, rcx, 14
  001df	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR vol1data$[rsp]
  001e7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001eb	0b c1		 or	 eax, ecx
  001ed	88 84 24 91 00
	00 00		 mov	 BYTE PTR head$[rsp], al

; 939  :     rec = vol1data[15];

  001f4	b8 01 00 00 00	 mov	 eax, 1
  001f9	48 6b c0 0f	 imul	 rax, rax, 15
  001fd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR vol1data$[rsp]
  00205	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00209	88 84 24 90 00
	00 00		 mov	 BYTE PTR rec$[rsp], al

; 940  : 
; 941  :     if (is_verbose_util())

  00210	e8 00 00 00 00	 call	 is_verbose_util
  00215	0f b6 c0	 movzx	 eax, al
  00218	85 c0		 test	 eax, eax
  0021a	0f 84 e4 00 00
	00		 je	 $LN4@build_exte

; 942  :     {
; 943  :        FWRMSG( stdout, HHC00456, "I", SSID_TO_LCSS(cif->devblk.ssid),

  00220	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR rec$[rsp]
  00228	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv156[rsp], eax
  0022f	0f b6 8c 24 91
	00 00 00	 movzx	 ecx, BYTE PTR head$[rsp]
  00237	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv158[rsp], ecx
  0023e	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  00246	0f b7 52 78	 movzx	 edx, WORD PTR [rdx+120]
  0024a	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv165[rsp], edx
  00251	4c 8b 84 24 90
	01 00 00	 mov	 r8, QWORD PTR cif$[rsp]
  00259	45 0f b7 40 74	 movzx	 r8d, WORD PTR [r8+116]
  0025e	41 d1 f8	 sar	 r8d, 1
  00261	44 89 84 24 c8
	00 00 00	 mov	 DWORD PTR tv169[rsp], r8d
  00269	b9 01 00 00 00	 mov	 ecx, 1
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00274	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv156[rsp]
  0027b	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0027f	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv158[rsp]
  00286	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0028a	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00291	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00295	48 8d 8c 24 24
	01 00 00	 lea	 rcx, QWORD PTR volser$[rsp]
  0029d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002a2	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  002aa	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002ad	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002b2	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv165[rsp]
  002b9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002bd	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv169[rsp]
  002c4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169163
  002cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169164
  002db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169165
  002f2	ba b0 03 00 00	 mov	 edx, 944		; 000003b0H
  002f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169166
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@build_exte:

; 944  :            cif->devblk.devnum, cif->fname, volser, cyl, head, rec );
; 945  :     }
; 946  : 
; 947  :     /* Read the format 4 DSCB */
; 948  :     rc = read_block (cif, cyl, head, rec,

  00304	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0030d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00316	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR keylen$[rsp]
  0031e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00323	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR f4dscb$[rsp]
  0032b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00330	44 0f b6 8c 24
	90 00 00 00	 movzx	 r9d, BYTE PTR rec$[rsp]
  00339	44 0f b6 84 24
	91 00 00 00	 movzx	 r8d, BYTE PTR head$[rsp]
  00342	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  00349	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00351	e8 00 00 00 00	 call	 read_block
  00356	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 949  :                     (void *)&f4dscb, &keylen, NULL, NULL);
; 950  :     if (rc < 0) return -1;

  0035d	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00365	7d 0a		 jge	 SHORT $LN5@build_exte
  00367	b8 ff ff ff ff	 mov	 eax, -1
  0036c	e9 af 0a 00 00	 jmp	 $LN1@build_exte
$LN5@build_exte:

; 951  :     if (rc > 0)

  00371	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00379	0f 8e ab 00 00
	00		 jle	 $LN6@build_exte

; 952  :     {
; 953  :         FWRMSG( stderr, HHC00455, "E", SSID_TO_LCSS(cif->devblk.ssid),

  0037f	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00387	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  0038b	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv195[rsp], eax
  00392	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0039a	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  0039e	d1 f9		 sar	 ecx, 1
  003a0	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv199[rsp], ecx
  003a7	b9 02 00 00 00	 mov	 ecx, 2
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169169
  003b9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003be	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  003c6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003c9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003ce	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  003d5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003d9	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv199[rsp]
  003e0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169170
  003eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169171
  003f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00401	41 b9 03 00 00
	00		 mov	 r9d, 3
  00407	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169172
  0040e	ba ba 03 00 00	 mov	 edx, 954		; 000003baH
  00413	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169173
  0041a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 954  :             cif->devblk.devnum, cif->fname, "F4DSCB" );
; 955  :         return -1;

  00420	b8 ff ff ff ff	 mov	 eax, -1
  00425	e9 f6 09 00 00	 jmp	 $LN1@build_exte
$LN6@build_exte:

; 956  :     }
; 957  : 
; 958  :     if (is_verbose_util())

  0042a	e8 00 00 00 00	 call	 is_verbose_util
  0042f	0f b6 c0	 movzx	 eax, al
  00432	85 c0		 test	 eax, eax
  00434	0f 84 c1 01 00
	00		 je	 $LN7@build_exte

; 959  :     {
; 960  :        FWRMSG( stdout, HHC00457, "I", SSID_TO_LCSS(cif->devblk.ssid),

  0043a	b8 01 00 00 00	 mov	 eax, 1
  0043f	48 6b c0 01	 imul	 rax, rax, 1
  00443	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  0044b	0f b6 44 01 71	 movzx	 eax, BYTE PTR [rcx+rax+113]
  00450	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
  00457	b9 01 00 00 00	 mov	 ecx, 1
  0045c	48 6b c9 00	 imul	 rcx, rcx, 0
  00460	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00468	0f b6 4c 0a 71	 movzx	 ecx, BYTE PTR [rdx+rcx+113]
  0046d	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv221[rsp], ecx
  00474	ba 01 00 00 00	 mov	 edx, 1
  00479	48 6b d2 01	 imul	 rdx, rdx, 1
  0047d	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR f4dscb$[rsp]
  00485	41 0f b6 54 10
	6f		 movzx	 edx, BYTE PTR [r8+rdx+111]
  0048b	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv226[rsp], edx
  00492	41 b8 01 00 00
	00		 mov	 r8d, 1
  00498	4d 6b c0 00	 imul	 r8, r8, 0
  0049c	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR f4dscb$[rsp]
  004a4	47 0f b6 44 01
	6f		 movzx	 r8d, BYTE PTR [r9+r8+111]
  004aa	44 89 84 24 e0
	00 00 00	 mov	 DWORD PTR tv231[rsp], r8d
  004b2	41 b9 01 00 00
	00		 mov	 r9d, 1
  004b8	4d 6b c9 01	 imul	 r9, r9, 1
  004bc	4c 8b 94 24 b0
	00 00 00	 mov	 r10, QWORD PTR f4dscb$[rsp]
  004c4	47 0f b6 4c 0a
	6d		 movzx	 r9d, BYTE PTR [r10+r9+109]
  004ca	44 89 8c 24 e4
	00 00 00	 mov	 DWORD PTR tv236[rsp], r9d
  004d2	41 ba 01 00 00
	00		 mov	 r10d, 1
  004d8	4d 6b d2 00	 imul	 r10, r10, 0
  004dc	4c 8b 9c 24 b0
	00 00 00	 mov	 r11, QWORD PTR f4dscb$[rsp]
  004e4	47 0f b6 54 13
	6d		 movzx	 r10d, BYTE PTR [r11+r10+109]
  004ea	44 89 94 24 e8
	00 00 00	 mov	 DWORD PTR tv241[rsp], r10d
  004f2	41 bb 01 00 00
	00		 mov	 r11d, 1
  004f8	4d 6b db 01	 imul	 r11, r11, 1
  004fc	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR f4dscb$[rsp]
  00504	42 0f b6 5c 1b
	6b		 movzx	 ebx, BYTE PTR [rbx+r11+107]
  0050a	41 bb 01 00 00
	00		 mov	 r11d, 1
  00510	4d 6b db 00	 imul	 r11, r11, 0
  00514	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR f4dscb$[rsp]
  0051c	42 0f b6 7c 1f
	6b		 movzx	 edi, BYTE PTR [rdi+r11+107]
  00522	4c 8b 9c 24 90
	01 00 00	 mov	 r11, QWORD PTR cif$[rsp]
  0052a	45 0f b7 5b 78	 movzx	 r11d, WORD PTR [r11+120]
  0052f	44 89 9c 24 ec
	00 00 00	 mov	 DWORD PTR tv256[rsp], r11d
  00537	48 8b b4 24 90
	01 00 00	 mov	 rsi, QWORD PTR cif$[rsp]
  0053f	0f b7 76 74	 movzx	 esi, WORD PTR [rsi+116]
  00543	d1 fe		 sar	 esi, 1
  00545	b9 01 00 00 00	 mov	 ecx, 1
  0054a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00550	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv216[rsp]
  00557	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  0055e	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv221[rsp]
  00565	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  0056c	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv226[rsp]
  00573	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00577	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv231[rsp]
  0057e	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00582	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv236[rsp]
  00589	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0058d	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv241[rsp]
  00594	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00598	89 5c 24 58	 mov	 DWORD PTR [rsp+88], ebx
  0059c	89 7c 24 50	 mov	 DWORD PTR [rsp+80], edi
  005a0	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  005a8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005b0	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv256[rsp]
  005b7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005bb	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  005bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169175
  005c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169176
  005d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169177
  005e9	ba c5 03 00 00	 mov	 edx, 965		; 000003c5H
  005ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169178
  005f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@build_exte:

; 961  :            cif->devblk.devnum, cif->fname,
; 962  :            f4dscb->ds4vtoce.xtbcyl[0], f4dscb->ds4vtoce.xtbcyl[1],
; 963  :            f4dscb->ds4vtoce.xtbtrk[0], f4dscb->ds4vtoce.xtbtrk[1],
; 964  :            f4dscb->ds4vtoce.xtecyl[0], f4dscb->ds4vtoce.xtecyl[1],
; 965  :            f4dscb->ds4vtoce.xtetrk[0], f4dscb->ds4vtoce.xtetrk[1] );
; 966  :     }
; 967  : 
; 968  :     /* Search for the requested dataset in the VTOC */
; 969  :     rc = search_key_equal (cif, dsname, sizeof(dsname),

  005fb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  00603	48 83 c0 69	 add	 rax, 105		; 00000069H
  00607	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR rec$[rsp]
  0060f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00614	48 8d 8c 24 91
	00 00 00	 lea	 rcx, QWORD PTR head$[rsp]
  0061c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00621	48 8d 8c 24 9c
	00 00 00	 lea	 rcx, QWORD PTR cyl$[rsp]
  00629	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0062e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00633	41 b9 01 00 00
	00		 mov	 r9d, 1
  00639	41 b0 2c	 mov	 r8b, 44			; 0000002cH
  0063c	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR dsname$[rsp]
  00644	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0064c	e8 00 00 00 00	 call	 search_key_equal
  00651	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 970  :                             1, &(f4dscb->ds4vtoce),
; 971  :                             &cyl, &head, &rec);
; 972  :     if (rc < 0) return -1;

  00658	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00660	7d 0a		 jge	 SHORT $LN8@build_exte
  00662	b8 ff ff ff ff	 mov	 eax, -1
  00667	e9 b4 07 00 00	 jmp	 $LN1@build_exte
$LN8@build_exte:

; 973  :     if (rc > 0)

  0066c	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00674	0f 8e ac 00 00
	00		 jle	 $LN9@build_exte

; 974  :     {
; 975  :         FWRMSG( stderr, HHC00458, "E", SSID_TO_LCSS(cif->devblk.ssid),

  0067a	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00682	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00686	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv287[rsp], eax
  0068d	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00695	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00699	d1 f9		 sar	 ecx, 1
  0069b	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR tv291[rsp], ecx
  006a2	b9 02 00 00 00	 mov	 ecx, 2
  006a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ad	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR dsnama$[rsp]
  006b5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006ba	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  006c2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006ca	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  006d1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006d5	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  006dc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169181
  006e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169182
  006f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00703	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169183
  0070a	ba d0 03 00 00	 mov	 edx, 976		; 000003d0H
  0070f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169184
  00716	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 976  :             cif->devblk.devnum, cif->fname, dsnama );
; 977  :         return -1;

  0071c	b8 ff ff ff ff	 mov	 eax, -1
  00721	e9 fa 06 00 00	 jmp	 $LN1@build_exte
$LN9@build_exte:

; 978  :     }
; 979  : 
; 980  :     if (is_verbose_util())

  00726	e8 00 00 00 00	 call	 is_verbose_util
  0072b	0f b6 c0	 movzx	 eax, al
  0072e	85 c0		 test	 eax, eax
  00730	0f 84 d3 00 00
	00		 je	 $LN10@build_exte

; 981  :     {
; 982  :        FWRMSG( stdout, HHC00459, "I", SSID_TO_LCSS(cif->devblk.ssid),

  00736	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR rec$[rsp]
  0073e	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv305[rsp], eax
  00745	0f b6 8c 24 91
	00 00 00	 movzx	 ecx, BYTE PTR head$[rsp]
  0074d	89 8c 24 fc 00
	00 00		 mov	 DWORD PTR tv307[rsp], ecx
  00754	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  0075c	0f b7 52 78	 movzx	 edx, WORD PTR [rdx+120]
  00760	89 94 24 00 01
	00 00		 mov	 DWORD PTR tv314[rsp], edx
  00767	48 8b 9c 24 90
	01 00 00	 mov	 rbx, QWORD PTR cif$[rsp]
  0076f	0f b7 5b 74	 movzx	 ebx, WORD PTR [rbx+116]
  00773	d1 fb		 sar	 ebx, 1
  00775	b9 01 00 00 00	 mov	 ecx, 1
  0077a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00780	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv305[rsp]
  00787	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0078b	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv307[rsp]
  00792	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00796	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  0079d	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  007a1	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR dsnama$[rsp]
  007a9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007ae	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  007b6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007b9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007be	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv314[rsp]
  007c5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007c9	89 5c 24 38	 mov	 DWORD PTR [rsp+56], ebx
  007cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169186
  007d4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169187
  007e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007ea	41 b9 03 00 00
	00		 mov	 r9d, 3
  007f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169188
  007f7	ba d7 03 00 00	 mov	 edx, 983		; 000003d7H
  007fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169189
  00803	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@build_exte:

; 983  :            cif->devblk.devnum, cif->fname, dsnama, cyl, head, rec );
; 984  :     }
; 985  : 
; 986  :     /* Read the format 1 DSCB */
; 987  :     rc = read_block (cif, cyl, head, rec,

  00809	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00812	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0081b	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR keylen$[rsp]
  00823	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00828	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR f1dscb$[rsp]
  00830	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00835	44 0f b6 8c 24
	90 00 00 00	 movzx	 r9d, BYTE PTR rec$[rsp]
  0083e	44 0f b6 84 24
	91 00 00 00	 movzx	 r8d, BYTE PTR head$[rsp]
  00847	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  0084e	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00856	e8 00 00 00 00	 call	 read_block
  0085b	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 988  :                     (void *)&f1dscb, &keylen, NULL, NULL);
; 989  :     if (rc < 0) return -1;

  00862	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0086a	7d 0a		 jge	 SHORT $LN11@build_exte
  0086c	b8 ff ff ff ff	 mov	 eax, -1
  00871	e9 aa 05 00 00	 jmp	 $LN1@build_exte
$LN11@build_exte:

; 990  :     if (rc > 0)

  00876	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0087e	0f 8e ab 00 00
	00		 jle	 $LN12@build_exte

; 991  :     {
; 992  :         FWRMSG( stderr, HHC00455, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00884	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0088c	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00890	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv344[rsp], eax
  00897	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0089f	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  008a3	d1 f9		 sar	 ecx, 1
  008a5	89 8c 24 08 01
	00 00		 mov	 DWORD PTR tv348[rsp], ecx
  008ac	b9 02 00 00 00	 mov	 ecx, 2
  008b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169192
  008be	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  008c3	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  008cb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  008ce	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008d3	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv344[rsp]
  008da	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008de	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv348[rsp]
  008e5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169193
  008f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169194
  008fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00901	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00906	41 b9 03 00 00
	00		 mov	 r9d, 3
  0090c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169195
  00913	ba e1 03 00 00	 mov	 edx, 993		; 000003e1H
  00918	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169196
  0091f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 993  :             cif->devblk.devnum, cif->fname, "F1DSCB" );
; 994  :         return -1;

  00925	b8 ff ff ff ff	 mov	 eax, -1
  0092a	e9 f1 04 00 00	 jmp	 $LN1@build_exte
$LN12@build_exte:

; 995  :     }
; 996  : 
; 997  :     /* Extract number of extents and first 3 extent descriptors */
; 998  :     *noext = f1dscb->ds1noepv;

  0092f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  00937	0f b6 40 3b	 movzx	 eax, BYTE PTR [rax+59]
  0093b	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR noext$[rsp]
  00943	89 01		 mov	 DWORD PTR [rcx], eax

; 999  :     extent[0] = f1dscb->ds1ext1;

  00945	b8 0a 00 00 00	 mov	 eax, 10
  0094a	48 6b c0 00	 imul	 rax, rax, 0
  0094e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00956	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  0095e	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00962	48 8d 72 69	 lea	 rsi, QWORD PTR [rdx+105]
  00966	b9 0a 00 00 00	 mov	 ecx, 10
  0096b	f3 a4		 rep movsb

; 1000 :     extent[1] = f1dscb->ds1ext2;

  0096d	b8 0a 00 00 00	 mov	 eax, 10
  00972	48 6b c0 01	 imul	 rax, rax, 1
  00976	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  0097e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  00986	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  0098a	48 8d 72 73	 lea	 rsi, QWORD PTR [rdx+115]
  0098e	b9 0a 00 00 00	 mov	 ecx, 10
  00993	f3 a4		 rep movsb

; 1001 :     extent[2] = f1dscb->ds1ext3;

  00995	b8 0a 00 00 00	 mov	 eax, 10
  0099a	48 6b c0 02	 imul	 rax, rax, 2
  0099e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  009a6	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  009ae	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  009b2	48 8d 72 7d	 lea	 rsi, QWORD PTR [rdx+125]
  009b6	b9 0a 00 00 00	 mov	 ecx, 10
  009bb	f3 a4		 rep movsb

; 1002 : 
; 1003 :     /* Obtain additional extent descriptors */
; 1004 :     if (f1dscb->ds1noepv > 3)

  009bd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  009c5	0f b6 40 3b	 movzx	 eax, BYTE PTR [rax+59]
  009c9	83 f8 03	 cmp	 eax, 3
  009cc	0f 8e 4c 04 00
	00		 jle	 $LN13@build_exte

; 1005 :     {
; 1006 :         /* Read the format 3 DSCB */
; 1007 :         cyl = (f1dscb->ds1ptrds[0] << 8) | f1dscb->ds1ptrds[1];

  009d2	b8 01 00 00 00	 mov	 eax, 1
  009d7	48 6b c0 00	 imul	 rax, rax, 0
  009db	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  009e3	0f b6 84 01 87
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+135]
  009eb	c1 e0 08	 shl	 eax, 8
  009ee	b9 01 00 00 00	 mov	 ecx, 1
  009f3	48 6b c9 01	 imul	 rcx, rcx, 1
  009f7	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  009ff	0f b6 8c 0a 87
	00 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+135]
  00a07	0b c1		 or	 eax, ecx
  00a09	89 84 24 9c 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax

; 1008 :         head = (f1dscb->ds1ptrds[2] << 8) | f1dscb->ds1ptrds[3];

  00a10	b8 01 00 00 00	 mov	 eax, 1
  00a15	48 6b c0 02	 imul	 rax, rax, 2
  00a19	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00a21	0f b6 84 01 87
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+135]
  00a29	c1 e0 08	 shl	 eax, 8
  00a2c	b9 01 00 00 00	 mov	 ecx, 1
  00a31	48 6b c9 03	 imul	 rcx, rcx, 3
  00a35	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  00a3d	0f b6 8c 0a 87
	00 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+135]
  00a45	0b c1		 or	 eax, ecx
  00a47	88 84 24 91 00
	00 00		 mov	 BYTE PTR head$[rsp], al

; 1009 :         rec = f1dscb->ds1ptrds[4];

  00a4e	b8 01 00 00 00	 mov	 eax, 1
  00a53	48 6b c0 04	 imul	 rax, rax, 4
  00a57	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00a5f	0f b6 84 01 87
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+135]
  00a67	88 84 24 90 00
	00 00		 mov	 BYTE PTR rec$[rsp], al

; 1010 :         rc = read_block (cif, cyl, head, rec,

  00a6e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00a77	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a80	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR keylen$[rsp]
  00a88	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a8d	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR f3dscb$[rsp]
  00a95	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a9a	44 0f b6 8c 24
	90 00 00 00	 movzx	 r9d, BYTE PTR rec$[rsp]
  00aa3	44 0f b6 84 24
	91 00 00 00	 movzx	 r8d, BYTE PTR head$[rsp]
  00aac	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  00ab3	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00abb	e8 00 00 00 00	 call	 read_block
  00ac0	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1011 :                         (void *)&f3dscb, &keylen, NULL, NULL);
; 1012 :         if (rc < 0) return -1;

  00ac7	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00acf	7d 0a		 jge	 SHORT $LN14@build_exte
  00ad1	b8 ff ff ff ff	 mov	 eax, -1
  00ad6	e9 45 03 00 00	 jmp	 $LN1@build_exte
$LN14@build_exte:

; 1013 :         if (rc > 0)

  00adb	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00ae3	0f 8e ab 00 00
	00		 jle	 $LN15@build_exte

; 1014 :         {
; 1015 :             FWRMSG( stderr, HHC00455, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00ae9	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00af1	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00af5	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv415[rsp], eax
  00afc	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00b04	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00b08	d1 f9		 sar	 ecx, 1
  00b0a	89 8c 24 10 01
	00 00		 mov	 DWORD PTR tv419[rsp], ecx
  00b11	b9 02 00 00 00	 mov	 ecx, 2
  00b16	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b1c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169200
  00b23	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b28	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00b30	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00b33	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b38	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv415[rsp]
  00b3f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b43	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv419[rsp]
  00b4a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169201
  00b55	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169202
  00b61	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b66	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b6b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b71	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169203
  00b78	ba f8 03 00 00	 mov	 edx, 1016		; 000003f8H
  00b7d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169204
  00b84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1016 :                 cif->devblk.devnum, cif->fname, "F3DSCB" );
; 1017 :             return -1;

  00b8a	b8 ff ff ff ff	 mov	 eax, -1
  00b8f	e9 8c 02 00 00	 jmp	 $LN1@build_exte
$LN15@build_exte:

; 1018 :         }
; 1019 : 
; 1020 :         /* Extract the next 13 extent descriptors */
; 1021 :         extent[3] = f3dscb->ds3extnt[0];

  00b94	b8 0a 00 00 00	 mov	 eax, 10
  00b99	48 6b c0 00	 imul	 rax, rax, 0
  00b9d	b9 0a 00 00 00	 mov	 ecx, 10
  00ba2	48 6b c9 03	 imul	 rcx, rcx, 3
  00ba6	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00bae	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00bb6	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00bba	48 8d 74 03 04	 lea	 rsi, QWORD PTR [rbx+rax+4]
  00bbf	b9 0a 00 00 00	 mov	 ecx, 10
  00bc4	f3 a4		 rep movsb

; 1022 :         extent[4] = f3dscb->ds3extnt[1];

  00bc6	b8 0a 00 00 00	 mov	 eax, 10
  00bcb	48 6b c0 01	 imul	 rax, rax, 1
  00bcf	b9 0a 00 00 00	 mov	 ecx, 10
  00bd4	48 6b c9 04	 imul	 rcx, rcx, 4
  00bd8	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00be0	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00be8	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00bec	48 8d 74 03 04	 lea	 rsi, QWORD PTR [rbx+rax+4]
  00bf1	b9 0a 00 00 00	 mov	 ecx, 10
  00bf6	f3 a4		 rep movsb

; 1023 :         extent[5] = f3dscb->ds3extnt[2];

  00bf8	b8 0a 00 00 00	 mov	 eax, 10
  00bfd	48 6b c0 02	 imul	 rax, rax, 2
  00c01	b9 0a 00 00 00	 mov	 ecx, 10
  00c06	48 6b c9 05	 imul	 rcx, rcx, 5
  00c0a	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00c12	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00c1a	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00c1e	48 8d 74 03 04	 lea	 rsi, QWORD PTR [rbx+rax+4]
  00c23	b9 0a 00 00 00	 mov	 ecx, 10
  00c28	f3 a4		 rep movsb

; 1024 :         extent[6] = f3dscb->ds3extnt[3];

  00c2a	b8 0a 00 00 00	 mov	 eax, 10
  00c2f	48 6b c0 03	 imul	 rax, rax, 3
  00c33	b9 0a 00 00 00	 mov	 ecx, 10
  00c38	48 6b c9 06	 imul	 rcx, rcx, 6
  00c3c	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00c44	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00c4c	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00c50	48 8d 74 03 04	 lea	 rsi, QWORD PTR [rbx+rax+4]
  00c55	b9 0a 00 00 00	 mov	 ecx, 10
  00c5a	f3 a4		 rep movsb

; 1025 :         extent[7] = f3dscb->ds3adext[0];

  00c5c	b8 0a 00 00 00	 mov	 eax, 10
  00c61	48 6b c0 00	 imul	 rax, rax, 0
  00c65	b9 0a 00 00 00	 mov	 ecx, 10
  00c6a	48 6b c9 07	 imul	 rcx, rcx, 7
  00c6e	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00c76	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00c7e	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00c82	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00c87	b9 0a 00 00 00	 mov	 ecx, 10
  00c8c	f3 a4		 rep movsb

; 1026 :         extent[8] = f3dscb->ds3adext[1];

  00c8e	b8 0a 00 00 00	 mov	 eax, 10
  00c93	48 6b c0 01	 imul	 rax, rax, 1
  00c97	b9 0a 00 00 00	 mov	 ecx, 10
  00c9c	48 6b c9 08	 imul	 rcx, rcx, 8
  00ca0	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00ca8	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00cb0	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00cb4	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00cb9	b9 0a 00 00 00	 mov	 ecx, 10
  00cbe	f3 a4		 rep movsb

; 1027 :         extent[9] = f3dscb->ds3adext[2];

  00cc0	b8 0a 00 00 00	 mov	 eax, 10
  00cc5	48 6b c0 02	 imul	 rax, rax, 2
  00cc9	b9 0a 00 00 00	 mov	 ecx, 10
  00cce	48 6b c9 09	 imul	 rcx, rcx, 9
  00cd2	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00cda	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00ce2	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00ce6	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00ceb	b9 0a 00 00 00	 mov	 ecx, 10
  00cf0	f3 a4		 rep movsb

; 1028 :         extent[10] = f3dscb->ds3adext[3];

  00cf2	b8 0a 00 00 00	 mov	 eax, 10
  00cf7	48 6b c0 03	 imul	 rax, rax, 3
  00cfb	b9 0a 00 00 00	 mov	 ecx, 10
  00d00	48 6b c9 0a	 imul	 rcx, rcx, 10
  00d04	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00d0c	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00d14	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00d18	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00d1d	b9 0a 00 00 00	 mov	 ecx, 10
  00d22	f3 a4		 rep movsb

; 1029 :         extent[11] = f3dscb->ds3adext[4];

  00d24	b8 0a 00 00 00	 mov	 eax, 10
  00d29	48 6b c0 04	 imul	 rax, rax, 4
  00d2d	b9 0a 00 00 00	 mov	 ecx, 10
  00d32	48 6b c9 0b	 imul	 rcx, rcx, 11
  00d36	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00d3e	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00d46	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00d4a	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00d4f	b9 0a 00 00 00	 mov	 ecx, 10
  00d54	f3 a4		 rep movsb

; 1030 :         extent[12] = f3dscb->ds3adext[5];

  00d56	b8 0a 00 00 00	 mov	 eax, 10
  00d5b	48 6b c0 05	 imul	 rax, rax, 5
  00d5f	b9 0a 00 00 00	 mov	 ecx, 10
  00d64	48 6b c9 0c	 imul	 rcx, rcx, 12
  00d68	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00d70	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00d78	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00d7c	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00d81	b9 0a 00 00 00	 mov	 ecx, 10
  00d86	f3 a4		 rep movsb

; 1031 :         extent[13] = f3dscb->ds3adext[6];

  00d88	b8 0a 00 00 00	 mov	 eax, 10
  00d8d	48 6b c0 06	 imul	 rax, rax, 6
  00d91	b9 0a 00 00 00	 mov	 ecx, 10
  00d96	48 6b c9 0d	 imul	 rcx, rcx, 13
  00d9a	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00da2	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00daa	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00dae	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00db3	b9 0a 00 00 00	 mov	 ecx, 10
  00db8	f3 a4		 rep movsb

; 1032 :         extent[14] = f3dscb->ds3adext[7];

  00dba	b8 0a 00 00 00	 mov	 eax, 10
  00dbf	48 6b c0 07	 imul	 rax, rax, 7
  00dc3	b9 0a 00 00 00	 mov	 ecx, 10
  00dc8	48 6b c9 0e	 imul	 rcx, rcx, 14
  00dcc	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00dd4	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00ddc	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00de0	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00de5	b9 0a 00 00 00	 mov	 ecx, 10
  00dea	f3 a4		 rep movsb

; 1033 :         extent[15] = f3dscb->ds3adext[8];

  00dec	b8 0a 00 00 00	 mov	 eax, 10
  00df1	48 6b c0 08	 imul	 rax, rax, 8
  00df5	b9 0a 00 00 00	 mov	 ecx, 10
  00dfa	48 6b c9 0f	 imul	 rcx, rcx, 15
  00dfe	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00e06	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR f3dscb$[rsp]
  00e0e	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00e12	48 8d 74 03 2d	 lea	 rsi, QWORD PTR [rbx+rax+45]
  00e17	b9 0a 00 00 00	 mov	 ecx, 10
  00e1c	f3 a4		 rep movsb
$LN13@build_exte:

; 1034 :     }
; 1035 : 
; 1036 :     return 0;

  00e1e	33 c0		 xor	 eax, eax
$LN1@build_exte:

; 1037 : } /* end function build_extent_array */

  00e20	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00e28	48 33 cc	 xor	 rcx, rsp
  00e2b	e8 00 00 00 00	 call	 __security_check_cookie
  00e30	48 81 c4 70 01
	00 00		 add	 rsp, 368		; 00000170H
  00e37	5f		 pop	 rdi
  00e38	5e		 pop	 rsi
  00e39	5b		 pop	 rbx
  00e3a	c3		 ret	 0
build_extent_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
unitstat$ = 96
dev$ = 104
tv77 = 112
tv81 = 116
trk$ = 120
rc$ = 124
tv140 = 128
tv145 = 132
tv149 = 136
cif$ = 160
close_ckd_image PROC

; 759  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 760  : int             rc;                     /* Return code               */
; 761  : U32             trk;                    /* Track number              */
; 762  : DEVBLK         *dev;                    /* -> CKD device block       */
; 763  : BYTE            unitstat;               /* Unit status               */
; 764  : 
; 765  :     dev = &cif->devblk;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00014	48 83 c0 30	 add	 rax, 48			; 00000030H
  00018	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax

; 766  : 
; 767  :     /* Write the last track if modified */
; 768  :     if (cif->trkmodif)

  0001d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00025	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00029	0f 84 cf 01 00
	00		 je	 $LN2@close_ckd_

; 769  :     {
; 770  :         if (is_verbose_util()) /* Issue progress message */

  0002f	e8 00 00 00 00	 call	 is_verbose_util
  00034	0f b6 c0	 movzx	 eax, al
  00037	85 c0		 test	 eax, eax
  00039	0f 84 a7 00 00
	00		 je	 $LN3@close_ckd_

; 771  :             FWRMSG( stdout, HHC00445, "I", SSID_TO_LCSS(cif->devblk.ssid),

  0003f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00047	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  0004b	89 44 24 70	 mov	 DWORD PTR tv77[rsp], eax
  0004f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00057	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  0005b	d1 f9		 sar	 ecx, 1
  0005d	89 4c 24 74	 mov	 DWORD PTR tv81[rsp], ecx
  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00074	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  00077	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0007b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00083	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00086	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0008a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00092	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00095	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0009a	8b 4c 24 70	 mov	 ecx, DWORD PTR tv77[rsp]
  0009e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000a2	8b 4c 24 74	 mov	 ecx, DWORD PTR tv81[rsp]
  000a6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169060
  000b1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169061
  000bd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169062
  000d4	ba 04 03 00 00	 mov	 edx, 772		; 00000304H
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169063
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@close_ckd_:

; 772  :                 cif->devblk.devnum, cif->fname, cif->curcyl, cif->curhead );
; 773  :         trk = (cif->curcyl * cif->heads) + cif->curhead;

  000e6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  000ee	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000f6	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000f9	0f af 41 24	 imul	 eax, DWORD PTR [rcx+36]
  000fd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00105	03 41 1c	 add	 eax, DWORD PTR [rcx+28]
  00108	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax

; 774  :         rc = (dev->hnd->write)(dev, trk, 0, NULL, cif->trksz, &unitstat);

  0010c	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00111	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00118	48 8d 4c 24 60	 lea	 rcx, QWORD PTR unitstat$[rsp]
  0011d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00122	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0012a	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  0012d	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00131	45 33 c9	 xor	 r9d, r9d
  00134	45 33 c0	 xor	 r8d, r8d
  00137	8b 54 24 78	 mov	 edx, DWORD PTR trk$[rsp]
  0013b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00140	ff 50 58	 call	 QWORD PTR [rax+88]
  00143	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 775  :         if (rc < 0)

  00147	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0014c	0f 8d ac 00 00
	00		 jge	 $LN4@close_ckd_

; 776  :         {
; 777  :             FWRMSG( stderr, HHC00446, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00152	0f b6 44 24 60	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00157	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv140[rsp], eax
  0015e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00166	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  0016a	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv145[rsp], ecx
  00171	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  00179	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  0017d	d1 fa		 sar	 edx, 1
  0017f	89 94 24 88 00
	00 00		 mov	 DWORD PTR tv149[rsp], edx
  00186	b9 02 00 00 00	 mov	 ecx, 2
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00191	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv140[rsp]
  00198	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0019c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  001a4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001a7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ac	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  001b3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001b7	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  001be	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169065
  001c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169066
  001d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001df	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169067
  001ec	ba 0a 03 00 00	 mov	 edx, 778		; 0000030aH
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169068
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@close_ckd_:
$LN2@close_ckd_:

; 778  :                 cif->devblk.devnum, cif->fname, unitstat );
; 779  :         }
; 780  :     }
; 781  : 
; 782  :     /* Call the END exit */
; 783  :     if (dev->hnd->end) (dev->hnd->end) (dev);

  001fe	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00203	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0020a	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0020f	74 14		 je	 SHORT $LN5@close_ckd_
  00211	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00216	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0021d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00222	ff 50 30	 call	 QWORD PTR [rax+48]
$LN5@close_ckd_:

; 784  : 
; 785  :     /* Close the CKD image file */
; 786  :     (dev->hnd->close)(dev);

  00225	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00231	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00236	ff 50 10	 call	 QWORD PTR [rax+16]

; 787  : 
; 788  :     /* Release the file descriptor structure */
; 789  :     free (cif);

  00239	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 790  : 
; 791  :     return 0;

  00247	33 c0		 xor	 eax, eax

; 792  : } /* end function close_ckd_image */

  00249	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00250	c3		 ret	 0
close_ckd_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
cif$ = 96
dev$ = 104
argc$ = 112
tv145 = 116
tv154 = 120
tv82 = 124
tv86 = 128
tv169 = 132
tv173 = 136
rc$ = 140
tv209 = 144
tv213 = 148
tv241 = 152
tv245 = 156
fba$ = 160
tv206 = 168
tv71 = 176
argv$ = 184
buf$1 = 200
__$ArrayPad$ = 240
fname$ = 272
sfname$ = 280
omode$ = 288
option$ = 296
open_fba_image PROC

; 809  : {

$LN15:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 810  : int             rc;                     /* Return code               */
; 811  : CIFBLK         *cif;                    /* FBA image file descriptor */
; 812  : DEVBLK         *dev;                    /* FBA device block          */
; 813  : FBADEV         *fba;                    /* FBA DASD table entry      */
; 814  : char           *argv[2];                /* Arguments to              */
; 815  : int             argc=0;                 /*  device open              */

  0002d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR argc$[rsp], 0

; 816  : 
; 817  :     /* Obtain storage for the file descriptor structure */
; 818  :     cif = (CIFBLK*) calloc( 1, sizeof(CIFBLK) );

  00035	ba d0 1b 00 00	 mov	 edx, 7120		; 00001bd0H
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00045	48 89 44 24 60	 mov	 QWORD PTR cif$[rsp], rax

; 819  :     if (cif == NULL)

  0004a	48 83 7c 24 60
	00		 cmp	 QWORD PTR cif$[rsp], 0
  00050	0f 85 dd 00 00
	00		 jne	 $LN2@open_fba_i

; 820  :     {
; 821  :         char buf[40];
; 822  :         MSGBUF(buf, "calloc(1,%d)", (int)sizeof(CIFBLK));

  00056	41 b9 d0 1b 00
	00		 mov	 r9d, 7120		; 00001bd0H
  0005c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169100
  00063	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00068	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 823  :         FWRMSG( stderr, HHC00404, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0007c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00084	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv71[rsp], rax
  0008c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00091	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  00095	89 4c 24 7c	 mov	 DWORD PTR tv82[rsp], ecx
  00099	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  0009e	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  000a2	d1 fa		 sar	 edx, 1
  000a4	89 94 24 80 00
	00 00		 mov	 DWORD PTR tv86[rsp], edx
  000ab	b9 02 00 00 00	 mov	 ecx, 2
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv71[rsp]
  000be	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000c3	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  000cb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000d0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000d8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000dd	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv82[rsp]
  000e1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e5	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  000ec	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169101
  000f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169102
  00103	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00108	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00113	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169103
  0011a	ba 38 03 00 00	 mov	 edx, 824		; 00000338H
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169104
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 824  :             cif->devblk.devnum, fname, buf, strerror( errno ));
; 825  :         return NULL;

  0012c	33 c0		 xor	 eax, eax
  0012e	e9 85 04 00 00	 jmp	 $LN1@open_fba_i
$LN2@open_fba_i:

; 826  :     }
; 827  : 
; 828  :     /* Initialize the devblk */
; 829  :     dev = &cif->devblk;

  00133	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00138	48 83 c0 30	 add	 rax, 48			; 00000030H
  0013c	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax

; 830  :     dev->cckd64 = 0;

  00141	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00146	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0014d	24 fe		 and	 al, 254			; 000000feH
  0014f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00154	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 831  :     if ((omode & O_RDWR) == 0) dev->ckdrdonly = 1;

  0015a	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR omode$[rsp]
  00161	83 e0 02	 and	 eax, 2
  00164	85 c0		 test	 eax, eax
  00166	75 1a		 jne	 SHORT $LN3@open_fba_i
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0016d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00173	0f ba e8 12	 bts	 eax, 18
  00177	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0017c	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN3@open_fba_i:

; 832  :     dev->fd = -1;

  00182	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00187	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 833  :     dev->batch = 1;

  00191	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00196	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0019c	0f ba e8 0a	 bts	 eax, 10
  001a0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001a5	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 834  :     dev->dasdcopy  = (option & IMAGE_OPEN_DASDCOPY) ? 1 : 0;

  001ab	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR option$[rsp]
  001b2	83 e0 01	 and	 eax, 1
  001b5	85 c0		 test	 eax, eax
  001b7	74 0a		 je	 SHORT $LN9@open_fba_i
  001b9	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  001c1	eb 08		 jmp	 SHORT $LN10@open_fba_i
$LN9@open_fba_i:
  001c3	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN10@open_fba_i:
  001cb	8b 44 24 74	 mov	 eax, DWORD PTR tv145[rsp]
  001cf	83 e0 01	 and	 eax, 1
  001d2	c1 e0 0b	 shl	 eax, 11
  001d5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001da	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  001e0	0f ba f1 0b	 btr	 ecx, 11
  001e4	0b c8		 or	 ecx, eax
  001e6	8b c1		 mov	 eax, ecx
  001e8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001ed	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 835  :     dev->quiet     = (option & IMAGE_OPEN_QUIET)    ? 1 : 0;

  001f3	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR option$[rsp]
  001fa	83 e0 02	 and	 eax, 2
  001fd	85 c0		 test	 eax, eax
  001ff	74 0a		 je	 SHORT $LN11@open_fba_i
  00201	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  00209	eb 08		 jmp	 SHORT $LN12@open_fba_i
$LN11@open_fba_i:
  0020b	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN12@open_fba_i:
  00213	8b 44 24 78	 mov	 eax, DWORD PTR tv154[rsp]
  00217	83 e0 01	 and	 eax, 1
  0021a	c1 e0 0c	 shl	 eax, 12
  0021d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00222	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  00228	0f ba f1 0c	 btr	 ecx, 12
  0022c	0b c8		 or	 ecx, eax
  0022e	8b c1		 mov	 eax, ecx
  00230	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00235	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 836  : 
; 837  :     /* Set the device type */
; 838  :     fba = dasd_lookup (DASD_FBADEV, NULL, DEFAULT_FBA_TYPE, 0);

  0023b	45 33 c9	 xor	 r9d, r9d
  0023e	41 b8 70 33 00
	00		 mov	 r8d, 13168		; 00003370H
  00244	33 d2		 xor	 edx, edx
  00246	b9 03 00 00 00	 mov	 ecx, 3
  0024b	e8 00 00 00 00	 call	 dasd_lookup
  00250	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR fba$[rsp], rax

; 839  :     if (fba == NULL)

  00258	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR fba$[rsp], 0
  00261	0f 85 a6 00 00
	00		 jne	 $LN4@open_fba_i

; 840  :     {
; 841  :         FWRMSG( stderr, HHC00451, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00267	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  0026c	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00270	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv169[rsp], eax
  00277	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0027c	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00280	d1 f9		 sar	 ecx, 1
  00282	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv173[rsp], ecx
  00289	b9 02 00 00 00	 mov	 ecx, 2
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00294	c7 44 24 50 70
	33 00 00	 mov	 DWORD PTR [rsp+80], 13168 ; 00003370H
  0029c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  002a4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002a9	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv169[rsp]
  002b0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002b4	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv173[rsp]
  002bb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169107
  002c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169108
  002d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169109
  002e9	ba 4a 03 00 00	 mov	 edx, 842		; 0000034aH
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169110
  002f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 842  :             cif->devblk.devnum, fname, DEFAULT_FBA_TYPE );
; 843  :         free (cif);

  002fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 844  :         return NULL;

  00306	33 c0		 xor	 eax, eax
  00308	e9 ab 02 00 00	 jmp	 $LN1@open_fba_i
$LN4@open_fba_i:

; 845  :     }
; 846  :     dev->devtype = fba->devt;

  0030d	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00312	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fba$[rsp]
  0031a	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  0031e	66 89 48 4a	 mov	 WORD PTR [rax+74], cx

; 847  : 
; 848  :     /* Set the device handlers */
; 849  :     dev->hnd = &fba_dasd_device_hndinfo;

  00322	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fba_dasd_device_hndinfo
  0032e	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx

; 850  : 
; 851  :     /* Set the device number */
; 852  :     dev->devnum = next_util_devnum();

  00335	e8 00 00 00 00	 call	 next_util_devnum
  0033a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0033f	66 89 41 48	 mov	 WORD PTR [rcx+72], ax

; 853  : 
; 854  :     /* Build arguments for fba_dasd_init_handler */
; 855  :     argv[0] = fname;

  00343	b8 08 00 00 00	 mov	 eax, 8
  00348	48 6b c0 00	 imul	 rax, rax, 0
  0034c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00354	48 89 8c 04 b8
	00 00 00	 mov	 QWORD PTR argv$[rsp+rax], rcx

; 856  :     argc++;

  0035c	8b 44 24 70	 mov	 eax, DWORD PTR argc$[rsp]
  00360	ff c0		 inc	 eax
  00362	89 44 24 70	 mov	 DWORD PTR argc$[rsp], eax

; 857  :     if (sfname != NULL)

  00366	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR sfname$[rsp], 0
  0036f	74 23		 je	 SHORT $LN5@open_fba_i

; 858  :     {
; 859  :         argv[1] = sfname;

  00371	b8 08 00 00 00	 mov	 eax, 8
  00376	48 6b c0 01	 imul	 rax, rax, 1
  0037a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR sfname$[rsp]
  00382	48 89 8c 04 b8
	00 00 00	 mov	 QWORD PTR argv$[rsp+rax], rcx

; 860  :         argc++;

  0038a	8b 44 24 70	 mov	 eax, DWORD PTR argc$[rsp]
  0038e	ff c0		 inc	 eax
  00390	89 44 24 70	 mov	 DWORD PTR argc$[rsp], eax
$LN5@open_fba_i:

; 861  :     }
; 862  : 
; 863  :     /* Call the device handler initialization function */
; 864  :     rc = (dev->hnd->init)(dev, argc, argv);

  00394	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00399	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  003a0	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR argv$[rsp]
  003a8	8b 54 24 70	 mov	 edx, DWORD PTR argc$[rsp]
  003ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  003b1	ff 10		 call	 QWORD PTR [rax]
  003b3	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 865  :     if (rc < 0)

  003ba	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  003c2	0f 8d ca 00 00
	00		 jge	 $LN6@open_fba_i

; 866  :     {
; 867  :         // "%1d:%04X CKD file %s: initialization failed"
; 868  :         FWRMSG( stderr, HHC00452, "E", SSID_TO_LCSS(cif->devblk.ssid),

  003c8	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  003d1	74 12		 je	 SHORT $LN13@open_fba_i
  003d3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  003db	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
  003e3	eb 0f		 jmp	 SHORT $LN14@open_fba_i
$LN13@open_fba_i:
  003e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169113
  003ec	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
$LN14@open_fba_i:
  003f4	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  003f9	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  003fd	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv209[rsp], eax
  00404	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00409	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  0040d	d1 f9		 sar	 ecx, 1
  0040f	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv213[rsp], ecx
  00416	b9 02 00 00 00	 mov	 ecx, 2
  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00421	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv206[rsp]
  00429	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0042e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv209[rsp]
  00435	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00439	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv213[rsp]
  00440	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00444	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169114
  0044b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00450	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169115
  00457	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0045c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00461	41 b9 03 00 00
	00		 mov	 r9d, 3
  00467	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169116
  0046e	ba 65 03 00 00	 mov	 edx, 869		; 00000365H
  00473	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169117
  0047a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 869  :             cif->devblk.devnum, fname ? fname : "(null)" );
; 870  :         free (cif);

  00480	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 871  :         return NULL;

  0048b	33 c0		 xor	 eax, eax
  0048d	e9 26 01 00 00	 jmp	 $LN1@open_fba_i
$LN6@open_fba_i:

; 872  :     }
; 873  : 
; 874  :     /* Set CIF fields */
; 875  :     cif->fname = fname;

  00492	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00497	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0049f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 876  :     cif->fd = dev->fd;

  004a2	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  004a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  004ac	8b 89 ac 01 00
	00		 mov	 ecx, DWORD PTR [rcx+428]
  004b2	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 877  : 
; 878  :     /* Extract the number of sectors and the sector size */
; 879  :     cif->heads = dev->fbanumblk;

  004b5	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  004ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  004bf	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  004c5	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 880  :     cif->trksz = dev->fbablksiz;

  004c8	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  004cd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  004d2	8b 89 8c 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4492]
  004d8	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 881  :     if (is_verbose_util())

  004db	e8 00 00 00 00	 call	 is_verbose_util
  004e0	0f b6 c0	 movzx	 eax, al
  004e3	85 c0		 test	 eax, eax
  004e5	0f 84 a4 00 00
	00		 je	 $LN7@open_fba_i

; 882  :     {
; 883  :        FWRMSG( stdout, HHC00454, "I", SSID_TO_LCSS(cif->devblk.ssid),

  004eb	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  004f0	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  004f4	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv241[rsp], eax
  004fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00500	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00504	d1 f9		 sar	 ecx, 1
  00506	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv245[rsp], ecx
  0050d	b9 01 00 00 00	 mov	 ecx, 1
  00512	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00518	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0051d	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00520	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00524	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00529	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  0052c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00530	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00538	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0053d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv241[rsp]
  00544	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00548	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  0054f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00553	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169119
  0055a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169120
  00566	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0056b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00570	41 b9 03 00 00
	00		 mov	 r9d, 3
  00576	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169121
  0057d	ba 74 03 00 00	 mov	 edx, 884		; 00000374H
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169122
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@open_fba_i:

; 884  :            cif->devblk.devnum, fname, cif->heads, cif->trksz );
; 885  :     }
; 886  : 
; 887  :     /* Indicate that the track buffer is empty */
; 888  :     cif->curcyl = -1;

  0058f	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00594	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1	; ffffffffH

; 889  :     cif->curhead = -1;

  0059b	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  005a0	c7 40 1c ff ff
	ff ff		 mov	 DWORD PTR [rax+28], -1	; ffffffffH

; 890  :     cif->trkmodif = 0;

  005a7	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  005ac	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 891  : 
; 892  :     return cif;

  005b3	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
$LN1@open_fba_i:

; 893  : } /* end function open_fba_image */

  005b8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c0	48 33 cc	 xor	 rcx, rsp
  005c3	e8 00 00 00 00	 call	 __security_check_cookie
  005c8	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  005cf	c3		 ret	 0
open_fba_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
cif$ = 96
dev$ = 104
fd$ = 112
i$1 = 116
argc$ = 120
s$2 = 128
tv145 = 136
tv154 = 140
iLen$ = 144
p$3 = 152
rmtdev$ = 160
tv291 = 168
tv328 = 172
tv332 = 176
tv351 = 180
tv356 = 184
tv360 = 188
rc$ = 192
tv405 = 196
tv409 = 200
tv449 = 204
tv453 = 208
tv82 = 212
tv86 = 216
tv253 = 220
tv257 = 224
tv287 = 228
suffix$4 = 232
ckd$ = 240
tv402 = 248
tv71 = 256
tv245 = 264
tv279 = 272
argv$ = 280
devhdr$ = 304
buf$5 = 816
typname$ = 864
sfxname$ = 928
pathname$ = 1456
__$ArrayPad$ = 1728
fname$ = 1760
sfname$ = 1768
omode$ = 1776
option$ = 1784
open_ckd_image PROC

; 543  : {

$LN38:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 06
	00 00		 sub	 rsp, 1752		; 000006d8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 c0
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 544  : int             fd;                     /* File descriptor           */
; 545  : int             rc;                     /* Return code               */
; 546  : int             iLen;                   /* Record length             */
; 547  : CKD_DEVHDR      devhdr;                 /* CKD device header         */
; 548  : CIFBLK         *cif;                    /* CKD image file descriptor */
; 549  : DEVBLK         *dev;                    /* CKD device block          */
; 550  : CKDDEV         *ckd;                    /* CKD DASD table entry      */
; 551  : char           *rmtdev;                 /* Possible remote device    */
; 552  : char           *argv[2];                /* Arguments to              */
; 553  : int             argc=0;                 /*                           */

  0002d	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR argc$[rsp], 0

; 554  : char            sfxname[FILENAME_MAX*2];/* Suffixed file name        */
; 555  : char            typname[64];
; 556  : char            pathname[MAX_PATH];     /* file path in host format  */
; 557  : 
; 558  :     /* Obtain storage for the file descriptor structure */
; 559  :     cif = (CIFBLK*) calloc (1,sizeof(CIFBLK));

  00035	ba d0 1b 00 00	 mov	 edx, 7120		; 00001bd0H
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00045	48 89 44 24 60	 mov	 QWORD PTR cif$[rsp], rax

; 560  :     if (cif == NULL)

  0004a	48 83 7c 24 60
	00		 cmp	 QWORD PTR cif$[rsp], 0
  00050	0f 85 e3 00 00
	00		 jne	 $LN5@open_ckd_i

; 561  :     {
; 562  :         char buf[40];
; 563  :         MSGBUF(buf, "calloc(1,%d)", (int)sizeof(CIFBLK));

  00056	41 b9 d0 1b 00
	00		 mov	 r9d, 7120		; 00001bd0H
  0005c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168989
  00063	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00068	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 564  :         FWRMSG( stderr, HHC00404, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0007c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00084	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv71[rsp], rax
  0008c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00091	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  00095	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv82[rsp], ecx
  0009c	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  000a1	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  000a5	d1 fa		 sar	 edx, 1
  000a7	89 94 24 d8 00
	00 00		 mov	 DWORD PTR tv86[rsp], edx
  000ae	b9 02 00 00 00	 mov	 ecx, 2
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv71[rsp]
  000c1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000c6	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  000ce	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000d3	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000db	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e0	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  000e7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000eb	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  000f2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168990
  000fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168991
  00109	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00113	41 b9 03 00 00
	00		 mov	 r9d, 3
  00119	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168992
  00120	ba 35 02 00 00	 mov	 edx, 565		; 00000235H
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168993
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 565  :             cif->devblk.devnum, fname, buf, strerror( errno ));
; 566  :         return NULL;

  00132	33 c0		 xor	 eax, eax
  00134	e9 34 0b 00 00	 jmp	 $LN1@open_ckd_i
$LN5@open_ckd_i:

; 567  :     }
; 568  : 
; 569  :     /* Initialize the devblk */
; 570  :     dev = &cif->devblk;

  00139	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  0013e	48 83 c0 30	 add	 rax, 48			; 00000030H
  00142	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax

; 571  :     dev->cckd64 = 0;

  00147	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00153	24 fe		 and	 al, 254			; 000000feH
  00155	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0015a	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 572  :     if ((omode & O_RDWR) == 0) dev->ckdrdonly = 1;

  00160	8b 84 24 f0 06
	00 00		 mov	 eax, DWORD PTR omode$[rsp]
  00167	83 e0 02	 and	 eax, 2
  0016a	85 c0		 test	 eax, eax
  0016c	75 1a		 jne	 SHORT $LN6@open_ckd_i
  0016e	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00173	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00179	0f ba e8 12	 bts	 eax, 18
  0017d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00182	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN6@open_ckd_i:

; 573  :     dev->fd = -1;

  00188	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0018d	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 574  :     dev->batch = 1;

  00197	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0019c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001a2	0f ba e8 0a	 bts	 eax, 10
  001a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001ab	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 575  :     dev->dasdcopy  = (option & IMAGE_OPEN_DASDCOPY) ? 1 : 0;

  001b1	8b 84 24 f8 06
	00 00		 mov	 eax, DWORD PTR option$[rsp]
  001b8	83 e0 01	 and	 eax, 1
  001bb	85 c0		 test	 eax, eax
  001bd	74 0d		 je	 SHORT $LN32@open_ckd_i
  001bf	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv145[rsp], 1
  001ca	eb 0b		 jmp	 SHORT $LN33@open_ckd_i
$LN32@open_ckd_i:
  001cc	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN33@open_ckd_i:
  001d7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv145[rsp]
  001de	83 e0 01	 and	 eax, 1
  001e1	c1 e0 0b	 shl	 eax, 11
  001e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001e9	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  001ef	0f ba f1 0b	 btr	 ecx, 11
  001f3	0b c8		 or	 ecx, eax
  001f5	8b c1		 mov	 eax, ecx
  001f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001fc	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 576  :     dev->quiet     = (option & IMAGE_OPEN_QUIET)    ? 1 : 0;

  00202	8b 84 24 f8 06
	00 00		 mov	 eax, DWORD PTR option$[rsp]
  00209	83 e0 02	 and	 eax, 2
  0020c	85 c0		 test	 eax, eax
  0020e	74 0d		 je	 SHORT $LN34@open_ckd_i
  00210	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv154[rsp], 1
  0021b	eb 0b		 jmp	 SHORT $LN35@open_ckd_i
$LN34@open_ckd_i:
  0021d	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv154[rsp], 0
$LN35@open_ckd_i:
  00228	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv154[rsp]
  0022f	83 e0 01	 and	 eax, 1
  00232	c1 e0 0c	 shl	 eax, 12
  00235	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0023a	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  00240	0f ba f1 0c	 btr	 ecx, 12
  00244	0b c8		 or	 ecx, eax
  00246	8b c1		 mov	 eax, ecx
  00248	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0024d	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 577  : 
; 578  :     /* If the filename has a `:' then it may be a remote device */
; 579  :     if ((rmtdev = strchr(fname, ':')))

  00253	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  00258	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00260	e8 00 00 00 00	 call	 strchr
  00265	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rmtdev$[rsp], rax
  0026d	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rmtdev$[rsp], 0
  00276	74 6e		 je	 SHORT $LN7@open_ckd_i

; 580  :     {
; 581  :         /* Verify port number follows colon */
; 582  :         char *p;
; 583  :         for (p = rmtdev + 1; *p && *p != ':'; p++)

  00278	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rmtdev$[rsp]
  00280	48 ff c0	 inc	 rax
  00283	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$3[rsp], rax
  0028b	eb 13		 jmp	 SHORT $LN4@open_ckd_i
$LN2@open_ckd_i:
  0028d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$3[rsp]
  00295	48 ff c0	 inc	 rax
  00298	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$3[rsp], rax
$LN4@open_ckd_i:
  002a0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$3[rsp]
  002a8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ab	85 c0		 test	 eax, eax
  002ad	74 37		 je	 SHORT $LN3@open_ckd_i
  002af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$3[rsp]
  002b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ba	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  002bd	74 27		 je	 SHORT $LN3@open_ckd_i

; 584  :         {
; 585  :             if (!isdigit(*p))  /* (port numbers are always numeric) */

  002bf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$3[rsp]
  002c7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ca	8b c8		 mov	 ecx, eax
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  002d2	85 c0		 test	 eax, eax
  002d4	75 0e		 jne	 SHORT $LN8@open_ckd_i

; 586  :             {
; 587  :                 /* Not a port number ==> not really a remote device */
; 588  :                 rmtdev = NULL;

  002d6	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rmtdev$[rsp], 0

; 589  :                 break;

  002e2	eb 02		 jmp	 SHORT $LN3@open_ckd_i
$LN8@open_ckd_i:

; 590  :             }
; 591  :         }

  002e4	eb a7		 jmp	 SHORT $LN2@open_ckd_i
$LN3@open_ckd_i:
$LN7@open_ckd_i:

; 592  :     }
; 593  : 
; 594  :     /* Read the device header so we can determine the device type */
; 595  :     STRLCPY( sfxname, fname );

  002e6	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  002ec	48 8b 94 24 e0
	06 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  002f4	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 596  :     hostpath(pathname, sfxname, sizeof(pathname));

  00302	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00308	48 8d 94 24 a0
	03 00 00	 lea	 rdx, QWORD PTR sfxname$[rsp]
  00310	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 597  :     fd = HOPEN (pathname, omode);

  0031e	8b 94 24 f0 06
	00 00		 mov	 edx, DWORD PTR omode$[rsp]
  00325	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00333	89 44 24 70	 mov	 DWORD PTR fd$[rsp], eax

; 598  :     if (fd < 0)

  00337	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  0033c	0f 8d de 02 00
	00		 jge	 $LN9@open_ckd_i

; 599  :     {
; 600  :         /* If no shadow file name was specified, then try opening the
; 601  :            file with the file sequence number in the name */
; 602  :         if (sfname == NULL)

  00342	48 83 bc 24 e8
	06 00 00 00	 cmp	 QWORD PTR sfname$[rsp], 0
  0034b	0f 85 c3 01 00
	00		 jne	 $LN10@open_ckd_i

; 603  :         {
; 604  :             int i;
; 605  :             char *s,*suffix;
; 606  : 
; 607  :             /* Look for last slash marking end of directory name */
; 608  :             s = strrchr (fname, PATHSEPC);

  00351	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00356	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0035e	e8 00 00 00 00	 call	 strrchr
  00363	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$2[rsp], rax

; 609  :             if (s == NULL) s = fname;

  0036b	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR s$2[rsp], 0
  00374	75 10		 jne	 SHORT $LN11@open_ckd_i
  00376	48 8b 84 24 e0
	06 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  0037e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$2[rsp], rax
$LN11@open_ckd_i:

; 610  : 
; 611  :             /* Insert suffix before first dot in file name, or
; 612  :                append suffix to file name if there is no dot.
; 613  :                If the filename already has a place for the suffix
; 614  :                then use that. */
; 615  :             s = strchr (s, '.');

  00386	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  0038b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$2[rsp]
  00393	e8 00 00 00 00	 call	 strchr
  00398	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$2[rsp], rax

; 616  :             if (s != NULL)

  003a0	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR s$2[rsp], 0
  003a9	0f 84 c0 00 00
	00		 je	 $LN12@open_ckd_i

; 617  :             {
; 618  :                 i = (int)(s - fname);

  003af	48 8b 84 24 e0
	06 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  003b7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$2[rsp]
  003bf	48 2b c8	 sub	 rcx, rax
  003c2	48 8b c1	 mov	 rax, rcx
  003c5	89 44 24 74	 mov	 DWORD PTR i$1[rsp], eax

; 619  :                 if (i > 2 && fname[i-2] == '_')

  003c9	83 7c 24 74 02	 cmp	 DWORD PTR i$1[rsp], 2
  003ce	7e 31		 jle	 SHORT $LN14@open_ckd_i
  003d0	8b 44 24 74	 mov	 eax, DWORD PTR i$1[rsp]
  003d4	83 e8 02	 sub	 eax, 2
  003d7	48 98		 cdqe
  003d9	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  003e1	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  003e5	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  003e8	75 17		 jne	 SHORT $LN14@open_ckd_i

; 620  :                     suffix = sfxname + i - 1;

  003ea	48 63 44 24 74	 movsxd	 rax, DWORD PTR i$1[rsp]
  003ef	48 8d 84 04 9f
	03 00 00	 lea	 rax, QWORD PTR sfxname$[rsp+rax-1]
  003f7	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR suffix$4[rsp], rax
  003ff	eb 6c		 jmp	 SHORT $LN15@open_ckd_i
$LN14@open_ckd_i:

; 621  :                 else
; 622  :                 {
; 623  :                     strlcpy( sfxname + i, "_1", sizeof(sfxname)-(size_t)i );

  00401	48 63 44 24 74	 movsxd	 rax, DWORD PTR i$1[rsp]
  00406	b9 08 02 00 00	 mov	 ecx, 520		; 00000208H
  0040b	48 2b c8	 sub	 rcx, rax
  0040e	48 8b c1	 mov	 rax, rcx
  00411	48 63 4c 24 74	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00416	48 8d 8c 0c a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp+rcx]
  0041e	4c 8b c0	 mov	 r8, rax
  00421	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169004
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 624  :                     STRLCAT( sfxname, fname + i );

  0042e	48 63 44 24 74	 movsxd	 rax, DWORD PTR i$1[rsp]
  00433	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0043b	48 03 c8	 add	 rcx, rax
  0043e	48 8b c1	 mov	 rax, rcx
  00441	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  00447	48 8b d0	 mov	 rdx, rax
  0044a	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  00452	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 625  :                     suffix = sfxname + i + 1;

  00458	48 63 44 24 74	 movsxd	 rax, DWORD PTR i$1[rsp]
  0045d	48 8d 84 04 a1
	03 00 00	 lea	 rax, QWORD PTR sfxname$[rsp+rax+1]
  00465	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR suffix$4[rsp], rax
$LN15@open_ckd_i:

; 626  :                 }
; 627  :             }

  0046d	eb 65		 jmp	 SHORT $LN13@open_ckd_i
$LN12@open_ckd_i:

; 628  :             else
; 629  :             {
; 630  :                 if (strlen(sfxname) < 2 || sfxname[strlen(sfxname)-2] != '_')

  0046f	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  00477	e8 00 00 00 00	 call	 strlen
  0047c	48 83 f8 02	 cmp	 rax, 2
  00480	72 1a		 jb	 SHORT $LN17@open_ckd_i
  00482	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  0048a	e8 00 00 00 00	 call	 strlen
  0048f	0f be 84 04 9e
	03 00 00	 movsx	 eax, BYTE PTR sfxname$[rsp+rax-2]
  00497	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0049a	74 1b		 je	 SHORT $LN16@open_ckd_i
$LN17@open_ckd_i:

; 631  :                     STRLCAT (sfxname, "_1" );

  0049c	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  004a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169007
  004a9	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN16@open_ckd_i:

; 632  :                 suffix = sfxname + strlen(sfxname) - 1;

  004b7	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  004bf	e8 00 00 00 00	 call	 strlen
  004c4	48 8d 84 04 9f
	03 00 00	 lea	 rax, QWORD PTR sfxname$[rsp+rax-1]
  004cc	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR suffix$4[rsp], rax
$LN13@open_ckd_i:

; 633  :             }
; 634  :             *suffix = '1';

  004d4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR suffix$4[rsp]
  004dc	c6 00 31	 mov	 BYTE PTR [rax], 49	; 00000031H

; 635  :             hostpath(pathname, sfxname, sizeof(pathname));

  004df	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  004e5	48 8d 94 24 a0
	03 00 00	 lea	 rdx, QWORD PTR sfxname$[rsp]
  004ed	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 636  :             fd = HOPEN (pathname, omode);

  004fb	8b 94 24 f0 06
	00 00		 mov	 edx, DWORD PTR omode$[rsp]
  00502	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0050a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00510	89 44 24 70	 mov	 DWORD PTR fd$[rsp], eax
$LN10@open_ckd_i:

; 637  :         }
; 638  :         if (fd < 0 && rmtdev == NULL)

  00514	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  00519	0f 8d de 00 00
	00		 jge	 $LN18@open_ckd_i
  0051f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rmtdev$[rsp], 0
  00528	0f 85 cf 00 00
	00		 jne	 $LN18@open_ckd_i

; 639  :         {
; 640  :             FWRMSG( stderr, HHC00404, "E", SSID_TO_LCSS(cif->devblk.ssid),

  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00534	8b 08		 mov	 ecx, DWORD PTR [rax]
  00536	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0053c	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv245[rsp], rax
  00544	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00549	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  0054d	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv253[rsp], ecx
  00554	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  00559	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  0055d	d1 fa		 sar	 edx, 1
  0055f	89 94 24 e0 00
	00 00		 mov	 DWORD PTR tv257[rsp], edx
  00566	b9 02 00 00 00	 mov	 ecx, 2
  0056b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00571	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv245[rsp]
  00579	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0057e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169010
  00585	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0058a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0058f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00592	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00597	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv253[rsp]
  0059e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005a2	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv257[rsp]
  005a9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169011
  005b4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169012
  005c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005ca	41 b9 03 00 00
	00		 mov	 r9d, 3
  005d0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169013
  005d7	ba 81 02 00 00	 mov	 edx, 641		; 00000281H
  005dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169014
  005e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 641  :                 cif->devblk.devnum, cif->fname, "open()", strerror( errno ));
; 642  :             free (cif);

  005e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  005ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 643  :             return NULL;

  005f4	33 c0		 xor	 eax, eax
  005f6	e9 72 06 00 00	 jmp	 $LN1@open_ckd_i

; 644  :         }

  005fb	eb 23		 jmp	 SHORT $LN19@open_ckd_i
$LN18@open_ckd_i:

; 645  :         else if (fd < 0) STRLCPY( sfxname, fname );

  005fd	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  00602	7d 1c		 jge	 SHORT $LN20@open_ckd_i
  00604	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  0060a	48 8b 94 24 e0
	06 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00612	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  0061a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN20@open_ckd_i:
$LN19@open_ckd_i:
$LN9@open_ckd_i:

; 646  :     }
; 647  : 
; 648  :     /* If not a possible remote device, check the dasd header
; 649  :        and set the device type */
; 650  :     if (fd >= 0)

  00620	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  00625	0f 8c 75 03 00
	00		 jl	 $LN21@open_ckd_i

; 651  :     {
; 652  :         iLen = read(fd, &devhdr, CKD_DEVHDR_SIZE);

  0062b	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00631	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  00639	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  0063d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00643	89 84 24 90 00
	00 00		 mov	 DWORD PTR iLen$[rsp], eax

; 653  :         if (iLen < 0)

  0064a	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR iLen$[rsp], 0
  00652	0f 8d d7 00 00
	00		 jge	 $LN22@open_ckd_i

; 654  :         {
; 655  :             FWRMSG( stderr, HHC00404, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00658	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0065e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00660	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00666	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv279[rsp], rax
  0066e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00673	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  00677	89 8c 24 e4 00
	00 00		 mov	 DWORD PTR tv287[rsp], ecx
  0067e	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  00683	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  00687	d1 fa		 sar	 edx, 1
  00689	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv291[rsp], edx
  00690	b9 02 00 00 00	 mov	 ecx, 2
  00695	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0069b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv279[rsp]
  006a3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169018
  006af	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  006b9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006bc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006c1	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  006c8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006cc	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  006d3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169019
  006de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169020
  006ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  006fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169021
  00701	ba 90 02 00 00	 mov	 edx, 656		; 00000290H
  00706	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169022
  0070d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 656  :                 cif->devblk.devnum, cif->fname, "read()", strerror( errno ));
; 657  :             close (fd);

  00713	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  00717	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 658  :             free (cif);

  0071d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00722	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 659  :             return NULL;

  00728	33 c0		 xor	 eax, eax
  0072a	e9 3e 05 00 00	 jmp	 $LN1@open_ckd_i
$LN22@open_ckd_i:

; 660  :         }
; 661  :         close (fd);

  0072f	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  00733	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 662  : 
; 663  :         /* Error if no device header or not CKD non-shadow type */
; 664  :         if (0
; 665  :             || iLen < CKD_DEVHDR_SIZE
; 666  :             || !(dh_devid_typ( devhdr.dh_devid ) & CKD32_CMP_OR_NML_TYP)

  00739	33 c0		 xor	 eax, eax
  0073b	85 c0		 test	 eax, eax
  0073d	75 2a		 jne	 SHORT $LN24@open_ckd_i
  0073f	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR iLen$[rsp]
  00747	48 3d 00 02 00
	00		 cmp	 rax, 512		; 00000200H
  0074d	7c 1a		 jl	 SHORT $LN24@open_ckd_i
  0074f	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  00757	e8 00 00 00 00	 call	 dh_devid_typ
  0075c	25 00 00 00 c0	 and	 eax, -1073741824	; c0000000H
  00761	85 c0		 test	 eax, eax
  00763	0f 85 02 01 00
	00		 jne	 $LN23@open_ckd_i
$LN24@open_ckd_i:

; 667  :         )
; 668  :         {
; 669  :             if (dh_devid_typ( devhdr.dh_devid ) & CKD64_CMP_OR_NML_TYP)

  00769	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  00771	e8 00 00 00 00	 call	 dh_devid_typ
  00776	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  0077b	85 c0		 test	 eax, eax
  0077d	74 4e		 je	 SHORT $LN25@open_ckd_i

; 670  :             {
; 671  :                 dev->cckd64 = 1;

  0077f	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00784	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0078b	0c 01		 or	 al, 1
  0078d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00792	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 672  :                 free( cif );

  00798	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0079d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 673  :                 return open_ckd64_image( fname, sfname, omode, option );

  007a3	44 8b 8c 24 f8
	06 00 00	 mov	 r9d, DWORD PTR option$[rsp]
  007ab	44 8b 84 24 f0
	06 00 00	 mov	 r8d, DWORD PTR omode$[rsp]
  007b3	48 8b 94 24 e8
	06 00 00	 mov	 rdx, QWORD PTR sfname$[rsp]
  007bb	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  007c3	e8 00 00 00 00	 call	 open_ckd64_image
  007c8	e9 a0 04 00 00	 jmp	 $LN1@open_ckd_i
$LN25@open_ckd_i:

; 674  :             }
; 675  : 
; 676  :             // "%1d:%04X CKD file %s: ckd header invalid"
; 677  :             FWRMSG( stderr, HHC00406, "E", SSID_TO_LCSS( cif->devblk.ssid ),

  007cd	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  007d2	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  007d6	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv328[rsp], eax
  007dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  007e2	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  007e6	d1 f9		 sar	 ecx, 1
  007e8	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv332[rsp], ecx
  007ef	b9 02 00 00 00	 mov	 ecx, 2
  007f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  007ff	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00802	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00807	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv328[rsp]
  0080e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00812	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv332[rsp]
  00819	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0081d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169026
  00824	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00829	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169027
  00830	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00835	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0083a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00840	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169028
  00847	ba a6 02 00 00	 mov	 edx, 678		; 000002a6H
  0084c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169029
  00853	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 678  :                 cif->devblk.devnum, cif->fname );
; 679  :             free( cif );

  00859	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0085e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 680  :             return NULL;

  00864	33 c0		 xor	 eax, eax
  00866	e9 02 04 00 00	 jmp	 $LN1@open_ckd_i
$LN23@open_ckd_i:

; 681  :         }
; 682  : 
; 683  :         /* Set the device type */
; 684  :         ckd = dasd_lookup (DASD_CKDDEV, NULL, devhdr.dh_devtyp, 0);

  0086b	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  00873	45 33 c9	 xor	 r9d, r9d
  00876	44 8b c0	 mov	 r8d, eax
  00879	33 d2		 xor	 edx, edx
  0087b	b9 01 00 00 00	 mov	 ecx, 1
  00880	e8 00 00 00 00	 call	 dasd_lookup
  00885	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR ckd$[rsp], rax

; 685  :         if (ckd == NULL)

  0088d	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR ckd$[rsp], 0
  00896	0f 85 b8 00 00
	00		 jne	 $LN26@open_ckd_i

; 686  :         {
; 687  :             // "%1d:%04X CKD file %s: DASD table entry not found for devtype 0x%2.2X"
; 688  :             FWRMSG( stderr, HHC00451, "E", SSID_TO_LCSS(cif->devblk.ssid),

  0089c	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  008a4	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv351[rsp], eax
  008ab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  008b0	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  008b4	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv356[rsp], ecx
  008bb	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  008c0	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  008c4	d1 fa		 sar	 edx, 1
  008c6	89 94 24 bc 00
	00 00		 mov	 DWORD PTR tv360[rsp], edx
  008cd	b9 02 00 00 00	 mov	 ecx, 2
  008d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008d8	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv351[rsp]
  008df	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  008e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  008e8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  008eb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008f0	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv356[rsp]
  008f7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008fb	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv360[rsp]
  00902	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00906	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169031
  0090d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00912	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169032
  00919	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0091e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00923	41 b9 03 00 00
	00		 mov	 r9d, 3
  00929	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169033
  00930	ba b1 02 00 00	 mov	 edx, 689		; 000002b1H
  00935	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169034
  0093c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 689  :                 cif->devblk.devnum, cif->fname, devhdr.dh_devtyp );
; 690  :             free (cif);

  00942	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00947	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 691  :             return NULL;

  0094d	33 c0		 xor	 eax, eax
  0094f	e9 19 03 00 00	 jmp	 $LN1@open_ckd_i
$LN26@open_ckd_i:

; 692  :         }
; 693  :         dev->devtype = ckd->devt;

  00954	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00959	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  00961	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  00965	66 89 48 4a	 mov	 WORD PTR [rax+74], cx

; 694  :         MSGBUF(typname, "%4.4X", dev->devtype);

  00969	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0096e	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00972	44 8b c8	 mov	 r9d, eax
  00975	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169035
  0097c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00981	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR typname$[rsp]
  00989	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 695  :         dev->typname=typname;   /* Makes HDL Happy */

  0098f	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00994	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR typname$[rsp]
  0099c	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
$LN21@open_ckd_i:

; 696  :     }
; 697  : 
; 698  :     /* Set the device handlers */
; 699  :     dev->hnd = &ckd_dasd_device_hndinfo;

  009a0	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  009a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckd_dasd_device_hndinfo
  009ac	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx

; 700  : 
; 701  :     /* Set the device number */
; 702  :     dev->devnum = next_util_devnum();

  009b3	e8 00 00 00 00	 call	 next_util_devnum
  009b8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  009bd	66 89 41 48	 mov	 WORD PTR [rcx+72], ax

; 703  : 
; 704  :     /* Build arguments for ckd_dasd_init_handler */
; 705  :     argv[0] = sfxname;

  009c1	b8 08 00 00 00	 mov	 eax, 8
  009c6	48 6b c0 00	 imul	 rax, rax, 0
  009ca	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  009d2	48 89 8c 04 18
	01 00 00	 mov	 QWORD PTR argv$[rsp+rax], rcx

; 706  :     argc++;

  009da	8b 44 24 78	 mov	 eax, DWORD PTR argc$[rsp]
  009de	ff c0		 inc	 eax
  009e0	89 44 24 78	 mov	 DWORD PTR argc$[rsp], eax

; 707  :     if (sfname != NULL)

  009e4	48 83 bc 24 e8
	06 00 00 00	 cmp	 QWORD PTR sfname$[rsp], 0
  009ed	74 23		 je	 SHORT $LN27@open_ckd_i

; 708  :     {
; 709  :         argv[1] = sfname;

  009ef	b8 08 00 00 00	 mov	 eax, 8
  009f4	48 6b c0 01	 imul	 rax, rax, 1
  009f8	48 8b 8c 24 e8
	06 00 00	 mov	 rcx, QWORD PTR sfname$[rsp]
  00a00	48 89 8c 04 18
	01 00 00	 mov	 QWORD PTR argv$[rsp+rax], rcx

; 710  :         argc++;

  00a08	8b 44 24 78	 mov	 eax, DWORD PTR argc$[rsp]
  00a0c	ff c0		 inc	 eax
  00a0e	89 44 24 78	 mov	 DWORD PTR argc$[rsp], eax
$LN27@open_ckd_i:

; 711  :     }
; 712  : 
; 713  :     /* Call the device handler initialization function */
; 714  :     rc = (dev->hnd->init)(dev, argc, argv);

  00a12	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00a17	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00a1e	4c 8d 84 24 18
	01 00 00	 lea	 r8, QWORD PTR argv$[rsp]
  00a26	8b 54 24 78	 mov	 edx, DWORD PTR argc$[rsp]
  00a2a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00a2f	ff 10		 call	 QWORD PTR [rax]
  00a31	89 84 24 c0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 715  :     if (rc < 0)

  00a38	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a40	0f 8d ca 00 00
	00		 jge	 $LN28@open_ckd_i

; 716  :     {
; 717  :         // "%1d:%04X CKD file %s: initialization failed"
; 718  :         FWRMSG( stderr, HHC00452, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00a46	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00a4b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00a4f	74 12		 je	 SHORT $LN36@open_ckd_i
  00a51	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00a56	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a59	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv402[rsp], rax
  00a61	eb 0f		 jmp	 SHORT $LN37@open_ckd_i
$LN36@open_ckd_i:
  00a63	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169038
  00a6a	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv402[rsp], rax
$LN37@open_ckd_i:
  00a72	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00a77	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00a7b	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv405[rsp], eax
  00a82	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00a87	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00a8b	d1 f9		 sar	 ecx, 1
  00a8d	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv409[rsp], ecx
  00a94	b9 02 00 00 00	 mov	 ecx, 2
  00a99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a9f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv402[rsp]
  00aa7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00aac	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv405[rsp]
  00ab3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ab7	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv409[rsp]
  00abe	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ac2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169039
  00ac9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ace	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169040
  00ad5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ada	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00adf	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ae5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169041
  00aec	ba cf 02 00 00	 mov	 edx, 719		; 000002cfH
  00af1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169042
  00af8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 719  :             cif->devblk.devnum, cif->fname ? cif->fname : "(null)" );
; 720  :         free (cif);

  00afe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00b03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 721  :         return NULL;

  00b09	33 c0		 xor	 eax, eax
  00b0b	e9 5d 01 00 00	 jmp	 $LN1@open_ckd_i
$LN28@open_ckd_i:

; 722  :     }
; 723  : 
; 724  :     /* Call the device start exit */
; 725  :     if (dev->hnd->start) (dev->hnd->start) (dev);

  00b10	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00b15	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00b1c	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00b21	74 14		 je	 SHORT $LN29@open_ckd_i
  00b23	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00b28	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00b2f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00b34	ff 50 28	 call	 QWORD PTR [rax+40]
$LN29@open_ckd_i:

; 726  : 
; 727  :     /* Set CIF fields */
; 728  :     cif->fname = fname;

  00b37	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00b3c	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00b44	48 89 08	 mov	 QWORD PTR [rax], rcx

; 729  :     cif->fd = dev->fd;

  00b47	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00b4c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00b51	8b 89 ac 01 00
	00		 mov	 ecx, DWORD PTR [rcx+428]
  00b57	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 730  : 
; 731  :     /* Extract the number of heads and the track size */
; 732  :     cif->heads = dev->ckdheads;

  00b5a	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00b5f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00b64	8b 89 c0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4800]
  00b6a	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 733  :     FETCH_LE_FW( cif->trksz, devhdr.dh_trksize );

  00b6d	48 8d 8c 24 3c
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  00b75	e8 00 00 00 00	 call	 fetch_fw_noswap
  00b7a	8b c8		 mov	 ecx, eax
  00b7c	e8 00 00 00 00	 call	 _byteswap_ulong
  00b81	8b c8		 mov	 ecx, eax
  00b83	e8 00 00 00 00	 call	 _byteswap_ulong
  00b88	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00b8d	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 734  : 
; 735  :     if (is_verbose_util())

  00b90	e8 00 00 00 00	 call	 is_verbose_util
  00b95	0f b6 c0	 movzx	 eax, al
  00b98	85 c0		 test	 eax, eax
  00b9a	0f 84 a4 00 00
	00		 je	 $LN30@open_ckd_i

; 736  :     {
; 737  :        FWRMSG( stdout, HHC00453, "I", SSID_TO_LCSS(cif->devblk.ssid),

  00ba0	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00ba5	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00ba9	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv449[rsp], eax
  00bb0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00bb5	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00bb9	d1 f9		 sar	 ecx, 1
  00bbb	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv453[rsp], ecx
  00bc2	b9 01 00 00 00	 mov	 ecx, 1
  00bc7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bcd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00bd2	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00bd5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00bd9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00bde	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  00be1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00be5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00bea	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00bed	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00bf2	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv449[rsp]
  00bf9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00bfd	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv453[rsp]
  00c04	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169045
  00c0f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c14	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169046
  00c1b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c20	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c25	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c2b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169047
  00c32	ba e2 02 00 00	 mov	 edx, 738		; 000002e2H
  00c37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169048
  00c3e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@open_ckd_i:

; 738  :            cif->devblk.devnum, cif->fname, cif->heads, cif->trksz );
; 739  :     }
; 740  : 
; 741  :     /* Indicate that the track buffer is empty */
; 742  :     cif->curcyl = -1;

  00c44	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00c49	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1	; ffffffffH

; 743  :     cif->curhead = -1;

  00c50	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00c55	c7 40 1c ff ff
	ff ff		 mov	 DWORD PTR [rax+28], -1	; ffffffffH

; 744  :     cif->trkmodif = 0;

  00c5c	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00c61	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 745  : 
; 746  :     return cif;

  00c68	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
$LN1@open_ckd_i:

; 747  : } /* end function open_ckd_image */

  00c6d	48 8b 8c 24 c0
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c75	48 33 cc	 xor	 rcx, rsp
  00c78	e8 00 00 00 00	 call	 __security_check_cookie
  00c7d	48 81 c4 d8 06
	00 00		 add	 rsp, 1752		; 000006d8H
  00c84	c3		 ret	 0
open_ckd_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
i$ = 64
trk$ = 68
start$ = 72
extsize$ = 76
bcyl$ = 80
btrk$ = 84
ecyl$ = 88
etrk$ = 92
end$ = 96
tv172 = 100
tv174 = 104
tt$ = 128
noext$ = 136
extent$ = 144
heads$ = 152
cyl$ = 160
head$ = 168
convert_tt PROC

; 489  : {

$LN7:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 490  : u_int           i;                      /* Extent sequence number    */
; 491  : u_int           trk;                    /* Relative track number     */
; 492  : u_int           bcyl;                   /* Extent begin cylinder     */
; 493  : u_int           btrk;                   /* Extent begin head         */
; 494  : u_int           ecyl;                   /* Extent end cylinder       */
; 495  : u_int           etrk;                   /* Extent end head           */
; 496  : u_int           start;                  /* Extent begin track        */
; 497  : u_int           end;                    /* Extent end track          */
; 498  : u_int           extsize;                /* Extent size in tracks     */
; 499  : 
; 500  :     for (i = 0, trk = tt; i < noext; i++)

  00016	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tt$[rsp]
  00025	89 44 24 44	 mov	 DWORD PTR trk$[rsp], eax
  00029	eb 0a		 jmp	 SHORT $LN4@convert_tt
$LN2@convert_tt:
  0002b	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0002f	ff c0		 inc	 eax
  00031	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@convert_tt:
  00035	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR noext$[rsp]
  0003c	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00040	0f 83 01 02 00
	00		 jae	 $LN3@convert_tt

; 501  :     {
; 502  :         bcyl = (extent[i].xtbcyl[0] << 8) | extent[i].xtbcyl[1];

  00046	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0004a	48 6b c0 0a	 imul	 rax, rax, 10
  0004e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00056	48 03 c8	 add	 rcx, rax
  00059	48 8b c1	 mov	 rax, rcx
  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	48 6b c9 00	 imul	 rcx, rcx, 0
  00065	0f b6 44 08 02	 movzx	 eax, BYTE PTR [rax+rcx+2]
  0006a	c1 e0 08	 shl	 eax, 8
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  00071	48 6b c9 0a	 imul	 rcx, rcx, 10
  00075	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  0007d	48 03 d1	 add	 rdx, rcx
  00080	48 8b ca	 mov	 rcx, rdx
  00083	ba 01 00 00 00	 mov	 edx, 1
  00088	48 6b d2 01	 imul	 rdx, rdx, 1
  0008c	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [rcx+rdx+2]
  00091	0b c1		 or	 eax, ecx
  00093	89 44 24 50	 mov	 DWORD PTR bcyl$[rsp], eax

; 503  :         btrk = (extent[i].xtbtrk[0] << 8) | extent[i].xtbtrk[1];

  00097	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0009b	48 6b c0 0a	 imul	 rax, rax, 10
  0009f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  000a7	48 03 c8	 add	 rcx, rax
  000aa	48 8b c1	 mov	 rax, rcx
  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	48 6b c9 00	 imul	 rcx, rcx, 0
  000b6	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  000bb	c1 e0 08	 shl	 eax, 8
  000be	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  000c2	48 6b c9 0a	 imul	 rcx, rcx, 10
  000c6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  000ce	48 03 d1	 add	 rdx, rcx
  000d1	48 8b ca	 mov	 rcx, rdx
  000d4	ba 01 00 00 00	 mov	 edx, 1
  000d9	48 6b d2 01	 imul	 rdx, rdx, 1
  000dd	0f b6 4c 11 04	 movzx	 ecx, BYTE PTR [rcx+rdx+4]
  000e2	0b c1		 or	 eax, ecx
  000e4	89 44 24 54	 mov	 DWORD PTR btrk$[rsp], eax

; 504  :         ecyl = (extent[i].xtecyl[0] << 8) | extent[i].xtecyl[1];

  000e8	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000ec	48 6b c0 0a	 imul	 rax, rax, 10
  000f0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  000f8	48 03 c8	 add	 rcx, rax
  000fb	48 8b c1	 mov	 rax, rcx
  000fe	b9 01 00 00 00	 mov	 ecx, 1
  00103	48 6b c9 00	 imul	 rcx, rcx, 0
  00107	0f b6 44 08 06	 movzx	 eax, BYTE PTR [rax+rcx+6]
  0010c	c1 e0 08	 shl	 eax, 8
  0010f	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  00113	48 6b c9 0a	 imul	 rcx, rcx, 10
  00117	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  0011f	48 03 d1	 add	 rdx, rcx
  00122	48 8b ca	 mov	 rcx, rdx
  00125	ba 01 00 00 00	 mov	 edx, 1
  0012a	48 6b d2 01	 imul	 rdx, rdx, 1
  0012e	0f b6 4c 11 06	 movzx	 ecx, BYTE PTR [rcx+rdx+6]
  00133	0b c1		 or	 eax, ecx
  00135	89 44 24 58	 mov	 DWORD PTR ecyl$[rsp], eax

; 505  :         etrk = (extent[i].xtetrk[0] << 8) | extent[i].xtetrk[1];

  00139	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0013d	48 6b c0 0a	 imul	 rax, rax, 10
  00141	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00149	48 03 c8	 add	 rcx, rax
  0014c	48 8b c1	 mov	 rax, rcx
  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	48 6b c9 00	 imul	 rcx, rcx, 0
  00158	0f b6 44 08 08	 movzx	 eax, BYTE PTR [rax+rcx+8]
  0015d	c1 e0 08	 shl	 eax, 8
  00160	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  00164	48 6b c9 0a	 imul	 rcx, rcx, 10
  00168	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00170	48 03 d1	 add	 rdx, rcx
  00173	48 8b ca	 mov	 rcx, rdx
  00176	ba 01 00 00 00	 mov	 edx, 1
  0017b	48 6b d2 01	 imul	 rdx, rdx, 1
  0017f	0f b6 4c 11 08	 movzx	 ecx, BYTE PTR [rcx+rdx+8]
  00184	0b c1		 or	 eax, ecx
  00186	89 44 24 5c	 mov	 DWORD PTR etrk$[rsp], eax

; 506  : 
; 507  :         start = (bcyl * heads) + btrk;

  0018a	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR heads$[rsp]
  00192	8b 4c 24 50	 mov	 ecx, DWORD PTR bcyl$[rsp]
  00196	0f af c8	 imul	 ecx, eax
  00199	8b c1		 mov	 eax, ecx
  0019b	03 44 24 54	 add	 eax, DWORD PTR btrk$[rsp]
  0019f	89 44 24 48	 mov	 DWORD PTR start$[rsp], eax

; 508  :         end = (ecyl * heads) + etrk;

  001a3	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR heads$[rsp]
  001ab	8b 4c 24 58	 mov	 ecx, DWORD PTR ecyl$[rsp]
  001af	0f af c8	 imul	 ecx, eax
  001b2	8b c1		 mov	 eax, ecx
  001b4	03 44 24 5c	 add	 eax, DWORD PTR etrk$[rsp]
  001b8	89 44 24 60	 mov	 DWORD PTR end$[rsp], eax

; 509  :         extsize = end - start + 1;

  001bc	8b 44 24 48	 mov	 eax, DWORD PTR start$[rsp]
  001c0	8b 4c 24 60	 mov	 ecx, DWORD PTR end$[rsp]
  001c4	2b c8		 sub	 ecx, eax
  001c6	8b c1		 mov	 eax, ecx
  001c8	ff c0		 inc	 eax
  001ca	89 44 24 4c	 mov	 DWORD PTR extsize$[rsp], eax

; 510  : 
; 511  :         if (trk < extsize)

  001ce	8b 44 24 4c	 mov	 eax, DWORD PTR extsize$[rsp]
  001d2	39 44 24 44	 cmp	 DWORD PTR trk$[rsp], eax
  001d6	73 5a		 jae	 SHORT $LN5@convert_tt

; 512  :         {
; 513  :             trk += start;

  001d8	8b 44 24 48	 mov	 eax, DWORD PTR start$[rsp]
  001dc	8b 4c 24 44	 mov	 ecx, DWORD PTR trk$[rsp]
  001e0	03 c8		 add	 ecx, eax
  001e2	8b c1		 mov	 eax, ecx
  001e4	89 44 24 44	 mov	 DWORD PTR trk$[rsp], eax

; 514  :             *cyl = trk / heads;

  001e8	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR heads$[rsp]
  001f0	89 44 24 64	 mov	 DWORD PTR tv172[rsp], eax
  001f4	33 d2		 xor	 edx, edx
  001f6	8b 44 24 44	 mov	 eax, DWORD PTR trk$[rsp]
  001fa	8b 4c 24 64	 mov	 ecx, DWORD PTR tv172[rsp]
  001fe	f7 f1		 div	 ecx
  00200	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cyl$[rsp]
  00208	89 01		 mov	 DWORD PTR [rcx], eax

; 515  :             *head = trk % heads;

  0020a	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR heads$[rsp]
  00212	89 44 24 68	 mov	 DWORD PTR tv174[rsp], eax
  00216	33 d2		 xor	 edx, edx
  00218	8b 44 24 44	 mov	 eax, DWORD PTR trk$[rsp]
  0021c	8b 4c 24 68	 mov	 ecx, DWORD PTR tv174[rsp]
  00220	f7 f1		 div	 ecx
  00222	8b c2		 mov	 eax, edx
  00224	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR head$[rsp]
  0022c	88 01		 mov	 BYTE PTR [rcx], al

; 516  :             return 0;

  0022e	33 c0		 xor	 eax, eax
  00230	eb 6c		 jmp	 SHORT $LN1@convert_tt
$LN5@convert_tt:

; 517  :         }
; 518  : 
; 519  :         trk -= extsize;

  00232	8b 44 24 4c	 mov	 eax, DWORD PTR extsize$[rsp]
  00236	8b 4c 24 44	 mov	 ecx, DWORD PTR trk$[rsp]
  0023a	2b c8		 sub	 ecx, eax
  0023c	8b c1		 mov	 eax, ecx
  0023e	89 44 24 44	 mov	 DWORD PTR trk$[rsp], eax

; 520  : 
; 521  :     } /* end for(i) */

  00242	e9 e4 fd ff ff	 jmp	 $LN2@convert_tt
$LN3@convert_tt:

; 522  : 
; 523  :     FWRMSG( stderr, HHC00450, "E", tt );

  00247	b9 02 00 00 00	 mov	 ecx, 2
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00252	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tt$[rsp]
  00259	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168923
  00264	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168924
  00270	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00275	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00280	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168925
  00287	ba 0b 02 00 00	 mov	 edx, 523		; 0000020bH
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168926
  00293	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 524  :     return -1;

  00299	b8 ff ff ff ff	 mov	 eax, -1
$LN1@convert_tt:

; 525  : 
; 526  : } /* end function convert_tt */

  0029e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002a2	c3		 ret	 0
convert_tt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
chead$ = 128
cext$ = 132
kl$ = 136
ccyl$ = 140
ecyl$ = 144
ehead$ = 148
dl$ = 152
ptr$ = 160
rechdr$ = 168
tv166 = 176
tv173 = 180
tv177 = 184
rc$ = 188
tv314 = 192
tv321 = 196
tv325 = 200
cif$ = 224
key$ = 232
keylen$ = 240
noext$ = 248
extent$ = 256
cyl$ = 264
head$ = 272
rec$ = 280
search_key_equal PROC

; 371  : {

$LN17:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 372  : int             rc;                     /* Return code               */
; 373  : U32             ccyl;                   /* Cylinder number           */
; 374  : U8              chead;                  /* Head number               */
; 375  : u_int           cext;                   /* Extent sequence number    */
; 376  : U32             ecyl;                   /* Extent end cylinder       */
; 377  : U32             ehead;                  /* Extent end head           */
; 378  : BYTE           *ptr;                    /* -> byte in track buffer   */
; 379  : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 380  : U8              kl;                     /* Key length                */
; 381  : U16             dl;                     /* Data length               */
; 382  : 
; 383  :     /* Start at first track of first extent */
; 384  :     cext = 0;

  0001b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cext$[rsp], 0

; 385  :     ccyl = (extent[cext].xtbcyl[0] << 8) | extent[cext].xtbcyl[1];

  00026	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  0002d	48 6b c0 0a	 imul	 rax, rax, 10
  00031	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 8b c1	 mov	 rax, rcx
  0003f	b9 01 00 00 00	 mov	 ecx, 1
  00044	48 6b c9 00	 imul	 rcx, rcx, 0
  00048	0f b6 44 08 02	 movzx	 eax, BYTE PTR [rax+rcx+2]
  0004d	c1 e0 08	 shl	 eax, 8
  00050	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  00057	48 6b c9 0a	 imul	 rcx, rcx, 10
  0005b	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00063	48 03 d1	 add	 rdx, rcx
  00066	48 8b ca	 mov	 rcx, rdx
  00069	ba 01 00 00 00	 mov	 edx, 1
  0006e	48 6b d2 01	 imul	 rdx, rdx, 1
  00072	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [rcx+rdx+2]
  00077	0b c1		 or	 eax, ecx
  00079	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ccyl$[rsp], eax

; 386  :     chead = (extent[cext].xtbtrk[0] << 8) | extent[cext].xtbtrk[1];

  00080	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  00087	48 6b c0 0a	 imul	 rax, rax, 10
  0008b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00093	48 03 c8	 add	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	b9 01 00 00 00	 mov	 ecx, 1
  0009e	48 6b c9 00	 imul	 rcx, rcx, 0
  000a2	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  000a7	c1 e0 08	 shl	 eax, 8
  000aa	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  000b1	48 6b c9 0a	 imul	 rcx, rcx, 10
  000b5	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  000bd	48 03 d1	 add	 rdx, rcx
  000c0	48 8b ca	 mov	 rcx, rdx
  000c3	ba 01 00 00 00	 mov	 edx, 1
  000c8	48 6b d2 01	 imul	 rdx, rdx, 1
  000cc	0f b6 4c 11 04	 movzx	 ecx, BYTE PTR [rcx+rdx+4]
  000d1	0b c1		 or	 eax, ecx
  000d3	88 84 24 80 00
	00 00		 mov	 BYTE PTR chead$[rsp], al

; 387  :     ecyl = (extent[cext].xtecyl[0] << 8) | extent[cext].xtecyl[1];

  000da	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  000e1	48 6b c0 0a	 imul	 rax, rax, 10
  000e5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  000ed	48 03 c8	 add	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	b9 01 00 00 00	 mov	 ecx, 1
  000f8	48 6b c9 00	 imul	 rcx, rcx, 0
  000fc	0f b6 44 08 06	 movzx	 eax, BYTE PTR [rax+rcx+6]
  00101	c1 e0 08	 shl	 eax, 8
  00104	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  0010b	48 6b c9 0a	 imul	 rcx, rcx, 10
  0010f	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00117	48 03 d1	 add	 rdx, rcx
  0011a	48 8b ca	 mov	 rcx, rdx
  0011d	ba 01 00 00 00	 mov	 edx, 1
  00122	48 6b d2 01	 imul	 rdx, rdx, 1
  00126	0f b6 4c 11 06	 movzx	 ecx, BYTE PTR [rcx+rdx+6]
  0012b	0b c1		 or	 eax, ecx
  0012d	89 84 24 90 00
	00 00		 mov	 DWORD PTR ecyl$[rsp], eax

; 388  :     ehead = (extent[cext].xtetrk[0] << 8) | extent[cext].xtetrk[1];

  00134	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  0013b	48 6b c0 0a	 imul	 rax, rax, 10
  0013f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00147	48 03 c8	 add	 rcx, rax
  0014a	48 8b c1	 mov	 rax, rcx
  0014d	b9 01 00 00 00	 mov	 ecx, 1
  00152	48 6b c9 00	 imul	 rcx, rcx, 0
  00156	0f b6 44 08 08	 movzx	 eax, BYTE PTR [rax+rcx+8]
  0015b	c1 e0 08	 shl	 eax, 8
  0015e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  00165	48 6b c9 0a	 imul	 rcx, rcx, 10
  00169	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00171	48 03 d1	 add	 rdx, rcx
  00174	48 8b ca	 mov	 rcx, rdx
  00177	ba 01 00 00 00	 mov	 edx, 1
  0017c	48 6b d2 01	 imul	 rdx, rdx, 1
  00180	0f b6 4c 11 08	 movzx	 ecx, BYTE PTR [rcx+rdx+8]
  00185	0b c1		 or	 eax, ecx
  00187	89 84 24 94 00
	00 00		 mov	 DWORD PTR ehead$[rsp], eax

; 389  : 
; 390  :     if (is_verbose_util())

  0018e	e8 00 00 00 00	 call	 is_verbose_util
  00193	0f b6 c0	 movzx	 eax, al
  00196	85 c0		 test	 eax, eax
  00198	0f 84 db 00 00
	00		 je	 $LN6@search_key

; 391  :     {
; 392  :        FWRMSG( stdout, HHC00449, "I", SSID_TO_LCSS(cif->devblk.ssid),

  0019e	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR chead$[rsp]
  001a6	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv166[rsp], eax
  001ad	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  001b5	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  001b9	89 8c 24 b4 00
	00 00		 mov	 DWORD PTR tv173[rsp], ecx
  001c0	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  001c8	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  001cc	d1 fa		 sar	 edx, 1
  001ce	89 94 24 b8 00
	00 00		 mov	 DWORD PTR tv177[rsp], edx
  001d5	b9 01 00 00 00	 mov	 ecx, 1
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e0	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR ehead$[rsp]
  001e7	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  001eb	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ecyl$[rsp]
  001f2	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  001f6	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv166[rsp]
  001fd	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00201	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ccyl$[rsp]
  00208	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0020c	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  00213	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00217	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0021f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00222	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00227	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv173[rsp]
  0022e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00232	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv177[rsp]
  00239	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168881
  00244	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168882
  00250	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00255	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00260	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168883
  00267	ba 89 01 00 00	 mov	 edx, 393		; 00000189H
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168884
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@search_key:
$LN16@search_key:
$LN2@search_key:

; 393  :            cif->devblk.devnum, cif->fname, cext, ccyl, chead, ecyl, ehead );
; 394  :     }
; 395  : 
; 396  :     while (1)

  00279	33 c0		 xor	 eax, eax
  0027b	83 f8 01	 cmp	 eax, 1
  0027e	0f 84 7f 04 00
	00		 je	 $LN3@search_key

; 397  :     {
; 398  :         /* Read the required track into the track buffer */
; 399  :         rc = read_track (cif, ccyl, chead);

  00284	44 0f b6 84 24
	80 00 00 00	 movzx	 r8d, BYTE PTR chead$[rsp]
  0028d	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR ccyl$[rsp]
  00294	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0029c	e8 00 00 00 00	 call	 read_track
  002a1	89 84 24 bc 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 400  :         if (rc < 0) return -1;

  002a8	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  002b0	7d 0a		 jge	 SHORT $LN7@search_key
  002b2	b8 ff ff ff ff	 mov	 eax, -1
  002b7	e9 4c 04 00 00	 jmp	 $LN1@search_key
$LN7@search_key:

; 401  : 
; 402  :         /* Search for the requested record in the track buffer */
; 403  :         ptr = cif->trkbuf;

  002bc	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  002c4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002c8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ptr$[rsp], rax

; 404  :         ptr += CKD_TRKHDR_SIZE;

  002d0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  002d8	48 83 c0 05	 add	 rax, 5
  002dc	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ptr$[rsp], rax
$LN4@search_key:

; 405  : 
; 406  :         while (1)

  002e4	33 c0		 xor	 eax, eax
  002e6	83 f8 01	 cmp	 eax, 1
  002e9	0f 84 23 01 00
	00		 je	 $LN5@search_key

; 407  :         {
; 408  :             /* Exit loop at end of track */
; 409  :             if (memcmp( ptr, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  002ef	41 b8 08 00 00
	00		 mov	 r8d, 8
  002f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  002fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  00304	e8 00 00 00 00	 call	 memcmp
  00309	85 c0		 test	 eax, eax
  0030b	75 05		 jne	 SHORT $LN8@search_key

; 410  :                 break;

  0030d	e9 00 01 00 00	 jmp	 $LN5@search_key
$LN8@search_key:

; 411  : 
; 412  :             /* Extract key length and data length from count field */
; 413  :             rechdr = (CKD_RECHDR*)ptr;

  00312	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  0031a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR rechdr$[rsp], rax

; 414  :             kl = rechdr->klen;

  00322	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  0032a	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0032e	88 84 24 88 00
	00 00		 mov	 BYTE PTR kl$[rsp], al

; 415  :             dl = (rechdr->dlen[0] << 8) | rechdr->dlen[1];

  00335	b8 01 00 00 00	 mov	 eax, 1
  0033a	48 6b c0 00	 imul	 rax, rax, 0
  0033e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00346	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  0034b	c1 e0 08	 shl	 eax, 8
  0034e	b9 01 00 00 00	 mov	 ecx, 1
  00353	48 6b c9 01	 imul	 rcx, rcx, 1
  00357	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR rechdr$[rsp]
  0035f	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  00364	0b c1		 or	 eax, ecx
  00366	66 89 84 24 98
	00 00 00	 mov	 WORD PTR dl$[rsp], ax

; 416  : 
; 417  :             /* Return if requested record key found */
; 418  :             if (kl == keylen
; 419  :                 && memcmp(ptr + CKD_RECHDR_SIZE, key, 44) == 0)

  0036e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR kl$[rsp]
  00376	0f b6 8c 24 f0
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  0037e	3b c1		 cmp	 eax, ecx
  00380	75 66		 jne	 SHORT $LN9@search_key
  00382	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  0038a	48 83 c0 08	 add	 rax, 8
  0038e	41 b8 2c 00 00
	00		 mov	 r8d, 44			; 0000002cH
  00394	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  0039c	48 8b c8	 mov	 rcx, rax
  0039f	e8 00 00 00 00	 call	 memcmp
  003a4	85 c0		 test	 eax, eax
  003a6	75 40		 jne	 SHORT $LN9@search_key

; 420  :             {
; 421  :                 *cyl = ccyl;

  003a8	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR cyl$[rsp]
  003b0	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ccyl$[rsp]
  003b7	89 08		 mov	 DWORD PTR [rax], ecx

; 422  :                 *head = chead;

  003b9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR head$[rsp]
  003c1	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR chead$[rsp]
  003c9	88 08		 mov	 BYTE PTR [rax], cl

; 423  :                 *rec = rechdr->rec;

  003cb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR rec$[rsp]
  003d3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  003db	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  003df	88 08		 mov	 BYTE PTR [rax], cl

; 424  :                 return 0;

  003e1	33 c0		 xor	 eax, eax
  003e3	e9 20 03 00 00	 jmp	 $LN1@search_key
$LN9@search_key:

; 425  :             }
; 426  : 
; 427  :             /* Issue progress message */
; 428  : //          FLOGMSG( stdout,
; 429  : //                   "Skipping CCHHR=%2.2X%2.2X%2.2X%2.2X"
; 430  : //                   "%2.2X KL=%2.2X DL=%2.2X%2.2X\n",
; 431  : //                   rechdr->cyl[0], rechdr->cyl[1],
; 432  : //                   rechdr->head[0], rechdr->head[1],
; 433  : //                   rechdr->rec, rechdr->klen,
; 434  : //                   rechdr->dlen[0], rechdr->dlen[1] );
; 435  : 
; 436  :             /* Point past count key and data to next block */
; 437  :             ptr += CKD_RECHDR_SIZE + kl + dl;

  003e8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR kl$[rsp]
  003f0	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR dl$[rsp]
  003f8	48 03 8c 24 a0
	00 00 00	 add	 rcx, QWORD PTR ptr$[rsp]
  00400	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00405	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ptr$[rsp], rax

; 438  : 
; 439  :         } /* end while */

  0040d	e9 d2 fe ff ff	 jmp	 $LN4@search_key
$LN5@search_key:

; 440  : 
; 441  :         /* Point to the next track */
; 442  :         chead++;

  00412	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR chead$[rsp]
  0041a	fe c0		 inc	 al
  0041c	88 84 24 80 00
	00 00		 mov	 BYTE PTR chead$[rsp], al

; 443  :         if (chead >= cif->heads)

  00423	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR chead$[rsp]
  0042b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00433	3b 41 24	 cmp	 eax, DWORD PTR [rcx+36]
  00436	72 18		 jb	 SHORT $LN10@search_key

; 444  :         {
; 445  :             ccyl++;

  00438	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR ccyl$[rsp]
  0043f	ff c0		 inc	 eax
  00441	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ccyl$[rsp], eax

; 446  :             chead = 0;

  00448	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR chead$[rsp], 0
$LN10@search_key:

; 447  :         }
; 448  : 
; 449  :         /* Loop if next track is within current extent */
; 450  :         if (ccyl < ecyl || (ccyl == ecyl && chead <= ehead))

  00450	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ecyl$[rsp]
  00457	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR ccyl$[rsp], eax
  0045e	72 21		 jb	 SHORT $LN12@search_key
  00460	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ecyl$[rsp]
  00467	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR ccyl$[rsp], eax
  0046e	75 16		 jne	 SHORT $LN11@search_key
  00470	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR chead$[rsp]
  00478	3b 84 24 94 00
	00 00		 cmp	 eax, DWORD PTR ehead$[rsp]
  0047f	77 05		 ja	 SHORT $LN11@search_key
$LN12@search_key:

; 451  :             continue;

  00481	e9 f3 fd ff ff	 jmp	 $LN2@search_key
$LN11@search_key:

; 452  : 
; 453  :         /* Move to next extent */
; 454  :         cext++;

  00486	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  0048d	ff c0		 inc	 eax
  0048f	89 84 24 84 00
	00 00		 mov	 DWORD PTR cext$[rsp], eax

; 455  :         if (cext >= noext) break;

  00496	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR noext$[rsp]
  0049d	39 84 24 84 00
	00 00		 cmp	 DWORD PTR cext$[rsp], eax
  004a4	72 05		 jb	 SHORT $LN13@search_key
  004a6	e9 58 02 00 00	 jmp	 $LN3@search_key
$LN13@search_key:

; 456  :         ccyl = (extent[cext].xtbcyl[0] << 8) | extent[cext].xtbcyl[1];

  004ab	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  004b2	48 6b c0 0a	 imul	 rax, rax, 10
  004b6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  004be	48 03 c8	 add	 rcx, rax
  004c1	48 8b c1	 mov	 rax, rcx
  004c4	b9 01 00 00 00	 mov	 ecx, 1
  004c9	48 6b c9 00	 imul	 rcx, rcx, 0
  004cd	0f b6 44 08 02	 movzx	 eax, BYTE PTR [rax+rcx+2]
  004d2	c1 e0 08	 shl	 eax, 8
  004d5	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  004dc	48 6b c9 0a	 imul	 rcx, rcx, 10
  004e0	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  004e8	48 03 d1	 add	 rdx, rcx
  004eb	48 8b ca	 mov	 rcx, rdx
  004ee	ba 01 00 00 00	 mov	 edx, 1
  004f3	48 6b d2 01	 imul	 rdx, rdx, 1
  004f7	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [rcx+rdx+2]
  004fc	0b c1		 or	 eax, ecx
  004fe	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ccyl$[rsp], eax

; 457  :         chead = (extent[cext].xtbtrk[0] << 8) | extent[cext].xtbtrk[1];

  00505	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  0050c	48 6b c0 0a	 imul	 rax, rax, 10
  00510	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00518	48 03 c8	 add	 rcx, rax
  0051b	48 8b c1	 mov	 rax, rcx
  0051e	b9 01 00 00 00	 mov	 ecx, 1
  00523	48 6b c9 00	 imul	 rcx, rcx, 0
  00527	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  0052c	c1 e0 08	 shl	 eax, 8
  0052f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  00536	48 6b c9 0a	 imul	 rcx, rcx, 10
  0053a	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00542	48 03 d1	 add	 rdx, rcx
  00545	48 8b ca	 mov	 rcx, rdx
  00548	ba 01 00 00 00	 mov	 edx, 1
  0054d	48 6b d2 01	 imul	 rdx, rdx, 1
  00551	0f b6 4c 11 04	 movzx	 ecx, BYTE PTR [rcx+rdx+4]
  00556	0b c1		 or	 eax, ecx
  00558	88 84 24 80 00
	00 00		 mov	 BYTE PTR chead$[rsp], al

; 458  :         ecyl = (extent[cext].xtecyl[0] << 8) | extent[cext].xtecyl[1];

  0055f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  00566	48 6b c0 0a	 imul	 rax, rax, 10
  0056a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00572	48 03 c8	 add	 rcx, rax
  00575	48 8b c1	 mov	 rax, rcx
  00578	b9 01 00 00 00	 mov	 ecx, 1
  0057d	48 6b c9 00	 imul	 rcx, rcx, 0
  00581	0f b6 44 08 06	 movzx	 eax, BYTE PTR [rax+rcx+6]
  00586	c1 e0 08	 shl	 eax, 8
  00589	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  00590	48 6b c9 0a	 imul	 rcx, rcx, 10
  00594	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  0059c	48 03 d1	 add	 rdx, rcx
  0059f	48 8b ca	 mov	 rcx, rdx
  005a2	ba 01 00 00 00	 mov	 edx, 1
  005a7	48 6b d2 01	 imul	 rdx, rdx, 1
  005ab	0f b6 4c 11 06	 movzx	 ecx, BYTE PTR [rcx+rdx+6]
  005b0	0b c1		 or	 eax, ecx
  005b2	89 84 24 90 00
	00 00		 mov	 DWORD PTR ecyl$[rsp], eax

; 459  :         ehead = (extent[cext].xtetrk[0] << 8) | extent[cext].xtetrk[1];

  005b9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cext$[rsp]
  005c0	48 6b c0 0a	 imul	 rax, rax, 10
  005c4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  005cc	48 03 c8	 add	 rcx, rax
  005cf	48 8b c1	 mov	 rax, rcx
  005d2	b9 01 00 00 00	 mov	 ecx, 1
  005d7	48 6b c9 00	 imul	 rcx, rcx, 0
  005db	0f b6 44 08 08	 movzx	 eax, BYTE PTR [rax+rcx+8]
  005e0	c1 e0 08	 shl	 eax, 8
  005e3	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  005ea	48 6b c9 0a	 imul	 rcx, rcx, 10
  005ee	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  005f6	48 03 d1	 add	 rdx, rcx
  005f9	48 8b ca	 mov	 rcx, rdx
  005fc	ba 01 00 00 00	 mov	 edx, 1
  00601	48 6b d2 01	 imul	 rdx, rdx, 1
  00605	0f b6 4c 11 08	 movzx	 ecx, BYTE PTR [rcx+rdx+8]
  0060a	0b c1		 or	 eax, ecx
  0060c	89 84 24 94 00
	00 00		 mov	 DWORD PTR ehead$[rsp], eax

; 460  : 
; 461  :        if (is_verbose_util())

  00613	e8 00 00 00 00	 call	 is_verbose_util
  00618	0f b6 c0	 movzx	 eax, al
  0061b	85 c0		 test	 eax, eax
  0061d	0f 84 db 00 00
	00		 je	 $LN14@search_key

; 462  :        {
; 463  :            FWRMSG( stdout, HHC00449, "I", SSID_TO_LCSS(cif->devblk.ssid),

  00623	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR chead$[rsp]
  0062b	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv314[rsp], eax
  00632	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0063a	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  0063e	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv321[rsp], ecx
  00645	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  0064d	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  00651	d1 fa		 sar	 edx, 1
  00653	89 94 24 c8 00
	00 00		 mov	 DWORD PTR tv325[rsp], edx
  0065a	b9 01 00 00 00	 mov	 ecx, 1
  0065f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00665	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR ehead$[rsp]
  0066c	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00670	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ecyl$[rsp]
  00677	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0067b	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv314[rsp]
  00682	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00686	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ccyl$[rsp]
  0068d	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00691	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR cext$[rsp]
  00698	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0069c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  006a4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006a7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006ac	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv321[rsp]
  006b3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006b7	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv325[rsp]
  006be	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168893
  006c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168894
  006d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006df	41 b9 03 00 00
	00		 mov	 r9d, 3
  006e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168895
  006ec	ba d0 01 00 00	 mov	 edx, 464		; 000001d0H
  006f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168896
  006f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@search_key:

; 464  :                cif->devblk.devnum, cif->fname, cext, ccyl, chead, ecyl, ehead );
; 465  :        }
; 466  : 
; 467  :     } /* end while */

  006fe	e9 76 fb ff ff	 jmp	 $LN16@search_key
$LN3@search_key:

; 468  : 
; 469  :     /* Return record not found at end of extents */
; 470  :     return +1;

  00703	b8 01 00 00 00	 mov	 eax, 1
$LN1@search_key:

; 471  : 
; 472  : } /* end function search_key_equal */

  00708	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0070f	c3		 ret	 0
search_key_equal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
kl$ = 32
dl$ = 36
rc$ = 40
ptr$ = 48
rechdr$ = 56
cif$ = 80
cyl$ = 88
head$ = 96
rec$ = 104
keyptr$ = 112
keylen$ = 120
dataptr$ = 128
datalen$ = 136
read_block PROC

; 302  : {

$LN12:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 303  : int             rc;                     /* Return code               */
; 304  : BYTE           *ptr;                    /* -> byte in track buffer   */
; 305  : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 306  : U8              kl;                     /* Key length                */
; 307  : U16             dl;                     /* Data length               */
; 308  : 
; 309  :     /* Read the required track into the track buffer if necessary */
; 310  :     rc = read_track (cif, cyl, head);

  00017	44 0f b6 44 24
	60		 movzx	 r8d, BYTE PTR head$[rsp]
  0001d	8b 54 24 58	 mov	 edx, DWORD PTR cyl$[rsp]
  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cif$[rsp]
  00026	e8 00 00 00 00	 call	 read_track
  0002b	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 311  :     if (rc < 0) return -1;

  0002f	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00034	7d 0a		 jge	 SHORT $LN4@read_block
  00036	b8 ff ff ff ff	 mov	 eax, -1
  0003b	e9 34 01 00 00	 jmp	 $LN1@read_block
$LN4@read_block:

; 312  : 
; 313  :     /* Search for the requested record in the track buffer */
; 314  :     ptr = cif->trkbuf;

  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR cif$[rsp]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	48 89 44 24 30	 mov	 QWORD PTR ptr$[rsp], rax

; 315  :     ptr += CKD_TRKHDR_SIZE;

  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR ptr$[rsp]
  00053	48 83 c0 05	 add	 rax, 5
  00057	48 89 44 24 30	 mov	 QWORD PTR ptr$[rsp], rax
$LN2@read_block:

; 316  : 
; 317  :     while (1)

  0005c	33 c0		 xor	 eax, eax
  0005e	83 f8 01	 cmp	 eax, 1
  00061	0f 84 9e 00 00
	00		 je	 $LN3@read_block

; 318  :     {
; 319  :         /* Exit with record not found if end of track */
; 320  :         if (memcmp( ptr, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  00067	41 b8 08 00 00
	00		 mov	 r8d, 8
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  00079	e8 00 00 00 00	 call	 memcmp
  0007e	85 c0		 test	 eax, eax
  00080	75 0a		 jne	 SHORT $LN5@read_block

; 321  :             return +1;

  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	e9 e8 00 00 00	 jmp	 $LN1@read_block
$LN5@read_block:

; 322  : 
; 323  :         /* Extract key length and data length from count field */
; 324  :         rechdr = (CKD_RECHDR*)ptr;

  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR ptr$[rsp]
  00091	48 89 44 24 38	 mov	 QWORD PTR rechdr$[rsp], rax

; 325  :         kl = rechdr->klen;

  00096	48 8b 44 24 38	 mov	 rax, QWORD PTR rechdr$[rsp]
  0009b	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0009f	88 44 24 20	 mov	 BYTE PTR kl$[rsp], al

; 326  :         dl = (rechdr->dlen[0] << 8) | rechdr->dlen[1];

  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	48 6b c0 00	 imul	 rax, rax, 0
  000ac	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000b1	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  000b6	c1 e0 08	 shl	 eax, 8
  000b9	b9 01 00 00 00	 mov	 ecx, 1
  000be	48 6b c9 01	 imul	 rcx, rcx, 1
  000c2	48 8b 54 24 38	 mov	 rdx, QWORD PTR rechdr$[rsp]
  000c7	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  000cc	0b c1		 or	 eax, ecx
  000ce	66 89 44 24 24	 mov	 WORD PTR dl$[rsp], ax

; 327  : 
; 328  :         /* Exit if requested record number found */
; 329  :         if (rechdr->rec == rec)

  000d3	48 8b 44 24 38	 mov	 rax, QWORD PTR rechdr$[rsp]
  000d8	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000dc	0f b6 4c 24 68	 movzx	 ecx, BYTE PTR rec$[rsp]
  000e1	3b c1		 cmp	 eax, ecx
  000e3	75 02		 jne	 SHORT $LN6@read_block

; 330  :             break;

  000e5	eb 1e		 jmp	 SHORT $LN3@read_block
$LN6@read_block:

; 331  : 
; 332  :         /* Issue progress message */
; 333  : //      FLOGMSG( stdout,
; 334  : //               "Skipping CCHHR=%2.2X%2.2X%2.2X%2.2X"
; 335  : //               "%2.2X KL=%2.2X DL=%2.2X%2.2X\n",
; 336  : //               rechdr->cyl[0], rechdr->cyl[1],
; 337  : //               rechdr->head[0], rechdr->head[1],
; 338  : //               rechdr->rec, rechdr->klen,
; 339  : //               rechdr->dlen[0], rechdr->dlen[1] );
; 340  : 
; 341  :         /* Point past count key and data to next block */
; 342  :         ptr += CKD_RECHDR_SIZE + kl + dl;

  000e7	0f b6 44 24 20	 movzx	 eax, BYTE PTR kl$[rsp]
  000ec	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dl$[rsp]
  000f1	48 03 4c 24 30	 add	 rcx, QWORD PTR ptr$[rsp]
  000f6	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000fb	48 89 44 24 30	 mov	 QWORD PTR ptr$[rsp], rax

; 343  :     }

  00100	e9 57 ff ff ff	 jmp	 $LN2@read_block
$LN3@read_block:

; 344  : 
; 345  :     /* Return key and data pointers and lengths */
; 346  :     if (keyptr != NULL) *keyptr = ptr + CKD_RECHDR_SIZE;

  00105	48 83 7c 24 70
	00		 cmp	 QWORD PTR keyptr$[rsp], 0
  0010b	74 11		 je	 SHORT $LN7@read_block
  0010d	48 8b 44 24 30	 mov	 rax, QWORD PTR ptr$[rsp]
  00112	48 83 c0 08	 add	 rax, 8
  00116	48 8b 4c 24 70	 mov	 rcx, QWORD PTR keyptr$[rsp]
  0011b	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN7@read_block:

; 347  :     if (keylen != NULL) *keylen = kl;

  0011e	48 83 7c 24 78
	00		 cmp	 QWORD PTR keylen$[rsp], 0
  00124	74 0c		 je	 SHORT $LN8@read_block
  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR keylen$[rsp]
  0012b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR kl$[rsp]
  00130	88 08		 mov	 BYTE PTR [rax], cl
$LN8@read_block:

; 348  :     if (dataptr != NULL) *dataptr = ptr + CKD_RECHDR_SIZE + kl;

  00132	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dataptr$[rsp], 0
  0013b	74 1a		 je	 SHORT $LN9@read_block
  0013d	0f b6 44 24 20	 movzx	 eax, BYTE PTR kl$[rsp]
  00142	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  00147	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0014c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dataptr$[rsp]
  00154	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@read_block:

; 349  :     if (datalen != NULL) *datalen = dl;

  00157	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR datalen$[rsp], 0
  00160	74 10		 je	 SHORT $LN10@read_block
  00162	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR datalen$[rsp]
  0016a	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dl$[rsp]
  0016f	66 89 08	 mov	 WORD PTR [rax], cx
$LN10@read_block:

; 350  :     return 0;

  00172	33 c0		 xor	 eax, eax
$LN1@read_block:

; 351  : 
; 352  : } /* end function read_block */

  00174	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00178	c3		 ret	 0
read_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
unitstat$ = 96
trk$ = 100
rc$ = 104
dev$ = 112
tv83 = 120
tv87 = 124
tv146 = 128
tv151 = 132
tv155 = 136
tv169 = 140
tv175 = 144
tv179 = 148
tv201 = 152
tv206 = 156
tv210 = 160
cif$ = 192
cyl$ = 200
head$ = 208
read_track PROC

; 236  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 237  : int             rc;                     /* Return code               */
; 238  : U32             trk;                    /* Track number              */
; 239  : DEVBLK         *dev;                    /* -> CKD device block       */
; 240  : BYTE            unitstat;               /* Unit status               */
; 241  : 
; 242  :     /* Exit if required track is already in buffer */
; 243  :     if (cif->curcyl == cyl && cif->curhead == head)

  00015	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0001d	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00024	39 48 18	 cmp	 DWORD PTR [rax+24], ecx
  00027	75 1c		 jne	 SHORT $LN2@read_track
  00029	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR head$[rsp]
  00031	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00039	39 41 1c	 cmp	 DWORD PTR [rcx+28], eax
  0003c	75 07		 jne	 SHORT $LN2@read_track

; 244  :         return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 16 04 00 00	 jmp	 $LN1@read_track
$LN2@read_track:

; 245  : 
; 246  :     dev = &cif->devblk;

  00045	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0004d	48 83 c0 30	 add	 rax, 48			; 00000030H
  00051	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax

; 247  : 
; 248  :     if (cif->trkmodif)

  00056	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0005e	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00062	0f 84 e8 01 00
	00		 je	 $LN3@read_track

; 249  :     {
; 250  :         cif->trkmodif = 0;

  00068	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00070	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 251  :         if (is_verbose_util()) /* Issue progress message */

  00077	e8 00 00 00 00	 call	 is_verbose_util
  0007c	0f b6 c0	 movzx	 eax, al
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 a7 00 00
	00		 je	 $LN4@read_track

; 252  :             FWRMSG( stdout, HHC00445, "I", SSID_TO_LCSS(cif->devblk.ssid),

  00087	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0008f	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00093	89 44 24 78	 mov	 DWORD PTR tv83[rsp], eax
  00097	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0009f	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  000a3	d1 f9		 sar	 ecx, 1
  000a5	89 4c 24 7c	 mov	 DWORD PTR tv87[rsp], ecx
  000a9	b9 01 00 00 00	 mov	 ecx, 1
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000bc	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  000bf	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  000c3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000cb	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  000ce	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000d2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000da	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000dd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e2	8b 4c 24 78	 mov	 ecx, DWORD PTR tv83[rsp]
  000e6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000ea	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv87[rsp]
  000ee	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168777
  000f9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168778
  00105	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00115	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168779
  0011c	ba fd 00 00 00	 mov	 edx, 253		; 000000fdH
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168780
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@read_track:

; 253  :                 cif->devblk.devnum, cif->fname, cif->curcyl, cif->curhead );
; 254  :         trk = (cif->curcyl * cif->heads) + cif->curhead;

  0012e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00136	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0013e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00141	0f af 41 24	 imul	 eax, DWORD PTR [rcx+36]
  00145	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0014d	03 41 1c	 add	 eax, DWORD PTR [rcx+28]
  00150	89 44 24 64	 mov	 DWORD PTR trk$[rsp], eax

; 255  :         rc = (dev->hnd->write)(dev, trk, 0, NULL, cif->trksz, &unitstat);

  00154	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00159	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00160	48 8d 4c 24 60	 lea	 rcx, QWORD PTR unitstat$[rsp]
  00165	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00172	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00175	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00179	45 33 c9	 xor	 r9d, r9d
  0017c	45 33 c0	 xor	 r8d, r8d
  0017f	8b 54 24 64	 mov	 edx, DWORD PTR trk$[rsp]
  00183	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00188	ff 50 58	 call	 QWORD PTR [rax+88]
  0018b	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 256  :         if (rc < 0)

  0018f	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00194	0f 8d b6 00 00
	00		 jge	 $LN5@read_track

; 257  :         {
; 258  :             FWRMSG( stderr, HHC00446, "E", SSID_TO_LCSS(cif->devblk.ssid),

  0019a	0f b6 44 24 60	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0019f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv146[rsp], eax
  001a6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  001ae	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  001b2	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv151[rsp], ecx
  001b9	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  001c1	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  001c5	d1 fa		 sar	 edx, 1
  001c7	89 94 24 88 00
	00 00		 mov	 DWORD PTR tv155[rsp], edx
  001ce	b9 02 00 00 00	 mov	 ecx, 2
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d9	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv146[rsp]
  001e0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  001e4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  001ec	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001ef	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001f4	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv151[rsp]
  001fb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001ff	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv155[rsp]
  00206	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0020a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168782
  00211	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168783
  0021d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00222	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00227	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168784
  00234	ba 03 01 00 00	 mov	 edx, 259		; 00000103H
  00239	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168785
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 259  :                 cif->devblk.devnum, cif->fname, unitstat );
; 260  :             return -1;

  00246	b8 ff ff ff ff	 mov	 eax, -1
  0024b	e9 0b 02 00 00	 jmp	 $LN1@read_track
$LN5@read_track:
$LN3@read_track:

; 261  :         }
; 262  :     }
; 263  : 
; 264  :     if (is_verbose_util()) /* Issue progress message */

  00250	e8 00 00 00 00	 call	 is_verbose_util
  00255	0f b6 c0	 movzx	 eax, al
  00258	85 c0		 test	 eax, eax
  0025a	0f 84 ba 00 00
	00		 je	 $LN6@read_track

; 265  :         FWRMSG( stdout, HHC00447, "I", SSID_TO_LCSS(cif->devblk.ssid),

  00260	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR head$[rsp]
  00268	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv169[rsp], eax
  0026f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00277	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  0027b	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv175[rsp], ecx
  00282	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  0028a	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  0028e	d1 fa		 sar	 edx, 1
  00290	89 94 24 94 00
	00 00		 mov	 DWORD PTR tv179[rsp], edx
  00297	b9 01 00 00 00	 mov	 ecx, 1
  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a2	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv169[rsp]
  002a9	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002ad	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  002b4	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002b8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  002c0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002c3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c8	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv175[rsp]
  002cf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d3	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  002da	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168787
  002e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168788
  002f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00301	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168789
  00308	ba 0a 01 00 00	 mov	 edx, 266		; 0000010aH
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168790
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@read_track:

; 266  :             cif->devblk.devnum, cif->fname, cyl, head );
; 267  : 
; 268  :     trk = (cyl * cif->heads) + head;

  0031a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00322	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00329	0f af 48 24	 imul	 ecx, DWORD PTR [rax+36]
  0032d	8b c1		 mov	 eax, ecx
  0032f	0f b6 8c 24 d0
	00 00 00	 movzx	 ecx, BYTE PTR head$[rsp]
  00337	03 c1		 add	 eax, ecx
  00339	89 44 24 64	 mov	 DWORD PTR trk$[rsp], eax

; 269  :     rc = (dev->hnd->read)(dev, trk, &unitstat);

  0033d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00342	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00349	4c 8d 44 24 60	 lea	 r8, QWORD PTR unitstat$[rsp]
  0034e	8b 54 24 64	 mov	 edx, DWORD PTR trk$[rsp]
  00352	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00357	ff 50 50	 call	 QWORD PTR [rax+80]
  0035a	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 270  :     if (rc < 0)

  0035e	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00363	0f 8d b3 00 00
	00		 jge	 $LN7@read_track

; 271  :     {
; 272  :         FWRMSG( stderr, HHC00448, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00369	0f b6 44 24 60	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0036e	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv201[rsp], eax
  00375	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0037d	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  00381	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv206[rsp], ecx
  00388	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  00390	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  00394	d1 fa		 sar	 edx, 1
  00396	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv210[rsp], edx
  0039d	b9 02 00 00 00	 mov	 ecx, 2
  003a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003a8	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv201[rsp]
  003af	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  003b3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  003bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003be	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003c3	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  003ca	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003ce	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv210[rsp]
  003d5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168792
  003e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168793
  003ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f6	41 b9 03 00 00
	00		 mov	 r9d, 3
  003fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168794
  00403	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  00408	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168795
  0040f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 273  :             cif->devblk.devnum, cif->fname, unitstat );
; 274  :         return -1;

  00415	b8 ff ff ff ff	 mov	 eax, -1
  0041a	eb 3f		 jmp	 SHORT $LN1@read_track
$LN7@read_track:

; 275  :     }
; 276  : 
; 277  :     /* Set current buf, cylinder and head */
; 278  :     cif->trkbuf = dev->buf;

  0041c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00424	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00429	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00430	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 279  :     cif->curcyl = cyl;

  00434	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0043c	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00443	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 280  :     cif->curhead = head;

  00446	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR head$[rsp]
  0044e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00456	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 281  : 
; 282  :     return 0;

  00459	33 c0		 xor	 eax, eax
$LN1@read_track:

; 283  : } /* end function read_track */

  0045b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00462	c3		 ret	 0
read_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
addr$ = 48
len$ = 56
offset$ = 64
data_dump_offset_ascii PROC

; 219  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 220  :     do_data_dump( true, addr, len, offset );

  00012	44 8b 4c 24 40	 mov	 r9d, DWORD PTR offset$[rsp]
  00017	44 8b 44 24 38	 mov	 r8d, DWORD PTR len$[rsp]
  0001c	48 8b 54 24 30	 mov	 rdx, QWORD PTR addr$[rsp]
  00021	b1 01		 mov	 cl, 1
  00023	e8 00 00 00 00	 call	 do_data_dump

; 221  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
data_dump_offset_ascii ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
addr$ = 48
len$ = 56
offset$ = 64
data_dump_offset PROC

; 214  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 215  :     do_data_dump( false, addr, len, offset );

  00012	44 8b 4c 24 40	 mov	 r9d, DWORD PTR offset$[rsp]
  00017	44 8b 44 24 38	 mov	 r8d, DWORD PTR len$[rsp]
  0001c	48 8b 54 24 30	 mov	 rdx, QWORD PTR addr$[rsp]
  00021	33 c9		 xor	 ecx, ecx
  00023	e8 00 00 00 00	 call	 do_data_dump

; 216  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
data_dump_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
addr$ = 48
len$ = 56
data_dump_ascii PROC

; 209  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 210  :     do_data_dump( true, addr, len, 0 );

  0000d	45 33 c9	 xor	 r9d, r9d
  00010	44 8b 44 24 38	 mov	 r8d, DWORD PTR len$[rsp]
  00015	48 8b 54 24 30	 mov	 rdx, QWORD PTR addr$[rsp]
  0001a	b1 01		 mov	 cl, 1
  0001c	e8 00 00 00 00	 call	 do_data_dump

; 211  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
data_dump_ascii ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
addr$ = 48
len$ = 56
data_dump PROC

; 204  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 205  :     do_data_dump( false, addr, len, 0 );

  0000d	45 33 c9	 xor	 r9d, r9d
  00010	44 8b 44 24 38	 mov	 r8d, DWORD PTR len$[rsp]
  00015	48 8b 54 24 30	 mov	 rdx, QWORD PTR addr$[rsp]
  0001a	33 c9		 xor	 ecx, ecx
  0001c	e8 00 00 00 00	 call	 do_data_dump

; 206  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
data_dump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
fba$1 = 32
ckd$2 = 40
buf$ = 64
volser$ = 72
owner$ = 80
ckddasd$ = 88
build_vol1 PROC

; 57   : {

$LN6:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 58   :     if (!owner)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR owner$[rsp], 0
  0001e	75 0c		 jne	 SHORT $LN2@build_vol1

; 59   :         owner = HERC_OWNERA;

  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168667
  00027	48 89 44 24 50	 mov	 QWORD PTR owner$[rsp], rax
$LN2@build_vol1:

; 60   : 
; 61   :     if (ckddasd)

  0002c	0f b6 44 24 58	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00031	85 c0		 test	 eax, eax
  00033	0f 84 d4 00 00
	00		 je	 $LN3@build_vol1

; 62   :     {
; 63   :         VOL1_CKD*  ckd  = buf;

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  0003e	48 89 44 24 28	 mov	 QWORD PTR ckd$2[rsp], rax

; 64   : 
; 65   :         memcpy( ckd->vol1, VOL1_KEY, sizeof( ckd->vol1 ));

  00043	48 8b 44 24 28	 mov	 rax, QWORD PTR ckd$2[rsp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR VOL1_KEY
  0004e	89 08		 mov	 DWORD PTR [rax], ecx

; 66   :         convert_to_ebcdic( ckd->volser, sizeof( ckd->volser ), volser );

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR ckd$2[rsp]
  00055	48 83 c0 04	 add	 rax, 4
  00059	4c 8b 44 24 48	 mov	 r8, QWORD PTR volser$[rsp]
  0005e	ba 06 00 00 00	 mov	 edx, 6
  00063	48 8b c8	 mov	 rcx, rax
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 67   :         convert_to_ebcdic( ckd->owner,  sizeof( ckd->owner  ), owner  );

  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR ckd$2[rsp]
  00071	48 83 c0 25	 add	 rax, 37			; 00000025H
  00075	4c 8b 44 24 50	 mov	 r8, QWORD PTR owner$[rsp]
  0007a	ba 0e 00 00 00	 mov	 edx, 14
  0007f	48 8b c8	 mov	 rcx, rax
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 68   : 
; 69   :         ckd->security = 0xC0;

  00088	48 8b 44 24 28	 mov	 rax, QWORD PTR ckd$2[rsp]
  0008d	c6 40 0a c0	 mov	 BYTE PTR [rax+10], 192	; 000000c0H

; 70   : 
; 71   :         store_hw( ckd->vtoc_CC, 0 );

  00091	33 c9		 xor	 ecx, ecx
  00093	e8 00 00 00 00	 call	 _byteswap_ushort
  00098	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ckd$2[rsp]
  0009d	48 83 c1 0b	 add	 rcx, 11
  000a1	0f b7 d0	 movzx	 edx, ax
  000a4	e8 00 00 00 00	 call	 store_hw_noswap

; 72   :         store_hw( ckd->vtoc_HH, 1 );

  000a9	66 b9 01 00	 mov	 cx, 1
  000ad	e8 00 00 00 00	 call	 _byteswap_ushort
  000b2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ckd$2[rsp]
  000b7	48 83 c1 0d	 add	 rcx, 13
  000bb	0f b7 d0	 movzx	 edx, ax
  000be	e8 00 00 00 00	 call	 store_hw_noswap

; 73   :                   ckd->vtoc_R = 1;

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR ckd$2[rsp]
  000c8	c6 40 0f 01	 mov	 BYTE PTR [rax+15], 1

; 74   : 
; 75   :         convert_to_ebcdic( ckd->rsrvd3, sizeof( ckd->rsrvd3 ), "" );

  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR ckd$2[rsp]
  000d1	48 83 c0 10	 add	 rax, 16
  000d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168670
  000dc	ba 15 00 00 00	 mov	 edx, 21
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 76   :         convert_to_ebcdic( ckd->rsrvd4, sizeof( ckd->rsrvd4 ), "" );

  000ea	48 8b 44 24 28	 mov	 rax, QWORD PTR ckd$2[rsp]
  000ef	48 83 c0 33	 add	 rax, 51			; 00000033H
  000f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168671
  000fa	ba 1d 00 00 00	 mov	 edx, 29
  000ff	48 8b c8	 mov	 rcx, rax
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 77   :     }

  00108	e9 23 01 00 00	 jmp	 $LN4@build_vol1
$LN3@build_vol1:

; 78   :     else
; 79   :     {
; 80   :         VOL1_FBA*  fba  = buf;

  0010d	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  00112	48 89 44 24 20	 mov	 QWORD PTR fba$1[rsp], rax

; 81   : 
; 82   :         memcpy( fba->vol1, VOL1_KEY, sizeof( fba->vol1 ));

  00117	48 8b 44 24 20	 mov	 rax, QWORD PTR fba$1[rsp]
  0011c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR VOL1_KEY
  00122	89 08		 mov	 DWORD PTR [rax], ecx

; 83   :         convert_to_ebcdic( fba->volser, sizeof( fba->volser ), volser );

  00124	48 8b 44 24 20	 mov	 rax, QWORD PTR fba$1[rsp]
  00129	48 83 c0 04	 add	 rax, 4
  0012d	4c 8b 44 24 48	 mov	 r8, QWORD PTR volser$[rsp]
  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b c8	 mov	 rcx, rax
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 84   :         convert_to_ebcdic( fba->owner,  sizeof( fba->owner  ), owner  );

  00140	48 8b 44 24 20	 mov	 rax, QWORD PTR fba$1[rsp]
  00145	48 83 c0 25	 add	 rax, 37			; 00000025H
  00149	4c 8b 44 24 50	 mov	 r8, QWORD PTR owner$[rsp]
  0014e	ba 0e 00 00 00	 mov	 edx, 14
  00153	48 8b c8	 mov	 rcx, rax
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 85   : 
; 86   :         fba->security = 0xC0;

  0015c	48 8b 44 24 20	 mov	 rax, QWORD PTR fba$1[rsp]
  00161	c6 40 0a c0	 mov	 BYTE PTR [rax+10], 192	; 000000c0H

; 87   :         fba->rsrvd1 = 0;

  00165	48 8b 44 24 20	 mov	 rax, QWORD PTR fba$1[rsp]
  0016a	c6 40 0b 00	 mov	 BYTE PTR [rax+11], 0

; 88   : 
; 89   :         store_fw( fba->vtoc_block,    2 );

  0016e	b9 02 00 00 00	 mov	 ecx, 2
  00173	e8 00 00 00 00	 call	 _byteswap_ulong
  00178	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fba$1[rsp]
  0017d	48 83 c1 0c	 add	 rcx, 12
  00181	8b d0		 mov	 edx, eax
  00183	e8 00 00 00 00	 call	 store_fw_noswap

; 90   :         store_fw( fba->vtoc_cisz,  1024 );

  00188	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0018d	e8 00 00 00 00	 call	 _byteswap_ulong
  00192	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fba$1[rsp]
  00197	48 83 c1 15	 add	 rcx, 21
  0019b	8b d0		 mov	 edx, eax
  0019d	e8 00 00 00 00	 call	 store_fw_noswap

; 91   :         store_fw( fba->vtoc_seci,     2 );

  001a2	b9 02 00 00 00	 mov	 ecx, 2
  001a7	e8 00 00 00 00	 call	 _byteswap_ulong
  001ac	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fba$1[rsp]
  001b1	48 83 c1 19	 add	 rcx, 25
  001b5	8b d0		 mov	 edx, eax
  001b7	e8 00 00 00 00	 call	 store_fw_noswap

; 92   :         store_fw( fba->vtoc_slci,     7 );

  001bc	b9 07 00 00 00	 mov	 ecx, 7
  001c1	e8 00 00 00 00	 call	 _byteswap_ulong
  001c6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fba$1[rsp]
  001cb	48 83 c1 1d	 add	 rcx, 29
  001cf	8b d0		 mov	 edx, eax
  001d1	e8 00 00 00 00	 call	 store_fw_noswap

; 93   : 
; 94   :         convert_to_ebcdic( fba->rsrvd2, sizeof( fba->rsrvd2 ), "" );

  001d6	48 8b 44 24 20	 mov	 rax, QWORD PTR fba$1[rsp]
  001db	48 83 c0 10	 add	 rax, 16
  001df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168672
  001e6	ba 05 00 00 00	 mov	 edx, 5
  001eb	48 8b c8	 mov	 rcx, rax
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 95   :         convert_to_ebcdic( fba->rsrvd3, sizeof( fba->rsrvd3 ), "" );

  001f4	48 8b 44 24 20	 mov	 rax, QWORD PTR fba$1[rsp]
  001f9	48 83 c0 21	 add	 rax, 33			; 00000021H
  001fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168673
  00204	ba 04 00 00 00	 mov	 edx, 4
  00209	48 8b c8	 mov	 rcx, rax
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 96   :         convert_to_ebcdic( fba->rsrvd4, sizeof( fba->rsrvd4 ), "" );

  00212	48 8b 44 24 20	 mov	 rax, QWORD PTR fba$1[rsp]
  00217	48 83 c0 33	 add	 rax, 51			; 00000033H
  0021b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168674
  00222	ba 1d 00 00 00	 mov	 edx, 29
  00227	48 8b c8	 mov	 rcx, rax
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic
$LN4@build_vol1:

; 97   :     }
; 98   : }

  00230	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00234	c3		 ret	 0
build_vol1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil.c
_TEXT	SEGMENT
i$1 = 32
$T2 = 40
buf$ = 48
__$ArrayPad$ = 64
serial$ = 112
gen_dasd_serial PROC

; 37   : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 38   :     static char prev[12+1]    = {0};
; 39   :     char buf[12+1]            = {0};

  0001a	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  0001f	48 8b f8	 mov	 rdi, rax
  00022	33 c0		 xor	 eax, eax
  00024	b9 0d 00 00 00	 mov	 ecx, 13
  00029	f3 aa		 rep stosb
$LN4@gen_dasd_s:

; 40   :     do
; 41   :     {
; 42   :         int i;
; 43   :         for (i=0; i < 12; i++)

  0002b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00033	eb 0a		 jmp	 SHORT $LN7@gen_dasd_s
$LN5@gen_dasd_s:
  00035	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00039	ff c0		 inc	 eax
  0003b	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@gen_dasd_s:
  0003f	83 7c 24 20 0c	 cmp	 DWORD PTR i$1[rsp], 12
  00044	7d 1e		 jge	 SHORT $LN6@gen_dasd_s

; 44   :             buf[i] = '0' + (rand() % 10);

  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  0004c	99		 cdq
  0004d	b9 0a 00 00 00	 mov	 ecx, 10
  00052	f7 f9		 idiv	 ecx
  00054	8b c2		 mov	 eax, edx
  00056	83 c0 30	 add	 eax, 48			; 00000030H
  00059	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0005e	88 44 0c 30	 mov	 BYTE PTR buf$[rsp+rcx], al
  00062	eb d1		 jmp	 SHORT $LN5@gen_dasd_s
$LN6@gen_dasd_s:

; 45   :         buf[12] = 0;

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	48 6b c0 0c	 imul	 rax, rax, 12
  0006d	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  00072	48 83 7c 24 28
	0d		 cmp	 QWORD PTR $T2[rsp], 13
  00078	73 02		 jae	 SHORT $LN9@gen_dasd_s
  0007a	eb 05		 jmp	 SHORT $LN10@gen_dasd_s
$LN9@gen_dasd_s:
  0007c	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@gen_dasd_s:
  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR $T2[rsp]
  00086	c6 44 04 30 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 46   :     }
; 47   :     while (str_eq( buf, prev ));

  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?prev@?1??gen_dasd_serial@@9@9
  00092	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00097	e8 00 00 00 00	 call	 strcmp
  0009c	85 c0		 test	 eax, eax
  0009e	74 8b		 je	 SHORT $LN4@gen_dasd_s

; 48   :     memcpy( prev,   buf, 12 );

  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?prev@?1??gen_dasd_serial@@9@9
  000a7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b f1	 mov	 rsi, rcx
  000b2	b9 0c 00 00 00	 mov	 ecx, 12
  000b7	f3 a4		 rep movsb

; 49   :     memcpy( serial, buf, 12 );

  000b9	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  000be	48 8b 7c 24 70	 mov	 rdi, QWORD PTR serial$[rsp]
  000c3	48 8b f0	 mov	 rsi, rax
  000c6	b9 0c 00 00 00	 mov	 ecx, 12
  000cb	f3 a4		 rep movsb
$LN8@gen_dasd_s:

; 50   : }

  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d2	48 33 cc	 xor	 rcx, rsp
  000d5	e8 00 00 00 00	 call	 __security_check_cookie
  000da	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000de	5f		 pop	 rdi
  000df	5e		 pop	 rsi
  000e0	c3		 ret	 0
gen_dasd_serial ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
