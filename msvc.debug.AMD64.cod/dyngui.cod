; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	bDoneProcessing
PUBLIC	pcpu
PUBLIC	pTargetCPU_REGS
PUBLIC	prev_pcpu
PUBLIC	pPrevTargetCPU_REGS
PUBLIC	copyregs
PUBLIC	copysieregs
PUBLIC	pszInputBuff
PUBLIC	nInputBuffSize
PUBLIC	nInputLen
PUBLIC	pszCommandBuff
PUBLIC	nCommandBuffSize
PUBLIC	nCommandLen
PUBLIC	gui_version
PUBLIC	gui_forced_refresh
PUBLIC	gui_wants_gregs
PUBLIC	gui_wants_gregs64
PUBLIC	gui_wants_cregs
PUBLIC	gui_wants_cregs64
PUBLIC	gui_wants_aregs
PUBLIC	gui_wants_fregs
PUBLIC	gui_wants_fregs64
PUBLIC	gui_wants_devlist
PUBLIC	gui_wants_new_devlist
PUBLIC	gui_wants_aggregates
PUBLIC	gui_wants_cpupct
PUBLIC	gui_wants_cpupct_all
PUBLIC	prev_mips_rate
PUBLIC	prev_sios_rate
PUBLIC	prev_cpustate
PUBLIC	prev_instcount
PUBLIC	curr_instcount
_BSS	SEGMENT
bDoneProcessing DD 01H DUP (?)
	ALIGN	8

pTargetCPU_REGS DQ 01H DUP (?)
pPrevTargetCPU_REGS DQ 01H DUP (?)
copyregs DB	016080H DUP (?)
copysieregs DB	016080H DUP (?)
pszInputBuff DQ	01H DUP (?)
nInputLen DD	01H DUP (?)
	ALIGN	8

pszCommandBuff DQ 01H DUP (?)
nCommandLen DD	01H DUP (?)
	ALIGN	8

gui_version DQ	01H DUP (?)
gui_wants_gregs DB 01H DUP (?)
	ALIGN	4

gui_wants_gregs64 DB 01H DUP (?)
	ALIGN	4

gui_wants_cregs DB 01H DUP (?)
	ALIGN	4

gui_wants_cregs64 DB 01H DUP (?)
	ALIGN	4

gui_wants_aregs DB 01H DUP (?)
	ALIGN	4

gui_wants_fregs DB 01H DUP (?)
	ALIGN	4

gui_wants_fregs64 DB 01H DUP (?)
	ALIGN	4

gui_wants_devlist DB 01H DUP (?)
	ALIGN	4

gui_wants_cpupct DB 01H DUP (?)
	ALIGN	4

gui_wants_cpupct_all DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	prev_cpupct:DWORD:040H
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

prev_mips_rate DD 01H DUP (?)
prev_sios_rate DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	psw:BYTE:010H
COMM	prev_psw:BYTE:010H
COMM	wait_bit:BYTE
_DATA	ENDS
_BSS	SEGMENT
prev_instcount DQ 01H DUP (?)
curr_instcount DQ 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	prev_gr:DWORD:010H
COMM	prev_gr64:QWORD:010H
COMM	prev_cr:DWORD:010H
COMM	prev_cr64:QWORD:010H
COMM	prev_ar:DWORD:010H
COMM	prev_fpr:DWORD:010H
COMM	prev_fpr64:DWORD:020H
COMM	szQueryDeviceBuff:BYTE:0501H
COMM	gui_fprintf_lock:QWORD
_DATA	ENDS
_DATA	SEGMENT
pcpu	DD	07fffffffH
prev_pcpu DD	07fffffffH
nInputBuffSize DD 0401H
nCommandBuffSize DD 0401H
gui_forced_refresh DB 01H
gui_wants_new_devlist DB 01H
gui_wants_aggregates DB 01H
prev_cpustate DB 0ffH
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	vfprintf
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	Initialize
PUBLIC	ProcessingLoop
PUBLIC	Cleanup
PUBLIC	UpdateTargetCPU
PUBLIC	ReadInputData
PUBLIC	ProcessInputData
PUBLIC	gui_panel_command
PUBLIC	UpdateStatus
PUBLIC	HandleForcedRefresh
PUBLIC	UpdateCPUStatus
PUBLIC	UpdateRegisters
PUBLIC	UpdateDeviceStatus
PUBLIC	NewUpdateDevStats
PUBLIC	gui_fprintf
PUBLIC	CopyREGS
PUBLIC	gui_debug_cpu_state
PUBLIC	gui_debug_cd_cmd
PUBLIC	gui_panel_display
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_register_symbols_ep
PUBLIC	hdl_resolve_symbols_ep
PUBLIC	hdl_on_module_unload_ep
PUBLIC	__real@3ff1eb851eb851ec
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_atof:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_fileno:PROC
EXTRN	__imp_getcwd:PROC
EXTRN	__imp_chdir:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_set_thread_name:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_get_stdin_char:PROC
EXTRN	__imp_w32_set_thread_name:PROC
EXTRN	__imp_hdl_next:PROC
EXTRN	__imp_copy_psw:PROC
EXTRN	__imp_InternalHercCmd:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_panel_command:QWORD
EXTRN	__imp_debug_cd_cmd:QWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
fOutputStream DQ 01H DUP (?)
fStatusStream DQ 01H DUP (?)
?bLoading@?1??gui_debug_cpu_state@@9@9 DD 01H DUP (?)	; `gui_debug_cpu_state'::`2'::bLoading
?bStopped@?1??gui_debug_cpu_state@@9@9 DD 01H DUP (?)	; `gui_debug_cpu_state'::`2'::bStopped
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vfprintf DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$vfprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$Initialize DD imagerel $LN14
	DD	imagerel $LN14+566
	DD	imagerel $unwind$Initialize
$pdata$ProcessingLoop DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$ProcessingLoop
$pdata$Cleanup DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$Cleanup
$pdata$UpdateTargetCPU DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$UpdateTargetCPU
$pdata$ReadInputData DD imagerel $LN22
	DD	imagerel $LN22+432
	DD	imagerel $unwind$ReadInputData
$pdata$ProcessInputData DD imagerel $LN23
	DD	imagerel $LN23+568
	DD	imagerel $unwind$ProcessInputData
$pdata$gui_panel_command DD imagerel $LN43
	DD	imagerel $LN43+1700
	DD	imagerel $unwind$gui_panel_command
$pdata$UpdateStatus DD imagerel $LN33
	DD	imagerel $LN33+1095
	DD	imagerel $unwind$UpdateStatus
$pdata$HandleForcedRefresh DD imagerel $LN3
	DD	imagerel $LN3+381
	DD	imagerel $unwind$HandleForcedRefresh
$pdata$UpdateCPUStatus DD imagerel $LN26
	DD	imagerel $LN26+1567
	DD	imagerel $unwind$UpdateCPUStatus
$pdata$UpdateRegisters DD imagerel $LN87
	DD	imagerel $LN87+15100
	DD	imagerel $unwind$UpdateRegisters
$pdata$UpdateDeviceStatus DD imagerel $LN23
	DD	imagerel $LN23+894
	DD	imagerel $unwind$UpdateDeviceStatus
$pdata$NewUpdateDevStats DD imagerel $LN31
	DD	imagerel $LN31+1315
	DD	imagerel $unwind$NewUpdateDevStats
$pdata$gui_fprintf DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$gui_fprintf
$pdata$CopyREGS DD imagerel $LN13
	DD	imagerel $LN13+502
	DD	imagerel $unwind$CopyREGS
$pdata$gui_debug_cpu_state DD imagerel $LN20
	DD	imagerel $LN20+416
	DD	imagerel $unwind$gui_debug_cpu_state
$pdata$gui_debug_cd_cmd DD imagerel $LN13
	DD	imagerel $LN13+164
	DD	imagerel $unwind$gui_debug_cd_cmd
$pdata$gui_panel_display DD imagerel $LN6
	DD	imagerel $LN6+214
	DD	imagerel $unwind$gui_panel_display
$pdata$hdl_check_depends_ep DD imagerel $LN19
	DD	imagerel $LN19+194
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_register_symbols_ep DD imagerel $LN3
	DD	imagerel $LN3+141
	DD	imagerel $unwind$hdl_register_symbols_ep
$pdata$hdl_resolve_symbols_ep DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$hdl_resolve_symbols_ep
$pdata$hdl_on_module_unload_ep DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$hdl_on_module_unload_ep
pdata	ENDS
;	COMDAT __real@3ff1eb851eb851ec
CONST	SEGMENT
__real@3ff1eb851eb851ec DQ 03ff1eb851eb851ecr	; 1.12
CONST	ENDS
_DATA	SEGMENT
nInputStreamFileNum DD 0ffffffffH
gui_nounload DD	01H
$SG168304 DB	'%u', 00H
	ORG $+1
$SG168174 DB	'dyngui.c:142', 00H
	ORG $+3
$SG168176 DB	'dyngui.c:146', 00H
	ORG $+3
$SG168178 DB	'dyngui.c:154', 00H
	ORG $+3
$SG168182 DB	'dyngui.c:172', 00H
	ORG $+3
$SG168265 DB	'VERS=', 00H
	ORG $+2
$SG168267 DB	'SCD=', 00H
	ORG $+3
$SG168271 DB	'GREGS=', 00H
	ORG $+1
$SG168273 DB	'GREGS64=', 00H
	ORG $+3
$SG168275 DB	'CREGS=', 00H
	ORG $+1
$SG168529 DB	'E', 00H
	ORG $+2
$SG168277 DB	'CREGS64=', 00H
	ORG $+3
$SG168279 DB	'AREGS=', 00H
	ORG $+1
$SG168281 DB	'FREGS=', 00H
	ORG $+1
?bFirstBatch@?1??NewUpdateDevStats@@9@9 DD 01H		; `NewUpdateDevStats'::`2'::bFirstBatch
$SG168283 DB	'FREGS64=', 00H
	ORG $+3
$SG168297 DB	'%u.%u', 00H
	ORG $+2
$SG168544 DB	'DEV=X', 0aH, 00H
	ORG $+1
$SG168569 DB	'E', 00H
	ORG $+2
$SG168285 DB	'DEVLIST=', 00H
	ORG $+3
$SG168585 DB	'%s', 0aH, 00H
$SG168288 DB	'NEWDEVLIST=', 00H
$SG168680 DB	'I', 00H
	ORG $+2
$SG168291 DB	'MAINSTOR=', 00H
	ORG $+2
$SG168292 DB	'%llu', 00H
	ORG $+3
$SG168588 DB	'DEVX=', 0aH, 00H
	ORG $+1
$SG168684 DB	'I', 00H
	ORG $+2
$SG168293 DB	'**** sending: "MAINSTOR=%s"', 0aH, 00H
	ORG $+3
$SG168295 DB	'**** sending: "MAINSTOR=%s"', 0aH, 00H
	ORG $+3
$SG168296 DB	'MAINSTOR=%s', 0aH, 00H
	ORG $+3
$SG168298 DB	'**** sending: "MAINSIZE=%s"', 0aH, 00H
	ORG $+3
$SG168300 DB	'**** sending: "MAINSIZE=%s"', 0aH, 00H
	ORG $+3
$SG168301 DB	'MAINSIZE=%s', 0aH, 00H
	ORG $+3
$SG168305 DB	'**** (gui_version < 1.12): sending: "MAINSIZE=%s"', 0aH, 00H
	ORG $+5
$SG168307 DB	'**** (gui_version < 1.12): sending: "MAINSIZE=%s"', 0aH, 00H
	ORG $+1
$SG168308 DB	'%llu', 00H
	ORG $+7
$SG168309 DB	'**** (gui_version >= 1.12): sending: "MAINSIZE=%s"', 0aH
	DB	00H
	ORG $+4
$SG168311 DB	'**** (gui_version >= 1.12): sending: "MAINSIZE=%s"', 0aH
	DB	00H
	ORG $+4
$SG168312 DB	'MAINSIZE=%s', 0aH, 00H
	ORG $+3
$SG168314 DB	'CPUPCT=', 00H
$SG168316 DB	'CPUPCTALL=', 00H
	ORG $+5
$SG168319 DB	'AGGREGATE=', 00H
	ORG $+5
$SG168351 DB	'SYS=%c', 0aH, 00H
$SG168356 DB	'CPUPCT=%d', 0aH, 00H
	ORG $+5
$SG168357 DB	'CPUPCT=%d', 0aH, 00H
	ORG $+5
$SG168363 DB	'CPUPCT%02d=%d', 0aH, 00H
	ORG $+1
$SG168385 DB	'MIPS=%4d.%2.2d', 0aH, 00H
$SG168531 DB	'UpdateDeviceStatus', 00H
	ORG $+5
$SG168380 DB	'STATUS=%s%02X (((((((((((((((((((((((( OFFLINE )))))))))'
	DB	')))))))))))))))', 0aH, 00H
	ORG $+7
$SG168381 DB	'STATUS=%s%02X PSW=%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2'
	DB	'.2X %2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X %c%c%c%c%c%c%c%c'
	DB	' instcount=%llu', 0aH, 00H
	ORG $+2
$SG168387 DB	'SIOS=%4d', 0aH, 00H
	ORG $+6
$SG168393 DB	'GR0-3=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168396 DB	'GR4-7=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168399 DB	'GR8-B=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168402 DB	'GRC-F=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168406 DB	'64_GR0-1=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168409 DB	'64_GR2-3=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168412 DB	'64_GR4-5=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168415 DB	'64_GR6-7=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168418 DB	'64_GR8-9=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168421 DB	'64_GRA-B=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168424 DB	'64_GRC-D=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168427 DB	'64_GRE-F=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168431 DB	'CR0-3=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168434 DB	'CR4-7=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168437 DB	'CR8-B=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168440 DB	'CRC-F=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168444 DB	'64_CR0-1=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168447 DB	'64_CR2-3=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168450 DB	'64_CR4-5=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168453 DB	'64_CR6-7=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168456 DB	'64_CR8-9=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168459 DB	'64_CRA-B=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168462 DB	'64_CRC-D=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168465 DB	'64_CRE-F=%16.16llX %16.16llX', 0aH, 00H
	ORG $+2
$SG168469 DB	'AR0-3=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168472 DB	'AR4-7=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168475 DB	'AR8-B=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168478 DB	'ARC-F=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168482 DB	'FR0-2=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168485 DB	'FR4-6=%8.8X %8.8X %8.8X %8.8X', 0aH, 00H
	ORG $+1
$SG168489 DB	'64_FR0-1=%8.8X%8.8X %8.8X%8.8X', 0aH, 00H
$SG168492 DB	'64_FR2-3=%8.8X%8.8X %8.8X%8.8X', 0aH, 00H
$SG168495 DB	'64_FR4-5=%8.8X%8.8X %8.8X%8.8X', 0aH, 00H
$SG168498 DB	'64_FR6-7=%8.8X%8.8X %8.8X%8.8X', 0aH, 00H
$SG168501 DB	'64_FR8-9=%8.8X%8.8X %8.8X%8.8X', 0aH, 00H
$SG168504 DB	'64_FRA-B=%8.8X%8.8X %8.8X%8.8X', 0aH, 00H
$SG168507 DB	'64_FRC-D=%8.8X%8.8X %8.8X%8.8X', 0aH, 00H
$SG168510 DB	'64_FRE-F=%8.8X%8.8X %8.8X%8.8X', 0aH, 00H
$SG168530 DB	'HHC01540%s HDL: query buffer overflow for device %1d:%04'
	DB	'X', 0aH, 00H
	ORG $+5
$SG168532 DB	'dyngui.c', 00H
	ORG $+7
$SG168542 DB	'DEV=0000 SYSG %-4.4s %c%c%c%c %s', 0aH, 00H
	ORG $+6
$SG168543 DB	'DEV=%4.4X %4.4X %-4.4s %c%c%c%c %s', 0aH, 00H
	ORG $+4
$SG168567 DB	'DEVD=%4.4X', 0aH, 00H
	ORG $+4
$SG168570 DB	'HHC01540%s HDL: query buffer overflow for device %1d:%04'
	DB	'X', 0aH, 00H
	ORG $+5
$SG168571 DB	'NewUpdateDevStats', 00H
	ORG $+6
$SG168572 DB	'dyngui.c', 00H
	ORG $+7
$SG168582 DB	'DEV%c=0000 SYSG %-4.4s %c%c%c%c %s', 00H
	ORG $+5
$SG168583 DB	'DEV%c=%4.4X %4.4X %-4.4s %c%c%c%c %s', 00H
	ORG $+3
$SG168605 DB	'LOAD=%c', 0aH, 00H
	ORG $+7
$SG168607 DB	'MAN=%c', 0aH, 00H
$SG168621 DB	'gui_debug_cd_cmd', 00H
	ORG $+7
$SG168622 DB	'dyngui.c', 00H
	ORG $+7
$SG168623 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168625 DB	'gui_debug_cd_cmd', 00H
	ORG $+7
$SG168626 DB	'dyngui.c', 00H
	ORG $+7
$SG168627 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168630 DB	']CWD=%s', 0aH, 00H
	ORG $+7
$SG168639 DB	'dyngui.c:1980', 00H
	ORG $+2
$SG168640 DB	'dyngui.c:1983', 00H
	ORG $+2
$SG168651 DB	'NoCmd', 00H
	ORG $+2
$SG168652 DB	'quiet', 00H
	ORG $+2
$SG168653 DB	'$zapcmd', 00H
$SG168654 DB	'%s %s %s', 00H
	ORG $+7
$SG168656 DB	'Initialize', 00H
	ORG $+5
$SG168657 DB	'dyngui.c', 00H
	ORG $+7
$SG168658 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168660 DB	'Initialize', 00H
	ORG $+5
$SG168661 DB	'dyngui.c', 00H
	ORG $+7
$SG168665 DB	'HHC90000D DBG: malloc() pszInputBuff failed: %s', 0aH, 00H
	ORG $+7
$SG168662 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168667 DB	'HHC90000D DBG: malloc() pszCommandBuff failed: %s', 0aH, 00H
	ORG $+1
$SG168678 DB	'dyngui', 00H
	ORG $+1
$SG168679 DB	'dyngui', 00H
	ORG $+5
$SG168681 DB	'HHC01541%s HDL: dyngui.dll initiated', 0aH, 00H
	ORG $+2
$SG168682 DB	'gui_panel_display', 00H
	ORG $+6
$SG168683 DB	'dyngui.c', 00H
	ORG $+7
$SG168685 DB	'HHC01542%s HDL: dyngui.dll terminated', 0aH, 00H
	ORG $+1
$SG168686 DB	'gui_panel_display', 00H
	ORG $+6
$SG168687 DB	'dyngui.c', 00H
	ORG $+7
$SG168709 DB	'SDL 4.60', 00H
	ORG $+7
$SG168710 DB	'HERCULES', 00H
	ORG $+7
$SG168712 DB	'SDL 4.2', 00H
$SG168713 DB	'SYSBLK', 00H
	ORG $+1
$SG168715 DB	'SDL 4.00', 00H
	ORG $+3
$SG168716 DB	'REGS', 00H
	ORG $+7
$SG168718 DB	'SDL 4.00', 00H
	ORG $+3
$SG168719 DB	'DEVBLK', 00H
	ORG $+5
$SG168729 DB	'dyngui.c:2120', 00H
	ORG $+2
$SG168730 DB	'&gui_fprintf_lock', 00H
	ORG $+6
$SG168731 DB	'panel_display', 00H
	ORG $+2
$SG168732 DB	'daemon_task', 00H
	ORG $+4
$SG168733 DB	'debug_cpu_state', 00H
$SG168734 DB	'debug_cd_cmd', 00H
	ORG $+3
$SG168735 DB	'panel_command', 00H
	ORG $+2
$SG168740 DB	'panel_command', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:gui_panel_command
	DD	017H
	DD	068bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:Initialize
	DD	013H
	DD	021dH
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$Initialize DD 031b19H
	DD	01c0109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$ProcessingLoop DD 010401H
	DD	04204H
$unwind$Cleanup DD 010401H
	DD	04204H
$unwind$UpdateTargetCPU DD 010401H
	DD	04204H
$unwind$ReadInputData DD 010801H
	DD	0c208H
$unwind$ProcessInputData DD 030701H
	DD	07003a207H
	DD	06002H
$unwind$gui_panel_command DD 031f19H
	DD	012010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$UpdateStatus DD 030701H
	DD	07003a207H
	DD	06002H
$unwind$HandleForcedRefresh DD 010201H
	DD	07002H
$unwind$UpdateCPUStatus DD 0a1401H
	DD	02b0114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
$unwind$UpdateRegisters DD 010401H
	DD	06204H
$unwind$UpdateDeviceStatus DD 020701H
	DD	0110107H
$unwind$NewUpdateDevStats DD 020701H
	DD	0170107H
$unwind$gui_fprintf DD 011801H
	DD	06218H
$unwind$CopyREGS DD 030a01H
	DD	07006620aH
	DD	06005H
$unwind$gui_debug_cpu_state DD 010901H
	DD	08209H
$unwind$gui_debug_cd_cmd DD 010901H
	DD	04209H
$unwind$gui_panel_display DD 010401H
	DD	08204H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_register_symbols_ep DD 010901H
	DD	04209H
$unwind$hdl_resolve_symbols_ep DD 010901H
	DD	04209H
$unwind$hdl_on_module_unload_ep DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vfprintf DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
rc$ = 32
hdl_on_module_unload_ep PROC

; 2173 : HDL_FINAL_SECTION

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2174 : {
; 2175 :     rc = gui_nounload;              // (reject unloads once activated)

  0000c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gui_nounload
  00012	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2176 : 
; 2177 :     if (sysblk.shutdown)

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00023	c1 e8 0b	 shr	 eax, 11
  00026	83 e0 01	 and	 eax, 1
  00029	85 c0		 test	 eax, eax
  0002b	74 15		 je	 SHORT $LN2@hdl_on_mod

; 2178 :     {
; 2179 :         bDoneProcessing = TRUE;     // (tell main loop to stop processing)

  0002d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR bDoneProcessing, 1

; 2180 :         usleep(100000);             // (brief delay to give GUI time

  00037	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN2@hdl_on_mod:

; 2181 :                                     //  to display ALL shutdown msgs)
; 2182 :     }
; 2183 : }
; 2184 : END_FINAL_SECTION

  00042	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
hdl_on_module_unload_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
getsym$ = 48
hdl_resolve_symbols_ep PROC

; 2149 : HDL_RESOLVER_SECTION            // ("Resolve" needed entry-points)

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2150 : {
; 2151 :     //            Registered
; 2152 :     //            entry-points
; 2153 :     //            that we call
; 2154 :     HDL_RESOLVE ( panel_command );

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168740
  00010	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_panel_command
  0001b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2155 : 
; 2156 : #if !defined( _MSVC_ )
; 2157 :     //                    Our pointer-     Registered entry-
; 2158 :     //                    variable name    point value name
; 2159 :     HDL_RESOLVE_SYMPTR (  psysblk,         sysblk            );
; 2160 : #endif
; 2161 : }
; 2162 : END_RESOLVER_SECTION

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
hdl_resolve_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
regsym$ = 48
hdl_register_symbols_ep PROC

; 2115 : HDL_REGISTER_SECTION            // ("Register" our entry-points)

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2116 : {
; 2117 :     // Perform static module initialization...
; 2118 : 
; 2119 :     gui_nounload = 1;                       // (reject any unload attempt)

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR gui_nounload, 1

; 2120 :     initialize_lock( &gui_fprintf_lock );   // (initialize GUI fprintf LOCK)

  00013	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168729
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168730
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gui_fprintf_lock
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 2121 : 
; 2122 :     // Register all of our override entry-points...
; 2123 : 
; 2124 :     //             Hercules's       Our
; 2125 :     //             registered       overriding
; 2126 :     //             entry-point      entry-point
; 2127 :     //             name             value
; 2128 :     HDL_REGISTER ( panel_display,   gui_panel_display   );// (Yep! We override EITHER!)

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gui_panel_display
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168731
  0003c	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 2129 :     HDL_REGISTER ( daemon_task,     gui_panel_display   );// (Yep! We override EITHER!)

  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gui_panel_display
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168732
  0004e	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 2130 :     HDL_REGISTER ( debug_cpu_state, gui_debug_cpu_state );

  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gui_debug_cpu_state
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168733
  00060	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 2131 :     HDL_REGISTER ( debug_cd_cmd,    gui_debug_cd_cmd    );

  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gui_debug_cd_cmd
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168734
  00072	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 2132 :     HDL_REGISTER ( panel_command,   gui_panel_command   );

  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gui_panel_command
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168735
  00084	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 2133 : }
; 2134 : END_REGISTER_SECTION

  00088	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008c	c3		 ret	 0
hdl_register_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 2096 : HDL_DEPENDENCY_SECTION          // (define module dependencies)

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 2097 : 
; 2098 :     HDL_DEPENDENCY ( HERCULES );        // Hercules itself

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168709
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168710
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN14@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN14@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 2099 :     HDL_DEPENDENCY ( SYSBLK   );        // Master control block

  0003b	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168712
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168713
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN15@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN15@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 2100 :     HDL_DEPENDENCY ( REGS     );        // CPU regs and such

  00065	41 b8 80 60 01
	00		 mov	 r8d, 90240		; 00016080H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168715
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168716
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN16@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN16@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_
$LN13@hdl_check_:

; 2101 :     HDL_DEPENDENCY ( DEVBLK   );        // Device info block

  0008f	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168718
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168719
  000a3	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 08		 je	 SHORT $LN17@hdl_check_
  000ab	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN17@hdl_check_:
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 d6		 jne	 SHORT $LN13@hdl_check_

; 2102 : 
; 2103 : END_DEPENDENCY_SECTION

  000b9	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
gui_panel_display PROC

; 2054 : {

$LN6:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@gui_panel_:

; 2055 :     SET_THREAD_NAME( "dyngui" );    // (for debugging)

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168678
  00011	8b c8		 mov	 ecx, eax
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_set_thread_name
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168679
  00026	8b c8		 mov	 ecx, eax
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_name
  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 d0		 jne	 SHORT $LN4@gui_panel_

; 2056 :     WRMSG( HHC01541,"I" );          // "Dyngui.dll initiated"

  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168680
  00046	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168681
  00052	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00062	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168682
  00069	ba 08 08 00 00	 mov	 edx, 2056		; 00000808H
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168683
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2057 :     Initialize();                   // (acquire resources)

  0007b	e8 00 00 00 00	 call	 Initialize

; 2058 : 
; 2059 :     ProcessingLoop();               // PRIMARY PROCESSING LOOP... (does not

  00080	e8 00 00 00 00	 call	 ProcessingLoop

; 2060 :                                     // return until Hercules is terminated)
; 2061 : 
; 2062 :     Cleanup();                      // (relinquish resources)

  00085	e8 00 00 00 00	 call	 Cleanup

; 2063 :     WRMSG( HHC01542,"I" );          // "Dyngui.dll terminated"

  0008a	b9 01 00 00 00	 mov	 ecx, 1
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168684
  0009c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168685
  000a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168686
  000bf	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168687
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2064 : }

  000d1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d5	c3		 ret	 0
gui_panel_display ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
pszCWD$ = 48
gui_debug_cd_cmd PROC

; 1964 : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@gui_debug_:

; 1965 :     ASSERT( pszCWD );

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR pszCWD$[rsp], 0
  0000f	75 5c		 jne	 SHORT $LN8@gui_debug_
$LN7@gui_debug_:
  00011	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168621
  00018	41 b8 ad 07 00
	00		 mov	 r8d, 1965		; 000007adH
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168622
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168623
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00038	85 c0		 test	 eax, eax
  0003a	74 20		 je	 SHORT $LN9@gui_debug_
  0003c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168625
  00043	41 b8 ad 07 00
	00		 mov	 r8d, 1965		; 000007adH
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168626
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168627
  00057	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@gui_debug_:
  0005c	33 c0		 xor	 eax, eax
  0005e	85 c0		 test	 eax, eax
  00060	75 af		 jne	 SHORT $LN7@gui_debug_
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00068	85 c0		 test	 eax, eax
  0006a	74 01		 je	 SHORT $LN10@gui_debug_
  0006c	cc		 int	 3
$LN10@gui_debug_:
$LN8@gui_debug_:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 96		 jne	 SHORT $LN4@gui_debug_

; 1966 :     if (gui_version >= 1.12)

  00073	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR gui_version
  0007b	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff1eb851eb851ec
  00083	72 18		 jb	 SHORT $LN11@gui_debug_

; 1967 :         gui_fprintf( fStatusStream, "]CWD=%s\n", pszCWD );

  00085	4c 8b 44 24 30	 mov	 r8, QWORD PTR pszCWD$[rsp]
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168630
  00091	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00098	e8 00 00 00 00	 call	 gui_fprintf
$LN11@gui_debug_:

; 1968 :     return NULL;

  0009d	33 c0		 xor	 eax, eax

; 1969 : }

  0009f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a3	c3		 ret	 0
gui_debug_cd_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
tv74 = 32
tv80 = 36
tv82 = 40
tv91 = 44
tv128 = 48
tv130 = 52
next_debug_call$ = 56
pREGS$ = 80
gui_debug_cpu_state PROC

; 1928 : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1929 : void *(*next_debug_call)(REGS *);
; 1930 : 
; 1931 :     static BOOL bLoading = FALSE;
; 1932 :     static BOOL bStopped = FALSE;
; 1933 : 
; 1934 :     if (sysblk.shutdown) return NULL;

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00016	c1 e8 0b	 shr	 eax, 11
  00019	83 e0 01	 and	 eax, 1
  0001c	85 c0		 test	 eax, eax
  0001e	74 07		 je	 SHORT $LN2@gui_debug_
  00020	33 c0		 xor	 eax, eax
  00022	e9 74 01 00 00	 jmp	 $LN1@gui_debug_
$LN2@gui_debug_:

; 1935 : 
; 1936 :     if (pTargetCPU_REGS && pREGS != pTargetCPU_REGS)

  00027	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pTargetCPU_REGS, 0
  0002f	74 15		 je	 SHORT $LN3@gui_debug_
  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00038	48 39 44 24 50	 cmp	 QWORD PTR pREGS$[rsp], rax
  0003d	74 07		 je	 SHORT $LN3@gui_debug_

; 1937 :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 55 01 00 00	 jmp	 $LN1@gui_debug_
$LN3@gui_debug_:

; 1938 : 
; 1939 :     if (bLoading != (pREGS->loadstate ? TRUE : FALSE))

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR pREGS$[rsp]
  0004b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00051	c1 e8 0c	 shr	 eax, 12
  00054	83 e0 01	 and	 eax, 1
  00057	85 c0		 test	 eax, eax
  00059	74 0a		 je	 SHORT $LN8@gui_debug_
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00063	eb 08		 jmp	 SHORT $LN9@gui_debug_
$LN8@gui_debug_:
  00065	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN9@gui_debug_:
  0006d	8b 44 24 20	 mov	 eax, DWORD PTR tv74[rsp]
  00071	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bLoading@?1??gui_debug_cpu_state@@9@9, eax
  00077	74 6b		 je	 SHORT $LN4@gui_debug_

; 1940 :     {
; 1941 :         bLoading  = (pREGS->loadstate ? TRUE : FALSE);

  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR pREGS$[rsp]
  0007e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00084	c1 e8 0c	 shr	 eax, 12
  00087	83 e0 01	 and	 eax, 1
  0008a	85 c0		 test	 eax, eax
  0008c	74 0a		 je	 SHORT $LN10@gui_debug_
  0008e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00096	eb 08		 jmp	 SHORT $LN11@gui_debug_
$LN10@gui_debug_:
  00098	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN11@gui_debug_:
  000a0	8b 44 24 24	 mov	 eax, DWORD PTR tv80[rsp]
  000a4	89 05 00 00 00
	00		 mov	 DWORD PTR ?bLoading@?1??gui_debug_cpu_state@@9@9, eax

; 1942 :         gui_fprintf(stdout,"LOAD=%c\n", bLoading ? '1' : '0');

  000aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bLoading@?1??gui_debug_cpu_state@@9@9, 0
  000b1	74 0a		 je	 SHORT $LN12@gui_debug_
  000b3	c7 44 24 28 31
	00 00 00	 mov	 DWORD PTR tv82[rsp], 49	; 00000031H
  000bb	eb 08		 jmp	 SHORT $LN13@gui_debug_
$LN12@gui_debug_:
  000bd	c7 44 24 28 30
	00 00 00	 mov	 DWORD PTR tv82[rsp], 48	; 00000030H
$LN13@gui_debug_:
  000c5	b9 01 00 00 00	 mov	 ecx, 1
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d0	44 8b 44 24 28	 mov	 r8d, DWORD PTR tv82[rsp]
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168605
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 gui_fprintf
$LN4@gui_debug_:

; 1943 :     }
; 1944 : 
; 1945 :     if (bStopped != ((CPUSTATE_STOPPED == pREGS->cpustate) ? TRUE : FALSE))

  000e4	48 8b 44 24 50	 mov	 rax, QWORD PTR pREGS$[rsp]
  000e9	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  000ed	83 f8 03	 cmp	 eax, 3
  000f0	75 0a		 jne	 SHORT $LN14@gui_debug_
  000f2	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000fa	eb 08		 jmp	 SHORT $LN15@gui_debug_
$LN14@gui_debug_:
  000fc	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN15@gui_debug_:
  00104	8b 44 24 2c	 mov	 eax, DWORD PTR tv91[rsp]
  00108	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bStopped@?1??gui_debug_cpu_state@@9@9, eax
  0010e	74 64		 je	 SHORT $LN5@gui_debug_

; 1946 :     {
; 1947 :         bStopped  = ((CPUSTATE_STOPPED == pREGS->cpustate) ? TRUE : FALSE);

  00110	48 8b 44 24 50	 mov	 rax, QWORD PTR pREGS$[rsp]
  00115	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00119	83 f8 03	 cmp	 eax, 3
  0011c	75 0a		 jne	 SHORT $LN16@gui_debug_
  0011e	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  00126	eb 08		 jmp	 SHORT $LN17@gui_debug_
$LN16@gui_debug_:
  00128	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN17@gui_debug_:
  00130	8b 44 24 30	 mov	 eax, DWORD PTR tv128[rsp]
  00134	89 05 00 00 00
	00		 mov	 DWORD PTR ?bStopped@?1??gui_debug_cpu_state@@9@9, eax

; 1948 :         gui_fprintf(stdout,"MAN=%c\n", bStopped ? '1' : '0');

  0013a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bStopped@?1??gui_debug_cpu_state@@9@9, 0
  00141	74 0a		 je	 SHORT $LN18@gui_debug_
  00143	c7 44 24 34 31
	00 00 00	 mov	 DWORD PTR tv130[rsp], 49 ; 00000031H
  0014b	eb 08		 jmp	 SHORT $LN19@gui_debug_
$LN18@gui_debug_:
  0014d	c7 44 24 34 30
	00 00 00	 mov	 DWORD PTR tv130[rsp], 48 ; 00000030H
$LN19@gui_debug_:
  00155	b9 01 00 00 00	 mov	 ecx, 1
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00160	44 8b 44 24 34	 mov	 r8d, DWORD PTR tv130[rsp]
  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168607
  0016c	48 8b c8	 mov	 rcx, rax
  0016f	e8 00 00 00 00	 call	 gui_fprintf
$LN5@gui_debug_:

; 1949 :     }
; 1950 : 
; 1951 :     if((next_debug_call = hdl_next( &gui_debug_cpu_state )))

  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gui_debug_cpu_state
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_next
  00181	48 89 44 24 38	 mov	 QWORD PTR next_debug_call$[rsp], rax
  00186	48 83 7c 24 38
	00		 cmp	 QWORD PTR next_debug_call$[rsp], 0
  0018c	74 0b		 je	 SHORT $LN6@gui_debug_

; 1952 :         return next_debug_call( pREGS );

  0018e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pREGS$[rsp]
  00193	ff 54 24 38	 call	 QWORD PTR next_debug_call$[rsp]
  00197	eb 02		 jmp	 SHORT $LN1@gui_debug_
$LN6@gui_debug_:

; 1953 : 
; 1954 :     return NULL;    // (I have no idea why this is a void* func)

  00199	33 c0		 xor	 eax, eax
$LN1@gui_debug_:

; 1955 : }

  0019b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019f	c3		 ret	 0
gui_debug_cpu_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
regs$ = 32
cpu$ = 80
CopyREGS PROC

; 136  : {

$LN13:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	56		 push	 rsi
  00005	57		 push	 rdi
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 137  :     REGS* regs;
; 138  : 
; 139  :     if (cpu < 0 || cpu >= sysblk.maxcpu)

  0000a	83 7c 24 50 00	 cmp	 DWORD PTR cpu$[rsp], 0
  0000f	7c 13		 jl	 SHORT $LN6@CopyREGS
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00018	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001e	39 44 24 50	 cmp	 DWORD PTR cpu$[rsp], eax
  00022	7c 08		 jl	 SHORT $LN5@CopyREGS
$LN6@CopyREGS:

; 140  :         cpu = 0;

  00024	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
$LN5@CopyREGS:

; 141  : 
; 142  :     obtain_lock( &sysblk.cpulock[cpu] );

  0002c	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00031	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00038	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168174
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 143  : 
; 144  :     if (!(regs = sysblk.regs[cpu]))

  00050	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005c	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00064	48 89 44 24 20	 mov	 QWORD PTR regs$[rsp], rax
  00069	48 83 7c 24 20
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0006f	75 36		 jne	 SHORT $LN7@CopyREGS

; 145  :     {
; 146  :         release_lock( &sysblk.cpulock[cpu] );

  00071	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00076	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0007d	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168176
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 147  :         return &sysblk.dummyregs;

  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009c	48 05 00 15 00
	00		 add	 rax, 5376		; 00001500H
  000a2	e9 48 01 00 00	 jmp	 $LN1@CopyREGS
$LN7@CopyREGS:

; 148  :     }
; 149  : 
; 150  :     memcpy( &copyregs, regs, sysblk.regs_copy_len );

  000a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ae	48 63 80 90 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5264]
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:copyregs
  000bc	48 8b f9	 mov	 rdi, rcx
  000bf	48 8b 74 24 20	 mov	 rsi, QWORD PTR regs$[rsp]
  000c4	48 8b c8	 mov	 rcx, rax
  000c7	f3 a4		 rep movsb

; 151  : 
; 152  :     if (!copyregs.hostregs)

  000c9	48 83 3d 68 08
	00 00 00	 cmp	 QWORD PTR copyregs+2152, 0
  000d1	75 36		 jne	 SHORT $LN8@CopyREGS

; 153  :     {
; 154  :         release_lock(&sysblk.cpulock[cpu]);

  000d3	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000df	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168178
  000ee	48 8b c8	 mov	 rcx, rax
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 155  :         return &sysblk.dummyregs;

  000f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000fe	48 05 00 15 00
	00		 add	 rax, 5376		; 00001500H
  00104	e9 e6 00 00 00	 jmp	 $LN1@CopyREGS
$LN8@CopyREGS:

; 156  :     }
; 157  : 
; 158  : #if defined(_FEATURE_SIE)
; 159  :     if (regs->sie_active)

  00109	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	83 e0 01	 and	 eax, 1
  00117	85 c0		 test	 eax, eax
  00119	74 53		 je	 SHORT $LN9@CopyREGS

; 160  :     {
; 161  :         memcpy( &copysieregs, GUESTREGS, sysblk.regs_copy_len );

  0011b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00122	48 63 80 90 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5264]
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:copysieregs
  00130	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  00135	48 8b f9	 mov	 rdi, rcx
  00138	48 8b b2 70 08
	00 00		 mov	 rsi, QWORD PTR [rdx+2160]
  0013f	48 8b c8	 mov	 rcx, rax
  00142	f3 a4		 rep movsb

; 162  :         copyregs.guestregs = &copysieregs;

  00144	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:copysieregs
  0014b	48 89 05 70 08
	00 00		 mov	 QWORD PTR copyregs+2160, rax

; 163  :         copysieregs.hostregs = &copyregs;

  00152	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:copyregs
  00159	48 89 05 68 08
	00 00		 mov	 QWORD PTR copysieregs+2152, rax

; 164  :         regs = &copysieregs;

  00160	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:copysieregs
  00167	48 89 44 24 20	 mov	 QWORD PTR regs$[rsp], rax

; 165  :     }

  0016c	eb 0c		 jmp	 SHORT $LN10@CopyREGS
$LN9@CopyREGS:

; 166  :     else
; 167  : #endif
; 168  :         regs = &copyregs;

  0016e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:copyregs
  00175	48 89 44 24 20	 mov	 QWORD PTR regs$[rsp], rax
$LN10@CopyREGS:
$LN4@CopyREGS:

; 169  : 
; 170  :     MAYBE_SET_PSW_IA_FROM_IP( regs );

  0017a	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00187	74 37		 je	 SHORT $LN11@CopyREGS
  00189	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0018e	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00194	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  0019e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  001a5	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001a9	48 2b ca	 sub	 rcx, rdx
  001ac	48 03 c1	 add	 rax, rcx
  001af	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  001b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  001ba	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN11@CopyREGS:
  001c0	33 c0		 xor	 eax, eax
  001c2	85 c0		 test	 eax, eax
  001c4	75 b4		 jne	 SHORT $LN4@CopyREGS

; 171  : 
; 172  :     release_lock( &sysblk.cpulock[cpu] );

  001c6	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  001cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d2	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168182
  001e1	48 8b c8	 mov	 rcx, rax
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 173  :     return regs;

  001ea	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
$LN1@CopyREGS:

; 174  : }

  001ef	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001f3	5f		 pop	 rdi
  001f4	5e		 pop	 rsi
  001f5	c3		 ret	 0
CopyREGS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
vl$ = 32
stream$ = 64
pszFormat$ = 72
gui_fprintf PROC

; 1977 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1978 :     va_list vl;
; 1979 :     va_start( vl, pszFormat );

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR pszFormat$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR vl$[rsp], rax

; 1980 :     obtain_lock ( &gui_fprintf_lock );

  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168639
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gui_fprintf_lock
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1981 :     vfprintf( stream, pszFormat, vl );

  00036	4c 8b 44 24 20	 mov	 r8, QWORD PTR vl$[rsp]
  0003b	48 8b 54 24 48	 mov	 rdx, QWORD PTR pszFormat$[rsp]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00045	e8 00 00 00 00	 call	 vfprintf

; 1982 :     fflush( stream );

  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1983 :     release_lock( &gui_fprintf_lock );

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168640
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gui_fprintf_lock
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1984 : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
gui_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
chOpenStat$ = 96
chPendingStat$ = 97
chBusyStat$ = 98
chOnlineStat$ = 99
pDEVBLK$ = 104
pGUIStat$ = 112
bUpdatesSent$ = 120
tv210 = 124
tv236 = 128
tv139 = 132
tv143 = 136
$T1 = 144
$T2 = 152
pDEVClass$ = 160
pszSavStatStr$3 = 168
NewUpdateDevStats PROC

; 1770 : {

$LN31:
  00000	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1771 :     DEVBLK*     pDEVBLK;
; 1772 :     GUISTAT*    pGUIStat;
; 1773 :     char*       pDEVClass;
; 1774 :     BYTE        chOnlineStat, chBusyStat, chPendingStat, chOpenStat;
; 1775 :     BOOL        bUpdatesSent = FALSE;

  00007	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR bUpdatesSent$[rsp], 0

; 1776 :     static BOOL bFirstBatch  = TRUE;
; 1777 : 
; 1778 :     if (sysblk.shutdown) return;

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0001c	c1 e8 0b	 shr	 eax, 11
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 05		 je	 SHORT $LN5@NewUpdateD
  00026	e9 f0 04 00 00	 jmp	 $LN1@NewUpdateD
$LN5@NewUpdateD:

; 1779 : 
; 1780 :     // Process ALL the devices in the entire configuration each time...
; 1781 : 
; 1782 :     // (But only send device status messages to the GUI only when the
; 1783 :     // device's status actually changes and not continuously like before)
; 1784 : 
; 1785 :     for (pDEVBLK = sysblk.firstdev; pDEVBLK != NULL; pDEVBLK = pDEVBLK->nextdev)

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00032	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00039	48 89 44 24 68	 mov	 QWORD PTR pDEVBLK$[rsp], rax
  0003e	eb 0e		 jmp	 SHORT $LN4@NewUpdateD
$LN2@NewUpdateD:
  00040	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00045	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00049	48 89 44 24 68	 mov	 QWORD PTR pDEVBLK$[rsp], rax
$LN4@NewUpdateD:
  0004e	48 83 7c 24 68
	00		 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  00054	0f 84 94 04 00
	00		 je	 $LN3@NewUpdateD

; 1786 :     {
; 1787 :         pGUIStat = pDEVBLK->pGUIStat;

  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0005f	48 8b 80 10 06
	00 00		 mov	 rax, QWORD PTR [rax+1552]
  00066	48 89 44 24 70	 mov	 QWORD PTR pGUIStat$[rsp], rax

; 1788 : 
; 1789 :         // Does this device exist in the configuration?
; 1790 : 
; 1791 :         if (!IS_DEV( pDEVBLK ))

  0006b	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00070	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00074	74 28		 je	 SHORT $LN7@NewUpdateD
  00076	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0007b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00082	83 e0 01	 and	 eax, 1
  00085	85 c0		 test	 eax, eax
  00087	75 68		 jne	 SHORT $LN6@NewUpdateD
  00089	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00090	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00097	48 39 44 24 68	 cmp	 QWORD PTR pDEVBLK$[rsp], rax
  0009c	74 53		 je	 SHORT $LN6@NewUpdateD
$LN7@NewUpdateD:

; 1792 :         {
; 1793 :             // This device no longer exists in the configuration...
; 1794 :             // If we haven't yet notified the GUI about this device
; 1795 :             // being deleted from the configuration, then do so at
; 1796 :             // this time...
; 1797 : 
; 1798 :             if (*pGUIStat->pszNewStatStr)

  0009e	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  000a3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000aa	85 c0		 test	 eax, eax
  000ac	74 3e		 je	 SHORT $LN8@NewUpdateD

; 1799 :             {
; 1800 :                 // Send "device deleted" message...
; 1801 : 
; 1802 :                 gui_fprintf ( fStatusStream, "DEVD=%4.4X\n", pDEVBLK->devnum );

  000ae	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000b3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000b7	44 8b c0	 mov	 r8d, eax
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168567
  000c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  000c8	e8 00 00 00 00	 call	 gui_fprintf

; 1803 :                 bUpdatesSent = TRUE;

  000cd	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR bUpdatesSent$[rsp], 1

; 1804 : 
; 1805 :                 *pGUIStat->pszNewStatStr = 0;   // (prevent re-reporting it)

  000d5	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  000da	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000de	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1806 :                 *pGUIStat->pszOldStatStr = 0;   // (prevent re-reporting it)

  000e1	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  000e6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e9	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN8@NewUpdateD:

; 1807 :             }
; 1808 : 
; 1809 :             continue;   // (go on to next device)

  000ec	e9 4f ff ff ff	 jmp	 $LN2@NewUpdateD
$LN6@NewUpdateD:

; 1810 :         }
; 1811 : 
; 1812 :         // Retrieve this device's filename and optional settings parameter values...
; 1813 : 
; 1814 :         szQueryDeviceBuff[MAX_DEVICEQUERY_LEN] = 0; // (buffer allows room for 1 extra)

  000f1	b8 01 00 00 00	 mov	 eax, 1
  000f6	48 69 c0 00 05
	00 00		 imul	 rax, rax, 1280		; 00000500H
  000fd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00105	48 81 bc 24 90
	00 00 00 01 05
	00 00		 cmp	 QWORD PTR $T1[rsp], 1281 ; 00000501H
  00111	73 02		 jae	 SHORT $LN23@NewUpdateD
  00113	eb 05		 jmp	 SHORT $LN24@NewUpdateD
$LN23@NewUpdateD:
  00115	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN24@NewUpdateD:
  0011a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:szQueryDeviceBuff
  00121	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR $T1[rsp]
  00129	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1815 : 
; 1816 :         (pDEVBLK->hnd->query)(pDEVBLK, &pDEVClass, MAX_DEVICEQUERY_LEN, szQueryDeviceBuff);

  0012d	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00132	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00139	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:szQueryDeviceBuff
  00140	41 b8 00 05 00
	00		 mov	 r8d, 1280		; 00000500H
  00146	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR pDEVClass$[rsp]
  0014e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00153	ff 50 18	 call	 QWORD PTR [rax+24]

; 1817 : 
; 1818 :         if (0 != szQueryDeviceBuff[MAX_DEVICEQUERY_LEN])    // (buffer overflow?)

  00156	b8 01 00 00 00	 mov	 eax, 1
  0015b	48 69 c0 00 05
	00 00		 imul	 rax, rax, 1280		; 00000500H
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:szQueryDeviceBuff
  00169	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0016d	85 c0		 test	 eax, eax
  0016f	74 7f		 je	 SHORT $LN9@NewUpdateD

; 1819 :         {
; 1820 :             WRMSG

  00171	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00176	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0017a	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv139[rsp], eax
  00181	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00186	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0018a	d1 f9		 sar	 ecx, 1
  0018c	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv143[rsp], ecx
  00193	b9 01 00 00 00	 mov	 ecx, 1
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv139[rsp]
  001a5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001a9	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv143[rsp]
  001b0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168569
  001bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168570
  001c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168571
  001de	ba 21 07 00 00	 mov	 edx, 1825		; 00000721H
  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168572
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@NewUpdateD:

; 1821 :             (
; 1822 :                 HHC01540, "E"
; 1823 :                 ,SSID_TO_LCSS(pDEVBLK->ssid)
; 1824 :                 ,pDEVBLK->devnum
; 1825 :             );
; 1826 :         }
; 1827 : 
; 1828 :         szQueryDeviceBuff[MAX_DEVICEQUERY_LEN] = 0;   // (enforce NULL termination)

  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	48 69 c0 00 05
	00 00		 imul	 rax, rax, 1280		; 00000500H
  001fc	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  00204	48 81 bc 24 98
	00 00 00 01 05
	00 00		 cmp	 QWORD PTR $T2[rsp], 1281 ; 00000501H
  00210	73 02		 jae	 SHORT $LN25@NewUpdateD
  00212	eb 05		 jmp	 SHORT $LN26@NewUpdateD
$LN25@NewUpdateD:
  00214	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN26@NewUpdateD:
  00219	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:szQueryDeviceBuff
  00220	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR $T2[rsp]
  00228	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1829 : 
; 1830 :         // Device status flags...
; 1831 :                                                                               chOnlineStat  =

  0022c	c6 44 24 60 30	 mov	 BYTE PTR chOpenStat$[rsp], 48 ; 00000030H
  00231	0f b6 44 24 60	 movzx	 eax, BYTE PTR chOpenStat$[rsp]
  00236	88 44 24 61	 mov	 BYTE PTR chPendingStat$[rsp], al
  0023a	0f b6 44 24 61	 movzx	 eax, BYTE PTR chPendingStat$[rsp]
  0023f	88 44 24 62	 mov	 BYTE PTR chBusyStat$[rsp], al
  00243	0f b6 44 24 62	 movzx	 eax, BYTE PTR chBusyStat$[rsp]
  00248	88 44 24 63	 mov	 BYTE PTR chOnlineStat$[rsp], al

; 1832 :                                                                               chBusyStat    =
; 1833 :                                                                               chPendingStat =
; 1834 :                                                                               chOpenStat    = '0';
; 1835 : 
; 1836 :         if ((!pDEVBLK->console && pDEVBLK->fd >= 0) ||

  0024c	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00251	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00257	c1 e8 04	 shr	 eax, 4
  0025a	83 e0 01	 and	 eax, 1
  0025d	85 c0		 test	 eax, eax
  0025f	75 0e		 jne	 SHORT $LN12@NewUpdateD
  00261	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00266	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0026d	7d 2a		 jge	 SHORT $LN11@NewUpdateD
$LN12@NewUpdateD:
  0026f	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00274	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0027a	c1 e8 04	 shr	 eax, 4
  0027d	83 e0 01	 and	 eax, 1
  00280	85 c0		 test	 eax, eax
  00282	74 1a		 je	 SHORT $LN10@NewUpdateD
  00284	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00289	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0028f	c1 e8 05	 shr	 eax, 5
  00292	83 e0 01	 and	 eax, 1
  00295	85 c0		 test	 eax, eax
  00297	74 05		 je	 SHORT $LN10@NewUpdateD
$LN11@NewUpdateD:

; 1837 :             ( pDEVBLK->console && pDEVBLK->connected))                        chOnlineStat  = '1';

  00299	c6 44 24 63 31	 mov	 BYTE PTR chOnlineStat$[rsp], 49 ; 00000031H
$LN10@NewUpdateD:

; 1838 :         if (pDEVBLK->busy)                                                    chBusyStat    = '1';

  0029e	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002a3	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002a9	c1 e8 13	 shr	 eax, 19
  002ac	83 e0 01	 and	 eax, 1
  002af	85 c0		 test	 eax, eax
  002b1	74 05		 je	 SHORT $LN13@NewUpdateD
  002b3	c6 44 24 62 31	 mov	 BYTE PTR chBusyStat$[rsp], 49 ; 00000031H
$LN13@NewUpdateD:

; 1839 :         if (IOPENDING(pDEVBLK))                                               chPendingStat = '1';

  002b8	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002bd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002c3	c1 e8 16	 shr	 eax, 22
  002c6	83 e0 01	 and	 eax, 1
  002c9	85 c0		 test	 eax, eax
  002cb	75 3f		 jne	 SHORT $LN15@NewUpdateD
  002cd	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002d2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002d8	c1 e8 17	 shr	 eax, 23
  002db	83 e0 01	 and	 eax, 1
  002de	85 c0		 test	 eax, eax
  002e0	75 2a		 jne	 SHORT $LN15@NewUpdateD
  002e2	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002e7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002ed	c1 e8 18	 shr	 eax, 24
  002f0	83 e0 01	 and	 eax, 1
  002f3	85 c0		 test	 eax, eax
  002f5	75 15		 jne	 SHORT $LN15@NewUpdateD
  002f7	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002fc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00302	c1 e8 1b	 shr	 eax, 27
  00305	83 e0 01	 and	 eax, 1
  00308	85 c0		 test	 eax, eax
  0030a	74 05		 je	 SHORT $LN14@NewUpdateD
$LN15@NewUpdateD:
  0030c	c6 44 24 61 31	 mov	 BYTE PTR chPendingStat$[rsp], 49 ; 00000031H
$LN14@NewUpdateD:

; 1840 :         if (pDEVBLK->fd > MAX(STDIN_FILENO,MAX(STDOUT_FILENO,STDERR_FILENO))) chOpenStat    = '1';

  00311	48 8b 44 24 68	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00316	83 b8 ac 01 00
	00 02		 cmp	 DWORD PTR [rax+428], 2
  0031d	7e 05		 jle	 SHORT $LN16@NewUpdateD
  0031f	c6 44 24 60 31	 mov	 BYTE PTR chOpenStat$[rsp], 49 ; 00000031H
$LN16@NewUpdateD:

; 1841 : 
; 1842 :         // Build a new "device added" or "device changed"
; 1843 :         // status string for this device...
; 1844 : 
; 1845 : #if defined(_FEATURE_INTEGRATED_3270_CONSOLE)
; 1846 :         if (pDEVBLK == sysblk.sysgdev)

  00324	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0032b	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00332	48 39 44 24 68	 cmp	 QWORD PTR pDEVBLK$[rsp], rax
  00337	0f 85 85 00 00
	00		 jne	 $LN17@NewUpdateD

; 1847 :         {
; 1848 :             snprintf( pGUIStat->pszNewStatStr, GUI_STATSTR_BUFSIZ,

  0033d	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  00342	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00345	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00348	85 c0		 test	 eax, eax
  0034a	74 0a		 je	 SHORT $LN27@NewUpdateD
  0034c	c7 44 24 7c 43
	00 00 00	 mov	 DWORD PTR tv210[rsp], 67 ; 00000043H
  00354	eb 08		 jmp	 SHORT $LN28@NewUpdateD
$LN27@NewUpdateD:
  00356	c7 44 24 7c 41
	00 00 00	 mov	 DWORD PTR tv210[rsp], 65 ; 00000041H
$LN28@NewUpdateD:
  0035e	0f b6 44 24 60	 movzx	 eax, BYTE PTR chOpenStat$[rsp]
  00363	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR chPendingStat$[rsp]
  00368	0f b6 54 24 62	 movzx	 edx, BYTE PTR chBusyStat$[rsp]
  0036d	44 0f b6 44 24
	63		 movzx	 r8d, BYTE PTR chOnlineStat$[rsp]
  00373	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:szQueryDeviceBuff
  0037a	4c 89 4c 24 48	 mov	 QWORD PTR [rsp+72], r9
  0037f	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00383	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00387	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  0038b	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00390	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVClass$[rsp]
  00398	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0039d	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR tv210[rsp]
  003a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168582
  003a9	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  003ae	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  003b3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1849 : 
; 1850 :                 "DEV%c=0000 SYSG %-4.4s %c%c%c%c %s"
; 1851 : 
; 1852 :                 ,*pGUIStat->pszOldStatStr ? 'C' : 'A'
; 1853 :                 ,pDEVClass
; 1854 : 
; 1855 :                 ,chOnlineStat
; 1856 :                 ,chBusyStat
; 1857 :                 ,chPendingStat
; 1858 :                 ,chOpenStat
; 1859 : 
; 1860 :                 ,szQueryDeviceBuff
; 1861 :             );
; 1862 :         }

  003bd	e9 a7 00 00 00	 jmp	 $LN18@NewUpdateD
$LN17@NewUpdateD:

; 1863 :         else
; 1864 : #endif // defined(_FEATURE_INTEGRATED_3270_CONSOLE)
; 1865 :         snprintf( pGUIStat->pszNewStatStr, GUI_STATSTR_BUFSIZ,

  003c2	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  003c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ca	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003cd	85 c0		 test	 eax, eax
  003cf	74 0d		 je	 SHORT $LN29@NewUpdateD
  003d1	c7 84 24 80 00
	00 00 43 00 00
	00		 mov	 DWORD PTR tv236[rsp], 67 ; 00000043H
  003dc	eb 0b		 jmp	 SHORT $LN30@NewUpdateD
$LN29@NewUpdateD:
  003de	c7 84 24 80 00
	00 00 41 00 00
	00		 mov	 DWORD PTR tv236[rsp], 65 ; 00000041H
$LN30@NewUpdateD:
  003e9	0f b6 44 24 60	 movzx	 eax, BYTE PTR chOpenStat$[rsp]
  003ee	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR chPendingStat$[rsp]
  003f3	0f b6 54 24 62	 movzx	 edx, BYTE PTR chBusyStat$[rsp]
  003f8	44 0f b6 44 24
	63		 movzx	 r8d, BYTE PTR chOnlineStat$[rsp]
  003fe	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pDEVBLK$[rsp]
  00403	45 0f b7 49 4a	 movzx	 r9d, WORD PTR [r9+74]
  00408	4c 8b 54 24 68	 mov	 r10, QWORD PTR pDEVBLK$[rsp]
  0040d	45 0f b7 52 48	 movzx	 r10d, WORD PTR [r10+72]
  00412	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:szQueryDeviceBuff
  00419	4c 89 5c 24 58	 mov	 QWORD PTR [rsp+88], r11
  0041e	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00422	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00426	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  0042a	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  0042f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVClass$[rsp]
  00437	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0043c	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  00441	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  00446	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR tv236[rsp]
  0044e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168583
  00455	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0045a	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  0045f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00463	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN18@NewUpdateD:

; 1866 : 
; 1867 :             "DEV%c=%4.4X %4.4X %-4.4s %c%c%c%c %s"
; 1868 : 
; 1869 :             ,*pGUIStat->pszOldStatStr ? 'C' : 'A'
; 1870 :             ,pDEVBLK->devnum
; 1871 :             ,pDEVBLK->devtype
; 1872 :             ,pDEVClass
; 1873 : 
; 1874 :             ,chOnlineStat
; 1875 :             ,chBusyStat
; 1876 :             ,chPendingStat
; 1877 :             ,chOpenStat
; 1878 : 
; 1879 :             ,szQueryDeviceBuff
; 1880 :         );
; 1881 : 
; 1882 :         *(pGUIStat->pszNewStatStr + GUI_STATSTR_BUFSIZ - 1) = 0;

  00469	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  0046e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00472	c6 80 ff 00 00
	00 00		 mov	 BYTE PTR [rax+255], 0

; 1883 : 
; 1884 :         // If the new status string is different from the old one,
; 1885 :         // then send the new one to the GUI and swap buffer ptrs
; 1886 :         // for next time. In this way we only send device status
; 1887 :         // msgs to the GUI only when the status actually changes...
; 1888 : 
; 1889 :         if (strcmp( pGUIStat->pszNewStatStr, pGUIStat->pszOldStatStr ))

  00479	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  0047e	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00481	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  00486	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0048a	e8 00 00 00 00	 call	 strcmp
  0048f	85 c0		 test	 eax, eax
  00491	74 56		 je	 SHORT $LN19@NewUpdateD

; 1890 :         {
; 1891 :             gui_fprintf ( fStatusStream, "%s\n", pGUIStat->pszNewStatStr );

  00493	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  00498	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0049c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168585
  004a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  004aa	e8 00 00 00 00	 call	 gui_fprintf

; 1892 :             bUpdatesSent = TRUE;

  004af	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR bUpdatesSent$[rsp], 1

; 1893 :             {
; 1894 :                 register char*
; 1895 :                           pszSavStatStr = pGUIStat->pszNewStatStr;

  004b7	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  004bc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  004c0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pszSavStatStr$3[rsp], rax

; 1896 :                 pGUIStat->pszNewStatStr = pGUIStat->pszOldStatStr;

  004c8	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  004cd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pGUIStat$[rsp]
  004d2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004d5	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1897 :                 pGUIStat->pszOldStatStr =           pszSavStatStr;

  004d9	48 8b 44 24 70	 mov	 rax, QWORD PTR pGUIStat$[rsp]
  004de	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pszSavStatStr$3[rsp]
  004e6	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN19@NewUpdateD:

; 1898 :             }
; 1899 :         }
; 1900 :     }

  004e9	e9 52 fb ff ff	 jmp	 $LN2@NewUpdateD
$LN3@NewUpdateD:

; 1901 : 
; 1902 :     // Only send End-of-Batch indicator if we sent any updates or
; 1903 :     // if this is the first device-list update since powering on.
; 1904 : 
; 1905 :     if ( bUpdatesSent || bFirstBatch )

  004ee	83 7c 24 78 00	 cmp	 DWORD PTR bUpdatesSent$[rsp], 0
  004f3	75 09		 jne	 SHORT $LN21@NewUpdateD
  004f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bFirstBatch@?1??NewUpdateDevStats@@9@9, 0
  004fc	74 1d		 je	 SHORT $LN20@NewUpdateD
$LN21@NewUpdateD:

; 1906 :     {
; 1907 :         bFirstBatch = FALSE;

  004fe	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bFirstBatch@?1??NewUpdateDevStats@@9@9, 0

; 1908 :         gui_fprintf(fStatusStream, "DEVX=\n");  // (send end-of-batch indicator)

  00508	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168588
  0050f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00516	e8 00 00 00 00	 call	 gui_fprintf
$LN20@NewUpdateD:
$LN1@NewUpdateD:
$LN22@NewUpdateD:

; 1909 :     }
; 1910 : }

  0051b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00522	c3		 ret	 0
NewUpdateDevStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
chOpenStat$ = 80
chPendingStat$ = 81
chBusyStat$ = 82
chOnlineStat$ = 83
pDEVBLK$ = 88
tv93 = 96
tv129 = 100
$T1 = 104
$T2 = 112
pDEVClass$ = 120
UpdateDeviceStatus PROC

; 1675 : {

$LN23:
  00000	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1676 :     DEVBLK* pDEVBLK;
; 1677 :     char*   pDEVClass;
; 1678 :     BYTE    chOnlineStat, chBusyStat, chPendingStat, chOpenStat;
; 1679 : 
; 1680 :     if (sysblk.shutdown) return;

  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00014	c1 e8 0b	 shr	 eax, 11
  00017	83 e0 01	 and	 eax, 1
  0001a	85 c0		 test	 eax, eax
  0001c	74 05		 je	 SHORT $LN5@UpdateDevi
  0001e	e9 53 03 00 00	 jmp	 $LN1@UpdateDevi
$LN5@UpdateDevi:

; 1681 : 
; 1682 :     // Process ALL the devices in the entire configuration each time...
; 1683 : 
; 1684 :     for (pDEVBLK = sysblk.firstdev; pDEVBLK != NULL; pDEVBLK = pDEVBLK->nextdev)

  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002a	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00031	48 89 44 24 58	 mov	 QWORD PTR pDEVBLK$[rsp], rax
  00036	eb 0e		 jmp	 SHORT $LN4@UpdateDevi
$LN2@UpdateDevi:
  00038	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0003d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00041	48 89 44 24 58	 mov	 QWORD PTR pDEVBLK$[rsp], rax
$LN4@UpdateDevi:
  00046	48 83 7c 24 58
	00		 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  0004c	0f 84 11 03 00
	00		 je	 $LN3@UpdateDevi

; 1685 :     {
; 1686 :         // Does this device actually exist in the configuration?
; 1687 : 
; 1688 :         if (!IS_DEV( pDEVBLK )) continue;   // (no, skip)

  00052	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00057	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0005b	74 28		 je	 SHORT $LN7@UpdateDevi
  0005d	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00062	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00069	83 e0 01	 and	 eax, 1
  0006c	85 c0		 test	 eax, eax
  0006e	75 17		 jne	 SHORT $LN6@UpdateDevi
  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00077	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  0007e	48 39 44 24 58	 cmp	 QWORD PTR pDEVBLK$[rsp], rax
  00083	74 02		 je	 SHORT $LN6@UpdateDevi
$LN7@UpdateDevi:
  00085	eb b1		 jmp	 SHORT $LN2@UpdateDevi
$LN6@UpdateDevi:

; 1689 : 
; 1690 :         // Retrieve this device's filename and optional settings parameter values...
; 1691 : 
; 1692 :         szQueryDeviceBuff[MAX_DEVICEQUERY_LEN] = 0; // (buffer allows room for 1 extra)

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	48 69 c0 00 05
	00 00		 imul	 rax, rax, 1280		; 00000500H
  00093	48 89 44 24 68	 mov	 QWORD PTR $T1[rsp], rax
  00098	48 81 7c 24 68
	01 05 00 00	 cmp	 QWORD PTR $T1[rsp], 1281 ; 00000501H
  000a1	73 02		 jae	 SHORT $LN19@UpdateDevi
  000a3	eb 05		 jmp	 SHORT $LN20@UpdateDevi
$LN19@UpdateDevi:
  000a5	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN20@UpdateDevi:
  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:szQueryDeviceBuff
  000b1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T1[rsp]
  000b6	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1693 : 
; 1694 :         (pDEVBLK->hnd->query)(pDEVBLK, &pDEVClass, MAX_DEVICEQUERY_LEN, szQueryDeviceBuff);

  000ba	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000bf	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:szQueryDeviceBuff
  000cd	41 b8 00 05 00
	00		 mov	 r8d, 1280		; 00000500H
  000d3	48 8d 54 24 78	 lea	 rdx, QWORD PTR pDEVClass$[rsp]
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000dd	ff 50 18	 call	 QWORD PTR [rax+24]

; 1695 : 
; 1696 :         if (0 != szQueryDeviceBuff[MAX_DEVICEQUERY_LEN])    // (buffer overflow?)

  000e0	b8 01 00 00 00	 mov	 eax, 1
  000e5	48 69 c0 00 05
	00 00		 imul	 rax, rax, 1280		; 00000500H
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:szQueryDeviceBuff
  000f3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000f7	85 c0		 test	 eax, eax
  000f9	74 73		 je	 SHORT $LN8@UpdateDevi

; 1697 :         {
; 1698 :             WRMSG

  000fb	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00100	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00104	89 44 24 60	 mov	 DWORD PTR tv93[rsp], eax
  00108	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0010d	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00111	d1 f9		 sar	 ecx, 1
  00113	89 4c 24 64	 mov	 DWORD PTR tv129[rsp], ecx
  00117	b9 01 00 00 00	 mov	 ecx, 1
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00122	8b 4c 24 60	 mov	 ecx, DWORD PTR tv93[rsp]
  00126	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0012a	8b 4c 24 64	 mov	 ecx, DWORD PTR tv129[rsp]
  0012e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168529
  00139	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168530
  00145	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00155	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168531
  0015c	ba a8 06 00 00	 mov	 edx, 1704		; 000006a8H
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168532
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@UpdateDevi:

; 1699 :             (
; 1700 :                 HHC01540, "E"
; 1701 :                 ,SSID_TO_LCSS(pDEVBLK->ssid)
; 1702 :                 ,pDEVBLK->devnum
; 1703 : 
; 1704 :             );
; 1705 :         }
; 1706 : 
; 1707 :         szQueryDeviceBuff[MAX_DEVICEQUERY_LEN] = 0;   // (enforce NULL termination)

  0016e	b8 01 00 00 00	 mov	 eax, 1
  00173	48 69 c0 00 05
	00 00		 imul	 rax, rax, 1280		; 00000500H
  0017a	48 89 44 24 70	 mov	 QWORD PTR $T2[rsp], rax
  0017f	48 81 7c 24 70
	01 05 00 00	 cmp	 QWORD PTR $T2[rsp], 1281 ; 00000501H
  00188	73 02		 jae	 SHORT $LN21@UpdateDevi
  0018a	eb 05		 jmp	 SHORT $LN22@UpdateDevi
$LN21@UpdateDevi:
  0018c	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN22@UpdateDevi:
  00191	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:szQueryDeviceBuff
  00198	48 8b 4c 24 70	 mov	 rcx, QWORD PTR $T2[rsp]
  0019d	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1708 : 
; 1709 :         // Device status flags...
; 1710 :                                                                               chOnlineStat  =

  001a1	c6 44 24 50 30	 mov	 BYTE PTR chOpenStat$[rsp], 48 ; 00000030H
  001a6	0f b6 44 24 50	 movzx	 eax, BYTE PTR chOpenStat$[rsp]
  001ab	88 44 24 51	 mov	 BYTE PTR chPendingStat$[rsp], al
  001af	0f b6 44 24 51	 movzx	 eax, BYTE PTR chPendingStat$[rsp]
  001b4	88 44 24 52	 mov	 BYTE PTR chBusyStat$[rsp], al
  001b8	0f b6 44 24 52	 movzx	 eax, BYTE PTR chBusyStat$[rsp]
  001bd	88 44 24 53	 mov	 BYTE PTR chOnlineStat$[rsp], al

; 1711 :                                                                               chBusyStat    =
; 1712 :                                                                               chPendingStat =
; 1713 :                                                                               chOpenStat    = '0';
; 1714 : 
; 1715 :         if ((!pDEVBLK->console && pDEVBLK->fd >= 0) ||

  001c1	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001c6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001cc	c1 e8 04	 shr	 eax, 4
  001cf	83 e0 01	 and	 eax, 1
  001d2	85 c0		 test	 eax, eax
  001d4	75 0e		 jne	 SHORT $LN11@UpdateDevi
  001d6	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001db	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  001e2	7d 2a		 jge	 SHORT $LN10@UpdateDevi
$LN11@UpdateDevi:
  001e4	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001e9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001ef	c1 e8 04	 shr	 eax, 4
  001f2	83 e0 01	 and	 eax, 1
  001f5	85 c0		 test	 eax, eax
  001f7	74 1a		 je	 SHORT $LN9@UpdateDevi
  001f9	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001fe	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00204	c1 e8 05	 shr	 eax, 5
  00207	83 e0 01	 and	 eax, 1
  0020a	85 c0		 test	 eax, eax
  0020c	74 05		 je	 SHORT $LN9@UpdateDevi
$LN10@UpdateDevi:

; 1716 :             ( pDEVBLK->console && pDEVBLK->connected))                        chOnlineStat  = '1';

  0020e	c6 44 24 53 31	 mov	 BYTE PTR chOnlineStat$[rsp], 49 ; 00000031H
$LN9@UpdateDevi:

; 1717 :         if (pDEVBLK->busy)                                                    chBusyStat    = '1';

  00213	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00218	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0021e	c1 e8 13	 shr	 eax, 19
  00221	83 e0 01	 and	 eax, 1
  00224	85 c0		 test	 eax, eax
  00226	74 05		 je	 SHORT $LN12@UpdateDevi
  00228	c6 44 24 52 31	 mov	 BYTE PTR chBusyStat$[rsp], 49 ; 00000031H
$LN12@UpdateDevi:

; 1718 :         if (IOPENDING(pDEVBLK))                                               chPendingStat = '1';

  0022d	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00232	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00238	c1 e8 16	 shr	 eax, 22
  0023b	83 e0 01	 and	 eax, 1
  0023e	85 c0		 test	 eax, eax
  00240	75 3f		 jne	 SHORT $LN14@UpdateDevi
  00242	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00247	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0024d	c1 e8 17	 shr	 eax, 23
  00250	83 e0 01	 and	 eax, 1
  00253	85 c0		 test	 eax, eax
  00255	75 2a		 jne	 SHORT $LN14@UpdateDevi
  00257	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0025c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00262	c1 e8 18	 shr	 eax, 24
  00265	83 e0 01	 and	 eax, 1
  00268	85 c0		 test	 eax, eax
  0026a	75 15		 jne	 SHORT $LN14@UpdateDevi
  0026c	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00271	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00277	c1 e8 1b	 shr	 eax, 27
  0027a	83 e0 01	 and	 eax, 1
  0027d	85 c0		 test	 eax, eax
  0027f	74 05		 je	 SHORT $LN13@UpdateDevi
$LN14@UpdateDevi:
  00281	c6 44 24 51 31	 mov	 BYTE PTR chPendingStat$[rsp], 49 ; 00000031H
$LN13@UpdateDevi:

; 1719 :         if (pDEVBLK->fd > MAX(STDIN_FILENO,MAX(STDOUT_FILENO,STDERR_FILENO))) chOpenStat    = '1';

  00286	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0028b	83 b8 ac 01 00
	00 02		 cmp	 DWORD PTR [rax+428], 2
  00292	7e 05		 jle	 SHORT $LN15@UpdateDevi
  00294	c6 44 24 50 31	 mov	 BYTE PTR chOpenStat$[rsp], 49 ; 00000031H
$LN15@UpdateDevi:

; 1720 : 
; 1721 :         // Send status message back to gui...
; 1722 : 
; 1723 : #if defined(_FEATURE_INTEGRATED_3270_CONSOLE)
; 1724 :         if (pDEVBLK == sysblk.sysgdev)

  00299	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002a0	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  002a7	48 39 44 24 58	 cmp	 QWORD PTR pDEVBLK$[rsp], rax
  002ac	75 4a		 jne	 SHORT $LN16@UpdateDevi

; 1725 :         {
; 1726 :             gui_fprintf( fStatusStream,

  002ae	0f b6 44 24 50	 movzx	 eax, BYTE PTR chOpenStat$[rsp]
  002b3	0f b6 4c 24 51	 movzx	 ecx, BYTE PTR chPendingStat$[rsp]
  002b8	0f b6 54 24 52	 movzx	 edx, BYTE PTR chBusyStat$[rsp]
  002bd	44 0f b6 44 24
	53		 movzx	 r8d, BYTE PTR chOnlineStat$[rsp]
  002c3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:szQueryDeviceBuff
  002ca	4c 89 4c 24 38	 mov	 QWORD PTR [rsp+56], r9
  002cf	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002d3	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  002d7	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  002db	45 8b c8	 mov	 r9d, r8d
  002de	4c 8b 44 24 78	 mov	 r8, QWORD PTR pDEVClass$[rsp]
  002e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168542
  002ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  002f1	e8 00 00 00 00	 call	 gui_fprintf

; 1727 : 
; 1728 :                 "DEV=0000 SYSG %-4.4s %c%c%c%c %s\n"
; 1729 : 
; 1730 :                 ,pDEVClass
; 1731 : 
; 1732 :                 ,chOnlineStat
; 1733 :                 ,chBusyStat
; 1734 :                 ,chPendingStat
; 1735 :                 ,chOpenStat
; 1736 : 
; 1737 :                 ,szQueryDeviceBuff
; 1738 :             );
; 1739 :         }

  002f6	eb 66		 jmp	 SHORT $LN17@UpdateDevi
$LN16@UpdateDevi:

; 1740 :         else
; 1741 : #endif // defined(_FEATURE_INTEGRATED_3270_CONSOLE)
; 1742 :         gui_fprintf(fStatusStream,

  002f8	0f b6 44 24 50	 movzx	 eax, BYTE PTR chOpenStat$[rsp]
  002fd	0f b6 4c 24 51	 movzx	 ecx, BYTE PTR chPendingStat$[rsp]
  00302	0f b6 54 24 52	 movzx	 edx, BYTE PTR chBusyStat$[rsp]
  00307	44 0f b6 44 24
	53		 movzx	 r8d, BYTE PTR chOnlineStat$[rsp]
  0030d	4c 8b 4c 24 58	 mov	 r9, QWORD PTR pDEVBLK$[rsp]
  00312	45 0f b7 49 4a	 movzx	 r9d, WORD PTR [r9+74]
  00317	4c 8b 54 24 58	 mov	 r10, QWORD PTR pDEVBLK$[rsp]
  0031c	45 0f b7 52 48	 movzx	 r10d, WORD PTR [r10+72]
  00321	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:szQueryDeviceBuff
  00328	4c 89 5c 24 48	 mov	 QWORD PTR [rsp+72], r11
  0032d	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00331	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00335	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00339	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  0033e	48 8b 44 24 78	 mov	 rax, QWORD PTR pDEVClass$[rsp]
  00343	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00348	45 8b c2	 mov	 r8d, r10d
  0034b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168543
  00352	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00359	e8 00 00 00 00	 call	 gui_fprintf
$LN17@UpdateDevi:

; 1743 : 
; 1744 :             "DEV=%4.4X %4.4X %-4.4s %c%c%c%c %s\n"
; 1745 : 
; 1746 :             ,pDEVBLK->devnum
; 1747 :             ,pDEVBLK->devtype
; 1748 :             ,pDEVClass
; 1749 : 
; 1750 :             ,chOnlineStat
; 1751 :             ,chBusyStat
; 1752 :             ,chPendingStat
; 1753 :             ,chOpenStat
; 1754 : 
; 1755 :             ,szQueryDeviceBuff
; 1756 :         );
; 1757 :     }

  0035e	e9 d5 fc ff ff	 jmp	 $LN2@UpdateDevi
$LN3@UpdateDevi:

; 1758 : 
; 1759 :     // Since the device list can be in any order and devices can be added
; 1760 :     // and/or removed at any time, the GUI needs to know "That's all the
; 1761 :     // devices there are" so that it can detect when devices are removed...
; 1762 : 
; 1763 :     gui_fprintf(fStatusStream, "DEV=X\n");    // (indicates end of list)

  00363	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168544
  0036a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00371	e8 00 00 00 00	 call	 gui_fprintf
$LN1@UpdateDevi:
$LN18@UpdateDevi:

; 1764 : }

  00376	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0037d	c3		 ret	 0
UpdateDeviceStatus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
UpdateRegisters PROC

; 878  : {

$LN87:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 879  :     if (sysblk.shutdown) return;

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00011	c1 e8 0b	 shr	 eax, 11
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 05		 je	 SHORT $LN2@UpdateRegi
  0001b	e9 d7 3a 00 00	 jmp	 $LN1@UpdateRegi
$LN2@UpdateRegi:

; 880  : 
; 881  :     if (gui_wants_gregs)

  00020	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_gregs
  00027	85 c0		 test	 eax, eax
  00029	0f 84 b4 07 00
	00		 je	 $LN3@UpdateRegi

; 882  :     {
; 883  :         if (0
; 884  :             || prev_gr[0] != pTargetCPU_REGS->GR_L(0)
; 885  :             || prev_gr[1] != pTargetCPU_REGS->GR_L(1)
; 886  :             || prev_gr[2] != pTargetCPU_REGS->GR_L(2)
; 887  :             || prev_gr[3] != pTargetCPU_REGS->GR_L(3)

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	0f 85 bc 00 00
	00		 jne	 $LN5@UpdateRegi
  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	48 6b c0 00	 imul	 rax, rax, 0
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00049	ba 08 00 00 00	 mov	 edx, 8
  0004e	48 6b d2 00	 imul	 rdx, rdx, 0
  00052	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00059	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00061	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  00064	0f 85 8b 00 00
	00		 jne	 $LN5@UpdateRegi
  0006a	b8 04 00 00 00	 mov	 eax, 4
  0006f	48 6b c0 01	 imul	 rax, rax, 1
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  0007a	ba 08 00 00 00	 mov	 edx, 8
  0007f	48 6b d2 01	 imul	 rdx, rdx, 1
  00083	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0008a	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00092	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  00095	75 5e		 jne	 SHORT $LN5@UpdateRegi
  00097	b8 04 00 00 00	 mov	 eax, 4
  0009c	48 6b c0 02	 imul	 rax, rax, 2
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  000a7	ba 08 00 00 00	 mov	 edx, 8
  000ac	48 6b d2 02	 imul	 rdx, rdx, 2
  000b0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  000b7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  000bf	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  000c2	75 31		 jne	 SHORT $LN5@UpdateRegi
  000c4	b8 04 00 00 00	 mov	 eax, 4
  000c9	48 6b c0 03	 imul	 rax, rax, 3
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  000d4	ba 08 00 00 00	 mov	 edx, 8
  000d9	48 6b d2 03	 imul	 rdx, rdx, 3
  000dd	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  000e4	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  000ec	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  000ef	0f 84 27 01 00
	00		 je	 $LN4@UpdateRegi
$LN5@UpdateRegi:

; 888  :         )
; 889  :         {
; 890  :             prev_gr[0] = pTargetCPU_REGS->GR_L(0);

  000f5	b8 08 00 00 00	 mov	 eax, 8
  000fa	48 6b c0 00	 imul	 rax, rax, 0
  000fe	b9 04 00 00 00	 mov	 ecx, 4
  00103	48 6b c9 00	 imul	 rcx, rcx, 0
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  0010e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00115	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  0011d	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 891  :             prev_gr[1] = pTargetCPU_REGS->GR_L(1);

  00120	b8 08 00 00 00	 mov	 eax, 8
  00125	48 6b c0 01	 imul	 rax, rax, 1
  00129	b9 04 00 00 00	 mov	 ecx, 4
  0012e	48 6b c9 01	 imul	 rcx, rcx, 1
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  00139	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00140	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  00148	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 892  :             prev_gr[2] = pTargetCPU_REGS->GR_L(2);

  0014b	b8 08 00 00 00	 mov	 eax, 8
  00150	48 6b c0 02	 imul	 rax, rax, 2
  00154	b9 04 00 00 00	 mov	 ecx, 4
  00159	48 6b c9 02	 imul	 rcx, rcx, 2
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  00164	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0016b	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  00173	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 893  :             prev_gr[3] = pTargetCPU_REGS->GR_L(3);

  00176	b8 08 00 00 00	 mov	 eax, 8
  0017b	48 6b c0 03	 imul	 rax, rax, 3
  0017f	b9 04 00 00 00	 mov	 ecx, 4
  00184	48 6b c9 03	 imul	 rcx, rcx, 3
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  0018f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00196	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  0019e	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 894  : 
; 895  :             gui_fprintf(fStatusStream,

  001a1	b8 08 00 00 00	 mov	 eax, 8
  001a6	48 6b c0 03	 imul	 rax, rax, 3
  001aa	b9 08 00 00 00	 mov	 ecx, 8
  001af	48 6b c9 02	 imul	 rcx, rcx, 2
  001b3	ba 08 00 00 00	 mov	 edx, 8
  001b8	48 6b d2 01	 imul	 rdx, rdx, 1
  001bc	41 b8 08 00 00
	00		 mov	 r8d, 8
  001c2	4d 6b c0 00	 imul	 r8, r8, 0
  001c6	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  001cd	41 8b 84 01 80
	02 00 00	 mov	 eax, DWORD PTR [r9+rax+640]
  001d5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  001e0	8b 84 08 80 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx+640]
  001e7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  001f2	44 8b 8c 10 80
	02 00 00	 mov	 r9d, DWORD PTR [rax+rdx+640]
  001fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00201	46 8b 84 00 80
	02 00 00	 mov	 r8d, DWORD PTR [rax+r8+640]
  00209	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168393
  00210	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00217	e8 00 00 00 00	 call	 gui_fprintf
$LN4@UpdateRegi:

; 896  : 
; 897  :                 "GR0-3="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 898  : 
; 899  :                 ,pTargetCPU_REGS->GR_L(0)
; 900  :                 ,pTargetCPU_REGS->GR_L(1)
; 901  :                 ,pTargetCPU_REGS->GR_L(2)
; 902  :                 ,pTargetCPU_REGS->GR_L(3)
; 903  :             );
; 904  :         }
; 905  : 
; 906  :         if (0
; 907  :             || prev_gr[4] != pTargetCPU_REGS->GR_L(4)
; 908  :             || prev_gr[5] != pTargetCPU_REGS->GR_L(5)
; 909  :             || prev_gr[6] != pTargetCPU_REGS->GR_L(6)
; 910  :             || prev_gr[7] != pTargetCPU_REGS->GR_L(7)

  0021c	33 c0		 xor	 eax, eax
  0021e	85 c0		 test	 eax, eax
  00220	0f 85 bc 00 00
	00		 jne	 $LN7@UpdateRegi
  00226	b8 04 00 00 00	 mov	 eax, 4
  0022b	48 6b c0 04	 imul	 rax, rax, 4
  0022f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00236	ba 08 00 00 00	 mov	 edx, 8
  0023b	48 6b d2 04	 imul	 rdx, rdx, 4
  0023f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00246	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0024e	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  00251	0f 85 8b 00 00
	00		 jne	 $LN7@UpdateRegi
  00257	b8 04 00 00 00	 mov	 eax, 4
  0025c	48 6b c0 05	 imul	 rax, rax, 5
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00267	ba 08 00 00 00	 mov	 edx, 8
  0026c	48 6b d2 05	 imul	 rdx, rdx, 5
  00270	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00277	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0027f	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  00282	75 5e		 jne	 SHORT $LN7@UpdateRegi
  00284	b8 04 00 00 00	 mov	 eax, 4
  00289	48 6b c0 06	 imul	 rax, rax, 6
  0028d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00294	ba 08 00 00 00	 mov	 edx, 8
  00299	48 6b d2 06	 imul	 rdx, rdx, 6
  0029d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  002a4	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002ac	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  002af	75 31		 jne	 SHORT $LN7@UpdateRegi
  002b1	b8 04 00 00 00	 mov	 eax, 4
  002b6	48 6b c0 07	 imul	 rax, rax, 7
  002ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  002c1	ba 08 00 00 00	 mov	 edx, 8
  002c6	48 6b d2 07	 imul	 rdx, rdx, 7
  002ca	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  002d1	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002d9	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  002dc	0f 84 27 01 00
	00		 je	 $LN6@UpdateRegi
$LN7@UpdateRegi:

; 911  :         )
; 912  :         {
; 913  :             prev_gr[4] = pTargetCPU_REGS->GR_L(4);

  002e2	b8 08 00 00 00	 mov	 eax, 8
  002e7	48 6b c0 04	 imul	 rax, rax, 4
  002eb	b9 04 00 00 00	 mov	 ecx, 4
  002f0	48 6b c9 04	 imul	 rcx, rcx, 4
  002f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  002fb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00302	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  0030a	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 914  :             prev_gr[5] = pTargetCPU_REGS->GR_L(5);

  0030d	b8 08 00 00 00	 mov	 eax, 8
  00312	48 6b c0 05	 imul	 rax, rax, 5
  00316	b9 04 00 00 00	 mov	 ecx, 4
  0031b	48 6b c9 05	 imul	 rcx, rcx, 5
  0031f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  00326	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0032d	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  00335	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 915  :             prev_gr[6] = pTargetCPU_REGS->GR_L(6);

  00338	b8 08 00 00 00	 mov	 eax, 8
  0033d	48 6b c0 06	 imul	 rax, rax, 6
  00341	b9 04 00 00 00	 mov	 ecx, 4
  00346	48 6b c9 06	 imul	 rcx, rcx, 6
  0034a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  00351	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00358	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  00360	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 916  :             prev_gr[7] = pTargetCPU_REGS->GR_L(7);

  00363	b8 08 00 00 00	 mov	 eax, 8
  00368	48 6b c0 07	 imul	 rax, rax, 7
  0036c	b9 04 00 00 00	 mov	 ecx, 4
  00371	48 6b c9 07	 imul	 rcx, rcx, 7
  00375	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  0037c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00383	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  0038b	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 917  : 
; 918  :             gui_fprintf(fStatusStream,

  0038e	b8 08 00 00 00	 mov	 eax, 8
  00393	48 6b c0 07	 imul	 rax, rax, 7
  00397	b9 08 00 00 00	 mov	 ecx, 8
  0039c	48 6b c9 06	 imul	 rcx, rcx, 6
  003a0	ba 08 00 00 00	 mov	 edx, 8
  003a5	48 6b d2 05	 imul	 rdx, rdx, 5
  003a9	41 b8 08 00 00
	00		 mov	 r8d, 8
  003af	4d 6b c0 04	 imul	 r8, r8, 4
  003b3	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  003ba	41 8b 84 01 80
	02 00 00	 mov	 eax, DWORD PTR [r9+rax+640]
  003c2	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  003cd	8b 84 08 80 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx+640]
  003d4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  003df	44 8b 8c 10 80
	02 00 00	 mov	 r9d, DWORD PTR [rax+rdx+640]
  003e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  003ee	46 8b 84 00 80
	02 00 00	 mov	 r8d, DWORD PTR [rax+r8+640]
  003f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168396
  003fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00404	e8 00 00 00 00	 call	 gui_fprintf
$LN6@UpdateRegi:

; 919  : 
; 920  :                 "GR4-7="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 921  : 
; 922  :                 ,pTargetCPU_REGS->GR_L(4)
; 923  :                 ,pTargetCPU_REGS->GR_L(5)
; 924  :                 ,pTargetCPU_REGS->GR_L(6)
; 925  :                 ,pTargetCPU_REGS->GR_L(7)
; 926  :             );
; 927  :         }
; 928  : 
; 929  :         if (0
; 930  :             || prev_gr[8]  != pTargetCPU_REGS->GR_L(8)
; 931  :             || prev_gr[9]  != pTargetCPU_REGS->GR_L(9)
; 932  :             || prev_gr[10] != pTargetCPU_REGS->GR_L(10)
; 933  :             || prev_gr[11] != pTargetCPU_REGS->GR_L(11)

  00409	33 c0		 xor	 eax, eax
  0040b	85 c0		 test	 eax, eax
  0040d	0f 85 bc 00 00
	00		 jne	 $LN9@UpdateRegi
  00413	b8 04 00 00 00	 mov	 eax, 4
  00418	48 6b c0 08	 imul	 rax, rax, 8
  0041c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00423	ba 08 00 00 00	 mov	 edx, 8
  00428	48 6b d2 08	 imul	 rdx, rdx, 8
  0042c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00433	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0043b	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0043e	0f 85 8b 00 00
	00		 jne	 $LN9@UpdateRegi
  00444	b8 04 00 00 00	 mov	 eax, 4
  00449	48 6b c0 09	 imul	 rax, rax, 9
  0044d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00454	ba 08 00 00 00	 mov	 edx, 8
  00459	48 6b d2 09	 imul	 rdx, rdx, 9
  0045d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00464	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0046c	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0046f	75 5e		 jne	 SHORT $LN9@UpdateRegi
  00471	b8 04 00 00 00	 mov	 eax, 4
  00476	48 6b c0 0a	 imul	 rax, rax, 10
  0047a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00481	ba 08 00 00 00	 mov	 edx, 8
  00486	48 6b d2 0a	 imul	 rdx, rdx, 10
  0048a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00491	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00499	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0049c	75 31		 jne	 SHORT $LN9@UpdateRegi
  0049e	b8 04 00 00 00	 mov	 eax, 4
  004a3	48 6b c0 0b	 imul	 rax, rax, 11
  004a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  004ae	ba 08 00 00 00	 mov	 edx, 8
  004b3	48 6b d2 0b	 imul	 rdx, rdx, 11
  004b7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  004be	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  004c6	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  004c9	0f 84 27 01 00
	00		 je	 $LN8@UpdateRegi
$LN9@UpdateRegi:

; 934  :         )
; 935  :         {
; 936  :             prev_gr[8]  = pTargetCPU_REGS->GR_L(8);

  004cf	b8 08 00 00 00	 mov	 eax, 8
  004d4	48 6b c0 08	 imul	 rax, rax, 8
  004d8	b9 04 00 00 00	 mov	 ecx, 4
  004dd	48 6b c9 08	 imul	 rcx, rcx, 8
  004e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  004e8	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  004ef	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  004f7	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 937  :             prev_gr[9]  = pTargetCPU_REGS->GR_L(9);

  004fa	b8 08 00 00 00	 mov	 eax, 8
  004ff	48 6b c0 09	 imul	 rax, rax, 9
  00503	b9 04 00 00 00	 mov	 ecx, 4
  00508	48 6b c9 09	 imul	 rcx, rcx, 9
  0050c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  00513	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0051a	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  00522	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 938  :             prev_gr[10] = pTargetCPU_REGS->GR_L(10);

  00525	b8 08 00 00 00	 mov	 eax, 8
  0052a	48 6b c0 0a	 imul	 rax, rax, 10
  0052e	b9 04 00 00 00	 mov	 ecx, 4
  00533	48 6b c9 0a	 imul	 rcx, rcx, 10
  00537	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  0053e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00545	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  0054d	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 939  :             prev_gr[11] = pTargetCPU_REGS->GR_L(11);

  00550	b8 08 00 00 00	 mov	 eax, 8
  00555	48 6b c0 0b	 imul	 rax, rax, 11
  00559	b9 04 00 00 00	 mov	 ecx, 4
  0055e	48 6b c9 0b	 imul	 rcx, rcx, 11
  00562	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  00569	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00570	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  00578	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 940  : 
; 941  :             gui_fprintf(fStatusStream,

  0057b	b8 08 00 00 00	 mov	 eax, 8
  00580	48 6b c0 0b	 imul	 rax, rax, 11
  00584	b9 08 00 00 00	 mov	 ecx, 8
  00589	48 6b c9 0a	 imul	 rcx, rcx, 10
  0058d	ba 08 00 00 00	 mov	 edx, 8
  00592	48 6b d2 09	 imul	 rdx, rdx, 9
  00596	41 b8 08 00 00
	00		 mov	 r8d, 8
  0059c	4d 6b c0 08	 imul	 r8, r8, 8
  005a0	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  005a7	41 8b 84 01 80
	02 00 00	 mov	 eax, DWORD PTR [r9+rax+640]
  005af	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  005ba	8b 84 08 80 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx+640]
  005c1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  005cc	44 8b 8c 10 80
	02 00 00	 mov	 r9d, DWORD PTR [rax+rdx+640]
  005d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  005db	46 8b 84 00 80
	02 00 00	 mov	 r8d, DWORD PTR [rax+r8+640]
  005e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168399
  005ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  005f1	e8 00 00 00 00	 call	 gui_fprintf
$LN8@UpdateRegi:

; 942  : 
; 943  :                 "GR8-B="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 944  : 
; 945  :                 ,pTargetCPU_REGS->GR_L(8)
; 946  :                 ,pTargetCPU_REGS->GR_L(9)
; 947  :                 ,pTargetCPU_REGS->GR_L(10)
; 948  :                 ,pTargetCPU_REGS->GR_L(11)
; 949  :             );
; 950  :         }
; 951  : 
; 952  :         if (0
; 953  :             || prev_gr[12] != pTargetCPU_REGS->GR_L(12)
; 954  :             || prev_gr[13] != pTargetCPU_REGS->GR_L(13)
; 955  :             || prev_gr[14] != pTargetCPU_REGS->GR_L(14)
; 956  :             || prev_gr[15] != pTargetCPU_REGS->GR_L(15)

  005f6	33 c0		 xor	 eax, eax
  005f8	85 c0		 test	 eax, eax
  005fa	0f 85 bc 00 00
	00		 jne	 $LN11@UpdateRegi
  00600	b8 04 00 00 00	 mov	 eax, 4
  00605	48 6b c0 0c	 imul	 rax, rax, 12
  00609	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00610	ba 08 00 00 00	 mov	 edx, 8
  00615	48 6b d2 0c	 imul	 rdx, rdx, 12
  00619	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00620	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00628	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0062b	0f 85 8b 00 00
	00		 jne	 $LN11@UpdateRegi
  00631	b8 04 00 00 00	 mov	 eax, 4
  00636	48 6b c0 0d	 imul	 rax, rax, 13
  0063a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00641	ba 08 00 00 00	 mov	 edx, 8
  00646	48 6b d2 0d	 imul	 rdx, rdx, 13
  0064a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00651	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00659	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0065c	75 5e		 jne	 SHORT $LN11@UpdateRegi
  0065e	b8 04 00 00 00	 mov	 eax, 4
  00663	48 6b c0 0e	 imul	 rax, rax, 14
  00667	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  0066e	ba 08 00 00 00	 mov	 edx, 8
  00673	48 6b d2 0e	 imul	 rdx, rdx, 14
  00677	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0067e	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00686	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  00689	75 31		 jne	 SHORT $LN11@UpdateRegi
  0068b	b8 04 00 00 00	 mov	 eax, 4
  00690	48 6b c0 0f	 imul	 rax, rax, 15
  00694	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  0069b	ba 08 00 00 00	 mov	 edx, 8
  006a0	48 6b d2 0f	 imul	 rdx, rdx, 15
  006a4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  006ab	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  006b3	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  006b6	0f 84 27 01 00
	00		 je	 $LN10@UpdateRegi
$LN11@UpdateRegi:

; 957  :         )
; 958  :         {
; 959  :             prev_gr[12] = pTargetCPU_REGS->GR_L(12);

  006bc	b8 08 00 00 00	 mov	 eax, 8
  006c1	48 6b c0 0c	 imul	 rax, rax, 12
  006c5	b9 04 00 00 00	 mov	 ecx, 4
  006ca	48 6b c9 0c	 imul	 rcx, rcx, 12
  006ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  006d5	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  006dc	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  006e4	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 960  :             prev_gr[13] = pTargetCPU_REGS->GR_L(13);

  006e7	b8 08 00 00 00	 mov	 eax, 8
  006ec	48 6b c0 0d	 imul	 rax, rax, 13
  006f0	b9 04 00 00 00	 mov	 ecx, 4
  006f5	48 6b c9 0d	 imul	 rcx, rcx, 13
  006f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  00700	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00707	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  0070f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 961  :             prev_gr[14] = pTargetCPU_REGS->GR_L(14);

  00712	b8 08 00 00 00	 mov	 eax, 8
  00717	48 6b c0 0e	 imul	 rax, rax, 14
  0071b	b9 04 00 00 00	 mov	 ecx, 4
  00720	48 6b c9 0e	 imul	 rcx, rcx, 14
  00724	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  0072b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00732	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  0073a	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 962  :             prev_gr[15] = pTargetCPU_REGS->GR_L(15);

  0073d	b8 08 00 00 00	 mov	 eax, 8
  00742	48 6b c0 0f	 imul	 rax, rax, 15
  00746	b9 04 00 00 00	 mov	 ecx, 4
  0074b	48 6b c9 0f	 imul	 rcx, rcx, 15
  0074f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr
  00756	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0075d	41 8b 84 00 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax+640]
  00765	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 963  : 
; 964  :             gui_fprintf(fStatusStream,

  00768	b8 08 00 00 00	 mov	 eax, 8
  0076d	48 6b c0 0f	 imul	 rax, rax, 15
  00771	b9 08 00 00 00	 mov	 ecx, 8
  00776	48 6b c9 0e	 imul	 rcx, rcx, 14
  0077a	ba 08 00 00 00	 mov	 edx, 8
  0077f	48 6b d2 0d	 imul	 rdx, rdx, 13
  00783	41 b8 08 00 00
	00		 mov	 r8d, 8
  00789	4d 6b c0 0c	 imul	 r8, r8, 12
  0078d	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  00794	41 8b 84 01 80
	02 00 00	 mov	 eax, DWORD PTR [r9+rax+640]
  0079c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  007a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  007a7	8b 84 08 80 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx+640]
  007ae	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  007b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  007b9	44 8b 8c 10 80
	02 00 00	 mov	 r9d, DWORD PTR [rax+rdx+640]
  007c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  007c8	46 8b 84 00 80
	02 00 00	 mov	 r8d, DWORD PTR [rax+r8+640]
  007d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168402
  007d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  007de	e8 00 00 00 00	 call	 gui_fprintf
$LN10@UpdateRegi:
$LN3@UpdateRegi:

; 965  : 
; 966  :                 "GRC-F="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 967  : 
; 968  :                 ,pTargetCPU_REGS->GR_L(12)
; 969  :                 ,pTargetCPU_REGS->GR_L(13)
; 970  :                 ,pTargetCPU_REGS->GR_L(14)
; 971  :                 ,pTargetCPU_REGS->GR_L(15)
; 972  :             );
; 973  :         }
; 974  :     }
; 975  : 
; 976  :     if (gui_wants_gregs64)

  007e3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_gregs64
  007ea	85 c0		 test	 eax, eax
  007ec	0f 84 08 08 00
	00		 je	 $LN12@UpdateRegi

; 977  :     {
; 978  :         if (0
; 979  :             || prev_gr64[0] != pTargetCPU_REGS->GR_G(0)
; 980  :             || prev_gr64[1] != pTargetCPU_REGS->GR_G(1)

  007f2	33 c0		 xor	 eax, eax
  007f4	85 c0		 test	 eax, eax
  007f6	75 60		 jne	 SHORT $LN14@UpdateRegi
  007f8	b8 08 00 00 00	 mov	 eax, 8
  007fd	48 6b c0 00	 imul	 rax, rax, 0
  00801	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00808	ba 08 00 00 00	 mov	 edx, 8
  0080d	48 6b d2 00	 imul	 rdx, rdx, 0
  00811	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00818	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00820	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00824	75 32		 jne	 SHORT $LN14@UpdateRegi
  00826	b8 08 00 00 00	 mov	 eax, 8
  0082b	48 6b c0 01	 imul	 rax, rax, 1
  0082f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00836	ba 08 00 00 00	 mov	 edx, 8
  0083b	48 6b d2 01	 imul	 rdx, rdx, 1
  0083f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00846	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  0084e	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00852	0f 84 9b 00 00
	00		 je	 $LN13@UpdateRegi
$LN14@UpdateRegi:

; 981  :         )
; 982  :         {
; 983  :             prev_gr64[0] = pTargetCPU_REGS->GR_G(0);

  00858	b8 08 00 00 00	 mov	 eax, 8
  0085d	48 6b c0 00	 imul	 rax, rax, 0
  00861	b9 08 00 00 00	 mov	 ecx, 8
  00866	48 6b c9 00	 imul	 rcx, rcx, 0
  0086a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00871	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00878	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00880	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 984  :             prev_gr64[1] = pTargetCPU_REGS->GR_G(1);

  00884	b8 08 00 00 00	 mov	 eax, 8
  00889	48 6b c0 01	 imul	 rax, rax, 1
  0088d	b9 08 00 00 00	 mov	 ecx, 8
  00892	48 6b c9 01	 imul	 rcx, rcx, 1
  00896	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  0089d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  008a4	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  008ac	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 985  : 
; 986  :             gui_fprintf(fStatusStream,

  008b0	b8 08 00 00 00	 mov	 eax, 8
  008b5	48 6b c0 01	 imul	 rax, rax, 1
  008b9	b9 08 00 00 00	 mov	 ecx, 8
  008be	48 6b c9 00	 imul	 rcx, rcx, 0
  008c2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  008c9	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  008d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  008d8	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  008e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168406
  008e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  008ee	e8 00 00 00 00	 call	 gui_fprintf
$LN13@UpdateRegi:

; 987  : 
; 988  :                 "64_GR0-1="REG64FMT" "REG64FMT"\n"
; 989  : 
; 990  :                 ,pTargetCPU_REGS->GR_G(0)
; 991  :                 ,pTargetCPU_REGS->GR_G(1)
; 992  :             );
; 993  :         }
; 994  : 
; 995  :         if (0
; 996  :             || prev_gr64[2] != pTargetCPU_REGS->GR_G(2)
; 997  :             || prev_gr64[3] != pTargetCPU_REGS->GR_G(3)

  008f3	33 c0		 xor	 eax, eax
  008f5	85 c0		 test	 eax, eax
  008f7	75 60		 jne	 SHORT $LN16@UpdateRegi
  008f9	b8 08 00 00 00	 mov	 eax, 8
  008fe	48 6b c0 02	 imul	 rax, rax, 2
  00902	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00909	ba 08 00 00 00	 mov	 edx, 8
  0090e	48 6b d2 02	 imul	 rdx, rdx, 2
  00912	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00919	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00921	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00925	75 32		 jne	 SHORT $LN16@UpdateRegi
  00927	b8 08 00 00 00	 mov	 eax, 8
  0092c	48 6b c0 03	 imul	 rax, rax, 3
  00930	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00937	ba 08 00 00 00	 mov	 edx, 8
  0093c	48 6b d2 03	 imul	 rdx, rdx, 3
  00940	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00947	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  0094f	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00953	0f 84 9b 00 00
	00		 je	 $LN15@UpdateRegi
$LN16@UpdateRegi:

; 998  :         )
; 999  :         {
; 1000 :             prev_gr64[2] = pTargetCPU_REGS->GR_G(2);

  00959	b8 08 00 00 00	 mov	 eax, 8
  0095e	48 6b c0 02	 imul	 rax, rax, 2
  00962	b9 08 00 00 00	 mov	 ecx, 8
  00967	48 6b c9 02	 imul	 rcx, rcx, 2
  0096b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00972	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00979	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00981	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1001 :             prev_gr64[3] = pTargetCPU_REGS->GR_G(3);

  00985	b8 08 00 00 00	 mov	 eax, 8
  0098a	48 6b c0 03	 imul	 rax, rax, 3
  0098e	b9 08 00 00 00	 mov	 ecx, 8
  00993	48 6b c9 03	 imul	 rcx, rcx, 3
  00997	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  0099e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  009a5	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  009ad	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1002 : 
; 1003 :             gui_fprintf(fStatusStream,

  009b1	b8 08 00 00 00	 mov	 eax, 8
  009b6	48 6b c0 03	 imul	 rax, rax, 3
  009ba	b9 08 00 00 00	 mov	 ecx, 8
  009bf	48 6b c9 02	 imul	 rcx, rcx, 2
  009c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  009ca	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  009d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  009d9	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  009e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168409
  009e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  009ef	e8 00 00 00 00	 call	 gui_fprintf
$LN15@UpdateRegi:

; 1004 : 
; 1005 :                 "64_GR2-3="REG64FMT" "REG64FMT"\n"
; 1006 : 
; 1007 :                 ,pTargetCPU_REGS->GR_G(2)
; 1008 :                 ,pTargetCPU_REGS->GR_G(3)
; 1009 :             );
; 1010 :         }
; 1011 : 
; 1012 :         if (0
; 1013 :             || prev_gr64[4] != pTargetCPU_REGS->GR_G(4)
; 1014 :             || prev_gr64[5] != pTargetCPU_REGS->GR_G(5)

  009f4	33 c0		 xor	 eax, eax
  009f6	85 c0		 test	 eax, eax
  009f8	75 60		 jne	 SHORT $LN18@UpdateRegi
  009fa	b8 08 00 00 00	 mov	 eax, 8
  009ff	48 6b c0 04	 imul	 rax, rax, 4
  00a03	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00a0a	ba 08 00 00 00	 mov	 edx, 8
  00a0f	48 6b d2 04	 imul	 rdx, rdx, 4
  00a13	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00a1a	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00a22	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00a26	75 32		 jne	 SHORT $LN18@UpdateRegi
  00a28	b8 08 00 00 00	 mov	 eax, 8
  00a2d	48 6b c0 05	 imul	 rax, rax, 5
  00a31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00a38	ba 08 00 00 00	 mov	 edx, 8
  00a3d	48 6b d2 05	 imul	 rdx, rdx, 5
  00a41	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00a48	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00a50	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00a54	0f 84 9b 00 00
	00		 je	 $LN17@UpdateRegi
$LN18@UpdateRegi:

; 1015 :         )
; 1016 :         {
; 1017 :             prev_gr64[4] = pTargetCPU_REGS->GR_G(4);

  00a5a	b8 08 00 00 00	 mov	 eax, 8
  00a5f	48 6b c0 04	 imul	 rax, rax, 4
  00a63	b9 08 00 00 00	 mov	 ecx, 8
  00a68	48 6b c9 04	 imul	 rcx, rcx, 4
  00a6c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00a73	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00a7a	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00a82	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1018 :             prev_gr64[5] = pTargetCPU_REGS->GR_G(5);

  00a86	b8 08 00 00 00	 mov	 eax, 8
  00a8b	48 6b c0 05	 imul	 rax, rax, 5
  00a8f	b9 08 00 00 00	 mov	 ecx, 8
  00a94	48 6b c9 05	 imul	 rcx, rcx, 5
  00a98	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00a9f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00aa6	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00aae	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1019 : 
; 1020 :             gui_fprintf(fStatusStream,

  00ab2	b8 08 00 00 00	 mov	 eax, 8
  00ab7	48 6b c0 05	 imul	 rax, rax, 5
  00abb	b9 08 00 00 00	 mov	 ecx, 8
  00ac0	48 6b c9 04	 imul	 rcx, rcx, 4
  00ac4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  00acb	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  00ad3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00ada	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  00ae2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168412
  00ae9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00af0	e8 00 00 00 00	 call	 gui_fprintf
$LN17@UpdateRegi:

; 1021 : 
; 1022 :                 "64_GR4-5="REG64FMT" "REG64FMT"\n"
; 1023 : 
; 1024 :                 ,pTargetCPU_REGS->GR_G(4)
; 1025 :                 ,pTargetCPU_REGS->GR_G(5)
; 1026 :             );
; 1027 :         }
; 1028 : 
; 1029 :         if (0
; 1030 :             || prev_gr64[6] != pTargetCPU_REGS->GR_G(6)
; 1031 :             || prev_gr64[7] != pTargetCPU_REGS->GR_G(7)

  00af5	33 c0		 xor	 eax, eax
  00af7	85 c0		 test	 eax, eax
  00af9	75 60		 jne	 SHORT $LN20@UpdateRegi
  00afb	b8 08 00 00 00	 mov	 eax, 8
  00b00	48 6b c0 06	 imul	 rax, rax, 6
  00b04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00b0b	ba 08 00 00 00	 mov	 edx, 8
  00b10	48 6b d2 06	 imul	 rdx, rdx, 6
  00b14	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00b1b	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00b23	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00b27	75 32		 jne	 SHORT $LN20@UpdateRegi
  00b29	b8 08 00 00 00	 mov	 eax, 8
  00b2e	48 6b c0 07	 imul	 rax, rax, 7
  00b32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00b39	ba 08 00 00 00	 mov	 edx, 8
  00b3e	48 6b d2 07	 imul	 rdx, rdx, 7
  00b42	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00b49	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00b51	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00b55	0f 84 9b 00 00
	00		 je	 $LN19@UpdateRegi
$LN20@UpdateRegi:

; 1032 :         )
; 1033 :         {
; 1034 :             prev_gr64[6] = pTargetCPU_REGS->GR_G(6);

  00b5b	b8 08 00 00 00	 mov	 eax, 8
  00b60	48 6b c0 06	 imul	 rax, rax, 6
  00b64	b9 08 00 00 00	 mov	 ecx, 8
  00b69	48 6b c9 06	 imul	 rcx, rcx, 6
  00b6d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00b74	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00b7b	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00b83	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1035 :             prev_gr64[7] = pTargetCPU_REGS->GR_G(7);

  00b87	b8 08 00 00 00	 mov	 eax, 8
  00b8c	48 6b c0 07	 imul	 rax, rax, 7
  00b90	b9 08 00 00 00	 mov	 ecx, 8
  00b95	48 6b c9 07	 imul	 rcx, rcx, 7
  00b99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00ba0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00ba7	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00baf	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1036 : 
; 1037 :             gui_fprintf(fStatusStream,

  00bb3	b8 08 00 00 00	 mov	 eax, 8
  00bb8	48 6b c0 07	 imul	 rax, rax, 7
  00bbc	b9 08 00 00 00	 mov	 ecx, 8
  00bc1	48 6b c9 06	 imul	 rcx, rcx, 6
  00bc5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  00bcc	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  00bd4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00bdb	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  00be3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168415
  00bea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00bf1	e8 00 00 00 00	 call	 gui_fprintf
$LN19@UpdateRegi:

; 1038 : 
; 1039 :                 "64_GR6-7="REG64FMT" "REG64FMT"\n"
; 1040 : 
; 1041 :                 ,pTargetCPU_REGS->GR_G(6)
; 1042 :                 ,pTargetCPU_REGS->GR_G(7)
; 1043 :             );
; 1044 :         }
; 1045 : 
; 1046 :         if (0
; 1047 :             || prev_gr64[8]  != pTargetCPU_REGS->GR_G(8)
; 1048 :             || prev_gr64[9]  != pTargetCPU_REGS->GR_G(9)

  00bf6	33 c0		 xor	 eax, eax
  00bf8	85 c0		 test	 eax, eax
  00bfa	75 60		 jne	 SHORT $LN22@UpdateRegi
  00bfc	b8 08 00 00 00	 mov	 eax, 8
  00c01	48 6b c0 08	 imul	 rax, rax, 8
  00c05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00c0c	ba 08 00 00 00	 mov	 edx, 8
  00c11	48 6b d2 08	 imul	 rdx, rdx, 8
  00c15	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00c1c	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00c24	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00c28	75 32		 jne	 SHORT $LN22@UpdateRegi
  00c2a	b8 08 00 00 00	 mov	 eax, 8
  00c2f	48 6b c0 09	 imul	 rax, rax, 9
  00c33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00c3a	ba 08 00 00 00	 mov	 edx, 8
  00c3f	48 6b d2 09	 imul	 rdx, rdx, 9
  00c43	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00c4a	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00c52	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00c56	0f 84 9b 00 00
	00		 je	 $LN21@UpdateRegi
$LN22@UpdateRegi:

; 1049 :         )
; 1050 :         {
; 1051 :             prev_gr64[8] = pTargetCPU_REGS->GR_G(8);

  00c5c	b8 08 00 00 00	 mov	 eax, 8
  00c61	48 6b c0 08	 imul	 rax, rax, 8
  00c65	b9 08 00 00 00	 mov	 ecx, 8
  00c6a	48 6b c9 08	 imul	 rcx, rcx, 8
  00c6e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00c75	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00c7c	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00c84	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1052 :             prev_gr64[9] = pTargetCPU_REGS->GR_G(9);

  00c88	b8 08 00 00 00	 mov	 eax, 8
  00c8d	48 6b c0 09	 imul	 rax, rax, 9
  00c91	b9 08 00 00 00	 mov	 ecx, 8
  00c96	48 6b c9 09	 imul	 rcx, rcx, 9
  00c9a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00ca1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00ca8	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00cb0	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1053 : 
; 1054 :             gui_fprintf(fStatusStream,

  00cb4	b8 08 00 00 00	 mov	 eax, 8
  00cb9	48 6b c0 09	 imul	 rax, rax, 9
  00cbd	b9 08 00 00 00	 mov	 ecx, 8
  00cc2	48 6b c9 08	 imul	 rcx, rcx, 8
  00cc6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  00ccd	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  00cd5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00cdc	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  00ce4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168418
  00ceb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00cf2	e8 00 00 00 00	 call	 gui_fprintf
$LN21@UpdateRegi:

; 1055 : 
; 1056 :                 "64_GR8-9="REG64FMT" "REG64FMT"\n"
; 1057 : 
; 1058 :                 ,pTargetCPU_REGS->GR_G(8)
; 1059 :                 ,pTargetCPU_REGS->GR_G(9)
; 1060 :             );
; 1061 :         }
; 1062 : 
; 1063 :         if (0
; 1064 :             || prev_gr64[10] != pTargetCPU_REGS->GR_G(10)
; 1065 :             || prev_gr64[11] != pTargetCPU_REGS->GR_G(11)

  00cf7	33 c0		 xor	 eax, eax
  00cf9	85 c0		 test	 eax, eax
  00cfb	75 60		 jne	 SHORT $LN24@UpdateRegi
  00cfd	b8 08 00 00 00	 mov	 eax, 8
  00d02	48 6b c0 0a	 imul	 rax, rax, 10
  00d06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00d0d	ba 08 00 00 00	 mov	 edx, 8
  00d12	48 6b d2 0a	 imul	 rdx, rdx, 10
  00d16	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00d1d	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00d25	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00d29	75 32		 jne	 SHORT $LN24@UpdateRegi
  00d2b	b8 08 00 00 00	 mov	 eax, 8
  00d30	48 6b c0 0b	 imul	 rax, rax, 11
  00d34	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00d3b	ba 08 00 00 00	 mov	 edx, 8
  00d40	48 6b d2 0b	 imul	 rdx, rdx, 11
  00d44	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00d4b	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00d53	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00d57	0f 84 9b 00 00
	00		 je	 $LN23@UpdateRegi
$LN24@UpdateRegi:

; 1066 :         )
; 1067 :         {
; 1068 :             prev_gr64[10] = pTargetCPU_REGS->GR_G(10);

  00d5d	b8 08 00 00 00	 mov	 eax, 8
  00d62	48 6b c0 0a	 imul	 rax, rax, 10
  00d66	b9 08 00 00 00	 mov	 ecx, 8
  00d6b	48 6b c9 0a	 imul	 rcx, rcx, 10
  00d6f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00d76	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00d7d	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00d85	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1069 :             prev_gr64[11] = pTargetCPU_REGS->GR_G(11);

  00d89	b8 08 00 00 00	 mov	 eax, 8
  00d8e	48 6b c0 0b	 imul	 rax, rax, 11
  00d92	b9 08 00 00 00	 mov	 ecx, 8
  00d97	48 6b c9 0b	 imul	 rcx, rcx, 11
  00d9b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00da2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00da9	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00db1	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1070 : 
; 1071 :             gui_fprintf(fStatusStream,

  00db5	b8 08 00 00 00	 mov	 eax, 8
  00dba	48 6b c0 0b	 imul	 rax, rax, 11
  00dbe	b9 08 00 00 00	 mov	 ecx, 8
  00dc3	48 6b c9 0a	 imul	 rcx, rcx, 10
  00dc7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  00dce	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  00dd6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00ddd	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  00de5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168421
  00dec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00df3	e8 00 00 00 00	 call	 gui_fprintf
$LN23@UpdateRegi:

; 1072 : 
; 1073 :                 "64_GRA-B="REG64FMT" "REG64FMT"\n"
; 1074 : 
; 1075 :                 ,pTargetCPU_REGS->GR_G(10)
; 1076 :                 ,pTargetCPU_REGS->GR_G(11)
; 1077 :             );
; 1078 :         }
; 1079 : 
; 1080 :         if (0
; 1081 :             || prev_gr64[12] != pTargetCPU_REGS->GR_G(12)
; 1082 :             || prev_gr64[13] != pTargetCPU_REGS->GR_G(13)

  00df8	33 c0		 xor	 eax, eax
  00dfa	85 c0		 test	 eax, eax
  00dfc	75 60		 jne	 SHORT $LN26@UpdateRegi
  00dfe	b8 08 00 00 00	 mov	 eax, 8
  00e03	48 6b c0 0c	 imul	 rax, rax, 12
  00e07	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00e0e	ba 08 00 00 00	 mov	 edx, 8
  00e13	48 6b d2 0c	 imul	 rdx, rdx, 12
  00e17	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00e1e	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00e26	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00e2a	75 32		 jne	 SHORT $LN26@UpdateRegi
  00e2c	b8 08 00 00 00	 mov	 eax, 8
  00e31	48 6b c0 0d	 imul	 rax, rax, 13
  00e35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00e3c	ba 08 00 00 00	 mov	 edx, 8
  00e41	48 6b d2 0d	 imul	 rdx, rdx, 13
  00e45	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00e4c	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00e54	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00e58	0f 84 9b 00 00
	00		 je	 $LN25@UpdateRegi
$LN26@UpdateRegi:

; 1083 :         )
; 1084 :         {
; 1085 :             prev_gr64[12] = pTargetCPU_REGS->GR_G(12);

  00e5e	b8 08 00 00 00	 mov	 eax, 8
  00e63	48 6b c0 0c	 imul	 rax, rax, 12
  00e67	b9 08 00 00 00	 mov	 ecx, 8
  00e6c	48 6b c9 0c	 imul	 rcx, rcx, 12
  00e70	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00e77	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00e7e	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00e86	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1086 :             prev_gr64[13] = pTargetCPU_REGS->GR_G(13);

  00e8a	b8 08 00 00 00	 mov	 eax, 8
  00e8f	48 6b c0 0d	 imul	 rax, rax, 13
  00e93	b9 08 00 00 00	 mov	 ecx, 8
  00e98	48 6b c9 0d	 imul	 rcx, rcx, 13
  00e9c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00ea3	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00eaa	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00eb2	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1087 : 
; 1088 :             gui_fprintf(fStatusStream,

  00eb6	b8 08 00 00 00	 mov	 eax, 8
  00ebb	48 6b c0 0d	 imul	 rax, rax, 13
  00ebf	b9 08 00 00 00	 mov	 ecx, 8
  00ec4	48 6b c9 0c	 imul	 rcx, rcx, 12
  00ec8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  00ecf	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  00ed7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00ede	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  00ee6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168424
  00eed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00ef4	e8 00 00 00 00	 call	 gui_fprintf
$LN25@UpdateRegi:

; 1089 : 
; 1090 :                 "64_GRC-D="REG64FMT" "REG64FMT"\n"
; 1091 : 
; 1092 :                 ,pTargetCPU_REGS->GR_G(12)
; 1093 :                 ,pTargetCPU_REGS->GR_G(13)
; 1094 :             );
; 1095 :         }
; 1096 : 
; 1097 :         if (0
; 1098 :             || prev_gr64[14] != pTargetCPU_REGS->GR_G(14)
; 1099 :             || prev_gr64[15] != pTargetCPU_REGS->GR_G(15)

  00ef9	33 c0		 xor	 eax, eax
  00efb	85 c0		 test	 eax, eax
  00efd	75 60		 jne	 SHORT $LN28@UpdateRegi
  00eff	b8 08 00 00 00	 mov	 eax, 8
  00f04	48 6b c0 0e	 imul	 rax, rax, 14
  00f08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00f0f	ba 08 00 00 00	 mov	 edx, 8
  00f14	48 6b d2 0e	 imul	 rdx, rdx, 14
  00f18	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00f1f	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00f27	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00f2b	75 32		 jne	 SHORT $LN28@UpdateRegi
  00f2d	b8 08 00 00 00	 mov	 eax, 8
  00f32	48 6b c0 0f	 imul	 rax, rax, 15
  00f36	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  00f3d	ba 08 00 00 00	 mov	 edx, 8
  00f42	48 6b d2 0f	 imul	 rdx, rdx, 15
  00f46	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00f4d	49 8b 94 10 80
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+640]
  00f55	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00f59	0f 84 9b 00 00
	00		 je	 $LN27@UpdateRegi
$LN28@UpdateRegi:

; 1100 :         )
; 1101 :         {
; 1102 :             prev_gr64[14] = pTargetCPU_REGS->GR_G(14);

  00f5f	b8 08 00 00 00	 mov	 eax, 8
  00f64	48 6b c0 0e	 imul	 rax, rax, 14
  00f68	b9 08 00 00 00	 mov	 ecx, 8
  00f6d	48 6b c9 0e	 imul	 rcx, rcx, 14
  00f71	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00f78	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00f7f	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00f87	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1103 :             prev_gr64[15] = pTargetCPU_REGS->GR_G(15);

  00f8b	b8 08 00 00 00	 mov	 eax, 8
  00f90	48 6b c0 0f	 imul	 rax, rax, 15
  00f94	b9 08 00 00 00	 mov	 ecx, 8
  00f99	48 6b c9 0f	 imul	 rcx, rcx, 15
  00f9d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_gr64
  00fa4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  00fab	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  00fb3	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1104 : 
; 1105 :             gui_fprintf(fStatusStream,

  00fb7	b8 08 00 00 00	 mov	 eax, 8
  00fbc	48 6b c0 0f	 imul	 rax, rax, 15
  00fc0	b9 08 00 00 00	 mov	 ecx, 8
  00fc5	48 6b c9 0e	 imul	 rcx, rcx, 14
  00fc9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  00fd0	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  00fd8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00fdf	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  00fe7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168427
  00fee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00ff5	e8 00 00 00 00	 call	 gui_fprintf
$LN27@UpdateRegi:
$LN12@UpdateRegi:

; 1106 : 
; 1107 :                 "64_GRE-F="REG64FMT" "REG64FMT"\n"
; 1108 : 
; 1109 :                 ,pTargetCPU_REGS->GR_G(14)
; 1110 :                 ,pTargetCPU_REGS->GR_G(15)
; 1111 :             );
; 1112 :         }
; 1113 :     }
; 1114 : 
; 1115 :     if (gui_wants_cregs)

  00ffa	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_cregs
  01001	85 c0		 test	 eax, eax
  01003	0f 84 b4 07 00
	00		 je	 $LN29@UpdateRegi

; 1116 :     {
; 1117 :         if (0
; 1118 :             || prev_cr[0] != pTargetCPU_REGS->CR_L(0)
; 1119 :             || prev_cr[1] != pTargetCPU_REGS->CR_L(1)
; 1120 :             || prev_cr[2] != pTargetCPU_REGS->CR_L(2)
; 1121 :             || prev_cr[3] != pTargetCPU_REGS->CR_L(3)

  01009	33 c0		 xor	 eax, eax
  0100b	85 c0		 test	 eax, eax
  0100d	0f 85 bc 00 00
	00		 jne	 $LN31@UpdateRegi
  01013	b8 04 00 00 00	 mov	 eax, 4
  01018	48 6b c0 00	 imul	 rax, rax, 0
  0101c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  01023	ba 08 00 00 00	 mov	 edx, 8
  01028	48 6b d2 01	 imul	 rdx, rdx, 1
  0102c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01033	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  0103b	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0103e	0f 85 8b 00 00
	00		 jne	 $LN31@UpdateRegi
  01044	b8 04 00 00 00	 mov	 eax, 4
  01049	48 6b c0 01	 imul	 rax, rax, 1
  0104d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  01054	ba 08 00 00 00	 mov	 edx, 8
  01059	48 6b d2 02	 imul	 rdx, rdx, 2
  0105d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01064	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  0106c	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0106f	75 5e		 jne	 SHORT $LN31@UpdateRegi
  01071	b8 04 00 00 00	 mov	 eax, 4
  01076	48 6b c0 02	 imul	 rax, rax, 2
  0107a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  01081	ba 08 00 00 00	 mov	 edx, 8
  01086	48 6b d2 03	 imul	 rdx, rdx, 3
  0108a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01091	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01099	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0109c	75 31		 jne	 SHORT $LN31@UpdateRegi
  0109e	b8 04 00 00 00	 mov	 eax, 4
  010a3	48 6b c0 03	 imul	 rax, rax, 3
  010a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  010ae	ba 08 00 00 00	 mov	 edx, 8
  010b3	48 6b d2 04	 imul	 rdx, rdx, 4
  010b7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  010be	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  010c6	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  010c9	0f 84 27 01 00
	00		 je	 $LN30@UpdateRegi
$LN31@UpdateRegi:

; 1122 :         )
; 1123 :         {
; 1124 :             prev_cr[0] = pTargetCPU_REGS->CR_L(0);

  010cf	b8 08 00 00 00	 mov	 eax, 8
  010d4	48 6b c0 01	 imul	 rax, rax, 1
  010d8	b9 04 00 00 00	 mov	 ecx, 4
  010dd	48 6b c9 00	 imul	 rcx, rcx, 0
  010e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  010e8	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  010ef	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  010f7	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1125 :             prev_cr[1] = pTargetCPU_REGS->CR_L(1);

  010fa	b8 08 00 00 00	 mov	 eax, 8
  010ff	48 6b c0 02	 imul	 rax, rax, 2
  01103	b9 04 00 00 00	 mov	 ecx, 4
  01108	48 6b c9 01	 imul	 rcx, rcx, 1
  0110c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  01113	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0111a	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  01122	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1126 :             prev_cr[2] = pTargetCPU_REGS->CR_L(2);

  01125	b8 08 00 00 00	 mov	 eax, 8
  0112a	48 6b c0 03	 imul	 rax, rax, 3
  0112e	b9 04 00 00 00	 mov	 ecx, 4
  01133	48 6b c9 02	 imul	 rcx, rcx, 2
  01137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  0113e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01145	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  0114d	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1127 :             prev_cr[3] = pTargetCPU_REGS->CR_L(3);

  01150	b8 08 00 00 00	 mov	 eax, 8
  01155	48 6b c0 04	 imul	 rax, rax, 4
  01159	b9 04 00 00 00	 mov	 ecx, 4
  0115e	48 6b c9 03	 imul	 rcx, rcx, 3
  01162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  01169	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01170	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  01178	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1128 : 
; 1129 :             gui_fprintf(fStatusStream,

  0117b	b8 08 00 00 00	 mov	 eax, 8
  01180	48 6b c0 04	 imul	 rax, rax, 4
  01184	b9 08 00 00 00	 mov	 ecx, 8
  01189	48 6b c9 03	 imul	 rcx, rcx, 3
  0118d	ba 08 00 00 00	 mov	 edx, 8
  01192	48 6b d2 02	 imul	 rdx, rdx, 2
  01196	41 b8 08 00 00
	00		 mov	 r8d, 8
  0119c	4d 6b c0 01	 imul	 r8, r8, 1
  011a0	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  011a7	41 8b 84 01 00
	06 00 00	 mov	 eax, DWORD PTR [r9+rax+1536]
  011af	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  011b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  011ba	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  011c1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  011c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  011cc	44 8b 8c 10 00
	06 00 00	 mov	 r9d, DWORD PTR [rax+rdx+1536]
  011d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  011db	46 8b 84 00 00
	06 00 00	 mov	 r8d, DWORD PTR [rax+r8+1536]
  011e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168431
  011ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  011f1	e8 00 00 00 00	 call	 gui_fprintf
$LN30@UpdateRegi:

; 1130 : 
; 1131 :                 "CR0-3="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1132 : 
; 1133 :                 ,pTargetCPU_REGS->CR_L(0)
; 1134 :                 ,pTargetCPU_REGS->CR_L(1)
; 1135 :                 ,pTargetCPU_REGS->CR_L(2)
; 1136 :                 ,pTargetCPU_REGS->CR_L(3)
; 1137 :             );
; 1138 :         }
; 1139 : 
; 1140 :         if (0
; 1141 :             || prev_cr[4] != pTargetCPU_REGS->CR_L(4)
; 1142 :             || prev_cr[5] != pTargetCPU_REGS->CR_L(5)
; 1143 :             || prev_cr[6] != pTargetCPU_REGS->CR_L(6)
; 1144 :             || prev_cr[7] != pTargetCPU_REGS->CR_L(7)

  011f6	33 c0		 xor	 eax, eax
  011f8	85 c0		 test	 eax, eax
  011fa	0f 85 bc 00 00
	00		 jne	 $LN33@UpdateRegi
  01200	b8 04 00 00 00	 mov	 eax, 4
  01205	48 6b c0 04	 imul	 rax, rax, 4
  01209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  01210	ba 08 00 00 00	 mov	 edx, 8
  01215	48 6b d2 05	 imul	 rdx, rdx, 5
  01219	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01220	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01228	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0122b	0f 85 8b 00 00
	00		 jne	 $LN33@UpdateRegi
  01231	b8 04 00 00 00	 mov	 eax, 4
  01236	48 6b c0 05	 imul	 rax, rax, 5
  0123a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  01241	ba 08 00 00 00	 mov	 edx, 8
  01246	48 6b d2 06	 imul	 rdx, rdx, 6
  0124a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01251	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01259	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0125c	75 5e		 jne	 SHORT $LN33@UpdateRegi
  0125e	b8 04 00 00 00	 mov	 eax, 4
  01263	48 6b c0 06	 imul	 rax, rax, 6
  01267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  0126e	ba 08 00 00 00	 mov	 edx, 8
  01273	48 6b d2 07	 imul	 rdx, rdx, 7
  01277	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0127e	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01286	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  01289	75 31		 jne	 SHORT $LN33@UpdateRegi
  0128b	b8 04 00 00 00	 mov	 eax, 4
  01290	48 6b c0 07	 imul	 rax, rax, 7
  01294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  0129b	ba 08 00 00 00	 mov	 edx, 8
  012a0	48 6b d2 08	 imul	 rdx, rdx, 8
  012a4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  012ab	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  012b3	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  012b6	0f 84 27 01 00
	00		 je	 $LN32@UpdateRegi
$LN33@UpdateRegi:

; 1145 :         )
; 1146 :         {
; 1147 :             prev_cr[4] = pTargetCPU_REGS->CR_L(4);

  012bc	b8 08 00 00 00	 mov	 eax, 8
  012c1	48 6b c0 05	 imul	 rax, rax, 5
  012c5	b9 04 00 00 00	 mov	 ecx, 4
  012ca	48 6b c9 04	 imul	 rcx, rcx, 4
  012ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  012d5	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  012dc	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  012e4	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1148 :             prev_cr[5] = pTargetCPU_REGS->CR_L(5);

  012e7	b8 08 00 00 00	 mov	 eax, 8
  012ec	48 6b c0 06	 imul	 rax, rax, 6
  012f0	b9 04 00 00 00	 mov	 ecx, 4
  012f5	48 6b c9 05	 imul	 rcx, rcx, 5
  012f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  01300	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01307	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  0130f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1149 :             prev_cr[6] = pTargetCPU_REGS->CR_L(6);

  01312	b8 08 00 00 00	 mov	 eax, 8
  01317	48 6b c0 07	 imul	 rax, rax, 7
  0131b	b9 04 00 00 00	 mov	 ecx, 4
  01320	48 6b c9 06	 imul	 rcx, rcx, 6
  01324	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  0132b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01332	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  0133a	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1150 :             prev_cr[7] = pTargetCPU_REGS->CR_L(7);

  0133d	b8 08 00 00 00	 mov	 eax, 8
  01342	48 6b c0 08	 imul	 rax, rax, 8
  01346	b9 04 00 00 00	 mov	 ecx, 4
  0134b	48 6b c9 07	 imul	 rcx, rcx, 7
  0134f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  01356	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0135d	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  01365	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1151 : 
; 1152 :             gui_fprintf(fStatusStream,

  01368	b8 08 00 00 00	 mov	 eax, 8
  0136d	48 6b c0 08	 imul	 rax, rax, 8
  01371	b9 08 00 00 00	 mov	 ecx, 8
  01376	48 6b c9 07	 imul	 rcx, rcx, 7
  0137a	ba 08 00 00 00	 mov	 edx, 8
  0137f	48 6b d2 06	 imul	 rdx, rdx, 6
  01383	41 b8 08 00 00
	00		 mov	 r8d, 8
  01389	4d 6b c0 05	 imul	 r8, r8, 5
  0138d	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  01394	41 8b 84 01 00
	06 00 00	 mov	 eax, DWORD PTR [r9+rax+1536]
  0139c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  013a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  013a7	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  013ae	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  013b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  013b9	44 8b 8c 10 00
	06 00 00	 mov	 r9d, DWORD PTR [rax+rdx+1536]
  013c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  013c8	46 8b 84 00 00
	06 00 00	 mov	 r8d, DWORD PTR [rax+r8+1536]
  013d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168434
  013d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  013de	e8 00 00 00 00	 call	 gui_fprintf
$LN32@UpdateRegi:

; 1153 : 
; 1154 :                 "CR4-7="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1155 : 
; 1156 :                 ,pTargetCPU_REGS->CR_L(4)
; 1157 :                 ,pTargetCPU_REGS->CR_L(5)
; 1158 :                 ,pTargetCPU_REGS->CR_L(6)
; 1159 :                 ,pTargetCPU_REGS->CR_L(7)
; 1160 :             );
; 1161 :         }
; 1162 : 
; 1163 :         if (0
; 1164 :             || prev_cr[8]  != pTargetCPU_REGS->CR_L(8)
; 1165 :             || prev_cr[9]  != pTargetCPU_REGS->CR_L(9)
; 1166 :             || prev_cr[10] != pTargetCPU_REGS->CR_L(10)
; 1167 :             || prev_cr[11] != pTargetCPU_REGS->CR_L(11)

  013e3	33 c0		 xor	 eax, eax
  013e5	85 c0		 test	 eax, eax
  013e7	0f 85 bc 00 00
	00		 jne	 $LN35@UpdateRegi
  013ed	b8 04 00 00 00	 mov	 eax, 4
  013f2	48 6b c0 08	 imul	 rax, rax, 8
  013f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  013fd	ba 08 00 00 00	 mov	 edx, 8
  01402	48 6b d2 09	 imul	 rdx, rdx, 9
  01406	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0140d	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01415	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  01418	0f 85 8b 00 00
	00		 jne	 $LN35@UpdateRegi
  0141e	b8 04 00 00 00	 mov	 eax, 4
  01423	48 6b c0 09	 imul	 rax, rax, 9
  01427	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  0142e	ba 08 00 00 00	 mov	 edx, 8
  01433	48 6b d2 0a	 imul	 rdx, rdx, 10
  01437	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0143e	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01446	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  01449	75 5e		 jne	 SHORT $LN35@UpdateRegi
  0144b	b8 04 00 00 00	 mov	 eax, 4
  01450	48 6b c0 0a	 imul	 rax, rax, 10
  01454	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  0145b	ba 08 00 00 00	 mov	 edx, 8
  01460	48 6b d2 0b	 imul	 rdx, rdx, 11
  01464	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0146b	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01473	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  01476	75 31		 jne	 SHORT $LN35@UpdateRegi
  01478	b8 04 00 00 00	 mov	 eax, 4
  0147d	48 6b c0 0b	 imul	 rax, rax, 11
  01481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  01488	ba 08 00 00 00	 mov	 edx, 8
  0148d	48 6b d2 0c	 imul	 rdx, rdx, 12
  01491	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01498	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  014a0	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  014a3	0f 84 27 01 00
	00		 je	 $LN34@UpdateRegi
$LN35@UpdateRegi:

; 1168 :         )
; 1169 :         {
; 1170 :             prev_cr[8]  = pTargetCPU_REGS->CR_L(8);

  014a9	b8 08 00 00 00	 mov	 eax, 8
  014ae	48 6b c0 09	 imul	 rax, rax, 9
  014b2	b9 04 00 00 00	 mov	 ecx, 4
  014b7	48 6b c9 08	 imul	 rcx, rcx, 8
  014bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  014c2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  014c9	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  014d1	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1171 :             prev_cr[9]  = pTargetCPU_REGS->CR_L(9);

  014d4	b8 08 00 00 00	 mov	 eax, 8
  014d9	48 6b c0 0a	 imul	 rax, rax, 10
  014dd	b9 04 00 00 00	 mov	 ecx, 4
  014e2	48 6b c9 09	 imul	 rcx, rcx, 9
  014e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  014ed	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  014f4	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  014fc	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1172 :             prev_cr[10] = pTargetCPU_REGS->CR_L(10);

  014ff	b8 08 00 00 00	 mov	 eax, 8
  01504	48 6b c0 0b	 imul	 rax, rax, 11
  01508	b9 04 00 00 00	 mov	 ecx, 4
  0150d	48 6b c9 0a	 imul	 rcx, rcx, 10
  01511	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  01518	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0151f	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  01527	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1173 :             prev_cr[10] = pTargetCPU_REGS->CR_L(10);

  0152a	b8 08 00 00 00	 mov	 eax, 8
  0152f	48 6b c0 0b	 imul	 rax, rax, 11
  01533	b9 04 00 00 00	 mov	 ecx, 4
  01538	48 6b c9 0a	 imul	 rcx, rcx, 10
  0153c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  01543	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0154a	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  01552	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1174 : 
; 1175 :             gui_fprintf(fStatusStream,

  01555	b8 08 00 00 00	 mov	 eax, 8
  0155a	48 6b c0 0c	 imul	 rax, rax, 12
  0155e	b9 08 00 00 00	 mov	 ecx, 8
  01563	48 6b c9 0b	 imul	 rcx, rcx, 11
  01567	ba 08 00 00 00	 mov	 edx, 8
  0156c	48 6b d2 0a	 imul	 rdx, rdx, 10
  01570	41 b8 08 00 00
	00		 mov	 r8d, 8
  01576	4d 6b c0 09	 imul	 r8, r8, 9
  0157a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  01581	41 8b 84 01 00
	06 00 00	 mov	 eax, DWORD PTR [r9+rax+1536]
  01589	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0158d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01594	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0159b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0159f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  015a6	44 8b 8c 10 00
	06 00 00	 mov	 r9d, DWORD PTR [rax+rdx+1536]
  015ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  015b5	46 8b 84 00 00
	06 00 00	 mov	 r8d, DWORD PTR [rax+r8+1536]
  015bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168437
  015c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  015cb	e8 00 00 00 00	 call	 gui_fprintf
$LN34@UpdateRegi:

; 1176 : 
; 1177 :                 "CR8-B="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1178 : 
; 1179 :                 ,pTargetCPU_REGS->CR_L(8)
; 1180 :                 ,pTargetCPU_REGS->CR_L(9)
; 1181 :                 ,pTargetCPU_REGS->CR_L(10)
; 1182 :                 ,pTargetCPU_REGS->CR_L(11)
; 1183 :             );
; 1184 :         }
; 1185 : 
; 1186 :         if (0
; 1187 :             || prev_cr[12] != pTargetCPU_REGS->CR_L(12)
; 1188 :             || prev_cr[13] != pTargetCPU_REGS->CR_L(13)
; 1189 :             || prev_cr[14] != pTargetCPU_REGS->CR_L(14)
; 1190 :             || prev_cr[15] != pTargetCPU_REGS->CR_L(15)

  015d0	33 c0		 xor	 eax, eax
  015d2	85 c0		 test	 eax, eax
  015d4	0f 85 bc 00 00
	00		 jne	 $LN37@UpdateRegi
  015da	b8 04 00 00 00	 mov	 eax, 4
  015df	48 6b c0 0c	 imul	 rax, rax, 12
  015e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  015ea	ba 08 00 00 00	 mov	 edx, 8
  015ef	48 6b d2 0d	 imul	 rdx, rdx, 13
  015f3	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  015fa	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01602	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  01605	0f 85 8b 00 00
	00		 jne	 $LN37@UpdateRegi
  0160b	b8 04 00 00 00	 mov	 eax, 4
  01610	48 6b c0 0d	 imul	 rax, rax, 13
  01614	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  0161b	ba 08 00 00 00	 mov	 edx, 8
  01620	48 6b d2 0e	 imul	 rdx, rdx, 14
  01624	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0162b	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01633	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  01636	75 5e		 jne	 SHORT $LN37@UpdateRegi
  01638	b8 04 00 00 00	 mov	 eax, 4
  0163d	48 6b c0 0e	 imul	 rax, rax, 14
  01641	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  01648	ba 08 00 00 00	 mov	 edx, 8
  0164d	48 6b d2 0f	 imul	 rdx, rdx, 15
  01651	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01658	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  01660	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  01663	75 31		 jne	 SHORT $LN37@UpdateRegi
  01665	b8 04 00 00 00	 mov	 eax, 4
  0166a	48 6b c0 0f	 imul	 rax, rax, 15
  0166e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  01675	ba 08 00 00 00	 mov	 edx, 8
  0167a	48 6b d2 10	 imul	 rdx, rdx, 16
  0167e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01685	41 8b 94 10 00
	06 00 00	 mov	 edx, DWORD PTR [r8+rdx+1536]
  0168d	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  01690	0f 84 27 01 00
	00		 je	 $LN36@UpdateRegi
$LN37@UpdateRegi:

; 1191 :         )
; 1192 :         {
; 1193 :             prev_cr[12] = pTargetCPU_REGS->CR_L(12);

  01696	b8 08 00 00 00	 mov	 eax, 8
  0169b	48 6b c0 0d	 imul	 rax, rax, 13
  0169f	b9 04 00 00 00	 mov	 ecx, 4
  016a4	48 6b c9 0c	 imul	 rcx, rcx, 12
  016a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  016af	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  016b6	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  016be	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1194 :             prev_cr[13] = pTargetCPU_REGS->CR_L(13);

  016c1	b8 08 00 00 00	 mov	 eax, 8
  016c6	48 6b c0 0e	 imul	 rax, rax, 14
  016ca	b9 04 00 00 00	 mov	 ecx, 4
  016cf	48 6b c9 0d	 imul	 rcx, rcx, 13
  016d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  016da	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  016e1	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  016e9	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1195 :             prev_cr[14] = pTargetCPU_REGS->CR_L(14);

  016ec	b8 08 00 00 00	 mov	 eax, 8
  016f1	48 6b c0 0f	 imul	 rax, rax, 15
  016f5	b9 04 00 00 00	 mov	 ecx, 4
  016fa	48 6b c9 0e	 imul	 rcx, rcx, 14
  016fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  01705	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0170c	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  01714	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1196 :             prev_cr[15] = pTargetCPU_REGS->CR_L(15);

  01717	b8 08 00 00 00	 mov	 eax, 8
  0171c	48 6b c0 10	 imul	 rax, rax, 16
  01720	b9 04 00 00 00	 mov	 ecx, 4
  01725	48 6b c9 0f	 imul	 rcx, rcx, 15
  01729	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr
  01730	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01737	41 8b 84 00 00
	06 00 00	 mov	 eax, DWORD PTR [r8+rax+1536]
  0173f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1197 : 
; 1198 :             gui_fprintf(fStatusStream,

  01742	b8 08 00 00 00	 mov	 eax, 8
  01747	48 6b c0 10	 imul	 rax, rax, 16
  0174b	b9 08 00 00 00	 mov	 ecx, 8
  01750	48 6b c9 0f	 imul	 rcx, rcx, 15
  01754	ba 08 00 00 00	 mov	 edx, 8
  01759	48 6b d2 0e	 imul	 rdx, rdx, 14
  0175d	41 b8 08 00 00
	00		 mov	 r8d, 8
  01763	4d 6b c0 0d	 imul	 r8, r8, 13
  01767	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  0176e	41 8b 84 01 00
	06 00 00	 mov	 eax, DWORD PTR [r9+rax+1536]
  01776	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0177a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01781	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  01788	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0178c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01793	44 8b 8c 10 00
	06 00 00	 mov	 r9d, DWORD PTR [rax+rdx+1536]
  0179b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  017a2	46 8b 84 00 00
	06 00 00	 mov	 r8d, DWORD PTR [rax+r8+1536]
  017aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168440
  017b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  017b8	e8 00 00 00 00	 call	 gui_fprintf
$LN36@UpdateRegi:
$LN29@UpdateRegi:

; 1199 : 
; 1200 :                 "CRC-F="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1201 : 
; 1202 :                 ,pTargetCPU_REGS->CR_L(12)
; 1203 :                 ,pTargetCPU_REGS->CR_L(13)
; 1204 :                 ,pTargetCPU_REGS->CR_L(14)
; 1205 :                 ,pTargetCPU_REGS->CR_L(15)
; 1206 :             );
; 1207 :         }
; 1208 :     }
; 1209 : 
; 1210 :     if (gui_wants_cregs64)

  017bd	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_cregs64
  017c4	85 c0		 test	 eax, eax
  017c6	0f 84 08 08 00
	00		 je	 $LN38@UpdateRegi

; 1211 :     {
; 1212 :         if (0
; 1213 :             || prev_cr64[0] != pTargetCPU_REGS->CR_G(0)
; 1214 :             || prev_cr64[1] != pTargetCPU_REGS->CR_G(1)

  017cc	33 c0		 xor	 eax, eax
  017ce	85 c0		 test	 eax, eax
  017d0	75 60		 jne	 SHORT $LN40@UpdateRegi
  017d2	b8 08 00 00 00	 mov	 eax, 8
  017d7	48 6b c0 00	 imul	 rax, rax, 0
  017db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  017e2	ba 08 00 00 00	 mov	 edx, 8
  017e7	48 6b d2 01	 imul	 rdx, rdx, 1
  017eb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  017f2	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  017fa	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  017fe	75 32		 jne	 SHORT $LN40@UpdateRegi
  01800	b8 08 00 00 00	 mov	 eax, 8
  01805	48 6b c0 01	 imul	 rax, rax, 1
  01809	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01810	ba 08 00 00 00	 mov	 edx, 8
  01815	48 6b d2 02	 imul	 rdx, rdx, 2
  01819	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01820	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01828	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  0182c	0f 84 9b 00 00
	00		 je	 $LN39@UpdateRegi
$LN40@UpdateRegi:

; 1215 :         )
; 1216 :         {
; 1217 :             prev_cr64[0] = pTargetCPU_REGS->CR_G(0);

  01832	b8 08 00 00 00	 mov	 eax, 8
  01837	48 6b c0 01	 imul	 rax, rax, 1
  0183b	b9 08 00 00 00	 mov	 ecx, 8
  01840	48 6b c9 00	 imul	 rcx, rcx, 0
  01844	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  0184b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01852	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  0185a	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1218 :             prev_cr64[1] = pTargetCPU_REGS->CR_G(1);

  0185e	b8 08 00 00 00	 mov	 eax, 8
  01863	48 6b c0 02	 imul	 rax, rax, 2
  01867	b9 08 00 00 00	 mov	 ecx, 8
  0186c	48 6b c9 01	 imul	 rcx, rcx, 1
  01870	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01877	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0187e	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01886	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1219 : 
; 1220 :             gui_fprintf(fStatusStream,

  0188a	b8 08 00 00 00	 mov	 eax, 8
  0188f	48 6b c0 02	 imul	 rax, rax, 2
  01893	b9 08 00 00 00	 mov	 ecx, 8
  01898	48 6b c9 01	 imul	 rcx, rcx, 1
  0189c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  018a3	4c 8b 8c 02 00
	06 00 00	 mov	 r9, QWORD PTR [rdx+rax+1536]
  018ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  018b2	4c 8b 84 08 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rcx+1536]
  018ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168444
  018c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  018c8	e8 00 00 00 00	 call	 gui_fprintf
$LN39@UpdateRegi:

; 1221 : 
; 1222 :                 "64_CR0-1="REG64FMT" "REG64FMT"\n"
; 1223 : 
; 1224 :                 ,pTargetCPU_REGS->CR_G(0)
; 1225 :                 ,pTargetCPU_REGS->CR_G(1)
; 1226 :             );
; 1227 :         }
; 1228 : 
; 1229 :         if (0
; 1230 :             || prev_cr64[2] != pTargetCPU_REGS->CR_G(2)
; 1231 :             || prev_cr64[3] != pTargetCPU_REGS->CR_G(3)

  018cd	33 c0		 xor	 eax, eax
  018cf	85 c0		 test	 eax, eax
  018d1	75 60		 jne	 SHORT $LN42@UpdateRegi
  018d3	b8 08 00 00 00	 mov	 eax, 8
  018d8	48 6b c0 02	 imul	 rax, rax, 2
  018dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  018e3	ba 08 00 00 00	 mov	 edx, 8
  018e8	48 6b d2 03	 imul	 rdx, rdx, 3
  018ec	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  018f3	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  018fb	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  018ff	75 32		 jne	 SHORT $LN42@UpdateRegi
  01901	b8 08 00 00 00	 mov	 eax, 8
  01906	48 6b c0 03	 imul	 rax, rax, 3
  0190a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01911	ba 08 00 00 00	 mov	 edx, 8
  01916	48 6b d2 04	 imul	 rdx, rdx, 4
  0191a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01921	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01929	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  0192d	0f 84 9b 00 00
	00		 je	 $LN41@UpdateRegi
$LN42@UpdateRegi:

; 1232 :         )
; 1233 :         {
; 1234 :             prev_cr64[2] = pTargetCPU_REGS->CR_G(2);

  01933	b8 08 00 00 00	 mov	 eax, 8
  01938	48 6b c0 03	 imul	 rax, rax, 3
  0193c	b9 08 00 00 00	 mov	 ecx, 8
  01941	48 6b c9 02	 imul	 rcx, rcx, 2
  01945	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  0194c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01953	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  0195b	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1235 :             prev_cr64[3] = pTargetCPU_REGS->CR_G(3);

  0195f	b8 08 00 00 00	 mov	 eax, 8
  01964	48 6b c0 04	 imul	 rax, rax, 4
  01968	b9 08 00 00 00	 mov	 ecx, 8
  0196d	48 6b c9 03	 imul	 rcx, rcx, 3
  01971	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01978	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0197f	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01987	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1236 : 
; 1237 :             gui_fprintf(fStatusStream,

  0198b	b8 08 00 00 00	 mov	 eax, 8
  01990	48 6b c0 04	 imul	 rax, rax, 4
  01994	b9 08 00 00 00	 mov	 ecx, 8
  01999	48 6b c9 03	 imul	 rcx, rcx, 3
  0199d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  019a4	4c 8b 8c 02 00
	06 00 00	 mov	 r9, QWORD PTR [rdx+rax+1536]
  019ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  019b3	4c 8b 84 08 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rcx+1536]
  019bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168447
  019c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  019c9	e8 00 00 00 00	 call	 gui_fprintf
$LN41@UpdateRegi:

; 1238 : 
; 1239 :                 "64_CR2-3="REG64FMT" "REG64FMT"\n"
; 1240 : 
; 1241 :                 ,pTargetCPU_REGS->CR_G(2)
; 1242 :                 ,pTargetCPU_REGS->CR_G(3)
; 1243 :             );
; 1244 :         }
; 1245 : 
; 1246 :         if (0
; 1247 :             || prev_cr64[4] != pTargetCPU_REGS->CR_G(4)
; 1248 :             || prev_cr64[5] != pTargetCPU_REGS->CR_G(5)

  019ce	33 c0		 xor	 eax, eax
  019d0	85 c0		 test	 eax, eax
  019d2	75 60		 jne	 SHORT $LN44@UpdateRegi
  019d4	b8 08 00 00 00	 mov	 eax, 8
  019d9	48 6b c0 04	 imul	 rax, rax, 4
  019dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  019e4	ba 08 00 00 00	 mov	 edx, 8
  019e9	48 6b d2 05	 imul	 rdx, rdx, 5
  019ed	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  019f4	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  019fc	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01a00	75 32		 jne	 SHORT $LN44@UpdateRegi
  01a02	b8 08 00 00 00	 mov	 eax, 8
  01a07	48 6b c0 05	 imul	 rax, rax, 5
  01a0b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01a12	ba 08 00 00 00	 mov	 edx, 8
  01a17	48 6b d2 06	 imul	 rdx, rdx, 6
  01a1b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01a22	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01a2a	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01a2e	0f 84 9b 00 00
	00		 je	 $LN43@UpdateRegi
$LN44@UpdateRegi:

; 1249 :         )
; 1250 :         {
; 1251 :             prev_cr64[4] = pTargetCPU_REGS->CR_G(4);

  01a34	b8 08 00 00 00	 mov	 eax, 8
  01a39	48 6b c0 05	 imul	 rax, rax, 5
  01a3d	b9 08 00 00 00	 mov	 ecx, 8
  01a42	48 6b c9 04	 imul	 rcx, rcx, 4
  01a46	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01a4d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01a54	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01a5c	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1252 :             prev_cr64[5] = pTargetCPU_REGS->CR_G(5);

  01a60	b8 08 00 00 00	 mov	 eax, 8
  01a65	48 6b c0 06	 imul	 rax, rax, 6
  01a69	b9 08 00 00 00	 mov	 ecx, 8
  01a6e	48 6b c9 05	 imul	 rcx, rcx, 5
  01a72	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01a79	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01a80	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01a88	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1253 : 
; 1254 :             gui_fprintf(fStatusStream,

  01a8c	b8 08 00 00 00	 mov	 eax, 8
  01a91	48 6b c0 06	 imul	 rax, rax, 6
  01a95	b9 08 00 00 00	 mov	 ecx, 8
  01a9a	48 6b c9 05	 imul	 rcx, rcx, 5
  01a9e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  01aa5	4c 8b 8c 02 00
	06 00 00	 mov	 r9, QWORD PTR [rdx+rax+1536]
  01aad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01ab4	4c 8b 84 08 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rcx+1536]
  01abc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168450
  01ac3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  01aca	e8 00 00 00 00	 call	 gui_fprintf
$LN43@UpdateRegi:

; 1255 : 
; 1256 :                 "64_CR4-5="REG64FMT" "REG64FMT"\n"
; 1257 : 
; 1258 :                 ,pTargetCPU_REGS->CR_G(4)
; 1259 :                 ,pTargetCPU_REGS->CR_G(5)
; 1260 :             );
; 1261 :         }
; 1262 : 
; 1263 :         if (0
; 1264 :             || prev_cr64[6] != pTargetCPU_REGS->CR_G(6)
; 1265 :             || prev_cr64[7] != pTargetCPU_REGS->CR_G(7)

  01acf	33 c0		 xor	 eax, eax
  01ad1	85 c0		 test	 eax, eax
  01ad3	75 60		 jne	 SHORT $LN46@UpdateRegi
  01ad5	b8 08 00 00 00	 mov	 eax, 8
  01ada	48 6b c0 06	 imul	 rax, rax, 6
  01ade	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01ae5	ba 08 00 00 00	 mov	 edx, 8
  01aea	48 6b d2 07	 imul	 rdx, rdx, 7
  01aee	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01af5	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01afd	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01b01	75 32		 jne	 SHORT $LN46@UpdateRegi
  01b03	b8 08 00 00 00	 mov	 eax, 8
  01b08	48 6b c0 07	 imul	 rax, rax, 7
  01b0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01b13	ba 08 00 00 00	 mov	 edx, 8
  01b18	48 6b d2 08	 imul	 rdx, rdx, 8
  01b1c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01b23	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01b2b	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01b2f	0f 84 9b 00 00
	00		 je	 $LN45@UpdateRegi
$LN46@UpdateRegi:

; 1266 :         )
; 1267 :         {
; 1268 :             prev_cr64[6] = pTargetCPU_REGS->CR_G(6);

  01b35	b8 08 00 00 00	 mov	 eax, 8
  01b3a	48 6b c0 07	 imul	 rax, rax, 7
  01b3e	b9 08 00 00 00	 mov	 ecx, 8
  01b43	48 6b c9 06	 imul	 rcx, rcx, 6
  01b47	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01b4e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01b55	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01b5d	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1269 :             prev_cr64[7] = pTargetCPU_REGS->CR_G(7);

  01b61	b8 08 00 00 00	 mov	 eax, 8
  01b66	48 6b c0 08	 imul	 rax, rax, 8
  01b6a	b9 08 00 00 00	 mov	 ecx, 8
  01b6f	48 6b c9 07	 imul	 rcx, rcx, 7
  01b73	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01b7a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01b81	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01b89	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1270 : 
; 1271 :             gui_fprintf(fStatusStream,

  01b8d	b8 08 00 00 00	 mov	 eax, 8
  01b92	48 6b c0 08	 imul	 rax, rax, 8
  01b96	b9 08 00 00 00	 mov	 ecx, 8
  01b9b	48 6b c9 07	 imul	 rcx, rcx, 7
  01b9f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  01ba6	4c 8b 8c 02 00
	06 00 00	 mov	 r9, QWORD PTR [rdx+rax+1536]
  01bae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01bb5	4c 8b 84 08 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rcx+1536]
  01bbd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168453
  01bc4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  01bcb	e8 00 00 00 00	 call	 gui_fprintf
$LN45@UpdateRegi:

; 1272 : 
; 1273 :                 "64_CR6-7="REG64FMT" "REG64FMT"\n"
; 1274 : 
; 1275 :                 ,pTargetCPU_REGS->CR_G(6)
; 1276 :                 ,pTargetCPU_REGS->CR_G(7)
; 1277 :             );
; 1278 :         }
; 1279 : 
; 1280 :         if (0
; 1281 :             || prev_cr64[8]  != pTargetCPU_REGS->CR_G(8)
; 1282 :             || prev_cr64[9]  != pTargetCPU_REGS->CR_G(9)

  01bd0	33 c0		 xor	 eax, eax
  01bd2	85 c0		 test	 eax, eax
  01bd4	75 60		 jne	 SHORT $LN48@UpdateRegi
  01bd6	b8 08 00 00 00	 mov	 eax, 8
  01bdb	48 6b c0 08	 imul	 rax, rax, 8
  01bdf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01be6	ba 08 00 00 00	 mov	 edx, 8
  01beb	48 6b d2 09	 imul	 rdx, rdx, 9
  01bef	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01bf6	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01bfe	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01c02	75 32		 jne	 SHORT $LN48@UpdateRegi
  01c04	b8 08 00 00 00	 mov	 eax, 8
  01c09	48 6b c0 09	 imul	 rax, rax, 9
  01c0d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01c14	ba 08 00 00 00	 mov	 edx, 8
  01c19	48 6b d2 0a	 imul	 rdx, rdx, 10
  01c1d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01c24	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01c2c	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01c30	0f 84 9b 00 00
	00		 je	 $LN47@UpdateRegi
$LN48@UpdateRegi:

; 1283 :         )
; 1284 :         {
; 1285 :             prev_cr64[8] = pTargetCPU_REGS->CR_G(8);

  01c36	b8 08 00 00 00	 mov	 eax, 8
  01c3b	48 6b c0 09	 imul	 rax, rax, 9
  01c3f	b9 08 00 00 00	 mov	 ecx, 8
  01c44	48 6b c9 08	 imul	 rcx, rcx, 8
  01c48	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01c4f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01c56	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01c5e	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1286 :             prev_cr64[9] = pTargetCPU_REGS->CR_G(9);

  01c62	b8 08 00 00 00	 mov	 eax, 8
  01c67	48 6b c0 0a	 imul	 rax, rax, 10
  01c6b	b9 08 00 00 00	 mov	 ecx, 8
  01c70	48 6b c9 09	 imul	 rcx, rcx, 9
  01c74	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01c7b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01c82	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01c8a	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1287 : 
; 1288 :             gui_fprintf(fStatusStream,

  01c8e	b8 08 00 00 00	 mov	 eax, 8
  01c93	48 6b c0 0a	 imul	 rax, rax, 10
  01c97	b9 08 00 00 00	 mov	 ecx, 8
  01c9c	48 6b c9 09	 imul	 rcx, rcx, 9
  01ca0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  01ca7	4c 8b 8c 02 00
	06 00 00	 mov	 r9, QWORD PTR [rdx+rax+1536]
  01caf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01cb6	4c 8b 84 08 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rcx+1536]
  01cbe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168456
  01cc5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  01ccc	e8 00 00 00 00	 call	 gui_fprintf
$LN47@UpdateRegi:

; 1289 : 
; 1290 :                 "64_CR8-9="REG64FMT" "REG64FMT"\n"
; 1291 : 
; 1292 :                 ,pTargetCPU_REGS->CR_G(8)
; 1293 :                 ,pTargetCPU_REGS->CR_G(9)
; 1294 :             );
; 1295 :         }
; 1296 : 
; 1297 :         if (0
; 1298 :             || prev_cr64[10] != pTargetCPU_REGS->CR_G(10)
; 1299 :             || prev_cr64[11] != pTargetCPU_REGS->CR_G(11)

  01cd1	33 c0		 xor	 eax, eax
  01cd3	85 c0		 test	 eax, eax
  01cd5	75 60		 jne	 SHORT $LN50@UpdateRegi
  01cd7	b8 08 00 00 00	 mov	 eax, 8
  01cdc	48 6b c0 0a	 imul	 rax, rax, 10
  01ce0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01ce7	ba 08 00 00 00	 mov	 edx, 8
  01cec	48 6b d2 0b	 imul	 rdx, rdx, 11
  01cf0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01cf7	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01cff	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01d03	75 32		 jne	 SHORT $LN50@UpdateRegi
  01d05	b8 08 00 00 00	 mov	 eax, 8
  01d0a	48 6b c0 0b	 imul	 rax, rax, 11
  01d0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01d15	ba 08 00 00 00	 mov	 edx, 8
  01d1a	48 6b d2 0c	 imul	 rdx, rdx, 12
  01d1e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01d25	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01d2d	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01d31	0f 84 9b 00 00
	00		 je	 $LN49@UpdateRegi
$LN50@UpdateRegi:

; 1300 :         )
; 1301 :         {
; 1302 :             prev_cr64[10] = pTargetCPU_REGS->CR_G(10);

  01d37	b8 08 00 00 00	 mov	 eax, 8
  01d3c	48 6b c0 0b	 imul	 rax, rax, 11
  01d40	b9 08 00 00 00	 mov	 ecx, 8
  01d45	48 6b c9 0a	 imul	 rcx, rcx, 10
  01d49	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01d50	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01d57	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01d5f	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1303 :             prev_cr64[11] = pTargetCPU_REGS->CR_G(11);

  01d63	b8 08 00 00 00	 mov	 eax, 8
  01d68	48 6b c0 0c	 imul	 rax, rax, 12
  01d6c	b9 08 00 00 00	 mov	 ecx, 8
  01d71	48 6b c9 0b	 imul	 rcx, rcx, 11
  01d75	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01d7c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01d83	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01d8b	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1304 : 
; 1305 :             gui_fprintf(fStatusStream,

  01d8f	b8 08 00 00 00	 mov	 eax, 8
  01d94	48 6b c0 0c	 imul	 rax, rax, 12
  01d98	b9 08 00 00 00	 mov	 ecx, 8
  01d9d	48 6b c9 0b	 imul	 rcx, rcx, 11
  01da1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  01da8	4c 8b 8c 02 00
	06 00 00	 mov	 r9, QWORD PTR [rdx+rax+1536]
  01db0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01db7	4c 8b 84 08 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rcx+1536]
  01dbf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168459
  01dc6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  01dcd	e8 00 00 00 00	 call	 gui_fprintf
$LN49@UpdateRegi:

; 1306 : 
; 1307 :                 "64_CRA-B="REG64FMT" "REG64FMT"\n"
; 1308 : 
; 1309 :                 ,pTargetCPU_REGS->CR_G(10)
; 1310 :                 ,pTargetCPU_REGS->CR_G(11)
; 1311 :             );
; 1312 :         }
; 1313 : 
; 1314 :         if (0
; 1315 :             || prev_cr64[12] != pTargetCPU_REGS->CR_G(12)
; 1316 :             || prev_cr64[13] != pTargetCPU_REGS->CR_G(13)

  01dd2	33 c0		 xor	 eax, eax
  01dd4	85 c0		 test	 eax, eax
  01dd6	75 60		 jne	 SHORT $LN52@UpdateRegi
  01dd8	b8 08 00 00 00	 mov	 eax, 8
  01ddd	48 6b c0 0c	 imul	 rax, rax, 12
  01de1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01de8	ba 08 00 00 00	 mov	 edx, 8
  01ded	48 6b d2 0d	 imul	 rdx, rdx, 13
  01df1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01df8	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01e00	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01e04	75 32		 jne	 SHORT $LN52@UpdateRegi
  01e06	b8 08 00 00 00	 mov	 eax, 8
  01e0b	48 6b c0 0d	 imul	 rax, rax, 13
  01e0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01e16	ba 08 00 00 00	 mov	 edx, 8
  01e1b	48 6b d2 0e	 imul	 rdx, rdx, 14
  01e1f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01e26	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01e2e	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01e32	0f 84 9b 00 00
	00		 je	 $LN51@UpdateRegi
$LN52@UpdateRegi:

; 1317 :         )
; 1318 :         {
; 1319 :             prev_cr64[12] = pTargetCPU_REGS->CR_G(12);

  01e38	b8 08 00 00 00	 mov	 eax, 8
  01e3d	48 6b c0 0d	 imul	 rax, rax, 13
  01e41	b9 08 00 00 00	 mov	 ecx, 8
  01e46	48 6b c9 0c	 imul	 rcx, rcx, 12
  01e4a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01e51	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01e58	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01e60	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1320 :             prev_cr64[13] = pTargetCPU_REGS->CR_G(13);

  01e64	b8 08 00 00 00	 mov	 eax, 8
  01e69	48 6b c0 0e	 imul	 rax, rax, 14
  01e6d	b9 08 00 00 00	 mov	 ecx, 8
  01e72	48 6b c9 0d	 imul	 rcx, rcx, 13
  01e76	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01e7d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01e84	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01e8c	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1321 : 
; 1322 :             gui_fprintf(fStatusStream,

  01e90	b8 08 00 00 00	 mov	 eax, 8
  01e95	48 6b c0 0e	 imul	 rax, rax, 14
  01e99	b9 08 00 00 00	 mov	 ecx, 8
  01e9e	48 6b c9 0d	 imul	 rcx, rcx, 13
  01ea2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  01ea9	4c 8b 8c 02 00
	06 00 00	 mov	 r9, QWORD PTR [rdx+rax+1536]
  01eb1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01eb8	4c 8b 84 08 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rcx+1536]
  01ec0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168462
  01ec7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  01ece	e8 00 00 00 00	 call	 gui_fprintf
$LN51@UpdateRegi:

; 1323 : 
; 1324 :                 "64_CRC-D="REG64FMT" "REG64FMT"\n"
; 1325 : 
; 1326 :                 ,pTargetCPU_REGS->CR_G(12)
; 1327 :                 ,pTargetCPU_REGS->CR_G(13)
; 1328 :             );
; 1329 :         }
; 1330 : 
; 1331 :         if (0
; 1332 :             || prev_cr64[14] != pTargetCPU_REGS->CR_G(14)
; 1333 :             || prev_cr64[15] != pTargetCPU_REGS->CR_G(15)

  01ed3	33 c0		 xor	 eax, eax
  01ed5	85 c0		 test	 eax, eax
  01ed7	75 60		 jne	 SHORT $LN54@UpdateRegi
  01ed9	b8 08 00 00 00	 mov	 eax, 8
  01ede	48 6b c0 0e	 imul	 rax, rax, 14
  01ee2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01ee9	ba 08 00 00 00	 mov	 edx, 8
  01eee	48 6b d2 0f	 imul	 rdx, rdx, 15
  01ef2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01ef9	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01f01	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01f05	75 32		 jne	 SHORT $LN54@UpdateRegi
  01f07	b8 08 00 00 00	 mov	 eax, 8
  01f0c	48 6b c0 0f	 imul	 rax, rax, 15
  01f10	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  01f17	ba 08 00 00 00	 mov	 edx, 8
  01f1c	48 6b d2 10	 imul	 rdx, rdx, 16
  01f20	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01f27	49 8b 94 10 00
	06 00 00	 mov	 rdx, QWORD PTR [r8+rdx+1536]
  01f2f	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  01f33	0f 84 9b 00 00
	00		 je	 $LN53@UpdateRegi
$LN54@UpdateRegi:

; 1334 :         )
; 1335 :         {
; 1336 :             prev_cr64[14] = pTargetCPU_REGS->CR_G(14);

  01f39	b8 08 00 00 00	 mov	 eax, 8
  01f3e	48 6b c0 0f	 imul	 rax, rax, 15
  01f42	b9 08 00 00 00	 mov	 ecx, 8
  01f47	48 6b c9 0e	 imul	 rcx, rcx, 14
  01f4b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01f52	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01f59	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01f61	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1337 :             prev_cr64[15] = pTargetCPU_REGS->CR_G(15);

  01f65	b8 08 00 00 00	 mov	 eax, 8
  01f6a	48 6b c0 10	 imul	 rax, rax, 16
  01f6e	b9 08 00 00 00	 mov	 ecx, 8
  01f73	48 6b c9 0f	 imul	 rcx, rcx, 15
  01f77	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_cr64
  01f7e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  01f85	49 8b 84 00 00
	06 00 00	 mov	 rax, QWORD PTR [r8+rax+1536]
  01f8d	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1338 : 
; 1339 :             gui_fprintf(fStatusStream,

  01f91	b8 08 00 00 00	 mov	 eax, 8
  01f96	48 6b c0 10	 imul	 rax, rax, 16
  01f9a	b9 08 00 00 00	 mov	 ecx, 8
  01f9f	48 6b c9 0f	 imul	 rcx, rcx, 15
  01fa3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pTargetCPU_REGS
  01faa	4c 8b 8c 02 00
	06 00 00	 mov	 r9, QWORD PTR [rdx+rax+1536]
  01fb2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  01fb9	4c 8b 84 08 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rcx+1536]
  01fc1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168465
  01fc8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  01fcf	e8 00 00 00 00	 call	 gui_fprintf
$LN53@UpdateRegi:
$LN38@UpdateRegi:

; 1340 : 
; 1341 :                 "64_CRE-F="REG64FMT" "REG64FMT"\n"
; 1342 : 
; 1343 :                 ,pTargetCPU_REGS->CR_G(14)
; 1344 :                 ,pTargetCPU_REGS->CR_G(15)
; 1345 :             );
; 1346 :         }
; 1347 :     }
; 1348 : 
; 1349 :     if (gui_wants_aregs)

  01fd4	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_aregs
  01fdb	85 c0		 test	 eax, eax
  01fdd	0f 84 b4 07 00
	00		 je	 $LN55@UpdateRegi

; 1350 :     {
; 1351 :         if (0
; 1352 :             || prev_ar[0] != pTargetCPU_REGS->AR(0)
; 1353 :             || prev_ar[1] != pTargetCPU_REGS->AR(1)
; 1354 :             || prev_ar[2] != pTargetCPU_REGS->AR(2)
; 1355 :             || prev_ar[3] != pTargetCPU_REGS->AR(3)

  01fe3	33 c0		 xor	 eax, eax
  01fe5	85 c0		 test	 eax, eax
  01fe7	0f 85 bc 00 00
	00		 jne	 $LN57@UpdateRegi
  01fed	b8 04 00 00 00	 mov	 eax, 4
  01ff2	48 6b c0 00	 imul	 rax, rax, 0
  01ff6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  01ffd	ba 04 00 00 00	 mov	 edx, 4
  02002	48 6b d2 00	 imul	 rdx, rdx, 0
  02006	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0200d	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  02015	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02018	0f 85 8b 00 00
	00		 jne	 $LN57@UpdateRegi
  0201e	b8 04 00 00 00	 mov	 eax, 4
  02023	48 6b c0 01	 imul	 rax, rax, 1
  02027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  0202e	ba 04 00 00 00	 mov	 edx, 4
  02033	48 6b d2 01	 imul	 rdx, rdx, 1
  02037	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0203e	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  02046	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02049	75 5e		 jne	 SHORT $LN57@UpdateRegi
  0204b	b8 04 00 00 00	 mov	 eax, 4
  02050	48 6b c0 02	 imul	 rax, rax, 2
  02054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  0205b	ba 04 00 00 00	 mov	 edx, 4
  02060	48 6b d2 02	 imul	 rdx, rdx, 2
  02064	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0206b	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  02073	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02076	75 31		 jne	 SHORT $LN57@UpdateRegi
  02078	b8 04 00 00 00	 mov	 eax, 4
  0207d	48 6b c0 03	 imul	 rax, rax, 3
  02081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  02088	ba 04 00 00 00	 mov	 edx, 4
  0208d	48 6b d2 03	 imul	 rdx, rdx, 3
  02091	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02098	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  020a0	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  020a3	0f 84 27 01 00
	00		 je	 $LN56@UpdateRegi
$LN57@UpdateRegi:

; 1356 :         )
; 1357 :         {
; 1358 :             prev_ar[0] = pTargetCPU_REGS->AR(0);

  020a9	b8 04 00 00 00	 mov	 eax, 4
  020ae	48 6b c0 00	 imul	 rax, rax, 0
  020b2	b9 04 00 00 00	 mov	 ecx, 4
  020b7	48 6b c9 00	 imul	 rcx, rcx, 0
  020bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  020c2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  020c9	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  020d1	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1359 :             prev_ar[1] = pTargetCPU_REGS->AR(1);

  020d4	b8 04 00 00 00	 mov	 eax, 4
  020d9	48 6b c0 01	 imul	 rax, rax, 1
  020dd	b9 04 00 00 00	 mov	 ecx, 4
  020e2	48 6b c9 01	 imul	 rcx, rcx, 1
  020e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  020ed	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  020f4	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  020fc	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1360 :             prev_ar[2] = pTargetCPU_REGS->AR(2);

  020ff	b8 04 00 00 00	 mov	 eax, 4
  02104	48 6b c0 02	 imul	 rax, rax, 2
  02108	b9 04 00 00 00	 mov	 ecx, 4
  0210d	48 6b c9 02	 imul	 rcx, rcx, 2
  02111	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  02118	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0211f	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  02127	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1361 :             prev_ar[3] = pTargetCPU_REGS->AR(3);

  0212a	b8 04 00 00 00	 mov	 eax, 4
  0212f	48 6b c0 03	 imul	 rax, rax, 3
  02133	b9 04 00 00 00	 mov	 ecx, 4
  02138	48 6b c9 03	 imul	 rcx, rcx, 3
  0213c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  02143	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0214a	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  02152	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1362 : 
; 1363 :             gui_fprintf(fStatusStream,

  02155	b8 04 00 00 00	 mov	 eax, 4
  0215a	48 6b c0 03	 imul	 rax, rax, 3
  0215e	b9 04 00 00 00	 mov	 ecx, 4
  02163	48 6b c9 02	 imul	 rcx, rcx, 2
  02167	ba 04 00 00 00	 mov	 edx, 4
  0216c	48 6b d2 01	 imul	 rdx, rdx, 1
  02170	41 b8 04 00 00
	00		 mov	 r8d, 4
  02176	4d 6b c0 00	 imul	 r8, r8, 0
  0217a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  02181	41 8b 84 01 00
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+768]
  02189	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0218d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02194	8b 84 08 00 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+768]
  0219b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0219f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  021a6	44 8b 8c 10 00
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+768]
  021ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  021b5	46 8b 84 00 00
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+768]
  021bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168469
  021c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  021cb	e8 00 00 00 00	 call	 gui_fprintf
$LN56@UpdateRegi:

; 1364 : 
; 1365 :                 "AR0-3="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1366 : 
; 1367 :                 ,pTargetCPU_REGS->AR(0)
; 1368 :                 ,pTargetCPU_REGS->AR(1)
; 1369 :                 ,pTargetCPU_REGS->AR(2)
; 1370 :                 ,pTargetCPU_REGS->AR(3)
; 1371 :             );
; 1372 :         }
; 1373 : 
; 1374 :         if (0
; 1375 :             || prev_ar[4] != pTargetCPU_REGS->AR(4)
; 1376 :             || prev_ar[5] != pTargetCPU_REGS->AR(5)
; 1377 :             || prev_ar[6] != pTargetCPU_REGS->AR(6)
; 1378 :             || prev_ar[7] != pTargetCPU_REGS->AR(7)

  021d0	33 c0		 xor	 eax, eax
  021d2	85 c0		 test	 eax, eax
  021d4	0f 85 bc 00 00
	00		 jne	 $LN59@UpdateRegi
  021da	b8 04 00 00 00	 mov	 eax, 4
  021df	48 6b c0 04	 imul	 rax, rax, 4
  021e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  021ea	ba 04 00 00 00	 mov	 edx, 4
  021ef	48 6b d2 04	 imul	 rdx, rdx, 4
  021f3	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  021fa	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  02202	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02205	0f 85 8b 00 00
	00		 jne	 $LN59@UpdateRegi
  0220b	b8 04 00 00 00	 mov	 eax, 4
  02210	48 6b c0 05	 imul	 rax, rax, 5
  02214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  0221b	ba 04 00 00 00	 mov	 edx, 4
  02220	48 6b d2 05	 imul	 rdx, rdx, 5
  02224	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0222b	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  02233	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02236	75 5e		 jne	 SHORT $LN59@UpdateRegi
  02238	b8 04 00 00 00	 mov	 eax, 4
  0223d	48 6b c0 06	 imul	 rax, rax, 6
  02241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  02248	ba 04 00 00 00	 mov	 edx, 4
  0224d	48 6b d2 06	 imul	 rdx, rdx, 6
  02251	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02258	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  02260	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02263	75 31		 jne	 SHORT $LN59@UpdateRegi
  02265	b8 04 00 00 00	 mov	 eax, 4
  0226a	48 6b c0 07	 imul	 rax, rax, 7
  0226e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  02275	ba 04 00 00 00	 mov	 edx, 4
  0227a	48 6b d2 07	 imul	 rdx, rdx, 7
  0227e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02285	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  0228d	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02290	0f 84 27 01 00
	00		 je	 $LN58@UpdateRegi
$LN59@UpdateRegi:

; 1379 :         )
; 1380 :         {
; 1381 :             prev_ar[4] = pTargetCPU_REGS->AR(4);

  02296	b8 04 00 00 00	 mov	 eax, 4
  0229b	48 6b c0 04	 imul	 rax, rax, 4
  0229f	b9 04 00 00 00	 mov	 ecx, 4
  022a4	48 6b c9 04	 imul	 rcx, rcx, 4
  022a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  022af	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  022b6	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  022be	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1382 :             prev_ar[5] = pTargetCPU_REGS->AR(5);

  022c1	b8 04 00 00 00	 mov	 eax, 4
  022c6	48 6b c0 05	 imul	 rax, rax, 5
  022ca	b9 04 00 00 00	 mov	 ecx, 4
  022cf	48 6b c9 05	 imul	 rcx, rcx, 5
  022d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  022da	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  022e1	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  022e9	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1383 :             prev_ar[6] = pTargetCPU_REGS->AR(6);

  022ec	b8 04 00 00 00	 mov	 eax, 4
  022f1	48 6b c0 06	 imul	 rax, rax, 6
  022f5	b9 04 00 00 00	 mov	 ecx, 4
  022fa	48 6b c9 06	 imul	 rcx, rcx, 6
  022fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  02305	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0230c	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  02314	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1384 :             prev_ar[7] = pTargetCPU_REGS->AR(7);

  02317	b8 04 00 00 00	 mov	 eax, 4
  0231c	48 6b c0 07	 imul	 rax, rax, 7
  02320	b9 04 00 00 00	 mov	 ecx, 4
  02325	48 6b c9 07	 imul	 rcx, rcx, 7
  02329	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  02330	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02337	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  0233f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1385 : 
; 1386 :             gui_fprintf(fStatusStream,

  02342	b8 04 00 00 00	 mov	 eax, 4
  02347	48 6b c0 07	 imul	 rax, rax, 7
  0234b	b9 04 00 00 00	 mov	 ecx, 4
  02350	48 6b c9 06	 imul	 rcx, rcx, 6
  02354	ba 04 00 00 00	 mov	 edx, 4
  02359	48 6b d2 05	 imul	 rdx, rdx, 5
  0235d	41 b8 04 00 00
	00		 mov	 r8d, 4
  02363	4d 6b c0 04	 imul	 r8, r8, 4
  02367	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  0236e	41 8b 84 01 00
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+768]
  02376	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0237a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02381	8b 84 08 00 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+768]
  02388	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0238c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02393	44 8b 8c 10 00
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+768]
  0239b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  023a2	46 8b 84 00 00
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+768]
  023aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168472
  023b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  023b8	e8 00 00 00 00	 call	 gui_fprintf
$LN58@UpdateRegi:

; 1387 : 
; 1388 :                 "AR4-7="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1389 : 
; 1390 :                 ,pTargetCPU_REGS->AR(4)
; 1391 :                 ,pTargetCPU_REGS->AR(5)
; 1392 :                 ,pTargetCPU_REGS->AR(6)
; 1393 :                 ,pTargetCPU_REGS->AR(7)
; 1394 :             );
; 1395 :         }
; 1396 : 
; 1397 :         if (0
; 1398 :             || prev_ar[8]  != pTargetCPU_REGS->AR(8)
; 1399 :             || prev_ar[9]  != pTargetCPU_REGS->AR(9)
; 1400 :             || prev_ar[10] != pTargetCPU_REGS->AR(10)
; 1401 :             || prev_ar[11] != pTargetCPU_REGS->AR(11)

  023bd	33 c0		 xor	 eax, eax
  023bf	85 c0		 test	 eax, eax
  023c1	0f 85 bc 00 00
	00		 jne	 $LN61@UpdateRegi
  023c7	b8 04 00 00 00	 mov	 eax, 4
  023cc	48 6b c0 08	 imul	 rax, rax, 8
  023d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  023d7	ba 04 00 00 00	 mov	 edx, 4
  023dc	48 6b d2 08	 imul	 rdx, rdx, 8
  023e0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  023e7	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  023ef	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  023f2	0f 85 8b 00 00
	00		 jne	 $LN61@UpdateRegi
  023f8	b8 04 00 00 00	 mov	 eax, 4
  023fd	48 6b c0 09	 imul	 rax, rax, 9
  02401	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  02408	ba 04 00 00 00	 mov	 edx, 4
  0240d	48 6b d2 09	 imul	 rdx, rdx, 9
  02411	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02418	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  02420	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02423	75 5e		 jne	 SHORT $LN61@UpdateRegi
  02425	b8 04 00 00 00	 mov	 eax, 4
  0242a	48 6b c0 0a	 imul	 rax, rax, 10
  0242e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  02435	ba 04 00 00 00	 mov	 edx, 4
  0243a	48 6b d2 0a	 imul	 rdx, rdx, 10
  0243e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02445	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  0244d	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02450	75 31		 jne	 SHORT $LN61@UpdateRegi
  02452	b8 04 00 00 00	 mov	 eax, 4
  02457	48 6b c0 0b	 imul	 rax, rax, 11
  0245b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  02462	ba 04 00 00 00	 mov	 edx, 4
  02467	48 6b d2 0b	 imul	 rdx, rdx, 11
  0246b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02472	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  0247a	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0247d	0f 84 27 01 00
	00		 je	 $LN60@UpdateRegi
$LN61@UpdateRegi:

; 1402 :         )
; 1403 :         {
; 1404 :             prev_ar[8]  = pTargetCPU_REGS->AR(8);

  02483	b8 04 00 00 00	 mov	 eax, 4
  02488	48 6b c0 08	 imul	 rax, rax, 8
  0248c	b9 04 00 00 00	 mov	 ecx, 4
  02491	48 6b c9 08	 imul	 rcx, rcx, 8
  02495	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  0249c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  024a3	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  024ab	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1405 :             prev_ar[9]  = pTargetCPU_REGS->AR(9);

  024ae	b8 04 00 00 00	 mov	 eax, 4
  024b3	48 6b c0 09	 imul	 rax, rax, 9
  024b7	b9 04 00 00 00	 mov	 ecx, 4
  024bc	48 6b c9 09	 imul	 rcx, rcx, 9
  024c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  024c7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  024ce	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  024d6	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1406 :             prev_ar[10] = pTargetCPU_REGS->AR(10);

  024d9	b8 04 00 00 00	 mov	 eax, 4
  024de	48 6b c0 0a	 imul	 rax, rax, 10
  024e2	b9 04 00 00 00	 mov	 ecx, 4
  024e7	48 6b c9 0a	 imul	 rcx, rcx, 10
  024eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  024f2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  024f9	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  02501	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1407 :             prev_ar[11] = pTargetCPU_REGS->AR(11);

  02504	b8 04 00 00 00	 mov	 eax, 4
  02509	48 6b c0 0b	 imul	 rax, rax, 11
  0250d	b9 04 00 00 00	 mov	 ecx, 4
  02512	48 6b c9 0b	 imul	 rcx, rcx, 11
  02516	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  0251d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02524	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  0252c	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1408 : 
; 1409 :             gui_fprintf(fStatusStream,

  0252f	b8 04 00 00 00	 mov	 eax, 4
  02534	48 6b c0 0b	 imul	 rax, rax, 11
  02538	b9 04 00 00 00	 mov	 ecx, 4
  0253d	48 6b c9 0a	 imul	 rcx, rcx, 10
  02541	ba 04 00 00 00	 mov	 edx, 4
  02546	48 6b d2 09	 imul	 rdx, rdx, 9
  0254a	41 b8 04 00 00
	00		 mov	 r8d, 4
  02550	4d 6b c0 08	 imul	 r8, r8, 8
  02554	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  0255b	41 8b 84 01 00
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+768]
  02563	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  02567	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0256e	8b 84 08 00 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+768]
  02575	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02579	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02580	44 8b 8c 10 00
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+768]
  02588	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0258f	46 8b 84 00 00
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+768]
  02597	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168475
  0259e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  025a5	e8 00 00 00 00	 call	 gui_fprintf
$LN60@UpdateRegi:

; 1410 : 
; 1411 :                 "AR8-B="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1412 : 
; 1413 :                 ,pTargetCPU_REGS->AR(8)
; 1414 :                 ,pTargetCPU_REGS->AR(9)
; 1415 :                 ,pTargetCPU_REGS->AR(10)
; 1416 :                 ,pTargetCPU_REGS->AR(11)
; 1417 :             );
; 1418 :         }
; 1419 : 
; 1420 :         if (0
; 1421 :             || prev_ar[12] != pTargetCPU_REGS->AR(12)
; 1422 :             || prev_ar[13] != pTargetCPU_REGS->AR(13)
; 1423 :             || prev_ar[14] != pTargetCPU_REGS->AR(14)
; 1424 :             || prev_ar[15] != pTargetCPU_REGS->AR(15)

  025aa	33 c0		 xor	 eax, eax
  025ac	85 c0		 test	 eax, eax
  025ae	0f 85 bc 00 00
	00		 jne	 $LN63@UpdateRegi
  025b4	b8 04 00 00 00	 mov	 eax, 4
  025b9	48 6b c0 0c	 imul	 rax, rax, 12
  025bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  025c4	ba 04 00 00 00	 mov	 edx, 4
  025c9	48 6b d2 0c	 imul	 rdx, rdx, 12
  025cd	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  025d4	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  025dc	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  025df	0f 85 8b 00 00
	00		 jne	 $LN63@UpdateRegi
  025e5	b8 04 00 00 00	 mov	 eax, 4
  025ea	48 6b c0 0d	 imul	 rax, rax, 13
  025ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  025f5	ba 04 00 00 00	 mov	 edx, 4
  025fa	48 6b d2 0d	 imul	 rdx, rdx, 13
  025fe	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02605	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  0260d	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02610	75 5e		 jne	 SHORT $LN63@UpdateRegi
  02612	b8 04 00 00 00	 mov	 eax, 4
  02617	48 6b c0 0e	 imul	 rax, rax, 14
  0261b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  02622	ba 04 00 00 00	 mov	 edx, 4
  02627	48 6b d2 0e	 imul	 rdx, rdx, 14
  0262b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02632	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  0263a	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0263d	75 31		 jne	 SHORT $LN63@UpdateRegi
  0263f	b8 04 00 00 00	 mov	 eax, 4
  02644	48 6b c0 0f	 imul	 rax, rax, 15
  02648	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  0264f	ba 04 00 00 00	 mov	 edx, 4
  02654	48 6b d2 0f	 imul	 rdx, rdx, 15
  02658	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0265f	41 8b 94 10 00
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+768]
  02667	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0266a	0f 84 27 01 00
	00		 je	 $LN62@UpdateRegi
$LN63@UpdateRegi:

; 1425 :         )
; 1426 :         {
; 1427 :             prev_ar[12] = pTargetCPU_REGS->AR(12);

  02670	b8 04 00 00 00	 mov	 eax, 4
  02675	48 6b c0 0c	 imul	 rax, rax, 12
  02679	b9 04 00 00 00	 mov	 ecx, 4
  0267e	48 6b c9 0c	 imul	 rcx, rcx, 12
  02682	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  02689	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02690	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  02698	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1428 :             prev_ar[13] = pTargetCPU_REGS->AR(13);

  0269b	b8 04 00 00 00	 mov	 eax, 4
  026a0	48 6b c0 0d	 imul	 rax, rax, 13
  026a4	b9 04 00 00 00	 mov	 ecx, 4
  026a9	48 6b c9 0d	 imul	 rcx, rcx, 13
  026ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  026b4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  026bb	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  026c3	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1429 :             prev_ar[14] = pTargetCPU_REGS->AR(14);

  026c6	b8 04 00 00 00	 mov	 eax, 4
  026cb	48 6b c0 0e	 imul	 rax, rax, 14
  026cf	b9 04 00 00 00	 mov	 ecx, 4
  026d4	48 6b c9 0e	 imul	 rcx, rcx, 14
  026d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  026df	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  026e6	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  026ee	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1430 :             prev_ar[15] = pTargetCPU_REGS->AR(15);

  026f1	b8 04 00 00 00	 mov	 eax, 4
  026f6	48 6b c0 0f	 imul	 rax, rax, 15
  026fa	b9 04 00 00 00	 mov	 ecx, 4
  026ff	48 6b c9 0f	 imul	 rcx, rcx, 15
  02703	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_ar
  0270a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02711	41 8b 84 00 00
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+768]
  02719	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1431 : 
; 1432 :             gui_fprintf(fStatusStream,

  0271c	b8 04 00 00 00	 mov	 eax, 4
  02721	48 6b c0 0f	 imul	 rax, rax, 15
  02725	b9 04 00 00 00	 mov	 ecx, 4
  0272a	48 6b c9 0e	 imul	 rcx, rcx, 14
  0272e	ba 04 00 00 00	 mov	 edx, 4
  02733	48 6b d2 0d	 imul	 rdx, rdx, 13
  02737	41 b8 04 00 00
	00		 mov	 r8d, 4
  0273d	4d 6b c0 0c	 imul	 r8, r8, 12
  02741	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  02748	41 8b 84 01 00
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+768]
  02750	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  02754	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0275b	8b 84 08 00 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+768]
  02762	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02766	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0276d	44 8b 8c 10 00
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+768]
  02775	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0277c	46 8b 84 00 00
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+768]
  02784	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168478
  0278b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  02792	e8 00 00 00 00	 call	 gui_fprintf
$LN62@UpdateRegi:
$LN55@UpdateRegi:

; 1433 : 
; 1434 :                 "ARC-F="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1435 : 
; 1436 :                 ,pTargetCPU_REGS->AR(12)
; 1437 :                 ,pTargetCPU_REGS->AR(13)
; 1438 :                 ,pTargetCPU_REGS->AR(14)
; 1439 :                 ,pTargetCPU_REGS->AR(15)
; 1440 :             );
; 1441 :         }
; 1442 :     }
; 1443 : 
; 1444 :     if (gui_wants_fregs)

  02797	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_fregs
  0279e	85 c0		 test	 eax, eax
  027a0	0f 84 da 03 00
	00		 je	 $LN64@UpdateRegi

; 1445 :     {
; 1446 :         if (0
; 1447 :             || prev_fpr[0] != pTargetCPU_REGS->fpr[0]
; 1448 :             || prev_fpr[1] != pTargetCPU_REGS->fpr[1]
; 1449 :             || prev_fpr[2] != pTargetCPU_REGS->fpr[2]
; 1450 :             || prev_fpr[3] != pTargetCPU_REGS->fpr[3]

  027a6	33 c0		 xor	 eax, eax
  027a8	85 c0		 test	 eax, eax
  027aa	0f 85 bc 00 00
	00		 jne	 $LN66@UpdateRegi
  027b0	b8 04 00 00 00	 mov	 eax, 4
  027b5	48 6b c0 00	 imul	 rax, rax, 0
  027b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  027c0	ba 04 00 00 00	 mov	 edx, 4
  027c5	48 6b d2 00	 imul	 rdx, rdx, 0
  027c9	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  027d0	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  027d8	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  027db	0f 85 8b 00 00
	00		 jne	 $LN66@UpdateRegi
  027e1	b8 04 00 00 00	 mov	 eax, 4
  027e6	48 6b c0 01	 imul	 rax, rax, 1
  027ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  027f1	ba 04 00 00 00	 mov	 edx, 4
  027f6	48 6b d2 01	 imul	 rdx, rdx, 1
  027fa	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02801	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02809	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0280c	75 5e		 jne	 SHORT $LN66@UpdateRegi
  0280e	b8 04 00 00 00	 mov	 eax, 4
  02813	48 6b c0 02	 imul	 rax, rax, 2
  02817	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  0281e	ba 04 00 00 00	 mov	 edx, 4
  02823	48 6b d2 02	 imul	 rdx, rdx, 2
  02827	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0282e	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02836	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02839	75 31		 jne	 SHORT $LN66@UpdateRegi
  0283b	b8 04 00 00 00	 mov	 eax, 4
  02840	48 6b c0 03	 imul	 rax, rax, 3
  02844	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  0284b	ba 04 00 00 00	 mov	 edx, 4
  02850	48 6b d2 03	 imul	 rdx, rdx, 3
  02854	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0285b	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02863	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02866	0f 84 27 01 00
	00		 je	 $LN65@UpdateRegi
$LN66@UpdateRegi:

; 1451 :         )
; 1452 :         {
; 1453 :             prev_fpr[0] = pTargetCPU_REGS->fpr[0];

  0286c	b8 04 00 00 00	 mov	 eax, 4
  02871	48 6b c0 00	 imul	 rax, rax, 0
  02875	b9 04 00 00 00	 mov	 ecx, 4
  0287a	48 6b c9 00	 imul	 rcx, rcx, 0
  0287e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr
  02885	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0288c	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02894	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1454 :             prev_fpr[1] = pTargetCPU_REGS->fpr[1];

  02897	b8 04 00 00 00	 mov	 eax, 4
  0289c	48 6b c0 01	 imul	 rax, rax, 1
  028a0	b9 04 00 00 00	 mov	 ecx, 4
  028a5	48 6b c9 01	 imul	 rcx, rcx, 1
  028a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr
  028b0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  028b7	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  028bf	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1455 :             prev_fpr[2] = pTargetCPU_REGS->fpr[2];

  028c2	b8 04 00 00 00	 mov	 eax, 4
  028c7	48 6b c0 02	 imul	 rax, rax, 2
  028cb	b9 04 00 00 00	 mov	 ecx, 4
  028d0	48 6b c9 02	 imul	 rcx, rcx, 2
  028d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr
  028db	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  028e2	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  028ea	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1456 :             prev_fpr[3] = pTargetCPU_REGS->fpr[3];

  028ed	b8 04 00 00 00	 mov	 eax, 4
  028f2	48 6b c0 03	 imul	 rax, rax, 3
  028f6	b9 04 00 00 00	 mov	 ecx, 4
  028fb	48 6b c9 03	 imul	 rcx, rcx, 3
  028ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr
  02906	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0290d	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02915	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1457 : 
; 1458 :             gui_fprintf(fStatusStream,

  02918	b8 04 00 00 00	 mov	 eax, 4
  0291d	48 6b c0 03	 imul	 rax, rax, 3
  02921	b9 04 00 00 00	 mov	 ecx, 4
  02926	48 6b c9 02	 imul	 rcx, rcx, 2
  0292a	ba 04 00 00 00	 mov	 edx, 4
  0292f	48 6b d2 01	 imul	 rdx, rdx, 1
  02933	41 b8 04 00 00
	00		 mov	 r8d, 4
  02939	4d 6b c0 00	 imul	 r8, r8, 0
  0293d	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  02944	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  0294c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  02950	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02957	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  0295e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02962	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02969	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  02971	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02978	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  02980	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168482
  02987	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  0298e	e8 00 00 00 00	 call	 gui_fprintf
$LN65@UpdateRegi:

; 1459 : 
; 1460 :                 "FR0-2="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1461 : 
; 1462 :                 ,pTargetCPU_REGS->fpr[0]
; 1463 :                 ,pTargetCPU_REGS->fpr[1]
; 1464 :                 ,pTargetCPU_REGS->fpr[2]
; 1465 :                 ,pTargetCPU_REGS->fpr[3]
; 1466 :             );
; 1467 :         }
; 1468 : 
; 1469 :         if (0
; 1470 :             || prev_fpr[4] != pTargetCPU_REGS->fpr[4]
; 1471 :             || prev_fpr[5] != pTargetCPU_REGS->fpr[5]
; 1472 :             || prev_fpr[6] != pTargetCPU_REGS->fpr[6]
; 1473 :             || prev_fpr[7] != pTargetCPU_REGS->fpr[7]

  02993	33 c0		 xor	 eax, eax
  02995	85 c0		 test	 eax, eax
  02997	0f 85 bc 00 00
	00		 jne	 $LN68@UpdateRegi
  0299d	b8 04 00 00 00	 mov	 eax, 4
  029a2	48 6b c0 04	 imul	 rax, rax, 4
  029a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  029ad	ba 04 00 00 00	 mov	 edx, 4
  029b2	48 6b d2 04	 imul	 rdx, rdx, 4
  029b6	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  029bd	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  029c5	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  029c8	0f 85 8b 00 00
	00		 jne	 $LN68@UpdateRegi
  029ce	b8 04 00 00 00	 mov	 eax, 4
  029d3	48 6b c0 05	 imul	 rax, rax, 5
  029d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  029de	ba 04 00 00 00	 mov	 edx, 4
  029e3	48 6b d2 05	 imul	 rdx, rdx, 5
  029e7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  029ee	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  029f6	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  029f9	75 5e		 jne	 SHORT $LN68@UpdateRegi
  029fb	b8 04 00 00 00	 mov	 eax, 4
  02a00	48 6b c0 06	 imul	 rax, rax, 6
  02a04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  02a0b	ba 04 00 00 00	 mov	 edx, 4
  02a10	48 6b d2 06	 imul	 rdx, rdx, 6
  02a14	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02a1b	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02a23	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02a26	75 31		 jne	 SHORT $LN68@UpdateRegi
  02a28	b8 04 00 00 00	 mov	 eax, 4
  02a2d	48 6b c0 07	 imul	 rax, rax, 7
  02a31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  02a38	ba 04 00 00 00	 mov	 edx, 4
  02a3d	48 6b d2 07	 imul	 rdx, rdx, 7
  02a41	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02a48	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02a50	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02a53	0f 84 27 01 00
	00		 je	 $LN67@UpdateRegi
$LN68@UpdateRegi:

; 1474 :         )
; 1475 :         {
; 1476 :             prev_fpr[4] = pTargetCPU_REGS->fpr[4];

  02a59	b8 04 00 00 00	 mov	 eax, 4
  02a5e	48 6b c0 04	 imul	 rax, rax, 4
  02a62	b9 04 00 00 00	 mov	 ecx, 4
  02a67	48 6b c9 04	 imul	 rcx, rcx, 4
  02a6b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr
  02a72	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02a79	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02a81	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1477 :             prev_fpr[5] = pTargetCPU_REGS->fpr[5];

  02a84	b8 04 00 00 00	 mov	 eax, 4
  02a89	48 6b c0 05	 imul	 rax, rax, 5
  02a8d	b9 04 00 00 00	 mov	 ecx, 4
  02a92	48 6b c9 05	 imul	 rcx, rcx, 5
  02a96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr
  02a9d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02aa4	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02aac	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1478 :             prev_fpr[6] = pTargetCPU_REGS->fpr[6];

  02aaf	b8 04 00 00 00	 mov	 eax, 4
  02ab4	48 6b c0 06	 imul	 rax, rax, 6
  02ab8	b9 04 00 00 00	 mov	 ecx, 4
  02abd	48 6b c9 06	 imul	 rcx, rcx, 6
  02ac1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr
  02ac8	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02acf	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02ad7	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1479 :             prev_fpr[7] = pTargetCPU_REGS->fpr[7];

  02ada	b8 04 00 00 00	 mov	 eax, 4
  02adf	48 6b c0 07	 imul	 rax, rax, 7
  02ae3	b9 04 00 00 00	 mov	 ecx, 4
  02ae8	48 6b c9 07	 imul	 rcx, rcx, 7
  02aec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr
  02af3	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02afa	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02b02	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1480 : 
; 1481 :             gui_fprintf(fStatusStream,

  02b05	b8 04 00 00 00	 mov	 eax, 4
  02b0a	48 6b c0 07	 imul	 rax, rax, 7
  02b0e	b9 04 00 00 00	 mov	 ecx, 4
  02b13	48 6b c9 06	 imul	 rcx, rcx, 6
  02b17	ba 04 00 00 00	 mov	 edx, 4
  02b1c	48 6b d2 05	 imul	 rdx, rdx, 5
  02b20	41 b8 04 00 00
	00		 mov	 r8d, 4
  02b26	4d 6b c0 04	 imul	 r8, r8, 4
  02b2a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  02b31	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  02b39	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  02b3d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02b44	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  02b4b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02b4f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02b56	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  02b5e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02b65	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  02b6d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168485
  02b74	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  02b7b	e8 00 00 00 00	 call	 gui_fprintf
$LN67@UpdateRegi:
$LN64@UpdateRegi:

; 1482 : 
; 1483 :                 "FR4-6="REG32FMT" "REG32FMT" "REG32FMT" "REG32FMT"\n"
; 1484 : 
; 1485 :                 ,pTargetCPU_REGS->fpr[4]
; 1486 :                 ,pTargetCPU_REGS->fpr[5]
; 1487 :                 ,pTargetCPU_REGS->fpr[6]
; 1488 :                 ,pTargetCPU_REGS->fpr[7]
; 1489 :             );
; 1490 :         }
; 1491 :     }
; 1492 : 
; 1493 :     if (gui_wants_fregs64)

  02b80	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_fregs64
  02b87	85 c0		 test	 eax, eax
  02b89	0f 84 68 0f 00
	00		 je	 $LN69@UpdateRegi

; 1494 :     {
; 1495 :         if (0
; 1496 :             || prev_fpr64[0] != pTargetCPU_REGS->fpr[0]
; 1497 :             || prev_fpr64[1] != pTargetCPU_REGS->fpr[1]
; 1498 :             || prev_fpr64[2] != pTargetCPU_REGS->fpr[2]
; 1499 :             || prev_fpr64[3] != pTargetCPU_REGS->fpr[3]

  02b8f	33 c0		 xor	 eax, eax
  02b91	85 c0		 test	 eax, eax
  02b93	0f 85 bc 00 00
	00		 jne	 $LN71@UpdateRegi
  02b99	b8 04 00 00 00	 mov	 eax, 4
  02b9e	48 6b c0 00	 imul	 rax, rax, 0
  02ba2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02ba9	ba 04 00 00 00	 mov	 edx, 4
  02bae	48 6b d2 00	 imul	 rdx, rdx, 0
  02bb2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02bb9	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02bc1	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02bc4	0f 85 8b 00 00
	00		 jne	 $LN71@UpdateRegi
  02bca	b8 04 00 00 00	 mov	 eax, 4
  02bcf	48 6b c0 01	 imul	 rax, rax, 1
  02bd3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02bda	ba 04 00 00 00	 mov	 edx, 4
  02bdf	48 6b d2 01	 imul	 rdx, rdx, 1
  02be3	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02bea	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02bf2	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02bf5	75 5e		 jne	 SHORT $LN71@UpdateRegi
  02bf7	b8 04 00 00 00	 mov	 eax, 4
  02bfc	48 6b c0 02	 imul	 rax, rax, 2
  02c00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02c07	ba 04 00 00 00	 mov	 edx, 4
  02c0c	48 6b d2 02	 imul	 rdx, rdx, 2
  02c10	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02c17	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02c1f	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02c22	75 31		 jne	 SHORT $LN71@UpdateRegi
  02c24	b8 04 00 00 00	 mov	 eax, 4
  02c29	48 6b c0 03	 imul	 rax, rax, 3
  02c2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02c34	ba 04 00 00 00	 mov	 edx, 4
  02c39	48 6b d2 03	 imul	 rdx, rdx, 3
  02c3d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02c44	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02c4c	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02c4f	0f 84 27 01 00
	00		 je	 $LN70@UpdateRegi
$LN71@UpdateRegi:

; 1500 :         )
; 1501 :         {
; 1502 :             prev_fpr64[0] = pTargetCPU_REGS->fpr[0];

  02c55	b8 04 00 00 00	 mov	 eax, 4
  02c5a	48 6b c0 00	 imul	 rax, rax, 0
  02c5e	b9 04 00 00 00	 mov	 ecx, 4
  02c63	48 6b c9 00	 imul	 rcx, rcx, 0
  02c67	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  02c6e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02c75	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02c7d	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1503 :             prev_fpr64[1] = pTargetCPU_REGS->fpr[1];

  02c80	b8 04 00 00 00	 mov	 eax, 4
  02c85	48 6b c0 01	 imul	 rax, rax, 1
  02c89	b9 04 00 00 00	 mov	 ecx, 4
  02c8e	48 6b c9 01	 imul	 rcx, rcx, 1
  02c92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  02c99	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02ca0	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02ca8	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1504 :             prev_fpr64[2] = pTargetCPU_REGS->fpr[2];

  02cab	b8 04 00 00 00	 mov	 eax, 4
  02cb0	48 6b c0 02	 imul	 rax, rax, 2
  02cb4	b9 04 00 00 00	 mov	 ecx, 4
  02cb9	48 6b c9 02	 imul	 rcx, rcx, 2
  02cbd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  02cc4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02ccb	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02cd3	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1505 :             prev_fpr64[3] = pTargetCPU_REGS->fpr[3];

  02cd6	b8 04 00 00 00	 mov	 eax, 4
  02cdb	48 6b c0 03	 imul	 rax, rax, 3
  02cdf	b9 04 00 00 00	 mov	 ecx, 4
  02ce4	48 6b c9 03	 imul	 rcx, rcx, 3
  02ce8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  02cef	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02cf6	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02cfe	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1506 : 
; 1507 :             gui_fprintf(fStatusStream,

  02d01	b8 04 00 00 00	 mov	 eax, 4
  02d06	48 6b c0 03	 imul	 rax, rax, 3
  02d0a	b9 04 00 00 00	 mov	 ecx, 4
  02d0f	48 6b c9 02	 imul	 rcx, rcx, 2
  02d13	ba 04 00 00 00	 mov	 edx, 4
  02d18	48 6b d2 01	 imul	 rdx, rdx, 1
  02d1c	41 b8 04 00 00
	00		 mov	 r8d, 4
  02d22	4d 6b c0 00	 imul	 r8, r8, 0
  02d26	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  02d2d	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  02d35	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  02d39	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02d40	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  02d47	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02d4b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02d52	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  02d5a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02d61	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  02d69	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168489
  02d70	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  02d77	e8 00 00 00 00	 call	 gui_fprintf
$LN70@UpdateRegi:

; 1508 : 
; 1509 :                 "64_FR0-1="REG32FMT""REG32FMT" "REG32FMT""REG32FMT"\n"
; 1510 : 
; 1511 :                 ,pTargetCPU_REGS->fpr[0]  ,pTargetCPU_REGS->fpr[1]
; 1512 :                 ,pTargetCPU_REGS->fpr[2]  ,pTargetCPU_REGS->fpr[3]
; 1513 :             );
; 1514 :         }
; 1515 : 
; 1516 :         if (0
; 1517 :             || prev_fpr64[4] != pTargetCPU_REGS->fpr[4]
; 1518 :             || prev_fpr64[5] != pTargetCPU_REGS->fpr[5]
; 1519 :             || prev_fpr64[6] != pTargetCPU_REGS->fpr[6]
; 1520 :             || prev_fpr64[7] != pTargetCPU_REGS->fpr[7]

  02d7c	33 c0		 xor	 eax, eax
  02d7e	85 c0		 test	 eax, eax
  02d80	0f 85 bc 00 00
	00		 jne	 $LN73@UpdateRegi
  02d86	b8 04 00 00 00	 mov	 eax, 4
  02d8b	48 6b c0 04	 imul	 rax, rax, 4
  02d8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02d96	ba 04 00 00 00	 mov	 edx, 4
  02d9b	48 6b d2 04	 imul	 rdx, rdx, 4
  02d9f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02da6	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02dae	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02db1	0f 85 8b 00 00
	00		 jne	 $LN73@UpdateRegi
  02db7	b8 04 00 00 00	 mov	 eax, 4
  02dbc	48 6b c0 05	 imul	 rax, rax, 5
  02dc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02dc7	ba 04 00 00 00	 mov	 edx, 4
  02dcc	48 6b d2 05	 imul	 rdx, rdx, 5
  02dd0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02dd7	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02ddf	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02de2	75 5e		 jne	 SHORT $LN73@UpdateRegi
  02de4	b8 04 00 00 00	 mov	 eax, 4
  02de9	48 6b c0 06	 imul	 rax, rax, 6
  02ded	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02df4	ba 04 00 00 00	 mov	 edx, 4
  02df9	48 6b d2 06	 imul	 rdx, rdx, 6
  02dfd	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02e04	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02e0c	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02e0f	75 31		 jne	 SHORT $LN73@UpdateRegi
  02e11	b8 04 00 00 00	 mov	 eax, 4
  02e16	48 6b c0 07	 imul	 rax, rax, 7
  02e1a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02e21	ba 04 00 00 00	 mov	 edx, 4
  02e26	48 6b d2 07	 imul	 rdx, rdx, 7
  02e2a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02e31	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02e39	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02e3c	0f 84 27 01 00
	00		 je	 $LN72@UpdateRegi
$LN73@UpdateRegi:

; 1521 :         )
; 1522 :         {
; 1523 :             prev_fpr64[4] = pTargetCPU_REGS->fpr[4];

  02e42	b8 04 00 00 00	 mov	 eax, 4
  02e47	48 6b c0 04	 imul	 rax, rax, 4
  02e4b	b9 04 00 00 00	 mov	 ecx, 4
  02e50	48 6b c9 04	 imul	 rcx, rcx, 4
  02e54	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  02e5b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02e62	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02e6a	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1524 :             prev_fpr64[5] = pTargetCPU_REGS->fpr[5];

  02e6d	b8 04 00 00 00	 mov	 eax, 4
  02e72	48 6b c0 05	 imul	 rax, rax, 5
  02e76	b9 04 00 00 00	 mov	 ecx, 4
  02e7b	48 6b c9 05	 imul	 rcx, rcx, 5
  02e7f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  02e86	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02e8d	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02e95	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1525 :             prev_fpr64[6] = pTargetCPU_REGS->fpr[6];

  02e98	b8 04 00 00 00	 mov	 eax, 4
  02e9d	48 6b c0 06	 imul	 rax, rax, 6
  02ea1	b9 04 00 00 00	 mov	 ecx, 4
  02ea6	48 6b c9 06	 imul	 rcx, rcx, 6
  02eaa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  02eb1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02eb8	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02ec0	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1526 :             prev_fpr64[7] = pTargetCPU_REGS->fpr[7];

  02ec3	b8 04 00 00 00	 mov	 eax, 4
  02ec8	48 6b c0 07	 imul	 rax, rax, 7
  02ecc	b9 04 00 00 00	 mov	 ecx, 4
  02ed1	48 6b c9 07	 imul	 rcx, rcx, 7
  02ed5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  02edc	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02ee3	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  02eeb	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1527 : 
; 1528 :             gui_fprintf(fStatusStream,

  02eee	b8 04 00 00 00	 mov	 eax, 4
  02ef3	48 6b c0 07	 imul	 rax, rax, 7
  02ef7	b9 04 00 00 00	 mov	 ecx, 4
  02efc	48 6b c9 06	 imul	 rcx, rcx, 6
  02f00	ba 04 00 00 00	 mov	 edx, 4
  02f05	48 6b d2 05	 imul	 rdx, rdx, 5
  02f09	41 b8 04 00 00
	00		 mov	 r8d, 4
  02f0f	4d 6b c0 04	 imul	 r8, r8, 4
  02f13	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  02f1a	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  02f22	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  02f26	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02f2d	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  02f34	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02f38	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02f3f	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  02f47	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  02f4e	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  02f56	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168492
  02f5d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  02f64	e8 00 00 00 00	 call	 gui_fprintf
$LN72@UpdateRegi:

; 1529 : 
; 1530 :                 "64_FR2-3="REG32FMT""REG32FMT" "REG32FMT""REG32FMT"\n"
; 1531 : 
; 1532 :                 ,pTargetCPU_REGS->fpr[4]  ,pTargetCPU_REGS->fpr[5]
; 1533 :                 ,pTargetCPU_REGS->fpr[6]  ,pTargetCPU_REGS->fpr[7]
; 1534 :             );
; 1535 :         }
; 1536 : 
; 1537 :         if (0
; 1538 :             || prev_fpr64[8]  != pTargetCPU_REGS->fpr[8]
; 1539 :             || prev_fpr64[9]  != pTargetCPU_REGS->fpr[9]
; 1540 :             || prev_fpr64[10] != pTargetCPU_REGS->fpr[10]
; 1541 :             || prev_fpr64[11] != pTargetCPU_REGS->fpr[11]

  02f69	33 c0		 xor	 eax, eax
  02f6b	85 c0		 test	 eax, eax
  02f6d	0f 85 bc 00 00
	00		 jne	 $LN75@UpdateRegi
  02f73	b8 04 00 00 00	 mov	 eax, 4
  02f78	48 6b c0 08	 imul	 rax, rax, 8
  02f7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02f83	ba 04 00 00 00	 mov	 edx, 4
  02f88	48 6b d2 08	 imul	 rdx, rdx, 8
  02f8c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02f93	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02f9b	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02f9e	0f 85 8b 00 00
	00		 jne	 $LN75@UpdateRegi
  02fa4	b8 04 00 00 00	 mov	 eax, 4
  02fa9	48 6b c0 09	 imul	 rax, rax, 9
  02fad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02fb4	ba 04 00 00 00	 mov	 edx, 4
  02fb9	48 6b d2 09	 imul	 rdx, rdx, 9
  02fbd	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02fc4	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02fcc	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02fcf	75 5e		 jne	 SHORT $LN75@UpdateRegi
  02fd1	b8 04 00 00 00	 mov	 eax, 4
  02fd6	48 6b c0 0a	 imul	 rax, rax, 10
  02fda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  02fe1	ba 04 00 00 00	 mov	 edx, 4
  02fe6	48 6b d2 0a	 imul	 rdx, rdx, 10
  02fea	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  02ff1	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  02ff9	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  02ffc	75 31		 jne	 SHORT $LN75@UpdateRegi
  02ffe	b8 04 00 00 00	 mov	 eax, 4
  03003	48 6b c0 0b	 imul	 rax, rax, 11
  03007	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  0300e	ba 04 00 00 00	 mov	 edx, 4
  03013	48 6b d2 0b	 imul	 rdx, rdx, 11
  03017	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0301e	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  03026	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03029	0f 84 27 01 00
	00		 je	 $LN74@UpdateRegi
$LN75@UpdateRegi:

; 1542 :         )
; 1543 :         {
; 1544 :             prev_fpr64[8]  = pTargetCPU_REGS->fpr[8];

  0302f	b8 04 00 00 00	 mov	 eax, 4
  03034	48 6b c0 08	 imul	 rax, rax, 8
  03038	b9 04 00 00 00	 mov	 ecx, 4
  0303d	48 6b c9 08	 imul	 rcx, rcx, 8
  03041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03048	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0304f	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03057	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1545 :             prev_fpr64[9]  = pTargetCPU_REGS->fpr[9];

  0305a	b8 04 00 00 00	 mov	 eax, 4
  0305f	48 6b c0 09	 imul	 rax, rax, 9
  03063	b9 04 00 00 00	 mov	 ecx, 4
  03068	48 6b c9 09	 imul	 rcx, rcx, 9
  0306c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03073	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0307a	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03082	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1546 :             prev_fpr64[10] = pTargetCPU_REGS->fpr[10];

  03085	b8 04 00 00 00	 mov	 eax, 4
  0308a	48 6b c0 0a	 imul	 rax, rax, 10
  0308e	b9 04 00 00 00	 mov	 ecx, 4
  03093	48 6b c9 0a	 imul	 rcx, rcx, 10
  03097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  0309e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  030a5	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  030ad	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1547 :             prev_fpr64[11] = pTargetCPU_REGS->fpr[11];

  030b0	b8 04 00 00 00	 mov	 eax, 4
  030b5	48 6b c0 0b	 imul	 rax, rax, 11
  030b9	b9 04 00 00 00	 mov	 ecx, 4
  030be	48 6b c9 0b	 imul	 rcx, rcx, 11
  030c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  030c9	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  030d0	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  030d8	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1548 : 
; 1549 :             gui_fprintf(fStatusStream,

  030db	b8 04 00 00 00	 mov	 eax, 4
  030e0	48 6b c0 0b	 imul	 rax, rax, 11
  030e4	b9 04 00 00 00	 mov	 ecx, 4
  030e9	48 6b c9 0a	 imul	 rcx, rcx, 10
  030ed	ba 04 00 00 00	 mov	 edx, 4
  030f2	48 6b d2 09	 imul	 rdx, rdx, 9
  030f6	41 b8 04 00 00
	00		 mov	 r8d, 4
  030fc	4d 6b c0 08	 imul	 r8, r8, 8
  03100	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  03107	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  0310f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  03113	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0311a	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  03121	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  03125	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0312c	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  03134	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0313b	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  03143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168495
  0314a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  03151	e8 00 00 00 00	 call	 gui_fprintf
$LN74@UpdateRegi:

; 1550 : 
; 1551 :                 "64_FR4-5="REG32FMT""REG32FMT" "REG32FMT""REG32FMT"\n"
; 1552 : 
; 1553 :                 ,pTargetCPU_REGS->fpr[8]  ,pTargetCPU_REGS->fpr[9]
; 1554 :                 ,pTargetCPU_REGS->fpr[10] ,pTargetCPU_REGS->fpr[11]
; 1555 : 
; 1556 :             );
; 1557 :         }
; 1558 : 
; 1559 :         if (0
; 1560 :             || prev_fpr64[12] != pTargetCPU_REGS->fpr[12]
; 1561 :             || prev_fpr64[13] != pTargetCPU_REGS->fpr[13]
; 1562 :             || prev_fpr64[14] != pTargetCPU_REGS->fpr[14]
; 1563 :             || prev_fpr64[15] != pTargetCPU_REGS->fpr[15]

  03156	33 c0		 xor	 eax, eax
  03158	85 c0		 test	 eax, eax
  0315a	0f 85 bc 00 00
	00		 jne	 $LN77@UpdateRegi
  03160	b8 04 00 00 00	 mov	 eax, 4
  03165	48 6b c0 0c	 imul	 rax, rax, 12
  03169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  03170	ba 04 00 00 00	 mov	 edx, 4
  03175	48 6b d2 0c	 imul	 rdx, rdx, 12
  03179	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03180	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  03188	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0318b	0f 85 8b 00 00
	00		 jne	 $LN77@UpdateRegi
  03191	b8 04 00 00 00	 mov	 eax, 4
  03196	48 6b c0 0d	 imul	 rax, rax, 13
  0319a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  031a1	ba 04 00 00 00	 mov	 edx, 4
  031a6	48 6b d2 0d	 imul	 rdx, rdx, 13
  031aa	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  031b1	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  031b9	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  031bc	75 5e		 jne	 SHORT $LN77@UpdateRegi
  031be	b8 04 00 00 00	 mov	 eax, 4
  031c3	48 6b c0 0e	 imul	 rax, rax, 14
  031c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  031ce	ba 04 00 00 00	 mov	 edx, 4
  031d3	48 6b d2 0e	 imul	 rdx, rdx, 14
  031d7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  031de	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  031e6	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  031e9	75 31		 jne	 SHORT $LN77@UpdateRegi
  031eb	b8 04 00 00 00	 mov	 eax, 4
  031f0	48 6b c0 0f	 imul	 rax, rax, 15
  031f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  031fb	ba 04 00 00 00	 mov	 edx, 4
  03200	48 6b d2 0f	 imul	 rdx, rdx, 15
  03204	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0320b	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  03213	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03216	0f 84 27 01 00
	00		 je	 $LN76@UpdateRegi
$LN77@UpdateRegi:

; 1564 :         )
; 1565 :         {
; 1566 :             prev_fpr64[12] = pTargetCPU_REGS->fpr[12];

  0321c	b8 04 00 00 00	 mov	 eax, 4
  03221	48 6b c0 0c	 imul	 rax, rax, 12
  03225	b9 04 00 00 00	 mov	 ecx, 4
  0322a	48 6b c9 0c	 imul	 rcx, rcx, 12
  0322e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03235	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0323c	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03244	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1567 :             prev_fpr64[13] = pTargetCPU_REGS->fpr[13];

  03247	b8 04 00 00 00	 mov	 eax, 4
  0324c	48 6b c0 0d	 imul	 rax, rax, 13
  03250	b9 04 00 00 00	 mov	 ecx, 4
  03255	48 6b c9 0d	 imul	 rcx, rcx, 13
  03259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03260	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03267	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  0326f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1568 :             prev_fpr64[14] = pTargetCPU_REGS->fpr[14];

  03272	b8 04 00 00 00	 mov	 eax, 4
  03277	48 6b c0 0e	 imul	 rax, rax, 14
  0327b	b9 04 00 00 00	 mov	 ecx, 4
  03280	48 6b c9 0e	 imul	 rcx, rcx, 14
  03284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  0328b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03292	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  0329a	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1569 :             prev_fpr64[15] = pTargetCPU_REGS->fpr[15];

  0329d	b8 04 00 00 00	 mov	 eax, 4
  032a2	48 6b c0 0f	 imul	 rax, rax, 15
  032a6	b9 04 00 00 00	 mov	 ecx, 4
  032ab	48 6b c9 0f	 imul	 rcx, rcx, 15
  032af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  032b6	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  032bd	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  032c5	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1570 : 
; 1571 :             gui_fprintf(fStatusStream,

  032c8	b8 04 00 00 00	 mov	 eax, 4
  032cd	48 6b c0 0f	 imul	 rax, rax, 15
  032d1	b9 04 00 00 00	 mov	 ecx, 4
  032d6	48 6b c9 0e	 imul	 rcx, rcx, 14
  032da	ba 04 00 00 00	 mov	 edx, 4
  032df	48 6b d2 0d	 imul	 rdx, rdx, 13
  032e3	41 b8 04 00 00
	00		 mov	 r8d, 4
  032e9	4d 6b c0 0c	 imul	 r8, r8, 12
  032ed	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  032f4	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  032fc	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  03300	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03307	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  0330e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  03312	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03319	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  03321	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03328	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  03330	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168498
  03337	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  0333e	e8 00 00 00 00	 call	 gui_fprintf
$LN76@UpdateRegi:

; 1572 : 
; 1573 :                 "64_FR6-7="REG32FMT""REG32FMT" "REG32FMT""REG32FMT"\n"
; 1574 : 
; 1575 :                 ,pTargetCPU_REGS->fpr[12] ,pTargetCPU_REGS->fpr[13]
; 1576 :                 ,pTargetCPU_REGS->fpr[14] ,pTargetCPU_REGS->fpr[15]
; 1577 : 
; 1578 :             );
; 1579 :         }
; 1580 : 
; 1581 :         if (0
; 1582 :             || prev_fpr64[16] != pTargetCPU_REGS->fpr[16]
; 1583 :             || prev_fpr64[17] != pTargetCPU_REGS->fpr[17]
; 1584 :             || prev_fpr64[18] != pTargetCPU_REGS->fpr[18]
; 1585 :             || prev_fpr64[19] != pTargetCPU_REGS->fpr[19]

  03343	33 c0		 xor	 eax, eax
  03345	85 c0		 test	 eax, eax
  03347	0f 85 bc 00 00
	00		 jne	 $LN79@UpdateRegi
  0334d	b8 04 00 00 00	 mov	 eax, 4
  03352	48 6b c0 10	 imul	 rax, rax, 16
  03356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  0335d	ba 04 00 00 00	 mov	 edx, 4
  03362	48 6b d2 10	 imul	 rdx, rdx, 16
  03366	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0336d	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  03375	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03378	0f 85 8b 00 00
	00		 jne	 $LN79@UpdateRegi
  0337e	b8 04 00 00 00	 mov	 eax, 4
  03383	48 6b c0 11	 imul	 rax, rax, 17
  03387	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  0338e	ba 04 00 00 00	 mov	 edx, 4
  03393	48 6b d2 11	 imul	 rdx, rdx, 17
  03397	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0339e	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  033a6	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  033a9	75 5e		 jne	 SHORT $LN79@UpdateRegi
  033ab	b8 04 00 00 00	 mov	 eax, 4
  033b0	48 6b c0 12	 imul	 rax, rax, 18
  033b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  033bb	ba 04 00 00 00	 mov	 edx, 4
  033c0	48 6b d2 12	 imul	 rdx, rdx, 18
  033c4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  033cb	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  033d3	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  033d6	75 31		 jne	 SHORT $LN79@UpdateRegi
  033d8	b8 04 00 00 00	 mov	 eax, 4
  033dd	48 6b c0 13	 imul	 rax, rax, 19
  033e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  033e8	ba 04 00 00 00	 mov	 edx, 4
  033ed	48 6b d2 13	 imul	 rdx, rdx, 19
  033f1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  033f8	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  03400	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03403	0f 84 27 01 00
	00		 je	 $LN78@UpdateRegi
$LN79@UpdateRegi:

; 1586 :         )
; 1587 :         {
; 1588 :             prev_fpr64[16] = pTargetCPU_REGS->fpr[16];

  03409	b8 04 00 00 00	 mov	 eax, 4
  0340e	48 6b c0 10	 imul	 rax, rax, 16
  03412	b9 04 00 00 00	 mov	 ecx, 4
  03417	48 6b c9 10	 imul	 rcx, rcx, 16
  0341b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03422	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03429	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03431	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1589 :             prev_fpr64[17] = pTargetCPU_REGS->fpr[17];

  03434	b8 04 00 00 00	 mov	 eax, 4
  03439	48 6b c0 11	 imul	 rax, rax, 17
  0343d	b9 04 00 00 00	 mov	 ecx, 4
  03442	48 6b c9 11	 imul	 rcx, rcx, 17
  03446	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  0344d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03454	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  0345c	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1590 :             prev_fpr64[18] = pTargetCPU_REGS->fpr[18];

  0345f	b8 04 00 00 00	 mov	 eax, 4
  03464	48 6b c0 12	 imul	 rax, rax, 18
  03468	b9 04 00 00 00	 mov	 ecx, 4
  0346d	48 6b c9 12	 imul	 rcx, rcx, 18
  03471	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03478	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0347f	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03487	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1591 :             prev_fpr64[19] = pTargetCPU_REGS->fpr[19];

  0348a	b8 04 00 00 00	 mov	 eax, 4
  0348f	48 6b c0 13	 imul	 rax, rax, 19
  03493	b9 04 00 00 00	 mov	 ecx, 4
  03498	48 6b c9 13	 imul	 rcx, rcx, 19
  0349c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  034a3	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  034aa	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  034b2	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1592 : 
; 1593 :             gui_fprintf(fStatusStream,

  034b5	b8 04 00 00 00	 mov	 eax, 4
  034ba	48 6b c0 13	 imul	 rax, rax, 19
  034be	b9 04 00 00 00	 mov	 ecx, 4
  034c3	48 6b c9 12	 imul	 rcx, rcx, 18
  034c7	ba 04 00 00 00	 mov	 edx, 4
  034cc	48 6b d2 11	 imul	 rdx, rdx, 17
  034d0	41 b8 04 00 00
	00		 mov	 r8d, 4
  034d6	4d 6b c0 10	 imul	 r8, r8, 16
  034da	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  034e1	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  034e9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  034ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  034f4	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  034fb	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  034ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03506	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  0350e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03515	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  0351d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168501
  03524	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  0352b	e8 00 00 00 00	 call	 gui_fprintf
$LN78@UpdateRegi:

; 1594 : 
; 1595 :                 "64_FR8-9="REG32FMT""REG32FMT" "REG32FMT""REG32FMT"\n"
; 1596 : 
; 1597 :                 ,pTargetCPU_REGS->fpr[16] ,pTargetCPU_REGS->fpr[17]
; 1598 :                 ,pTargetCPU_REGS->fpr[18] ,pTargetCPU_REGS->fpr[19]
; 1599 :             );
; 1600 :         }
; 1601 : 
; 1602 :         if (0
; 1603 :             || prev_fpr64[20] != pTargetCPU_REGS->fpr[20]
; 1604 :             || prev_fpr64[21] != pTargetCPU_REGS->fpr[21]
; 1605 :             || prev_fpr64[22] != pTargetCPU_REGS->fpr[22]
; 1606 :             || prev_fpr64[23] != pTargetCPU_REGS->fpr[23]

  03530	33 c0		 xor	 eax, eax
  03532	85 c0		 test	 eax, eax
  03534	0f 85 bc 00 00
	00		 jne	 $LN81@UpdateRegi
  0353a	b8 04 00 00 00	 mov	 eax, 4
  0353f	48 6b c0 14	 imul	 rax, rax, 20
  03543	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  0354a	ba 04 00 00 00	 mov	 edx, 4
  0354f	48 6b d2 14	 imul	 rdx, rdx, 20
  03553	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0355a	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  03562	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03565	0f 85 8b 00 00
	00		 jne	 $LN81@UpdateRegi
  0356b	b8 04 00 00 00	 mov	 eax, 4
  03570	48 6b c0 15	 imul	 rax, rax, 21
  03574	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  0357b	ba 04 00 00 00	 mov	 edx, 4
  03580	48 6b d2 15	 imul	 rdx, rdx, 21
  03584	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0358b	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  03593	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03596	75 5e		 jne	 SHORT $LN81@UpdateRegi
  03598	b8 04 00 00 00	 mov	 eax, 4
  0359d	48 6b c0 16	 imul	 rax, rax, 22
  035a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  035a8	ba 04 00 00 00	 mov	 edx, 4
  035ad	48 6b d2 16	 imul	 rdx, rdx, 22
  035b1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  035b8	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  035c0	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  035c3	75 31		 jne	 SHORT $LN81@UpdateRegi
  035c5	b8 04 00 00 00	 mov	 eax, 4
  035ca	48 6b c0 17	 imul	 rax, rax, 23
  035ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  035d5	ba 04 00 00 00	 mov	 edx, 4
  035da	48 6b d2 17	 imul	 rdx, rdx, 23
  035de	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  035e5	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  035ed	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  035f0	0f 84 27 01 00
	00		 je	 $LN80@UpdateRegi
$LN81@UpdateRegi:

; 1607 :         )
; 1608 :         {
; 1609 :             prev_fpr64[20] = pTargetCPU_REGS->fpr[20];

  035f6	b8 04 00 00 00	 mov	 eax, 4
  035fb	48 6b c0 14	 imul	 rax, rax, 20
  035ff	b9 04 00 00 00	 mov	 ecx, 4
  03604	48 6b c9 14	 imul	 rcx, rcx, 20
  03608	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  0360f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03616	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  0361e	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1610 :             prev_fpr64[21] = pTargetCPU_REGS->fpr[21];

  03621	b8 04 00 00 00	 mov	 eax, 4
  03626	48 6b c0 15	 imul	 rax, rax, 21
  0362a	b9 04 00 00 00	 mov	 ecx, 4
  0362f	48 6b c9 15	 imul	 rcx, rcx, 21
  03633	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  0363a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03641	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03649	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1611 :             prev_fpr64[22] = pTargetCPU_REGS->fpr[22];

  0364c	b8 04 00 00 00	 mov	 eax, 4
  03651	48 6b c0 16	 imul	 rax, rax, 22
  03655	b9 04 00 00 00	 mov	 ecx, 4
  0365a	48 6b c9 16	 imul	 rcx, rcx, 22
  0365e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03665	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0366c	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03674	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1612 :             prev_fpr64[23] = pTargetCPU_REGS->fpr[23];

  03677	b8 04 00 00 00	 mov	 eax, 4
  0367c	48 6b c0 17	 imul	 rax, rax, 23
  03680	b9 04 00 00 00	 mov	 ecx, 4
  03685	48 6b c9 17	 imul	 rcx, rcx, 23
  03689	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03690	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03697	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  0369f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1613 : 
; 1614 :             gui_fprintf(fStatusStream,

  036a2	b8 04 00 00 00	 mov	 eax, 4
  036a7	48 6b c0 17	 imul	 rax, rax, 23
  036ab	b9 04 00 00 00	 mov	 ecx, 4
  036b0	48 6b c9 16	 imul	 rcx, rcx, 22
  036b4	ba 04 00 00 00	 mov	 edx, 4
  036b9	48 6b d2 15	 imul	 rdx, rdx, 21
  036bd	41 b8 04 00 00
	00		 mov	 r8d, 4
  036c3	4d 6b c0 14	 imul	 r8, r8, 20
  036c7	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  036ce	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  036d6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  036da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  036e1	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  036e8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  036ec	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  036f3	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  036fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03702	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  0370a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168504
  03711	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  03718	e8 00 00 00 00	 call	 gui_fprintf
$LN80@UpdateRegi:

; 1615 : 
; 1616 :                 "64_FRA-B="REG32FMT""REG32FMT" "REG32FMT""REG32FMT"\n"
; 1617 : 
; 1618 :                 ,pTargetCPU_REGS->fpr[20] ,pTargetCPU_REGS->fpr[21]
; 1619 :                 ,pTargetCPU_REGS->fpr[22] ,pTargetCPU_REGS->fpr[23]
; 1620 :             );
; 1621 :         }
; 1622 : 
; 1623 :         if (0
; 1624 :             || prev_fpr64[24] != pTargetCPU_REGS->fpr[24]
; 1625 :             || prev_fpr64[25] != pTargetCPU_REGS->fpr[25]
; 1626 :             || prev_fpr64[26] != pTargetCPU_REGS->fpr[26]
; 1627 :             || prev_fpr64[27] != pTargetCPU_REGS->fpr[27]

  0371d	33 c0		 xor	 eax, eax
  0371f	85 c0		 test	 eax, eax
  03721	0f 85 bc 00 00
	00		 jne	 $LN83@UpdateRegi
  03727	b8 04 00 00 00	 mov	 eax, 4
  0372c	48 6b c0 18	 imul	 rax, rax, 24
  03730	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  03737	ba 04 00 00 00	 mov	 edx, 4
  0373c	48 6b d2 18	 imul	 rdx, rdx, 24
  03740	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03747	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  0374f	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03752	0f 85 8b 00 00
	00		 jne	 $LN83@UpdateRegi
  03758	b8 04 00 00 00	 mov	 eax, 4
  0375d	48 6b c0 19	 imul	 rax, rax, 25
  03761	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  03768	ba 04 00 00 00	 mov	 edx, 4
  0376d	48 6b d2 19	 imul	 rdx, rdx, 25
  03771	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03778	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  03780	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03783	75 5e		 jne	 SHORT $LN83@UpdateRegi
  03785	b8 04 00 00 00	 mov	 eax, 4
  0378a	48 6b c0 1a	 imul	 rax, rax, 26
  0378e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  03795	ba 04 00 00 00	 mov	 edx, 4
  0379a	48 6b d2 1a	 imul	 rdx, rdx, 26
  0379e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  037a5	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  037ad	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  037b0	75 31		 jne	 SHORT $LN83@UpdateRegi
  037b2	b8 04 00 00 00	 mov	 eax, 4
  037b7	48 6b c0 1b	 imul	 rax, rax, 27
  037bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  037c2	ba 04 00 00 00	 mov	 edx, 4
  037c7	48 6b d2 1b	 imul	 rdx, rdx, 27
  037cb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  037d2	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  037da	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  037dd	0f 84 27 01 00
	00		 je	 $LN82@UpdateRegi
$LN83@UpdateRegi:

; 1628 :         )
; 1629 :         {
; 1630 :             prev_fpr64[24] = pTargetCPU_REGS->fpr[24];

  037e3	b8 04 00 00 00	 mov	 eax, 4
  037e8	48 6b c0 18	 imul	 rax, rax, 24
  037ec	b9 04 00 00 00	 mov	 ecx, 4
  037f1	48 6b c9 18	 imul	 rcx, rcx, 24
  037f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  037fc	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03803	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  0380b	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1631 :             prev_fpr64[25] = pTargetCPU_REGS->fpr[25];

  0380e	b8 04 00 00 00	 mov	 eax, 4
  03813	48 6b c0 19	 imul	 rax, rax, 25
  03817	b9 04 00 00 00	 mov	 ecx, 4
  0381c	48 6b c9 19	 imul	 rcx, rcx, 25
  03820	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03827	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  0382e	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03836	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1632 :             prev_fpr64[26] = pTargetCPU_REGS->fpr[26];

  03839	b8 04 00 00 00	 mov	 eax, 4
  0383e	48 6b c0 1a	 imul	 rax, rax, 26
  03842	b9 04 00 00 00	 mov	 ecx, 4
  03847	48 6b c9 1a	 imul	 rcx, rcx, 26
  0384b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03852	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03859	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03861	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1633 :             prev_fpr64[27] = pTargetCPU_REGS->fpr[27];

  03864	b8 04 00 00 00	 mov	 eax, 4
  03869	48 6b c0 1b	 imul	 rax, rax, 27
  0386d	b9 04 00 00 00	 mov	 ecx, 4
  03872	48 6b c9 1b	 imul	 rcx, rcx, 27
  03876	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  0387d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03884	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  0388c	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1634 : 
; 1635 :             gui_fprintf(fStatusStream,

  0388f	b8 04 00 00 00	 mov	 eax, 4
  03894	48 6b c0 1b	 imul	 rax, rax, 27
  03898	b9 04 00 00 00	 mov	 ecx, 4
  0389d	48 6b c9 1a	 imul	 rcx, rcx, 26
  038a1	ba 04 00 00 00	 mov	 edx, 4
  038a6	48 6b d2 19	 imul	 rdx, rdx, 25
  038aa	41 b8 04 00 00
	00		 mov	 r8d, 4
  038b0	4d 6b c0 18	 imul	 r8, r8, 24
  038b4	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  038bb	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  038c3	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  038c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  038ce	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  038d5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  038d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  038e0	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  038e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  038ef	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  038f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168507
  038fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  03905	e8 00 00 00 00	 call	 gui_fprintf
$LN82@UpdateRegi:

; 1636 : 
; 1637 :                 "64_FRC-D="REG32FMT""REG32FMT" "REG32FMT""REG32FMT"\n"
; 1638 : 
; 1639 :                 ,pTargetCPU_REGS->fpr[24] ,pTargetCPU_REGS->fpr[25]
; 1640 :                 ,pTargetCPU_REGS->fpr[26] ,pTargetCPU_REGS->fpr[27]
; 1641 :             );
; 1642 :         }
; 1643 : 
; 1644 :         if (0
; 1645 :             || prev_fpr64[28] != pTargetCPU_REGS->fpr[28]
; 1646 :             || prev_fpr64[29] != pTargetCPU_REGS->fpr[29]
; 1647 :             || prev_fpr64[30] != pTargetCPU_REGS->fpr[30]
; 1648 :             || prev_fpr64[31] != pTargetCPU_REGS->fpr[31]

  0390a	33 c0		 xor	 eax, eax
  0390c	85 c0		 test	 eax, eax
  0390e	0f 85 bc 00 00
	00		 jne	 $LN85@UpdateRegi
  03914	b8 04 00 00 00	 mov	 eax, 4
  03919	48 6b c0 1c	 imul	 rax, rax, 28
  0391d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  03924	ba 04 00 00 00	 mov	 edx, 4
  03929	48 6b d2 1c	 imul	 rdx, rdx, 28
  0392d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03934	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  0393c	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0393f	0f 85 8b 00 00
	00		 jne	 $LN85@UpdateRegi
  03945	b8 04 00 00 00	 mov	 eax, 4
  0394a	48 6b c0 1d	 imul	 rax, rax, 29
  0394e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  03955	ba 04 00 00 00	 mov	 edx, 4
  0395a	48 6b d2 1d	 imul	 rdx, rdx, 29
  0395e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03965	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  0396d	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  03970	75 5e		 jne	 SHORT $LN85@UpdateRegi
  03972	b8 04 00 00 00	 mov	 eax, 4
  03977	48 6b c0 1e	 imul	 rax, rax, 30
  0397b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  03982	ba 04 00 00 00	 mov	 edx, 4
  03987	48 6b d2 1e	 imul	 rdx, rdx, 30
  0398b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03992	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  0399a	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  0399d	75 31		 jne	 SHORT $LN85@UpdateRegi
  0399f	b8 04 00 00 00	 mov	 eax, 4
  039a4	48 6b c0 1f	 imul	 rax, rax, 31
  039a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  039af	ba 04 00 00 00	 mov	 edx, 4
  039b4	48 6b d2 1f	 imul	 rdx, rdx, 31
  039b8	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  039bf	41 8b 94 10 40
	03 00 00	 mov	 edx, DWORD PTR [r8+rdx+832]
  039c7	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  039ca	0f 84 27 01 00
	00		 je	 $LN84@UpdateRegi
$LN85@UpdateRegi:

; 1649 :         )
; 1650 :         {
; 1651 :             prev_fpr64[28] = pTargetCPU_REGS->fpr[28];

  039d0	b8 04 00 00 00	 mov	 eax, 4
  039d5	48 6b c0 1c	 imul	 rax, rax, 28
  039d9	b9 04 00 00 00	 mov	 ecx, 4
  039de	48 6b c9 1c	 imul	 rcx, rcx, 28
  039e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  039e9	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  039f0	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  039f8	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1652 :             prev_fpr64[29] = pTargetCPU_REGS->fpr[29];

  039fb	b8 04 00 00 00	 mov	 eax, 4
  03a00	48 6b c0 1d	 imul	 rax, rax, 29
  03a04	b9 04 00 00 00	 mov	 ecx, 4
  03a09	48 6b c9 1d	 imul	 rcx, rcx, 29
  03a0d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03a14	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03a1b	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03a23	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1653 :             prev_fpr64[30] = pTargetCPU_REGS->fpr[30];

  03a26	b8 04 00 00 00	 mov	 eax, 4
  03a2b	48 6b c0 1e	 imul	 rax, rax, 30
  03a2f	b9 04 00 00 00	 mov	 ecx, 4
  03a34	48 6b c9 1e	 imul	 rcx, rcx, 30
  03a38	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03a3f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03a46	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03a4e	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1654 :             prev_fpr64[31] = pTargetCPU_REGS->fpr[31];

  03a51	b8 04 00 00 00	 mov	 eax, 4
  03a56	48 6b c0 1f	 imul	 rax, rax, 31
  03a5a	b9 04 00 00 00	 mov	 ecx, 4
  03a5f	48 6b c9 1f	 imul	 rcx, rcx, 31
  03a63	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prev_fpr64
  03a6a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pTargetCPU_REGS
  03a71	41 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax+832]
  03a79	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 1655 : 
; 1656 :             gui_fprintf(fStatusStream,

  03a7c	b8 04 00 00 00	 mov	 eax, 4
  03a81	48 6b c0 1f	 imul	 rax, rax, 31
  03a85	b9 04 00 00 00	 mov	 ecx, 4
  03a8a	48 6b c9 1e	 imul	 rcx, rcx, 30
  03a8e	ba 04 00 00 00	 mov	 edx, 4
  03a93	48 6b d2 1d	 imul	 rdx, rdx, 29
  03a97	41 b8 04 00 00
	00		 mov	 r8d, 4
  03a9d	4d 6b c0 1c	 imul	 r8, r8, 28
  03aa1	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pTargetCPU_REGS
  03aa8	41 8b 84 01 40
	03 00 00	 mov	 eax, DWORD PTR [r9+rax+832]
  03ab0	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  03ab4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03abb	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  03ac2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  03ac6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03acd	44 8b 8c 10 40
	03 00 00	 mov	 r9d, DWORD PTR [rax+rdx+832]
  03ad5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  03adc	46 8b 84 00 40
	03 00 00	 mov	 r8d, DWORD PTR [rax+r8+832]
  03ae4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168510
  03aeb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  03af2	e8 00 00 00 00	 call	 gui_fprintf
$LN84@UpdateRegi:
$LN69@UpdateRegi:
$LN1@UpdateRegi:

; 1657 : 
; 1658 :                 "64_FRE-F="REG32FMT""REG32FMT" "REG32FMT""REG32FMT"\n"
; 1659 : 
; 1660 :                 ,pTargetCPU_REGS->fpr[28] ,pTargetCPU_REGS->fpr[29]
; 1661 :                 ,pTargetCPU_REGS->fpr[30] ,pTargetCPU_REGS->fpr[31]
; 1662 :             );
; 1663 :         }
; 1664 :     }
; 1665 : }

  03af7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  03afb	c3		 ret	 0
UpdateRegisters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
tv83 = 240
tv89 = 244
tv95 = 248
tv133 = 252
tv139 = 256
tv143 = 260
tv149 = 264
tv154 = 268
mipsrate$1 = 272
siosrate$2 = 280
tv158 = 288
tv162 = 292
tv166 = 296
tv170 = 300
tv174 = 304
tv178 = 308
tv198 = 312
tv210 = 316
tv214 = 320
tv218 = 324
tv221 = 328
tv241 = 332
UpdateCPUStatus PROC

; 770  : {

$LN26:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H

; 771  :     if (sysblk.shutdown) return;

  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00021	c1 e8 0b	 shr	 eax, 11
  00024	83 e0 01	 and	 eax, 1
  00027	85 c0		 test	 eax, eax
  00029	74 05		 je	 SHORT $LN2@UpdateCPUS
  0002b	e9 db 05 00 00	 jmp	 $LN1@UpdateCPUS
$LN2@UpdateCPUS:

; 772  : 
; 773  :     if (pTargetCPU_REGS == &sysblk.dummyregs)

  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00037	48 05 00 15 00
	00		 add	 rax, 5376		; 00001500H
  0003d	48 39 05 00 00
	00 00		 cmp	 QWORD PTR pTargetCPU_REGS, rax
  00044	75 3e		 jne	 SHORT $LN3@UpdateCPUS

; 774  :     {
; 775  :         // pTargetCPU_REGS == &sysblk.dummyregs; cpu is offline
; 776  : 
; 777  :         gui_fprintf(fStatusStream, "STATUS="

  00046	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR pcpu
  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00054	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00062	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR pcpu
  00069	4c 8b c0	 mov	 r8, rax
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168380
  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  0007a	e8 00 00 00 00	 call	 gui_fprintf

; 778  : 
; 779  :             "%s%02X (((((((((((((((((((((((( OFFLINE ))))))))))))))))))))))))\n",
; 780  : 
; 781  :             PTYPSTR(pcpu) ,pcpu);
; 782  :     }

  0007f	e9 6c 04 00 00	 jmp	 $LN4@UpdateCPUS
$LN3@UpdateCPUS:

; 783  :     else // pTargetCPU_REGS != &sysblk.dummyregs; cpu is online
; 784  :     {
; 785  :         // CPU status line...  (PSW, status indicators, and instruction count)
; 786  : 
; 787  :         gui_fprintf(fStatusStream, "STATUS="

  00084	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0008b	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  0008f	75 0d		 jne	 SHORT $LN10@UpdateCPUS
  00091	c7 84 24 f0 00
	00 00 5a 00 00
	00		 mov	 DWORD PTR tv83[rsp], 90	; 0000005aH
  0009c	eb 0b		 jmp	 SHORT $LN11@UpdateCPUS
$LN10@UpdateCPUS:
  0009e	c7 84 24 f0 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv83[rsp], 46	; 0000002eH
$LN11@UpdateCPUS:
  000a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  000b0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b6	d1 e8		 shr	 eax, 1
  000b8	83 e0 01	 and	 eax, 1
  000bb	85 c0		 test	 eax, eax
  000bd	74 0d		 je	 SHORT $LN12@UpdateCPUS
  000bf	c7 84 24 f4 00
	00 00 53 00 00
	00		 mov	 DWORD PTR tv89[rsp], 83	; 00000053H
  000ca	eb 0b		 jmp	 SHORT $LN13@UpdateCPUS
$LN12@UpdateCPUS:
  000cc	c7 84 24 f4 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv89[rsp], 46	; 0000002eH
$LN13@UpdateCPUS:
  000d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  000de	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000e2	83 e0 01	 and	 eax, 1
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN14@UpdateCPUS
  000e9	c7 84 24 f8 00
	00 00 50 00 00
	00		 mov	 DWORD PTR tv95[rsp], 80	; 00000050H
  000f4	eb 0b		 jmp	 SHORT $LN15@UpdateCPUS
$LN14@UpdateCPUS:
  000f6	c7 84 24 f8 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv95[rsp], 46	; 0000002eH
$LN15@UpdateCPUS:
  00101	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00108	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0010e	c1 e8 05	 shr	 eax, 5
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 0d		 je	 SHORT $LN16@UpdateCPUS
  00118	c7 84 24 fc 00
	00 00 43 00 00
	00		 mov	 DWORD PTR tv133[rsp], 67 ; 00000043H
  00123	eb 0b		 jmp	 SHORT $LN17@UpdateCPUS
$LN16@UpdateCPUS:
  00125	c7 84 24 fc 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv133[rsp], 46 ; 0000002eH
$LN17@UpdateCPUS:
  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00137	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0013d	c1 e8 0c	 shr	 eax, 12
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	74 0d		 je	 SHORT $LN18@UpdateCPUS
  00147	c7 84 24 00 01
	00 00 4c 00 00
	00		 mov	 DWORD PTR tv139[rsp], 76 ; 0000004cH
  00152	eb 0b		 jmp	 SHORT $LN19@UpdateCPUS
$LN18@UpdateCPUS:
  00154	c7 84 24 00 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv139[rsp], 46 ; 0000002eH
$LN19@UpdateCPUS:
  0015f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR wait_bit
  00166	85 c0		 test	 eax, eax
  00168	74 0d		 je	 SHORT $LN20@UpdateCPUS
  0016a	c7 84 24 04 01
	00 00 57 00 00
	00		 mov	 DWORD PTR tv143[rsp], 87 ; 00000057H
  00175	eb 0b		 jmp	 SHORT $LN21@UpdateCPUS
$LN20@UpdateCPUS:
  00177	c7 84 24 04 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv143[rsp], 46 ; 0000002eH
$LN21@UpdateCPUS:
  00182	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00189	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0018f	c1 e8 0a	 shr	 eax, 10
  00192	83 e0 01	 and	 eax, 1
  00195	85 c0		 test	 eax, eax
  00197	74 0d		 je	 SHORT $LN22@UpdateCPUS
  00199	c7 84 24 08 01
	00 00 54 00 00
	00		 mov	 DWORD PTR tv149[rsp], 84 ; 00000054H
  001a4	eb 0b		 jmp	 SHORT $LN23@UpdateCPUS
$LN22@UpdateCPUS:
  001a6	c7 84 24 08 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv149[rsp], 46 ; 0000002eH
$LN23@UpdateCPUS:
  001b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  001b8	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  001bc	83 f8 03	 cmp	 eax, 3
  001bf	75 0d		 jne	 SHORT $LN24@UpdateCPUS
  001c1	c7 84 24 0c 01
	00 00 4d 00 00
	00		 mov	 DWORD PTR tv154[rsp], 77 ; 0000004dH
  001cc	eb 0b		 jmp	 SHORT $LN25@UpdateCPUS
$LN24@UpdateCPUS:
  001ce	c7 84 24 0c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv154[rsp], 46 ; 0000002eH
$LN25@UpdateCPUS:
  001d9	b8 01 00 00 00	 mov	 eax, 1
  001de	48 6b c0 0f	 imul	 rax, rax, 15
  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psw
  001e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ed	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv158[rsp], eax
  001f4	b9 01 00 00 00	 mov	 ecx, 1
  001f9	48 6b c9 0e	 imul	 rcx, rcx, 14
  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:psw
  00204	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00208	89 8c 24 24 01
	00 00		 mov	 DWORD PTR tv162[rsp], ecx
  0020f	ba 01 00 00 00	 mov	 edx, 1
  00214	48 6b d2 0d	 imul	 rdx, rdx, 13
  00218	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:psw
  0021f	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00224	89 94 24 28 01
	00 00		 mov	 DWORD PTR tv166[rsp], edx
  0022b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00231	4d 6b c0 0c	 imul	 r8, r8, 12
  00235	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:psw
  0023c	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00241	44 89 84 24 2c
	01 00 00	 mov	 DWORD PTR tv170[rsp], r8d
  00249	41 b9 01 00 00
	00		 mov	 r9d, 1
  0024f	4d 6b c9 0b	 imul	 r9, r9, 11
  00253	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:psw
  0025a	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0025f	44 89 8c 24 30
	01 00 00	 mov	 DWORD PTR tv174[rsp], r9d
  00267	41 ba 01 00 00
	00		 mov	 r10d, 1
  0026d	4d 6b d2 0a	 imul	 r10, r10, 10
  00271	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:psw
  00278	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  0027d	44 89 94 24 34
	01 00 00	 mov	 DWORD PTR tv178[rsp], r10d
  00285	41 bb 01 00 00
	00		 mov	 r11d, 1
  0028b	4d 6b db 09	 imul	 r11, r11, 9
  0028f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:psw
  00296	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  0029b	41 bb 01 00 00
	00		 mov	 r11d, 1
  002a1	4d 6b db 08	 imul	 r11, r11, 8
  002a5	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:psw
  002ac	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  002b1	41 bb 01 00 00
	00		 mov	 r11d, 1
  002b7	4d 6b db 07	 imul	 r11, r11, 7
  002bb	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:psw
  002c2	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  002c7	41 bb 01 00 00
	00		 mov	 r11d, 1
  002cd	4d 6b db 06	 imul	 r11, r11, 6
  002d1	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:psw
  002d8	41 0f b6 2c 2b	 movzx	 ebp, BYTE PTR [r11+rbp]
  002dd	41 bb 01 00 00
	00		 mov	 r11d, 1
  002e3	4d 6b db 05	 imul	 r11, r11, 5
  002e7	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:psw
  002ee	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  002f3	44 89 9c 24 38
	01 00 00	 mov	 DWORD PTR tv198[rsp], r11d
  002fb	41 be 01 00 00
	00		 mov	 r14d, 1
  00301	4d 6b f6 04	 imul	 r14, r14, 4
  00305	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:psw
  0030c	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  00311	41 bf 01 00 00
	00		 mov	 r15d, 1
  00317	4d 6b ff 03	 imul	 r15, r15, 3
  0031b	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:psw
  00322	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  00327	41 bc 01 00 00
	00		 mov	 r12d, 1
  0032d	4d 6b e4 02	 imul	 r12, r12, 2
  00331	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:psw
  00338	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0033d	44 89 a4 24 3c
	01 00 00	 mov	 DWORD PTR tv210[rsp], r12d
  00345	41 bd 01 00 00
	00		 mov	 r13d, 1
  0034b	4d 6b ed 01	 imul	 r13, r13, 1
  0034f	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:psw
  00356	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0035b	44 89 a4 24 40
	01 00 00	 mov	 DWORD PTR tv214[rsp], r12d
  00363	41 bd 01 00 00
	00		 mov	 r13d, 1
  00369	4d 6b ed 00	 imul	 r13, r13, 0
  0036d	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:psw
  00374	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00379	44 89 a4 24 44
	01 00 00	 mov	 DWORD PTR tv218[rsp], r12d
  00381	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR pTargetCPU_REGS
  00388	45 0f b7 ad 3c
	08 00 00	 movzx	 r13d, WORD PTR [r13+2108]
  00390	44 89 ac 24 48
	01 00 00	 mov	 DWORD PTR tv221[rsp], r13d
  00398	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR pTargetCPU_REGS
  0039f	45 0f b7 ad 3c
	08 00 00	 movzx	 r13d, WORD PTR [r13+2108]
  003a7	4c 8b 25 00 00
	00 00		 mov	 r12, QWORD PTR __imp_sysblk
  003ae	43 0f b6 8c 2c
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r12+r13+2888]
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  003bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR curr_instcount
  003c4	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rcx
  003cc	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv83[rsp]
  003d3	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], ecx
  003da	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv89[rsp]
  003e1	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], ecx
  003e8	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv95[rsp]
  003ef	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], ecx
  003f6	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv133[rsp]
  003fd	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], ecx
  00404	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv139[rsp]
  0040b	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], ecx
  00412	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv143[rsp]
  00419	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], ecx
  00420	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  00427	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], ecx
  0042e	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv154[rsp]
  00435	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], ecx
  0043c	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv158[rsp]
  00443	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  0044a	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv162[rsp]
  00451	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  00458	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv166[rsp]
  0045f	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  00466	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv170[rsp]
  0046d	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00474	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv174[rsp]
  0047b	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  0047f	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  00486	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0048a	89 5c 24 68	 mov	 DWORD PTR [rsp+104], ebx
  0048e	89 7c 24 60	 mov	 DWORD PTR [rsp+96], edi
  00492	89 74 24 58	 mov	 DWORD PTR [rsp+88], esi
  00496	89 6c 24 50	 mov	 DWORD PTR [rsp+80], ebp
  0049a	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  004a1	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004a5	44 89 74 24 40	 mov	 DWORD PTR [rsp+64], r14d
  004aa	44 89 7c 24 38	 mov	 DWORD PTR [rsp+56], r15d
  004af	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv210[rsp]
  004b6	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  004ba	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv214[rsp]
  004c1	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  004c5	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv218[rsp]
  004cc	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  004d0	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv221[rsp]
  004d7	44 8b c9	 mov	 r9d, ecx
  004da	4c 8b c0	 mov	 r8, rax
  004dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168381
  004e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  004eb	e8 00 00 00 00	 call	 gui_fprintf
$LN4@UpdateCPUS:

; 788  : 
; 789  :             "%s%02X "
; 790  : 
; 791  :             "PSW=%2.2X%2.2X%2.2X%2.2X "
; 792  :                 "%2.2X%2.2X%2.2X%2.2X "
; 793  :                 "%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X "
; 794  : 
; 795  :             "%c%c%c%c%c%c%c%c "
; 796  : 
; 797  :             "instcount=%"PRIu64"\n"
; 798  : 
; 799  :             ,PTYPSTR(pTargetCPU_REGS->cpuad), pTargetCPU_REGS->cpuad
; 800  : 
; 801  :             ,psw[0], psw[1], psw[2],  psw[3]
; 802  :             ,psw[4], psw[5], psw[6],  psw[7]
; 803  :             ,psw[8], psw[9], psw[10], psw[11], psw[12], psw[13], psw[14], psw[15]
; 804  : 
; 805  :             ,CPUSTATE_STOPPED == pTargetCPU_REGS->cpustate ? 'M' : '.'
; 806  :             ,sysblk.instbreak                              ? 'T' : '.'
; 807  :             ,wait_bit                                      ? 'W' : '.'
; 808  :             ,pTargetCPU_REGS->loadstate                    ? 'L' : '.'
; 809  :             ,pTargetCPU_REGS->checkstop                    ? 'C' : '.'
; 810  :             ,PROBSTATE(&pTargetCPU_REGS->psw)              ? 'P' : '.'
; 811  :             ,
; 812  : #if        defined(_FEATURE_SIE)
; 813  :             SIE_MODE(pTargetCPU_REGS)                      ? 'S' : '.'
; 814  : #else  // !defined(_FEATURE_SIE)
; 815  :                                                                    '.'
; 816  : #endif //  defined(_FEATURE_SIE)
; 817  :             ,
; 818  : #if        defined(_900)
; 819  :             ARCH_900_IDX == pTargetCPU_REGS->arch_mode     ? 'Z' : '.'
; 820  : #else  // !defined(_900)
; 821  :                                                                    '.'
; 822  : #endif //  defined(_900)
; 823  :             ,curr_instcount
; 824  :         );
; 825  : 
; 826  :     } // endif cpu is online/offline
; 827  : 
; 828  :     // MIPS rate and SIOS rate...
; 829  :     {
; 830  :         U32* mipsrate;
; 831  :         U32* siosrate;
; 832  : 
; 833  :         if (gui_wants_aggregates)

  004f0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_aggregates
  004f7	85 c0		 test	 eax, eax
  004f9	74 2c		 je	 SHORT $LN5@UpdateCPUS

; 834  :         {
; 835  :             mipsrate = &sysblk.mipsrate;

  004fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00502	48 05 88 14 00
	00		 add	 rax, 5256		; 00001488H
  00508	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR mipsrate$1[rsp], rax

; 836  :             siosrate = &sysblk.siosrate;

  00510	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00517	48 05 8c 14 00
	00		 add	 rax, 5260		; 0000148cH
  0051d	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR siosrate$2[rsp], rax

; 837  :         }

  00525	eb 2a		 jmp	 SHORT $LN6@UpdateCPUS
$LN5@UpdateCPUS:

; 838  :         else
; 839  :         {
; 840  :             mipsrate = &pTargetCPU_REGS->mipsrate;

  00527	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0052e	48 05 9c 07 00
	00		 add	 rax, 1948		; 0000079cH
  00534	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR mipsrate$1[rsp], rax

; 841  :             siosrate = &pTargetCPU_REGS->siosrate;

  0053c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00543	48 05 a4 07 00
	00		 add	 rax, 1956		; 000007a4H
  00549	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR siosrate$2[rsp], rax
$LN6@UpdateCPUS:

; 842  :         }
; 843  : 
; 844  :         if (*mipsrate != prev_mips_rate)

  00551	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR mipsrate$1[rsp]
  00559	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR prev_mips_rate
  0055f	39 08		 cmp	 DWORD PTR [rax], ecx
  00561	74 68		 je	 SHORT $LN7@UpdateCPUS

; 845  :         {
; 846  :             gui_fprintf( fStatusStream,

  00563	33 d2		 xor	 edx, edx
  00565	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR mipsrate$1[rsp]
  0056d	8b 00		 mov	 eax, DWORD PTR [rax]
  0056f	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00574	f7 f1		 div	 ecx
  00576	8b c2		 mov	 eax, edx
  00578	33 d2		 xor	 edx, edx
  0057a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0057f	f7 f1		 div	 ecx
  00581	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv241[rsp], eax
  00588	33 d2		 xor	 edx, edx
  0058a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR mipsrate$1[rsp]
  00592	8b 01		 mov	 eax, DWORD PTR [rcx]
  00594	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00599	f7 f1		 div	 ecx
  0059b	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv241[rsp]
  005a2	44 8b c9	 mov	 r9d, ecx
  005a5	44 8b c0	 mov	 r8d, eax
  005a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168385
  005af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  005b6	e8 00 00 00 00	 call	 gui_fprintf

; 847  : 
; 848  :                 "MIPS=%4d.%2.2d\n"
; 849  : 
; 850  :                 , *mipsrate / 1000000
; 851  :                 ,(*mipsrate % 1000000) / 10000
; 852  :             );
; 853  : 
; 854  :             prev_mips_rate = *mipsrate;

  005bb	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR mipsrate$1[rsp]
  005c3	8b 00		 mov	 eax, DWORD PTR [rax]
  005c5	89 05 00 00 00
	00		 mov	 DWORD PTR prev_mips_rate, eax
$LN7@UpdateCPUS:

; 855  :         }
; 856  : 
; 857  :         if (*siosrate != prev_sios_rate)

  005cb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR siosrate$2[rsp]
  005d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR prev_sios_rate
  005d9	39 08		 cmp	 DWORD PTR [rax], ecx
  005db	74 2e		 je	 SHORT $LN8@UpdateCPUS

; 858  :         {
; 859  :             gui_fprintf( fStatusStream,

  005dd	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR siosrate$2[rsp]
  005e5	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  005e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168387
  005ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  005f6	e8 00 00 00 00	 call	 gui_fprintf

; 860  : 
; 861  :                 "SIOS=%4d\n"
; 862  : 
; 863  :                 ,*siosrate
; 864  :             );
; 865  : 
; 866  :             prev_sios_rate = *siosrate;

  005fb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR siosrate$2[rsp]
  00603	8b 00		 mov	 eax, DWORD PTR [rax]
  00605	89 05 00 00 00
	00		 mov	 DWORD PTR prev_sios_rate, eax
$LN8@UpdateCPUS:
$LN1@UpdateCPUS:

; 867  :         }
; 868  :     }
; 869  : }

  0060b	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  00612	41 5f		 pop	 r15
  00614	41 5e		 pop	 r14
  00616	41 5d		 pop	 r13
  00618	41 5c		 pop	 r12
  0061a	5f		 pop	 rdi
  0061b	5e		 pop	 rsi
  0061c	5d		 pop	 rbp
  0061d	5b		 pop	 rbx
  0061e	c3		 ret	 0
UpdateCPUStatus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
HandleForcedRefresh PROC

; 732  : {

$LN3:
  00000	40 57		 push	 rdi

; 733  :     prev_mips_rate          = INT_MAX;

  00002	c7 05 00 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR prev_mips_rate, 2147483647 ; 7fffffffH

; 734  :     prev_sios_rate          = INT_MAX;

  0000c	c7 05 00 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR prev_sios_rate, 2147483647 ; 7fffffffH

; 735  :     prev_instcount          = ULLONG_MAX;

  00016	48 c7 05 00 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR prev_instcount, -1

; 736  :     prev_pcpu               = INT_MAX;

  00021	c7 05 00 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR prev_pcpu, 2147483647 ; 7fffffffH

; 737  :     pPrevTargetCPU_REGS     = NULL;

  0002b	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR pPrevTargetCPU_REGS, 0

; 738  :     prev_cpustate           = 0xFF;

  00036	c6 05 00 00 00
	00 ff		 mov	 BYTE PTR prev_cpustate, 255 ; 000000ffH

; 739  :     memset( prev_psw,         0xFF,  sizeof(prev_psw) );

  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:prev_psw
  00044	48 8b f8	 mov	 rdi, rax
  00047	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0004c	b9 10 00 00 00	 mov	 ecx, 16
  00051	f3 aa		 rep stosb

; 740  : 
; 741  :     memset(   &prev_gr   [0], 0xFF,

  00053	b8 04 00 00 00	 mov	 eax, 4
  00058	48 6b c0 00	 imul	 rax, rax, 0
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr
  00063	48 03 c8	 add	 rcx, rax
  00066	48 8b c1	 mov	 rax, rcx
  00069	48 8b f8	 mov	 rdi, rax
  0006c	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00071	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00076	f3 aa		 rep stosb

; 742  :         sizeof(prev_gr) );
; 743  : 
; 744  :     memset(   &prev_cr   [0], 0xFF,

  00078	b8 04 00 00 00	 mov	 eax, 4
  0007d	48 6b c0 00	 imul	 rax, rax, 0
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 8b f8	 mov	 rdi, rax
  00091	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00096	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0009b	f3 aa		 rep stosb

; 745  :         sizeof(prev_cr) );
; 746  : 
; 747  :     memset(   &prev_ar   [0], 0xFF,

  0009d	b8 04 00 00 00	 mov	 eax, 4
  000a2	48 6b c0 00	 imul	 rax, rax, 0
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_ar
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 8b f8	 mov	 rdi, rax
  000b6	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000bb	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000c0	f3 aa		 rep stosb

; 748  :         sizeof(prev_ar) );
; 749  : 
; 750  :     memset(   &prev_fpr  [0], 0xFF,

  000c2	b8 04 00 00 00	 mov	 eax, 4
  000c7	48 6b c0 00	 imul	 rax, rax, 0
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr
  000d2	48 03 c8	 add	 rcx, rax
  000d5	48 8b c1	 mov	 rax, rcx
  000d8	48 8b f8	 mov	 rdi, rax
  000db	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000e0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000e5	f3 aa		 rep stosb

; 751  :         sizeof(prev_fpr) );
; 752  : 
; 753  :     memset(   &prev_gr64 [0], 0xFF,

  000e7	b8 08 00 00 00	 mov	 eax, 8
  000ec	48 6b c0 00	 imul	 rax, rax, 0
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_gr64
  000f7	48 03 c8	 add	 rcx, rax
  000fa	48 8b c1	 mov	 rax, rcx
  000fd	48 8b f8	 mov	 rdi, rax
  00100	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00105	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0010a	f3 aa		 rep stosb

; 754  :         sizeof(prev_gr64) );
; 755  : 
; 756  :     memset(   &prev_cr64 [0], 0xFF,

  0010c	b8 08 00 00 00	 mov	 eax, 8
  00111	48 6b c0 00	 imul	 rax, rax, 0
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cr64
  0011c	48 03 c8	 add	 rcx, rax
  0011f	48 8b c1	 mov	 rax, rcx
  00122	48 8b f8	 mov	 rdi, rax
  00125	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0012a	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0012f	f3 aa		 rep stosb

; 757  :         sizeof(prev_cr64) );
; 758  : 
; 759  :     memset(   &prev_fpr64[0], 0xFF,

  00131	b8 04 00 00 00	 mov	 eax, 4
  00136	48 6b c0 00	 imul	 rax, rax, 0
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_fpr64
  00141	48 03 c8	 add	 rcx, rax
  00144	48 8b c1	 mov	 rax, rcx
  00147	48 8b f8	 mov	 rdi, rax
  0014a	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0014f	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00154	f3 aa		 rep stosb

; 760  :         sizeof(prev_fpr64) );
; 761  : 
; 762  :     memset(   &prev_cpupct   [0], 0xFF,

  00156	b8 04 00 00 00	 mov	 eax, 4
  0015b	48 6b c0 00	 imul	 rax, rax, 0
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cpupct
  00166	48 03 c8	 add	 rcx, rax
  00169	48 8b c1	 mov	 rax, rcx
  0016c	48 8b f8	 mov	 rdi, rax
  0016f	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00174	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00179	f3 aa		 rep stosb

; 763  :         sizeof(prev_cpupct   ) );
; 764  : }

  0017b	5f		 pop	 rdi
  0017c	c3		 ret	 0
HandleForcedRefresh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
i$1 = 32
cpu$2 = 36
cpupct$3 = 40
started$4 = 44
cpupct$5 = 48
bStatusChanged$ = 52
tv84 = 56
tv149 = 60
tv200 = 64
UpdateStatus PROC

; 577  : {

$LN33:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 578  :     BOOL  bStatusChanged = FALSE;   // (whether or not anything has changed)

  00007	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR bStatusChanged$[rsp], 0

; 579  : 
; 580  :     if (sysblk.shutdown) return;

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0001c	c1 e8 0b	 shr	 eax, 11
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 05		 je	 SHORT $LN8@UpdateStat
  00026	e9 15 04 00 00	 jmp	 $LN1@UpdateStat
$LN8@UpdateStat:

; 581  : 
; 582  :     copy_psw(pTargetCPU_REGS, psw);

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:psw
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pTargetCPU_REGS
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_copy_psw

; 583  :     wait_bit = (psw[1] & 0x02);

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	48 6b c0 01	 imul	 rax, rax, 1
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psw
  0004f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00053	83 e0 02	 and	 eax, 2
  00056	88 05 00 00 00
	00		 mov	 BYTE PTR wait_bit, al

; 584  : 
; 585  :     // The SYS light and %CPU-Utilization
; 586  :     // information we send *ALL* the time...
; 587  : 
; 588  :     if (!(0

  0005c	33 c0		 xor	 eax, eax
  0005e	85 c0		 test	 eax, eax
  00060	75 55		 jne	 SHORT $LN9@UpdateStat
  00062	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00069	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0006d	83 f8 02	 cmp	 eax, 2
  00070	74 45		 je	 SHORT $LN9@UpdateStat
  00072	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  00079	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0007d	83 f8 03	 cmp	 eax, 3
  00080	74 35		 je	 SHORT $LN9@UpdateStat

; 589  :         || CPUSTATE_STOPPING == pTargetCPU_REGS->cpustate
; 590  :         || CPUSTATE_STOPPED  == pTargetCPU_REGS->cpustate
; 591  :     ))
; 592  :     {
; 593  :         gui_fprintf(fStatusStream,

  00082	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR wait_bit
  00089	85 c0		 test	 eax, eax
  0008b	74 0a		 je	 SHORT $LN27@UpdateStat
  0008d	c7 44 24 38 30
	00 00 00	 mov	 DWORD PTR tv84[rsp], 48	; 00000030H
  00095	eb 08		 jmp	 SHORT $LN28@UpdateStat
$LN27@UpdateStat:
  00097	c7 44 24 38 31
	00 00 00	 mov	 DWORD PTR tv84[rsp], 49	; 00000031H
$LN28@UpdateStat:
  0009f	44 8b 44 24 38	 mov	 r8d, DWORD PTR tv84[rsp]
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168351
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  000b2	e8 00 00 00 00	 call	 gui_fprintf
$LN9@UpdateStat:

; 594  : 
; 595  :             "SYS=%c\n"
; 596  : 
; 597  :             ,wait_bit ? '0' : '1'
; 598  :         );
; 599  :     }
; 600  : 
; 601  :     if (gui_wants_cpupct)

  000b7	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_cpupct
  000be	85 c0		 test	 eax, eax
  000c0	0f 84 17 01 00
	00		 je	 $LN10@UpdateStat

; 602  :     {
; 603  :         if (gui_wants_aggregates)

  000c6	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_aggregates
  000cd	85 c0		 test	 eax, eax
  000cf	0f 84 e7 00 00
	00		 je	 $LN11@UpdateStat

; 604  :         {
; 605  :             int cpu, cpupct = 0, started = 0;

  000d5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR cpupct$3[rsp], 0
  000dd	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR started$4[rsp], 0

; 606  :             for (cpupct=0, cpu=0; cpu < sysblk.maxcpu; cpu++)

  000e5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR cpupct$3[rsp], 0
  000ed	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR cpu$2[rsp], 0
  000f5	eb 0a		 jmp	 SHORT $LN4@UpdateStat
$LN2@UpdateStat:
  000f7	8b 44 24 24	 mov	 eax, DWORD PTR cpu$2[rsp]
  000fb	ff c0		 inc	 eax
  000fd	89 44 24 24	 mov	 DWORD PTR cpu$2[rsp], eax
$LN4@UpdateStat:
  00101	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00108	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0010e	39 44 24 24	 cmp	 DWORD PTR cpu$2[rsp], eax
  00112	7d 70		 jge	 SHORT $LN3@UpdateStat

; 607  :             {
; 608  :                 if (1
; 609  :                     && IS_CPU_ONLINE( cpu )
; 610  :                     && CPUSTATE_STARTED == sysblk.regs[ cpu ]->cpustate

  00114	33 c0		 xor	 eax, eax
  00116	83 f8 01	 cmp	 eax, 1
  00119	74 64		 je	 SHORT $LN13@UpdateStat
  0011b	48 63 44 24 24	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  00120	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00127	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00130	74 4d		 je	 SHORT $LN13@UpdateStat
  00132	48 63 44 24 24	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  00137	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0013e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00146	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0014a	83 f8 01	 cmp	 eax, 1
  0014d	75 30		 jne	 SHORT $LN13@UpdateStat

; 611  :                 )
; 612  :                 {
; 613  :                     started++;

  0014f	8b 44 24 2c	 mov	 eax, DWORD PTR started$4[rsp]
  00153	ff c0		 inc	 eax
  00155	89 44 24 2c	 mov	 DWORD PTR started$4[rsp], eax

; 614  :                     cpupct += sysblk.regs[ cpu ]->cpupct;

  00159	48 63 44 24 24	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00165	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0016d	8b 80 b0 07 00
	00		 mov	 eax, DWORD PTR [rax+1968]
  00173	8b 4c 24 28	 mov	 ecx, DWORD PTR cpupct$3[rsp]
  00177	03 c8		 add	 ecx, eax
  00179	8b c1		 mov	 eax, ecx
  0017b	89 44 24 28	 mov	 DWORD PTR cpupct$3[rsp], eax
$LN13@UpdateStat:

; 615  :                 }
; 616  :             }

  0017f	e9 73 ff ff ff	 jmp	 $LN2@UpdateStat
$LN3@UpdateStat:

; 617  :             gui_fprintf(fStatusStream,

  00184	83 7c 24 2c 00	 cmp	 DWORD PTR started$4[rsp], 0
  00189	74 0f		 je	 SHORT $LN29@UpdateStat
  0018b	8b 44 24 28	 mov	 eax, DWORD PTR cpupct$3[rsp]
  0018f	99		 cdq
  00190	f7 7c 24 2c	 idiv	 DWORD PTR started$4[rsp]
  00194	89 44 24 3c	 mov	 DWORD PTR tv149[rsp], eax
  00198	eb 08		 jmp	 SHORT $LN30@UpdateStat
$LN29@UpdateStat:
  0019a	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN30@UpdateStat:
  001a2	44 8b 44 24 3c	 mov	 r8d, DWORD PTR tv149[rsp]
  001a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168356
  001ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  001b5	e8 00 00 00 00	 call	 gui_fprintf

; 618  : 
; 619  :                 "CPUPCT=%d\n"
; 620  : 
; 621  :                 ,started ? (cpupct / started) : 0
; 622  :             );
; 623  :         }

  001ba	eb 21		 jmp	 SHORT $LN12@UpdateStat
$LN11@UpdateStat:

; 624  :         else
; 625  :         {
; 626  :             gui_fprintf(fStatusStream,

  001bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  001c3	44 8b 80 b0 07
	00 00		 mov	 r8d, DWORD PTR [rax+1968]
  001ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168357
  001d1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  001d8	e8 00 00 00 00	 call	 gui_fprintf
$LN12@UpdateStat:
$LN10@UpdateStat:

; 627  : 
; 628  :                 "CPUPCT=%d\n"
; 629  : 
; 630  :                 ,pTargetCPU_REGS->cpupct
; 631  :             );
; 632  :         }
; 633  :     }
; 634  :     if (gui_wants_cpupct_all)

  001dd	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_cpupct_all
  001e4	85 c0		 test	 eax, eax
  001e6	0f 84 d7 00 00
	00		 je	 $LN14@UpdateStat

; 635  :     {
; 636  :         int  i, cpupct;
; 637  : 
; 638  :         for (i = 0; i < sysblk.hicpu; i++)

  001ec	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  001f4	eb 0a		 jmp	 SHORT $LN7@UpdateStat
$LN5@UpdateStat:
  001f6	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  001fa	ff c0		 inc	 eax
  001fc	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@UpdateStat:
  00200	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00207	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  0020d	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00211	0f 8d ac 00 00
	00		 jge	 $LN6@UpdateStat

; 639  :         {
; 640  :             if (0
; 641  :                 || !IS_CPU_ONLINE(i)
; 642  :                 || CPUSTATE_STARTED != sysblk.regs[i]->cpustate

  00217	33 c0		 xor	 eax, eax
  00219	85 c0		 test	 eax, eax
  0021b	75 34		 jne	 SHORT $LN17@UpdateStat
  0021d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00222	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00229	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00232	74 1d		 je	 SHORT $LN17@UpdateStat
  00234	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00239	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00240	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00248	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0024c	83 f8 01	 cmp	 eax, 1
  0024f	74 0a		 je	 SHORT $LN15@UpdateStat
$LN17@UpdateStat:

; 643  :             )
; 644  :                 cpupct = 0;

  00251	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR cpupct$5[rsp], 0
  00259	eb 1e		 jmp	 SHORT $LN16@UpdateStat
$LN15@UpdateStat:

; 645  :             else
; 646  :                 cpupct = sysblk.regs[i]->cpupct;

  0025b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00260	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00267	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0026f	8b 80 b0 07 00
	00		 mov	 eax, DWORD PTR [rax+1968]
  00275	89 44 24 30	 mov	 DWORD PTR cpupct$5[rsp], eax
$LN16@UpdateStat:

; 647  : 
; 648  :             if (cpupct != prev_cpupct[i])

  00279	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0027e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cpupct
  00285	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00288	39 44 24 30	 cmp	 DWORD PTR cpupct$5[rsp], eax
  0028c	74 30		 je	 SHORT $LN18@UpdateStat

; 649  :             {
; 650  :                 prev_cpupct[i] = cpupct;

  0028e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00293	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cpupct
  0029a	8b 54 24 30	 mov	 edx, DWORD PTR cpupct$5[rsp]
  0029e	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 651  :                 gui_fprintf( fStatusStream, "CPUPCT%02d=%d\n", i, cpupct );

  002a1	44 8b 4c 24 30	 mov	 r9d, DWORD PTR cpupct$5[rsp]
  002a6	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$1[rsp]
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168363
  002b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  002b9	e8 00 00 00 00	 call	 gui_fprintf
$LN18@UpdateStat:

; 652  :             }
; 653  :         }

  002be	e9 33 ff ff ff	 jmp	 $LN5@UpdateStat
$LN6@UpdateStat:
$LN14@UpdateStat:

; 654  :     }
; 655  : 
; 656  :     // Determine if we need to inform the GUI of anything...
; 657  : 
; 658  :     bStatusChanged = FALSE;   // (whether or not anything has changed)

  002c3	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR bStatusChanged$[rsp], 0

; 659  : 
; 660  :     curr_instcount = gui_wants_aggregates ?

  002cb	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_aggregates
  002d2	85 c0		 test	 eax, eax
  002d4	74 15		 je	 SHORT $LN31@UpdateStat
  002d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002dd	48 8b 80 80 14
	00 00		 mov	 rax, QWORD PTR [rax+5248]
  002e4	48 89 44 24 40	 mov	 QWORD PTR tv200[rsp], rax
  002e9	eb 31		 jmp	 SHORT $LN32@UpdateStat
$LN31@UpdateStat:
  002eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  002f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  002f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pTargetCPU_REGS
  00300	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00307	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  0030d	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  00314	48 8b c1	 mov	 rax, rcx
  00317	48 89 44 24 40	 mov	 QWORD PTR tv200[rsp], rax
$LN32@UpdateStat:
  0031c	48 8b 44 24 40	 mov	 rax, QWORD PTR tv200[rsp]
  00321	48 89 05 00 00
	00 00		 mov	 QWORD PTR curr_instcount, rax

; 661  :         sysblk.instcount : INSTCOUNT( pTargetCPU_REGS );
; 662  : 
; 663  :     if (0
; 664  :         || gui_forced_refresh
; 665  :         || pTargetCPU_REGS           != pPrevTargetCPU_REGS
; 666  :         || pcpu                      != prev_pcpu
; 667  :         || curr_instcount            != prev_instcount
; 668  :         || pTargetCPU_REGS->cpustate != prev_cpustate
; 669  :         || memcmp( prev_psw, psw, sizeof( prev_psw )) != 0

  00328	33 c0		 xor	 eax, eax
  0032a	85 c0		 test	 eax, eax
  0032c	75 6c		 jne	 SHORT $LN20@UpdateStat
  0032e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_forced_refresh
  00335	85 c0		 test	 eax, eax
  00337	75 61		 jne	 SHORT $LN20@UpdateStat
  00339	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pPrevTargetCPU_REGS
  00340	48 39 05 00 00
	00 00		 cmp	 QWORD PTR pTargetCPU_REGS, rax
  00347	75 51		 jne	 SHORT $LN20@UpdateStat
  00349	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR prev_pcpu
  0034f	39 05 00 00 00
	00		 cmp	 DWORD PTR pcpu, eax
  00355	75 43		 jne	 SHORT $LN20@UpdateStat
  00357	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR prev_instcount
  0035e	48 39 05 00 00
	00 00		 cmp	 QWORD PTR curr_instcount, rax
  00365	75 33		 jne	 SHORT $LN20@UpdateStat
  00367	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  0036e	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00372	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR prev_cpustate
  00379	3b c1		 cmp	 eax, ecx
  0037b	75 1d		 jne	 SHORT $LN20@UpdateStat
  0037d	41 b8 10 00 00
	00		 mov	 r8d, 16
  00383	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:psw
  0038a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_psw
  00391	e8 00 00 00 00	 call	 memcmp
  00396	85 c0		 test	 eax, eax
  00398	74 6c		 je	 SHORT $LN19@UpdateStat
$LN20@UpdateStat:

; 670  :     )
; 671  :     {
; 672  :         bStatusChanged = TRUE;          // (something has indeed changed...)

  0039a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR bStatusChanged$[rsp], 1

; 673  : 
; 674  :         if (gui_forced_refresh)         // (forced refresh?)

  003a2	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_forced_refresh
  003a9	85 c0		 test	 eax, eax
  003ab	74 05		 je	 SHORT $LN21@UpdateStat

; 675  :             HandleForcedRefresh();      // (reset all prev values)

  003ad	e8 00 00 00 00	 call	 HandleForcedRefresh
$LN21@UpdateStat:

; 676  : 
; 677  :         // Save new values for next time...
; 678  : 
; 679  :         pPrevTargetCPU_REGS = pTargetCPU_REGS;

  003b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  003b9	48 89 05 00 00
	00 00		 mov	 QWORD PTR pPrevTargetCPU_REGS, rax

; 680  :         prev_cpustate       = pTargetCPU_REGS->cpustate;

  003c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  003c7	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  003cb	88 05 00 00 00
	00		 mov	 BYTE PTR prev_cpustate, al

; 681  :         prev_instcount      = curr_instcount;

  003d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curr_instcount
  003d8	48 89 05 00 00
	00 00		 mov	 QWORD PTR prev_instcount, rax

; 682  :         prev_pcpu           = pcpu;

  003df	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pcpu
  003e5	89 05 00 00 00
	00		 mov	 DWORD PTR prev_pcpu, eax

; 683  :         memcpy( prev_psw, psw, sizeof( prev_psw ));

  003eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:prev_psw
  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psw
  003f9	48 8b f8	 mov	 rdi, rax
  003fc	48 8b f1	 mov	 rsi, rcx
  003ff	b9 10 00 00 00	 mov	 ecx, 16
  00404	f3 a4		 rep movsb
$LN19@UpdateStat:

; 684  :     }
; 685  : 
; 686  :     // If anything has changed, inform the GUI...
; 687  : 
; 688  :     if (bStatusChanged)

  00406	83 7c 24 34 00	 cmp	 DWORD PTR bStatusChanged$[rsp], 0
  0040b	74 0a		 je	 SHORT $LN22@UpdateStat

; 689  :     {
; 690  :         UpdateCPUStatus();      // (update the status line info...)

  0040d	e8 00 00 00 00	 call	 UpdateCPUStatus

; 691  :         UpdateRegisters();      // (update the registers display...)

  00412	e8 00 00 00 00	 call	 UpdateRegisters
$LN22@UpdateStat:

; 692  :     }
; 693  : 
; 694  :     // PROGRAMMING NOTE: my original [rather poorly designed I admit] logic
; 695  :     // sent device status messages to the GUI *continuously* (i.e. all the
; 696  :     // time), even when both Herc and the channel subsystem was idle. This
; 697  :     // proved to be terribly inefficient, causing the GUI to consume *FAR*
; 698  :     // too much valuable CPU cycles parsing all of those messages.
; 699  : 
; 700  :     // Thus, starting with this version of dyngui, we now only send device
; 701  :     // status messages to the GUI only whenever the device's status actually
; 702  :     // changes, but only if it (the GUI) specifically requests such notifi-
; 703  :     // cations of course (via the new "]NEWDEVLIST=" special message).
; 704  : 
; 705  :     // The new(er) version of HercGUI understands (and thus requests) these
; 706  :     // newer format device status messages, but older versions of HercGUI
; 707  :     // of course do not. Thus in order to remain compatible with the current
; 708  :     // (older) version of the GUI, we still need to support the inefficient
; 709  :     // technique of constantly sending a constant stream of device status
; 710  :     // messages.
; 711  : 
; 712  :     // Eventually at some point this existing original inefficient technique
; 713  :     // logic will be removed (once everyone has had time to upgrade to the
; 714  :     // newer version of HercGUI), but for now, at least for the next couple
; 715  :     // of HercGUI release cycles, we need to keep it.
; 716  : 
; 717  :     if (gui_wants_devlist)      // (if the device list is visible)

  00417	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_devlist
  0041e	85 c0		 test	 eax, eax
  00420	74 07		 je	 SHORT $LN23@UpdateStat

; 718  :         UpdateDeviceStatus();   // (update the list of devices...)

  00422	e8 00 00 00 00	 call	 UpdateDeviceStatus
  00427	eb 10		 jmp	 SHORT $LN24@UpdateStat
$LN23@UpdateStat:

; 719  : 
; 720  :     else // (the two options are mutually exclusive from one another)
; 721  : 
; 722  :     if (gui_wants_new_devlist)  // (if the device list is visible)

  00429	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_new_devlist
  00430	85 c0		 test	 eax, eax
  00432	74 05		 je	 SHORT $LN25@UpdateStat

; 723  :         NewUpdateDevStats();    // (update the list of devices...)

  00434	e8 00 00 00 00	 call	 NewUpdateDevStats
$LN25@UpdateStat:
$LN24@UpdateStat:

; 724  : 
; 725  :     gui_forced_refresh  = 0;    // (reset switch; must follow devlist update)

  00439	c6 05 00 00 00
	00 00		 mov	 BYTE PTR gui_forced_refresh, 0
$LN1@UpdateStat:

; 726  : }

  00440	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00444	5f		 pop	 rdi
  00445	5e		 pop	 rsi
  00446	c3		 ret	 0
UpdateStatus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
cwd$1 = 48
next_panel_command_handler$ = 56
buffer$2 = 64
__$ArrayPad$ = 128
pszCommand$ = 160
gui_panel_command PROC

; 351  : {

$LN43:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 352  :     void* (*next_panel_command_handler)(char* pszCommand);
; 353  : 
; 354  :     // Special GUI commands start with ']'. At the moment, all these special
; 355  :     // gui commands tell us is what status information it's interested in...
; 356  : 
; 357  :     if ( ']' != *pszCommand )

  0001f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  00027	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002a	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  0002d	74 05		 je	 SHORT $LN14@gui_panel_

; 358  :         goto NotSpecialGUICommand;

  0002f	e9 28 06 00 00	 jmp	 $NotSpecialGUICommand$44
$LN14@gui_panel_:

; 359  : 
; 360  :     gui_forced_refresh = 1;                         // (forced update refresh)

  00034	c6 05 00 00 00
	00 01		 mov	 BYTE PTR gui_forced_refresh, 1

; 361  : 
; 362  :     pszCommand++;                                   // (bump past ']')

  0003b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  00043	48 ff c0	 inc	 rax
  00046	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pszCommand$[rsp], rax

; 363  : 
; 364  :     if (strncasecmp(pszCommand,"VERS=",5) == 0)

  0004e	41 b8 05 00 00
	00		 mov	 r8d, 5
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168265
  0005b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00069	85 c0		 test	 eax, eax
  0006b	75 24		 jne	 SHORT $LN15@gui_panel_

; 365  :     {
; 366  :         gui_version = atof(pszCommand+5);

  0006d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  00075	48 83 c0 05	 add	 rax, 5
  00079	48 8b c8	 mov	 rcx, rax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atof
  00082	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR gui_version, xmm0

; 367  :         return NULL;

  0008a	33 c0		 xor	 eax, eax
  0008c	e9 fa 05 00 00	 jmp	 $LN1@gui_panel_
$LN15@gui_panel_:

; 368  :     }
; 369  : 
; 370  :     if (strncasecmp(pszCommand,"SCD=",4) == 0)

  00091	41 b8 04 00 00
	00		 mov	 r8d, 4
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168267
  0009e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000ac	85 c0		 test	 eax, eax
  000ae	75 50		 jne	 SHORT $LN16@gui_panel_

; 371  :     {
; 372  :         // (set current directory)
; 373  :         if (chdir(pszCommand+4) != 0)

  000b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  000b8	48 83 c0 04	 add	 rax, 4
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_chdir
  000c5	85 c0		 test	 eax, eax
  000c7	74 30		 je	 SHORT $LN17@gui_panel_

; 374  :         {
; 375  :             // (inform gui of error)
; 376  :             char *cwd = getcwd( NULL, 0 );

  000c9	33 d2		 xor	 edx, edx
  000cb	33 c9		 xor	 ecx, ecx
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getcwd
  000d3	48 89 44 24 30	 mov	 QWORD PTR cwd$1[rsp], rax

; 377  :             if (cwd)

  000d8	48 83 7c 24 30
	00		 cmp	 QWORD PTR cwd$1[rsp], 0
  000de	74 19		 je	 SHORT $LN18@gui_panel_

; 378  :             {
; 379  :                 debug_cd_cmd( cwd );

  000e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cwd$1[rsp]
  000e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cd_cmd
  000ec	ff 10		 call	 QWORD PTR [rax]

; 380  :                 free( cwd );

  000ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cwd$1[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN18@gui_panel_:
$LN17@gui_panel_:

; 381  :             }
; 382  :         }
; 383  :         return NULL;

  000f9	33 c0		 xor	 eax, eax
  000fb	e9 8b 05 00 00	 jmp	 $LN1@gui_panel_
$LN16@gui_panel_:

; 384  :     }
; 385  : 
; 386  :     if (strncasecmp(pszCommand,"GREGS=",6) == 0)

  00100	41 b8 06 00 00
	00		 mov	 r8d, 6
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168271
  0010d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0011b	85 c0		 test	 eax, eax
  0011d	75 22		 jne	 SHORT $LN19@gui_panel_

; 387  :     {
; 388  :         gui_wants_gregs = atoi(pszCommand+6);

  0011f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  00127	48 83 c0 06	 add	 rax, 6
  0012b	48 8b c8	 mov	 rcx, rax
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00134	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_gregs, al

; 389  :         return NULL;

  0013a	33 c0		 xor	 eax, eax
  0013c	e9 4a 05 00 00	 jmp	 $LN1@gui_panel_
$LN19@gui_panel_:

; 390  :     }
; 391  : 
; 392  :     if (strncasecmp(pszCommand,"GREGS64=",8) == 0)

  00141	41 b8 08 00 00
	00		 mov	 r8d, 8
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168273
  0014e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0015c	85 c0		 test	 eax, eax
  0015e	75 22		 jne	 SHORT $LN20@gui_panel_

; 393  :     {
; 394  :         gui_wants_gregs64 = atoi(pszCommand+8);

  00160	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  00168	48 83 c0 08	 add	 rax, 8
  0016c	48 8b c8	 mov	 rcx, rax
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00175	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_gregs64, al

; 395  :         return NULL;

  0017b	33 c0		 xor	 eax, eax
  0017d	e9 09 05 00 00	 jmp	 $LN1@gui_panel_
$LN20@gui_panel_:

; 396  :     }
; 397  : 
; 398  :     if (strncasecmp(pszCommand,"CREGS=",6) == 0)

  00182	41 b8 06 00 00
	00		 mov	 r8d, 6
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168275
  0018f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0019d	85 c0		 test	 eax, eax
  0019f	75 22		 jne	 SHORT $LN21@gui_panel_

; 399  :     {
; 400  :         gui_wants_cregs = atoi(pszCommand+6);

  001a1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  001a9	48 83 c0 06	 add	 rax, 6
  001ad	48 8b c8	 mov	 rcx, rax
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  001b6	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_cregs, al

; 401  :         return NULL;

  001bc	33 c0		 xor	 eax, eax
  001be	e9 c8 04 00 00	 jmp	 $LN1@gui_panel_
$LN21@gui_panel_:

; 402  :     }
; 403  : 
; 404  :     if (strncasecmp(pszCommand,"CREGS64=",8) == 0)

  001c3	41 b8 08 00 00
	00		 mov	 r8d, 8
  001c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168277
  001d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  001de	85 c0		 test	 eax, eax
  001e0	75 22		 jne	 SHORT $LN22@gui_panel_

; 405  :     {
; 406  :         gui_wants_cregs64 = atoi(pszCommand+8);

  001e2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  001ea	48 83 c0 08	 add	 rax, 8
  001ee	48 8b c8	 mov	 rcx, rax
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  001f7	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_cregs64, al

; 407  :         return NULL;

  001fd	33 c0		 xor	 eax, eax
  001ff	e9 87 04 00 00	 jmp	 $LN1@gui_panel_
$LN22@gui_panel_:

; 408  :     }
; 409  : 
; 410  :     if (strncasecmp(pszCommand,"AREGS=",6) == 0)

  00204	41 b8 06 00 00
	00		 mov	 r8d, 6
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168279
  00211	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0021f	85 c0		 test	 eax, eax
  00221	75 22		 jne	 SHORT $LN23@gui_panel_

; 411  :     {
; 412  :         gui_wants_aregs = atoi(pszCommand+6);

  00223	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  0022b	48 83 c0 06	 add	 rax, 6
  0022f	48 8b c8	 mov	 rcx, rax
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00238	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_aregs, al

; 413  :         return NULL;

  0023e	33 c0		 xor	 eax, eax
  00240	e9 46 04 00 00	 jmp	 $LN1@gui_panel_
$LN23@gui_panel_:

; 414  :     }
; 415  : 
; 416  :     if (strncasecmp(pszCommand,"FREGS=",6) == 0)

  00245	41 b8 06 00 00
	00		 mov	 r8d, 6
  0024b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168281
  00252	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00260	85 c0		 test	 eax, eax
  00262	75 22		 jne	 SHORT $LN24@gui_panel_

; 417  :     {
; 418  :         gui_wants_fregs = atoi(pszCommand+6);

  00264	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  0026c	48 83 c0 06	 add	 rax, 6
  00270	48 8b c8	 mov	 rcx, rax
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00279	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_fregs, al

; 419  :         return NULL;

  0027f	33 c0		 xor	 eax, eax
  00281	e9 05 04 00 00	 jmp	 $LN1@gui_panel_
$LN24@gui_panel_:

; 420  :     }
; 421  : 
; 422  :     if (strncasecmp(pszCommand,"FREGS64=",8) == 0)

  00286	41 b8 08 00 00
	00		 mov	 r8d, 8
  0028c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168283
  00293	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  002a1	85 c0		 test	 eax, eax
  002a3	75 22		 jne	 SHORT $LN25@gui_panel_

; 423  :     {
; 424  :         gui_wants_fregs64 = atoi(pszCommand+8);

  002a5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  002ad	48 83 c0 08	 add	 rax, 8
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  002ba	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_fregs64, al

; 425  :         return NULL;

  002c0	33 c0		 xor	 eax, eax
  002c2	e9 c4 03 00 00	 jmp	 $LN1@gui_panel_
$LN25@gui_panel_:

; 426  :     }
; 427  : 
; 428  :     if (strncasecmp(pszCommand,"DEVLIST=",8) == 0)

  002c7	41 b8 08 00 00
	00		 mov	 r8d, 8
  002cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168285
  002d4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  002e2	85 c0		 test	 eax, eax
  002e4	75 34		 jne	 SHORT $LN26@gui_panel_

; 429  :     {
; 430  :         gui_wants_devlist = atoi(pszCommand+8);

  002e6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  002ee	48 83 c0 08	 add	 rax, 8
  002f2	48 8b c8	 mov	 rcx, rax
  002f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  002fb	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_devlist, al

; 431  :         if ( gui_wants_devlist )

  00301	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_devlist
  00308	85 c0		 test	 eax, eax
  0030a	74 07		 je	 SHORT $LN27@gui_panel_

; 432  :             gui_wants_new_devlist = 0;

  0030c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR gui_wants_new_devlist, 0
$LN27@gui_panel_:

; 433  :         return NULL;

  00313	33 c0		 xor	 eax, eax
  00315	e9 71 03 00 00	 jmp	 $LN1@gui_panel_
$LN26@gui_panel_:

; 434  :     }
; 435  : 
; 436  :     if (strncasecmp(pszCommand,"NEWDEVLIST=",11) == 0)

  0031a	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00320	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168288
  00327	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00335	85 c0		 test	 eax, eax
  00337	75 34		 jne	 SHORT $LN28@gui_panel_

; 437  :     {
; 438  :         gui_wants_new_devlist = atoi(pszCommand+11);

  00339	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  00341	48 83 c0 0b	 add	 rax, 11
  00345	48 8b c8	 mov	 rcx, rax
  00348	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0034e	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_new_devlist, al

; 439  :         if ( gui_wants_new_devlist )

  00354	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_new_devlist
  0035b	85 c0		 test	 eax, eax
  0035d	74 07		 je	 SHORT $LN29@gui_panel_

; 440  :             gui_wants_devlist = 0;

  0035f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR gui_wants_devlist, 0
$LN29@gui_panel_:

; 441  :         return NULL;

  00366	33 c0		 xor	 eax, eax
  00368	e9 1e 03 00 00	 jmp	 $LN1@gui_panel_
$LN28@gui_panel_:

; 442  :     }
; 443  : 
; 444  :     if (strncasecmp( pszCommand, "MAINSTOR=", 9 ) == 0)

  0036d	41 b8 09 00 00
	00		 mov	 r8d, 9
  00373	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168291
  0037a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00382	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00388	85 c0		 test	 eax, eax
  0038a	0f 85 d4 01 00
	00		 jne	 $LN30@gui_panel_

; 445  :     {
; 446  :         char buffer[64] = {0};

  00390	48 8d 44 24 40	 lea	 rax, QWORD PTR buffer$2[rsp]
  00395	48 8b f8	 mov	 rdi, rax
  00398	33 c0		 xor	 eax, eax
  0039a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0039f	f3 aa		 rep stosb

; 447  : 
; 448  :         MSGBUF( buffer, "%"PRIu64, (U64) pTargetCPU_REGS->mainstor );

  003a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pTargetCPU_REGS
  003a8	4c 8b 88 48 08
	00 00		 mov	 r9, QWORD PTR [rax+2120]
  003af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168292
  003b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  003bb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$2[rsp]
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN4@gui_panel_:

; 449  :         TRACE("**** sending: \"MAINSTOR=%s\"\n", buffer );

  003c6	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$2[rsp]
  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168293
  003d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  003d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003de	85 c0		 test	 eax, eax
  003e0	74 11		 je	 SHORT $LN31@gui_panel_
  003e2	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$2[rsp]
  003e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168295
  003ee	e8 00 00 00 00	 call	 DebuggerTrace
$LN31@gui_panel_:
  003f3	33 c0		 xor	 eax, eax
  003f5	85 c0		 test	 eax, eax
  003f7	75 cd		 jne	 SHORT $LN4@gui_panel_

; 450  :         gui_fprintf( fStatusStream, "MAINSTOR=%s\n", buffer );

  003f9	4c 8d 44 24 40	 lea	 r8, QWORD PTR buffer$2[rsp]
  003fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168296
  00405	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  0040c	e8 00 00 00 00	 call	 gui_fprintf

; 451  : 
; 452  :         // Here's a trick! Hercules reports its version number to the GUI
; 453  :         // by means of the MAINSIZE value! Later releases of HercGUI know
; 454  :         // to interpret mainsizes less than 1000 as Hercule's version number.
; 455  :         // Earlier versions of HercGUI will simply try to interpret it as
; 456  :         // the actual mainsize, but no real harm is done since we immediately
; 457  :         // send it the CORRECT mainsize immediately afterwards. This allows
; 458  :         // future versions of HercGUI to know which version of Hercules they
; 459  :         // are talking to and thus whether it supports a given feature or not.
; 460  : 
; 461  : #if defined( _MSVC_ )
; 462  : 
; 463  :         // PROGRAMMING NOTE: we use 'VERS_MAJ' and 'VERS_INT' here and NOT
; 464  :         // the VERSION string since the 'VERSION' string can be any value
; 465  :         // the user wants and thus might not be numeric nor even correspond
; 466  :         // at all to Hercules's actual build version.
; 467  :         //
; 468  :         // The VERS_MAJ and VERS_INT variables however are ALWAYS be numbers
; 469  :         // and thus should ALWAYS equal Hercules's actual build version. The
; 470  :         // makefile.bat file on Windows guarantees this and ensures neither
; 471  :         // has any leading zeroes (which would cause them to be intrepreted
; 472  :         // by the C compiler as invalid octal numbers for e.g. 3.08, etc).
; 473  : 
; 474  :         MSGBUF( buffer, "%u.%u", VERS_MAJ, VERS_INT );

  00411	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR [rsp+32], 6
  00419	41 b9 04 00 00
	00		 mov	 r9d, 4
  0041f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168297
  00426	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0042b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$2[rsp]
  00430	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN7@gui_panel_:

; 475  : #else
; 476  :         //  VERSION is set in configure.ac as x.xx. (why we insist on using
; 477  :         //  two digits for the second part is unclear) However, if 'xx' is
; 478  :         //  greater than '07' (as it would be for Hercules versions 3.08 and
; 479  :         //  3.09 for example) then printing VERS_INT with a %d format fails
; 480  :         //  with a compiler error about it being an invalid octal constant.
; 481  :         //
; 482  :         //  On Windows the makefile.bat build script used to build Hercules
; 483  :         //  with ensures this will never happen. On non-Windows platforms
; 484  :         //  however it could conceivably still happen, so for the time being
; 485  :         //  we have no choice but to use the full VERSION string instead and
; 486  :         //  hope all non-Windows GUIs will be able to properly parse it.
; 487  : 
; 488  :         MSGBUF( buffer, "%s", VERSION );
; 489  : #endif
; 490  :         TRACE("**** sending: \"MAINSIZE=%s\"\n", buffer );

  00436	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$2[rsp]
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168298
  00442	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00448	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0044e	85 c0		 test	 eax, eax
  00450	74 11		 je	 SHORT $LN32@gui_panel_
  00452	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$2[rsp]
  00457	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168300
  0045e	e8 00 00 00 00	 call	 DebuggerTrace
$LN32@gui_panel_:
  00463	33 c0		 xor	 eax, eax
  00465	85 c0		 test	 eax, eax
  00467	75 cd		 jne	 SHORT $LN7@gui_panel_

; 491  :         gui_fprintf( fStatusStream, "MAINSIZE=%s\n", buffer );

  00469	4c 8d 44 24 40	 lea	 r8, QWORD PTR buffer$2[rsp]
  0046e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168301
  00475	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  0047c	e8 00 00 00 00	 call	 gui_fprintf

; 492  : 
; 493  :         if (gui_version < 1.12)

  00481	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff1eb851eb851ec
  00489	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR gui_version
  00491	76 5a		 jbe	 SHORT $LN33@gui_panel_

; 494  :         {
; 495  :             // Older versions of HercGUI only support
; 496  :             // maximum 32-bit (4GB) mainsize values
; 497  : 
; 498  :             MSGBUF( buffer, "%"PRIu32, (U32) sysblk.mainsize );

  00493	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0049a	44 8b 88 90 00
	00 00		 mov	 r9d, DWORD PTR [rax+144]
  004a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168304
  004a8	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  004ad	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$2[rsp]
  004b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN10@gui_panel_:

; 499  :             TRACE("**** (gui_version < 1.12): sending: \"MAINSIZE=%s\"\n", buffer );

  004b8	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$2[rsp]
  004bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168305
  004c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  004ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004d0	85 c0		 test	 eax, eax
  004d2	74 11		 je	 SHORT $LN35@gui_panel_
  004d4	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$2[rsp]
  004d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168307
  004e0	e8 00 00 00 00	 call	 DebuggerTrace
$LN35@gui_panel_:
  004e5	33 c0		 xor	 eax, eax
  004e7	85 c0		 test	 eax, eax
  004e9	75 cd		 jne	 SHORT $LN10@gui_panel_

; 500  :         }

  004eb	eb 58		 jmp	 SHORT $LN34@gui_panel_
$LN33@gui_panel_:

; 501  :         else
; 502  :         {
; 503  :             // Newer versions of HercGUI now support
; 504  :             // up to 64-bit (8M TB) mainsize values
; 505  : 
; 506  :             MSGBUF( buffer, "%"PRIu64, (U64) sysblk.mainsize );

  004ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004f4	4c 8b 88 90 00
	00 00		 mov	 r9, QWORD PTR [rax+144]
  004fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168308
  00502	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00507	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$2[rsp]
  0050c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN13@gui_panel_:

; 507  :             TRACE("**** (gui_version >= 1.12): sending: \"MAINSIZE=%s\"\n", buffer );

  00512	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$2[rsp]
  00517	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168309
  0051e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00524	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0052a	85 c0		 test	 eax, eax
  0052c	74 11		 je	 SHORT $LN36@gui_panel_
  0052e	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$2[rsp]
  00533	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168311
  0053a	e8 00 00 00 00	 call	 DebuggerTrace
$LN36@gui_panel_:
  0053f	33 c0		 xor	 eax, eax
  00541	85 c0		 test	 eax, eax
  00543	75 cd		 jne	 SHORT $LN13@gui_panel_
$LN34@gui_panel_:

; 508  :         }
; 509  : 
; 510  :         gui_fprintf( fStatusStream, "MAINSIZE=%s\n", buffer );

  00545	4c 8d 44 24 40	 lea	 r8, QWORD PTR buffer$2[rsp]
  0054a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168312
  00551	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fStatusStream
  00558	e8 00 00 00 00	 call	 gui_fprintf

; 511  :         return NULL;

  0055d	33 c0		 xor	 eax, eax
  0055f	e9 27 01 00 00	 jmp	 $LN1@gui_panel_
$LN30@gui_panel_:

; 512  :     }
; 513  : 
; 514  :     if (strncasecmp(pszCommand,"CPUPCT=",7) == 0)

  00564	41 b8 07 00 00
	00		 mov	 r8d, 7
  0056a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168314
  00571	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00579	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0057f	85 c0		 test	 eax, eax
  00581	75 22		 jne	 SHORT $LN37@gui_panel_

; 515  :     {
; 516  :         gui_wants_cpupct = atoi(pszCommand+7);

  00583	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  0058b	48 83 c0 07	 add	 rax, 7
  0058f	48 8b c8	 mov	 rcx, rax
  00592	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00598	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_cpupct, al

; 517  :         return NULL;

  0059e	33 c0		 xor	 eax, eax
  005a0	e9 e6 00 00 00	 jmp	 $LN1@gui_panel_
$LN37@gui_panel_:

; 518  :     }
; 519  : 
; 520  :     if (strncasecmp(pszCommand,"CPUPCTALL=",10) == 0)

  005a5	41 b8 0a 00 00
	00		 mov	 r8d, 10
  005ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168316
  005b2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  005ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  005c0	85 c0		 test	 eax, eax
  005c2	75 4f		 jne	 SHORT $LN38@gui_panel_

; 521  :     {
; 522  :         if (!(gui_wants_cpupct_all = atoi(pszCommand+10)))

  005c4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  005cc	48 83 c0 0a	 add	 rax, 10
  005d0	48 8b c8	 mov	 rcx, rax
  005d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  005d9	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_cpupct_all, al
  005df	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR gui_wants_cpupct_all
  005e6	85 c0		 test	 eax, eax
  005e8	75 25		 jne	 SHORT $LN39@gui_panel_

; 523  :             memset( &prev_cpupct[0], 0xFF, sizeof(prev_cpupct) );

  005ea	b8 04 00 00 00	 mov	 eax, 4
  005ef	48 6b c0 00	 imul	 rax, rax, 0
  005f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prev_cpupct
  005fa	48 03 c8	 add	 rcx, rax
  005fd	48 8b c1	 mov	 rax, rcx
  00600	48 8b f8	 mov	 rdi, rax
  00603	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00608	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0060d	f3 aa		 rep stosb
$LN39@gui_panel_:

; 524  :         return NULL;

  0060f	33 c0		 xor	 eax, eax
  00611	eb 78		 jmp	 SHORT $LN1@gui_panel_
$LN38@gui_panel_:

; 525  :     }
; 526  : 
; 527  :     if (strncasecmp(pszCommand,"AGGREGATE=",10) == 0)

  00613	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00619	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168319
  00620	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00628	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0062e	85 c0		 test	 eax, eax
  00630	75 26		 jne	 SHORT $LN40@gui_panel_

; 528  :     {
; 529  :         gui_wants_aggregates = atoi(pszCommand+10);

  00632	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pszCommand$[rsp]
  0063a	48 83 c0 0a	 add	 rax, 10
  0063e	48 8b c8	 mov	 rcx, rax
  00641	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00647	88 05 00 00 00
	00		 mov	 BYTE PTR gui_wants_aggregates, al

; 530  :         gui_forced_refresh = 1;

  0064d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR gui_forced_refresh, 1

; 531  :         return NULL;

  00654	33 c0		 xor	 eax, eax
  00656	eb 33		 jmp	 SHORT $LN1@gui_panel_
$LN40@gui_panel_:

; 532  :     }
; 533  : 
; 534  :     // Silently ignore any unrecognized special GUI commands...
; 535  : 
; 536  :     return NULL;        // (silently ignore it)

  00658	33 c0		 xor	 eax, eax
  0065a	eb 2f		 jmp	 SHORT $LN1@gui_panel_
$NotSpecialGUICommand$44:

; 537  : 
; 538  : NotSpecialGUICommand:
; 539  : 
; 540  :     // Otherwise it's not a command that we handle. Call the next higher
; 541  :     // level command handler which, under normal circumstances SHOULD be
; 542  :     // Hercules's "panel_command" function, but which MAY have been over-
; 543  :     // ridden by yet some OTHER dynamically loaded command handler...
; 544  : 
; 545  :     next_panel_command_handler = hdl_next( &gui_panel_command );

  0065c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gui_panel_command
  00663	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_next
  00669	48 89 44 24 38	 mov	 QWORD PTR next_panel_command_handler$[rsp], rax

; 546  : 
; 547  :     if (!next_panel_command_handler)    // (extremely unlikely!)

  0066e	48 83 7c 24 38
	00		 cmp	 QWORD PTR next_panel_command_handler$[rsp], 0
  00674	75 09		 jne	 SHORT $LN41@gui_panel_

; 548  :         return (char *)-1;              // (extremely unlikely!)

  00676	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0067d	eb 0c		 jmp	 SHORT $LN1@gui_panel_
$LN41@gui_panel_:

; 549  : 
; 550  :     return  next_panel_command_handler( pszCommand );

  0067f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszCommand$[rsp]
  00687	ff 54 24 38	 call	 QWORD PTR next_panel_command_handler$[rsp]
$LN1@gui_panel_:

; 551  : }

  0068b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00693	48 33 cc	 xor	 rcx, rsp
  00696	e8 00 00 00 00	 call	 __security_check_cookie
  0069b	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  006a2	5f		 pop	 rdi
  006a3	c3		 ret	 0
gui_panel_command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
tv65 = 32
tv69 = 36
tv71 = 40
tv82 = 44
tv86 = 48
tv88 = 52
tv136 = 56
tv140 = 60
tv142 = 64
pNewLineChar$ = 72
ProcessInputData PROC

; 286  : {

$LN23:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 287  :     char*  pNewLineChar;
; 288  : 
; 289  :     // Ensure our buffer is NULL terminated...
; 290  : 
; 291  :     MINMAX(nInputLen,0,(nInputBuffSize-1));

  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  0000e	7e 0c		 jle	 SHORT $LN5@ProcessInp
  00010	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  00016	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001a	eb 08		 jmp	 SHORT $LN6@ProcessInp
$LN5@ProcessInp:
  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN6@ProcessInp:
  00024	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  0002a	ff c8		 dec	 eax
  0002c	39 44 24 20	 cmp	 DWORD PTR tv65[rsp], eax
  00030	7d 27		 jge	 SHORT $LN9@ProcessInp
  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  00039	7e 0c		 jle	 SHORT $LN7@ProcessInp
  0003b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  00041	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
  00045	eb 08		 jmp	 SHORT $LN8@ProcessInp
$LN7@ProcessInp:
  00047	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN8@ProcessInp:
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR tv69[rsp]
  00053	89 44 24 28	 mov	 DWORD PTR tv71[rsp], eax
  00057	eb 0c		 jmp	 SHORT $LN10@ProcessInp
$LN9@ProcessInp:
  00059	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  0005f	ff c8		 dec	 eax
  00061	89 44 24 28	 mov	 DWORD PTR tv71[rsp], eax
$LN10@ProcessInp:
  00065	8b 44 24 28	 mov	 eax, DWORD PTR tv71[rsp]
  00069	89 05 00 00 00
	00		 mov	 DWORD PTR nInputLen, eax

; 292  :     *(pszInputBuff + nInputLen) = 0;

  0006f	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nInputLen
  00076	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszInputBuff
  0007d	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN2@ProcessInp:

; 293  : 
; 294  :     // Input commands are delimited by newline characters...
; 295  : 
; 296  :     while (nInputLen && (pNewLineChar = strchr(pszInputBuff,'\n')) != NULL)

  00081	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  00088	0f 84 a3 01 00
	00		 je	 $LN3@ProcessInp
  0008e	ba 0a 00 00 00	 mov	 edx, 10
  00093	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszInputBuff
  0009a	e8 00 00 00 00	 call	 strchr
  0009f	48 89 44 24 48	 mov	 QWORD PTR pNewLineChar$[rsp], rax
  000a4	48 83 7c 24 48
	00		 cmp	 QWORD PTR pNewLineChar$[rsp], 0
  000aa	0f 84 81 01 00
	00		 je	 $LN3@ProcessInp

; 297  :     {
; 298  :         // Extract command from input buffer
; 299  :         // into our command processing buffer...
; 300  : 
; 301  :         nCommandLen = (pNewLineChar - pszInputBuff);

  000b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pszInputBuff
  000b7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pNewLineChar$[rsp]
  000bc	48 2b c8	 sub	 rcx, rax
  000bf	48 8b c1	 mov	 rax, rcx
  000c2	89 05 00 00 00
	00		 mov	 DWORD PTR nCommandLen, eax

; 302  :         MINMAX(nCommandLen,0,(nCommandBuffSize-1));

  000c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nCommandLen, 0
  000cf	7e 0c		 jle	 SHORT $LN11@ProcessInp
  000d1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nCommandLen
  000d7	89 44 24 2c	 mov	 DWORD PTR tv82[rsp], eax
  000db	eb 08		 jmp	 SHORT $LN12@ProcessInp
$LN11@ProcessInp:
  000dd	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@ProcessInp:
  000e5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nCommandBuffSize
  000eb	ff c8		 dec	 eax
  000ed	39 44 24 2c	 cmp	 DWORD PTR tv82[rsp], eax
  000f1	7d 27		 jge	 SHORT $LN15@ProcessInp
  000f3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nCommandLen, 0
  000fa	7e 0c		 jle	 SHORT $LN13@ProcessInp
  000fc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nCommandLen
  00102	89 44 24 30	 mov	 DWORD PTR tv86[rsp], eax
  00106	eb 08		 jmp	 SHORT $LN14@ProcessInp
$LN13@ProcessInp:
  00108	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN14@ProcessInp:
  00110	8b 44 24 30	 mov	 eax, DWORD PTR tv86[rsp]
  00114	89 44 24 34	 mov	 DWORD PTR tv88[rsp], eax
  00118	eb 0c		 jmp	 SHORT $LN16@ProcessInp
$LN15@ProcessInp:
  0011a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nCommandBuffSize
  00120	ff c8		 dec	 eax
  00122	89 44 24 34	 mov	 DWORD PTR tv88[rsp], eax
$LN16@ProcessInp:
  00126	8b 44 24 34	 mov	 eax, DWORD PTR tv88[rsp]
  0012a	89 05 00 00 00
	00		 mov	 DWORD PTR nCommandLen, eax

; 303  :         memcpy(pszCommandBuff, pszInputBuff, nCommandLen);

  00130	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nCommandLen
  00137	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR pszCommandBuff
  0013e	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR pszInputBuff
  00145	48 8b c8	 mov	 rcx, rax
  00148	f3 a4		 rep movsb

; 304  :         *(pszCommandBuff + nCommandLen) = 0;

  0014a	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nCommandLen
  00151	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszCommandBuff
  00158	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 305  : 
; 306  :         // Process the extracted command...
; 307  : 
; 308  :         // Note that we always call the registered "panel_command" function
; 309  :         // rather than call our "gui_panel_command" function directly. This
; 310  :         // is in case some other DLL has overridden OUR command handler...
; 311  : 
; 312  :         panel_command ( pszCommandBuff );   // (call registered handler)

  0015c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszCommandBuff
  00163	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0016a	ff 10		 call	 QWORD PTR [rax]

; 313  : 
; 314  :         // Shift remaining data back to beginning of input buffer...
; 315  : 
; 316  :         nInputLen = ((pszInputBuff + nInputLen) - (pNewLineChar+1));

  0016c	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nInputLen
  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszInputBuff
  0017a	48 03 c8	 add	 rcx, rax
  0017d	48 8b c1	 mov	 rax, rcx
  00180	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pNewLineChar$[rsp]
  00185	48 ff c1	 inc	 rcx
  00188	48 2b c1	 sub	 rax, rcx
  0018b	89 05 00 00 00
	00		 mov	 DWORD PTR nInputLen, eax

; 317  :         MINMAX(nInputLen,0,(nInputBuffSize-1));

  00191	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  00198	7e 0c		 jle	 SHORT $LN17@ProcessInp
  0019a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  001a0	89 44 24 38	 mov	 DWORD PTR tv136[rsp], eax
  001a4	eb 08		 jmp	 SHORT $LN18@ProcessInp
$LN17@ProcessInp:
  001a6	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN18@ProcessInp:
  001ae	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  001b4	ff c8		 dec	 eax
  001b6	39 44 24 38	 cmp	 DWORD PTR tv136[rsp], eax
  001ba	7d 27		 jge	 SHORT $LN21@ProcessInp
  001bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  001c3	7e 0c		 jle	 SHORT $LN19@ProcessInp
  001c5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  001cb	89 44 24 3c	 mov	 DWORD PTR tv140[rsp], eax
  001cf	eb 08		 jmp	 SHORT $LN20@ProcessInp
$LN19@ProcessInp:
  001d1	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN20@ProcessInp:
  001d9	8b 44 24 3c	 mov	 eax, DWORD PTR tv140[rsp]
  001dd	89 44 24 40	 mov	 DWORD PTR tv142[rsp], eax
  001e1	eb 0c		 jmp	 SHORT $LN22@ProcessInp
$LN21@ProcessInp:
  001e3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  001e9	ff c8		 dec	 eax
  001eb	89 44 24 40	 mov	 DWORD PTR tv142[rsp], eax
$LN22@ProcessInp:
  001ef	8b 44 24 40	 mov	 eax, DWORD PTR tv142[rsp]
  001f3	89 05 00 00 00
	00		 mov	 DWORD PTR nInputLen, eax

; 318  :         memmove(pszInputBuff,pNewLineChar+1,nInputLen);

  001f9	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nInputLen
  00200	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pNewLineChar$[rsp]
  00205	48 ff c1	 inc	 rcx
  00208	4c 8b c0	 mov	 r8, rax
  0020b	48 8b d1	 mov	 rdx, rcx
  0020e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszInputBuff
  00215	e8 00 00 00 00	 call	 memmove

; 319  :         *(pszInputBuff + nInputLen) = 0;

  0021a	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nInputLen
  00221	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszInputBuff
  00228	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 320  :     }

  0022c	e9 50 fe ff ff	 jmp	 $LN2@ProcessInp
$LN3@ProcessInp:

; 321  : }

  00231	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00235	5f		 pop	 rdi
  00236	5e		 pop	 rsi
  00237	c3		 ret	 0
ProcessInputData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
nBytesRead$ = 32
tv65 = 36
tv69 = 40
tv71 = 44
tv82 = 48
tv85 = 52
tv86 = 56
tv89 = 60
tv93 = 64
tv95 = 68
pReadBuffer$ = 72
nMaxBytesToRead$ = 80
nTimeoutMillsecs$ = 112
ReadInputData PROC

; 185  : {

$LN22:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 186  :     size_t  nMaxBytesToRead;
; 187  :     int     nBytesRead;
; 188  :     char*   pReadBuffer;
; 189  : 
; 190  :     // Wait for keyboard input data to arrive...
; 191  : 
; 192  : #if !defined( _MSVC_ )
; 193  : 
; 194  :     fd_set          input_fd_set;
; 195  :     struct timeval  wait_interval_timeval;
; 196  :     int             rc;
; 197  : 
; 198  :     FD_ZERO ( &input_fd_set );
; 199  :     FD_SET  ( nInputStreamFileNum, &input_fd_set );
; 200  : 
; 201  :     wait_interval_timeval.tv_sec  =  nTimeoutMillsecs / 1000;
; 202  :     wait_interval_timeval.tv_usec = (nTimeoutMillsecs % 1000) * 1000;
; 203  : 
; 204  :     if ((rc = select( nInputStreamFileNum+1, &input_fd_set, NULL, NULL, &wait_interval_timeval )) < 0)
; 205  :     {
; 206  :         if (HSO_EINTR == HSO_errno)
; 207  :             return;             // (we were interrupted by a signal)
; 208  : 
; 209  :         // A bonafide error occurred; abort...
; 210  : 
; 211  :         WRMSG
; 212  :         (
; 213  :             HHC01511, "S"
; 214  :             ,"select()"
; 215  :             ,strerror(HSO_errno)
; 216  :         );
; 217  : 
; 218  :         bDoneProcessing = TRUE;     // (force main loop to exit)
; 219  :         return;
; 220  :     }
; 221  : 
; 222  :     // Has keyboard input data indeed arrived yet?
; 223  : 
; 224  :     if (!FD_ISSET( nInputStreamFileNum, &input_fd_set ))
; 225  :         return;     // (nothing for us to do...)
; 226  : 
; 227  : #endif // !defined( _MSVC_ )
; 228  : 
; 229  :     // Ensure our buffer never overflows... (-2 because
; 230  :     // we need room for at least 1 byte + NULL terminator)
; 231  : 
; 232  :     MINMAX(nInputLen,0,(nInputBuffSize-2));

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  0000f	7e 0c		 jle	 SHORT $LN4@ReadInputD
  00011	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  00017	89 44 24 24	 mov	 DWORD PTR tv65[rsp], eax
  0001b	eb 08		 jmp	 SHORT $LN5@ReadInputD
$LN4@ReadInputD:
  0001d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN5@ReadInputD:
  00025	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  0002b	83 e8 02	 sub	 eax, 2
  0002e	39 44 24 24	 cmp	 DWORD PTR tv65[rsp], eax
  00032	7d 27		 jge	 SHORT $LN8@ReadInputD
  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  0003b	7e 0c		 jle	 SHORT $LN6@ReadInputD
  0003d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  00043	89 44 24 28	 mov	 DWORD PTR tv69[rsp], eax
  00047	eb 08		 jmp	 SHORT $LN7@ReadInputD
$LN6@ReadInputD:
  00049	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN7@ReadInputD:
  00051	8b 44 24 28	 mov	 eax, DWORD PTR tv69[rsp]
  00055	89 44 24 2c	 mov	 DWORD PTR tv71[rsp], eax
  00059	eb 0d		 jmp	 SHORT $LN9@ReadInputD
$LN8@ReadInputD:
  0005b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  00061	83 e8 02	 sub	 eax, 2
  00064	89 44 24 2c	 mov	 DWORD PTR tv71[rsp], eax
$LN9@ReadInputD:
  00068	8b 44 24 2c	 mov	 eax, DWORD PTR tv71[rsp]
  0006c	89 05 00 00 00
	00		 mov	 DWORD PTR nInputLen, eax

; 233  : 
; 234  :     // Read input data into next available buffer location...
; 235  :     // (nMaxBytesToRead-1 == room for NULL terminator)
; 236  : 
; 237  :     pReadBuffer     = (pszInputBuff   + nInputLen);

  00072	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nInputLen
  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszInputBuff
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 89 44 24 48	 mov	 QWORD PTR pReadBuffer$[rsp], rax

; 238  :     nMaxBytesToRead = (nInputBuffSize - nInputLen) - 1;

  0008b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nInputBuffSize
  00097	2b c8		 sub	 ecx, eax
  00099	8b c1		 mov	 eax, ecx
  0009b	ff c8		 dec	 eax
  0009d	48 98		 cdqe
  0009f	48 89 44 24 50	 mov	 QWORD PTR nMaxBytesToRead$[rsp], rax

; 239  : 
; 240  : #if !defined( _MSVC_ )
; 241  : 
; 242  :     if ((nBytesRead = read( nInputStreamFileNum, pReadBuffer, nMaxBytesToRead )) < 0)
; 243  :     {
; 244  :         if (EINTR == errno)
; 245  :             return;             // (we were interrupted by a signal)
; 246  : 
; 247  :         // A bonafide error occurred; abort...
; 248  : 
; 249  :         WRMSG
; 250  :         (
; 251  :             HHC01511, "S"
; 252  :             ,"read()"
; 253  :             ,strerror(errno)
; 254  :         );
; 255  : 
; 256  :         bDoneProcessing = TRUE;     // (force main loop to exit)
; 257  :         return;
; 258  :     }
; 259  : 
; 260  : #else // defined( _MSVC_ )
; 261  : 
; 262  :     if ( ( nBytesRead = w32_get_stdin_char( pReadBuffer, nTimeoutMillsecs ) ) <= 0 )

  000a4	8b 54 24 70	 mov	 edx, DWORD PTR nTimeoutMillsecs$[rsp]
  000a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pReadBuffer$[rsp]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_get_stdin_char
  000b3	89 44 24 20	 mov	 DWORD PTR nBytesRead$[rsp], eax
  000b7	83 7c 24 20 00	 cmp	 DWORD PTR nBytesRead$[rsp], 0
  000bc	7f 05		 jg	 SHORT $LN2@ReadInputD

; 263  :         return;

  000be	e9 e8 00 00 00	 jmp	 $LN1@ReadInputD
$LN2@ReadInputD:

; 264  : 
; 265  : #endif // !defined( _MSVC_ )
; 266  : 
; 267  :     // Update amount of input data we have and
; 268  :     // ensure that it's always NULL terminated...
; 269  : 
; 270  :     MINMAX(nBytesRead,0,nInputBuffSize);

  000c3	83 7c 24 20 00	 cmp	 DWORD PTR nBytesRead$[rsp], 0
  000c8	7e 0a		 jle	 SHORT $LN10@ReadInputD
  000ca	8b 44 24 20	 mov	 eax, DWORD PTR nBytesRead$[rsp]
  000ce	89 44 24 30	 mov	 DWORD PTR tv82[rsp], eax
  000d2	eb 08		 jmp	 SHORT $LN11@ReadInputD
$LN10@ReadInputD:
  000d4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN11@ReadInputD:
  000dc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  000e2	39 44 24 30	 cmp	 DWORD PTR tv82[rsp], eax
  000e6	7d 23		 jge	 SHORT $LN14@ReadInputD
  000e8	83 7c 24 20 00	 cmp	 DWORD PTR nBytesRead$[rsp], 0
  000ed	7e 0a		 jle	 SHORT $LN12@ReadInputD
  000ef	8b 44 24 20	 mov	 eax, DWORD PTR nBytesRead$[rsp]
  000f3	89 44 24 34	 mov	 DWORD PTR tv85[rsp], eax
  000f7	eb 08		 jmp	 SHORT $LN13@ReadInputD
$LN12@ReadInputD:
  000f9	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN13@ReadInputD:
  00101	8b 44 24 34	 mov	 eax, DWORD PTR tv85[rsp]
  00105	89 44 24 38	 mov	 DWORD PTR tv86[rsp], eax
  00109	eb 0a		 jmp	 SHORT $LN15@ReadInputD
$LN14@ReadInputD:
  0010b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  00111	89 44 24 38	 mov	 DWORD PTR tv86[rsp], eax
$LN15@ReadInputD:
  00115	8b 44 24 38	 mov	 eax, DWORD PTR tv86[rsp]
  00119	89 44 24 20	 mov	 DWORD PTR nBytesRead$[rsp], eax

; 271  :     nInputLen += nBytesRead;

  0011d	8b 44 24 20	 mov	 eax, DWORD PTR nBytesRead$[rsp]
  00121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nInputLen
  00127	03 c8		 add	 ecx, eax
  00129	8b c1		 mov	 eax, ecx
  0012b	89 05 00 00 00
	00		 mov	 DWORD PTR nInputLen, eax

; 272  :     MINMAX(nInputLen,0,(nInputBuffSize-1));

  00131	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  00138	7e 0c		 jle	 SHORT $LN16@ReadInputD
  0013a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  00140	89 44 24 3c	 mov	 DWORD PTR tv89[rsp], eax
  00144	eb 08		 jmp	 SHORT $LN17@ReadInputD
$LN16@ReadInputD:
  00146	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN17@ReadInputD:
  0014e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  00154	ff c8		 dec	 eax
  00156	39 44 24 3c	 cmp	 DWORD PTR tv89[rsp], eax
  0015a	7d 27		 jge	 SHORT $LN20@ReadInputD
  0015c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nInputLen, 0
  00163	7e 0c		 jle	 SHORT $LN18@ReadInputD
  00165	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputLen
  0016b	89 44 24 40	 mov	 DWORD PTR tv93[rsp], eax
  0016f	eb 08		 jmp	 SHORT $LN19@ReadInputD
$LN18@ReadInputD:
  00171	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN19@ReadInputD:
  00179	8b 44 24 40	 mov	 eax, DWORD PTR tv93[rsp]
  0017d	89 44 24 44	 mov	 DWORD PTR tv95[rsp], eax
  00181	eb 0c		 jmp	 SHORT $LN21@ReadInputD
$LN20@ReadInputD:
  00183	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nInputBuffSize
  00189	ff c8		 dec	 eax
  0018b	89 44 24 44	 mov	 DWORD PTR tv95[rsp], eax
$LN21@ReadInputD:
  0018f	8b 44 24 44	 mov	 eax, DWORD PTR tv95[rsp]
  00193	89 05 00 00 00
	00		 mov	 DWORD PTR nInputLen, eax

; 273  :     *(pszInputBuff + nInputLen) = 0;

  00199	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nInputLen
  001a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszInputBuff
  001a7	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN1@ReadInputD:

; 274  : }

  001ab	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001af	c3		 ret	 0
ReadInputData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
UpdateTargetCPU PROC

; 127  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 128  :     if (!sysblk.shutdown)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00011	c1 e8 0b	 shr	 eax, 11
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 25		 jne	 SHORT $LN2@UpdateTarg

; 129  :         pTargetCPU_REGS = CopyREGS( pcpu = sysblk.pcpu );

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00022	8b 80 54 13 00
	00		 mov	 eax, DWORD PTR [rax+4948]
  00028	89 05 00 00 00
	00		 mov	 DWORD PTR pcpu, eax
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR pcpu
  00034	e8 00 00 00 00	 call	 CopyREGS
  00039	48 89 05 00 00
	00 00		 mov	 QWORD PTR pTargetCPU_REGS, rax
$LN2@UpdateTarg:

; 130  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
UpdateTargetCPU ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
Cleanup	PROC

; 2042 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2043 :     if  (pszInputBuff)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pszInputBuff, 0
  0000c	74 0d		 je	 SHORT $LN2@Cleanup

; 2044 :     free(pszInputBuff);

  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszInputBuff
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@Cleanup:

; 2045 : 
; 2046 :     if  (pszCommandBuff)

  0001b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pszCommandBuff, 0
  00023	74 0d		 je	 SHORT $LN3@Cleanup

; 2047 :     free(pszCommandBuff);

  00025	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pszCommandBuff
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@Cleanup:

; 2048 : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
Cleanup	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
ProcessingLoop PROC

; 83   : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 84   :     // Notify logger_thread we're in control
; 85   : 
; 86   :     sysblk.panel_init = 1;

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00011	83 c8 08	 or	 eax, 8
  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0001b	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN2@Processing:

; 87   : 
; 88   :     // Our main purpose in life: read input stream and process
; 89   :     // any commands that may be entered, and send periodic status
; 90   :     // information back to the external gui via its status stream.
; 91   : 
; 92   :     // Note we only exit whenever our bDoneProcessing flag is set
; 93   :     // which is normally not done until just before Herc unloads
; 94   :     // us which is normally not done until immediately before it
; 95   :     // terminates.
; 96   : 
; 97   :     // Also note we re-retrieve sysblk.panrate each iteration
; 98   :     // since it could change from one iteration to the next as a result
; 99   :     // of the Hercules "panrate" command being entered and processed.
; 100  : 
; 101  :     while (!bDoneProcessing)

  00021	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR bDoneProcessing, 0
  00028	75 23		 jne	 SHORT $LN3@Processing

; 102  :     {
; 103  :         UpdateTargetCPU();      // ("cpu" command could have changed it)

  0002a	e8 00 00 00 00	 call	 UpdateTargetCPU

; 104  :         UpdateStatus();         // (keep sending status back to gui...)

  0002f	e8 00 00 00 00	 call	 UpdateStatus

; 105  : 
; 106  :         ReadInputData( sysblk.panrate );

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	8b 88 30 11 00
	00		 mov	 ecx, DWORD PTR [rax+4400]
  00041	e8 00 00 00 00	 call	 ReadInputData

; 107  : 
; 108  :         ProcessInputData();     // (if there even is any of course...)

  00046	e8 00 00 00 00	 call	 ProcessInputData

; 109  :     }

  0004b	eb d4		 jmp	 SHORT $LN2@Processing
$LN3@Processing:

; 110  : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
ProcessingLoop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyngui.c
_TEXT	SEGMENT
tv139 = 48
tv149 = 56
tv160 = 64
tv170 = 72
cmdbuf$1 = 80
__$ArrayPad$ = 208
Initialize PROC

; 1991 : {

$LN14:
  00000	40 57		 push	 rdi
  00002	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1992 :     // Disable the "quiet" command...
; 1993 :     {
; 1994 :         char cmdbuf[128] = {0};

  0001b	48 8d 44 24 50	 lea	 rax, QWORD PTR cmdbuf$1[rsp]
  00020	48 8b f8	 mov	 rdi, rax
  00023	33 c0		 xor	 eax, eax
  00025	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0002a	f3 aa		 rep stosb

; 1995 :         MSGBUF( cmdbuf, "%s %s %s", "$zapcmd", "quiet", "NoCmd" );

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168651
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168652
  0003f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00044	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168653
  0004b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168654
  00052	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00057	48 8d 4c 24 50	 lea	 rcx, QWORD PTR cmdbuf$1[rsp]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN4@Initialize:

; 1996 :         VERIFY( 0 == InternalHercCmd( cmdbuf ));

  00062	48 8d 4c 24 50	 lea	 rcx, QWORD PTR cmdbuf$1[rsp]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InternalHercCmd
  0006d	85 c0		 test	 eax, eax
  0006f	74 5c		 je	 SHORT $LN8@Initialize
$LN7@Initialize:
  00071	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168656
  00078	41 b8 cc 07 00
	00		 mov	 r8d, 1996		; 000007ccH
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168657
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168658
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00098	85 c0		 test	 eax, eax
  0009a	74 20		 je	 SHORT $LN9@Initialize
  0009c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168660
  000a3	41 b8 cc 07 00
	00		 mov	 r8d, 1996		; 000007ccH
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168661
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168662
  000b7	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@Initialize:
  000bc	33 c0		 xor	 eax, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 af		 jne	 SHORT $LN7@Initialize
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c8	85 c0		 test	 eax, eax
  000ca	74 01		 je	 SHORT $LN10@Initialize
  000cc	cc		 int	 3
$LN10@Initialize:
$LN8@Initialize:
  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 8f		 jne	 SHORT $LN4@Initialize

; 1997 :     }
; 1998 : 
; 1999 :     // Initialize streams...
; 2000 : 
; 2001 :     fOutputStream = OUTPUT_STREAM_FILE_PTR;

  000d3	b9 01 00 00 00	 mov	 ecx, 1
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000de	48 89 05 00 00
	00 00		 mov	 QWORD PTR fOutputStream, rax

; 2002 :     fStatusStream = STATUS_STREAM_FILE_PTR;

  000e5	b9 02 00 00 00	 mov	 ecx, 2
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f0	48 89 05 00 00
	00 00		 mov	 QWORD PTR fStatusStream, rax

; 2003 : 
; 2004 :     nInputStreamFileNum = fileno( INPUT_STREAM_FILE_PTR );

  000f7	33 c9		 xor	 ecx, ecx
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ff	48 8b c8	 mov	 rcx, rax
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  00108	89 05 00 00 00
	00		 mov	 DWORD PTR nInputStreamFileNum, eax

; 2005 : 
; 2006 :     // Allocate input stream buffer...
; 2007 : 
; 2008 :     if (!(pszInputBuff = (char *) malloc( nInputBuffSize )))

  0010e	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nInputBuffSize
  00115	48 8b c8	 mov	 rcx, rax
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0011e	48 89 05 00 00
	00 00		 mov	 QWORD PTR pszInputBuff, rax
  00125	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pszInputBuff, 0
  0012d	75 3e		 jne	 SHORT $LN11@Initialize

; 2009 :     {
; 2010 :         fprintf(stderr,

  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00135	8b 08		 mov	 ecx, DWORD PTR [rax]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0013d	48 89 44 24 30	 mov	 QWORD PTR tv139[rsp], rax
  00142	b9 02 00 00 00	 mov	 ecx, 2
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv139[rsp]
  00152	4c 8b c1	 mov	 r8, rcx
  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168665
  0015c	48 8b c8	 mov	 rcx, rax
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 2011 :             "HHC90000D DBG: malloc() pszInputBuff failed: %s\n",
; 2012 :             strerror( errno ));
; 2013 :         exit(0);

  00165	33 c9		 xor	 ecx, ecx
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN11@Initialize:

; 2014 :     }
; 2015 : 
; 2016 :     memset(pszInputBuff, 0, nInputBuffSize);

  0016d	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nInputBuffSize
  00174	48 89 44 24 38	 mov	 QWORD PTR tv149[rsp], rax
  00179	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR pszInputBuff
  00180	33 c0		 xor	 eax, eax
  00182	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv149[rsp]
  00187	f3 aa		 rep stosb

; 2017 :     nInputLen = 0;

  00189	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR nInputLen, 0

; 2018 : 
; 2019 :     // Allocate command processing buffer...
; 2020 : 
; 2021 :     if (!(pszCommandBuff = (char *) malloc( nCommandBuffSize )))

  00193	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nCommandBuffSize
  0019a	48 8b c8	 mov	 rcx, rax
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001a3	48 89 05 00 00
	00 00		 mov	 QWORD PTR pszCommandBuff, rax
  001aa	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pszCommandBuff, 0
  001b2	75 3e		 jne	 SHORT $LN12@Initialize

; 2022 :     {
; 2023 :         fprintf(stderr,

  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ba	8b 08		 mov	 ecx, DWORD PTR [rax]
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001c2	48 89 44 24 40	 mov	 QWORD PTR tv160[rsp], rax
  001c7	b9 02 00 00 00	 mov	 ecx, 2
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv160[rsp]
  001d7	4c 8b c1	 mov	 r8, rcx
  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168667
  001e1	48 8b c8	 mov	 rcx, rax
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 2024 :             "HHC90000D DBG: malloc() pszCommandBuff failed: %s\n",
; 2025 :             strerror( errno ));
; 2026 :         exit(0);

  001ea	33 c9		 xor	 ecx, ecx
  001ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN12@Initialize:

; 2027 :     }
; 2028 : 
; 2029 :     memset(pszCommandBuff, 0, nCommandBuffSize);

  001f2	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR nCommandBuffSize
  001f9	48 89 44 24 48	 mov	 QWORD PTR tv170[rsp], rax
  001fe	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR pszCommandBuff
  00205	33 c0		 xor	 eax, eax
  00207	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv170[rsp]
  0020c	f3 aa		 rep stosb

; 2030 :     nCommandLen = 0;

  0020e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR nCommandLen, 0

; 2031 : 
; 2032 :     // Initialize some variables...
; 2033 : 
; 2034 :     HandleForcedRefresh();

  00218	e8 00 00 00 00	 call	 HandleForcedRefresh
$LN13@Initialize:

; 2035 : }

  0021d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00225	48 33 cc	 xor	 rcx, rsp
  00228	e8 00 00 00 00	 call	 __security_check_cookie
  0022d	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00234	5f		 pop	 rdi
  00235	c3		 ret	 0
Initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT vfprintf
_TEXT	SEGMENT
_Stream$ = 48
_Format$ = 56
_ArgList$ = 64
vfprintf PROC						; COMDAT

; 658  :     {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 659  :         return _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00013	4c 8b 4c 24 40	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00018	45 33 c0	 xor	 r8d, r8d
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Format$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00025	e8 00 00 00 00	 call	 _vfprintf_l

; 660  :     }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
