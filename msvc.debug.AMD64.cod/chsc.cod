; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	s390_channel_subsystem_call
PUBLIC	s390_maddr_l
PUBLIC	s390_validate_operand
PUBLIC	z900_channel_subsystem_call
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_check
PUBLIC	z900_maddr_l
PUBLIC	z900_validate_operand
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	longjmp:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	find_device_by_subchan:PROC
EXTRN	get_lparname:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_debug_chsc_unknown_request:QWORD
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$chsc_max_rsp DD imagerel chsc_max_rsp
	DD	imagerel chsc_max_rsp+135
	DD	imagerel $unwind$chsc_max_rsp
$pdata$chsc_req_ok DD imagerel chsc_req_ok
	DD	imagerel chsc_req_ok+100
	DD	imagerel $unwind$chsc_req_ok
$pdata$chsc_req_errreq DD imagerel chsc_req_errreq
	DD	imagerel chsc_req_errreq+93
	DD	imagerel $unwind$chsc_req_errreq
$pdata$s390_channel_subsystem_call DD imagerel $LN40
	DD	imagerel $LN40+1335
	DD	imagerel $unwind$s390_channel_subsystem_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+185
	DD	imagerel $unwind$s390_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$s390_chsc_get_conf_info DD imagerel s390_chsc_get_conf_info
	DD	imagerel s390_chsc_get_conf_info+502
	DD	imagerel $unwind$s390_chsc_get_conf_info
$pdata$s390_chsc_get_sch_desc DD imagerel s390_chsc_get_sch_desc
	DD	imagerel s390_chsc_get_sch_desc+1007
	DD	imagerel $unwind$s390_chsc_get_sch_desc
$pdata$s390_chsc_get_cu_desc DD imagerel s390_chsc_get_cu_desc
	DD	imagerel s390_chsc_get_cu_desc+954
	DD	imagerel $unwind$s390_chsc_get_cu_desc
$pdata$s390_chsc_get_css_info DD imagerel s390_chsc_get_css_info
	DD	imagerel s390_chsc_get_css_info+1677
	DD	imagerel $unwind$s390_chsc_get_css_info
$pdata$s390_chsc_get_ssqd DD imagerel s390_chsc_get_ssqd
	DD	imagerel s390_chsc_get_ssqd+673
	DD	imagerel $unwind$s390_chsc_get_ssqd
$pdata$s390_chsc_set_sci DD imagerel s390_chsc_set_sci
	DD	imagerel s390_chsc_set_sci+249
	DD	imagerel $unwind$s390_chsc_set_sci
$pdata$s390_chsc_get_chp_desc DD imagerel s390_chsc_get_chp_desc
	DD	imagerel s390_chsc_get_chp_desc+919
	DD	imagerel $unwind$s390_chsc_get_chp_desc
$pdata$z900_channel_subsystem_call DD imagerel $LN44
	DD	imagerel $LN44+1447
	DD	imagerel $unwind$z900_channel_subsystem_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_check DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$z900_per3_zero_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$z900_chsc_get_conf_info DD imagerel z900_chsc_get_conf_info
	DD	imagerel z900_chsc_get_conf_info+502
	DD	imagerel $unwind$z900_chsc_get_conf_info
$pdata$z900_chsc_get_sch_desc DD imagerel z900_chsc_get_sch_desc
	DD	imagerel z900_chsc_get_sch_desc+1007
	DD	imagerel $unwind$z900_chsc_get_sch_desc
$pdata$z900_chsc_get_cu_desc DD imagerel z900_chsc_get_cu_desc
	DD	imagerel z900_chsc_get_cu_desc+954
	DD	imagerel $unwind$z900_chsc_get_cu_desc
$pdata$z900_chsc_get_css_info DD imagerel z900_chsc_get_css_info
	DD	imagerel z900_chsc_get_css_info+1677
	DD	imagerel $unwind$z900_chsc_get_css_info
$pdata$z900_chsc_get_ssqd DD imagerel z900_chsc_get_ssqd
	DD	imagerel z900_chsc_get_ssqd+673
	DD	imagerel $unwind$z900_chsc_get_ssqd
$pdata$z900_chsc_set_sci DD imagerel z900_chsc_set_sci
	DD	imagerel z900_chsc_set_sci+249
	DD	imagerel $unwind$z900_chsc_set_sci
$pdata$z900_chsc_get_chp_desc DD imagerel z900_chsc_get_chp_desc
	DD	imagerel z900_chsc_get_chp_desc+919
	DD	imagerel $unwind$z900_chsc_get_chp_desc
pdata	ENDS
_DATA	SEGMENT
$SG180225 DB	'C:\papa\MyGit\hyperion-zvector\chsc.c:594', 00H
	ORG $+2
$SG180226 DB	'CHSC', 00H
	ORG $+7
$SG180241 DB	'C:\papa\MyGit\hyperion-zvector\chsc.c:672', 00H
	ORG $+2
$SG180242 DB	'*CHSC', 00H
	ORG $+6
$SG193566 DB	'C:\papa\MyGit\hyperion-zvector\chsc.c:589', 00H
	ORG $+6
$SG193570 DB	'C:\papa\MyGit\hyperion-zvector\chsc.c:594', 00H
	ORG $+2
$SG193571 DB	'CHSC', 00H
	ORG $+7
$SG193586 DB	'C:\papa\MyGit\hyperion-zvector\chsc.c:672', 00H
	ORG $+2
$SG193587 DB	'*CHSC', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_check DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
xdata	SEGMENT
$unwind$chsc_max_rsp DD 010e01H
	DD	0220eH
$unwind$chsc_req_ok DD 011301H
	DD	04213H
$unwind$chsc_req_errreq DD 010d01H
	DD	0420dH
$unwind$s390_channel_subsystem_call DD 021101H
	DD	0110111H
$unwind$s390_chsc_get_conf_info DD 020f01H
	DD	0700bd20fH
$unwind$s390_chsc_get_sch_desc DD 020f01H
	DD	0700bd20fH
$unwind$s390_chsc_get_cu_desc DD 020f01H
	DD	0700bd20fH
$unwind$s390_chsc_get_css_info DD 021401H
	DD	070105214H
$unwind$s390_chsc_get_ssqd DD 020f01H
	DD	0700bd20fH
$unwind$s390_chsc_set_sci DD 010e01H
	DD	0820eH
$unwind$s390_chsc_get_chp_desc DD 021201H
	DD	0700bf212H
$unwind$z900_channel_subsystem_call DD 021101H
	DD	0110111H
$unwind$z900_chsc_get_conf_info DD 020f01H
	DD	0700bd20fH
$unwind$z900_chsc_get_sch_desc DD 020f01H
	DD	0700bd20fH
$unwind$z900_chsc_get_cu_desc DD 020f01H
	DD	0700bd20fH
$unwind$z900_chsc_get_css_info DD 021401H
	DD	070105214H
$unwind$z900_chsc_get_ssqd DD 020f01H
	DD	0700bd20fH
$unwind$z900_chsc_set_sci DD 010e01H
	DD	0820eH
$unwind$z900_chsc_get_chp_desc DD 021201H
	DD	0700bf212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
max_rsp$ = 32
chp$ = 36
dev$ = 40
f_chp$ = 48
l_chp$ = 52
req_len$ = 56
rsp_len$ = 60
chsc_rsp2$ = 64
chsc_rsp2f1$ = 72
tv79 = 80
num_chps$ = 84
tv128 = 88
fmt1$ = 92
chsc_req2$ = 96
tv81 = 104
rsp_size$ = 112
chsc_req$ = 144
chsc_rsp$ = 152
z900_chsc_get_chp_desc PROC

; 493  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 494  : U16 req_len, rsp_len, max_rsp;
; 495  : int fmt1, chp, f_chp, l_chp, num_chps;
; 496  : size_t rsp_size;
; 497  : DEVBLK *dev;
; 498  : 
; 499  : CHSC_REQ2   *chsc_req2   = (CHSC_REQ2 *)  (chsc_req);

  00012	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  0001a	48 89 44 24 60	 mov	 QWORD PTR chsc_req2$[rsp], rax

; 500  : CHSC_RSP2   *chsc_rsp2   = (CHSC_RSP2 *)  (chsc_rsp+1);

  0001f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00027	48 83 c0 08	 add	 rax, 8
  0002b	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp2$[rsp], rax

; 501  : CHSC_RSP2F1 *chsc_rsp2f1 = (CHSC_RSP2F1 *)(chsc_rsp+1);

  00030	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00038	48 83 c0 08	 add	 rax, 8
  0003c	48 89 44 24 48	 mov	 QWORD PTR chsc_rsp2f1$[rsp], rax

; 502  : 
; 503  :     f_chp = chsc_req2->first_chpid;

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR chsc_req2$[rsp]
  00046	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  0004a	89 44 24 30	 mov	 DWORD PTR f_chp$[rsp], eax

; 504  :     l_chp = chsc_req2->last_chpid;

  0004e	48 8b 44 24 60	 mov	 rax, QWORD PTR chsc_req2$[rsp]
  00053	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  00057	89 44 24 34	 mov	 DWORD PTR l_chp$[rsp], eax

; 505  : 
; 506  :     FETCH_HW(req_len, chsc_req2->length);

  0005b	48 8b 44 24 60	 mov	 rax, QWORD PTR chsc_req2$[rsp]
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 fetch_hw_noswap
  00068	0f b7 c8	 movzx	 ecx, ax
  0006b	e8 00 00 00 00	 call	 _byteswap_ushort
  00070	66 89 44 24 38	 mov	 WORD PTR req_len$[rsp], ax

; 507  : 
; 508  :     fmt1 = (chsc_req2->flags1 & CHSC_REQ2_F1_C) ? 1 : 0;

  00075	48 8b 44 24 60	 mov	 rax, QWORD PTR chsc_req2$[rsp]
  0007a	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0007e	83 e0 10	 and	 eax, 16
  00081	85 c0		 test	 eax, eax
  00083	74 0a		 je	 SHORT $LN21@z900_chsc_
  00085	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  0008d	eb 08		 jmp	 SHORT $LN22@z900_chsc_
$LN21@z900_chsc_:
  0008f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN22@z900_chsc_:
  00097	8b 44 24 50	 mov	 eax, DWORD PTR tv79[rsp]
  0009b	89 44 24 5c	 mov	 DWORD PTR fmt1$[rsp], eax

; 509  :     rsp_size = fmt1 ? sizeof(CHSC_RSP2F1) : sizeof(CHSC_RSP2);

  0009f	83 7c 24 5c 00	 cmp	 DWORD PTR fmt1$[rsp], 0
  000a4	74 0b		 je	 SHORT $LN23@z900_chsc_
  000a6	48 c7 44 24 68
	20 00 00 00	 mov	 QWORD PTR tv81[rsp], 32	; 00000020H
  000af	eb 09		 jmp	 SHORT $LN24@z900_chsc_
$LN23@z900_chsc_:
  000b1	48 c7 44 24 68
	08 00 00 00	 mov	 QWORD PTR tv81[rsp], 8
$LN24@z900_chsc_:
  000ba	48 8b 44 24 68	 mov	 rax, QWORD PTR tv81[rsp]
  000bf	48 89 44 24 70	 mov	 QWORD PTR rsp_size$[rsp], rax

; 510  : 
; 511  :     if(!(max_rsp = chsc_max_rsp(req_len, rsp_size))
; 512  : // ZZ || (chsc_req2->rfmt != 1 && chsc_req2->rfmt != 2)
; 513  :       || f_chp > l_chp)

  000c4	48 8b 54 24 70	 mov	 rdx, QWORD PTR rsp_size$[rsp]
  000c9	0f b7 4c 24 38	 movzx	 ecx, WORD PTR req_len$[rsp]
  000ce	e8 00 00 00 00	 call	 chsc_max_rsp
  000d3	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  000d8	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  000dd	85 c0		 test	 eax, eax
  000df	74 0a		 je	 SHORT $LN15@z900_chsc_
  000e1	8b 44 24 34	 mov	 eax, DWORD PTR l_chp$[rsp]
  000e5	39 44 24 30	 cmp	 DWORD PTR f_chp$[rsp], eax
  000e9	7e 14		 jle	 SHORT $LN14@z900_chsc_
$LN15@z900_chsc_:

; 514  :         return chsc_req_errreq(chsc_rsp, 0);

  000eb	33 d2		 xor	 edx, edx
  000ed	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000f5	e8 00 00 00 00	 call	 chsc_req_errreq
  000fa	e9 8f 02 00 00	 jmp	 $LN1@z900_chsc_
$LN14@z900_chsc_:

; 515  : 
; 516  :     num_chps = (l_chp - f_chp) + 1;

  000ff	8b 44 24 30	 mov	 eax, DWORD PTR f_chp$[rsp]
  00103	8b 4c 24 34	 mov	 ecx, DWORD PTR l_chp$[rsp]
  00107	2b c8		 sub	 ecx, eax
  00109	8b c1		 mov	 eax, ecx
  0010b	ff c0		 inc	 eax
  0010d	89 44 24 54	 mov	 DWORD PTR num_chps$[rsp], eax

; 517  :     max_rsp  = (U16) min((int)max_rsp, num_chps);

  00111	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00116	3b 44 24 54	 cmp	 eax, DWORD PTR num_chps$[rsp]
  0011a	7d 0b		 jge	 SHORT $LN25@z900_chsc_
  0011c	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00121	89 44 24 58	 mov	 DWORD PTR tv128[rsp], eax
  00125	eb 08		 jmp	 SHORT $LN26@z900_chsc_
$LN25@z900_chsc_:
  00127	8b 44 24 54	 mov	 eax, DWORD PTR num_chps$[rsp]
  0012b	89 44 24 58	 mov	 DWORD PTR tv128[rsp], eax
$LN26@z900_chsc_:
  0012f	0f b7 44 24 58	 movzx	 eax, WORD PTR tv128[rsp]
  00134	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax

; 518  :     rsp_len  = sizeof(CHSC_RSP) + (max_rsp * rsp_size);

  00139	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0013e	48 0f af 44 24
	70		 imul	 rax, QWORD PTR rsp_size$[rsp]
  00144	48 83 c0 08	 add	 rax, 8
  00148	66 89 44 24 3c	 mov	 WORD PTR rsp_len$[rsp], ax

; 519  : 
; 520  :     if (!fmt1)

  0014d	83 7c 24 5c 00	 cmp	 DWORD PTR fmt1$[rsp], 0
  00152	0f 85 13 01 00
	00		 jne	 $LN16@z900_chsc_

; 521  :     {
; 522  :         for(chp = f_chp; chp <= l_chp && max_rsp; chp++, max_rsp--, chsc_rsp2++)

  00158	8b 44 24 30	 mov	 eax, DWORD PTR f_chp$[rsp]
  0015c	89 44 24 24	 mov	 DWORD PTR chp$[rsp], eax
  00160	eb 25		 jmp	 SHORT $LN4@z900_chsc_
$LN2@z900_chsc_:
  00162	8b 44 24 24	 mov	 eax, DWORD PTR chp$[rsp]
  00166	ff c0		 inc	 eax
  00168	89 44 24 24	 mov	 DWORD PTR chp$[rsp], eax
  0016c	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00171	66 ff c8	 dec	 ax
  00174	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  00179	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp2$[rsp]
  0017e	48 83 c0 08	 add	 rax, 8
  00182	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp2$[rsp], rax
$LN4@z900_chsc_:
  00187	8b 44 24 34	 mov	 eax, DWORD PTR l_chp$[rsp]
  0018b	39 44 24 24	 cmp	 DWORD PTR chp$[rsp], eax
  0018f	0f 8f d1 00 00
	00		 jg	 $LN3@z900_chsc_
  00195	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0019a	85 c0		 test	 eax, eax
  0019c	0f 84 c4 00 00
	00		 je	 $LN3@z900_chsc_

; 523  :         {
; 524  :             memset(chsc_rsp2, 0, sizeof(CHSC_RSP2));

  001a2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR chsc_rsp2$[rsp]
  001a7	33 c0		 xor	 eax, eax
  001a9	b9 08 00 00 00	 mov	 ecx, 8
  001ae	f3 aa		 rep stosb

; 525  :             chsc_rsp2->chpid = chp;

  001b0	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp2$[rsp]
  001b5	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR chp$[rsp]
  001ba	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 526  : 
; 527  :             for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  001bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c4	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  001cb	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
  001d0	eb 0e		 jmp	 SHORT $LN7@z900_chsc_
$LN5@z900_chsc_:
  001d2	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  001d7	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001db	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN7@z900_chsc_:
  001e0	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001e6	74 79		 je	 SHORT $LN6@z900_chsc_

; 528  :                 if (dev->allocated
; 529  :                   && (dev->pmcw.chpid[0] == chp)
; 530  :                   && dev->chptype[0])

  001e8	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  001ed	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  001f1	74 69		 je	 SHORT $LN18@z900_chsc_
  001f3	b8 01 00 00 00	 mov	 eax, 1
  001f8	48 6b c0 00	 imul	 rax, rax, 0
  001fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00201	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  00209	3b 44 24 24	 cmp	 eax, DWORD PTR chp$[rsp]
  0020d	75 4d		 jne	 SHORT $LN18@z900_chsc_
  0020f	b8 01 00 00 00	 mov	 eax, 1
  00214	48 6b c0 00	 imul	 rax, rax, 0
  00218	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  0021d	0f b6 84 01 cc
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1484]
  00225	85 c0		 test	 eax, eax
  00227	74 33		 je	 SHORT $LN18@z900_chsc_

; 531  :                 {
; 532  :                     chsc_rsp2->flags1   |= CHSC_RSP2_F1_CHPID_VALID;

  00229	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp2$[rsp]
  0022e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00231	0f ba e8 07	 bts	 eax, 7
  00235	48 8b 4c 24 40	 mov	 rcx, QWORD PTR chsc_rsp2$[rsp]
  0023a	88 01		 mov	 BYTE PTR [rcx], al

; 533  :                     chsc_rsp2->chp_type  = dev->chptype[0];

  0023c	b8 01 00 00 00	 mov	 eax, 1
  00241	48 6b c0 00	 imul	 rax, rax, 0
  00245	48 8b 4c 24 40	 mov	 rcx, QWORD PTR chsc_rsp2$[rsp]
  0024a	48 8b 54 24 28	 mov	 rdx, QWORD PTR dev$[rsp]
  0024f	0f b6 84 02 cc
	05 00 00	 movzx	 eax, BYTE PTR [rdx+rax+1484]
  00257	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 534  : //                  chsc_rsp2->lsn       = 0;
; 535  : //                  chsc_rsp2->swla      = 0;
; 536  : //                  chsc_rsp2->chla      = 0;
; 537  :                     break;

  0025a	eb 05		 jmp	 SHORT $LN6@z900_chsc_
$LN18@z900_chsc_:

; 538  :                 }

  0025c	e9 71 ff ff ff	 jmp	 $LN5@z900_chsc_
$LN6@z900_chsc_:

; 539  :         }

  00261	e9 fc fe ff ff	 jmp	 $LN2@z900_chsc_
$LN3@z900_chsc_:

; 540  :     }

  00266	e9 0e 01 00 00	 jmp	 $LN17@z900_chsc_
$LN16@z900_chsc_:

; 541  :     else
; 542  :     {
; 543  :         for(chp = f_chp; chp <= l_chp && max_rsp; chp++, max_rsp--, chsc_rsp2f1++)

  0026b	8b 44 24 30	 mov	 eax, DWORD PTR f_chp$[rsp]
  0026f	89 44 24 24	 mov	 DWORD PTR chp$[rsp], eax
  00273	eb 25		 jmp	 SHORT $LN10@z900_chsc_
$LN8@z900_chsc_:
  00275	8b 44 24 24	 mov	 eax, DWORD PTR chp$[rsp]
  00279	ff c0		 inc	 eax
  0027b	89 44 24 24	 mov	 DWORD PTR chp$[rsp], eax
  0027f	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00284	66 ff c8	 dec	 ax
  00287	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0028c	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_rsp2f1$[rsp]
  00291	48 83 c0 20	 add	 rax, 32			; 00000020H
  00295	48 89 44 24 48	 mov	 QWORD PTR chsc_rsp2f1$[rsp], rax
$LN10@z900_chsc_:
  0029a	8b 44 24 34	 mov	 eax, DWORD PTR l_chp$[rsp]
  0029e	39 44 24 24	 cmp	 DWORD PTR chp$[rsp], eax
  002a2	0f 8f d1 00 00
	00		 jg	 $LN9@z900_chsc_
  002a8	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  002ad	85 c0		 test	 eax, eax
  002af	0f 84 c4 00 00
	00		 je	 $LN9@z900_chsc_

; 544  :         {
; 545  :             memset(chsc_rsp2f1, 0, sizeof(CHSC_RSP2F1));

  002b5	48 8b 7c 24 48	 mov	 rdi, QWORD PTR chsc_rsp2f1$[rsp]
  002ba	33 c0		 xor	 eax, eax
  002bc	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002c1	f3 aa		 rep stosb

; 546  :             chsc_rsp2f1->chpid = chp;

  002c3	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_rsp2f1$[rsp]
  002c8	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR chp$[rsp]
  002cd	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 547  : 
; 548  :             for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  002d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002d7	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  002de	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
  002e3	eb 0e		 jmp	 SHORT $LN13@z900_chsc_
$LN11@z900_chsc_:
  002e5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  002ea	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002ee	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN13@z900_chsc_:
  002f3	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002f9	74 79		 je	 SHORT $LN12@z900_chsc_

; 549  :                 if (dev->allocated
; 550  :                   && (dev->pmcw.chpid[0] == chp)
; 551  :                   && dev->chptype[0])

  002fb	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00300	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00304	74 69		 je	 SHORT $LN19@z900_chsc_
  00306	b8 01 00 00 00	 mov	 eax, 1
  0030b	48 6b c0 00	 imul	 rax, rax, 0
  0030f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00314	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  0031c	3b 44 24 24	 cmp	 eax, DWORD PTR chp$[rsp]
  00320	75 4d		 jne	 SHORT $LN19@z900_chsc_
  00322	b8 01 00 00 00	 mov	 eax, 1
  00327	48 6b c0 00	 imul	 rax, rax, 0
  0032b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00330	0f b6 84 01 cc
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1484]
  00338	85 c0		 test	 eax, eax
  0033a	74 33		 je	 SHORT $LN19@z900_chsc_

; 552  :                 {
; 553  :                     chsc_rsp2f1->flags1   |= CHSC_RSP2F1_F1_CHPID_VALID;

  0033c	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_rsp2f1$[rsp]
  00341	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00344	0f ba e8 07	 bts	 eax, 7
  00348	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_rsp2f1$[rsp]
  0034d	88 01		 mov	 BYTE PTR [rcx], al

; 554  :                     chsc_rsp2f1->chp_type  = dev->chptype[0];

  0034f	b8 01 00 00 00	 mov	 eax, 1
  00354	48 6b c0 00	 imul	 rax, rax, 0
  00358	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_rsp2f1$[rsp]
  0035d	48 8b 54 24 28	 mov	 rdx, QWORD PTR dev$[rsp]
  00362	0f b6 84 02 cc
	05 00 00	 movzx	 eax, BYTE PTR [rdx+rax+1484]
  0036a	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 555  : //                  chsc_rsp2f1->lsn       = 0;
; 556  : //                  chsc_rsp2f1->chpp      = 0;
; 557  : //                  STORE_HW(chsc_rsp2f1->mdc,0x0000);
; 558  : //                  STORE_HW(chsc_rsp2f1->flags2,0x0000);
; 559  :                     break;

  0036d	eb 05		 jmp	 SHORT $LN12@z900_chsc_
$LN19@z900_chsc_:

; 560  :                 }

  0036f	e9 71 ff ff ff	 jmp	 $LN11@z900_chsc_
$LN12@z900_chsc_:

; 561  :         }

  00374	e9 fc fe ff ff	 jmp	 $LN8@z900_chsc_
$LN9@z900_chsc_:
$LN17@z900_chsc_:

; 562  :     }
; 563  : 
; 564  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  00379	45 33 c0	 xor	 r8d, r8d
  0037c	0f b7 54 24 3c	 movzx	 edx, WORD PTR rsp_len$[rsp]
  00381	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00389	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@z900_chsc_:

; 565  : }

  0038e	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00395	5f		 pop	 rdi
  00396	c3		 ret	 0
z900_chsc_get_chp_desc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
req_len$ = 32
rsp_len$ = 36
ssid$ = 40
rc$ = 44
dev$ = 48
chsc_req21$ = 56
chsc_req$ = 80
chsc_rsp$ = 88
z900_chsc_set_sci PROC

; 460  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 461  : U16 req_len, rsp_len;
; 462  : DEVBLK *dev;
; 463  : U32 ssid;
; 464  : int rc;
; 465  : 
; 466  : CHSC_REQ21 *chsc_req21 = (CHSC_REQ21 *)(chsc_req);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00013	48 89 44 24 38	 mov	 QWORD PTR chsc_req21$[rsp], rax

; 467  : 
; 468  :     FETCH_HW( req_len, chsc_req21->length );

  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR chsc_req21$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_hw_noswap
  00025	0f b7 c8	 movzx	 ecx, ax
  00028	e8 00 00 00 00	 call	 _byteswap_ushort
  0002d	66 89 44 24 20	 mov	 WORD PTR req_len$[rsp], ax

; 469  : 
; 470  :     rsp_len = sizeof(CHSC_RSP) + 0;

  00032	b8 08 00 00 00	 mov	 eax, 8
  00037	66 89 44 24 24	 mov	 WORD PTR rsp_len$[rsp], ax

; 471  : 
; 472  :     if (!chsc_max_rsp(req_len, 0))

  0003c	33 d2		 xor	 edx, edx
  0003e	0f b7 4c 24 20	 movzx	 ecx, WORD PTR req_len$[rsp]
  00043	e8 00 00 00 00	 call	 chsc_max_rsp
  00048	0f b7 c0	 movzx	 eax, ax
  0004b	85 c0		 test	 eax, eax
  0004d	75 11		 jne	 SHORT $LN2@z900_chsc_

; 473  :         return chsc_req_errreq(chsc_rsp, 0);

  0004f	33 d2		 xor	 edx, edx
  00051	48 8b 4c 24 58	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00056	e8 00 00 00 00	 call	 chsc_req_errreq
  0005b	e9 94 00 00 00	 jmp	 $LN1@z900_chsc_
$LN2@z900_chsc_:

; 474  : 
; 475  :     /* Fetch requested Subchannel Id */
; 476  :     FETCH_FW(ssid, chsc_req21->ssid);

  00060	48 8b 44 24 38	 mov	 rax, QWORD PTR chsc_req21$[rsp]
  00065	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00069	48 8b c8	 mov	 rcx, rax
  0006c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00071	8b c8		 mov	 ecx, eax
  00073	e8 00 00 00 00	 call	 _byteswap_ulong
  00078	89 44 24 28	 mov	 DWORD PTR ssid$[rsp], eax

; 477  : 
; 478  :     if((dev = find_device_by_subchan(ssid)))

  0007c	8b 4c 24 28	 mov	 ecx, DWORD PTR ssid$[rsp]
  00080	e8 00 00 00 00	 call	 find_device_by_subchan
  00085	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  0008a	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00090	74 50		 je	 SHORT $LN3@z900_chsc_

; 479  :         if(dev->hnd->ssci)

  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00097	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0009e	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  000a6	74 3a		 je	 SHORT $LN4@z900_chsc_

; 480  :             if(!(rc = (dev->hnd->ssci)(dev, chsc_req21)))

  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000ad	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000b4	48 8b 54 24 38	 mov	 rdx, QWORD PTR chsc_req21$[rsp]
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000be	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  000c4	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax
  000c8	83 7c 24 2c 00	 cmp	 DWORD PTR rc$[rsp], 0
  000cd	75 13		 jne	 SHORT $LN5@z900_chsc_

; 481  :                 return chsc_req_ok(chsc_rsp, sizeof(CHSC_RSP), 0);

  000cf	45 33 c0	 xor	 r8d, r8d
  000d2	66 ba 08 00	 mov	 dx, 8
  000d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000db	e8 00 00 00 00	 call	 chsc_req_ok
  000e0	eb 12		 jmp	 SHORT $LN1@z900_chsc_
$LN5@z900_chsc_:
$LN4@z900_chsc_:
$LN3@z900_chsc_:

; 482  : 
; 483  : //  return chsc_req_errreq(chsc_rsp, 0);
; 484  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  000e2	45 33 c0	 xor	 r8d, r8d
  000e5	0f b7 54 24 24	 movzx	 edx, WORD PTR rsp_len$[rsp]
  000ea	48 8b 4c 24 58	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000ef	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@z900_chsc_:

; 485  : }

  000f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f8	c3		 ret	 0
z900_chsc_set_sci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
max_rsp$ = 32
lcss$ = 36
sch$ = 40
work$ = 44
f_sch$ = 48
l_sch$ = 52
req_len$ = 56
rsp_len$ = 60
chsc_rsp24$ = 64
num_sch$ = 72
tv142 = 76
max_sch$ = 80
chsc_req24$ = 88
dev$1 = 96
chsc_req$ = 128
chsc_rsp$ = 136
z900_chsc_get_ssqd PROC

; 368  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 369  : U16 req_len, rsp_len, lcss, max_rsp, work;
; 370  : int sch, f_sch, l_sch, num_sch, max_sch;
; 371  : 
; 372  : CHSC_REQ24 *chsc_req24 = (CHSC_REQ24 *)(chsc_req);

  0000f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00017	48 89 44 24 58	 mov	 QWORD PTR chsc_req24$[rsp], rax

; 373  : CHSC_RSP24 *chsc_rsp24 = (CHSC_RSP24 *)(chsc_rsp+1);

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp24$[rsp], rax

; 374  : 
; 375  :     FETCH_HW(work,chsc_req24->f_sch); f_sch = work;

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req24$[rsp]
  00032	48 83 c0 06	 add	 rax, 6
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_hw_noswap
  0003e	0f b7 c8	 movzx	 ecx, ax
  00041	e8 00 00 00 00	 call	 _byteswap_ushort
  00046	66 89 44 24 2c	 mov	 WORD PTR work$[rsp], ax
  0004b	0f b7 44 24 2c	 movzx	 eax, WORD PTR work$[rsp]
  00050	89 44 24 30	 mov	 DWORD PTR f_sch$[rsp], eax

; 376  :     FETCH_HW(work,chsc_req24->l_sch); l_sch = work;

  00054	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req24$[rsp]
  00059	48 83 c0 0a	 add	 rax, 10
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 fetch_hw_noswap
  00065	0f b7 c8	 movzx	 ecx, ax
  00068	e8 00 00 00 00	 call	 _byteswap_ushort
  0006d	66 89 44 24 2c	 mov	 WORD PTR work$[rsp], ax
  00072	0f b7 44 24 2c	 movzx	 eax, WORD PTR work$[rsp]
  00077	89 44 24 34	 mov	 DWORD PTR l_sch$[rsp], eax

; 377  :     FETCH_HW(lcss,chsc_req24->ssidfmt);

  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req24$[rsp]
  00080	48 83 c0 04	 add	 rax, 4
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 fetch_hw_noswap
  0008c	0f b7 c8	 movzx	 ecx, ax
  0008f	e8 00 00 00 00	 call	 _byteswap_ushort
  00094	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 378  :     lcss &= CHSC_REQ24_SSID;

  00099	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  0009e	83 e0 30	 and	 eax, 48			; 00000030H
  000a1	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 379  :     lcss >>= 4;

  000a6	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  000ab	66 c1 e8 04	 shr	 ax, 4
  000af	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 380  : 
; 381  :     FETCH_HW(req_len, chsc_req24->length);

  000b4	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req24$[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 fetch_hw_noswap
  000c1	0f b7 c8	 movzx	 ecx, ax
  000c4	e8 00 00 00 00	 call	 _byteswap_ushort
  000c9	66 89 44 24 38	 mov	 WORD PTR req_len$[rsp], ax

; 382  : 
; 383  :     if (!(max_rsp = chsc_max_rsp(req_len, sizeof(CHSC_RSP24))) || l_sch < f_sch)

  000ce	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d3	0f b7 4c 24 38	 movzx	 ecx, WORD PTR req_len$[rsp]
  000d8	e8 00 00 00 00	 call	 chsc_max_rsp
  000dd	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  000e2	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  000e7	85 c0		 test	 eax, eax
  000e9	74 0a		 je	 SHORT $LN9@z900_chsc_
  000eb	8b 44 24 30	 mov	 eax, DWORD PTR f_sch$[rsp]
  000ef	39 44 24 34	 cmp	 DWORD PTR l_sch$[rsp], eax
  000f3	7d 14		 jge	 SHORT $LN8@z900_chsc_
$LN9@z900_chsc_:

; 384  :         return chsc_req_errreq(chsc_rsp, 0);

  000f5	33 d2		 xor	 edx, edx
  000f7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000ff	e8 00 00 00 00	 call	 chsc_req_errreq
  00104	e9 92 01 00 00	 jmp	 $LN1@z900_chsc_
$LN8@z900_chsc_:

; 385  : 
; 386  :     num_sch = (l_sch - f_sch) + 1;

  00109	8b 44 24 30	 mov	 eax, DWORD PTR f_sch$[rsp]
  0010d	8b 4c 24 34	 mov	 ecx, DWORD PTR l_sch$[rsp]
  00111	2b c8		 sub	 ecx, eax
  00113	8b c1		 mov	 eax, ecx
  00115	ff c0		 inc	 eax
  00117	89 44 24 48	 mov	 DWORD PTR num_sch$[rsp], eax

; 387  :     max_sch = sysblk.highsubchan[lcss]-1;

  0011b	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  00120	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00127	8b 84 81 e0 11
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4576]
  0012e	ff c8		 dec	 eax
  00130	89 44 24 50	 mov	 DWORD PTR max_sch$[rsp], eax

; 388  :     max_rsp = (U16) min((int)max_rsp, num_sch);

  00134	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00139	3b 44 24 48	 cmp	 eax, DWORD PTR num_sch$[rsp]
  0013d	7d 0b		 jge	 SHORT $LN16@z900_chsc_
  0013f	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00144	89 44 24 4c	 mov	 DWORD PTR tv142[rsp], eax
  00148	eb 08		 jmp	 SHORT $LN17@z900_chsc_
$LN16@z900_chsc_:
  0014a	8b 44 24 48	 mov	 eax, DWORD PTR num_sch$[rsp]
  0014e	89 44 24 4c	 mov	 DWORD PTR tv142[rsp], eax
$LN17@z900_chsc_:
  00152	0f b7 44 24 4c	 movzx	 eax, WORD PTR tv142[rsp]
  00157	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax

; 389  :     rsp_len = sizeof(CHSC_RSP) + (max_rsp * sizeof(CHSC_RSP24));

  0015c	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00161	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00165	48 83 c0 08	 add	 rax, 8
  00169	66 89 44 24 3c	 mov	 WORD PTR rsp_len$[rsp], ax

; 390  : 
; 391  :     if (f_sch <= max_sch)

  0016e	8b 44 24 50	 mov	 eax, DWORD PTR max_sch$[rsp]
  00172	39 44 24 30	 cmp	 DWORD PTR f_sch$[rsp], eax
  00176	0f 8f b8 00 00
	00		 jg	 $LN10@z900_chsc_

; 392  :     {
; 393  :     DEVBLK *dev;
; 394  : 
; 395  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp24++)

  0017c	8b 44 24 30	 mov	 eax, DWORD PTR f_sch$[rsp]
  00180	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00184	eb 25		 jmp	 SHORT $LN4@z900_chsc_
$LN2@z900_chsc_:
  00186	8b 44 24 28	 mov	 eax, DWORD PTR sch$[rsp]
  0018a	ff c0		 inc	 eax
  0018c	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00190	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00195	66 ff c8	 dec	 ax
  00198	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0019d	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp24$[rsp]
  001a2	48 83 c0 20	 add	 rax, 32			; 00000020H
  001a6	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp24$[rsp], rax
$LN4@z900_chsc_:
  001ab	8b 44 24 34	 mov	 eax, DWORD PTR l_sch$[rsp]
  001af	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  001b3	7f 7d		 jg	 SHORT $LN3@z900_chsc_
  001b5	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  001ba	85 c0		 test	 eax, eax
  001bc	74 74		 je	 SHORT $LN3@z900_chsc_

; 396  :         {
; 397  :             memset(chsc_rsp24, 0, sizeof(CHSC_RSP24) );

  001be	48 8b 7c 24 40	 mov	 rdi, QWORD PTR chsc_rsp24$[rsp]
  001c3	33 c0		 xor	 eax, eax
  001c5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001ca	f3 aa		 rep stosb

; 398  :             if (sch <= max_sch)

  001cc	8b 44 24 50	 mov	 eax, DWORD PTR max_sch$[rsp]
  001d0	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  001d4	7f 57		 jg	 SHORT $LN12@z900_chsc_

; 399  :             {
; 400  :                 if((dev = find_device_by_subchan((LCSS_TO_SSID(lcss) << 16)|sch)))

  001d6	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  001db	d1 e0		 shl	 eax, 1
  001dd	83 c8 01	 or	 eax, 1
  001e0	c1 e0 10	 shl	 eax, 16
  001e3	0b 44 24 28	 or	 eax, DWORD PTR sch$[rsp]
  001e7	8b c8		 mov	 ecx, eax
  001e9	e8 00 00 00 00	 call	 find_device_by_subchan
  001ee	48 89 44 24 60	 mov	 QWORD PTR dev$1[rsp], rax
  001f3	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$1[rsp], 0
  001f9	74 32		 je	 SHORT $LN13@z900_chsc_

; 401  :                     if(dev->hnd->ssqd)

  001fb	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$1[rsp]
  00200	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00207	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  0020f	74 1c		 je	 SHORT $LN14@z900_chsc_

; 402  :                         (dev->hnd->ssqd)(dev, chsc_rsp24);

  00211	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$1[rsp]
  00216	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0021d	48 8b 54 24 40	 mov	 rdx, QWORD PTR chsc_rsp24$[rsp]
  00222	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$1[rsp]
  00227	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]
$LN14@z900_chsc_:
$LN13@z900_chsc_:
$LN12@z900_chsc_:

; 403  :             }
; 404  :         }

  0022d	e9 54 ff ff ff	 jmp	 $LN2@z900_chsc_
$LN3@z900_chsc_:

; 405  :     }

  00232	eb 52		 jmp	 SHORT $LN11@z900_chsc_
$LN10@z900_chsc_:

; 406  :     else /* f_sch > max_sch */
; 407  :     {
; 408  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp24++)

  00234	8b 44 24 30	 mov	 eax, DWORD PTR f_sch$[rsp]
  00238	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  0023c	eb 25		 jmp	 SHORT $LN7@z900_chsc_
$LN5@z900_chsc_:
  0023e	8b 44 24 28	 mov	 eax, DWORD PTR sch$[rsp]
  00242	ff c0		 inc	 eax
  00244	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00248	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0024d	66 ff c8	 dec	 ax
  00250	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  00255	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp24$[rsp]
  0025a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0025e	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp24$[rsp], rax
$LN7@z900_chsc_:
  00263	8b 44 24 34	 mov	 eax, DWORD PTR l_sch$[rsp]
  00267	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  0026b	7f 19		 jg	 SHORT $LN6@z900_chsc_
  0026d	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00272	85 c0		 test	 eax, eax
  00274	74 10		 je	 SHORT $LN6@z900_chsc_

; 409  :             memset(chsc_rsp24, 0, sizeof(CHSC_RSP24) );

  00276	48 8b 7c 24 40	 mov	 rdi, QWORD PTR chsc_rsp24$[rsp]
  0027b	33 c0		 xor	 eax, eax
  0027d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00282	f3 aa		 rep stosb
  00284	eb b8		 jmp	 SHORT $LN5@z900_chsc_
$LN6@z900_chsc_:
$LN11@z900_chsc_:

; 410  :     }
; 411  : 
; 412  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  00286	45 33 c0	 xor	 r8d, r8d
  00289	0f b7 54 24 3c	 movzx	 edx, WORD PTR rsp_len$[rsp]
  0028e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00296	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@z900_chsc_:

; 413  : }

  0029b	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0029f	5f		 pop	 rdi
  002a0	c3		 ret	 0
z900_chsc_get_ssqd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
req_len$ = 32
rsp_len$ = 36
chsc_rsp10$ = 40
regs$ = 64
chsc_req$ = 72
chsc_rsp$ = 80
z900_chsc_get_css_info PROC

; 283  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 284  : CHSC_RSP10 *chsc_rsp10;
; 285  : U16 req_len, rsp_len;
; 286  : 
; 287  :     chsc_rsp10 = (CHSC_RSP10 *)(chsc_rsp+1);

  00014	48 8b 44 24 50	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00019	48 83 c0 08	 add	 rax, 8
  0001d	48 89 44 24 28	 mov	 QWORD PTR chsc_rsp10$[rsp], rax

; 288  : 
; 289  :     FETCH_HW(req_len, chsc_req->length);

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002f	0f b7 c8	 movzx	 ecx, ax
  00032	e8 00 00 00 00	 call	 _byteswap_ushort
  00037	66 89 44 24 20	 mov	 WORD PTR req_len$[rsp], ax

; 290  : 
; 291  :     rsp_len = sizeof(CHSC_RSP) + sizeof(CHSC_RSP10);

  0003c	b8 f0 0f 00 00	 mov	 eax, 4080		; 00000ff0H
  00041	66 89 44 24 24	 mov	 WORD PTR rsp_len$[rsp], ax

; 292  : 
; 293  :     if (!chsc_max_rsp(req_len, sizeof(CHSC_RSP10)))

  00046	ba e8 0f 00 00	 mov	 edx, 4072		; 00000fe8H
  0004b	0f b7 4c 24 20	 movzx	 ecx, WORD PTR req_len$[rsp]
  00050	e8 00 00 00 00	 call	 chsc_max_rsp
  00055	0f b7 c0	 movzx	 eax, ax
  00058	85 c0		 test	 eax, eax
  0005a	75 11		 jne	 SHORT $LN56@z900_chsc_

; 294  :         return chsc_req_errreq(chsc_rsp, 0);

  0005c	33 d2		 xor	 edx, edx
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00063	e8 00 00 00 00	 call	 chsc_req_errreq
  00068	e9 1a 06 00 00	 jmp	 $LN1@z900_chsc_
$LN56@z900_chsc_:

; 295  : 
; 296  :     memset(chsc_rsp10->general_char, 0, sizeof(chsc_rsp10->general_char));

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR chsc_rsp10$[rsp]
  00072	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00077	33 c0		 xor	 eax, eax
  00079	b9 f8 07 00 00	 mov	 ecx, 2040		; 000007f8H
  0007e	f3 aa		 rep stosb

; 297  :     memset(chsc_rsp10->chsc_char,    0, sizeof(chsc_rsp10->chsc_char));

  00080	48 8b 44 24 28	 mov	 rax, QWORD PTR chsc_rsp10$[rsp]
  00085	48 05 f8 07 00
	00		 add	 rax, 2040		; 000007f8H
  0008b	48 8b f8	 mov	 rdi, rax
  0008e	33 c0		 xor	 eax, eax
  00090	b9 f0 07 00 00	 mov	 ecx, 2032		; 000007f0H
  00095	f3 aa		 rep stosb
$LN4@z900_chsc_:

; 298  : 
; 299  : #if defined(FEATURE_REGION_RELOCATE)
; 300  :     CHSC_SB(chsc_rsp10->general_char,2);

  00097	b8 04 00 00 00	 mov	 eax, 4
  0009c	48 6b c0 00	 imul	 rax, rax, 0
  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  000a5	48 03 c8	 add	 rcx, rax
  000a8	48 8b c1	 mov	 rax, rcx
  000ab	b9 01 00 00 00	 mov	 ecx, 1
  000b0	48 6b c9 00	 imul	 rcx, rcx, 0
  000b4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000b8	83 c8 20	 or	 eax, 32			; 00000020H
  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	48 6b c9 00	 imul	 rcx, rcx, 0
  000c4	ba 04 00 00 00	 mov	 edx, 4
  000c9	48 6b d2 00	 imul	 rdx, rdx, 0
  000cd	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  000d2	48 03 fa	 add	 rdi, rdx
  000d5	48 8b d7	 mov	 rdx, rdi
  000d8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000db	33 c0		 xor	 eax, eax
  000dd	85 c0		 test	 eax, eax
  000df	75 b6		 jne	 SHORT $LN4@z900_chsc_
$LN7@z900_chsc_:

; 301  :     CHSC_SB(chsc_rsp10->general_char,5);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	48 6b c0 00	 imul	 rax, rax, 0
  000ea	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  000ef	48 03 c8	 add	 rcx, rax
  000f2	48 8b c1	 mov	 rax, rcx
  000f5	b9 01 00 00 00	 mov	 ecx, 1
  000fa	48 6b c9 00	 imul	 rcx, rcx, 0
  000fe	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00102	83 c8 04	 or	 eax, 4
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	48 6b c9 00	 imul	 rcx, rcx, 0
  0010e	ba 04 00 00 00	 mov	 edx, 4
  00113	48 6b d2 00	 imul	 rdx, rdx, 0
  00117	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  0011c	48 03 fa	 add	 rdi, rdx
  0011f	48 8b d7	 mov	 rdx, rdi
  00122	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00125	33 c0		 xor	 eax, eax
  00127	85 c0		 test	 eax, eax
  00129	75 b6		 jne	 SHORT $LN7@z900_chsc_
$LN10@z900_chsc_:

; 302  : #endif
; 303  : #if defined(FEATURE_CANCEL_IO_FACILITY)
; 304  :     CHSC_SB(chsc_rsp10->general_char,6);

  0012b	b8 04 00 00 00	 mov	 eax, 4
  00130	48 6b c0 00	 imul	 rax, rax, 0
  00134	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00139	48 03 c8	 add	 rcx, rax
  0013c	48 8b c1	 mov	 rax, rcx
  0013f	b9 01 00 00 00	 mov	 ecx, 1
  00144	48 6b c9 00	 imul	 rcx, rcx, 0
  00148	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0014c	83 c8 02	 or	 eax, 2
  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	48 6b c9 00	 imul	 rcx, rcx, 0
  00158	ba 04 00 00 00	 mov	 edx, 4
  0015d	48 6b d2 00	 imul	 rdx, rdx, 0
  00161	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00166	48 03 fa	 add	 rdi, rdx
  00169	48 8b d7	 mov	 rdx, rdi
  0016c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0016f	33 c0		 xor	 eax, eax
  00171	85 c0		 test	 eax, eax
  00173	75 b6		 jne	 SHORT $LN10@z900_chsc_
$LN13@z900_chsc_:

; 305  : #endif
; 306  : 
; 307  :     CHSC_SB(chsc_rsp10->general_char,7);         /* Concurrent Sense */

  00175	b8 04 00 00 00	 mov	 eax, 4
  0017a	48 6b c0 00	 imul	 rax, rax, 0
  0017e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00183	48 03 c8	 add	 rcx, rax
  00186	48 8b c1	 mov	 rax, rcx
  00189	b9 01 00 00 00	 mov	 ecx, 1
  0018e	48 6b c9 00	 imul	 rcx, rcx, 0
  00192	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00196	83 c8 01	 or	 eax, 1
  00199	b9 01 00 00 00	 mov	 ecx, 1
  0019e	48 6b c9 00	 imul	 rcx, rcx, 0
  001a2	ba 04 00 00 00	 mov	 edx, 4
  001a7	48 6b d2 00	 imul	 rdx, rdx, 0
  001ab	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  001b0	48 03 fa	 add	 rdi, rdx
  001b3	48 8b d7	 mov	 rdx, rdi
  001b6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001b9	33 c0		 xor	 eax, eax
  001bb	85 c0		 test	 eax, eax
  001bd	75 b6		 jne	 SHORT $LN13@z900_chsc_
$LN16@z900_chsc_:

; 308  :     CHSC_SB(chsc_rsp10->general_char,12);              /* Dynamic IO */

  001bf	b8 04 00 00 00	 mov	 eax, 4
  001c4	48 6b c0 00	 imul	 rax, rax, 0
  001c8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  001cd	48 03 c8	 add	 rcx, rax
  001d0	48 8b c1	 mov	 rax, rcx
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	48 6b c9 01	 imul	 rcx, rcx, 1
  001dc	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001e0	83 c8 08	 or	 eax, 8
  001e3	b9 01 00 00 00	 mov	 ecx, 1
  001e8	48 6b c9 01	 imul	 rcx, rcx, 1
  001ec	ba 04 00 00 00	 mov	 edx, 4
  001f1	48 6b d2 00	 imul	 rdx, rdx, 0
  001f5	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  001fa	48 03 fa	 add	 rdi, rdx
  001fd	48 8b d7	 mov	 rdx, rdi
  00200	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00203	33 c0		 xor	 eax, eax
  00205	85 c0		 test	 eax, eax
  00207	75 b6		 jne	 SHORT $LN16@z900_chsc_

; 309  : 
; 310  :     if (sysblk.lparmode)

  00209	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00210	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [rax+236]
  00216	83 e0 01	 and	 eax, 1
  00219	85 c0		 test	 eax, eax
  0021b	0f 84 94 00 00
	00		 je	 $LN57@z900_chsc_
$LN19@z900_chsc_:

; 311  :     {
; 312  :         CHSC_SB(chsc_rsp10->general_char,10);                 /* MIF */

  00221	b8 04 00 00 00	 mov	 eax, 4
  00226	48 6b c0 00	 imul	 rax, rax, 0
  0022a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  0022f	48 03 c8	 add	 rcx, rax
  00232	48 8b c1	 mov	 rax, rcx
  00235	b9 01 00 00 00	 mov	 ecx, 1
  0023a	48 6b c9 01	 imul	 rcx, rcx, 1
  0023e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00242	83 c8 20	 or	 eax, 32			; 00000020H
  00245	b9 01 00 00 00	 mov	 ecx, 1
  0024a	48 6b c9 01	 imul	 rcx, rcx, 1
  0024e	ba 04 00 00 00	 mov	 edx, 4
  00253	48 6b d2 00	 imul	 rdx, rdx, 0
  00257	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  0025c	48 03 fa	 add	 rdi, rdx
  0025f	48 8b d7	 mov	 rdx, rdi
  00262	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00265	33 c0		 xor	 eax, eax
  00267	85 c0		 test	 eax, eax
  00269	75 b6		 jne	 SHORT $LN19@z900_chsc_
$LN22@z900_chsc_:

; 313  :         CHSC_SB(chsc_rsp10->general_char,13);                /* LPAR */

  0026b	b8 04 00 00 00	 mov	 eax, 4
  00270	48 6b c0 00	 imul	 rax, rax, 0
  00274	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00279	48 03 c8	 add	 rcx, rax
  0027c	48 8b c1	 mov	 rax, rcx
  0027f	b9 01 00 00 00	 mov	 ecx, 1
  00284	48 6b c9 01	 imul	 rcx, rcx, 1
  00288	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0028c	83 c8 04	 or	 eax, 4
  0028f	b9 01 00 00 00	 mov	 ecx, 1
  00294	48 6b c9 01	 imul	 rcx, rcx, 1
  00298	ba 04 00 00 00	 mov	 edx, 4
  0029d	48 6b d2 00	 imul	 rdx, rdx, 0
  002a1	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  002a6	48 03 fa	 add	 rdi, rdx
  002a9	48 8b d7	 mov	 rdx, rdi
  002ac	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002af	33 c0		 xor	 eax, eax
  002b1	85 c0		 test	 eax, eax
  002b3	75 b6		 jne	 SHORT $LN22@z900_chsc_
$LN57@z900_chsc_:
$LN25@z900_chsc_:

; 314  :     }
; 315  : 
; 316  : #if defined(FEATURE_QUEUED_DIRECT_IO)
; 317  :     CHSC_SB(chsc_rsp10->general_char,41);         /* Adapter Int Fac */

  002b5	b8 04 00 00 00	 mov	 eax, 4
  002ba	48 6b c0 01	 imul	 rax, rax, 1
  002be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  002c3	48 03 c8	 add	 rcx, rax
  002c6	48 8b c1	 mov	 rax, rcx
  002c9	b9 01 00 00 00	 mov	 ecx, 1
  002ce	48 6b c9 01	 imul	 rcx, rcx, 1
  002d2	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002d6	83 c8 40	 or	 eax, 64			; 00000040H
  002d9	b9 01 00 00 00	 mov	 ecx, 1
  002de	48 6b c9 01	 imul	 rcx, rcx, 1
  002e2	ba 04 00 00 00	 mov	 edx, 4
  002e7	48 6b d2 01	 imul	 rdx, rdx, 1
  002eb	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  002f0	48 03 fa	 add	 rdi, rdx
  002f3	48 8b d7	 mov	 rdx, rdi
  002f6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002f9	33 c0		 xor	 eax, eax
  002fb	85 c0		 test	 eax, eax
  002fd	75 b6		 jne	 SHORT $LN25@z900_chsc_
$LN28@z900_chsc_:

; 318  : 
; 319  :     CHSC_SB(chsc_rsp10->chsc_char,1);            /* 0x0002 Supported */

  002ff	b8 04 00 00 00	 mov	 eax, 4
  00304	48 6b c0 00	 imul	 rax, rax, 0
  00308	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  0030d	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  00315	b9 01 00 00 00	 mov	 ecx, 1
  0031a	48 6b c9 00	 imul	 rcx, rcx, 0
  0031e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00322	83 c8 40	 or	 eax, 64			; 00000040H
  00325	b9 01 00 00 00	 mov	 ecx, 1
  0032a	48 6b c9 00	 imul	 rcx, rcx, 0
  0032e	ba 04 00 00 00	 mov	 edx, 4
  00333	48 6b d2 00	 imul	 rdx, rdx, 0
  00337	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  0033c	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  00344	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00347	33 c0		 xor	 eax, eax
  00349	85 c0		 test	 eax, eax
  0034b	75 b2		 jne	 SHORT $LN28@z900_chsc_
$LN31@z900_chsc_:

; 320  :     CHSC_SB(chsc_rsp10->chsc_char,2);            /* 0x0006 Supported */

  0034d	b8 04 00 00 00	 mov	 eax, 4
  00352	48 6b c0 00	 imul	 rax, rax, 0
  00356	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  0035b	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  00363	b9 01 00 00 00	 mov	 ecx, 1
  00368	48 6b c9 00	 imul	 rcx, rcx, 0
  0036c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00370	83 c8 20	 or	 eax, 32			; 00000020H
  00373	b9 01 00 00 00	 mov	 ecx, 1
  00378	48 6b c9 00	 imul	 rcx, rcx, 0
  0037c	ba 04 00 00 00	 mov	 edx, 4
  00381	48 6b d2 00	 imul	 rdx, rdx, 0
  00385	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  0038a	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  00392	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00395	33 c0		 xor	 eax, eax
  00397	85 c0		 test	 eax, eax
  00399	75 b2		 jne	 SHORT $LN31@z900_chsc_
$LN34@z900_chsc_:

; 321  :     CHSC_SB(chsc_rsp10->chsc_char,3);            /* 0x0004 Supported */

  0039b	b8 04 00 00 00	 mov	 eax, 4
  003a0	48 6b c0 00	 imul	 rax, rax, 0
  003a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  003a9	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  003b1	b9 01 00 00 00	 mov	 ecx, 1
  003b6	48 6b c9 00	 imul	 rcx, rcx, 0
  003ba	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003be	83 c8 10	 or	 eax, 16
  003c1	b9 01 00 00 00	 mov	 ecx, 1
  003c6	48 6b c9 00	 imul	 rcx, rcx, 0
  003ca	ba 04 00 00 00	 mov	 edx, 4
  003cf	48 6b d2 00	 imul	 rdx, rdx, 0
  003d3	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  003d8	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  003e0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003e3	33 c0		 xor	 eax, eax
  003e5	85 c0		 test	 eax, eax
  003e7	75 b2		 jne	 SHORT $LN34@z900_chsc_
$LN37@z900_chsc_:

; 322  :     CHSC_SB(chsc_rsp10->chsc_char,8);            /* 0x0024 Supported */

  003e9	b8 04 00 00 00	 mov	 eax, 4
  003ee	48 6b c0 00	 imul	 rax, rax, 0
  003f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  003f7	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  003ff	b9 01 00 00 00	 mov	 ecx, 1
  00404	48 6b c9 01	 imul	 rcx, rcx, 1
  00408	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0040c	0f ba e8 07	 bts	 eax, 7
  00410	b9 01 00 00 00	 mov	 ecx, 1
  00415	48 6b c9 01	 imul	 rcx, rcx, 1
  00419	ba 04 00 00 00	 mov	 edx, 4
  0041e	48 6b d2 00	 imul	 rdx, rdx, 0
  00422	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00427	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  0042f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00432	33 c0		 xor	 eax, eax
  00434	85 c0		 test	 eax, eax
  00436	75 b1		 jne	 SHORT $LN37@z900_chsc_

; 323  : 
; 324  :     if (FACILITY_ENABLED( HERC_QDIO_ASSIST, regs ))

  00438	b8 01 00 00 00	 mov	 eax, 1
  0043d	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00441	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00446	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0044e	83 e0 40	 and	 eax, 64			; 00000040H
  00451	85 c0		 test	 eax, eax
  00453	74 4a		 je	 SHORT $LN58@z900_chsc_
$LN40@z900_chsc_:

; 325  :         CHSC_SB(chsc_rsp10->general_char,61);         /* QDIO Assist */

  00455	b8 04 00 00 00	 mov	 eax, 4
  0045a	48 6b c0 01	 imul	 rax, rax, 1
  0045e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00463	48 03 c8	 add	 rcx, rax
  00466	48 8b c1	 mov	 rax, rcx
  00469	b9 01 00 00 00	 mov	 ecx, 1
  0046e	48 6b c9 03	 imul	 rcx, rcx, 3
  00472	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00476	83 c8 04	 or	 eax, 4
  00479	b9 01 00 00 00	 mov	 ecx, 1
  0047e	48 6b c9 03	 imul	 rcx, rcx, 3
  00482	ba 04 00 00 00	 mov	 edx, 4
  00487	48 6b d2 01	 imul	 rdx, rdx, 1
  0048b	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00490	48 03 fa	 add	 rdi, rdx
  00493	48 8b d7	 mov	 rdx, rdi
  00496	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00499	33 c0		 xor	 eax, eax
  0049b	85 c0		 test	 eax, eax
  0049d	75 b6		 jne	 SHORT $LN40@z900_chsc_
$LN58@z900_chsc_:

; 326  : #endif /*defined(FEATURE_QUEUED_DIRECT_IO)*/
; 327  : 
; 328  : #if defined(_FEATURE_QDIO_TDD)
; 329  :     if (FACILITY_ENABLED( HERC_QDIO_TDD, regs ))

  0049f	b8 01 00 00 00	 mov	 eax, 1
  004a4	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  004a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  004ad	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  004b5	83 e0 20	 and	 eax, 32			; 00000020H
  004b8	85 c0		 test	 eax, eax
  004ba	74 4b		 je	 SHORT $LN59@z900_chsc_
$LN43@z900_chsc_:

; 330  :         CHSC_SB(chsc_rsp10->general_char,56);  /* AIF Time Delay Dis */

  004bc	b8 04 00 00 00	 mov	 eax, 4
  004c1	48 6b c0 01	 imul	 rax, rax, 1
  004c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  004ca	48 03 c8	 add	 rcx, rax
  004cd	48 8b c1	 mov	 rax, rcx
  004d0	b9 01 00 00 00	 mov	 ecx, 1
  004d5	48 6b c9 03	 imul	 rcx, rcx, 3
  004d9	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  004dd	0f ba e8 07	 bts	 eax, 7
  004e1	b9 01 00 00 00	 mov	 ecx, 1
  004e6	48 6b c9 03	 imul	 rcx, rcx, 3
  004ea	ba 04 00 00 00	 mov	 edx, 4
  004ef	48 6b d2 01	 imul	 rdx, rdx, 1
  004f3	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  004f8	48 03 fa	 add	 rdi, rdx
  004fb	48 8b d7	 mov	 rdx, rdi
  004fe	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00501	33 c0		 xor	 eax, eax
  00503	85 c0		 test	 eax, eax
  00505	75 b5		 jne	 SHORT $LN43@z900_chsc_
$LN59@z900_chsc_:

; 331  : #endif /*defined(_FEATURE_QDIO_TDD)*/
; 332  : 
; 333  : #if defined(_FEATURE_QEBSM)
; 334  :     if (FACILITY_ENABLED( HERC_QEBSM, regs ))

  00507	b8 01 00 00 00	 mov	 eax, 1
  0050c	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00510	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00515	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0051d	83 e0 08	 and	 eax, 8
  00520	85 c0		 test	 eax, eax
  00522	0f 84 94 00 00
	00		 je	 $LN60@z900_chsc_
$LN46@z900_chsc_:

; 335  :     {
; 336  :         CHSC_SB(chsc_rsp10->general_char,58); /* SQBS/EQBS Available */

  00528	b8 04 00 00 00	 mov	 eax, 4
  0052d	48 6b c0 01	 imul	 rax, rax, 1
  00531	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00536	48 03 c8	 add	 rcx, rax
  00539	48 8b c1	 mov	 rax, rcx
  0053c	b9 01 00 00 00	 mov	 ecx, 1
  00541	48 6b c9 03	 imul	 rcx, rcx, 3
  00545	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00549	83 c8 20	 or	 eax, 32			; 00000020H
  0054c	b9 01 00 00 00	 mov	 ecx, 1
  00551	48 6b c9 03	 imul	 rcx, rcx, 3
  00555	ba 04 00 00 00	 mov	 edx, 4
  0055a	48 6b d2 01	 imul	 rdx, rdx, 1
  0055e	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00563	48 03 fa	 add	 rdi, rdx
  00566	48 8b d7	 mov	 rdx, rdi
  00569	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0056c	33 c0		 xor	 eax, eax
  0056e	85 c0		 test	 eax, eax
  00570	75 b6		 jne	 SHORT $LN46@z900_chsc_
$LN49@z900_chsc_:

; 337  :         CHSC_SB(chsc_rsp10->general_char,66); /* SQBS/EQBS Interpret */

  00572	b8 04 00 00 00	 mov	 eax, 4
  00577	48 6b c0 02	 imul	 rax, rax, 2
  0057b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00580	48 03 c8	 add	 rcx, rax
  00583	48 8b c1	 mov	 rax, rcx
  00586	b9 01 00 00 00	 mov	 ecx, 1
  0058b	48 6b c9 00	 imul	 rcx, rcx, 0
  0058f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00593	83 c8 20	 or	 eax, 32			; 00000020H
  00596	b9 01 00 00 00	 mov	 ecx, 1
  0059b	48 6b c9 00	 imul	 rcx, rcx, 0
  0059f	ba 04 00 00 00	 mov	 edx, 4
  005a4	48 6b d2 02	 imul	 rdx, rdx, 2
  005a8	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  005ad	48 03 fa	 add	 rdi, rdx
  005b0	48 8b d7	 mov	 rdx, rdi
  005b3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005b6	33 c0		 xor	 eax, eax
  005b8	85 c0		 test	 eax, eax
  005ba	75 b6		 jne	 SHORT $LN49@z900_chsc_
$LN60@z900_chsc_:

; 338  :     }
; 339  : #endif /*defined(_FEATURE_QEBSM)*/
; 340  : 
; 341  : #if defined(_FEATURE_QDIO_THININT)
; 342  :     if (FACILITY_ENABLED( HERC_QDIO_THININT, regs ))

  005bc	b8 01 00 00 00	 mov	 eax, 1
  005c1	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  005c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  005ca	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  005d2	83 e0 10	 and	 eax, 16
  005d5	85 c0		 test	 eax, eax
  005d7	0f 84 98 00 00
	00		 je	 $LN61@z900_chsc_
$LN52@z900_chsc_:

; 343  :     {
; 344  :         CHSC_SB(chsc_rsp10->general_char,67);   /* OSA/FCP Thin Ints */

  005dd	b8 04 00 00 00	 mov	 eax, 4
  005e2	48 6b c0 02	 imul	 rax, rax, 2
  005e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  005eb	48 03 c8	 add	 rcx, rax
  005ee	48 8b c1	 mov	 rax, rcx
  005f1	b9 01 00 00 00	 mov	 ecx, 1
  005f6	48 6b c9 00	 imul	 rcx, rcx, 0
  005fa	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  005fe	83 c8 10	 or	 eax, 16
  00601	b9 01 00 00 00	 mov	 ecx, 1
  00606	48 6b c9 00	 imul	 rcx, rcx, 0
  0060a	ba 04 00 00 00	 mov	 edx, 4
  0060f	48 6b d2 02	 imul	 rdx, rdx, 2
  00613	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00618	48 03 fa	 add	 rdi, rdx
  0061b	48 8b d7	 mov	 rdx, rdi
  0061e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00621	33 c0		 xor	 eax, eax
  00623	85 c0		 test	 eax, eax
  00625	75 b6		 jne	 SHORT $LN52@z900_chsc_
$LN55@z900_chsc_:

; 345  :         CHSC_SB(chsc_rsp10->chsc_char,107);      /* 0x0021 Supported */

  00627	b8 04 00 00 00	 mov	 eax, 4
  0062c	48 6b c0 03	 imul	 rax, rax, 3
  00630	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00635	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  0063d	b9 01 00 00 00	 mov	 ecx, 1
  00642	48 6b c9 01	 imul	 rcx, rcx, 1
  00646	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0064a	83 c8 10	 or	 eax, 16
  0064d	b9 01 00 00 00	 mov	 ecx, 1
  00652	48 6b c9 01	 imul	 rcx, rcx, 1
  00656	ba 04 00 00 00	 mov	 edx, 4
  0065b	48 6b d2 03	 imul	 rdx, rdx, 3
  0065f	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00664	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  0066c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0066f	33 c0		 xor	 eax, eax
  00671	85 c0		 test	 eax, eax
  00673	75 b2		 jne	 SHORT $LN55@z900_chsc_
$LN61@z900_chsc_:

; 346  :     }
; 347  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 348  : 
; 349  : //  CHSC_SB(chsc_rsp10->general_char,45);            /* Multiple CSS */
; 350  : //  CHSC_SB(chsc_rsp10->general_char,64);        /* QDIO Multiple CU */
; 351  : //  CHSC_SB(chsc_rsp10->general_char,65);      /* OSA System Console */
; 352  : //  CHSC_SB(chsc_rsp10->general_char,82);                     /* CIB */
; 353  : //  CHSC_SB(chsc_rsp10->general_char,88);                     /* FCX */
; 354  : 
; 355  : //  CHSC_SB(chsc_rsp10->chsc_char,84);                       /* SECM */
; 356  : //  CHSC_SB(chsc_rsp10->chsc_char,86);                       /* SCMC */
; 357  : //  CHSC_SB(chsc_rsp10->chsc_char,107);   /* Set Channel Subsys Char */
; 358  : //  CHSC_SB(chsc_rsp10->chsc_char,108);                /* Fast CHSCs */
; 359  : 
; 360  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  00675	45 33 c0	 xor	 r8d, r8d
  00678	0f b7 54 24 24	 movzx	 edx, WORD PTR rsp_len$[rsp]
  0067d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00682	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@z900_chsc_:

; 361  : }

  00687	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0068b	5f		 pop	 rdi
  0068c	c3		 ret	 0
z900_chsc_get_css_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
max_rsp$ = 32
sch$ = 36
lcss$ = 40
chsc_rsp6$ = 48
work$ = 56
n$1 = 60
f_sch$ = 64
l_sch$ = 68
dev$2 = 72
req_len$ = 80
cun$ = 84
rsp_len$ = 88
num_sch$ = 92
tv141 = 96
max_sch$ = 100
chsc_req6$ = 104
chsc_req$ = 128
chsc_rsp$ = 136
z900_chsc_get_cu_desc PROC

; 214  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 215  : U16 req_len, rsp_len, lcss, cun, max_rsp, work;
; 216  : int sch, f_sch, l_sch, num_sch, max_sch;
; 217  : 
; 218  : CHSC_REQ6 *chsc_req6 = (CHSC_REQ6 *)(chsc_req);

  0000f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00017	48 89 44 24 68	 mov	 QWORD PTR chsc_req6$[rsp], rax

; 219  : CHSC_RSP6 *chsc_rsp6 = (CHSC_RSP6 *)(chsc_rsp+1);

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp6$[rsp], rax

; 220  : 
; 221  :     FETCH_HW(work,chsc_req6->f_sch); f_sch = work;

  0002d	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req6$[rsp]
  00032	48 83 c0 06	 add	 rax, 6
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_hw_noswap
  0003e	0f b7 c8	 movzx	 ecx, ax
  00041	e8 00 00 00 00	 call	 _byteswap_ushort
  00046	66 89 44 24 38	 mov	 WORD PTR work$[rsp], ax
  0004b	0f b7 44 24 38	 movzx	 eax, WORD PTR work$[rsp]
  00050	89 44 24 40	 mov	 DWORD PTR f_sch$[rsp], eax

; 222  :     FETCH_HW(work,chsc_req6->l_sch); l_sch = work;

  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req6$[rsp]
  00059	48 83 c0 0a	 add	 rax, 10
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 fetch_hw_noswap
  00065	0f b7 c8	 movzx	 ecx, ax
  00068	e8 00 00 00 00	 call	 _byteswap_ushort
  0006d	66 89 44 24 38	 mov	 WORD PTR work$[rsp], ax
  00072	0f b7 44 24 38	 movzx	 eax, WORD PTR work$[rsp]
  00077	89 44 24 44	 mov	 DWORD PTR l_sch$[rsp], eax

; 223  :     FETCH_HW(lcss,chsc_req6->ssidfmt);

  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req6$[rsp]
  00080	48 83 c0 04	 add	 rax, 4
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 fetch_hw_noswap
  0008c	0f b7 c8	 movzx	 ecx, ax
  0008f	e8 00 00 00 00	 call	 _byteswap_ushort
  00094	66 89 44 24 28	 mov	 WORD PTR lcss$[rsp], ax

; 224  :     lcss &= CHSC_REQ6_SSID;

  00099	0f b7 44 24 28	 movzx	 eax, WORD PTR lcss$[rsp]
  0009e	83 e0 03	 and	 eax, 3
  000a1	66 89 44 24 28	 mov	 WORD PTR lcss$[rsp], ax

; 225  : //  lcss >>= 0;
; 226  : 
; 227  :     FETCH_HW(req_len, chsc_req6->length);

  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req6$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	e8 00 00 00 00	 call	 fetch_hw_noswap
  000b3	0f b7 c8	 movzx	 ecx, ax
  000b6	e8 00 00 00 00	 call	 _byteswap_ushort
  000bb	66 89 44 24 50	 mov	 WORD PTR req_len$[rsp], ax

; 228  : 
; 229  :     if (!(max_rsp = chsc_max_rsp(req_len, sizeof(CHSC_RSP6))) || l_sch < f_sch)

  000c0	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000c5	0f b7 4c 24 50	 movzx	 ecx, WORD PTR req_len$[rsp]
  000ca	e8 00 00 00 00	 call	 chsc_max_rsp
  000cf	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  000d4	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  000d9	85 c0		 test	 eax, eax
  000db	74 0a		 je	 SHORT $LN12@z900_chsc_
  000dd	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  000e1	39 44 24 44	 cmp	 DWORD PTR l_sch$[rsp], eax
  000e5	7d 14		 jge	 SHORT $LN11@z900_chsc_
$LN12@z900_chsc_:

; 230  :         return chsc_req_errreq(chsc_rsp, 0);

  000e7	33 d2		 xor	 edx, edx
  000e9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000f1	e8 00 00 00 00	 call	 chsc_req_errreq
  000f6	e9 b9 02 00 00	 jmp	 $LN1@z900_chsc_
$LN11@z900_chsc_:

; 231  : 
; 232  :     num_sch = (l_sch - f_sch) + 1;

  000fb	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  000ff	8b 4c 24 44	 mov	 ecx, DWORD PTR l_sch$[rsp]
  00103	2b c8		 sub	 ecx, eax
  00105	8b c1		 mov	 eax, ecx
  00107	ff c0		 inc	 eax
  00109	89 44 24 5c	 mov	 DWORD PTR num_sch$[rsp], eax

; 233  :     max_sch = sysblk.highsubchan[lcss]-1;

  0010d	0f b7 44 24 28	 movzx	 eax, WORD PTR lcss$[rsp]
  00112	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00119	8b 84 81 e0 11
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4576]
  00120	ff c8		 dec	 eax
  00122	89 44 24 64	 mov	 DWORD PTR max_sch$[rsp], eax

; 234  :     max_rsp = (U16) min((int)max_rsp, num_sch);

  00126	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0012b	3b 44 24 5c	 cmp	 eax, DWORD PTR num_sch$[rsp]
  0012f	7d 0b		 jge	 SHORT $LN20@z900_chsc_
  00131	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00136	89 44 24 60	 mov	 DWORD PTR tv141[rsp], eax
  0013a	eb 08		 jmp	 SHORT $LN21@z900_chsc_
$LN20@z900_chsc_:
  0013c	8b 44 24 5c	 mov	 eax, DWORD PTR num_sch$[rsp]
  00140	89 44 24 60	 mov	 DWORD PTR tv141[rsp], eax
$LN21@z900_chsc_:
  00144	0f b7 44 24 60	 movzx	 eax, WORD PTR tv141[rsp]
  00149	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax

; 235  :     rsp_len = sizeof(CHSC_RSP) + (max_rsp * sizeof(CHSC_RSP6));

  0014e	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00153	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00157	48 83 c0 08	 add	 rax, 8
  0015b	66 89 44 24 58	 mov	 WORD PTR rsp_len$[rsp], ax

; 236  : 
; 237  :     if (f_sch <= max_sch)

  00160	8b 44 24 64	 mov	 eax, DWORD PTR max_sch$[rsp]
  00164	39 44 24 40	 cmp	 DWORD PTR f_sch$[rsp], eax
  00168	0f 8f df 01 00
	00		 jg	 $LN13@z900_chsc_

; 238  :     {
; 239  :     DEVBLK *dev;
; 240  : 
; 241  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp6++)

  0016e	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  00172	89 44 24 24	 mov	 DWORD PTR sch$[rsp], eax
  00176	eb 25		 jmp	 SHORT $LN4@z900_chsc_
$LN2@z900_chsc_:
  00178	8b 44 24 24	 mov	 eax, DWORD PTR sch$[rsp]
  0017c	ff c0		 inc	 eax
  0017e	89 44 24 24	 mov	 DWORD PTR sch$[rsp], eax
  00182	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00187	66 ff c8	 dec	 ax
  0018a	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0018f	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00194	48 83 c0 20	 add	 rax, 32			; 00000020H
  00198	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp6$[rsp], rax
$LN4@z900_chsc_:
  0019d	8b 44 24 44	 mov	 eax, DWORD PTR l_sch$[rsp]
  001a1	39 44 24 24	 cmp	 DWORD PTR sch$[rsp], eax
  001a5	0f 8f a0 01 00
	00		 jg	 $LN3@z900_chsc_
  001ab	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  001b0	85 c0		 test	 eax, eax
  001b2	0f 84 93 01 00
	00		 je	 $LN3@z900_chsc_

; 242  :         {
; 243  :             memset(chsc_rsp6, 0, sizeof(CHSC_RSP6) );

  001b8	48 8b 7c 24 30	 mov	 rdi, QWORD PTR chsc_rsp6$[rsp]
  001bd	33 c0		 xor	 eax, eax
  001bf	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001c4	f3 aa		 rep stosb

; 244  :             if (sch <= max_sch)

  001c6	8b 44 24 64	 mov	 eax, DWORD PTR max_sch$[rsp]
  001ca	39 44 24 24	 cmp	 DWORD PTR sch$[rsp], eax
  001ce	0f 8f 72 01 00
	00		 jg	 $LN15@z900_chsc_

; 245  :             {
; 246  :                 if((dev = find_device_by_subchan((LCSS_TO_SSID(lcss) << 16)|sch)))

  001d4	0f b7 44 24 28	 movzx	 eax, WORD PTR lcss$[rsp]
  001d9	d1 e0		 shl	 eax, 1
  001db	83 c8 01	 or	 eax, 1
  001de	c1 e0 10	 shl	 eax, 16
  001e1	0b 44 24 24	 or	 eax, DWORD PTR sch$[rsp]
  001e5	8b c8		 mov	 ecx, eax
  001e7	e8 00 00 00 00	 call	 find_device_by_subchan
  001ec	48 89 44 24 48	 mov	 QWORD PTR dev$2[rsp], rax
  001f1	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$2[rsp], 0
  001f7	0f 84 49 01 00
	00		 je	 $LN16@z900_chsc_

; 247  :                 {
; 248  :                     int n;
; 249  :                     chsc_rsp6->flags1 |= CHSC_RSP6_F1_SCH_VALID;

  001fd	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00202	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00205	0f ba e8 07	 bts	 eax, 7
  00209	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  0020e	88 01		 mov	 BYTE PTR [rcx], al

; 250  :                     if(dev->pmcw.flag5 & PMCW5_V)

  00210	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00215	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0021c	83 e0 01	 and	 eax, 1
  0021f	85 c0		 test	 eax, eax
  00221	74 12		 je	 SHORT $LN17@z900_chsc_

; 251  :                         chsc_rsp6->flags1 |= CHSC_RSP6_F1_DEV_VALID;

  00223	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00228	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0022b	83 c8 40	 or	 eax, 64			; 00000040H
  0022e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  00233	88 01		 mov	 BYTE PTR [rcx], al
$LN17@z900_chsc_:

; 252  :                     chsc_rsp6->flags1 |= ((dev->pmcw.flag25 & PMCW25_TYPE) >> 2);

  00235	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  0023a	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  00241	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  00246	c1 f8 02	 sar	 eax, 2
  00249	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  0024e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00251	0b c8		 or	 ecx, eax
  00253	8b c1		 mov	 eax, ecx
  00255	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  0025a	88 01		 mov	 BYTE PTR [rcx], al

; 253  :                     chsc_rsp6->path_mask = dev->pmcw.pim;

  0025c	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00261	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  00266	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  0026d	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 254  :                     STORE_HW(chsc_rsp6->devnum,dev->devnum);

  00270	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00275	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  00279	e8 00 00 00 00	 call	 _byteswap_ushort
  0027e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  00283	48 83 c1 02	 add	 rcx, 2
  00287	0f b7 d0	 movzx	 edx, ax
  0028a	e8 00 00 00 00	 call	 store_hw_noswap

; 255  :                     STORE_HW(chsc_rsp6->sch, sch);

  0028f	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sch$[rsp]
  00294	e8 00 00 00 00	 call	 _byteswap_ushort
  00299	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  0029e	48 83 c1 06	 add	 rcx, 6
  002a2	0f b7 d0	 movzx	 edx, ax
  002a5	e8 00 00 00 00	 call	 store_hw_noswap

; 256  :                     memcpy(chsc_rsp6->chpid, dev->pmcw.chpid, 8);

  002aa	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  002af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  002b4	48 8b 89 fc 02
	00 00		 mov	 rcx, QWORD PTR [rcx+764]
  002bb	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 257  :                     for(n = 0; n < 8; n++)

  002bf	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  002c7	eb 0a		 jmp	 SHORT $LN7@z900_chsc_
$LN5@z900_chsc_:
  002c9	8b 44 24 3c	 mov	 eax, DWORD PTR n$1[rsp]
  002cd	ff c0		 inc	 eax
  002cf	89 44 24 3c	 mov	 DWORD PTR n$1[rsp], eax
$LN7@z900_chsc_:
  002d3	83 7c 24 3c 08	 cmp	 DWORD PTR n$1[rsp], 8
  002d8	7d 6c		 jge	 SHORT $LN6@z900_chsc_

; 258  :                     {
; 259  :                         if(dev->pmcw.pim & (0x80 >> n))

  002da	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  002df	0f b6 80 f7 02
	00 00		 movzx	 eax, BYTE PTR [rax+759]
  002e6	8b 4c 24 3c	 mov	 ecx, DWORD PTR n$1[rsp]
  002ea	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  002ef	d3 fa		 sar	 edx, cl
  002f1	8b ca		 mov	 ecx, edx
  002f3	23 c1		 and	 eax, ecx
  002f5	85 c0		 test	 eax, eax
  002f7	74 4b		 je	 SHORT $LN18@z900_chsc_

; 260  :                         {
; 261  :                             cun = ((dev->devnum & 0x00F0) << 4) | dev->pmcw.chpid[n];

  002f9	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  002fe	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00302	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00307	c1 e0 04	 shl	 eax, 4
  0030a	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR n$1[rsp]
  0030f	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$2[rsp]
  00314	0f b6 8c 0a fc
	02 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+764]
  0031c	0b c1		 or	 eax, ecx
  0031e	66 89 44 24 54	 mov	 WORD PTR cun$[rsp], ax

; 262  :                             STORE_HW(chsc_rsp6->cun[n], cun);

  00323	0f b7 4c 24 54	 movzx	 ecx, WORD PTR cun$[rsp]
  00328	e8 00 00 00 00	 call	 _byteswap_ushort
  0032d	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR n$1[rsp]
  00332	48 8b 54 24 30	 mov	 rdx, QWORD PTR chsc_rsp6$[rsp]
  00337	48 8d 4c 4a 10	 lea	 rcx, QWORD PTR [rdx+rcx*2+16]
  0033c	0f b7 d0	 movzx	 edx, ax
  0033f	e8 00 00 00 00	 call	 store_hw_noswap
$LN18@z900_chsc_:

; 263  :                         }
; 264  :                     }

  00344	eb 83		 jmp	 SHORT $LN5@z900_chsc_
$LN6@z900_chsc_:
$LN16@z900_chsc_:
$LN15@z900_chsc_:

; 265  :                 }
; 266  :             }
; 267  :         }

  00346	e9 2d fe ff ff	 jmp	 $LN2@z900_chsc_
$LN3@z900_chsc_:

; 268  :     }

  0034b	eb 52		 jmp	 SHORT $LN14@z900_chsc_
$LN13@z900_chsc_:

; 269  :     else /* f_sch > max_sch */
; 270  :     {
; 271  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp6++)

  0034d	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  00351	89 44 24 24	 mov	 DWORD PTR sch$[rsp], eax
  00355	eb 25		 jmp	 SHORT $LN10@z900_chsc_
$LN8@z900_chsc_:
  00357	8b 44 24 24	 mov	 eax, DWORD PTR sch$[rsp]
  0035b	ff c0		 inc	 eax
  0035d	89 44 24 24	 mov	 DWORD PTR sch$[rsp], eax
  00361	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00366	66 ff c8	 dec	 ax
  00369	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0036e	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00373	48 83 c0 20	 add	 rax, 32			; 00000020H
  00377	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp6$[rsp], rax
$LN10@z900_chsc_:
  0037c	8b 44 24 44	 mov	 eax, DWORD PTR l_sch$[rsp]
  00380	39 44 24 24	 cmp	 DWORD PTR sch$[rsp], eax
  00384	7f 19		 jg	 SHORT $LN9@z900_chsc_
  00386	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0038b	85 c0		 test	 eax, eax
  0038d	74 10		 je	 SHORT $LN9@z900_chsc_

; 272  :             memset(chsc_rsp6, 0, sizeof(CHSC_RSP6) );

  0038f	48 8b 7c 24 30	 mov	 rdi, QWORD PTR chsc_rsp6$[rsp]
  00394	33 c0		 xor	 eax, eax
  00396	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0039b	f3 aa		 rep stosb
  0039d	eb b8		 jmp	 SHORT $LN8@z900_chsc_
$LN9@z900_chsc_:
$LN14@z900_chsc_:

; 273  :     }
; 274  : 
; 275  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  0039f	45 33 c0	 xor	 r8d, r8d
  003a2	0f b7 54 24 58	 movzx	 edx, WORD PTR rsp_len$[rsp]
  003a7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  003af	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@z900_chsc_:

; 276  : }

  003b4	48 83 c4 70	 add	 rsp, 112		; 00000070H
  003b8	5f		 pop	 rdi
  003b9	c3		 ret	 0
z900_chsc_get_cu_desc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
max_rsp$ = 32
lcss$ = 36
sch$ = 40
chsc_rsp4$ = 48
work$ = 56
n$1 = 60
f_sch$ = 64
dev$2 = 72
l_sch$ = 80
req_len$ = 84
rsp_len$ = 88
num_sch$ = 92
tv142 = 96
max_sch$ = 100
chsc_req4$ = 104
chsc_req$ = 128
chsc_rsp$ = 136
z900_chsc_get_sch_desc PROC

; 145  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 146  : U16 req_len, rsp_len, lcss, max_rsp, work;
; 147  : int sch, f_sch, l_sch, num_sch, max_sch;
; 148  : 
; 149  : CHSC_REQ4 *chsc_req4 = (CHSC_REQ4 *)(chsc_req);

  0000f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00017	48 89 44 24 68	 mov	 QWORD PTR chsc_req4$[rsp], rax

; 150  : CHSC_RSP4 *chsc_rsp4 = (CHSC_RSP4 *)(chsc_rsp+1);

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp4$[rsp], rax

; 151  : 
; 152  :     FETCH_HW(work,chsc_req4->f_sch); f_sch = work;

  0002d	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req4$[rsp]
  00032	48 83 c0 06	 add	 rax, 6
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_hw_noswap
  0003e	0f b7 c8	 movzx	 ecx, ax
  00041	e8 00 00 00 00	 call	 _byteswap_ushort
  00046	66 89 44 24 38	 mov	 WORD PTR work$[rsp], ax
  0004b	0f b7 44 24 38	 movzx	 eax, WORD PTR work$[rsp]
  00050	89 44 24 40	 mov	 DWORD PTR f_sch$[rsp], eax

; 153  :     FETCH_HW(work,chsc_req4->l_sch); l_sch = work;

  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req4$[rsp]
  00059	48 83 c0 0a	 add	 rax, 10
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 fetch_hw_noswap
  00065	0f b7 c8	 movzx	 ecx, ax
  00068	e8 00 00 00 00	 call	 _byteswap_ushort
  0006d	66 89 44 24 38	 mov	 WORD PTR work$[rsp], ax
  00072	0f b7 44 24 38	 movzx	 eax, WORD PTR work$[rsp]
  00077	89 44 24 50	 mov	 DWORD PTR l_sch$[rsp], eax

; 154  :     FETCH_HW(lcss,chsc_req4->ssidfmt);

  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req4$[rsp]
  00080	48 83 c0 04	 add	 rax, 4
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 fetch_hw_noswap
  0008c	0f b7 c8	 movzx	 ecx, ax
  0008f	e8 00 00 00 00	 call	 _byteswap_ushort
  00094	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 155  :     lcss &= CHSC_REQ4_SSID;

  00099	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  0009e	83 e0 30	 and	 eax, 48			; 00000030H
  000a1	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 156  :     lcss >>= 4;

  000a6	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  000ab	66 c1 e8 04	 shr	 ax, 4
  000af	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 157  : 
; 158  :     FETCH_HW(req_len, chsc_req4->length);

  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req4$[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 fetch_hw_noswap
  000c1	0f b7 c8	 movzx	 ecx, ax
  000c4	e8 00 00 00 00	 call	 _byteswap_ushort
  000c9	66 89 44 24 54	 mov	 WORD PTR req_len$[rsp], ax

; 159  : 
; 160  :     if (!(max_rsp = chsc_max_rsp(req_len, sizeof(CHSC_RSP4))) || l_sch < f_sch)

  000ce	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d3	0f b7 4c 24 54	 movzx	 ecx, WORD PTR req_len$[rsp]
  000d8	e8 00 00 00 00	 call	 chsc_max_rsp
  000dd	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  000e2	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  000e7	85 c0		 test	 eax, eax
  000e9	74 0a		 je	 SHORT $LN12@z900_chsc_
  000eb	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  000ef	39 44 24 50	 cmp	 DWORD PTR l_sch$[rsp], eax
  000f3	7d 14		 jge	 SHORT $LN11@z900_chsc_
$LN12@z900_chsc_:

; 161  :         return chsc_req_errreq(chsc_rsp, 0);

  000f5	33 d2		 xor	 edx, edx
  000f7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000ff	e8 00 00 00 00	 call	 chsc_req_errreq
  00104	e9 e0 02 00 00	 jmp	 $LN1@z900_chsc_
$LN11@z900_chsc_:

; 162  : 
; 163  :     num_sch = (l_sch - f_sch) + 1;

  00109	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  0010d	8b 4c 24 50	 mov	 ecx, DWORD PTR l_sch$[rsp]
  00111	2b c8		 sub	 ecx, eax
  00113	8b c1		 mov	 eax, ecx
  00115	ff c0		 inc	 eax
  00117	89 44 24 5c	 mov	 DWORD PTR num_sch$[rsp], eax

; 164  :     max_sch = sysblk.highsubchan[lcss]-1;

  0011b	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  00120	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00127	8b 84 81 e0 11
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4576]
  0012e	ff c8		 dec	 eax
  00130	89 44 24 64	 mov	 DWORD PTR max_sch$[rsp], eax

; 165  :     max_rsp = (U16) min((int)max_rsp, num_sch);

  00134	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00139	3b 44 24 5c	 cmp	 eax, DWORD PTR num_sch$[rsp]
  0013d	7d 0b		 jge	 SHORT $LN21@z900_chsc_
  0013f	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00144	89 44 24 60	 mov	 DWORD PTR tv142[rsp], eax
  00148	eb 08		 jmp	 SHORT $LN22@z900_chsc_
$LN21@z900_chsc_:
  0014a	8b 44 24 5c	 mov	 eax, DWORD PTR num_sch$[rsp]
  0014e	89 44 24 60	 mov	 DWORD PTR tv142[rsp], eax
$LN22@z900_chsc_:
  00152	0f b7 44 24 60	 movzx	 eax, WORD PTR tv142[rsp]
  00157	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax

; 166  :     rsp_len = sizeof(CHSC_RSP) + (max_rsp * sizeof(CHSC_RSP4));

  0015c	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00161	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00165	48 83 c0 08	 add	 rax, 8
  00169	66 89 44 24 58	 mov	 WORD PTR rsp_len$[rsp], ax

; 167  : 
; 168  :     if (f_sch <= max_sch)

  0016e	8b 44 24 64	 mov	 eax, DWORD PTR max_sch$[rsp]
  00172	39 44 24 40	 cmp	 DWORD PTR f_sch$[rsp], eax
  00176	0f 8f 06 02 00
	00		 jg	 $LN13@z900_chsc_

; 169  :     {
; 170  :     DEVBLK *dev;
; 171  : 
; 172  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp4++)

  0017c	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  00180	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00184	eb 25		 jmp	 SHORT $LN4@z900_chsc_
$LN2@z900_chsc_:
  00186	8b 44 24 28	 mov	 eax, DWORD PTR sch$[rsp]
  0018a	ff c0		 inc	 eax
  0018c	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00190	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00195	66 ff c8	 dec	 ax
  00198	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0019d	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  001a2	48 83 c0 20	 add	 rax, 32			; 00000020H
  001a6	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp4$[rsp], rax
$LN4@z900_chsc_:
  001ab	8b 44 24 50	 mov	 eax, DWORD PTR l_sch$[rsp]
  001af	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  001b3	0f 8f c7 01 00
	00		 jg	 $LN3@z900_chsc_
  001b9	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  001be	85 c0		 test	 eax, eax
  001c0	0f 84 ba 01 00
	00		 je	 $LN3@z900_chsc_

; 173  :         {
; 174  :             memset(chsc_rsp4, 0, sizeof(CHSC_RSP4) );

  001c6	48 8b 7c 24 30	 mov	 rdi, QWORD PTR chsc_rsp4$[rsp]
  001cb	33 c0		 xor	 eax, eax
  001cd	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001d2	f3 aa		 rep stosb

; 175  :             if (sch <= max_sch)

  001d4	8b 44 24 64	 mov	 eax, DWORD PTR max_sch$[rsp]
  001d8	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  001dc	0f 8f 99 01 00
	00		 jg	 $LN15@z900_chsc_

; 176  :             {
; 177  :                 if((dev = find_device_by_subchan((LCSS_TO_SSID(lcss) << 16)|sch)))

  001e2	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  001e7	d1 e0		 shl	 eax, 1
  001e9	83 c8 01	 or	 eax, 1
  001ec	c1 e0 10	 shl	 eax, 16
  001ef	0b 44 24 28	 or	 eax, DWORD PTR sch$[rsp]
  001f3	8b c8		 mov	 ecx, eax
  001f5	e8 00 00 00 00	 call	 find_device_by_subchan
  001fa	48 89 44 24 48	 mov	 QWORD PTR dev$2[rsp], rax
  001ff	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$2[rsp], 0
  00205	0f 84 70 01 00
	00		 je	 $LN16@z900_chsc_

; 178  :                 {
; 179  :                     int n;
; 180  :                     chsc_rsp4->flags1 |= CHSC_RSP4_F1_SCH_VALID;

  0020b	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  00210	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00213	0f ba e8 07	 bts	 eax, 7
  00217	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  0021c	88 01		 mov	 BYTE PTR [rcx], al

; 181  :                     if(dev->pmcw.flag5 & PMCW5_V)

  0021e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00223	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0022a	83 e0 01	 and	 eax, 1
  0022d	85 c0		 test	 eax, eax
  0022f	74 12		 je	 SHORT $LN17@z900_chsc_

; 182  :                         chsc_rsp4->flags1 |= CHSC_RSP4_F1_DEV_VALID;

  00231	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  00236	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00239	83 c8 40	 or	 eax, 64			; 00000040H
  0023c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  00241	88 01		 mov	 BYTE PTR [rcx], al
$LN17@z900_chsc_:

; 183  :                     chsc_rsp4->flags1 |= ((dev->pmcw.flag25 & PMCW25_TYPE) >> 2);

  00243	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00248	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  0024f	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  00254	c1 f8 02	 sar	 eax, 2
  00257	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  0025c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0025f	0b c8		 or	 ecx, eax
  00261	8b c1		 mov	 eax, ecx
  00263	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  00268	88 01		 mov	 BYTE PTR [rcx], al

; 184  :                     chsc_rsp4->path_mask = dev->pmcw.pim;

  0026a	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  0026f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  00274	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  0027b	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 185  :                     chsc_rsp4->unit_addr = dev->devnum & 0xff;

  0027e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00283	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00287	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0028c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  00291	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 186  :                     STORE_HW(chsc_rsp4->devno,dev->devnum);

  00294	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00299	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  0029d	e8 00 00 00 00	 call	 _byteswap_ushort
  002a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  002a7	48 83 c1 02	 add	 rcx, 2
  002ab	0f b7 d0	 movzx	 edx, ax
  002ae	e8 00 00 00 00	 call	 store_hw_noswap

; 187  :                     STORE_HW(chsc_rsp4->sch, sch);

  002b3	0f b7 4c 24 28	 movzx	 ecx, WORD PTR sch$[rsp]
  002b8	e8 00 00 00 00	 call	 _byteswap_ushort
  002bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  002c2	48 83 c1 06	 add	 rcx, 6
  002c6	0f b7 d0	 movzx	 edx, ax
  002c9	e8 00 00 00 00	 call	 store_hw_noswap

; 188  :                     memcpy(chsc_rsp4->chpid, dev->pmcw.chpid, 8);

  002ce	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  002d3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  002d8	48 8b 89 fc 02
	00 00		 mov	 rcx, QWORD PTR [rcx+764]
  002df	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 189  :                     if(dev->fla[0])

  002e3	b8 02 00 00 00	 mov	 eax, 2
  002e8	48 6b c0 00	 imul	 rax, rax, 0
  002ec	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  002f1	0f b7 84 01 bc
	05 00 00	 movzx	 eax, WORD PTR [rcx+rax+1468]
  002f9	85 c0		 test	 eax, eax
  002fb	74 14		 je	 SHORT $LN18@z900_chsc_

; 190  :                         chsc_rsp4->fla_valid_mask = dev->pmcw.pim;

  002fd	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  00302	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  00307	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  0030e	88 48 05	 mov	 BYTE PTR [rax+5], cl
$LN18@z900_chsc_:

; 191  :                     for(n = 0; n < 8; n++)

  00311	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  00319	eb 0a		 jmp	 SHORT $LN7@z900_chsc_
$LN5@z900_chsc_:
  0031b	8b 44 24 3c	 mov	 eax, DWORD PTR n$1[rsp]
  0031f	ff c0		 inc	 eax
  00321	89 44 24 3c	 mov	 DWORD PTR n$1[rsp], eax
$LN7@z900_chsc_:
  00325	83 7c 24 3c 08	 cmp	 DWORD PTR n$1[rsp], 8
  0032a	7d 4f		 jge	 SHORT $LN6@z900_chsc_

; 192  :                         if(dev->pmcw.pim & (0x80 >> n))

  0032c	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00331	0f b6 80 f7 02
	00 00		 movzx	 eax, BYTE PTR [rax+759]
  00338	8b 4c 24 3c	 mov	 ecx, DWORD PTR n$1[rsp]
  0033c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00341	d3 fa		 sar	 edx, cl
  00343	8b ca		 mov	 ecx, edx
  00345	23 c1		 and	 eax, ecx
  00347	85 c0		 test	 eax, eax
  00349	74 2e		 je	 SHORT $LN19@z900_chsc_

; 193  :                         {
; 194  :                             STORE_HW(chsc_rsp4->fla[n], dev->fla[n]);

  0034b	48 63 44 24 3c	 movsxd	 rax, DWORD PTR n$1[rsp]
  00350	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  00355	0f b7 8c 41 bc
	05 00 00	 movzx	 ecx, WORD PTR [rcx+rax*2+1468]
  0035d	e8 00 00 00 00	 call	 _byteswap_ushort
  00362	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR n$1[rsp]
  00367	48 8b 54 24 30	 mov	 rdx, QWORD PTR chsc_rsp4$[rsp]
  0036c	48 8d 4c 4a 10	 lea	 rcx, QWORD PTR [rdx+rcx*2+16]
  00371	0f b7 d0	 movzx	 edx, ax
  00374	e8 00 00 00 00	 call	 store_hw_noswap
$LN19@z900_chsc_:

; 195  :                         }

  00379	eb a0		 jmp	 SHORT $LN5@z900_chsc_
$LN6@z900_chsc_:
$LN16@z900_chsc_:
$LN15@z900_chsc_:

; 196  :                 }
; 197  :             }
; 198  :         }

  0037b	e9 06 fe ff ff	 jmp	 $LN2@z900_chsc_
$LN3@z900_chsc_:

; 199  :     }

  00380	eb 52		 jmp	 SHORT $LN14@z900_chsc_
$LN13@z900_chsc_:

; 200  :     else /* f_sch > max_sch */
; 201  :     {
; 202  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp4++)

  00382	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  00386	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  0038a	eb 25		 jmp	 SHORT $LN10@z900_chsc_
$LN8@z900_chsc_:
  0038c	8b 44 24 28	 mov	 eax, DWORD PTR sch$[rsp]
  00390	ff c0		 inc	 eax
  00392	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00396	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0039b	66 ff c8	 dec	 ax
  0039e	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  003a3	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  003a8	48 83 c0 20	 add	 rax, 32			; 00000020H
  003ac	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp4$[rsp], rax
$LN10@z900_chsc_:
  003b1	8b 44 24 50	 mov	 eax, DWORD PTR l_sch$[rsp]
  003b5	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  003b9	7f 19		 jg	 SHORT $LN9@z900_chsc_
  003bb	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  003c0	85 c0		 test	 eax, eax
  003c2	74 10		 je	 SHORT $LN9@z900_chsc_

; 203  :             memset(chsc_rsp4, 0, sizeof(CHSC_RSP4) );

  003c4	48 8b 7c 24 30	 mov	 rdi, QWORD PTR chsc_rsp4$[rsp]
  003c9	33 c0		 xor	 eax, eax
  003cb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  003d0	f3 aa		 rep stosb
  003d2	eb b8		 jmp	 SHORT $LN8@z900_chsc_
$LN9@z900_chsc_:
$LN14@z900_chsc_:

; 204  :     }
; 205  : 
; 206  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  003d4	45 33 c0	 xor	 r8d, r8d
  003d7	0f b7 54 24 58	 movzx	 edx, WORD PTR rsp_len$[rsp]
  003dc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  003e4	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@z900_chsc_:

; 207  : }

  003e9	48 83 c4 70	 add	 rsp, 112		; 00000070H
  003ed	5f		 pop	 rdi
  003ee	c3		 ret	 0
z900_chsc_get_sch_desc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
valid_bit_domain$1 = 32
rsp_len$ = 36
req_len$ = 40
z$2 = 48
tv66 = 56
tv92 = 60
valid_bit_offset$3 = 64
chsc_rsp12$ = 72
lparname_offset$4 = 80
chsc_req12$ = 88
tv83 = 96
tv137 = 104
chsc_req$ = 128
chsc_rsp$ = 136
z900_chsc_get_conf_info PROC

; 58   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 59   : U16 req_len, rsp_len;
; 60   : 
; 61   : CHSC_REQ12 *chsc_req12 = (CHSC_REQ12 *)(chsc_req);

  0000f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00017	48 89 44 24 58	 mov	 QWORD PTR chsc_req12$[rsp], rax

; 62   : CHSC_RSP12 *chsc_rsp12 = (CHSC_RSP12 *)(chsc_rsp+1);

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 44 24 48	 mov	 QWORD PTR chsc_rsp12$[rsp], rax

; 63   : 
; 64   :     /* Set response length based on MIF mode */
; 65   :     switch (sysblk.operation_mode)

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  0003a	89 44 24 38	 mov	 DWORD PTR tv66[rsp], eax
  0003e	83 7c 24 38 02	 cmp	 DWORD PTR tv66[rsp], 2
  00043	74 02		 je	 SHORT $LN6@z900_chsc_
  00045	eb 0c		 jmp	 SHORT $LN7@z900_chsc_
$LN6@z900_chsc_:

; 66   :     {
; 67   :         case om_emif:
; 68   :             rsp_len = sizeof(CHSC_RSP) + sizeof(CHSC_RSP12);

  00047	b8 d8 08 00 00	 mov	 eax, 2264		; 000008d8H
  0004c	66 89 44 24 24	 mov	 WORD PTR rsp_len$[rsp], ax

; 69   :             break;

  00051	eb 0a		 jmp	 SHORT $LN2@z900_chsc_
$LN7@z900_chsc_:

; 70   : 
; 71   :         default:
; 72   :             rsp_len = 0x0138;

  00053	b8 38 01 00 00	 mov	 eax, 312		; 00000138H
  00058	66 89 44 24 24	 mov	 WORD PTR rsp_len$[rsp], ax
$LN2@z900_chsc_:

; 73   :             break;
; 74   :     }
; 75   : 
; 76   :     FETCH_HW(req_len, chsc_req12->length);

  0005d	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req12$[rsp]
  00062	48 8b c8	 mov	 rcx, rax
  00065	e8 00 00 00 00	 call	 fetch_hw_noswap
  0006a	0f b7 c8	 movzx	 ecx, ax
  0006d	e8 00 00 00 00	 call	 _byteswap_ushort
  00072	66 89 44 24 28	 mov	 WORD PTR req_len$[rsp], ax

; 77   : 
; 78   :     /* If the response won't fit in the requested length, return an
; 79   :      * error back to the caller.
; 80   :      */
; 81   :     if (!chsc_max_rsp(req_len, sizeof(CHSC_RSP12)))

  00077	ba d0 08 00 00	 mov	 edx, 2256		; 000008d0H
  0007c	0f b7 4c 24 28	 movzx	 ecx, WORD PTR req_len$[rsp]
  00081	e8 00 00 00 00	 call	 chsc_max_rsp
  00086	0f b7 c0	 movzx	 eax, ax
  00089	85 c0		 test	 eax, eax
  0008b	75 14		 jne	 SHORT $LN8@z900_chsc_

; 82   :         return chsc_req_errreq(chsc_rsp, 0);

  0008d	33 d2		 xor	 edx, edx
  0008f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00097	e8 00 00 00 00	 call	 chsc_req_errreq
  0009c	e9 4f 01 00 00	 jmp	 $LN1@z900_chsc_
$LN8@z900_chsc_:

; 83   : 
; 84   :     /* Clear the response area */
; 85   :     memset(chsc_rsp12, 0, rsp_len);

  000a1	0f b7 44 24 24	 movzx	 eax, WORD PTR rsp_len$[rsp]
  000a6	48 89 44 24 60	 mov	 QWORD PTR tv83[rsp], rax
  000ab	48 8b 7c 24 48	 mov	 rdi, QWORD PTR chsc_rsp12$[rsp]
  000b0	33 c0		 xor	 eax, eax
  000b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv83[rsp]
  000b7	f3 aa		 rep stosb

; 86   : 
; 87   :     /* Where did this bit come from? Is it a z-machine indicator? */
; 88   :     chsc_rsp12->unknow00A = 0x01;

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_rsp12$[rsp]
  000be	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 89   : 
; 90   :     /* FIXME: BASIC mode operations are not returning the proper
; 91   :      *        information; instead, return of an error may be required.
; 92   :      */
; 93   :     if (sysblk.operation_mode != om_basic)

  000c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c9	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [rax+232], 0
  000d0	0f 84 05 01 00
	00		 je	 $LN9@z900_chsc_

; 94   :     {
; 95   :         BYTE*   z = (BYTE*)chsc_rsp;

  000d6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  000de	48 89 44 24 30	 mov	 QWORD PTR z$2[rsp], rax

; 96   :         BYTE    valid_bit_domain;
; 97   :         size_t  valid_bit_offset;
; 98   :         size_t  lparname_offset;
; 99   : 
; 100  :         /* Save Hercules LPAR number as the partition number */
; 101  :         *(z + 11) = valid_bit_domain = sysblk.lparnum;

  000e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ea	0f b6 80 f0 00
	00 00		 movzx	 eax, BYTE PTR [rax+240]
  000f1	88 44 24 20	 mov	 BYTE PTR valid_bit_domain$1[rsp], al
  000f5	48 8b 44 24 30	 mov	 rax, QWORD PTR z$2[rsp]
  000fa	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR valid_bit_domain$1[rsp]
  000ff	88 48 0b	 mov	 BYTE PTR [rax+11], cl

; 102  : 
; 103  :         /* Set current LPAR name valid bit and LPAR name
; 104  :          *
; 105  :          * Note: The value fields are arrays of *ALL* defined and active
; 106  :          *       LPAR names and validity bits for the host system. It
; 107  :          *       should also be noted that the offsets to the array of
; 108  :          *       LPAR name valid bits and to the array of LPAR names is
; 109  :          *       different between non-EMIF and EMIF modes.
; 110  :          *
; 111  :          * FIXME: Future. Supply and maintain the information from *ALL*
; 112  :          *        active Hercules instances on the host system.
; 113  :          */
; 114  :         switch (sysblk.operation_mode)

  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00109	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  0010f	89 44 24 3c	 mov	 DWORD PTR tv92[rsp], eax
  00113	83 7c 24 3c 01	 cmp	 DWORD PTR tv92[rsp], 1
  00118	74 02		 je	 SHORT $LN10@z900_chsc_
  0011a	eb 1f		 jmp	 SHORT $LN11@z900_chsc_
$LN10@z900_chsc_:

; 115  :         {
; 116  :             case om_mif:
; 117  :                 --valid_bit_domain;

  0011c	0f b6 44 24 20	 movzx	 eax, BYTE PTR valid_bit_domain$1[rsp]
  00121	fe c8		 dec	 al
  00123	88 44 24 20	 mov	 BYTE PTR valid_bit_domain$1[rsp], al

; 118  :                 valid_bit_offset = 180;

  00127	48 c7 44 24 40
	b4 00 00 00	 mov	 QWORD PTR valid_bit_offset$3[rsp], 180 ; 000000b4H

; 119  :                 lparname_offset  = 184;

  00130	48 c7 44 24 50
	b8 00 00 00	 mov	 QWORD PTR lparname_offset$4[rsp], 184 ; 000000b8H

; 120  :                 break;

  00139	eb 12		 jmp	 SHORT $LN4@z900_chsc_
$LN11@z900_chsc_:

; 121  : 
; 122  :          /* case om_emif: */
; 123  :             default:
; 124  :                 valid_bit_offset = 184;

  0013b	48 c7 44 24 40
	b8 00 00 00	 mov	 QWORD PTR valid_bit_offset$3[rsp], 184 ; 000000b8H

; 125  :                 lparname_offset  = 216;

  00144	48 c7 44 24 50
	d8 00 00 00	 mov	 QWORD PTR lparname_offset$4[rsp], 216 ; 000000d8H
$LN4@z900_chsc_:

; 126  :                 break;
; 127  :         }
; 128  : 
; 129  :         /* Set LPAR name */
; 130  :         get_lparname(z + lparname_offset + (sysblk.lparnum << 3));

  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR lparname_offset$4[rsp]
  00152	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$2[rsp]
  00157	48 03 c8	 add	 rcx, rax
  0015a	48 8b c1	 mov	 rax, rcx
  0015d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00164	0f b7 89 f0 00
	00 00		 movzx	 ecx, WORD PTR [rcx+240]
  0016b	c1 e1 03	 shl	 ecx, 3
  0016e	48 63 c9	 movsxd	 rcx, ecx
  00171	48 03 c1	 add	 rax, rcx
  00174	48 8b c8	 mov	 rcx, rax
  00177	e8 00 00 00 00	 call	 get_lparname

; 131  : 
; 132  :         /* Set valid bit */
; 133  :         *(z + valid_bit_offset + (valid_bit_domain >> 3)) |=

  0017c	48 8b 44 24 40	 mov	 rax, QWORD PTR valid_bit_offset$3[rsp]
  00181	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$2[rsp]
  00186	48 03 c8	 add	 rcx, rax
  00189	48 8b c1	 mov	 rax, rcx
  0018c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR valid_bit_domain$1[rsp]
  00191	c1 f9 03	 sar	 ecx, 3
  00194	48 63 c9	 movsxd	 rcx, ecx
  00197	48 89 4c 24 68	 mov	 QWORD PTR tv137[rsp], rcx
  0019c	0f b6 54 24 20	 movzx	 edx, BYTE PTR valid_bit_domain$1[rsp]
  001a1	83 e2 07	 and	 edx, 7
  001a4	bf 80 00 00 00	 mov	 edi, 128		; 00000080H
  001a9	0f b6 ca	 movzx	 ecx, dl
  001ac	8b d7		 mov	 edx, edi
  001ae	d3 fa		 sar	 edx, cl
  001b0	8b ca		 mov	 ecx, edx
  001b2	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv137[rsp]
  001b7	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  001bb	0b c1		 or	 eax, ecx
  001bd	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR valid_bit_domain$1[rsp]
  001c2	c1 f9 03	 sar	 ecx, 3
  001c5	48 63 c9	 movsxd	 rcx, ecx
  001c8	48 8b 54 24 40	 mov	 rdx, QWORD PTR valid_bit_offset$3[rsp]
  001cd	48 8b 7c 24 30	 mov	 rdi, QWORD PTR z$2[rsp]
  001d2	48 03 fa	 add	 rdi, rdx
  001d5	48 8b d7	 mov	 rdx, rdi
  001d8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN9@z900_chsc_:

; 134  :             (0x80 >> (valid_bit_domain & 0x07));
; 135  :     }
; 136  : 
; 137  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  001db	45 33 c0	 xor	 r8d, r8d
  001de	0f b7 54 24 24	 movzx	 edx, WORD PTR rsp_len$[rsp]
  001e3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  001eb	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@z900_chsc_:

; 138  : }

  001f0	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001f4	5f		 pop	 rdi
  001f5	c3		 ret	 0
z900_chsc_get_conf_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_check
_TEXT	SEGMENT
tv78 = 32
regs$ = 64
r1$ = 72
z900_per3_zero_check PROC				; COMDAT

; 629  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 630  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 631  :     if (GR_A( r1, regs ) == 0)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 19		 je	 SHORT $LN4@z900_per3_
  0001f	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00029	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00031	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  00036	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  00038	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00049	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
$LN5@z900_per3_:
  0004e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv78[rsp], 0
  00054	75 0a		 jne	 SHORT $LN2@z900_per3_

; 632  :         ARCH_DEP( per3_zero )( regs );

  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 633  : #else
; 634  :     UNREFERENCED( regs );
; 635  :     UNREFERENCED( r1 );
; 636  : #endif
; 637  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
z900_per3_zero_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
req_len$ = 64
r1$ = 68
chsc_req$ = 72
chsc_rsp$ = 80
tv203 = 88
req$ = 92
i$1 = 96
r2$ = 100
n$ = 104
tv275 = 112
mn$ = 120
inst$ = 144
regs$ = 152
z900_channel_subsystem_call PROC

; 572  : {

$LN44:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 573  : int     r1, r2;                                 /* register values   */
; 574  : VADR    n;                                      /* Unsigned work     */
; 575  : BYTE   *mn;                                     /* Unsigned work     */
; 576  : U16     req_len;                                /* Length of request */
; 577  : U16     req;                                    /* Request code      */
; 578  : CHSC_REQ *chsc_req;                             /* Request structure */
; 579  : CHSC_RSP *chsc_rsp;                             /* Response structure*/
; 580  : 
; 581  :     RRE(inst, regs, r1, r2);

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 03	 imul	 rax, rax, 3
  0001a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00022	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00026	89 44 24 60	 mov	 DWORD PTR i$1[rsp], eax
  0002a	8b 44 24 60	 mov	 eax, DWORD PTR i$1[rsp]
  0002e	83 e0 0f	 and	 eax, 15
  00031	89 44 24 64	 mov	 DWORD PTR r2$[rsp], eax
  00035	8b 44 24 60	 mov	 eax, DWORD PTR i$1[rsp]
  00039	c1 f8 04	 sar	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_chann:
  00043	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004f	48 83 c0 04	 add	 rax, 4
  00053	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005f	33 c0		 xor	 eax, eax
  00061	83 f8 04	 cmp	 eax, 4
  00064	74 0f		 je	 SHORT $LN19@z900_chann
  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN19@z900_chann:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 c8		 jne	 SHORT $LN4@z900_chann

; 582  : 
; 583  :     /* Display instruction if debugging */
; 584  : #if defined(CHSC_DEBUG)
; 585  :     ARCH_DEP(display_inst) (regs, inst);
; 586  : #endif
; 587  : 
; 588  :     PER_ZEROADDR_CHECK( regs, r1 );

  0007b	8b 54 24 44	 mov	 edx, DWORD PTR r1$[rsp]
  0007f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	e8 00 00 00 00	 call	 z900_per3_zero_check
$LN7@z900_chann:

; 589  :     TXF_INSTR_CHECK( regs );

  0008c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00094	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0009b	85 c0		 test	 eax, eax
  0009d	74 3f		 je	 SHORT $LN20@z900_chann
  0009f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ad	0f ba e8 0c	 bts	 eax, 12
  000b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000bf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193566
  000c6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000cc	ba 02 00 00 00	 mov	 edx, 2
  000d1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	e8 00 00 00 00	 call	 z900_abort_transaction
$LN20@z900_chann:
  000de	33 c0		 xor	 eax, eax
  000e0	85 c0		 test	 eax, eax
  000e2	75 a8		 jne	 SHORT $LN7@z900_chann

; 590  :     PRIV_CHECK(regs);

  000e4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000f0	83 e0 01	 and	 eax, 1
  000f3	85 c0		 test	 eax, eax
  000f5	74 1b		 je	 SHORT $LN21@z900_chann
  000f7	ba 02 00 00 00	 mov	 edx, 2
  000fc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN21@z900_chann:
$LN10@z900_chann:

; 591  : 
; 592  :     SIE_INTERCEPT(regs);

  00112	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00120	d1 e8		 shr	 eax, 1
  00122	83 e0 01	 and	 eax, 1
  00125	85 c0		 test	 eax, eax
  00127	74 1b		 je	 SHORT $LN22@z900_chann
  00129	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00137	ba fc ff ff ff	 mov	 edx, -4
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	e8 00 00 00 00	 call	 longjmp
$LN22@z900_chann:
  00144	33 c0		 xor	 eax, eax
  00146	85 c0		 test	 eax, eax
  00148	75 c8		 jne	 SHORT $LN10@z900_chann
$LN13@z900_chann:

; 593  : 
; 594  :     PTT_INF("CHSC",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  0014a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00151	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00154	48 83 e0 08	 and	 rax, 8
  00158	48 85 c0	 test	 rax, rax
  0015b	74 69		 je	 SHORT $LN23@z900_chann
  0015d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0016b	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00170	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00178	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  0017f	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00184	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018c	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00194	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193570
  001a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ae	44 8b c9	 mov	 r9d, ecx
  001b1	44 8b c2	 mov	 r8d, edx
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193571
  001bb	b9 08 00 00 00	 mov	 ecx, 8
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN23@z900_chann:
  001c6	33 c0		 xor	 eax, eax
  001c8	85 c0		 test	 eax, eax
  001ca	0f 85 7a ff ff
	ff		 jne	 $LN13@z900_chann

; 595  : 
; 596  :     /* Check operand-1 for page alignment */
; 597  :     n = regs->GR(r1) & ADDRESS_MAXWRAP(regs);

  001d0	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e5	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  001ec	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001f4	48 23 c2	 and	 rax, rdx
  001f7	48 89 44 24 68	 mov	 QWORD PTR n$[rsp], rax

; 598  : 
; 599  :     if(n & 0xFFF)

  001fc	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00201	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00207	48 85 c0	 test	 rax, rax
  0020a	74 12		 je	 SHORT $LN24@z900_chann

; 600  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0020c	ba 06 00 00 00	 mov	 edx, 6
  00211	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	e8 00 00 00 00	 call	 z900_program_interrupt
$LN24@z900_chann:

; 601  : 
; 602  :     /* Get pointer to request/response */
; 603  :     mn = MADDR(n, r1, regs, ACCTYPE_READ, regs->psw.pkey);

  0021e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00226	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0022a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0022e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00236	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0023e	44 8b 44 24 44	 mov	 r8d, DWORD PTR r1$[rsp]
  00243	ba 01 00 00 00	 mov	 edx, 1
  00248	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  0024d	e8 00 00 00 00	 call	 z900_maddr_l
  00252	48 89 44 24 78	 mov	 QWORD PTR mn$[rsp], rax

; 604  :     chsc_req = (CHSC_REQ*)(mn);

  00257	48 8b 44 24 78	 mov	 rax, QWORD PTR mn$[rsp]
  0025c	48 89 44 24 48	 mov	 QWORD PTR chsc_req$[rsp], rax

; 605  : 
; 606  :     /* Fetch length of request field */
; 607  :     FETCH_HW(req_len, chsc_req->length);

  00261	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00266	48 8b c8	 mov	 rcx, rax
  00269	e8 00 00 00 00	 call	 fetch_hw_noswap
  0026e	0f b7 c8	 movzx	 ecx, ax
  00271	e8 00 00 00 00	 call	 _byteswap_ushort
  00276	66 89 44 24 40	 mov	 WORD PTR req_len$[rsp], ax

; 608  : 
; 609  :     /* Point to beginning of response field */
; 610  :     chsc_rsp = (CHSC_RSP*)((BYTE*)chsc_req + req_len);

  0027b	0f b7 44 24 40	 movzx	 eax, WORD PTR req_len$[rsp]
  00280	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00285	48 03 c8	 add	 rcx, rax
  00288	48 8b c1	 mov	 rax, rcx
  0028b	48 89 44 24 50	 mov	 QWORD PTR chsc_rsp$[rsp], rax

; 611  : 
; 612  :     /* Check for invalid request length */
; 613  :     if((req_len < sizeof(CHSC_REQ))
; 614  :       || (req_len > (CHSC_REQRSP_SIZE - sizeof(CHSC_RSP))))

  00290	0f b7 44 24 40	 movzx	 eax, WORD PTR req_len$[rsp]
  00295	48 83 f8 10	 cmp	 rax, 16
  00299	72 0d		 jb	 SHORT $LN26@z900_chann
  0029b	0f b7 44 24 40	 movzx	 eax, WORD PTR req_len$[rsp]
  002a0	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  002a6	76 12		 jbe	 SHORT $LN25@z900_chann
$LN26@z900_chann:

; 615  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  002a8	ba 15 00 00 00	 mov	 edx, 21
  002ad	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b5	e8 00 00 00 00	 call	 z900_program_interrupt
$LN25@z900_chann:

; 616  : 
; 617  :     /* Fetch the CHSC request code */
; 618  :     FETCH_HW(req,chsc_req->req);

  002ba	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_req$[rsp]
  002bf	48 83 c0 02	 add	 rax, 2
  002c3	48 8b c8	 mov	 rcx, rax
  002c6	e8 00 00 00 00	 call	 fetch_hw_noswap
  002cb	0f b7 c8	 movzx	 ecx, ax
  002ce	e8 00 00 00 00	 call	 _byteswap_ushort
  002d3	66 89 44 24 5c	 mov	 WORD PTR req$[rsp], ax

; 619  : 
; 620  :     /* Verify we have write access to the page */
; 621  :     ARCH_DEP(validate_operand) (n, r1, 0, ACCTYPE_WRITE, regs);

  002d8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e5	41 b9 02 00 00
	00		 mov	 r9d, 2
  002eb	45 33 c0	 xor	 r8d, r8d
  002ee	8b 54 24 44	 mov	 edx, DWORD PTR r1$[rsp]
  002f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  002f7	e8 00 00 00 00	 call	 z900_validate_operand

; 622  : 
; 623  :     switch(req) {

  002fc	0f b7 44 24 5c	 movzx	 eax, WORD PTR req$[rsp]
  00301	89 44 24 58	 mov	 DWORD PTR tv203[rsp], eax
  00305	8b 44 24 58	 mov	 eax, DWORD PTR tv203[rsp]
  00309	83 e8 02	 sub	 eax, 2
  0030c	89 44 24 58	 mov	 DWORD PTR tv203[rsp], eax
  00310	83 7c 24 58 22	 cmp	 DWORD PTR tv203[rsp], 34 ; 00000022H
  00315	0f 87 25 01 00
	00		 ja	 $LN36@z900_chann
  0031b	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv203[rsp]
  00320	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00327	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN42@z900_chann[rcx+rax]
  0032f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN43@z900_chann[rcx+rax*4]
  00336	48 03 c1	 add	 rax, rcx
  00339	ff e0		 jmp	 rax
$LN27@z900_chann:

; 624  : 
; 625  :         case CHSC_REQ_CHPDESC: /* 0x0002  Store Channel-Path Description */
; 626  :             regs->psw.cc = ARCH_DEP(chsc_get_chp_desc) (chsc_req, chsc_rsp);

  0033b	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  00340	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00345	e8 00 00 00 00	 call	 z900_chsc_get_chp_desc
  0034a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 627  :             break;

  00355	e9 01 02 00 00	 jmp	 $LN14@z900_chann
$LN28@z900_chann:

; 628  : 
; 629  :         case CHSC_REQ_SCHDESC: /* 0x0004  Store Subchannel Description Data */
; 630  :             regs->psw.cc = ARCH_DEP(chsc_get_sch_desc) (chsc_req, chsc_rsp);

  0035a	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  0035f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00364	e8 00 00 00 00	 call	 z900_chsc_get_sch_desc
  00369	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00371	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 631  :             break;

  00374	e9 e2 01 00 00	 jmp	 $LN14@z900_chann
$LN29@z900_chann:

; 632  : 
; 633  :         case CHSC_REQ_CUDESC:  /* 0x0006  Store Subchannel Control-Unit Data */
; 634  :             regs->psw.cc = ARCH_DEP(chsc_get_cu_desc) (chsc_req, chsc_rsp);

  00379	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  0037e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00383	e8 00 00 00 00	 call	 z900_chsc_get_cu_desc
  00388	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00390	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 635  :             break;

  00393	e9 c3 01 00 00	 jmp	 $LN14@z900_chann
$LN30@z900_chann:

; 636  : 
; 637  :         case CHSC_REQ_CSSINFO: /* 0x0010  Store Channel-Subsystem Characteristics */
; 638  :             regs->psw.cc = ARCH_DEP(chsc_get_css_info) (regs, chsc_req, chsc_rsp);

  00398	4c 8b 44 24 50	 mov	 r8, QWORD PTR chsc_rsp$[rsp]
  0039d	48 8b 54 24 48	 mov	 rdx, QWORD PTR chsc_req$[rsp]
  003a2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003aa	e8 00 00 00 00	 call	 z900_chsc_get_css_info
  003af	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b7	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 639  :             break;

  003ba	e9 9c 01 00 00	 jmp	 $LN14@z900_chann
$LN31@z900_chann:

; 640  : 
; 641  :         case CHSC_REQ_CNFINFO: /* 0x0012  Store Configuration Information */
; 642  :             regs->psw.cc = ARCH_DEP(chsc_get_conf_info) (chsc_req, chsc_rsp);

  003bf	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  003c4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  003c9	e8 00 00 00 00	 call	 z900_chsc_get_conf_info
  003ce	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d6	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 643  :             break;

  003d9	e9 7d 01 00 00	 jmp	 $LN14@z900_chann
$LN32@z900_chann:

; 644  : 
; 645  : #if defined(_FEATURE_QDIO_THININT)
; 646  : 
; 647  :         case CHSC_REQ_SETSSSI: /* 0x0021  Set Subchannel Indicator */
; 648  :             if (FACILITY_ENABLED( HERC_QDIO_THININT, regs ))

  003de	b8 01 00 00 00	 mov	 eax, 1
  003e3	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  003e7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ef	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  003f7	83 e0 10	 and	 eax, 16
  003fa	85 c0		 test	 eax, eax
  003fc	74 21		 je	 SHORT $LN33@z900_chann

; 649  :             {
; 650  :                 regs->psw.cc = ARCH_DEP(chsc_set_sci) (chsc_req, chsc_rsp);

  003fe	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  00403	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00408	e8 00 00 00 00	 call	 z900_chsc_set_sci
  0040d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00415	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 651  :                 break;

  00418	e9 3e 01 00 00	 jmp	 $LN14@z900_chann

; 652  :             }

  0041d	eb 02		 jmp	 SHORT $LN34@z900_chann
$LN33@z900_chann:

; 653  :             else
; 654  :                 goto chsc_error;

  0041f	eb 1f		 jmp	 SHORT $chsc_error$45
$LN34@z900_chann:
$LN35@z900_chann:

; 655  : 
; 656  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 657  : 
; 658  :         case CHSC_REQ_GETSSQD: /* 0x0024  Store Subchannel QDIO Data */
; 659  :             regs->psw.cc = ARCH_DEP(chsc_get_ssqd) (chsc_req, chsc_rsp);

  00421	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  00426	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  0042b	e8 00 00 00 00	 call	 z900_chsc_get_ssqd
  00430	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00438	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 660  :             break;

  0043b	e9 1b 01 00 00	 jmp	 $LN14@z900_chann
$LN36@z900_chann:
$chsc_error$45:
$LN18@z900_chann:

; 661  : 
; 662  : #if 0
; 663  :         case CHSC_REQ_ENFACIL: /* 0x0031  Enable Facility */
; 664  :             regs->psw.cc = ARCH_DEP(chsc_enable_facility) (chsc_req, chsc_rsp);
; 665  :             break;
; 666  : #endif
; 667  : 
; 668  :         default:
; 669  : #if defined(_FEATURE_QDIO_THININT)
; 670  :         chsc_error:
; 671  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 672  :             PTT_ERR("*CHSC",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00440	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00447	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044a	48 83 e0 10	 and	 rax, 16
  0044e	48 85 c0	 test	 rax, rax
  00451	74 69		 je	 SHORT $LN37@z900_chann
  00453	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00461	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00466	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0046e	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00475	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0047a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00482	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  0048a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00493	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00498	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193586
  0049f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a4	44 8b c9	 mov	 r9d, ecx
  004a7	44 8b c2	 mov	 r8d, edx
  004aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193587
  004b1	b9 10 00 00 00	 mov	 ecx, 16
  004b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@z900_chann:
  004bc	33 c0		 xor	 eax, eax
  004be	85 c0		 test	 eax, eax
  004c0	0f 85 7a ff ff
	ff		 jne	 $LN18@z900_chann

; 673  :             if( HDC3(debug_chsc_unknown_request, chsc_rsp, chsc_req, regs) )

  004c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_chsc_unknown_request
  004cd	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  004d1	74 22		 je	 SHORT $LN40@z900_chann
  004d3	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004db	48 8b 54 24 48	 mov	 rdx, QWORD PTR chsc_req$[rsp]
  004e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  004e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_chsc_unknown_request
  004ec	ff 10		 call	 QWORD PTR [rax]
  004ee	48 89 44 24 70	 mov	 QWORD PTR tv275[rsp], rax
  004f3	eb 09		 jmp	 SHORT $LN41@z900_chann
$LN40@z900_chann:
  004f5	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv275[rsp], 0
$LN41@z900_chann:
  004fe	48 83 7c 24 70
	00		 cmp	 QWORD PTR tv275[rsp], 0
  00504	74 02		 je	 SHORT $LN38@z900_chann

; 674  :                 break;

  00506	eb 53		 jmp	 SHORT $LN14@z900_chann
$LN38@z900_chann:

; 675  :             STORE_HW(chsc_rsp->length,sizeof(CHSC_RSP));

  00508	66 b9 08 00	 mov	 cx, 8
  0050c	e8 00 00 00 00	 call	 _byteswap_ushort
  00511	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00516	0f b7 d0	 movzx	 edx, ax
  00519	e8 00 00 00 00	 call	 store_hw_noswap

; 676  :             STORE_HW(chsc_rsp->rsp,CHSC_REQ_INVALID);

  0051e	66 b9 02 00	 mov	 cx, 2
  00522	e8 00 00 00 00	 call	 _byteswap_ushort
  00527	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  0052c	48 83 c1 02	 add	 rcx, 2
  00530	0f b7 d0	 movzx	 edx, ax
  00533	e8 00 00 00 00	 call	 store_hw_noswap

; 677  :             /* No reason code */
; 678  :             STORE_FW(chsc_rsp->info,0);

  00538	33 c9		 xor	 ecx, ecx
  0053a	e8 00 00 00 00	 call	 _byteswap_ulong
  0053f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00544	48 83 c1 04	 add	 rcx, 4
  00548	8b d0		 mov	 edx, eax
  0054a	e8 00 00 00 00	 call	 store_fw_noswap

; 679  :             /* Return cc0 even for unsupported requests?? */
; 680  :             regs->psw.cc = 0;

  0054f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00557	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN14@z900_chann:
$LN39@z900_chann:

; 681  :             break;
; 682  :     }
; 683  : 
; 684  :     /* Show results if debugging */
; 685  :     #if defined(CHSC_DEBUG)
; 686  :     DUMP_CHSC_REQRSP( req, chsc_req );
; 687  :     #endif
; 688  : }

  0055b	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00562	c3		 ret	 0
  00563	90		 npad	 1
$LN43@z900_chann:
  00564	00 00 00 00	 DD	 $LN27@z900_chann
  00568	00 00 00 00	 DD	 $LN28@z900_chann
  0056c	00 00 00 00	 DD	 $LN29@z900_chann
  00570	00 00 00 00	 DD	 $LN30@z900_chann
  00574	00 00 00 00	 DD	 $LN31@z900_chann
  00578	00 00 00 00	 DD	 $LN32@z900_chann
  0057c	00 00 00 00	 DD	 $LN35@z900_chann
  00580	00 00 00 00	 DD	 $LN36@z900_chann
$LN42@z900_chann:
  00584	00		 DB	 0
  00585	07		 DB	 7
  00586	01		 DB	 1
  00587	07		 DB	 7
  00588	02		 DB	 2
  00589	07		 DB	 7
  0058a	07		 DB	 7
  0058b	07		 DB	 7
  0058c	07		 DB	 7
  0058d	07		 DB	 7
  0058e	07		 DB	 7
  0058f	07		 DB	 7
  00590	07		 DB	 7
  00591	07		 DB	 7
  00592	03		 DB	 3
  00593	07		 DB	 7
  00594	04		 DB	 4
  00595	07		 DB	 7
  00596	07		 DB	 7
  00597	07		 DB	 7
  00598	07		 DB	 7
  00599	07		 DB	 7
  0059a	07		 DB	 7
  0059b	07		 DB	 7
  0059c	07		 DB	 7
  0059d	07		 DB	 7
  0059e	07		 DB	 7
  0059f	07		 DB	 7
  005a0	07		 DB	 7
  005a1	07		 DB	 7
  005a2	07		 DB	 7
  005a3	05		 DB	 5
  005a4	07		 DB	 7
  005a5	07		 DB	 7
  005a6	06		 DB	 6
z900_channel_subsystem_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
max_rsp$ = 32
chp$ = 36
dev$ = 40
f_chp$ = 48
l_chp$ = 52
req_len$ = 56
rsp_len$ = 60
chsc_rsp2$ = 64
chsc_rsp2f1$ = 72
tv79 = 80
num_chps$ = 84
tv128 = 88
fmt1$ = 92
chsc_req2$ = 96
tv81 = 104
rsp_size$ = 112
chsc_req$ = 144
chsc_rsp$ = 152
s390_chsc_get_chp_desc PROC

; 493  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 494  : U16 req_len, rsp_len, max_rsp;
; 495  : int fmt1, chp, f_chp, l_chp, num_chps;
; 496  : size_t rsp_size;
; 497  : DEVBLK *dev;
; 498  : 
; 499  : CHSC_REQ2   *chsc_req2   = (CHSC_REQ2 *)  (chsc_req);

  00012	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  0001a	48 89 44 24 60	 mov	 QWORD PTR chsc_req2$[rsp], rax

; 500  : CHSC_RSP2   *chsc_rsp2   = (CHSC_RSP2 *)  (chsc_rsp+1);

  0001f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00027	48 83 c0 08	 add	 rax, 8
  0002b	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp2$[rsp], rax

; 501  : CHSC_RSP2F1 *chsc_rsp2f1 = (CHSC_RSP2F1 *)(chsc_rsp+1);

  00030	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00038	48 83 c0 08	 add	 rax, 8
  0003c	48 89 44 24 48	 mov	 QWORD PTR chsc_rsp2f1$[rsp], rax

; 502  : 
; 503  :     f_chp = chsc_req2->first_chpid;

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR chsc_req2$[rsp]
  00046	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  0004a	89 44 24 30	 mov	 DWORD PTR f_chp$[rsp], eax

; 504  :     l_chp = chsc_req2->last_chpid;

  0004e	48 8b 44 24 60	 mov	 rax, QWORD PTR chsc_req2$[rsp]
  00053	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  00057	89 44 24 34	 mov	 DWORD PTR l_chp$[rsp], eax

; 505  : 
; 506  :     FETCH_HW(req_len, chsc_req2->length);

  0005b	48 8b 44 24 60	 mov	 rax, QWORD PTR chsc_req2$[rsp]
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 fetch_hw_noswap
  00068	0f b7 c8	 movzx	 ecx, ax
  0006b	e8 00 00 00 00	 call	 _byteswap_ushort
  00070	66 89 44 24 38	 mov	 WORD PTR req_len$[rsp], ax

; 507  : 
; 508  :     fmt1 = (chsc_req2->flags1 & CHSC_REQ2_F1_C) ? 1 : 0;

  00075	48 8b 44 24 60	 mov	 rax, QWORD PTR chsc_req2$[rsp]
  0007a	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0007e	83 e0 10	 and	 eax, 16
  00081	85 c0		 test	 eax, eax
  00083	74 0a		 je	 SHORT $LN21@s390_chsc_
  00085	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  0008d	eb 08		 jmp	 SHORT $LN22@s390_chsc_
$LN21@s390_chsc_:
  0008f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN22@s390_chsc_:
  00097	8b 44 24 50	 mov	 eax, DWORD PTR tv79[rsp]
  0009b	89 44 24 5c	 mov	 DWORD PTR fmt1$[rsp], eax

; 509  :     rsp_size = fmt1 ? sizeof(CHSC_RSP2F1) : sizeof(CHSC_RSP2);

  0009f	83 7c 24 5c 00	 cmp	 DWORD PTR fmt1$[rsp], 0
  000a4	74 0b		 je	 SHORT $LN23@s390_chsc_
  000a6	48 c7 44 24 68
	20 00 00 00	 mov	 QWORD PTR tv81[rsp], 32	; 00000020H
  000af	eb 09		 jmp	 SHORT $LN24@s390_chsc_
$LN23@s390_chsc_:
  000b1	48 c7 44 24 68
	08 00 00 00	 mov	 QWORD PTR tv81[rsp], 8
$LN24@s390_chsc_:
  000ba	48 8b 44 24 68	 mov	 rax, QWORD PTR tv81[rsp]
  000bf	48 89 44 24 70	 mov	 QWORD PTR rsp_size$[rsp], rax

; 510  : 
; 511  :     if(!(max_rsp = chsc_max_rsp(req_len, rsp_size))
; 512  : // ZZ || (chsc_req2->rfmt != 1 && chsc_req2->rfmt != 2)
; 513  :       || f_chp > l_chp)

  000c4	48 8b 54 24 70	 mov	 rdx, QWORD PTR rsp_size$[rsp]
  000c9	0f b7 4c 24 38	 movzx	 ecx, WORD PTR req_len$[rsp]
  000ce	e8 00 00 00 00	 call	 chsc_max_rsp
  000d3	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  000d8	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  000dd	85 c0		 test	 eax, eax
  000df	74 0a		 je	 SHORT $LN15@s390_chsc_
  000e1	8b 44 24 34	 mov	 eax, DWORD PTR l_chp$[rsp]
  000e5	39 44 24 30	 cmp	 DWORD PTR f_chp$[rsp], eax
  000e9	7e 14		 jle	 SHORT $LN14@s390_chsc_
$LN15@s390_chsc_:

; 514  :         return chsc_req_errreq(chsc_rsp, 0);

  000eb	33 d2		 xor	 edx, edx
  000ed	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000f5	e8 00 00 00 00	 call	 chsc_req_errreq
  000fa	e9 8f 02 00 00	 jmp	 $LN1@s390_chsc_
$LN14@s390_chsc_:

; 515  : 
; 516  :     num_chps = (l_chp - f_chp) + 1;

  000ff	8b 44 24 30	 mov	 eax, DWORD PTR f_chp$[rsp]
  00103	8b 4c 24 34	 mov	 ecx, DWORD PTR l_chp$[rsp]
  00107	2b c8		 sub	 ecx, eax
  00109	8b c1		 mov	 eax, ecx
  0010b	ff c0		 inc	 eax
  0010d	89 44 24 54	 mov	 DWORD PTR num_chps$[rsp], eax

; 517  :     max_rsp  = (U16) min((int)max_rsp, num_chps);

  00111	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00116	3b 44 24 54	 cmp	 eax, DWORD PTR num_chps$[rsp]
  0011a	7d 0b		 jge	 SHORT $LN25@s390_chsc_
  0011c	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00121	89 44 24 58	 mov	 DWORD PTR tv128[rsp], eax
  00125	eb 08		 jmp	 SHORT $LN26@s390_chsc_
$LN25@s390_chsc_:
  00127	8b 44 24 54	 mov	 eax, DWORD PTR num_chps$[rsp]
  0012b	89 44 24 58	 mov	 DWORD PTR tv128[rsp], eax
$LN26@s390_chsc_:
  0012f	0f b7 44 24 58	 movzx	 eax, WORD PTR tv128[rsp]
  00134	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax

; 518  :     rsp_len  = sizeof(CHSC_RSP) + (max_rsp * rsp_size);

  00139	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0013e	48 0f af 44 24
	70		 imul	 rax, QWORD PTR rsp_size$[rsp]
  00144	48 83 c0 08	 add	 rax, 8
  00148	66 89 44 24 3c	 mov	 WORD PTR rsp_len$[rsp], ax

; 519  : 
; 520  :     if (!fmt1)

  0014d	83 7c 24 5c 00	 cmp	 DWORD PTR fmt1$[rsp], 0
  00152	0f 85 13 01 00
	00		 jne	 $LN16@s390_chsc_

; 521  :     {
; 522  :         for(chp = f_chp; chp <= l_chp && max_rsp; chp++, max_rsp--, chsc_rsp2++)

  00158	8b 44 24 30	 mov	 eax, DWORD PTR f_chp$[rsp]
  0015c	89 44 24 24	 mov	 DWORD PTR chp$[rsp], eax
  00160	eb 25		 jmp	 SHORT $LN4@s390_chsc_
$LN2@s390_chsc_:
  00162	8b 44 24 24	 mov	 eax, DWORD PTR chp$[rsp]
  00166	ff c0		 inc	 eax
  00168	89 44 24 24	 mov	 DWORD PTR chp$[rsp], eax
  0016c	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00171	66 ff c8	 dec	 ax
  00174	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  00179	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp2$[rsp]
  0017e	48 83 c0 08	 add	 rax, 8
  00182	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp2$[rsp], rax
$LN4@s390_chsc_:
  00187	8b 44 24 34	 mov	 eax, DWORD PTR l_chp$[rsp]
  0018b	39 44 24 24	 cmp	 DWORD PTR chp$[rsp], eax
  0018f	0f 8f d1 00 00
	00		 jg	 $LN3@s390_chsc_
  00195	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0019a	85 c0		 test	 eax, eax
  0019c	0f 84 c4 00 00
	00		 je	 $LN3@s390_chsc_

; 523  :         {
; 524  :             memset(chsc_rsp2, 0, sizeof(CHSC_RSP2));

  001a2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR chsc_rsp2$[rsp]
  001a7	33 c0		 xor	 eax, eax
  001a9	b9 08 00 00 00	 mov	 ecx, 8
  001ae	f3 aa		 rep stosb

; 525  :             chsc_rsp2->chpid = chp;

  001b0	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp2$[rsp]
  001b5	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR chp$[rsp]
  001ba	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 526  : 
; 527  :             for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  001bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c4	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  001cb	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
  001d0	eb 0e		 jmp	 SHORT $LN7@s390_chsc_
$LN5@s390_chsc_:
  001d2	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  001d7	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001db	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN7@s390_chsc_:
  001e0	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001e6	74 79		 je	 SHORT $LN6@s390_chsc_

; 528  :                 if (dev->allocated
; 529  :                   && (dev->pmcw.chpid[0] == chp)
; 530  :                   && dev->chptype[0])

  001e8	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  001ed	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  001f1	74 69		 je	 SHORT $LN18@s390_chsc_
  001f3	b8 01 00 00 00	 mov	 eax, 1
  001f8	48 6b c0 00	 imul	 rax, rax, 0
  001fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00201	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  00209	3b 44 24 24	 cmp	 eax, DWORD PTR chp$[rsp]
  0020d	75 4d		 jne	 SHORT $LN18@s390_chsc_
  0020f	b8 01 00 00 00	 mov	 eax, 1
  00214	48 6b c0 00	 imul	 rax, rax, 0
  00218	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  0021d	0f b6 84 01 cc
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1484]
  00225	85 c0		 test	 eax, eax
  00227	74 33		 je	 SHORT $LN18@s390_chsc_

; 531  :                 {
; 532  :                     chsc_rsp2->flags1   |= CHSC_RSP2_F1_CHPID_VALID;

  00229	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp2$[rsp]
  0022e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00231	0f ba e8 07	 bts	 eax, 7
  00235	48 8b 4c 24 40	 mov	 rcx, QWORD PTR chsc_rsp2$[rsp]
  0023a	88 01		 mov	 BYTE PTR [rcx], al

; 533  :                     chsc_rsp2->chp_type  = dev->chptype[0];

  0023c	b8 01 00 00 00	 mov	 eax, 1
  00241	48 6b c0 00	 imul	 rax, rax, 0
  00245	48 8b 4c 24 40	 mov	 rcx, QWORD PTR chsc_rsp2$[rsp]
  0024a	48 8b 54 24 28	 mov	 rdx, QWORD PTR dev$[rsp]
  0024f	0f b6 84 02 cc
	05 00 00	 movzx	 eax, BYTE PTR [rdx+rax+1484]
  00257	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 534  : //                  chsc_rsp2->lsn       = 0;
; 535  : //                  chsc_rsp2->swla      = 0;
; 536  : //                  chsc_rsp2->chla      = 0;
; 537  :                     break;

  0025a	eb 05		 jmp	 SHORT $LN6@s390_chsc_
$LN18@s390_chsc_:

; 538  :                 }

  0025c	e9 71 ff ff ff	 jmp	 $LN5@s390_chsc_
$LN6@s390_chsc_:

; 539  :         }

  00261	e9 fc fe ff ff	 jmp	 $LN2@s390_chsc_
$LN3@s390_chsc_:

; 540  :     }

  00266	e9 0e 01 00 00	 jmp	 $LN17@s390_chsc_
$LN16@s390_chsc_:

; 541  :     else
; 542  :     {
; 543  :         for(chp = f_chp; chp <= l_chp && max_rsp; chp++, max_rsp--, chsc_rsp2f1++)

  0026b	8b 44 24 30	 mov	 eax, DWORD PTR f_chp$[rsp]
  0026f	89 44 24 24	 mov	 DWORD PTR chp$[rsp], eax
  00273	eb 25		 jmp	 SHORT $LN10@s390_chsc_
$LN8@s390_chsc_:
  00275	8b 44 24 24	 mov	 eax, DWORD PTR chp$[rsp]
  00279	ff c0		 inc	 eax
  0027b	89 44 24 24	 mov	 DWORD PTR chp$[rsp], eax
  0027f	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00284	66 ff c8	 dec	 ax
  00287	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0028c	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_rsp2f1$[rsp]
  00291	48 83 c0 20	 add	 rax, 32			; 00000020H
  00295	48 89 44 24 48	 mov	 QWORD PTR chsc_rsp2f1$[rsp], rax
$LN10@s390_chsc_:
  0029a	8b 44 24 34	 mov	 eax, DWORD PTR l_chp$[rsp]
  0029e	39 44 24 24	 cmp	 DWORD PTR chp$[rsp], eax
  002a2	0f 8f d1 00 00
	00		 jg	 $LN9@s390_chsc_
  002a8	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  002ad	85 c0		 test	 eax, eax
  002af	0f 84 c4 00 00
	00		 je	 $LN9@s390_chsc_

; 544  :         {
; 545  :             memset(chsc_rsp2f1, 0, sizeof(CHSC_RSP2F1));

  002b5	48 8b 7c 24 48	 mov	 rdi, QWORD PTR chsc_rsp2f1$[rsp]
  002ba	33 c0		 xor	 eax, eax
  002bc	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002c1	f3 aa		 rep stosb

; 546  :             chsc_rsp2f1->chpid = chp;

  002c3	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_rsp2f1$[rsp]
  002c8	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR chp$[rsp]
  002cd	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 547  : 
; 548  :             for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  002d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002d7	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  002de	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
  002e3	eb 0e		 jmp	 SHORT $LN13@s390_chsc_
$LN11@s390_chsc_:
  002e5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  002ea	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002ee	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN13@s390_chsc_:
  002f3	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002f9	74 79		 je	 SHORT $LN12@s390_chsc_

; 549  :                 if (dev->allocated
; 550  :                   && (dev->pmcw.chpid[0] == chp)
; 551  :                   && dev->chptype[0])

  002fb	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00300	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00304	74 69		 je	 SHORT $LN19@s390_chsc_
  00306	b8 01 00 00 00	 mov	 eax, 1
  0030b	48 6b c0 00	 imul	 rax, rax, 0
  0030f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00314	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  0031c	3b 44 24 24	 cmp	 eax, DWORD PTR chp$[rsp]
  00320	75 4d		 jne	 SHORT $LN19@s390_chsc_
  00322	b8 01 00 00 00	 mov	 eax, 1
  00327	48 6b c0 00	 imul	 rax, rax, 0
  0032b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00330	0f b6 84 01 cc
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1484]
  00338	85 c0		 test	 eax, eax
  0033a	74 33		 je	 SHORT $LN19@s390_chsc_

; 552  :                 {
; 553  :                     chsc_rsp2f1->flags1   |= CHSC_RSP2F1_F1_CHPID_VALID;

  0033c	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_rsp2f1$[rsp]
  00341	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00344	0f ba e8 07	 bts	 eax, 7
  00348	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_rsp2f1$[rsp]
  0034d	88 01		 mov	 BYTE PTR [rcx], al

; 554  :                     chsc_rsp2f1->chp_type  = dev->chptype[0];

  0034f	b8 01 00 00 00	 mov	 eax, 1
  00354	48 6b c0 00	 imul	 rax, rax, 0
  00358	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_rsp2f1$[rsp]
  0035d	48 8b 54 24 28	 mov	 rdx, QWORD PTR dev$[rsp]
  00362	0f b6 84 02 cc
	05 00 00	 movzx	 eax, BYTE PTR [rdx+rax+1484]
  0036a	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 555  : //                  chsc_rsp2f1->lsn       = 0;
; 556  : //                  chsc_rsp2f1->chpp      = 0;
; 557  : //                  STORE_HW(chsc_rsp2f1->mdc,0x0000);
; 558  : //                  STORE_HW(chsc_rsp2f1->flags2,0x0000);
; 559  :                     break;

  0036d	eb 05		 jmp	 SHORT $LN12@s390_chsc_
$LN19@s390_chsc_:

; 560  :                 }

  0036f	e9 71 ff ff ff	 jmp	 $LN11@s390_chsc_
$LN12@s390_chsc_:

; 561  :         }

  00374	e9 fc fe ff ff	 jmp	 $LN8@s390_chsc_
$LN9@s390_chsc_:
$LN17@s390_chsc_:

; 562  :     }
; 563  : 
; 564  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  00379	45 33 c0	 xor	 r8d, r8d
  0037c	0f b7 54 24 3c	 movzx	 edx, WORD PTR rsp_len$[rsp]
  00381	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00389	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@s390_chsc_:

; 565  : }

  0038e	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00395	5f		 pop	 rdi
  00396	c3		 ret	 0
s390_chsc_get_chp_desc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
req_len$ = 32
rsp_len$ = 36
ssid$ = 40
rc$ = 44
dev$ = 48
chsc_req21$ = 56
chsc_req$ = 80
chsc_rsp$ = 88
s390_chsc_set_sci PROC

; 460  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 461  : U16 req_len, rsp_len;
; 462  : DEVBLK *dev;
; 463  : U32 ssid;
; 464  : int rc;
; 465  : 
; 466  : CHSC_REQ21 *chsc_req21 = (CHSC_REQ21 *)(chsc_req);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00013	48 89 44 24 38	 mov	 QWORD PTR chsc_req21$[rsp], rax

; 467  : 
; 468  :     FETCH_HW( req_len, chsc_req21->length );

  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR chsc_req21$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_hw_noswap
  00025	0f b7 c8	 movzx	 ecx, ax
  00028	e8 00 00 00 00	 call	 _byteswap_ushort
  0002d	66 89 44 24 20	 mov	 WORD PTR req_len$[rsp], ax

; 469  : 
; 470  :     rsp_len = sizeof(CHSC_RSP) + 0;

  00032	b8 08 00 00 00	 mov	 eax, 8
  00037	66 89 44 24 24	 mov	 WORD PTR rsp_len$[rsp], ax

; 471  : 
; 472  :     if (!chsc_max_rsp(req_len, 0))

  0003c	33 d2		 xor	 edx, edx
  0003e	0f b7 4c 24 20	 movzx	 ecx, WORD PTR req_len$[rsp]
  00043	e8 00 00 00 00	 call	 chsc_max_rsp
  00048	0f b7 c0	 movzx	 eax, ax
  0004b	85 c0		 test	 eax, eax
  0004d	75 11		 jne	 SHORT $LN2@s390_chsc_

; 473  :         return chsc_req_errreq(chsc_rsp, 0);

  0004f	33 d2		 xor	 edx, edx
  00051	48 8b 4c 24 58	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00056	e8 00 00 00 00	 call	 chsc_req_errreq
  0005b	e9 94 00 00 00	 jmp	 $LN1@s390_chsc_
$LN2@s390_chsc_:

; 474  : 
; 475  :     /* Fetch requested Subchannel Id */
; 476  :     FETCH_FW(ssid, chsc_req21->ssid);

  00060	48 8b 44 24 38	 mov	 rax, QWORD PTR chsc_req21$[rsp]
  00065	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00069	48 8b c8	 mov	 rcx, rax
  0006c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00071	8b c8		 mov	 ecx, eax
  00073	e8 00 00 00 00	 call	 _byteswap_ulong
  00078	89 44 24 28	 mov	 DWORD PTR ssid$[rsp], eax

; 477  : 
; 478  :     if((dev = find_device_by_subchan(ssid)))

  0007c	8b 4c 24 28	 mov	 ecx, DWORD PTR ssid$[rsp]
  00080	e8 00 00 00 00	 call	 find_device_by_subchan
  00085	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  0008a	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00090	74 50		 je	 SHORT $LN3@s390_chsc_

; 479  :         if(dev->hnd->ssci)

  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00097	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0009e	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  000a6	74 3a		 je	 SHORT $LN4@s390_chsc_

; 480  :             if(!(rc = (dev->hnd->ssci)(dev, chsc_req21)))

  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000ad	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000b4	48 8b 54 24 38	 mov	 rdx, QWORD PTR chsc_req21$[rsp]
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000be	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  000c4	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax
  000c8	83 7c 24 2c 00	 cmp	 DWORD PTR rc$[rsp], 0
  000cd	75 13		 jne	 SHORT $LN5@s390_chsc_

; 481  :                 return chsc_req_ok(chsc_rsp, sizeof(CHSC_RSP), 0);

  000cf	45 33 c0	 xor	 r8d, r8d
  000d2	66 ba 08 00	 mov	 dx, 8
  000d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000db	e8 00 00 00 00	 call	 chsc_req_ok
  000e0	eb 12		 jmp	 SHORT $LN1@s390_chsc_
$LN5@s390_chsc_:
$LN4@s390_chsc_:
$LN3@s390_chsc_:

; 482  : 
; 483  : //  return chsc_req_errreq(chsc_rsp, 0);
; 484  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  000e2	45 33 c0	 xor	 r8d, r8d
  000e5	0f b7 54 24 24	 movzx	 edx, WORD PTR rsp_len$[rsp]
  000ea	48 8b 4c 24 58	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000ef	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@s390_chsc_:

; 485  : }

  000f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f8	c3		 ret	 0
s390_chsc_set_sci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
max_rsp$ = 32
lcss$ = 36
sch$ = 40
work$ = 44
f_sch$ = 48
l_sch$ = 52
req_len$ = 56
rsp_len$ = 60
chsc_rsp24$ = 64
num_sch$ = 72
tv142 = 76
max_sch$ = 80
chsc_req24$ = 88
dev$1 = 96
chsc_req$ = 128
chsc_rsp$ = 136
s390_chsc_get_ssqd PROC

; 368  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 369  : U16 req_len, rsp_len, lcss, max_rsp, work;
; 370  : int sch, f_sch, l_sch, num_sch, max_sch;
; 371  : 
; 372  : CHSC_REQ24 *chsc_req24 = (CHSC_REQ24 *)(chsc_req);

  0000f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00017	48 89 44 24 58	 mov	 QWORD PTR chsc_req24$[rsp], rax

; 373  : CHSC_RSP24 *chsc_rsp24 = (CHSC_RSP24 *)(chsc_rsp+1);

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp24$[rsp], rax

; 374  : 
; 375  :     FETCH_HW(work,chsc_req24->f_sch); f_sch = work;

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req24$[rsp]
  00032	48 83 c0 06	 add	 rax, 6
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_hw_noswap
  0003e	0f b7 c8	 movzx	 ecx, ax
  00041	e8 00 00 00 00	 call	 _byteswap_ushort
  00046	66 89 44 24 2c	 mov	 WORD PTR work$[rsp], ax
  0004b	0f b7 44 24 2c	 movzx	 eax, WORD PTR work$[rsp]
  00050	89 44 24 30	 mov	 DWORD PTR f_sch$[rsp], eax

; 376  :     FETCH_HW(work,chsc_req24->l_sch); l_sch = work;

  00054	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req24$[rsp]
  00059	48 83 c0 0a	 add	 rax, 10
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 fetch_hw_noswap
  00065	0f b7 c8	 movzx	 ecx, ax
  00068	e8 00 00 00 00	 call	 _byteswap_ushort
  0006d	66 89 44 24 2c	 mov	 WORD PTR work$[rsp], ax
  00072	0f b7 44 24 2c	 movzx	 eax, WORD PTR work$[rsp]
  00077	89 44 24 34	 mov	 DWORD PTR l_sch$[rsp], eax

; 377  :     FETCH_HW(lcss,chsc_req24->ssidfmt);

  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req24$[rsp]
  00080	48 83 c0 04	 add	 rax, 4
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 fetch_hw_noswap
  0008c	0f b7 c8	 movzx	 ecx, ax
  0008f	e8 00 00 00 00	 call	 _byteswap_ushort
  00094	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 378  :     lcss &= CHSC_REQ24_SSID;

  00099	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  0009e	83 e0 30	 and	 eax, 48			; 00000030H
  000a1	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 379  :     lcss >>= 4;

  000a6	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  000ab	66 c1 e8 04	 shr	 ax, 4
  000af	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 380  : 
; 381  :     FETCH_HW(req_len, chsc_req24->length);

  000b4	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req24$[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 fetch_hw_noswap
  000c1	0f b7 c8	 movzx	 ecx, ax
  000c4	e8 00 00 00 00	 call	 _byteswap_ushort
  000c9	66 89 44 24 38	 mov	 WORD PTR req_len$[rsp], ax

; 382  : 
; 383  :     if (!(max_rsp = chsc_max_rsp(req_len, sizeof(CHSC_RSP24))) || l_sch < f_sch)

  000ce	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d3	0f b7 4c 24 38	 movzx	 ecx, WORD PTR req_len$[rsp]
  000d8	e8 00 00 00 00	 call	 chsc_max_rsp
  000dd	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  000e2	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  000e7	85 c0		 test	 eax, eax
  000e9	74 0a		 je	 SHORT $LN9@s390_chsc_
  000eb	8b 44 24 30	 mov	 eax, DWORD PTR f_sch$[rsp]
  000ef	39 44 24 34	 cmp	 DWORD PTR l_sch$[rsp], eax
  000f3	7d 14		 jge	 SHORT $LN8@s390_chsc_
$LN9@s390_chsc_:

; 384  :         return chsc_req_errreq(chsc_rsp, 0);

  000f5	33 d2		 xor	 edx, edx
  000f7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000ff	e8 00 00 00 00	 call	 chsc_req_errreq
  00104	e9 92 01 00 00	 jmp	 $LN1@s390_chsc_
$LN8@s390_chsc_:

; 385  : 
; 386  :     num_sch = (l_sch - f_sch) + 1;

  00109	8b 44 24 30	 mov	 eax, DWORD PTR f_sch$[rsp]
  0010d	8b 4c 24 34	 mov	 ecx, DWORD PTR l_sch$[rsp]
  00111	2b c8		 sub	 ecx, eax
  00113	8b c1		 mov	 eax, ecx
  00115	ff c0		 inc	 eax
  00117	89 44 24 48	 mov	 DWORD PTR num_sch$[rsp], eax

; 387  :     max_sch = sysblk.highsubchan[lcss]-1;

  0011b	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  00120	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00127	8b 84 81 e0 11
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4576]
  0012e	ff c8		 dec	 eax
  00130	89 44 24 50	 mov	 DWORD PTR max_sch$[rsp], eax

; 388  :     max_rsp = (U16) min((int)max_rsp, num_sch);

  00134	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00139	3b 44 24 48	 cmp	 eax, DWORD PTR num_sch$[rsp]
  0013d	7d 0b		 jge	 SHORT $LN16@s390_chsc_
  0013f	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00144	89 44 24 4c	 mov	 DWORD PTR tv142[rsp], eax
  00148	eb 08		 jmp	 SHORT $LN17@s390_chsc_
$LN16@s390_chsc_:
  0014a	8b 44 24 48	 mov	 eax, DWORD PTR num_sch$[rsp]
  0014e	89 44 24 4c	 mov	 DWORD PTR tv142[rsp], eax
$LN17@s390_chsc_:
  00152	0f b7 44 24 4c	 movzx	 eax, WORD PTR tv142[rsp]
  00157	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax

; 389  :     rsp_len = sizeof(CHSC_RSP) + (max_rsp * sizeof(CHSC_RSP24));

  0015c	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00161	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00165	48 83 c0 08	 add	 rax, 8
  00169	66 89 44 24 3c	 mov	 WORD PTR rsp_len$[rsp], ax

; 390  : 
; 391  :     if (f_sch <= max_sch)

  0016e	8b 44 24 50	 mov	 eax, DWORD PTR max_sch$[rsp]
  00172	39 44 24 30	 cmp	 DWORD PTR f_sch$[rsp], eax
  00176	0f 8f b8 00 00
	00		 jg	 $LN10@s390_chsc_

; 392  :     {
; 393  :     DEVBLK *dev;
; 394  : 
; 395  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp24++)

  0017c	8b 44 24 30	 mov	 eax, DWORD PTR f_sch$[rsp]
  00180	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00184	eb 25		 jmp	 SHORT $LN4@s390_chsc_
$LN2@s390_chsc_:
  00186	8b 44 24 28	 mov	 eax, DWORD PTR sch$[rsp]
  0018a	ff c0		 inc	 eax
  0018c	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00190	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00195	66 ff c8	 dec	 ax
  00198	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0019d	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp24$[rsp]
  001a2	48 83 c0 20	 add	 rax, 32			; 00000020H
  001a6	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp24$[rsp], rax
$LN4@s390_chsc_:
  001ab	8b 44 24 34	 mov	 eax, DWORD PTR l_sch$[rsp]
  001af	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  001b3	7f 7d		 jg	 SHORT $LN3@s390_chsc_
  001b5	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  001ba	85 c0		 test	 eax, eax
  001bc	74 74		 je	 SHORT $LN3@s390_chsc_

; 396  :         {
; 397  :             memset(chsc_rsp24, 0, sizeof(CHSC_RSP24) );

  001be	48 8b 7c 24 40	 mov	 rdi, QWORD PTR chsc_rsp24$[rsp]
  001c3	33 c0		 xor	 eax, eax
  001c5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001ca	f3 aa		 rep stosb

; 398  :             if (sch <= max_sch)

  001cc	8b 44 24 50	 mov	 eax, DWORD PTR max_sch$[rsp]
  001d0	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  001d4	7f 57		 jg	 SHORT $LN12@s390_chsc_

; 399  :             {
; 400  :                 if((dev = find_device_by_subchan((LCSS_TO_SSID(lcss) << 16)|sch)))

  001d6	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  001db	d1 e0		 shl	 eax, 1
  001dd	83 c8 01	 or	 eax, 1
  001e0	c1 e0 10	 shl	 eax, 16
  001e3	0b 44 24 28	 or	 eax, DWORD PTR sch$[rsp]
  001e7	8b c8		 mov	 ecx, eax
  001e9	e8 00 00 00 00	 call	 find_device_by_subchan
  001ee	48 89 44 24 60	 mov	 QWORD PTR dev$1[rsp], rax
  001f3	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$1[rsp], 0
  001f9	74 32		 je	 SHORT $LN13@s390_chsc_

; 401  :                     if(dev->hnd->ssqd)

  001fb	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$1[rsp]
  00200	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00207	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  0020f	74 1c		 je	 SHORT $LN14@s390_chsc_

; 402  :                         (dev->hnd->ssqd)(dev, chsc_rsp24);

  00211	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$1[rsp]
  00216	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0021d	48 8b 54 24 40	 mov	 rdx, QWORD PTR chsc_rsp24$[rsp]
  00222	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$1[rsp]
  00227	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]
$LN14@s390_chsc_:
$LN13@s390_chsc_:
$LN12@s390_chsc_:

; 403  :             }
; 404  :         }

  0022d	e9 54 ff ff ff	 jmp	 $LN2@s390_chsc_
$LN3@s390_chsc_:

; 405  :     }

  00232	eb 52		 jmp	 SHORT $LN11@s390_chsc_
$LN10@s390_chsc_:

; 406  :     else /* f_sch > max_sch */
; 407  :     {
; 408  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp24++)

  00234	8b 44 24 30	 mov	 eax, DWORD PTR f_sch$[rsp]
  00238	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  0023c	eb 25		 jmp	 SHORT $LN7@s390_chsc_
$LN5@s390_chsc_:
  0023e	8b 44 24 28	 mov	 eax, DWORD PTR sch$[rsp]
  00242	ff c0		 inc	 eax
  00244	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00248	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0024d	66 ff c8	 dec	 ax
  00250	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  00255	48 8b 44 24 40	 mov	 rax, QWORD PTR chsc_rsp24$[rsp]
  0025a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0025e	48 89 44 24 40	 mov	 QWORD PTR chsc_rsp24$[rsp], rax
$LN7@s390_chsc_:
  00263	8b 44 24 34	 mov	 eax, DWORD PTR l_sch$[rsp]
  00267	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  0026b	7f 19		 jg	 SHORT $LN6@s390_chsc_
  0026d	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00272	85 c0		 test	 eax, eax
  00274	74 10		 je	 SHORT $LN6@s390_chsc_

; 409  :             memset(chsc_rsp24, 0, sizeof(CHSC_RSP24) );

  00276	48 8b 7c 24 40	 mov	 rdi, QWORD PTR chsc_rsp24$[rsp]
  0027b	33 c0		 xor	 eax, eax
  0027d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00282	f3 aa		 rep stosb
  00284	eb b8		 jmp	 SHORT $LN5@s390_chsc_
$LN6@s390_chsc_:
$LN11@s390_chsc_:

; 410  :     }
; 411  : 
; 412  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  00286	45 33 c0	 xor	 r8d, r8d
  00289	0f b7 54 24 3c	 movzx	 edx, WORD PTR rsp_len$[rsp]
  0028e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00296	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@s390_chsc_:

; 413  : }

  0029b	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0029f	5f		 pop	 rdi
  002a0	c3		 ret	 0
s390_chsc_get_ssqd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
req_len$ = 32
rsp_len$ = 36
chsc_rsp10$ = 40
regs$ = 64
chsc_req$ = 72
chsc_rsp$ = 80
s390_chsc_get_css_info PROC

; 283  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 284  : CHSC_RSP10 *chsc_rsp10;
; 285  : U16 req_len, rsp_len;
; 286  : 
; 287  :     chsc_rsp10 = (CHSC_RSP10 *)(chsc_rsp+1);

  00014	48 8b 44 24 50	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00019	48 83 c0 08	 add	 rax, 8
  0001d	48 89 44 24 28	 mov	 QWORD PTR chsc_rsp10$[rsp], rax

; 288  : 
; 289  :     FETCH_HW(req_len, chsc_req->length);

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002f	0f b7 c8	 movzx	 ecx, ax
  00032	e8 00 00 00 00	 call	 _byteswap_ushort
  00037	66 89 44 24 20	 mov	 WORD PTR req_len$[rsp], ax

; 290  : 
; 291  :     rsp_len = sizeof(CHSC_RSP) + sizeof(CHSC_RSP10);

  0003c	b8 f0 0f 00 00	 mov	 eax, 4080		; 00000ff0H
  00041	66 89 44 24 24	 mov	 WORD PTR rsp_len$[rsp], ax

; 292  : 
; 293  :     if (!chsc_max_rsp(req_len, sizeof(CHSC_RSP10)))

  00046	ba e8 0f 00 00	 mov	 edx, 4072		; 00000fe8H
  0004b	0f b7 4c 24 20	 movzx	 ecx, WORD PTR req_len$[rsp]
  00050	e8 00 00 00 00	 call	 chsc_max_rsp
  00055	0f b7 c0	 movzx	 eax, ax
  00058	85 c0		 test	 eax, eax
  0005a	75 11		 jne	 SHORT $LN56@s390_chsc_

; 294  :         return chsc_req_errreq(chsc_rsp, 0);

  0005c	33 d2		 xor	 edx, edx
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00063	e8 00 00 00 00	 call	 chsc_req_errreq
  00068	e9 1a 06 00 00	 jmp	 $LN1@s390_chsc_
$LN56@s390_chsc_:

; 295  : 
; 296  :     memset(chsc_rsp10->general_char, 0, sizeof(chsc_rsp10->general_char));

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR chsc_rsp10$[rsp]
  00072	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00077	33 c0		 xor	 eax, eax
  00079	b9 f8 07 00 00	 mov	 ecx, 2040		; 000007f8H
  0007e	f3 aa		 rep stosb

; 297  :     memset(chsc_rsp10->chsc_char,    0, sizeof(chsc_rsp10->chsc_char));

  00080	48 8b 44 24 28	 mov	 rax, QWORD PTR chsc_rsp10$[rsp]
  00085	48 05 f8 07 00
	00		 add	 rax, 2040		; 000007f8H
  0008b	48 8b f8	 mov	 rdi, rax
  0008e	33 c0		 xor	 eax, eax
  00090	b9 f0 07 00 00	 mov	 ecx, 2032		; 000007f0H
  00095	f3 aa		 rep stosb
$LN4@s390_chsc_:

; 298  : 
; 299  : #if defined(FEATURE_REGION_RELOCATE)
; 300  :     CHSC_SB(chsc_rsp10->general_char,2);

  00097	b8 04 00 00 00	 mov	 eax, 4
  0009c	48 6b c0 00	 imul	 rax, rax, 0
  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  000a5	48 03 c8	 add	 rcx, rax
  000a8	48 8b c1	 mov	 rax, rcx
  000ab	b9 01 00 00 00	 mov	 ecx, 1
  000b0	48 6b c9 00	 imul	 rcx, rcx, 0
  000b4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000b8	83 c8 20	 or	 eax, 32			; 00000020H
  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	48 6b c9 00	 imul	 rcx, rcx, 0
  000c4	ba 04 00 00 00	 mov	 edx, 4
  000c9	48 6b d2 00	 imul	 rdx, rdx, 0
  000cd	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  000d2	48 03 fa	 add	 rdi, rdx
  000d5	48 8b d7	 mov	 rdx, rdi
  000d8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000db	33 c0		 xor	 eax, eax
  000dd	85 c0		 test	 eax, eax
  000df	75 b6		 jne	 SHORT $LN4@s390_chsc_
$LN7@s390_chsc_:

; 301  :     CHSC_SB(chsc_rsp10->general_char,5);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	48 6b c0 00	 imul	 rax, rax, 0
  000ea	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  000ef	48 03 c8	 add	 rcx, rax
  000f2	48 8b c1	 mov	 rax, rcx
  000f5	b9 01 00 00 00	 mov	 ecx, 1
  000fa	48 6b c9 00	 imul	 rcx, rcx, 0
  000fe	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00102	83 c8 04	 or	 eax, 4
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	48 6b c9 00	 imul	 rcx, rcx, 0
  0010e	ba 04 00 00 00	 mov	 edx, 4
  00113	48 6b d2 00	 imul	 rdx, rdx, 0
  00117	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  0011c	48 03 fa	 add	 rdi, rdx
  0011f	48 8b d7	 mov	 rdx, rdi
  00122	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00125	33 c0		 xor	 eax, eax
  00127	85 c0		 test	 eax, eax
  00129	75 b6		 jne	 SHORT $LN7@s390_chsc_
$LN10@s390_chsc_:

; 302  : #endif
; 303  : #if defined(FEATURE_CANCEL_IO_FACILITY)
; 304  :     CHSC_SB(chsc_rsp10->general_char,6);

  0012b	b8 04 00 00 00	 mov	 eax, 4
  00130	48 6b c0 00	 imul	 rax, rax, 0
  00134	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00139	48 03 c8	 add	 rcx, rax
  0013c	48 8b c1	 mov	 rax, rcx
  0013f	b9 01 00 00 00	 mov	 ecx, 1
  00144	48 6b c9 00	 imul	 rcx, rcx, 0
  00148	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0014c	83 c8 02	 or	 eax, 2
  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	48 6b c9 00	 imul	 rcx, rcx, 0
  00158	ba 04 00 00 00	 mov	 edx, 4
  0015d	48 6b d2 00	 imul	 rdx, rdx, 0
  00161	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00166	48 03 fa	 add	 rdi, rdx
  00169	48 8b d7	 mov	 rdx, rdi
  0016c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0016f	33 c0		 xor	 eax, eax
  00171	85 c0		 test	 eax, eax
  00173	75 b6		 jne	 SHORT $LN10@s390_chsc_
$LN13@s390_chsc_:

; 305  : #endif
; 306  : 
; 307  :     CHSC_SB(chsc_rsp10->general_char,7);         /* Concurrent Sense */

  00175	b8 04 00 00 00	 mov	 eax, 4
  0017a	48 6b c0 00	 imul	 rax, rax, 0
  0017e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00183	48 03 c8	 add	 rcx, rax
  00186	48 8b c1	 mov	 rax, rcx
  00189	b9 01 00 00 00	 mov	 ecx, 1
  0018e	48 6b c9 00	 imul	 rcx, rcx, 0
  00192	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00196	83 c8 01	 or	 eax, 1
  00199	b9 01 00 00 00	 mov	 ecx, 1
  0019e	48 6b c9 00	 imul	 rcx, rcx, 0
  001a2	ba 04 00 00 00	 mov	 edx, 4
  001a7	48 6b d2 00	 imul	 rdx, rdx, 0
  001ab	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  001b0	48 03 fa	 add	 rdi, rdx
  001b3	48 8b d7	 mov	 rdx, rdi
  001b6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001b9	33 c0		 xor	 eax, eax
  001bb	85 c0		 test	 eax, eax
  001bd	75 b6		 jne	 SHORT $LN13@s390_chsc_
$LN16@s390_chsc_:

; 308  :     CHSC_SB(chsc_rsp10->general_char,12);              /* Dynamic IO */

  001bf	b8 04 00 00 00	 mov	 eax, 4
  001c4	48 6b c0 00	 imul	 rax, rax, 0
  001c8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  001cd	48 03 c8	 add	 rcx, rax
  001d0	48 8b c1	 mov	 rax, rcx
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	48 6b c9 01	 imul	 rcx, rcx, 1
  001dc	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001e0	83 c8 08	 or	 eax, 8
  001e3	b9 01 00 00 00	 mov	 ecx, 1
  001e8	48 6b c9 01	 imul	 rcx, rcx, 1
  001ec	ba 04 00 00 00	 mov	 edx, 4
  001f1	48 6b d2 00	 imul	 rdx, rdx, 0
  001f5	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  001fa	48 03 fa	 add	 rdi, rdx
  001fd	48 8b d7	 mov	 rdx, rdi
  00200	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00203	33 c0		 xor	 eax, eax
  00205	85 c0		 test	 eax, eax
  00207	75 b6		 jne	 SHORT $LN16@s390_chsc_

; 309  : 
; 310  :     if (sysblk.lparmode)

  00209	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00210	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [rax+236]
  00216	83 e0 01	 and	 eax, 1
  00219	85 c0		 test	 eax, eax
  0021b	0f 84 94 00 00
	00		 je	 $LN57@s390_chsc_
$LN19@s390_chsc_:

; 311  :     {
; 312  :         CHSC_SB(chsc_rsp10->general_char,10);                 /* MIF */

  00221	b8 04 00 00 00	 mov	 eax, 4
  00226	48 6b c0 00	 imul	 rax, rax, 0
  0022a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  0022f	48 03 c8	 add	 rcx, rax
  00232	48 8b c1	 mov	 rax, rcx
  00235	b9 01 00 00 00	 mov	 ecx, 1
  0023a	48 6b c9 01	 imul	 rcx, rcx, 1
  0023e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00242	83 c8 20	 or	 eax, 32			; 00000020H
  00245	b9 01 00 00 00	 mov	 ecx, 1
  0024a	48 6b c9 01	 imul	 rcx, rcx, 1
  0024e	ba 04 00 00 00	 mov	 edx, 4
  00253	48 6b d2 00	 imul	 rdx, rdx, 0
  00257	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  0025c	48 03 fa	 add	 rdi, rdx
  0025f	48 8b d7	 mov	 rdx, rdi
  00262	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00265	33 c0		 xor	 eax, eax
  00267	85 c0		 test	 eax, eax
  00269	75 b6		 jne	 SHORT $LN19@s390_chsc_
$LN22@s390_chsc_:

; 313  :         CHSC_SB(chsc_rsp10->general_char,13);                /* LPAR */

  0026b	b8 04 00 00 00	 mov	 eax, 4
  00270	48 6b c0 00	 imul	 rax, rax, 0
  00274	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00279	48 03 c8	 add	 rcx, rax
  0027c	48 8b c1	 mov	 rax, rcx
  0027f	b9 01 00 00 00	 mov	 ecx, 1
  00284	48 6b c9 01	 imul	 rcx, rcx, 1
  00288	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0028c	83 c8 04	 or	 eax, 4
  0028f	b9 01 00 00 00	 mov	 ecx, 1
  00294	48 6b c9 01	 imul	 rcx, rcx, 1
  00298	ba 04 00 00 00	 mov	 edx, 4
  0029d	48 6b d2 00	 imul	 rdx, rdx, 0
  002a1	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  002a6	48 03 fa	 add	 rdi, rdx
  002a9	48 8b d7	 mov	 rdx, rdi
  002ac	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002af	33 c0		 xor	 eax, eax
  002b1	85 c0		 test	 eax, eax
  002b3	75 b6		 jne	 SHORT $LN22@s390_chsc_
$LN57@s390_chsc_:
$LN25@s390_chsc_:

; 314  :     }
; 315  : 
; 316  : #if defined(FEATURE_QUEUED_DIRECT_IO)
; 317  :     CHSC_SB(chsc_rsp10->general_char,41);         /* Adapter Int Fac */

  002b5	b8 04 00 00 00	 mov	 eax, 4
  002ba	48 6b c0 01	 imul	 rax, rax, 1
  002be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  002c3	48 03 c8	 add	 rcx, rax
  002c6	48 8b c1	 mov	 rax, rcx
  002c9	b9 01 00 00 00	 mov	 ecx, 1
  002ce	48 6b c9 01	 imul	 rcx, rcx, 1
  002d2	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002d6	83 c8 40	 or	 eax, 64			; 00000040H
  002d9	b9 01 00 00 00	 mov	 ecx, 1
  002de	48 6b c9 01	 imul	 rcx, rcx, 1
  002e2	ba 04 00 00 00	 mov	 edx, 4
  002e7	48 6b d2 01	 imul	 rdx, rdx, 1
  002eb	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  002f0	48 03 fa	 add	 rdi, rdx
  002f3	48 8b d7	 mov	 rdx, rdi
  002f6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002f9	33 c0		 xor	 eax, eax
  002fb	85 c0		 test	 eax, eax
  002fd	75 b6		 jne	 SHORT $LN25@s390_chsc_
$LN28@s390_chsc_:

; 318  : 
; 319  :     CHSC_SB(chsc_rsp10->chsc_char,1);            /* 0x0002 Supported */

  002ff	b8 04 00 00 00	 mov	 eax, 4
  00304	48 6b c0 00	 imul	 rax, rax, 0
  00308	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  0030d	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  00315	b9 01 00 00 00	 mov	 ecx, 1
  0031a	48 6b c9 00	 imul	 rcx, rcx, 0
  0031e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00322	83 c8 40	 or	 eax, 64			; 00000040H
  00325	b9 01 00 00 00	 mov	 ecx, 1
  0032a	48 6b c9 00	 imul	 rcx, rcx, 0
  0032e	ba 04 00 00 00	 mov	 edx, 4
  00333	48 6b d2 00	 imul	 rdx, rdx, 0
  00337	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  0033c	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  00344	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00347	33 c0		 xor	 eax, eax
  00349	85 c0		 test	 eax, eax
  0034b	75 b2		 jne	 SHORT $LN28@s390_chsc_
$LN31@s390_chsc_:

; 320  :     CHSC_SB(chsc_rsp10->chsc_char,2);            /* 0x0006 Supported */

  0034d	b8 04 00 00 00	 mov	 eax, 4
  00352	48 6b c0 00	 imul	 rax, rax, 0
  00356	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  0035b	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  00363	b9 01 00 00 00	 mov	 ecx, 1
  00368	48 6b c9 00	 imul	 rcx, rcx, 0
  0036c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00370	83 c8 20	 or	 eax, 32			; 00000020H
  00373	b9 01 00 00 00	 mov	 ecx, 1
  00378	48 6b c9 00	 imul	 rcx, rcx, 0
  0037c	ba 04 00 00 00	 mov	 edx, 4
  00381	48 6b d2 00	 imul	 rdx, rdx, 0
  00385	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  0038a	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  00392	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00395	33 c0		 xor	 eax, eax
  00397	85 c0		 test	 eax, eax
  00399	75 b2		 jne	 SHORT $LN31@s390_chsc_
$LN34@s390_chsc_:

; 321  :     CHSC_SB(chsc_rsp10->chsc_char,3);            /* 0x0004 Supported */

  0039b	b8 04 00 00 00	 mov	 eax, 4
  003a0	48 6b c0 00	 imul	 rax, rax, 0
  003a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  003a9	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  003b1	b9 01 00 00 00	 mov	 ecx, 1
  003b6	48 6b c9 00	 imul	 rcx, rcx, 0
  003ba	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003be	83 c8 10	 or	 eax, 16
  003c1	b9 01 00 00 00	 mov	 ecx, 1
  003c6	48 6b c9 00	 imul	 rcx, rcx, 0
  003ca	ba 04 00 00 00	 mov	 edx, 4
  003cf	48 6b d2 00	 imul	 rdx, rdx, 0
  003d3	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  003d8	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  003e0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003e3	33 c0		 xor	 eax, eax
  003e5	85 c0		 test	 eax, eax
  003e7	75 b2		 jne	 SHORT $LN34@s390_chsc_
$LN37@s390_chsc_:

; 322  :     CHSC_SB(chsc_rsp10->chsc_char,8);            /* 0x0024 Supported */

  003e9	b8 04 00 00 00	 mov	 eax, 4
  003ee	48 6b c0 00	 imul	 rax, rax, 0
  003f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  003f7	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  003ff	b9 01 00 00 00	 mov	 ecx, 1
  00404	48 6b c9 01	 imul	 rcx, rcx, 1
  00408	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0040c	0f ba e8 07	 bts	 eax, 7
  00410	b9 01 00 00 00	 mov	 ecx, 1
  00415	48 6b c9 01	 imul	 rcx, rcx, 1
  00419	ba 04 00 00 00	 mov	 edx, 4
  0041e	48 6b d2 00	 imul	 rdx, rdx, 0
  00422	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00427	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  0042f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00432	33 c0		 xor	 eax, eax
  00434	85 c0		 test	 eax, eax
  00436	75 b1		 jne	 SHORT $LN37@s390_chsc_

; 323  : 
; 324  :     if (FACILITY_ENABLED( HERC_QDIO_ASSIST, regs ))

  00438	b8 01 00 00 00	 mov	 eax, 1
  0043d	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00441	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00446	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0044e	83 e0 40	 and	 eax, 64			; 00000040H
  00451	85 c0		 test	 eax, eax
  00453	74 4a		 je	 SHORT $LN58@s390_chsc_
$LN40@s390_chsc_:

; 325  :         CHSC_SB(chsc_rsp10->general_char,61);         /* QDIO Assist */

  00455	b8 04 00 00 00	 mov	 eax, 4
  0045a	48 6b c0 01	 imul	 rax, rax, 1
  0045e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00463	48 03 c8	 add	 rcx, rax
  00466	48 8b c1	 mov	 rax, rcx
  00469	b9 01 00 00 00	 mov	 ecx, 1
  0046e	48 6b c9 03	 imul	 rcx, rcx, 3
  00472	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00476	83 c8 04	 or	 eax, 4
  00479	b9 01 00 00 00	 mov	 ecx, 1
  0047e	48 6b c9 03	 imul	 rcx, rcx, 3
  00482	ba 04 00 00 00	 mov	 edx, 4
  00487	48 6b d2 01	 imul	 rdx, rdx, 1
  0048b	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00490	48 03 fa	 add	 rdi, rdx
  00493	48 8b d7	 mov	 rdx, rdi
  00496	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00499	33 c0		 xor	 eax, eax
  0049b	85 c0		 test	 eax, eax
  0049d	75 b6		 jne	 SHORT $LN40@s390_chsc_
$LN58@s390_chsc_:

; 326  : #endif /*defined(FEATURE_QUEUED_DIRECT_IO)*/
; 327  : 
; 328  : #if defined(_FEATURE_QDIO_TDD)
; 329  :     if (FACILITY_ENABLED( HERC_QDIO_TDD, regs ))

  0049f	b8 01 00 00 00	 mov	 eax, 1
  004a4	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  004a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  004ad	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  004b5	83 e0 20	 and	 eax, 32			; 00000020H
  004b8	85 c0		 test	 eax, eax
  004ba	74 4b		 je	 SHORT $LN59@s390_chsc_
$LN43@s390_chsc_:

; 330  :         CHSC_SB(chsc_rsp10->general_char,56);  /* AIF Time Delay Dis */

  004bc	b8 04 00 00 00	 mov	 eax, 4
  004c1	48 6b c0 01	 imul	 rax, rax, 1
  004c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  004ca	48 03 c8	 add	 rcx, rax
  004cd	48 8b c1	 mov	 rax, rcx
  004d0	b9 01 00 00 00	 mov	 ecx, 1
  004d5	48 6b c9 03	 imul	 rcx, rcx, 3
  004d9	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  004dd	0f ba e8 07	 bts	 eax, 7
  004e1	b9 01 00 00 00	 mov	 ecx, 1
  004e6	48 6b c9 03	 imul	 rcx, rcx, 3
  004ea	ba 04 00 00 00	 mov	 edx, 4
  004ef	48 6b d2 01	 imul	 rdx, rdx, 1
  004f3	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  004f8	48 03 fa	 add	 rdi, rdx
  004fb	48 8b d7	 mov	 rdx, rdi
  004fe	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00501	33 c0		 xor	 eax, eax
  00503	85 c0		 test	 eax, eax
  00505	75 b5		 jne	 SHORT $LN43@s390_chsc_
$LN59@s390_chsc_:

; 331  : #endif /*defined(_FEATURE_QDIO_TDD)*/
; 332  : 
; 333  : #if defined(_FEATURE_QEBSM)
; 334  :     if (FACILITY_ENABLED( HERC_QEBSM, regs ))

  00507	b8 01 00 00 00	 mov	 eax, 1
  0050c	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00510	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00515	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0051d	83 e0 08	 and	 eax, 8
  00520	85 c0		 test	 eax, eax
  00522	0f 84 94 00 00
	00		 je	 $LN60@s390_chsc_
$LN46@s390_chsc_:

; 335  :     {
; 336  :         CHSC_SB(chsc_rsp10->general_char,58); /* SQBS/EQBS Available */

  00528	b8 04 00 00 00	 mov	 eax, 4
  0052d	48 6b c0 01	 imul	 rax, rax, 1
  00531	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00536	48 03 c8	 add	 rcx, rax
  00539	48 8b c1	 mov	 rax, rcx
  0053c	b9 01 00 00 00	 mov	 ecx, 1
  00541	48 6b c9 03	 imul	 rcx, rcx, 3
  00545	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00549	83 c8 20	 or	 eax, 32			; 00000020H
  0054c	b9 01 00 00 00	 mov	 ecx, 1
  00551	48 6b c9 03	 imul	 rcx, rcx, 3
  00555	ba 04 00 00 00	 mov	 edx, 4
  0055a	48 6b d2 01	 imul	 rdx, rdx, 1
  0055e	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00563	48 03 fa	 add	 rdi, rdx
  00566	48 8b d7	 mov	 rdx, rdi
  00569	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0056c	33 c0		 xor	 eax, eax
  0056e	85 c0		 test	 eax, eax
  00570	75 b6		 jne	 SHORT $LN46@s390_chsc_
$LN49@s390_chsc_:

; 337  :         CHSC_SB(chsc_rsp10->general_char,66); /* SQBS/EQBS Interpret */

  00572	b8 04 00 00 00	 mov	 eax, 4
  00577	48 6b c0 02	 imul	 rax, rax, 2
  0057b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00580	48 03 c8	 add	 rcx, rax
  00583	48 8b c1	 mov	 rax, rcx
  00586	b9 01 00 00 00	 mov	 ecx, 1
  0058b	48 6b c9 00	 imul	 rcx, rcx, 0
  0058f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00593	83 c8 20	 or	 eax, 32			; 00000020H
  00596	b9 01 00 00 00	 mov	 ecx, 1
  0059b	48 6b c9 00	 imul	 rcx, rcx, 0
  0059f	ba 04 00 00 00	 mov	 edx, 4
  005a4	48 6b d2 02	 imul	 rdx, rdx, 2
  005a8	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  005ad	48 03 fa	 add	 rdi, rdx
  005b0	48 8b d7	 mov	 rdx, rdi
  005b3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005b6	33 c0		 xor	 eax, eax
  005b8	85 c0		 test	 eax, eax
  005ba	75 b6		 jne	 SHORT $LN49@s390_chsc_
$LN60@s390_chsc_:

; 338  :     }
; 339  : #endif /*defined(_FEATURE_QEBSM)*/
; 340  : 
; 341  : #if defined(_FEATURE_QDIO_THININT)
; 342  :     if (FACILITY_ENABLED( HERC_QDIO_THININT, regs ))

  005bc	b8 01 00 00 00	 mov	 eax, 1
  005c1	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  005c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  005ca	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  005d2	83 e0 10	 and	 eax, 16
  005d5	85 c0		 test	 eax, eax
  005d7	0f 84 98 00 00
	00		 je	 $LN61@s390_chsc_
$LN52@s390_chsc_:

; 343  :     {
; 344  :         CHSC_SB(chsc_rsp10->general_char,67);   /* OSA/FCP Thin Ints */

  005dd	b8 04 00 00 00	 mov	 eax, 4
  005e2	48 6b c0 02	 imul	 rax, rax, 2
  005e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  005eb	48 03 c8	 add	 rcx, rax
  005ee	48 8b c1	 mov	 rax, rcx
  005f1	b9 01 00 00 00	 mov	 ecx, 1
  005f6	48 6b c9 00	 imul	 rcx, rcx, 0
  005fa	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  005fe	83 c8 10	 or	 eax, 16
  00601	b9 01 00 00 00	 mov	 ecx, 1
  00606	48 6b c9 00	 imul	 rcx, rcx, 0
  0060a	ba 04 00 00 00	 mov	 edx, 4
  0060f	48 6b d2 02	 imul	 rdx, rdx, 2
  00613	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00618	48 03 fa	 add	 rdi, rdx
  0061b	48 8b d7	 mov	 rdx, rdi
  0061e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00621	33 c0		 xor	 eax, eax
  00623	85 c0		 test	 eax, eax
  00625	75 b6		 jne	 SHORT $LN52@s390_chsc_
$LN55@s390_chsc_:

; 345  :         CHSC_SB(chsc_rsp10->chsc_char,107);      /* 0x0021 Supported */

  00627	b8 04 00 00 00	 mov	 eax, 4
  0062c	48 6b c0 03	 imul	 rax, rax, 3
  00630	48 8b 4c 24 28	 mov	 rcx, QWORD PTR chsc_rsp10$[rsp]
  00635	48 8d 84 01 f8
	07 00 00	 lea	 rax, QWORD PTR [rcx+rax+2040]
  0063d	b9 01 00 00 00	 mov	 ecx, 1
  00642	48 6b c9 01	 imul	 rcx, rcx, 1
  00646	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0064a	83 c8 10	 or	 eax, 16
  0064d	b9 01 00 00 00	 mov	 ecx, 1
  00652	48 6b c9 01	 imul	 rcx, rcx, 1
  00656	ba 04 00 00 00	 mov	 edx, 4
  0065b	48 6b d2 03	 imul	 rdx, rdx, 3
  0065f	48 8b 7c 24 28	 mov	 rdi, QWORD PTR chsc_rsp10$[rsp]
  00664	48 8d 94 17 f8
	07 00 00	 lea	 rdx, QWORD PTR [rdi+rdx+2040]
  0066c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0066f	33 c0		 xor	 eax, eax
  00671	85 c0		 test	 eax, eax
  00673	75 b2		 jne	 SHORT $LN55@s390_chsc_
$LN61@s390_chsc_:

; 346  :     }
; 347  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 348  : 
; 349  : //  CHSC_SB(chsc_rsp10->general_char,45);            /* Multiple CSS */
; 350  : //  CHSC_SB(chsc_rsp10->general_char,64);        /* QDIO Multiple CU */
; 351  : //  CHSC_SB(chsc_rsp10->general_char,65);      /* OSA System Console */
; 352  : //  CHSC_SB(chsc_rsp10->general_char,82);                     /* CIB */
; 353  : //  CHSC_SB(chsc_rsp10->general_char,88);                     /* FCX */
; 354  : 
; 355  : //  CHSC_SB(chsc_rsp10->chsc_char,84);                       /* SECM */
; 356  : //  CHSC_SB(chsc_rsp10->chsc_char,86);                       /* SCMC */
; 357  : //  CHSC_SB(chsc_rsp10->chsc_char,107);   /* Set Channel Subsys Char */
; 358  : //  CHSC_SB(chsc_rsp10->chsc_char,108);                /* Fast CHSCs */
; 359  : 
; 360  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  00675	45 33 c0	 xor	 r8d, r8d
  00678	0f b7 54 24 24	 movzx	 edx, WORD PTR rsp_len$[rsp]
  0067d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00682	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@s390_chsc_:

; 361  : }

  00687	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0068b	5f		 pop	 rdi
  0068c	c3		 ret	 0
s390_chsc_get_css_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
max_rsp$ = 32
sch$ = 36
lcss$ = 40
chsc_rsp6$ = 48
work$ = 56
n$1 = 60
f_sch$ = 64
l_sch$ = 68
dev$2 = 72
req_len$ = 80
cun$ = 84
rsp_len$ = 88
num_sch$ = 92
tv141 = 96
max_sch$ = 100
chsc_req6$ = 104
chsc_req$ = 128
chsc_rsp$ = 136
s390_chsc_get_cu_desc PROC

; 214  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 215  : U16 req_len, rsp_len, lcss, cun, max_rsp, work;
; 216  : int sch, f_sch, l_sch, num_sch, max_sch;
; 217  : 
; 218  : CHSC_REQ6 *chsc_req6 = (CHSC_REQ6 *)(chsc_req);

  0000f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00017	48 89 44 24 68	 mov	 QWORD PTR chsc_req6$[rsp], rax

; 219  : CHSC_RSP6 *chsc_rsp6 = (CHSC_RSP6 *)(chsc_rsp+1);

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp6$[rsp], rax

; 220  : 
; 221  :     FETCH_HW(work,chsc_req6->f_sch); f_sch = work;

  0002d	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req6$[rsp]
  00032	48 83 c0 06	 add	 rax, 6
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_hw_noswap
  0003e	0f b7 c8	 movzx	 ecx, ax
  00041	e8 00 00 00 00	 call	 _byteswap_ushort
  00046	66 89 44 24 38	 mov	 WORD PTR work$[rsp], ax
  0004b	0f b7 44 24 38	 movzx	 eax, WORD PTR work$[rsp]
  00050	89 44 24 40	 mov	 DWORD PTR f_sch$[rsp], eax

; 222  :     FETCH_HW(work,chsc_req6->l_sch); l_sch = work;

  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req6$[rsp]
  00059	48 83 c0 0a	 add	 rax, 10
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 fetch_hw_noswap
  00065	0f b7 c8	 movzx	 ecx, ax
  00068	e8 00 00 00 00	 call	 _byteswap_ushort
  0006d	66 89 44 24 38	 mov	 WORD PTR work$[rsp], ax
  00072	0f b7 44 24 38	 movzx	 eax, WORD PTR work$[rsp]
  00077	89 44 24 44	 mov	 DWORD PTR l_sch$[rsp], eax

; 223  :     FETCH_HW(lcss,chsc_req6->ssidfmt);

  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req6$[rsp]
  00080	48 83 c0 04	 add	 rax, 4
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 fetch_hw_noswap
  0008c	0f b7 c8	 movzx	 ecx, ax
  0008f	e8 00 00 00 00	 call	 _byteswap_ushort
  00094	66 89 44 24 28	 mov	 WORD PTR lcss$[rsp], ax

; 224  :     lcss &= CHSC_REQ6_SSID;

  00099	0f b7 44 24 28	 movzx	 eax, WORD PTR lcss$[rsp]
  0009e	83 e0 03	 and	 eax, 3
  000a1	66 89 44 24 28	 mov	 WORD PTR lcss$[rsp], ax

; 225  : //  lcss >>= 0;
; 226  : 
; 227  :     FETCH_HW(req_len, chsc_req6->length);

  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req6$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	e8 00 00 00 00	 call	 fetch_hw_noswap
  000b3	0f b7 c8	 movzx	 ecx, ax
  000b6	e8 00 00 00 00	 call	 _byteswap_ushort
  000bb	66 89 44 24 50	 mov	 WORD PTR req_len$[rsp], ax

; 228  : 
; 229  :     if (!(max_rsp = chsc_max_rsp(req_len, sizeof(CHSC_RSP6))) || l_sch < f_sch)

  000c0	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000c5	0f b7 4c 24 50	 movzx	 ecx, WORD PTR req_len$[rsp]
  000ca	e8 00 00 00 00	 call	 chsc_max_rsp
  000cf	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  000d4	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  000d9	85 c0		 test	 eax, eax
  000db	74 0a		 je	 SHORT $LN12@s390_chsc_
  000dd	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  000e1	39 44 24 44	 cmp	 DWORD PTR l_sch$[rsp], eax
  000e5	7d 14		 jge	 SHORT $LN11@s390_chsc_
$LN12@s390_chsc_:

; 230  :         return chsc_req_errreq(chsc_rsp, 0);

  000e7	33 d2		 xor	 edx, edx
  000e9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000f1	e8 00 00 00 00	 call	 chsc_req_errreq
  000f6	e9 b9 02 00 00	 jmp	 $LN1@s390_chsc_
$LN11@s390_chsc_:

; 231  : 
; 232  :     num_sch = (l_sch - f_sch) + 1;

  000fb	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  000ff	8b 4c 24 44	 mov	 ecx, DWORD PTR l_sch$[rsp]
  00103	2b c8		 sub	 ecx, eax
  00105	8b c1		 mov	 eax, ecx
  00107	ff c0		 inc	 eax
  00109	89 44 24 5c	 mov	 DWORD PTR num_sch$[rsp], eax

; 233  :     max_sch = sysblk.highsubchan[lcss]-1;

  0010d	0f b7 44 24 28	 movzx	 eax, WORD PTR lcss$[rsp]
  00112	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00119	8b 84 81 e0 11
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4576]
  00120	ff c8		 dec	 eax
  00122	89 44 24 64	 mov	 DWORD PTR max_sch$[rsp], eax

; 234  :     max_rsp = (U16) min((int)max_rsp, num_sch);

  00126	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0012b	3b 44 24 5c	 cmp	 eax, DWORD PTR num_sch$[rsp]
  0012f	7d 0b		 jge	 SHORT $LN20@s390_chsc_
  00131	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00136	89 44 24 60	 mov	 DWORD PTR tv141[rsp], eax
  0013a	eb 08		 jmp	 SHORT $LN21@s390_chsc_
$LN20@s390_chsc_:
  0013c	8b 44 24 5c	 mov	 eax, DWORD PTR num_sch$[rsp]
  00140	89 44 24 60	 mov	 DWORD PTR tv141[rsp], eax
$LN21@s390_chsc_:
  00144	0f b7 44 24 60	 movzx	 eax, WORD PTR tv141[rsp]
  00149	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax

; 235  :     rsp_len = sizeof(CHSC_RSP) + (max_rsp * sizeof(CHSC_RSP6));

  0014e	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00153	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00157	48 83 c0 08	 add	 rax, 8
  0015b	66 89 44 24 58	 mov	 WORD PTR rsp_len$[rsp], ax

; 236  : 
; 237  :     if (f_sch <= max_sch)

  00160	8b 44 24 64	 mov	 eax, DWORD PTR max_sch$[rsp]
  00164	39 44 24 40	 cmp	 DWORD PTR f_sch$[rsp], eax
  00168	0f 8f df 01 00
	00		 jg	 $LN13@s390_chsc_

; 238  :     {
; 239  :     DEVBLK *dev;
; 240  : 
; 241  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp6++)

  0016e	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  00172	89 44 24 24	 mov	 DWORD PTR sch$[rsp], eax
  00176	eb 25		 jmp	 SHORT $LN4@s390_chsc_
$LN2@s390_chsc_:
  00178	8b 44 24 24	 mov	 eax, DWORD PTR sch$[rsp]
  0017c	ff c0		 inc	 eax
  0017e	89 44 24 24	 mov	 DWORD PTR sch$[rsp], eax
  00182	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00187	66 ff c8	 dec	 ax
  0018a	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0018f	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00194	48 83 c0 20	 add	 rax, 32			; 00000020H
  00198	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp6$[rsp], rax
$LN4@s390_chsc_:
  0019d	8b 44 24 44	 mov	 eax, DWORD PTR l_sch$[rsp]
  001a1	39 44 24 24	 cmp	 DWORD PTR sch$[rsp], eax
  001a5	0f 8f a0 01 00
	00		 jg	 $LN3@s390_chsc_
  001ab	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  001b0	85 c0		 test	 eax, eax
  001b2	0f 84 93 01 00
	00		 je	 $LN3@s390_chsc_

; 242  :         {
; 243  :             memset(chsc_rsp6, 0, sizeof(CHSC_RSP6) );

  001b8	48 8b 7c 24 30	 mov	 rdi, QWORD PTR chsc_rsp6$[rsp]
  001bd	33 c0		 xor	 eax, eax
  001bf	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001c4	f3 aa		 rep stosb

; 244  :             if (sch <= max_sch)

  001c6	8b 44 24 64	 mov	 eax, DWORD PTR max_sch$[rsp]
  001ca	39 44 24 24	 cmp	 DWORD PTR sch$[rsp], eax
  001ce	0f 8f 72 01 00
	00		 jg	 $LN15@s390_chsc_

; 245  :             {
; 246  :                 if((dev = find_device_by_subchan((LCSS_TO_SSID(lcss) << 16)|sch)))

  001d4	0f b7 44 24 28	 movzx	 eax, WORD PTR lcss$[rsp]
  001d9	d1 e0		 shl	 eax, 1
  001db	83 c8 01	 or	 eax, 1
  001de	c1 e0 10	 shl	 eax, 16
  001e1	0b 44 24 24	 or	 eax, DWORD PTR sch$[rsp]
  001e5	8b c8		 mov	 ecx, eax
  001e7	e8 00 00 00 00	 call	 find_device_by_subchan
  001ec	48 89 44 24 48	 mov	 QWORD PTR dev$2[rsp], rax
  001f1	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$2[rsp], 0
  001f7	0f 84 49 01 00
	00		 je	 $LN16@s390_chsc_

; 247  :                 {
; 248  :                     int n;
; 249  :                     chsc_rsp6->flags1 |= CHSC_RSP6_F1_SCH_VALID;

  001fd	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00202	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00205	0f ba e8 07	 bts	 eax, 7
  00209	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  0020e	88 01		 mov	 BYTE PTR [rcx], al

; 250  :                     if(dev->pmcw.flag5 & PMCW5_V)

  00210	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00215	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0021c	83 e0 01	 and	 eax, 1
  0021f	85 c0		 test	 eax, eax
  00221	74 12		 je	 SHORT $LN17@s390_chsc_

; 251  :                         chsc_rsp6->flags1 |= CHSC_RSP6_F1_DEV_VALID;

  00223	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00228	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0022b	83 c8 40	 or	 eax, 64			; 00000040H
  0022e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  00233	88 01		 mov	 BYTE PTR [rcx], al
$LN17@s390_chsc_:

; 252  :                     chsc_rsp6->flags1 |= ((dev->pmcw.flag25 & PMCW25_TYPE) >> 2);

  00235	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  0023a	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  00241	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  00246	c1 f8 02	 sar	 eax, 2
  00249	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  0024e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00251	0b c8		 or	 ecx, eax
  00253	8b c1		 mov	 eax, ecx
  00255	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  0025a	88 01		 mov	 BYTE PTR [rcx], al

; 253  :                     chsc_rsp6->path_mask = dev->pmcw.pim;

  0025c	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00261	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  00266	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  0026d	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 254  :                     STORE_HW(chsc_rsp6->devnum,dev->devnum);

  00270	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00275	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  00279	e8 00 00 00 00	 call	 _byteswap_ushort
  0027e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  00283	48 83 c1 02	 add	 rcx, 2
  00287	0f b7 d0	 movzx	 edx, ax
  0028a	e8 00 00 00 00	 call	 store_hw_noswap

; 255  :                     STORE_HW(chsc_rsp6->sch, sch);

  0028f	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sch$[rsp]
  00294	e8 00 00 00 00	 call	 _byteswap_ushort
  00299	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp6$[rsp]
  0029e	48 83 c1 06	 add	 rcx, 6
  002a2	0f b7 d0	 movzx	 edx, ax
  002a5	e8 00 00 00 00	 call	 store_hw_noswap

; 256  :                     memcpy(chsc_rsp6->chpid, dev->pmcw.chpid, 8);

  002aa	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  002af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  002b4	48 8b 89 fc 02
	00 00		 mov	 rcx, QWORD PTR [rcx+764]
  002bb	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 257  :                     for(n = 0; n < 8; n++)

  002bf	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  002c7	eb 0a		 jmp	 SHORT $LN7@s390_chsc_
$LN5@s390_chsc_:
  002c9	8b 44 24 3c	 mov	 eax, DWORD PTR n$1[rsp]
  002cd	ff c0		 inc	 eax
  002cf	89 44 24 3c	 mov	 DWORD PTR n$1[rsp], eax
$LN7@s390_chsc_:
  002d3	83 7c 24 3c 08	 cmp	 DWORD PTR n$1[rsp], 8
  002d8	7d 6c		 jge	 SHORT $LN6@s390_chsc_

; 258  :                     {
; 259  :                         if(dev->pmcw.pim & (0x80 >> n))

  002da	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  002df	0f b6 80 f7 02
	00 00		 movzx	 eax, BYTE PTR [rax+759]
  002e6	8b 4c 24 3c	 mov	 ecx, DWORD PTR n$1[rsp]
  002ea	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  002ef	d3 fa		 sar	 edx, cl
  002f1	8b ca		 mov	 ecx, edx
  002f3	23 c1		 and	 eax, ecx
  002f5	85 c0		 test	 eax, eax
  002f7	74 4b		 je	 SHORT $LN18@s390_chsc_

; 260  :                         {
; 261  :                             cun = ((dev->devnum & 0x00F0) << 4) | dev->pmcw.chpid[n];

  002f9	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  002fe	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00302	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00307	c1 e0 04	 shl	 eax, 4
  0030a	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR n$1[rsp]
  0030f	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$2[rsp]
  00314	0f b6 8c 0a fc
	02 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+764]
  0031c	0b c1		 or	 eax, ecx
  0031e	66 89 44 24 54	 mov	 WORD PTR cun$[rsp], ax

; 262  :                             STORE_HW(chsc_rsp6->cun[n], cun);

  00323	0f b7 4c 24 54	 movzx	 ecx, WORD PTR cun$[rsp]
  00328	e8 00 00 00 00	 call	 _byteswap_ushort
  0032d	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR n$1[rsp]
  00332	48 8b 54 24 30	 mov	 rdx, QWORD PTR chsc_rsp6$[rsp]
  00337	48 8d 4c 4a 10	 lea	 rcx, QWORD PTR [rdx+rcx*2+16]
  0033c	0f b7 d0	 movzx	 edx, ax
  0033f	e8 00 00 00 00	 call	 store_hw_noswap
$LN18@s390_chsc_:

; 263  :                         }
; 264  :                     }

  00344	eb 83		 jmp	 SHORT $LN5@s390_chsc_
$LN6@s390_chsc_:
$LN16@s390_chsc_:
$LN15@s390_chsc_:

; 265  :                 }
; 266  :             }
; 267  :         }

  00346	e9 2d fe ff ff	 jmp	 $LN2@s390_chsc_
$LN3@s390_chsc_:

; 268  :     }

  0034b	eb 52		 jmp	 SHORT $LN14@s390_chsc_
$LN13@s390_chsc_:

; 269  :     else /* f_sch > max_sch */
; 270  :     {
; 271  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp6++)

  0034d	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  00351	89 44 24 24	 mov	 DWORD PTR sch$[rsp], eax
  00355	eb 25		 jmp	 SHORT $LN10@s390_chsc_
$LN8@s390_chsc_:
  00357	8b 44 24 24	 mov	 eax, DWORD PTR sch$[rsp]
  0035b	ff c0		 inc	 eax
  0035d	89 44 24 24	 mov	 DWORD PTR sch$[rsp], eax
  00361	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00366	66 ff c8	 dec	 ax
  00369	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0036e	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp6$[rsp]
  00373	48 83 c0 20	 add	 rax, 32			; 00000020H
  00377	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp6$[rsp], rax
$LN10@s390_chsc_:
  0037c	8b 44 24 44	 mov	 eax, DWORD PTR l_sch$[rsp]
  00380	39 44 24 24	 cmp	 DWORD PTR sch$[rsp], eax
  00384	7f 19		 jg	 SHORT $LN9@s390_chsc_
  00386	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0038b	85 c0		 test	 eax, eax
  0038d	74 10		 je	 SHORT $LN9@s390_chsc_

; 272  :             memset(chsc_rsp6, 0, sizeof(CHSC_RSP6) );

  0038f	48 8b 7c 24 30	 mov	 rdi, QWORD PTR chsc_rsp6$[rsp]
  00394	33 c0		 xor	 eax, eax
  00396	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0039b	f3 aa		 rep stosb
  0039d	eb b8		 jmp	 SHORT $LN8@s390_chsc_
$LN9@s390_chsc_:
$LN14@s390_chsc_:

; 273  :     }
; 274  : 
; 275  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  0039f	45 33 c0	 xor	 r8d, r8d
  003a2	0f b7 54 24 58	 movzx	 edx, WORD PTR rsp_len$[rsp]
  003a7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  003af	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@s390_chsc_:

; 276  : }

  003b4	48 83 c4 70	 add	 rsp, 112		; 00000070H
  003b8	5f		 pop	 rdi
  003b9	c3		 ret	 0
s390_chsc_get_cu_desc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
max_rsp$ = 32
lcss$ = 36
sch$ = 40
chsc_rsp4$ = 48
work$ = 56
n$1 = 60
f_sch$ = 64
dev$2 = 72
l_sch$ = 80
req_len$ = 84
rsp_len$ = 88
num_sch$ = 92
tv142 = 96
max_sch$ = 100
chsc_req4$ = 104
chsc_req$ = 128
chsc_rsp$ = 136
s390_chsc_get_sch_desc PROC

; 145  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 146  : U16 req_len, rsp_len, lcss, max_rsp, work;
; 147  : int sch, f_sch, l_sch, num_sch, max_sch;
; 148  : 
; 149  : CHSC_REQ4 *chsc_req4 = (CHSC_REQ4 *)(chsc_req);

  0000f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00017	48 89 44 24 68	 mov	 QWORD PTR chsc_req4$[rsp], rax

; 150  : CHSC_RSP4 *chsc_rsp4 = (CHSC_RSP4 *)(chsc_rsp+1);

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp4$[rsp], rax

; 151  : 
; 152  :     FETCH_HW(work,chsc_req4->f_sch); f_sch = work;

  0002d	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req4$[rsp]
  00032	48 83 c0 06	 add	 rax, 6
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_hw_noswap
  0003e	0f b7 c8	 movzx	 ecx, ax
  00041	e8 00 00 00 00	 call	 _byteswap_ushort
  00046	66 89 44 24 38	 mov	 WORD PTR work$[rsp], ax
  0004b	0f b7 44 24 38	 movzx	 eax, WORD PTR work$[rsp]
  00050	89 44 24 40	 mov	 DWORD PTR f_sch$[rsp], eax

; 153  :     FETCH_HW(work,chsc_req4->l_sch); l_sch = work;

  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req4$[rsp]
  00059	48 83 c0 0a	 add	 rax, 10
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 fetch_hw_noswap
  00065	0f b7 c8	 movzx	 ecx, ax
  00068	e8 00 00 00 00	 call	 _byteswap_ushort
  0006d	66 89 44 24 38	 mov	 WORD PTR work$[rsp], ax
  00072	0f b7 44 24 38	 movzx	 eax, WORD PTR work$[rsp]
  00077	89 44 24 50	 mov	 DWORD PTR l_sch$[rsp], eax

; 154  :     FETCH_HW(lcss,chsc_req4->ssidfmt);

  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req4$[rsp]
  00080	48 83 c0 04	 add	 rax, 4
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 fetch_hw_noswap
  0008c	0f b7 c8	 movzx	 ecx, ax
  0008f	e8 00 00 00 00	 call	 _byteswap_ushort
  00094	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 155  :     lcss &= CHSC_REQ4_SSID;

  00099	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  0009e	83 e0 30	 and	 eax, 48			; 00000030H
  000a1	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 156  :     lcss >>= 4;

  000a6	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  000ab	66 c1 e8 04	 shr	 ax, 4
  000af	66 89 44 24 24	 mov	 WORD PTR lcss$[rsp], ax

; 157  : 
; 158  :     FETCH_HW(req_len, chsc_req4->length);

  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR chsc_req4$[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 fetch_hw_noswap
  000c1	0f b7 c8	 movzx	 ecx, ax
  000c4	e8 00 00 00 00	 call	 _byteswap_ushort
  000c9	66 89 44 24 54	 mov	 WORD PTR req_len$[rsp], ax

; 159  : 
; 160  :     if (!(max_rsp = chsc_max_rsp(req_len, sizeof(CHSC_RSP4))) || l_sch < f_sch)

  000ce	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d3	0f b7 4c 24 54	 movzx	 ecx, WORD PTR req_len$[rsp]
  000d8	e8 00 00 00 00	 call	 chsc_max_rsp
  000dd	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  000e2	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  000e7	85 c0		 test	 eax, eax
  000e9	74 0a		 je	 SHORT $LN12@s390_chsc_
  000eb	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  000ef	39 44 24 50	 cmp	 DWORD PTR l_sch$[rsp], eax
  000f3	7d 14		 jge	 SHORT $LN11@s390_chsc_
$LN12@s390_chsc_:

; 161  :         return chsc_req_errreq(chsc_rsp, 0);

  000f5	33 d2		 xor	 edx, edx
  000f7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  000ff	e8 00 00 00 00	 call	 chsc_req_errreq
  00104	e9 e0 02 00 00	 jmp	 $LN1@s390_chsc_
$LN11@s390_chsc_:

; 162  : 
; 163  :     num_sch = (l_sch - f_sch) + 1;

  00109	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  0010d	8b 4c 24 50	 mov	 ecx, DWORD PTR l_sch$[rsp]
  00111	2b c8		 sub	 ecx, eax
  00113	8b c1		 mov	 eax, ecx
  00115	ff c0		 inc	 eax
  00117	89 44 24 5c	 mov	 DWORD PTR num_sch$[rsp], eax

; 164  :     max_sch = sysblk.highsubchan[lcss]-1;

  0011b	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  00120	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00127	8b 84 81 e0 11
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4576]
  0012e	ff c8		 dec	 eax
  00130	89 44 24 64	 mov	 DWORD PTR max_sch$[rsp], eax

; 165  :     max_rsp = (U16) min((int)max_rsp, num_sch);

  00134	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00139	3b 44 24 5c	 cmp	 eax, DWORD PTR num_sch$[rsp]
  0013d	7d 0b		 jge	 SHORT $LN21@s390_chsc_
  0013f	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00144	89 44 24 60	 mov	 DWORD PTR tv142[rsp], eax
  00148	eb 08		 jmp	 SHORT $LN22@s390_chsc_
$LN21@s390_chsc_:
  0014a	8b 44 24 5c	 mov	 eax, DWORD PTR num_sch$[rsp]
  0014e	89 44 24 60	 mov	 DWORD PTR tv142[rsp], eax
$LN22@s390_chsc_:
  00152	0f b7 44 24 60	 movzx	 eax, WORD PTR tv142[rsp]
  00157	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax

; 166  :     rsp_len = sizeof(CHSC_RSP) + (max_rsp * sizeof(CHSC_RSP4));

  0015c	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00161	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00165	48 83 c0 08	 add	 rax, 8
  00169	66 89 44 24 58	 mov	 WORD PTR rsp_len$[rsp], ax

; 167  : 
; 168  :     if (f_sch <= max_sch)

  0016e	8b 44 24 64	 mov	 eax, DWORD PTR max_sch$[rsp]
  00172	39 44 24 40	 cmp	 DWORD PTR f_sch$[rsp], eax
  00176	0f 8f 06 02 00
	00		 jg	 $LN13@s390_chsc_

; 169  :     {
; 170  :     DEVBLK *dev;
; 171  : 
; 172  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp4++)

  0017c	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  00180	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00184	eb 25		 jmp	 SHORT $LN4@s390_chsc_
$LN2@s390_chsc_:
  00186	8b 44 24 28	 mov	 eax, DWORD PTR sch$[rsp]
  0018a	ff c0		 inc	 eax
  0018c	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00190	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  00195	66 ff c8	 dec	 ax
  00198	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  0019d	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  001a2	48 83 c0 20	 add	 rax, 32			; 00000020H
  001a6	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp4$[rsp], rax
$LN4@s390_chsc_:
  001ab	8b 44 24 50	 mov	 eax, DWORD PTR l_sch$[rsp]
  001af	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  001b3	0f 8f c7 01 00
	00		 jg	 $LN3@s390_chsc_
  001b9	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  001be	85 c0		 test	 eax, eax
  001c0	0f 84 ba 01 00
	00		 je	 $LN3@s390_chsc_

; 173  :         {
; 174  :             memset(chsc_rsp4, 0, sizeof(CHSC_RSP4) );

  001c6	48 8b 7c 24 30	 mov	 rdi, QWORD PTR chsc_rsp4$[rsp]
  001cb	33 c0		 xor	 eax, eax
  001cd	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001d2	f3 aa		 rep stosb

; 175  :             if (sch <= max_sch)

  001d4	8b 44 24 64	 mov	 eax, DWORD PTR max_sch$[rsp]
  001d8	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  001dc	0f 8f 99 01 00
	00		 jg	 $LN15@s390_chsc_

; 176  :             {
; 177  :                 if((dev = find_device_by_subchan((LCSS_TO_SSID(lcss) << 16)|sch)))

  001e2	0f b7 44 24 24	 movzx	 eax, WORD PTR lcss$[rsp]
  001e7	d1 e0		 shl	 eax, 1
  001e9	83 c8 01	 or	 eax, 1
  001ec	c1 e0 10	 shl	 eax, 16
  001ef	0b 44 24 28	 or	 eax, DWORD PTR sch$[rsp]
  001f3	8b c8		 mov	 ecx, eax
  001f5	e8 00 00 00 00	 call	 find_device_by_subchan
  001fa	48 89 44 24 48	 mov	 QWORD PTR dev$2[rsp], rax
  001ff	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$2[rsp], 0
  00205	0f 84 70 01 00
	00		 je	 $LN16@s390_chsc_

; 178  :                 {
; 179  :                     int n;
; 180  :                     chsc_rsp4->flags1 |= CHSC_RSP4_F1_SCH_VALID;

  0020b	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  00210	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00213	0f ba e8 07	 bts	 eax, 7
  00217	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  0021c	88 01		 mov	 BYTE PTR [rcx], al

; 181  :                     if(dev->pmcw.flag5 & PMCW5_V)

  0021e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00223	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0022a	83 e0 01	 and	 eax, 1
  0022d	85 c0		 test	 eax, eax
  0022f	74 12		 je	 SHORT $LN17@s390_chsc_

; 182  :                         chsc_rsp4->flags1 |= CHSC_RSP4_F1_DEV_VALID;

  00231	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  00236	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00239	83 c8 40	 or	 eax, 64			; 00000040H
  0023c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  00241	88 01		 mov	 BYTE PTR [rcx], al
$LN17@s390_chsc_:

; 183  :                     chsc_rsp4->flags1 |= ((dev->pmcw.flag25 & PMCW25_TYPE) >> 2);

  00243	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00248	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  0024f	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  00254	c1 f8 02	 sar	 eax, 2
  00257	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  0025c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0025f	0b c8		 or	 ecx, eax
  00261	8b c1		 mov	 eax, ecx
  00263	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  00268	88 01		 mov	 BYTE PTR [rcx], al

; 184  :                     chsc_rsp4->path_mask = dev->pmcw.pim;

  0026a	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  0026f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  00274	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  0027b	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 185  :                     chsc_rsp4->unit_addr = dev->devnum & 0xff;

  0027e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00283	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00287	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0028c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  00291	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 186  :                     STORE_HW(chsc_rsp4->devno,dev->devnum);

  00294	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00299	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  0029d	e8 00 00 00 00	 call	 _byteswap_ushort
  002a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  002a7	48 83 c1 02	 add	 rcx, 2
  002ab	0f b7 d0	 movzx	 edx, ax
  002ae	e8 00 00 00 00	 call	 store_hw_noswap

; 187  :                     STORE_HW(chsc_rsp4->sch, sch);

  002b3	0f b7 4c 24 28	 movzx	 ecx, WORD PTR sch$[rsp]
  002b8	e8 00 00 00 00	 call	 _byteswap_ushort
  002bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp4$[rsp]
  002c2	48 83 c1 06	 add	 rcx, 6
  002c6	0f b7 d0	 movzx	 edx, ax
  002c9	e8 00 00 00 00	 call	 store_hw_noswap

; 188  :                     memcpy(chsc_rsp4->chpid, dev->pmcw.chpid, 8);

  002ce	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  002d3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  002d8	48 8b 89 fc 02
	00 00		 mov	 rcx, QWORD PTR [rcx+764]
  002df	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 189  :                     if(dev->fla[0])

  002e3	b8 02 00 00 00	 mov	 eax, 2
  002e8	48 6b c0 00	 imul	 rax, rax, 0
  002ec	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  002f1	0f b7 84 01 bc
	05 00 00	 movzx	 eax, WORD PTR [rcx+rax+1468]
  002f9	85 c0		 test	 eax, eax
  002fb	74 14		 je	 SHORT $LN18@s390_chsc_

; 190  :                         chsc_rsp4->fla_valid_mask = dev->pmcw.pim;

  002fd	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  00302	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  00307	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  0030e	88 48 05	 mov	 BYTE PTR [rax+5], cl
$LN18@s390_chsc_:

; 191  :                     for(n = 0; n < 8; n++)

  00311	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  00319	eb 0a		 jmp	 SHORT $LN7@s390_chsc_
$LN5@s390_chsc_:
  0031b	8b 44 24 3c	 mov	 eax, DWORD PTR n$1[rsp]
  0031f	ff c0		 inc	 eax
  00321	89 44 24 3c	 mov	 DWORD PTR n$1[rsp], eax
$LN7@s390_chsc_:
  00325	83 7c 24 3c 08	 cmp	 DWORD PTR n$1[rsp], 8
  0032a	7d 4f		 jge	 SHORT $LN6@s390_chsc_

; 192  :                         if(dev->pmcw.pim & (0x80 >> n))

  0032c	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$2[rsp]
  00331	0f b6 80 f7 02
	00 00		 movzx	 eax, BYTE PTR [rax+759]
  00338	8b 4c 24 3c	 mov	 ecx, DWORD PTR n$1[rsp]
  0033c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00341	d3 fa		 sar	 edx, cl
  00343	8b ca		 mov	 ecx, edx
  00345	23 c1		 and	 eax, ecx
  00347	85 c0		 test	 eax, eax
  00349	74 2e		 je	 SHORT $LN19@s390_chsc_

; 193  :                         {
; 194  :                             STORE_HW(chsc_rsp4->fla[n], dev->fla[n]);

  0034b	48 63 44 24 3c	 movsxd	 rax, DWORD PTR n$1[rsp]
  00350	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$2[rsp]
  00355	0f b7 8c 41 bc
	05 00 00	 movzx	 ecx, WORD PTR [rcx+rax*2+1468]
  0035d	e8 00 00 00 00	 call	 _byteswap_ushort
  00362	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR n$1[rsp]
  00367	48 8b 54 24 30	 mov	 rdx, QWORD PTR chsc_rsp4$[rsp]
  0036c	48 8d 4c 4a 10	 lea	 rcx, QWORD PTR [rdx+rcx*2+16]
  00371	0f b7 d0	 movzx	 edx, ax
  00374	e8 00 00 00 00	 call	 store_hw_noswap
$LN19@s390_chsc_:

; 195  :                         }

  00379	eb a0		 jmp	 SHORT $LN5@s390_chsc_
$LN6@s390_chsc_:
$LN16@s390_chsc_:
$LN15@s390_chsc_:

; 196  :                 }
; 197  :             }
; 198  :         }

  0037b	e9 06 fe ff ff	 jmp	 $LN2@s390_chsc_
$LN3@s390_chsc_:

; 199  :     }

  00380	eb 52		 jmp	 SHORT $LN14@s390_chsc_
$LN13@s390_chsc_:

; 200  :     else /* f_sch > max_sch */
; 201  :     {
; 202  :         for(sch = f_sch; sch <= l_sch && max_rsp; sch++, max_rsp--, chsc_rsp4++)

  00382	8b 44 24 40	 mov	 eax, DWORD PTR f_sch$[rsp]
  00386	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  0038a	eb 25		 jmp	 SHORT $LN10@s390_chsc_
$LN8@s390_chsc_:
  0038c	8b 44 24 28	 mov	 eax, DWORD PTR sch$[rsp]
  00390	ff c0		 inc	 eax
  00392	89 44 24 28	 mov	 DWORD PTR sch$[rsp], eax
  00396	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  0039b	66 ff c8	 dec	 ax
  0039e	66 89 44 24 20	 mov	 WORD PTR max_rsp$[rsp], ax
  003a3	48 8b 44 24 30	 mov	 rax, QWORD PTR chsc_rsp4$[rsp]
  003a8	48 83 c0 20	 add	 rax, 32			; 00000020H
  003ac	48 89 44 24 30	 mov	 QWORD PTR chsc_rsp4$[rsp], rax
$LN10@s390_chsc_:
  003b1	8b 44 24 50	 mov	 eax, DWORD PTR l_sch$[rsp]
  003b5	39 44 24 28	 cmp	 DWORD PTR sch$[rsp], eax
  003b9	7f 19		 jg	 SHORT $LN9@s390_chsc_
  003bb	0f b7 44 24 20	 movzx	 eax, WORD PTR max_rsp$[rsp]
  003c0	85 c0		 test	 eax, eax
  003c2	74 10		 je	 SHORT $LN9@s390_chsc_

; 203  :             memset(chsc_rsp4, 0, sizeof(CHSC_RSP4) );

  003c4	48 8b 7c 24 30	 mov	 rdi, QWORD PTR chsc_rsp4$[rsp]
  003c9	33 c0		 xor	 eax, eax
  003cb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  003d0	f3 aa		 rep stosb
  003d2	eb b8		 jmp	 SHORT $LN8@s390_chsc_
$LN9@s390_chsc_:
$LN14@s390_chsc_:

; 204  :     }
; 205  : 
; 206  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  003d4	45 33 c0	 xor	 r8d, r8d
  003d7	0f b7 54 24 58	 movzx	 edx, WORD PTR rsp_len$[rsp]
  003dc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  003e4	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@s390_chsc_:

; 207  : }

  003e9	48 83 c4 70	 add	 rsp, 112		; 00000070H
  003ed	5f		 pop	 rdi
  003ee	c3		 ret	 0
s390_chsc_get_sch_desc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
valid_bit_domain$1 = 32
rsp_len$ = 36
req_len$ = 40
z$2 = 48
tv66 = 56
tv92 = 60
valid_bit_offset$3 = 64
chsc_rsp12$ = 72
lparname_offset$4 = 80
chsc_req12$ = 88
tv83 = 96
tv137 = 104
chsc_req$ = 128
chsc_rsp$ = 136
s390_chsc_get_conf_info PROC

; 58   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 59   : U16 req_len, rsp_len;
; 60   : 
; 61   : CHSC_REQ12 *chsc_req12 = (CHSC_REQ12 *)(chsc_req);

  0000f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chsc_req$[rsp]
  00017	48 89 44 24 58	 mov	 QWORD PTR chsc_req12$[rsp], rax

; 62   : CHSC_RSP12 *chsc_rsp12 = (CHSC_RSP12 *)(chsc_rsp+1);

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 89 44 24 48	 mov	 QWORD PTR chsc_rsp12$[rsp], rax

; 63   : 
; 64   :     /* Set response length based on MIF mode */
; 65   :     switch (sysblk.operation_mode)

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  0003a	89 44 24 38	 mov	 DWORD PTR tv66[rsp], eax
  0003e	83 7c 24 38 02	 cmp	 DWORD PTR tv66[rsp], 2
  00043	74 02		 je	 SHORT $LN6@s390_chsc_
  00045	eb 0c		 jmp	 SHORT $LN7@s390_chsc_
$LN6@s390_chsc_:

; 66   :     {
; 67   :         case om_emif:
; 68   :             rsp_len = sizeof(CHSC_RSP) + sizeof(CHSC_RSP12);

  00047	b8 d8 08 00 00	 mov	 eax, 2264		; 000008d8H
  0004c	66 89 44 24 24	 mov	 WORD PTR rsp_len$[rsp], ax

; 69   :             break;

  00051	eb 0a		 jmp	 SHORT $LN2@s390_chsc_
$LN7@s390_chsc_:

; 70   : 
; 71   :         default:
; 72   :             rsp_len = 0x0138;

  00053	b8 38 01 00 00	 mov	 eax, 312		; 00000138H
  00058	66 89 44 24 24	 mov	 WORD PTR rsp_len$[rsp], ax
$LN2@s390_chsc_:

; 73   :             break;
; 74   :     }
; 75   : 
; 76   :     FETCH_HW(req_len, chsc_req12->length);

  0005d	48 8b 44 24 58	 mov	 rax, QWORD PTR chsc_req12$[rsp]
  00062	48 8b c8	 mov	 rcx, rax
  00065	e8 00 00 00 00	 call	 fetch_hw_noswap
  0006a	0f b7 c8	 movzx	 ecx, ax
  0006d	e8 00 00 00 00	 call	 _byteswap_ushort
  00072	66 89 44 24 28	 mov	 WORD PTR req_len$[rsp], ax

; 77   : 
; 78   :     /* If the response won't fit in the requested length, return an
; 79   :      * error back to the caller.
; 80   :      */
; 81   :     if (!chsc_max_rsp(req_len, sizeof(CHSC_RSP12)))

  00077	ba d0 08 00 00	 mov	 edx, 2256		; 000008d0H
  0007c	0f b7 4c 24 28	 movzx	 ecx, WORD PTR req_len$[rsp]
  00081	e8 00 00 00 00	 call	 chsc_max_rsp
  00086	0f b7 c0	 movzx	 eax, ax
  00089	85 c0		 test	 eax, eax
  0008b	75 14		 jne	 SHORT $LN8@s390_chsc_

; 82   :         return chsc_req_errreq(chsc_rsp, 0);

  0008d	33 d2		 xor	 edx, edx
  0008f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00097	e8 00 00 00 00	 call	 chsc_req_errreq
  0009c	e9 4f 01 00 00	 jmp	 $LN1@s390_chsc_
$LN8@s390_chsc_:

; 83   : 
; 84   :     /* Clear the response area */
; 85   :     memset(chsc_rsp12, 0, rsp_len);

  000a1	0f b7 44 24 24	 movzx	 eax, WORD PTR rsp_len$[rsp]
  000a6	48 89 44 24 60	 mov	 QWORD PTR tv83[rsp], rax
  000ab	48 8b 7c 24 48	 mov	 rdi, QWORD PTR chsc_rsp12$[rsp]
  000b0	33 c0		 xor	 eax, eax
  000b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv83[rsp]
  000b7	f3 aa		 rep stosb

; 86   : 
; 87   :     /* Where did this bit come from? Is it a z-machine indicator? */
; 88   :     chsc_rsp12->unknow00A = 0x01;

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_rsp12$[rsp]
  000be	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 89   : 
; 90   :     /* FIXME: BASIC mode operations are not returning the proper
; 91   :      *        information; instead, return of an error may be required.
; 92   :      */
; 93   :     if (sysblk.operation_mode != om_basic)

  000c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c9	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [rax+232], 0
  000d0	0f 84 05 01 00
	00		 je	 $LN9@s390_chsc_

; 94   :     {
; 95   :         BYTE*   z = (BYTE*)chsc_rsp;

  000d6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR chsc_rsp$[rsp]
  000de	48 89 44 24 30	 mov	 QWORD PTR z$2[rsp], rax

; 96   :         BYTE    valid_bit_domain;
; 97   :         size_t  valid_bit_offset;
; 98   :         size_t  lparname_offset;
; 99   : 
; 100  :         /* Save Hercules LPAR number as the partition number */
; 101  :         *(z + 11) = valid_bit_domain = sysblk.lparnum;

  000e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ea	0f b6 80 f0 00
	00 00		 movzx	 eax, BYTE PTR [rax+240]
  000f1	88 44 24 20	 mov	 BYTE PTR valid_bit_domain$1[rsp], al
  000f5	48 8b 44 24 30	 mov	 rax, QWORD PTR z$2[rsp]
  000fa	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR valid_bit_domain$1[rsp]
  000ff	88 48 0b	 mov	 BYTE PTR [rax+11], cl

; 102  : 
; 103  :         /* Set current LPAR name valid bit and LPAR name
; 104  :          *
; 105  :          * Note: The value fields are arrays of *ALL* defined and active
; 106  :          *       LPAR names and validity bits for the host system. It
; 107  :          *       should also be noted that the offsets to the array of
; 108  :          *       LPAR name valid bits and to the array of LPAR names is
; 109  :          *       different between non-EMIF and EMIF modes.
; 110  :          *
; 111  :          * FIXME: Future. Supply and maintain the information from *ALL*
; 112  :          *        active Hercules instances on the host system.
; 113  :          */
; 114  :         switch (sysblk.operation_mode)

  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00109	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  0010f	89 44 24 3c	 mov	 DWORD PTR tv92[rsp], eax
  00113	83 7c 24 3c 01	 cmp	 DWORD PTR tv92[rsp], 1
  00118	74 02		 je	 SHORT $LN10@s390_chsc_
  0011a	eb 1f		 jmp	 SHORT $LN11@s390_chsc_
$LN10@s390_chsc_:

; 115  :         {
; 116  :             case om_mif:
; 117  :                 --valid_bit_domain;

  0011c	0f b6 44 24 20	 movzx	 eax, BYTE PTR valid_bit_domain$1[rsp]
  00121	fe c8		 dec	 al
  00123	88 44 24 20	 mov	 BYTE PTR valid_bit_domain$1[rsp], al

; 118  :                 valid_bit_offset = 180;

  00127	48 c7 44 24 40
	b4 00 00 00	 mov	 QWORD PTR valid_bit_offset$3[rsp], 180 ; 000000b4H

; 119  :                 lparname_offset  = 184;

  00130	48 c7 44 24 50
	b8 00 00 00	 mov	 QWORD PTR lparname_offset$4[rsp], 184 ; 000000b8H

; 120  :                 break;

  00139	eb 12		 jmp	 SHORT $LN4@s390_chsc_
$LN11@s390_chsc_:

; 121  : 
; 122  :          /* case om_emif: */
; 123  :             default:
; 124  :                 valid_bit_offset = 184;

  0013b	48 c7 44 24 40
	b8 00 00 00	 mov	 QWORD PTR valid_bit_offset$3[rsp], 184 ; 000000b8H

; 125  :                 lparname_offset  = 216;

  00144	48 c7 44 24 50
	d8 00 00 00	 mov	 QWORD PTR lparname_offset$4[rsp], 216 ; 000000d8H
$LN4@s390_chsc_:

; 126  :                 break;
; 127  :         }
; 128  : 
; 129  :         /* Set LPAR name */
; 130  :         get_lparname(z + lparname_offset + (sysblk.lparnum << 3));

  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR lparname_offset$4[rsp]
  00152	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$2[rsp]
  00157	48 03 c8	 add	 rcx, rax
  0015a	48 8b c1	 mov	 rax, rcx
  0015d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00164	0f b7 89 f0 00
	00 00		 movzx	 ecx, WORD PTR [rcx+240]
  0016b	c1 e1 03	 shl	 ecx, 3
  0016e	48 63 c9	 movsxd	 rcx, ecx
  00171	48 03 c1	 add	 rax, rcx
  00174	48 8b c8	 mov	 rcx, rax
  00177	e8 00 00 00 00	 call	 get_lparname

; 131  : 
; 132  :         /* Set valid bit */
; 133  :         *(z + valid_bit_offset + (valid_bit_domain >> 3)) |=

  0017c	48 8b 44 24 40	 mov	 rax, QWORD PTR valid_bit_offset$3[rsp]
  00181	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$2[rsp]
  00186	48 03 c8	 add	 rcx, rax
  00189	48 8b c1	 mov	 rax, rcx
  0018c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR valid_bit_domain$1[rsp]
  00191	c1 f9 03	 sar	 ecx, 3
  00194	48 63 c9	 movsxd	 rcx, ecx
  00197	48 89 4c 24 68	 mov	 QWORD PTR tv137[rsp], rcx
  0019c	0f b6 54 24 20	 movzx	 edx, BYTE PTR valid_bit_domain$1[rsp]
  001a1	83 e2 07	 and	 edx, 7
  001a4	bf 80 00 00 00	 mov	 edi, 128		; 00000080H
  001a9	0f b6 ca	 movzx	 ecx, dl
  001ac	8b d7		 mov	 edx, edi
  001ae	d3 fa		 sar	 edx, cl
  001b0	8b ca		 mov	 ecx, edx
  001b2	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv137[rsp]
  001b7	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  001bb	0b c1		 or	 eax, ecx
  001bd	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR valid_bit_domain$1[rsp]
  001c2	c1 f9 03	 sar	 ecx, 3
  001c5	48 63 c9	 movsxd	 rcx, ecx
  001c8	48 8b 54 24 40	 mov	 rdx, QWORD PTR valid_bit_offset$3[rsp]
  001cd	48 8b 7c 24 30	 mov	 rdi, QWORD PTR z$2[rsp]
  001d2	48 03 fa	 add	 rdi, rdx
  001d5	48 8b d7	 mov	 rdx, rdi
  001d8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN9@s390_chsc_:

; 134  :             (0x80 >> (valid_bit_domain & 0x07));
; 135  :     }
; 136  : 
; 137  :     return chsc_req_ok(chsc_rsp, rsp_len, 0);

  001db	45 33 c0	 xor	 r8d, r8d
  001de	0f b7 54 24 24	 movzx	 edx, WORD PTR rsp_len$[rsp]
  001e3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  001eb	e8 00 00 00 00	 call	 chsc_req_ok
$LN1@s390_chsc_:

; 138  : }

  001f0	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001f4	5f		 pop	 rdi
  001f5	c3		 ret	 0
s390_chsc_get_conf_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_validate_operand
_TEXT	SEGMENT
tv79 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s390_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN6@s390_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN7@s390_valid
$LN6@s390_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@s390_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 42		 je	 SHORT $LN2@s390_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00092	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00096	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  0009a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 s390_maddr_l
$LN2@s390_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
s390_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.c
_TEXT	SEGMENT
req_len$ = 64
r1$ = 68
chsc_req$ = 72
chsc_rsp$ = 80
tv190 = 88
req$ = 92
n$ = 96
i$1 = 100
r2$ = 104
tv262 = 112
mn$ = 120
inst$ = 144
regs$ = 152
s390_channel_subsystem_call PROC

; 572  : {

$LN40:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 573  : int     r1, r2;                                 /* register values   */
; 574  : VADR    n;                                      /* Unsigned work     */
; 575  : BYTE   *mn;                                     /* Unsigned work     */
; 576  : U16     req_len;                                /* Length of request */
; 577  : U16     req;                                    /* Request code      */
; 578  : CHSC_REQ *chsc_req;                             /* Request structure */
; 579  : CHSC_RSP *chsc_rsp;                             /* Response structure*/
; 580  : 
; 581  :     RRE(inst, regs, r1, r2);

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 03	 imul	 rax, rax, 3
  0001a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00022	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00026	89 44 24 64	 mov	 DWORD PTR i$1[rsp], eax
  0002a	8b 44 24 64	 mov	 eax, DWORD PTR i$1[rsp]
  0002e	83 e0 0f	 and	 eax, 15
  00031	89 44 24 68	 mov	 DWORD PTR r2$[rsp], eax
  00035	8b 44 24 64	 mov	 eax, DWORD PTR i$1[rsp]
  00039	c1 f8 04	 sar	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_chann:
  00043	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004f	48 83 c0 04	 add	 rax, 4
  00053	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005f	33 c0		 xor	 eax, eax
  00061	83 f8 04	 cmp	 eax, 4
  00064	74 0f		 je	 SHORT $LN16@s390_chann
  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN16@s390_chann:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 c8		 jne	 SHORT $LN4@s390_chann

; 582  : 
; 583  :     /* Display instruction if debugging */
; 584  : #if defined(CHSC_DEBUG)
; 585  :     ARCH_DEP(display_inst) (regs, inst);
; 586  : #endif
; 587  : 
; 588  :     PER_ZEROADDR_CHECK( regs, r1 );
; 589  :     TXF_INSTR_CHECK( regs );
; 590  :     PRIV_CHECK(regs);

  0007b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00083	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00087	83 e0 01	 and	 eax, 1
  0008a	85 c0		 test	 eax, eax
  0008c	74 1b		 je	 SHORT $LN17@s390_chann
  0008e	ba 02 00 00 00	 mov	 edx, 2
  00093	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@s390_chann:
$LN7@s390_chann:

; 591  : 
; 592  :     SIE_INTERCEPT(regs);

  000a9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b7	d1 e8		 shr	 eax, 1
  000b9	83 e0 01	 and	 eax, 1
  000bc	85 c0		 test	 eax, eax
  000be	74 1b		 je	 SHORT $LN18@s390_chann
  000c0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000ce	ba fc ff ff ff	 mov	 edx, -4
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 longjmp
$LN18@s390_chann:
  000db	33 c0		 xor	 eax, eax
  000dd	85 c0		 test	 eax, eax
  000df	75 c8		 jne	 SHORT $LN7@s390_chann
$LN10@s390_chann:

; 593  : 
; 594  :     PTT_INF("CHSC",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  000e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000eb	48 83 e0 08	 and	 rax, 8
  000ef	48 85 c0	 test	 rax, rax
  000f2	74 69		 je	 SHORT $LN19@s390_chann
  000f4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00102	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00107	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0010f	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00116	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0011b	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00123	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  0012b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00134	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180225
  00140	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00145	44 8b c9	 mov	 r9d, ecx
  00148	44 8b c2	 mov	 r8d, edx
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180226
  00152	b9 08 00 00 00	 mov	 ecx, 8
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@s390_chann:
  0015d	33 c0		 xor	 eax, eax
  0015f	85 c0		 test	 eax, eax
  00161	0f 85 7a ff ff
	ff		 jne	 $LN10@s390_chann

; 595  : 
; 596  :     /* Check operand-1 for page alignment */
; 597  :     n = regs->GR(r1) & ADDRESS_MAXWRAP(regs);

  00167	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0017c	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00182	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00189	23 c2		 and	 eax, edx
  0018b	89 44 24 60	 mov	 DWORD PTR n$[rsp], eax

; 598  : 
; 599  :     if(n & 0xFFF)

  0018f	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  00193	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00198	85 c0		 test	 eax, eax
  0019a	74 12		 je	 SHORT $LN20@s390_chann

; 600  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0019c	ba 06 00 00 00	 mov	 edx, 6
  001a1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	e8 00 00 00 00	 call	 s390_program_interrupt
$LN20@s390_chann:

; 601  : 
; 602  :     /* Get pointer to request/response */
; 603  :     mn = MADDR(n, r1, regs, ACCTYPE_READ, regs->psw.pkey);

  001ae	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001ba	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  001be	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001c6	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001ce	44 8b 44 24 44	 mov	 r8d, DWORD PTR r1$[rsp]
  001d3	ba 01 00 00 00	 mov	 edx, 1
  001d8	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  001dc	e8 00 00 00 00	 call	 s390_maddr_l
  001e1	48 89 44 24 78	 mov	 QWORD PTR mn$[rsp], rax

; 604  :     chsc_req = (CHSC_REQ*)(mn);

  001e6	48 8b 44 24 78	 mov	 rax, QWORD PTR mn$[rsp]
  001eb	48 89 44 24 48	 mov	 QWORD PTR chsc_req$[rsp], rax

; 605  : 
; 606  :     /* Fetch length of request field */
; 607  :     FETCH_HW(req_len, chsc_req->length);

  001f0	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_req$[rsp]
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	e8 00 00 00 00	 call	 fetch_hw_noswap
  001fd	0f b7 c8	 movzx	 ecx, ax
  00200	e8 00 00 00 00	 call	 _byteswap_ushort
  00205	66 89 44 24 40	 mov	 WORD PTR req_len$[rsp], ax

; 608  : 
; 609  :     /* Point to beginning of response field */
; 610  :     chsc_rsp = (CHSC_RSP*)((BYTE*)chsc_req + req_len);

  0020a	0f b7 44 24 40	 movzx	 eax, WORD PTR req_len$[rsp]
  0020f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00214	48 03 c8	 add	 rcx, rax
  00217	48 8b c1	 mov	 rax, rcx
  0021a	48 89 44 24 50	 mov	 QWORD PTR chsc_rsp$[rsp], rax

; 611  : 
; 612  :     /* Check for invalid request length */
; 613  :     if((req_len < sizeof(CHSC_REQ))
; 614  :       || (req_len > (CHSC_REQRSP_SIZE - sizeof(CHSC_RSP))))

  0021f	0f b7 44 24 40	 movzx	 eax, WORD PTR req_len$[rsp]
  00224	48 83 f8 10	 cmp	 rax, 16
  00228	72 0d		 jb	 SHORT $LN22@s390_chann
  0022a	0f b7 44 24 40	 movzx	 eax, WORD PTR req_len$[rsp]
  0022f	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00235	76 12		 jbe	 SHORT $LN21@s390_chann
$LN22@s390_chann:

; 615  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00237	ba 15 00 00 00	 mov	 edx, 21
  0023c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00244	e8 00 00 00 00	 call	 s390_program_interrupt
$LN21@s390_chann:

; 616  : 
; 617  :     /* Fetch the CHSC request code */
; 618  :     FETCH_HW(req,chsc_req->req);

  00249	48 8b 44 24 48	 mov	 rax, QWORD PTR chsc_req$[rsp]
  0024e	48 83 c0 02	 add	 rax, 2
  00252	48 8b c8	 mov	 rcx, rax
  00255	e8 00 00 00 00	 call	 fetch_hw_noswap
  0025a	0f b7 c8	 movzx	 ecx, ax
  0025d	e8 00 00 00 00	 call	 _byteswap_ushort
  00262	66 89 44 24 5c	 mov	 WORD PTR req$[rsp], ax

; 619  : 
; 620  :     /* Verify we have write access to the page */
; 621  :     ARCH_DEP(validate_operand) (n, r1, 0, ACCTYPE_WRITE, regs);

  00267	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00274	41 b9 02 00 00
	00		 mov	 r9d, 2
  0027a	45 33 c0	 xor	 r8d, r8d
  0027d	8b 54 24 44	 mov	 edx, DWORD PTR r1$[rsp]
  00281	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  00285	e8 00 00 00 00	 call	 s390_validate_operand

; 622  : 
; 623  :     switch(req) {

  0028a	0f b7 44 24 5c	 movzx	 eax, WORD PTR req$[rsp]
  0028f	89 44 24 58	 mov	 DWORD PTR tv190[rsp], eax
  00293	8b 44 24 58	 mov	 eax, DWORD PTR tv190[rsp]
  00297	83 e8 02	 sub	 eax, 2
  0029a	89 44 24 58	 mov	 DWORD PTR tv190[rsp], eax
  0029e	83 7c 24 58 22	 cmp	 DWORD PTR tv190[rsp], 34 ; 00000022H
  002a3	0f 87 25 01 00
	00		 ja	 $LN32@s390_chann
  002a9	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv190[rsp]
  002ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002b5	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN38@s390_chann[rcx+rax]
  002bd	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN39@s390_chann[rcx+rax*4]
  002c4	48 03 c1	 add	 rax, rcx
  002c7	ff e0		 jmp	 rax
$LN23@s390_chann:

; 624  : 
; 625  :         case CHSC_REQ_CHPDESC: /* 0x0002  Store Channel-Path Description */
; 626  :             regs->psw.cc = ARCH_DEP(chsc_get_chp_desc) (chsc_req, chsc_rsp);

  002c9	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  002ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  002d3	e8 00 00 00 00	 call	 s390_chsc_get_chp_desc
  002d8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e0	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 627  :             break;

  002e3	e9 01 02 00 00	 jmp	 $LN11@s390_chann
$LN24@s390_chann:

; 628  : 
; 629  :         case CHSC_REQ_SCHDESC: /* 0x0004  Store Subchannel Description Data */
; 630  :             regs->psw.cc = ARCH_DEP(chsc_get_sch_desc) (chsc_req, chsc_rsp);

  002e8	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  002ed	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  002f2	e8 00 00 00 00	 call	 s390_chsc_get_sch_desc
  002f7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ff	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 631  :             break;

  00302	e9 e2 01 00 00	 jmp	 $LN11@s390_chann
$LN25@s390_chann:

; 632  : 
; 633  :         case CHSC_REQ_CUDESC:  /* 0x0006  Store Subchannel Control-Unit Data */
; 634  :             regs->psw.cc = ARCH_DEP(chsc_get_cu_desc) (chsc_req, chsc_rsp);

  00307	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  0030c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00311	e8 00 00 00 00	 call	 s390_chsc_get_cu_desc
  00316	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 635  :             break;

  00321	e9 c3 01 00 00	 jmp	 $LN11@s390_chann
$LN26@s390_chann:

; 636  : 
; 637  :         case CHSC_REQ_CSSINFO: /* 0x0010  Store Channel-Subsystem Characteristics */
; 638  :             regs->psw.cc = ARCH_DEP(chsc_get_css_info) (regs, chsc_req, chsc_rsp);

  00326	4c 8b 44 24 50	 mov	 r8, QWORD PTR chsc_rsp$[rsp]
  0032b	48 8b 54 24 48	 mov	 rdx, QWORD PTR chsc_req$[rsp]
  00330	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00338	e8 00 00 00 00	 call	 s390_chsc_get_css_info
  0033d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00345	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 639  :             break;

  00348	e9 9c 01 00 00	 jmp	 $LN11@s390_chann
$LN27@s390_chann:

; 640  : 
; 641  :         case CHSC_REQ_CNFINFO: /* 0x0012  Store Configuration Information */
; 642  :             regs->psw.cc = ARCH_DEP(chsc_get_conf_info) (chsc_req, chsc_rsp);

  0034d	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  00352	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00357	e8 00 00 00 00	 call	 s390_chsc_get_conf_info
  0035c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00364	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 643  :             break;

  00367	e9 7d 01 00 00	 jmp	 $LN11@s390_chann
$LN28@s390_chann:

; 644  : 
; 645  : #if defined(_FEATURE_QDIO_THININT)
; 646  : 
; 647  :         case CHSC_REQ_SETSSSI: /* 0x0021  Set Subchannel Indicator */
; 648  :             if (FACILITY_ENABLED( HERC_QDIO_THININT, regs ))

  0036c	b8 01 00 00 00	 mov	 eax, 1
  00371	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00375	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037d	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00385	83 e0 10	 and	 eax, 16
  00388	85 c0		 test	 eax, eax
  0038a	74 21		 je	 SHORT $LN29@s390_chann

; 649  :             {
; 650  :                 regs->psw.cc = ARCH_DEP(chsc_set_sci) (chsc_req, chsc_rsp);

  0038c	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  00391	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  00396	e8 00 00 00 00	 call	 s390_chsc_set_sci
  0039b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a3	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 651  :                 break;

  003a6	e9 3e 01 00 00	 jmp	 $LN11@s390_chann

; 652  :             }

  003ab	eb 02		 jmp	 SHORT $LN30@s390_chann
$LN29@s390_chann:

; 653  :             else
; 654  :                 goto chsc_error;

  003ad	eb 1f		 jmp	 SHORT $chsc_error$41
$LN30@s390_chann:
$LN31@s390_chann:

; 655  : 
; 656  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 657  : 
; 658  :         case CHSC_REQ_GETSSQD: /* 0x0024  Store Subchannel QDIO Data */
; 659  :             regs->psw.cc = ARCH_DEP(chsc_get_ssqd) (chsc_req, chsc_rsp);

  003af	48 8b 54 24 50	 mov	 rdx, QWORD PTR chsc_rsp$[rsp]
  003b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chsc_req$[rsp]
  003b9	e8 00 00 00 00	 call	 s390_chsc_get_ssqd
  003be	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c6	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 660  :             break;

  003c9	e9 1b 01 00 00	 jmp	 $LN11@s390_chann
$LN32@s390_chann:
$chsc_error$41:
$LN15@s390_chann:

; 661  : 
; 662  : #if 0
; 663  :         case CHSC_REQ_ENFACIL: /* 0x0031  Enable Facility */
; 664  :             regs->psw.cc = ARCH_DEP(chsc_enable_facility) (chsc_req, chsc_rsp);
; 665  :             break;
; 666  : #endif
; 667  : 
; 668  :         default:
; 669  : #if defined(_FEATURE_QDIO_THININT)
; 670  :         chsc_error:
; 671  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 672  :             PTT_ERR("*CHSC",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  003ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003d5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003d8	48 83 e0 10	 and	 rax, 16
  003dc	48 85 c0	 test	 rax, rax
  003df	74 69		 je	 SHORT $LN33@s390_chann
  003e1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003ef	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR r2$[rsp]
  003f4	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003fc	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00403	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00408	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00410	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00418	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00421	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00426	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180241
  0042d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00432	44 8b c9	 mov	 r9d, ecx
  00435	44 8b c2	 mov	 r8d, edx
  00438	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180242
  0043f	b9 10 00 00 00	 mov	 ecx, 16
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@s390_chann:
  0044a	33 c0		 xor	 eax, eax
  0044c	85 c0		 test	 eax, eax
  0044e	0f 85 7a ff ff
	ff		 jne	 $LN15@s390_chann

; 673  :             if( HDC3(debug_chsc_unknown_request, chsc_rsp, chsc_req, regs) )

  00454	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_chsc_unknown_request
  0045b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0045f	74 22		 je	 SHORT $LN36@s390_chann
  00461	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00469	48 8b 54 24 48	 mov	 rdx, QWORD PTR chsc_req$[rsp]
  0046e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00473	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_chsc_unknown_request
  0047a	ff 10		 call	 QWORD PTR [rax]
  0047c	48 89 44 24 70	 mov	 QWORD PTR tv262[rsp], rax
  00481	eb 09		 jmp	 SHORT $LN37@s390_chann
$LN36@s390_chann:
  00483	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv262[rsp], 0
$LN37@s390_chann:
  0048c	48 83 7c 24 70
	00		 cmp	 QWORD PTR tv262[rsp], 0
  00492	74 02		 je	 SHORT $LN34@s390_chann

; 674  :                 break;

  00494	eb 53		 jmp	 SHORT $LN11@s390_chann
$LN34@s390_chann:

; 675  :             STORE_HW(chsc_rsp->length,sizeof(CHSC_RSP));

  00496	66 b9 08 00	 mov	 cx, 8
  0049a	e8 00 00 00 00	 call	 _byteswap_ushort
  0049f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  004a4	0f b7 d0	 movzx	 edx, ax
  004a7	e8 00 00 00 00	 call	 store_hw_noswap

; 676  :             STORE_HW(chsc_rsp->rsp,CHSC_REQ_INVALID);

  004ac	66 b9 02 00	 mov	 cx, 2
  004b0	e8 00 00 00 00	 call	 _byteswap_ushort
  004b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  004ba	48 83 c1 02	 add	 rcx, 2
  004be	0f b7 d0	 movzx	 edx, ax
  004c1	e8 00 00 00 00	 call	 store_hw_noswap

; 677  :             /* No reason code */
; 678  :             STORE_FW(chsc_rsp->info,0);

  004c6	33 c9		 xor	 ecx, ecx
  004c8	e8 00 00 00 00	 call	 _byteswap_ulong
  004cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  004d2	48 83 c1 04	 add	 rcx, 4
  004d6	8b d0		 mov	 edx, eax
  004d8	e8 00 00 00 00	 call	 store_fw_noswap

; 679  :             /* Return cc0 even for unsupported requests?? */
; 680  :             regs->psw.cc = 0;

  004dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e5	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN11@s390_chann:
$LN35@s390_chann:

; 681  :             break;
; 682  :     }
; 683  : 
; 684  :     /* Show results if debugging */
; 685  :     #if defined(CHSC_DEBUG)
; 686  :     DUMP_CHSC_REQRSP( req, chsc_req );
; 687  :     #endif
; 688  : }

  004e9	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  004f0	c3		 ret	 0
  004f1	0f 1f 00	 npad	 3
$LN39@s390_chann:
  004f4	00 00 00 00	 DD	 $LN23@s390_chann
  004f8	00 00 00 00	 DD	 $LN24@s390_chann
  004fc	00 00 00 00	 DD	 $LN25@s390_chann
  00500	00 00 00 00	 DD	 $LN26@s390_chann
  00504	00 00 00 00	 DD	 $LN27@s390_chann
  00508	00 00 00 00	 DD	 $LN28@s390_chann
  0050c	00 00 00 00	 DD	 $LN31@s390_chann
  00510	00 00 00 00	 DD	 $LN32@s390_chann
$LN38@s390_chann:
  00514	00		 DB	 0
  00515	07		 DB	 7
  00516	01		 DB	 1
  00517	07		 DB	 7
  00518	02		 DB	 2
  00519	07		 DB	 7
  0051a	07		 DB	 7
  0051b	07		 DB	 7
  0051c	07		 DB	 7
  0051d	07		 DB	 7
  0051e	07		 DB	 7
  0051f	07		 DB	 7
  00520	07		 DB	 7
  00521	07		 DB	 7
  00522	03		 DB	 3
  00523	07		 DB	 7
  00524	04		 DB	 4
  00525	07		 DB	 7
  00526	07		 DB	 7
  00527	07		 DB	 7
  00528	07		 DB	 7
  00529	07		 DB	 7
  0052a	07		 DB	 7
  0052b	07		 DB	 7
  0052c	07		 DB	 7
  0052d	07		 DB	 7
  0052e	07		 DB	 7
  0052f	07		 DB	 7
  00530	07		 DB	 7
  00531	07		 DB	 7
  00532	07		 DB	 7
  00533	05		 DB	 5
  00534	07		 DB	 7
  00535	07		 DB	 7
  00536	06		 DB	 6
s390_channel_subsystem_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.h
_TEXT	SEGMENT
chsc_rsp$ = 48
info$ = 56
chsc_req_errreq PROC

; 168  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 169  :     STORE_HW( chsc_rsp->length, sizeof(CHSC_RSP));

  0000d	66 b9 08 00	 mov	 cx, 8
  00011	e8 00 00 00 00	 call	 _byteswap_ushort
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  0001b	0f b7 d0	 movzx	 edx, ax
  0001e	e8 00 00 00 00	 call	 store_hw_noswap

; 170  :     STORE_HW( chsc_rsp->rsp, CHSC_REQ_ERRREQ);

  00023	66 b9 03 00	 mov	 cx, 3
  00027	e8 00 00 00 00	 call	 _byteswap_ushort
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00031	48 83 c1 02	 add	 rcx, 2
  00035	0f b7 d0	 movzx	 edx, ax
  00038	e8 00 00 00 00	 call	 store_hw_noswap

; 171  :     STORE_FW( chsc_rsp->info, info);

  0003d	8b 4c 24 38	 mov	 ecx, DWORD PTR info$[rsp]
  00041	e8 00 00 00 00	 call	 _byteswap_ulong
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  0004b	48 83 c1 04	 add	 rcx, 4
  0004f	8b d0		 mov	 edx, eax
  00051	e8 00 00 00 00	 call	 store_fw_noswap

; 172  :     return 0;

  00056	33 c0		 xor	 eax, eax

; 173  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
chsc_req_errreq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.h
_TEXT	SEGMENT
chsc_rsp$ = 48
rsp_len$ = 56
info$ = 64
chsc_req_ok PROC

; 156  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 157  :     STORE_HW( chsc_rsp->length, rsp_len);

  00013	0f b7 4c 24 38	 movzx	 ecx, WORD PTR rsp_len$[rsp]
  00018	e8 00 00 00 00	 call	 _byteswap_ushort
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00022	0f b7 d0	 movzx	 edx, ax
  00025	e8 00 00 00 00	 call	 store_hw_noswap

; 158  :     STORE_HW( chsc_rsp->rsp, CHSC_REQ_OK);

  0002a	66 b9 01 00	 mov	 cx, 1
  0002e	e8 00 00 00 00	 call	 _byteswap_ushort
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00038	48 83 c1 02	 add	 rcx, 2
  0003c	0f b7 d0	 movzx	 edx, ax
  0003f	e8 00 00 00 00	 call	 store_hw_noswap

; 159  :     STORE_FW( chsc_rsp->info, info);

  00044	8b 4c 24 40	 mov	 ecx, DWORD PTR info$[rsp]
  00048	e8 00 00 00 00	 call	 _byteswap_ulong
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR chsc_rsp$[rsp]
  00052	48 83 c1 04	 add	 rcx, 4
  00056	8b d0		 mov	 edx, eax
  00058	e8 00 00 00 00	 call	 store_fw_noswap

; 160  :     return 0;

  0005d	33 c0		 xor	 eax, eax

; 161  : }

  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
chsc_req_ok ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\chsc.h
_TEXT	SEGMENT
max_rsp$ = 0
req_len$ = 32
rsp_size$ = 40
chsc_max_rsp PROC

; 137  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 138  : register U16 max_rsp;
; 139  :     if (0
; 140  :         || rsp_size > (CHSC_REQRSP_SIZE - sizeof(CHSC_REQ) - sizeof(CHSC_RSP))
; 141  :         || req_len  > (CHSC_REQRSP_SIZE - sizeof(CHSC_RSP) - rsp_size)

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 1f		 jne	 SHORT $LN3@chsc_max_r
  00014	48 81 7c 24 28
	e8 0f 00 00	 cmp	 QWORD PTR rsp_size$[rsp], 4072 ; 00000fe8H
  0001d	77 14		 ja	 SHORT $LN3@chsc_max_r
  0001f	0f b7 44 24 20	 movzx	 eax, WORD PTR req_len$[rsp]
  00024	b9 f8 0f 00 00	 mov	 ecx, 4088		; 00000ff8H
  00029	48 2b 4c 24 28	 sub	 rcx, QWORD PTR rsp_size$[rsp]
  0002e	48 3b c1	 cmp	 rax, rcx
  00031	76 04		 jbe	 SHORT $LN2@chsc_max_r
$LN3@chsc_max_r:

; 142  :     )
; 143  :         return 0;

  00033	33 c0		 xor	 eax, eax
  00035	eb 4b		 jmp	 SHORT $LN1@chsc_max_r
$LN2@chsc_max_r:

; 144  :     if (!rsp_size)

  00037	48 83 7c 24 28
	00		 cmp	 QWORD PTR rsp_size$[rsp], 0
  0003d	75 20		 jne	 SHORT $LN4@chsc_max_r

; 145  :         max_rsp = (CHSC_REQRSP_SIZE - req_len) / sizeof(CHSC_RSP);

  0003f	0f b7 44 24 20	 movzx	 eax, WORD PTR req_len$[rsp]
  00044	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00049	2b c8		 sub	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 98		 cdqe
  0004f	33 d2		 xor	 edx, edx
  00051	b9 08 00 00 00	 mov	 ecx, 8
  00056	48 f7 f1	 div	 rcx
  00059	66 89 04 24	 mov	 WORD PTR max_rsp$[rsp], ax
  0005d	eb 1f		 jmp	 SHORT $LN5@chsc_max_r
$LN4@chsc_max_r:

; 146  :     else
; 147  :         max_rsp = (CHSC_REQRSP_SIZE - req_len - sizeof(CHSC_RSP)) / rsp_size;

  0005f	0f b7 44 24 20	 movzx	 eax, WORD PTR req_len$[rsp]
  00064	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00069	2b c8		 sub	 ecx, eax
  0006b	8b c1		 mov	 eax, ecx
  0006d	48 98		 cdqe
  0006f	48 83 e8 08	 sub	 rax, 8
  00073	33 d2		 xor	 edx, edx
  00075	48 f7 74 24 28	 div	 QWORD PTR rsp_size$[rsp]
  0007a	66 89 04 24	 mov	 WORD PTR max_rsp$[rsp], ax
$LN5@chsc_max_r:

; 148  :     return max_rsp;

  0007e	0f b7 04 24	 movzx	 eax, WORD PTR max_rsp$[rsp]
$LN1@chsc_max_r:

; 149  : }

  00082	48 83 c4 18	 add	 rsp, 24
  00086	c3		 ret	 0
chsc_max_rsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
