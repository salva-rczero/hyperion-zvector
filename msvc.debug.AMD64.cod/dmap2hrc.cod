; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	main
EXTRN	__imp_isprint:PROC
EXTRN	__imp__errno:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG159137 DB	01H DUP (?)
$SG159155 DB	01H DUP (?)
$SG159179 DB	01H DUP (?)
$SG159183 DB	01H DUP (?)
$SG159185 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$main DD	imagerel $LN29
	DD	imagerel $LN29+1955
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159116 DB	'Convert P/390 DEVMAP to Hercules', 00H
	ORG $+7
$SG159117 DB	'dmap2hrc', 00H
	ORG $+3
$SG159120 DB	'I', 00H
	ORG $+2
$SG159122 DB	'main', 00H
	ORG $+3
$SG159121 DB	'HHC02645%s Usage: %s infile', 0aH, 'HHC02645I', 0aH, 'HH'
	DB	'C02645I   infile    name of P/390 DEVMAP input file', 0aH, 'H'
	DB	'HC02645I', 0aH, 'HHC02645I The converted output is always wri'
	DB	'tten to stdout.', 0aH, 'HHC02645I Use standard redirection to'
	DB	' create a file instead.', 0aH, 'HHC02645I', 0aH, 'HHC02645I R'
	DB	'eturn code:', 0aH, 'HHC02645I', 0aH, 'HHC02645I   0   Success'
	DB	'ful completion', 0aH, 'HHC02645I   1   Invalid argument(s)', 0aH
	DB	'HHC02645I   2   Error opening input file', 0aH, 'HHC02645I   '
	DB	'3   Error reading header', 0aH, 'HHC02645I   4   Error readin'
	DB	'g controller record', 0aH, 'HHC02645I   5   Incomplete contro'
	DB	'ller record', 0aH, 'HHC02645I   6   Error reading device reco'
	DB	'rd', 0aH, 'HHC02645I   7   Incomplete device record', 0aH, 'H'
	DB	'HC02645I   8   Premature end of input file', 0aH, 00H
	ORG $+3
$SG159125 DB	'E', 00H
	ORG $+2
$SG159123 DB	'dmap2hrc.c', 00H
	ORG $+1
$SG159130 DB	's', 00H
	ORG $+2
$SG159126 DB	'HHC02646%s Error opening %s: %s', 0aH, 00H
	ORG $+3
$SG159127 DB	'main', 00H
	ORG $+3
$SG159131 DB	'header', 00H
	ORG $+1
$SG159132 DB	'E', 00H
	ORG $+2
$SG159128 DB	'dmap2hrc.c', 00H
	ORG $+1
$SG159139 DB	'E', 00H
	ORG $+2
$SG159133 DB	'HHC02647%s Error reading %s record%s from %s: %s', 0aH, 00H
	ORG $+2
$SG159134 DB	'main', 00H
	ORG $+3
$SG159145 DB	'E', 00H
	ORG $+2
$SG159135 DB	'dmap2hrc.c', 00H
	ORG $+1
$SG159150 DB	'E', 00H
	ORG $+2
$SG159138 DB	'controller', 00H
	ORG $+1
$SG159157 DB	'E', 00H
	ORG $+2
$SG159140 DB	'HHC02647%s Error reading %s record%s from %s: %s', 0aH, 00H
	ORG $+2
$SG159141 DB	'main', 00H
	ORG $+3
$SG159156 DB	'device', 00H
	ORG $+1
$SG159163 DB	'E', 00H
	ORG $+2
$SG159142 DB	'dmap2hrc.c', 00H
	ORG $+1
$SG159168 DB	'E', 00H
	ORG $+2
$SG159144 DB	'controller', 00H
	ORG $+5
$SG159146 DB	'HHC02648%s Incomplete %s record on %s', 0aH, 00H
	ORG $+1
$SG159147 DB	'main', 00H
	ORG $+3
$SG159148 DB	'dmap2hrc.c', 00H
	ORG $+5
$SG159151 DB	'HHC02649%s End of input file.', 0aH, 00H
	ORG $+1
$SG159152 DB	'main', 00H
	ORG $+3
$SG159153 DB	'dmap2hrc.c', 00H
	ORG $+5
$SG159158 DB	'HHC02647%s Error reading %s record%s from %s: %s', 0aH, 00H
	ORG $+2
$SG159159 DB	'main', 00H
	ORG $+7
$SG159160 DB	'dmap2hrc.c', 00H
	ORG $+1
$SG159162 DB	'device', 00H
	ORG $+5
$SG159164 DB	'HHC02648%s Incomplete %s record on %s', 0aH, 00H
	ORG $+1
$SG159165 DB	'main', 00H
	ORG $+3
$SG159166 DB	'dmap2hrc.c', 00H
	ORG $+5
$SG159169 DB	'HHC02650%s Premature end of input file', 0aH, 00H
$SG159170 DB	'main', 00H
	ORG $+3
$SG159171 DB	'dmap2hrc.c', 00H
	ORG $+1
$SG159173 DB	'    ', 00H
	ORG $+3
$SG159177 DB	'3278', 00H
	ORG $+3
$SG159178 DB	'3270', 00H
	ORG $+3
$SG159181 DB	'2540', 00H
	ORG $+3
$SG159182 DB	'3505', 00H
	ORG $+3
$SG159184 DB	'    ', 00H
	ORG $+7
$SG159186 DB	'%02X%02X    %s%s%s', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	078bH
voltbl	ENDS
xdata	SEGMENT
$unwind$main DD	022219H
	DD	04f0110H
	DD	imagerel __GSHandlerCheck
	DD	0260H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dmap2hrc.c
_TEXT	SEGMENT
len$ = 96
infd$ = 100
i$ = 104
filename$ = 112
more_devices$ = 120
output_filename$ = 128
tv327 = 136
tv330 = 144
pgm$ = 152
tv94 = 160
tv148 = 168
tv171 = 176
tv218 = 184
device$ = 192
controller$ = 256
output_type$ = 320
pathname$ = 336
__$ArrayPad$ = 608
argc$ = 640
argv$ = 648
main	PROC

; 61   : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 78 02
	00 00		 sub	 rsp, 632		; 00000278H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 62   : char           *pgm;                    /* less any extension (.ext) */
; 63   : int             i;                      /* Array subscript           */
; 64   : int             len;                    /* Length of actual read     */
; 65   : char           *filename;               /* -> Input file name        */
; 66   : int             infd = -1;              /* Input file descriptor     */

  00022	c7 44 24 64 ff
	ff ff ff	 mov	 DWORD PTR infd$[rsp], -1

; 67   : DEVMAP_CTLR     controller;             /* Controller record         */
; 68   : DEVMAP_DEV      device;                 /* Device record             */
; 69   : char            output_type[5];         /* Device type to print      */
; 70   : char           *output_filename;        /* -> filename to print      */
; 71   : int             more_devices;           /* More devices this ctlr?   */
; 72   : char            pathname[MAX_PATH];     /* file path in host format  */
; 73   : 
; 74   :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  0002a	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159116
  0003e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159117
  00045	48 8b 94 24 88
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0004d	8b 8c 24 80 02
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  0005a	89 84 24 80 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 75   : 
; 76   :     /* The only argument is the DEVMAP file name */
; 77   :     if (argc == 2 && argv[1] != NULL)

  00061	83 bc 24 80 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00069	75 34		 jne	 SHORT $LN9@main
  0006b	b8 08 00 00 00	 mov	 eax, 8
  00070	48 6b c0 01	 imul	 rax, rax, 1
  00074	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0007c	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00081	74 1c		 je	 SHORT $LN9@main

; 78   :     {
; 79   :         filename = argv[1];

  00083	b8 08 00 00 00	 mov	 eax, 8
  00088	48 6b c0 01	 imul	 rax, rax, 1
  0008c	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00094	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00098	48 89 44 24 70	 mov	 QWORD PTR filename$[rsp], rax

; 80   :     }

  0009d	eb 5f		 jmp	 SHORT $LN10@main
$LN9@main:

; 81   :     else
; 82   :     {
; 83   :         // "Usage: ..."
; 84   :         WRMSG( HHC02645, "I", pgm );

  0009f	b9 01 00 00 00	 mov	 ecx, 1
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000aa	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  000b2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159120
  000be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159121
  000ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159122
  000e1	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159123
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 85   :         exit (1);

  000f3	b9 01 00 00 00	 mov	 ecx, 1
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN10@main:

; 86   :     }
; 87   : 
; 88   :     /* Open the devmap file */
; 89   :     hostpath(pathname, filename, sizeof(pathname));

  000fe	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00104	48 8b 54 24 70	 mov	 rdx, QWORD PTR filename$[rsp]
  00109	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 90   :     infd = HOPEN (pathname, O_RDONLY | O_BINARY);

  00117	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0011c	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0012a	89 44 24 64	 mov	 DWORD PTR infd$[rsp], eax

; 91   :     if (infd < 0)

  0012e	83 7c 24 64 00	 cmp	 DWORD PTR infd$[rsp], 0
  00133	7d 7f		 jge	 SHORT $LN11@main

; 92   :     {
; 93   :         // "Error opening %s: %s"
; 94   :         FWRMSG( stderr, HHC02646, "E", filename, strerror( errno ));

  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00143	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv94[rsp], rax
  0014b	b9 02 00 00 00	 mov	 ecx, 2
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00156	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  0015e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00163	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  00168	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159125
  00174	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159126
  00180	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00185	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00190	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159127
  00197	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159128
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 95   :         exit (2);

  001a9	b9 02 00 00 00	 mov	 ecx, 2
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN11@main:

; 96   :     }
; 97   : 
; 98   :     /* Skip the file header */
; 99   :     for (i = 0; i < 9; i++)

  001b4	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001bc	eb 0a		 jmp	 SHORT $LN4@main
$LN2@main:
  001be	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  001c2	ff c0		 inc	 eax
  001c4	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN4@main:
  001c8	83 7c 24 68 09	 cmp	 DWORD PTR i$[rsp], 9
  001cd	0f 8d c3 00 00
	00		 jge	 $LN3@main

; 100  :     {
; 101  :         len = read (infd, (void *)&controller, sizeof(DEVMAP_CTLR));

  001d3	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  001d9	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR controller$[rsp]
  001e1	8b 4c 24 64	 mov	 ecx, DWORD PTR infd$[rsp]
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  001eb	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 102  :         if (len < 0)

  001ef	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  001f4	0f 8d 97 00 00
	00		 jge	 $LN12@main

; 103  :         {
; 104  :             // "Error reading %s record%s from %s: %s"
; 105  :             FWRMSG( stderr, HHC02647, "E", "header", "s", filename, strerror( errno ));

  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00200	8b 08		 mov	 ecx, DWORD PTR [rax]
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00208	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  00210	b9 02 00 00 00	 mov	 ecx, 2
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0021b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  00223	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00228	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  0022d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159130
  00239	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0023e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159131
  00245	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0024a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159132
  00251	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159133
  0025d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00262	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00267	41 b9 03 00 00
	00		 mov	 r9d, 3
  0026d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159134
  00274	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159135
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 106  :             exit (3);

  00286	b9 03 00 00 00	 mov	 ecx, 3
  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN12@main:

; 107  :         }
; 108  :     }

  00291	e9 28 ff ff ff	 jmp	 $LN2@main
$LN3@main:
$LN5@main:

; 109  : 
; 110  :     /* Read records from the input file and convert them */
; 111  :     while (1)

  00296	33 c0		 xor	 eax, eax
  00298	83 f8 01	 cmp	 eax, 1
  0029b	0f 84 de 04 00
	00		 je	 $LN6@main

; 112  :     {
; 113  :         /* Read a controller record. */
; 114  :         len = read (infd, (void *)&controller, sizeof(DEVMAP_CTLR));

  002a1	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  002a7	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR controller$[rsp]
  002af	8b 4c 24 64	 mov	 ecx, DWORD PTR infd$[rsp]
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  002b9	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 115  :         if (len < 0)

  002bd	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  002c2	0f 8d 97 00 00
	00		 jge	 $LN13@main

; 116  :         {
; 117  :             // "Error reading %s record%s from %s: %s"
; 118  :             FWRMSG( stderr, HHC02647, "E", "controller", "", filename, strerror( errno ));

  002c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002ce	8b 08		 mov	 ecx, DWORD PTR [rax]
  002d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002d6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
  002de	b9 02 00 00 00	 mov	 ecx, 2
  002e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv171[rsp]
  002f1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  002fb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159137
  00307	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159138
  00313	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00318	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159139
  0031f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159140
  0032b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00330	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00335	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159141
  00342	ba 76 00 00 00	 mov	 edx, 118		; 00000076H
  00347	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159142
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 119  :             exit (4);

  00354	b9 04 00 00 00	 mov	 ecx, 4
  00359	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN13@main:

; 120  :         }
; 121  : 
; 122  :         /* Did we finish too soon? */
; 123  :         if ((len > 0) && (len < (int)sizeof(DEVMAP_CTLR)))

  0035f	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  00364	7e 6f		 jle	 SHORT $LN14@main
  00366	83 7c 24 60 40	 cmp	 DWORD PTR len$[rsp], 64	; 00000040H
  0036b	7d 68		 jge	 SHORT $LN14@main

; 124  :         {
; 125  :             // "Incomplete %s record on %s"
; 126  :             FWRMSG( stderr, HHC02648, "E", "controller", filename );

  0036d	b9 02 00 00 00	 mov	 ecx, 2
  00372	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00378	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  0037d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159144
  00389	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0038e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159145
  00395	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159146
  003a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  003b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159147
  003b8	ba 7e 00 00 00	 mov	 edx, 126		; 0000007eH
  003bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159148
  003c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 127  :             exit(5);

  003ca	b9 05 00 00 00	 mov	 ecx, 5
  003cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN14@main:

; 128  :         }
; 129  : 
; 130  :         /* Check for end of file. */
; 131  :         if (len == 0)

  003d5	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  003da	75 4c		 jne	 SHORT $LN15@main

; 132  :         {
; 133  :             // "End of input file."
; 134  :             FWRMSG( stderr, HHC02649, "E" );

  003dc	b9 02 00 00 00	 mov	 ecx, 2
  003e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159150
  003ee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159151
  003fa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00404	41 b9 03 00 00
	00		 mov	 r9d, 3
  0040a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159152
  00411	ba 86 00 00 00	 mov	 edx, 134		; 00000086H
  00416	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159153
  0041d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 135  :             break;

  00423	e9 57 03 00 00	 jmp	 $LN6@main
$LN15@main:

; 136  :         }
; 137  : 
; 138  :         /* Read devices on this controller. */
; 139  :         more_devices = 1;

  00428	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR more_devices$[rsp], 1
$LN7@main:

; 140  :         while (more_devices)

  00430	83 7c 24 78 00	 cmp	 DWORD PTR more_devices$[rsp], 0
  00435	0f 84 3f 03 00
	00		 je	 $LN8@main

; 141  :         {
; 142  : 
; 143  :             /* Read a device record. */
; 144  :             len = read (infd, (void *)&device, sizeof(DEVMAP_DEV));

  0043b	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00441	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR device$[rsp]
  00449	8b 4c 24 64	 mov	 ecx, DWORD PTR infd$[rsp]
  0044d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00453	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 145  :             if (len < 0)

  00457	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  0045c	0f 8d 97 00 00
	00		 jge	 $LN16@main

; 146  :             {
; 147  :                 // "Error reading %s record%s from %s: %s"
; 148  :                 FWRMSG( stderr, HHC02647, "E", "device", "", filename, strerror( errno ));

  00462	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00468	8b 08		 mov	 ecx, DWORD PTR [rax]
  0046a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00470	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv218[rsp], rax
  00478	b9 02 00 00 00	 mov	 ecx, 2
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00483	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv218[rsp]
  0048b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00490	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  00495	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0049a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159155
  004a1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159156
  004ad	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159157
  004b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159158
  004c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  004d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159159
  004dc	ba 94 00 00 00	 mov	 edx, 148		; 00000094H
  004e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159160
  004e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 149  :                 exit (6);

  004ee	b9 06 00 00 00	 mov	 ecx, 6
  004f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN16@main:

; 150  :             }
; 151  : 
; 152  :             /* Did we finish too soon? */
; 153  :             if ((len > 0) && (len < (int)sizeof(DEVMAP_DEV)))

  004f9	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  004fe	7e 6f		 jle	 SHORT $LN17@main
  00500	83 7c 24 60 40	 cmp	 DWORD PTR len$[rsp], 64	; 00000040H
  00505	7d 68		 jge	 SHORT $LN17@main

; 154  :             {
; 155  :                 // "Incomplete %s record on %s"
; 156  :                 FWRMSG( stderr, HHC02648, "E", "device", filename );

  00507	b9 02 00 00 00	 mov	 ecx, 2
  0050c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00512	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  00517	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0051c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159162
  00523	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00528	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159163
  0052f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00534	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159164
  0053b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00540	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00545	41 b9 03 00 00
	00		 mov	 r9d, 3
  0054b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159165
  00552	ba 9c 00 00 00	 mov	 edx, 156		; 0000009cH
  00557	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159166
  0055e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 157  :                 exit(7);

  00564	b9 07 00 00 00	 mov	 ecx, 7
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN17@main:

; 158  :             }
; 159  : 
; 160  :             /* Check for end of file. */
; 161  :             if (len == 0)

  0056f	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  00574	75 52		 jne	 SHORT $LN18@main

; 162  :             {
; 163  :                 // Premature end of input file"
; 164  :                 FWRMSG( stderr, HHC02650, "E" );

  00576	b9 02 00 00 00	 mov	 ecx, 2
  0057b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159168
  00588	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159169
  00594	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00599	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0059e	41 b9 03 00 00
	00		 mov	 r9d, 3
  005a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159170
  005ab	ba a4 00 00 00	 mov	 edx, 164		; 000000a4H
  005b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159171
  005b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 165  :                 exit(8);

  005bd	b9 08 00 00 00	 mov	 ecx, 8
  005c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN18@main:

; 166  :             }
; 167  : 
; 168  :             /* Is this the dummy device record at the end of the controller's
; 169  :                set of devices? */
; 170  :             if (strncmp(device.type,"    ",4) == 0)

  005c8	41 b8 04 00 00
	00		 mov	 r8d, 4
  005ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159173
  005d5	48 8d 8c 24 c2
	00 00 00	 lea	 rcx, QWORD PTR device$[rsp+2]
  005dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  005e3	85 c0		 test	 eax, eax
  005e5	75 0d		 jne	 SHORT $LN19@main

; 171  :             {
; 172  :                 more_devices = 0;

  005e7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR more_devices$[rsp], 0

; 173  :                 break;

  005ef	e9 86 01 00 00	 jmp	 $LN8@main
$LN19@main:

; 174  :             }
; 175  : 
; 176  :             /* It's a real device. Fix the type so Hercules can use it and
; 177  :                locate the output filename. */
; 178  :             STRLCPY( output_type, device.type );

  005f4	41 b8 05 00 00
	00		 mov	 r8d, 5
  005fa	48 8d 94 24 c2
	00 00 00	 lea	 rdx, QWORD PTR device$[rsp+2]
  00602	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR output_type$[rsp]
  0060a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 179  :             if (isprint(device.parms.disk.volser[0]))

  00610	b8 01 00 00 00	 mov	 eax, 1
  00615	48 6b c0 00	 imul	 rax, rax, 0
  00619	0f b6 84 04 ca
	00 00 00	 movzx	 eax, BYTE PTR device$[rsp+rax+10]
  00621	8b c8		 mov	 ecx, eax
  00623	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00629	85 c0		 test	 eax, eax
  0062b	74 12		 je	 SHORT $LN20@main

; 180  :                 output_filename = device.parms.disk.filename;

  0062d	48 8d 84 24 d2
	00 00 00	 lea	 rax, QWORD PTR device$[rsp+18]
  00635	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR output_filename$[rsp], rax
  0063d	eb 10		 jmp	 SHORT $LN21@main
$LN20@main:

; 181  :             else output_filename = device.parms.other.filename;

  0063f	48 8d 84 24 cd
	00 00 00	 lea	 rax, QWORD PTR device$[rsp+13]
  00647	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR output_filename$[rsp], rax
$LN21@main:

; 182  : 
; 183  :             if (strncmp(device.type, "3278", 4) == 0)

  0064f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00655	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159177
  0065c	48 8d 8c 24 c2
	00 00 00	 lea	 rcx, QWORD PTR device$[rsp+2]
  00664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0066a	85 c0		 test	 eax, eax
  0066c	75 2a		 jne	 SHORT $LN22@main

; 184  :             {
; 185  :                 STRLCPY( output_type, "3270" );

  0066e	41 b8 05 00 00
	00		 mov	 r8d, 5
  00674	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159178
  0067b	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR output_type$[rsp]
  00683	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 186  :                 output_filename = "";

  00689	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159179
  00690	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR output_filename$[rsp], rax
$LN22@main:

; 187  :             }
; 188  :             if (strncmp(device.type, "2540", 4) == 0)

  00698	41 b8 04 00 00
	00		 mov	 r8d, 4
  0069e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159181
  006a5	48 8d 8c 24 c2
	00 00 00	 lea	 rcx, QWORD PTR device$[rsp+2]
  006ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  006b3	85 c0		 test	 eax, eax
  006b5	75 1b		 jne	 SHORT $LN23@main

; 189  :                 STRLCPY( output_type, "3505" );

  006b7	41 b8 05 00 00
	00		 mov	 r8d, 5
  006bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159182
  006c4	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR output_type$[rsp]
  006cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN23@main:

; 190  : 
; 191  :             /* Emit the Hercules config file entry. */
; 192  :             len = (int) strlen( output_filename );

  006d2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR output_filename$[rsp]
  006da	e8 00 00 00 00	 call	 strlen
  006df	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 193  :             printf("%02X%02X    %s%s%s\n",

  006e3	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  006e8	74 12		 je	 SHORT $LN25@main
  006ea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR output_filename$[rsp]
  006f2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv327[rsp], rax
  006fa	eb 0f		 jmp	 SHORT $LN26@main
$LN25@main:
  006fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159183
  00703	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv327[rsp], rax
$LN26@main:
  0070b	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  00710	74 11		 je	 SHORT $LN27@main
  00712	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159184
  00719	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv330[rsp], rax
  00721	eb 0f		 jmp	 SHORT $LN28@main
$LN27@main:
  00723	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159185
  0072a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv330[rsp], rax
$LN28@main:
  00732	0f b6 84 24 c1
	00 00 00	 movzx	 eax, BYTE PTR device$[rsp+1]
  0073a	0f b6 8c 24 c0
	00 00 00	 movzx	 ecx, BYTE PTR device$[rsp]
  00742	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv327[rsp]
  0074a	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0074f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv330[rsp]
  00757	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0075c	4c 8d 8c 24 40
	01 00 00	 lea	 r9, QWORD PTR output_type$[rsp]
  00764	44 8b c0	 mov	 r8d, eax
  00767	8b d1		 mov	 edx, ecx
  00769	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159186
  00770	e8 00 00 00 00	 call	 printf

; 194  :                 device.highaddr,
; 195  :                 device.lowaddr,
; 196  :                 output_type,
; 197  :                 len ?          "    " : "",
; 198  :                 len ? output_filename : ""
; 199  :             );
; 200  : 
; 201  :         } /* end while more_devices) */

  00775	e9 b6 fc ff ff	 jmp	 $LN7@main
$LN8@main:

; 202  : 
; 203  :     } /* end while (1) */

  0077a	e9 17 fb ff ff	 jmp	 $LN5@main
$LN6@main:

; 204  : 
; 205  :     /* Close files and exit */
; 206  :     close (infd);

  0077f	8b 4c 24 64	 mov	 ecx, DWORD PTR infd$[rsp]
  00783	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 207  : 
; 208  :     return 0;

  00789	33 c0		 xor	 eax, eax
$LN24@main:

; 209  : 
; 210  : } /* end function main */

  0078b	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00793	48 33 cc	 xor	 rcx, rsp
  00796	e8 00 00 00 00	 call	 __security_check_cookie
  0079b	48 81 c4 78 02
	00 00		 add	 rsp, 632		; 00000278H
  007a2	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
