; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	packed_to_binary
PUBLIC	binary_to_packed
PUBLIC	s370_test_decimal
PUBLIC	s370_add_decimal
PUBLIC	s370_compare_decimal
PUBLIC	s370_divide_decimal
PUBLIC	s370_edit_x_edit_and_mark
PUBLIC	s370_multiply_decimal
PUBLIC	s370_shift_and_round_decimal
PUBLIC	s370_subtract_decimal
PUBLIC	s370_zero_and_add
PUBLIC	fetch_fw_noswap
PUBLIC	s370_per1_gra
PUBLIC	s370_maddr_l
PUBLIC	s370_vstorec
PUBLIC	s370_vstoreb
PUBLIC	s370_vfetchc
PUBLIC	s370_vfetchb
PUBLIC	s370_validate_operand
PUBLIC	s390_test_decimal
PUBLIC	s390_add_decimal
PUBLIC	s390_compare_decimal
PUBLIC	s390_divide_decimal
PUBLIC	s390_edit_x_edit_and_mark
PUBLIC	s390_multiply_decimal
PUBLIC	s390_shift_and_round_decimal
PUBLIC	s390_subtract_decimal
PUBLIC	s390_zero_and_add
PUBLIC	s390_maddr_l
PUBLIC	s390_vstorec
PUBLIC	s390_vstoreb
PUBLIC	s390_vfetchc
PUBLIC	s390_vfetchb
PUBLIC	s390_validate_operand
PUBLIC	z900_test_decimal
PUBLIC	z900_add_decimal
PUBLIC	z900_compare_decimal
PUBLIC	z900_divide_decimal
PUBLIC	z900_edit_x_edit_and_mark
PUBLIC	z900_multiply_decimal
PUBLIC	z900_shift_and_round_decimal
PUBLIC	z900_subtract_decimal
PUBLIC	z900_zero_and_add
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_per3_zero_xcheck2
PUBLIC	z900_maddr_l
PUBLIC	z900_vstorec
PUBLIC	z900_vstoreb
PUBLIC	z900_vfetchc
PUBLIC	z900_vfetchb
PUBLIC	z900_validate_operand
PUBLIC	??_C@_0CM@OMLMFJCF@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
PUBLIC	??_C@_0CM@JBMLKNGA@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
EXTRN	_byteswap_ulong:PROC
EXTRN	longjmp:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$packed_to_binary DD imagerel $LN26
	DD	imagerel $LN26+667
	DD	imagerel $unwind$packed_to_binary
$pdata$binary_to_packed DD imagerel $LN11
	DD	imagerel $LN11+304
	DD	imagerel $unwind$binary_to_packed
$pdata$s370_test_decimal DD imagerel $LN15
	DD	imagerel $LN15+380
	DD	imagerel $unwind$s370_test_decimal
$pdata$s370_add_decimal DD imagerel $LN23
	DD	imagerel $LN23+916
	DD	imagerel $unwind$s370_add_decimal
$pdata$s370_compare_decimal DD imagerel $LN20
	DD	imagerel $LN20+714
	DD	imagerel $unwind$s370_compare_decimal
$pdata$s370_divide_decimal DD imagerel $LN15
	DD	imagerel $LN15+866
	DD	imagerel $unwind$s370_divide_decimal
$pdata$s370_edit_x_edit_and_mark DD imagerel $LN57
	DD	imagerel $LN57+1638
	DD	imagerel $unwind$s370_edit_x_edit_and_mark
$pdata$s370_multiply_decimal DD imagerel $LN21
	DD	imagerel $LN21+904
	DD	imagerel $unwind$s370_multiply_decimal
$pdata$s370_shift_and_round_decimal DD imagerel $LN36
	DD	imagerel $LN36+1178
	DD	imagerel $unwind$s370_shift_and_round_decimal
$pdata$s370_subtract_decimal DD imagerel $LN23
	DD	imagerel $LN23+918
	DD	imagerel $unwind$s370_subtract_decimal
$pdata$s370_zero_and_add DD imagerel $LN16
	DD	imagerel $LN16+621
	DD	imagerel $unwind$s370_zero_and_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_per1_gra DD imagerel $LN7
	DD	imagerel $LN7+149
	DD	imagerel $unwind$s370_per1_gra
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstoreb DD imagerel $LN18
	DD	imagerel $LN18+169
	DD	imagerel $unwind$s370_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchc DD imagerel $LN24
	DD	imagerel $LN24+528
	DD	imagerel $unwind$s370_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchb DD imagerel $LN18
	DD	imagerel $LN18+160
	DD	imagerel $unwind$s370_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_validate_operand DD imagerel $LN24
	DD	imagerel $LN24+271
	DD	imagerel $unwind$s370_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$add_decimal DD imagerel add_decimal
	DD	imagerel add_decimal+213
	DD	imagerel $unwind$add_decimal
$pdata$subtract_decimal DD imagerel subtract_decimal
	DD	imagerel subtract_decimal+355
	DD	imagerel $unwind$subtract_decimal
$pdata$divide_decimal DD imagerel divide_decimal
	DD	imagerel divide_decimal+1740
	DD	imagerel $unwind$divide_decimal
$pdata$s370_load_decimal DD imagerel s370_load_decimal
	DD	imagerel s370_load_decimal+466
	DD	imagerel $unwind$s370_load_decimal
$pdata$s370_store_decimal DD imagerel s370_store_decimal
	DD	imagerel s370_store_decimal+367
	DD	imagerel $unwind$s370_store_decimal
$pdata$s390_test_decimal DD imagerel $LN15
	DD	imagerel $LN15+390
	DD	imagerel $unwind$s390_test_decimal
$pdata$s390_add_decimal DD imagerel $LN23
	DD	imagerel $LN23+942
	DD	imagerel $unwind$s390_add_decimal
$pdata$s390_compare_decimal DD imagerel $LN20
	DD	imagerel $LN20+740
	DD	imagerel $unwind$s390_compare_decimal
$pdata$s390_divide_decimal DD imagerel $LN15
	DD	imagerel $LN15+892
	DD	imagerel $unwind$s390_divide_decimal
$pdata$s390_edit_x_edit_and_mark DD imagerel $LN48
	DD	imagerel $LN48+1525
	DD	imagerel $unwind$s390_edit_x_edit_and_mark
$pdata$s390_multiply_decimal DD imagerel $LN21
	DD	imagerel $LN21+930
	DD	imagerel $unwind$s390_multiply_decimal
$pdata$s390_shift_and_round_decimal DD imagerel $LN36
	DD	imagerel $LN36+1204
	DD	imagerel $unwind$s390_shift_and_round_decimal
$pdata$s390_subtract_decimal DD imagerel $LN23
	DD	imagerel $LN23+944
	DD	imagerel $unwind$s390_subtract_decimal
$pdata$s390_zero_and_add DD imagerel $LN16
	DD	imagerel $LN16+647
	DD	imagerel $unwind$s390_zero_and_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$s390_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchb DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$s390_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+185
	DD	imagerel $unwind$s390_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$s390_load_decimal DD imagerel s390_load_decimal
	DD	imagerel s390_load_decimal+466
	DD	imagerel $unwind$s390_load_decimal
$pdata$s390_store_decimal DD imagerel s390_store_decimal
	DD	imagerel s390_store_decimal+367
	DD	imagerel $unwind$s390_store_decimal
$pdata$z900_test_decimal DD imagerel $LN19
	DD	imagerel $LN19+532
	DD	imagerel $unwind$z900_test_decimal
$pdata$z900_add_decimal DD imagerel $LN27
	DD	imagerel $LN27+1105
	DD	imagerel $unwind$z900_add_decimal
$pdata$z900_compare_decimal DD imagerel $LN24
	DD	imagerel $LN24+884
	DD	imagerel $unwind$z900_compare_decimal
$pdata$z900_divide_decimal DD imagerel $LN19
	DD	imagerel $LN19+1050
	DD	imagerel $unwind$z900_divide_decimal
$pdata$z900_edit_x_edit_and_mark DD imagerel $LN54
	DD	imagerel $LN54+1787
	DD	imagerel $unwind$z900_edit_x_edit_and_mark
$pdata$z900_multiply_decimal DD imagerel $LN25
	DD	imagerel $LN25+1087
	DD	imagerel $unwind$z900_multiply_decimal
$pdata$z900_shift_and_round_decimal DD imagerel $LN40
	DD	imagerel $LN40+1374
	DD	imagerel $unwind$z900_shift_and_round_decimal
$pdata$z900_subtract_decimal DD imagerel $LN27
	DD	imagerel $LN27+1107
	DD	imagerel $unwind$z900_subtract_decimal
$pdata$z900_zero_and_add DD imagerel $LN20
	DD	imagerel $LN20+791
	DD	imagerel $unwind$z900_zero_and_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck2 DD imagerel $LN18
	DD	imagerel $LN18+485
	DD	imagerel $unwind$z900_per3_zero_xcheck2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$z900_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchb DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$z900_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$z900_load_decimal DD imagerel z900_load_decimal
	DD	imagerel z900_load_decimal+467
	DD	imagerel $unwind$z900_load_decimal
$pdata$z900_store_decimal DD imagerel z900_store_decimal
	DD	imagerel z900_store_decimal+377
	DD	imagerel $unwind$z900_store_decimal
pdata	ENDS
_DATA	SEGMENT
$SG169595 DB	00H, 00H, 00H, 00H, 00H, 00H, 092H, '#7 6', 085H, 'Gu', 080H
	DB	08dH, 00H
	ORG $+7
$SG193510 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:713', 00H
	ORG $+3
$SG193550 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:788', 00H
	ORG $+3
$SG193590 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:849', 00H
	ORG $+3
$SG193634 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:923', 00H
	ORG $+3
$SG193709 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:1112', 00H
	ORG $+2
$SG193752 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:1183', 00H
	ORG $+2
$SG193793 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:1279', 00H
	ORG $+2
$SG193831 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:1353', 00H
	ORG $+2
$SG193859 DB	'C:\papa\MyGit\hyperion-zvector\decimal.c:1398', 00H
_DATA	ENDS
;	COMDAT ??_C@_0CM@JBMLKNGA@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@JBMLKNGA@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\inline.h:555', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@OMLMFJCF@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@OMLMFJCF@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\inline.h:550', 00H	; `string'
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchb DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstoreb DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck2 DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchb DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchb DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_per1_gra DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_store_decimal
	DD	021H
	DD	0167H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_decimal
	DD	022H
	DD	01c0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_zero_and_add
	DD	01bH
	DD	02ffH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_subtract_decimal
	DD	01dH
	DD	0439H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_shift_and_round_decimal
	DD	01bH
	DD	0546H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_multiply_decimal
	DD	01cH
	DD	0426H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_divide_decimal
	DD	01bH
	DD	0402H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_decimal
	DD	01bH
	DD	035cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_add_decimal
	DD	01dH
	DD	0437H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_decimal
	DD	018H
	DD	0202H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_store_decimal
	DD	020H
	DD	015dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_decimal
	DD	021H
	DD	01bfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_zero_and_add
	DD	01bH
	DD	026fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_subtract_decimal
	DD	01dH
	DD	0396H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_shift_and_round_decimal
	DD	01bH
	DD	049cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_multiply_decimal
	DD	01cH
	DD	0389H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_divide_decimal
	DD	01bH
	DD	0364H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_compare_decimal
	DD	01bH
	DD	02ccH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_add_decimal
	DD	01dH
	DD	0394H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_test_decimal
	DD	018H
	DD	0174H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_store_decimal
	DD	020H
	DD	015dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_decimal
	DD	021H
	DD	01bfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_zero_and_add
	DD	01bH
	DD	0255H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_subtract_decimal
	DD	01dH
	DD	037cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_shift_and_round_decimal
	DD	01bH
	DD	0482H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_multiply_decimal
	DD	01cH
	DD	036fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_divide_decimal
	DD	01bH
	DD	034aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_decimal
	DD	01bH
	DD	02b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_add_decimal
	DD	01dH
	DD	037aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_test_decimal
	DD	018H
	DD	016aH
voltbl	ENDS
xdata	SEGMENT
$unwind$packed_to_binary DD 011701H
	DD	06217H
$unwind$binary_to_packed DD 031001H
	DD	0700c2210H
	DD	0600bH
$unwind$s370_test_decimal DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s370_add_decimal DD 042519H
	DD	01f0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$s370_compare_decimal DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$s370_divide_decimal DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$s370_edit_x_edit_and_mark DD 021101H
	DD	0110111H
$unwind$s370_multiply_decimal DD 032419H
	DD	01e0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$s370_shift_and_round_decimal DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$s370_subtract_decimal DD 042519H
	DD	01f0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$s370_zero_and_add DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$add_decimal DD 011801H
	DD	02218H
$unwind$subtract_decimal DD 021901H
	DD	070159219H
$unwind$divide_decimal DD 041c01H
	DD	011011cH
	DD	060147015H
$unwind$s370_load_decimal DD 022619H
	DD	07013d217H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s370_store_decimal DD 012519H
	DD	0c216H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s390_test_decimal DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s390_add_decimal DD 042519H
	DD	01f0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$s390_compare_decimal DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$s390_divide_decimal DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$s390_edit_x_edit_and_mark DD 021101H
	DD	0110111H
$unwind$s390_multiply_decimal DD 032419H
	DD	01e0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$s390_shift_and_round_decimal DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$s390_subtract_decimal DD 042519H
	DD	01f0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$s390_zero_and_add DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s390_load_decimal DD 022619H
	DD	07013d217H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$s390_store_decimal DD 012519H
	DD	0c216H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$z900_test_decimal DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_add_decimal DD 042519H
	DD	0210113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$z900_compare_decimal DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_divide_decimal DD 022319H
	DD	0250111H
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$z900_edit_x_edit_and_mark DD 021101H
	DD	0130111H
$unwind$z900_multiply_decimal DD 032419H
	DD	0200112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$z900_shift_and_round_decimal DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_subtract_decimal DD 042519H
	DD	0210113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$z900_zero_and_add DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_load_decimal DD 022719H
	DD	07014d218H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_store_decimal DD 012619H
	DD	0c217H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 48
j$ = 52
tv136 = 56
pack$ = 64
__$ArrayPad$ = 88
addr$ = 112
len$ = 120
arn$ = 128
regs$ = 136
dec$ = 144
sign$ = 152
z900_store_decimal PROC

; 668  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 669  : int     i, j;                           /* Array subscripts          */
; 670  : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 671  : 
; 672  :     /* if operand crosses page, make sure both pages are accessible */
; 673  :     if((addr & PAGEFRAME_PAGEMASK) !=

  00026	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00031	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR len$[rsp]
  00036	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  0003b	48 03 d1	 add	 rdx, rcx
  0003e	48 8b ca	 mov	 rcx, rdx
  00041	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00048	48 3b c1	 cmp	 rax, rcx
  0004b	74 29		 je	 SHORT $LN5@z900_store

; 674  :         ((addr + len) & PAGEFRAME_PAGEMASK))
; 675  :         ARCH_DEP(validate_operand) (addr, arn, len, ACCTYPE_WRITE_SKP, regs);

  0004d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00055	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00060	44 8b 44 24 78	 mov	 r8d, DWORD PTR len$[rsp]
  00065	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR arn$[rsp]
  0006c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  00071	e8 00 00 00 00	 call	 z900_validate_operand
$LN5@z900_store:

; 676  : 
; 677  :     /* Pack digits into packed decimal work area */
; 678  :     for (i=0, j=0; i < MAX_DECIMAL_DIGITS; i++)

  00076	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00086	eb 0a		 jmp	 SHORT $LN4@z900_store
$LN2@z900_store:
  00088	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0008c	ff c0		 inc	 eax
  0008e	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_store:
  00092	83 7c 24 30 1f	 cmp	 DWORD PTR i$[rsp], 31
  00097	7d 5c		 jge	 SHORT $LN3@z900_store

; 679  :     {
; 680  :         if (i & 1)

  00099	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0009d	83 e0 01	 and	 eax, 1
  000a0	85 c0		 test	 eax, eax
  000a2	74 32		 je	 SHORT $LN6@z900_store

; 681  :             pack[j++] |= dec[i];

  000a4	48 63 44 24 34	 movsxd	 rax, DWORD PTR j$[rsp]
  000a9	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ae	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dec$[rsp]
  000b6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ba	0f b6 44 04 40	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000bf	0b c1		 or	 eax, ecx
  000c1	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000c6	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al
  000ca	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  000ce	ff c0		 inc	 eax
  000d0	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
  000d4	eb 1d		 jmp	 SHORT $LN7@z900_store
$LN6@z900_store:

; 682  :         else
; 683  :             pack[j] = dec[i] << 4;

  000d6	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000db	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dec$[rsp]
  000e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e7	c1 e0 04	 shl	 eax, 4
  000ea	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000ef	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al
$LN7@z900_store:

; 684  :     } /* end for */

  000f3	eb 93		 jmp	 SHORT $LN2@z900_store
$LN3@z900_store:

; 685  : 
; 686  :     /* Pack the sign into low-order digit of work area */
; 687  :     pack[MAX_DECIMAL_LENGTH-1] |= (sign < 0 ? 0x0D : 0x0C);

  000f5	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR sign$[rsp], 0
  000fd	7d 0a		 jge	 SHORT $LN9@z900_store
  000ff	c7 44 24 38 0d
	00 00 00	 mov	 DWORD PTR tv136[rsp], 13
  00107	eb 08		 jmp	 SHORT $LN10@z900_store
$LN9@z900_store:
  00109	c7 44 24 38 0c
	00 00 00	 mov	 DWORD PTR tv136[rsp], 12
$LN10@z900_store:
  00111	b8 01 00 00 00	 mov	 eax, 1
  00116	48 6b c0 0f	 imul	 rax, rax, 15
  0011a	0f b6 44 04 40	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  0011f	0b 44 24 38	 or	 eax, DWORD PTR tv136[rsp]
  00123	b9 01 00 00 00	 mov	 ecx, 1
  00128	48 6b c9 0f	 imul	 rcx, rcx, 15
  0012c	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al

; 688  : 
; 689  :     /* Store the result at the operand location */
; 690  :     ARCH_DEP(vstorec) (pack+sizeof(pack)-len-1, len, addr, arn, regs);

  00130	48 8d 44 24 50	 lea	 rax, QWORD PTR pack$[rsp+16]
  00135	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR len$[rsp]
  0013a	48 2b c1	 sub	 rax, rcx
  0013d	48 ff c8	 dec	 rax
  00140	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0014d	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR arn$[rsp]
  00155	4c 8b 44 24 70	 mov	 r8, QWORD PTR addr$[rsp]
  0015a	0f b6 54 24 78	 movzx	 edx, BYTE PTR len$[rsp]
  0015f	48 8b c8	 mov	 rcx, rax
  00162	e8 00 00 00 00	 call	 z900_vstorec

; 691  : 
; 692  : } /* end function ARCH_DEP(store_decimal) */

  00167	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016c	48 33 cc	 xor	 rcx, rsp
  0016f	e8 00 00 00 00	 call	 __security_check_cookie
  00174	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00178	c3		 ret	 0
z900_store_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
h$ = 48
i$ = 52
j$ = 56
n$ = 60
tv144 = 64
pack$ = 72
__$ArrayPad$ = 96
addr$ = 128
len$ = 136
arn$ = 144
regs$ = 152
result$ = 160
count$ = 168
sign$ = 176
z900_load_decimal PROC

; 596  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 597  : int     h;                              /* Hexadecimal digit         */
; 598  : int     i, j;                           /* Array subscripts          */
; 599  : int     n;                              /* Significant digit counter */
; 600  : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 601  : 
; 602  :     /* Fetch the packed decimal operand into work area */
; 603  :     memset( pack, 0, sizeof(pack) );

  00027	48 8d 44 24 48	 lea	 rax, QWORD PTR pack$[rsp]
  0002c	48 8b f8	 mov	 rdi, rax
  0002f	33 c0		 xor	 eax, eax
  00031	b9 10 00 00 00	 mov	 ecx, 16
  00036	f3 aa		 rep stosb

; 604  :     ARCH_DEP(vfetchc) (pack+sizeof(pack)-len-1, len, addr, arn, regs);

  00038	48 8d 44 24 58	 lea	 rax, QWORD PTR pack$[rsp+16]
  0003d	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR len$[rsp]
  00045	48 2b c1	 sub	 rax, rcx
  00048	48 ff c8	 dec	 rax
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00058	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR arn$[rsp]
  00060	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR addr$[rsp]
  00068	0f b6 94 24 88
	00 00 00	 movzx	 edx, BYTE PTR len$[rsp]
  00070	48 8b c8	 mov	 rcx, rax
  00073	e8 00 00 00 00	 call	 z900_vfetchc

; 605  : 
; 606  :     /* Unpack digits into result */
; 607  :     for (i=0, j=0, n=0; i < MAX_DECIMAL_DIGITS; i++)

  00078	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00080	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00088	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00090	eb 0a		 jmp	 SHORT $LN4@z900_load_
$LN2@z900_load_:
  00092	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00096	ff c0		 inc	 eax
  00098	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_load_:
  0009c	83 7c 24 34 1f	 cmp	 DWORD PTR i$[rsp], 31
  000a1	0f 8d 9b 00 00
	00		 jge	 $LN3@z900_load_

; 608  :     {
; 609  :         /* Load source digit */
; 610  :         if (i & 1)

  000a7	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  000ab	83 e0 01	 and	 eax, 1
  000ae	85 c0		 test	 eax, eax
  000b0	74 1d		 je	 SHORT $LN5@z900_load_

; 611  :             h = pack[j++] & 0x0F;

  000b2	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  000b7	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000bc	83 e0 0f	 and	 eax, 15
  000bf	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax
  000c3	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000c7	ff c0		 inc	 eax
  000c9	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
  000cd	eb 11		 jmp	 SHORT $LN6@z900_load_
$LN5@z900_load_:

; 612  :         else
; 613  :             h = pack[j] >> 4;

  000cf	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  000d4	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000d9	c1 f8 04	 sar	 eax, 4
  000dc	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax
$LN6@z900_load_:

; 614  : 
; 615  :         /* Check for valid numeric */
; 616  :         if (h > 9)

  000e0	83 7c 24 30 09	 cmp	 DWORD PTR h$[rsp], 9
  000e5	7e 29		 jle	 SHORT $LN7@z900_load_

; 617  :         {
; 618  :             regs->dxc = DXC_DECIMAL;

  000e7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 619  :             ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  000f9	ba 07 00 00 00	 mov	 edx, 7
  000fe	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00106	e8 00 00 00 00	 call	 z900_program_interrupt

; 620  :             return;

  0010b	e9 b0 00 00 00	 jmp	 $LN1@z900_load_
$LN7@z900_load_:

; 621  :         }
; 622  : 
; 623  :         /* Count significant digits */
; 624  :         if (n > 0 || h != 0)

  00110	83 7c 24 3c 00	 cmp	 DWORD PTR n$[rsp], 0
  00115	7f 07		 jg	 SHORT $LN9@z900_load_
  00117	83 7c 24 30 00	 cmp	 DWORD PTR h$[rsp], 0
  0011c	74 0a		 je	 SHORT $LN8@z900_load_
$LN9@z900_load_:

; 625  :             n++;

  0011e	8b 44 24 3c	 mov	 eax, DWORD PTR n$[rsp]
  00122	ff c0		 inc	 eax
  00124	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax
$LN8@z900_load_:

; 626  : 
; 627  :         /* Store decimal digit in result */
; 628  :         result[i] = h;

  00128	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  0012d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00135	0f b6 54 24 30	 movzx	 edx, BYTE PTR h$[rsp]
  0013a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 629  : 
; 630  :     } /* end for */

  0013d	e9 50 ff ff ff	 jmp	 $LN2@z900_load_
$LN3@z900_load_:

; 631  : 
; 632  :     /* Check for valid sign */
; 633  :     h = pack[MAX_DECIMAL_LENGTH-1] & 0x0F;

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	48 6b c0 0f	 imul	 rax, rax, 15
  0014b	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  00150	83 e0 0f	 and	 eax, 15
  00153	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax

; 634  :     if (h < 0x0A)

  00157	83 7c 24 30 0a	 cmp	 DWORD PTR h$[rsp], 10
  0015c	7d 26		 jge	 SHORT $LN10@z900_load_

; 635  :     {
; 636  :         regs->dxc = DXC_DECIMAL;

  0015e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 637  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00170	ba 07 00 00 00	 mov	 edx, 7
  00175	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	e8 00 00 00 00	 call	 z900_program_interrupt

; 638  :         return;

  00182	eb 3c		 jmp	 SHORT $LN1@z900_load_
$LN10@z900_load_:

; 639  :     }
; 640  : 
; 641  :     /* Set number of significant digits */
; 642  :     *count = n;

  00184	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR count$[rsp]
  0018c	8b 4c 24 3c	 mov	 ecx, DWORD PTR n$[rsp]
  00190	89 08		 mov	 DWORD PTR [rax], ecx

; 643  : 
; 644  :     /* Set sign of operand */
; 645  :     *sign = (h == 0x0B || h == 0x0D) ? -1 : 1;

  00192	83 7c 24 30 0b	 cmp	 DWORD PTR h$[rsp], 11
  00197	74 11		 je	 SHORT $LN12@z900_load_
  00199	83 7c 24 30 0d	 cmp	 DWORD PTR h$[rsp], 13
  0019e	74 0a		 je	 SHORT $LN12@z900_load_
  001a0	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
  001a8	eb 08		 jmp	 SHORT $LN13@z900_load_
$LN12@z900_load_:
  001aa	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR tv144[rsp], -1
$LN13@z900_load_:
  001b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  001ba	8b 4c 24 40	 mov	 ecx, DWORD PTR tv144[rsp]
  001be	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@z900_load_:

; 646  : 
; 647  : } /* end function ARCH_DEP(load_decimal) */

  001c0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c5	48 33 cc	 xor	 rcx, rsp
  001c8	e8 00 00 00 00	 call	 __security_check_cookie
  001cd	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001d1	5f		 pop	 rdi
  001d2	c3		 ret	 0
z900_load_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchb
_TEXT	SEGMENT
mn$ = 48
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetchb PROC					; COMDAT

; 667  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );
; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00027	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0003b	e8 00 00 00 00	 call	 z900_maddr_l
  00040	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0004d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00051	c3		 ret	 0
z900_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l
  00045	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004f	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00054	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
z900_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck2
_TEXT	SEGMENT
tv81 = 32
tv131 = 40
tv150 = 48
tv181 = 56
tv166 = 64
regs$ = 96
x2$ = 104
b2$ = 112
z900_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 ba 01 00
	00		 jne	 $LN3@z900_per3_
  0001c	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00021	75 54		 jne	 SHORT $LN4@z900_per3_
  00023	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  00028	74 4d		 je	 SHORT $LN4@z900_per3_
  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $LN8@z900_per3_
  0003c	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0004e	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
  00053	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  00055	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
$LN9@z900_per3_:
  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv81[rsp], 0
  00071	0f 84 5f 01 00
	00		 je	 $LN3@z900_per3_
$LN4@z900_per3_:
  00077	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007c	75 54		 jne	 SHORT $LN5@z900_per3_
  0007e	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 4d		 je	 SHORT $LN5@z900_per3_
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 19		 je	 SHORT $LN10@z900_per3_
  00097	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a9	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  000ae	eb 16		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  000b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c1	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
$LN11@z900_per3_:
  000c6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv131[rsp], 0
  000cc	0f 84 04 01 00
	00		 je	 $LN3@z900_per3_
$LN5@z900_per3_:
  000d2	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  000d7	0f 84 03 01 00
	00		 je	 $LN2@z900_per3_
  000dd	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  000e2	0f 84 f8 00 00
	00		 je	 $LN2@z900_per3_
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 e4 00 00
	00		 jne	 $LN6@z900_per3_
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 19		 je	 SHORT $LN12@z900_per3_
  00104	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
  0011b	eb 16		 jmp	 SHORT $LN13@z900_per3_
$LN12@z900_per3_:
  0011d	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0012e	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
$LN13@z900_per3_:
  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv150[rsp], 0
  00139	0f 84 97 00 00
	00		 je	 $LN6@z900_per3_
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 19		 je	 SHORT $LN14@z900_per3_
  00151	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00163	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
  00168	eb 16		 jmp	 SHORT $LN15@z900_per3_
$LN14@z900_per3_:
  0016a	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
$LN15@z900_per3_:
  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	74 19		 je	 SHORT $LN16@z900_per3_
  00192	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001a4	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
  001a9	eb 16		 jmp	 SHORT $LN17@z900_per3_
$LN16@z900_per3_:
  001ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001bc	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
$LN17@z900_per3_:
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv181[rsp]
  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv166[rsp]
  001cb	48 03 c8	 add	 rcx, rax
  001ce	48 8b c1	 mov	 rax, rcx
  001d1	48 85 c0	 test	 rax, rax
  001d4	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN6@z900_per3_:
$LN3@z900_per3_:

; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );

  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 777  : #else
; 778  :     UNREFERENCED( regs );
; 779  :     UNREFERENCED( x2 );
; 780  :     UNREFERENCED( b2 );
; 781  : #endif
; 782  : }

  001e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e4	c3		 ret	 0
z900_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
temp$1 = 64
b2$ = 68
b1$ = 72
count$ = 76
sign$ = 80
cc$ = 84
tv166 = 88
tv167 = 92
l1$ = 96
effective_addr2$ = 104
effective_addr1$ = 112
l2$ = 120
dec$ = 128
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_zero_and_add PROC

; 1341 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1342 : int     l1, l2;                         /* Length values             */
; 1343 : int     b1, b2;                         /* Base register numbers     */
; 1344 : VADR    effective_addr1,
; 1345 :         effective_addr2;                /* Effective addresses       */
; 1346 : int     cc;                             /* Condition code            */
; 1347 : BYTE    dec[MAX_DECIMAL_DIGITS];        /* Work area for operand     */
; 1348 : int     count;                          /* Significant digit counter */
; 1349 : int     sign;                           /* Sign                      */
; 1350 : 
; 1351 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	8b c0		 mov	 eax, eax
  0004d	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00052	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00060	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00064	c1 e8 10	 shr	 eax, 16
  00067	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006c	8b c0		 mov	 eax, eax
  0006e	48 89 44 24 70	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00073	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00077	c1 e8 1c	 shr	 eax, 28
  0007a	83 e0 0f	 and	 eax, 15
  0007d	89 44 24 48	 mov	 DWORD PTR b1$[rsp], eax
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00092	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00096	83 e0 0f	 and	 eax, 15
  00099	89 44 24 78	 mov	 DWORD PTR l2$[rsp], eax
  0009d	b8 01 00 00 00	 mov	 eax, 1
  000a2	48 6b c0 01	 imul	 rax, rax, 1
  000a6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000ae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b2	c1 f8 04	 sar	 eax, 4
  000b5	83 e0 0f	 and	 eax, 15
  000b8	89 44 24 60	 mov	 DWORD PTR l1$[rsp], eax
  000bc	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  000c1	74 44		 je	 SHORT $LN8@z900_zero_
  000c3	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000dd	48 03 c8	 add	 rcx, rax
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 89 44 24 70	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000e8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000fc	48 23 c8	 and	 rcx, rax
  000ff	48 8b c1	 mov	 rax, rcx
  00102	48 89 44 24 70	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_zero_:
  00107	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  0010c	74 44		 je	 SHORT $LN9@z900_zero_
  0010e	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  00113	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00123	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00128	48 03 c8	 add	 rcx, rax
  0012b	48 8b c1	 mov	 rax, rcx
  0012e	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00133	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00142	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	48 23 c8	 and	 rcx, rax
  0014a	48 8b c1	 mov	 rax, rcx
  0014d	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_zero_:
$LN4@z900_zero_:
  00152	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0015e	48 83 c0 06	 add	 rax, 6
  00162	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016e	33 c0		 xor	 eax, eax
  00170	83 f8 06	 cmp	 eax, 6
  00173	74 0f		 je	 SHORT $LN10@z900_zero_
  00175	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_zero_:
  00184	33 c0		 xor	 eax, eax
  00186	85 c0		 test	 eax, eax
  00188	75 c8		 jne	 SHORT $LN4@z900_zero_

; 1352 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  0018a	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  0018f	8b 54 24 48	 mov	 edx, DWORD PTR b1$[rsp]
  00193	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_zero_:

; 1353 :     TXFC_INSTR_CHECK( regs );

  001a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001af	85 c0		 test	 eax, eax
  001b1	74 3f		 je	 SHORT $LN11@z900_zero_
  001b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001c1	0f ba e8 0f	 bts	 eax, 15
  001c5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193831
  001da	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001e0	ba 02 00 00 00	 mov	 edx, 2
  001e5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_zero_:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	75 a8		 jne	 SHORT $LN7@z900_zero_

; 1354 : 
; 1355 :     /* Load second operand into work area */
; 1356 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec, &count, &sign);

  001f8	48 8d 44 24 50	 lea	 rax, QWORD PTR sign$[rsp]
  001fd	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00202	48 8d 44 24 4c	 lea	 rax, QWORD PTR count$[rsp]
  00207	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0020c	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec$[rsp]
  00214	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00219	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00221	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  00226	8b 54 24 78	 mov	 edx, DWORD PTR l2$[rsp]
  0022a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_load_decimal

; 1357 : 
; 1358 :     /* Set condition code */
; 1359 :     cc = (count == 0) ? 0 : (sign < 1) ? 1 : 2;

  00234	83 7c 24 4c 00	 cmp	 DWORD PTR count$[rsp], 0
  00239	75 0a		 jne	 SHORT $LN18@z900_zero_
  0023b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
  00243	eb 21		 jmp	 SHORT $LN19@z900_zero_
$LN18@z900_zero_:
  00245	83 7c 24 50 01	 cmp	 DWORD PTR sign$[rsp], 1
  0024a	7d 0a		 jge	 SHORT $LN16@z900_zero_
  0024c	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  00254	eb 08		 jmp	 SHORT $LN17@z900_zero_
$LN16@z900_zero_:
  00256	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv166[rsp], 2
$LN17@z900_zero_:
  0025e	8b 44 24 58	 mov	 eax, DWORD PTR tv166[rsp]
  00262	89 44 24 5c	 mov	 DWORD PTR tv167[rsp], eax
$LN19@z900_zero_:
  00266	8b 44 24 5c	 mov	 eax, DWORD PTR tv167[rsp]
  0026a	89 44 24 54	 mov	 DWORD PTR cc$[rsp], eax

; 1360 : 
; 1361 :     /* Overflow if result exceeds first operand length */
; 1362 :     if (count > (l1+1) * 2 - 1)

  0026e	8b 44 24 60	 mov	 eax, DWORD PTR l1$[rsp]
  00272	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  00276	39 44 24 4c	 cmp	 DWORD PTR count$[rsp], eax
  0027a	7e 08		 jle	 SHORT $LN12@z900_zero_

; 1363 :         cc = 3;

  0027c	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN12@z900_zero_:

; 1364 : 
; 1365 :     /* Set positive sign if result is zero */
; 1366 :     if (count == 0)

  00284	83 7c 24 4c 00	 cmp	 DWORD PTR count$[rsp], 0
  00289	75 08		 jne	 SHORT $LN13@z900_zero_

; 1367 :         sign = +1;

  0028b	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN13@z900_zero_:

; 1368 : 
; 1369 :     /* Store result into first operand location */
; 1370 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec, sign);

  00293	8b 44 24 50	 mov	 eax, DWORD PTR sign$[rsp]
  00297	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0029b	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec$[rsp]
  002a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a8	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002b0	44 8b 44 24 48	 mov	 r8d, DWORD PTR b1$[rsp]
  002b5	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  002b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  002be	e8 00 00 00 00	 call	 z900_store_decimal

; 1371 : 
; 1372 :     /* Return condition code */
; 1373 :     regs->psw.cc = cc;

  002c3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cb	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR cc$[rsp]
  002d0	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1374 : 
; 1375 :     /* Program check if overflow and PSW program mask is set */
; 1376 :     if (cc == 3 && DOMASK(&regs->psw))

  002d3	83 7c 24 54 03	 cmp	 DWORD PTR cc$[rsp], 3
  002d8	75 25		 jne	 SHORT $LN14@z900_zero_
  002da	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e2	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  002e6	83 e0 04	 and	 eax, 4
  002e9	85 c0		 test	 eax, eax
  002eb	74 12		 je	 SHORT $LN14@z900_zero_

; 1377 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  002ed	ba 0a 00 00 00	 mov	 edx, 10
  002f2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fa	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_zero_:

; 1378 : 
; 1379 : } /* end DEF_INST(zero_and_add) */

  002ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00307	48 33 cc	 xor	 rcx, rsp
  0030a	e8 00 00 00 00	 call	 __security_check_cookie
  0030f	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00316	c3		 ret	 0
z900_zero_and_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sign3$ = 64
count3$ = 68
b1$ = 72
temp$1 = 76
b2$ = 80
sign1$ = 84
l1$ = 88
cc$ = 92
effective_addr1$ = 96
count1$ = 104
count2$ = 108
sign2$ = 112
tv202 = 116
tv203 = 120
effective_addr2$ = 128
l2$ = 136
dec3$ = 144
dec2$ = 176
dec1$ = 208
__$ArrayPad$ = 240
inst$ = 288
regs$ = 296
z900_subtract_decimal PROC

; 1265 : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1266 : int     l1, l2;                         /* Length values             */
; 1267 : int     b1, b2;                         /* Base register numbers     */
; 1268 : VADR    effective_addr1,
; 1269 :         effective_addr2;                /* Effective addresses       */
; 1270 : int     cc;                             /* Condition code            */
; 1271 : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 1272 : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 1273 : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 1274 : int     count1, count2, count3;         /* Significant digit counters*/
; 1275 : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 1276 : 
; 1277 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00025	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002d	48 83 c0 02	 add	 rax, 2
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 fetch_fw_noswap
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 _byteswap_ulong
  00040	89 44 24 4c	 mov	 DWORD PTR temp$1[rsp], eax
  00044	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	8b c0		 mov	 eax, eax
  0004f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00057	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	c1 e8 0c	 shr	 eax, 12
  0005e	83 e0 0f	 and	 eax, 15
  00061	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00065	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00069	c1 e8 10	 shr	 eax, 16
  0006c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00071	8b c0		 mov	 eax, eax
  00073	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00078	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 1c	 shr	 eax, 28
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 48	 mov	 DWORD PTR b1$[rsp], eax
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 01	 imul	 rax, rax, 1
  0008f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00097	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009b	83 e0 0f	 and	 eax, 15
  0009e	89 84 24 88 00
	00 00		 mov	 DWORD PTR l2$[rsp], eax
  000a5	b8 01 00 00 00	 mov	 eax, 1
  000aa	48 6b c0 01	 imul	 rax, rax, 1
  000ae	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ba	c1 f8 04	 sar	 eax, 4
  000bd	83 e0 0f	 and	 eax, 15
  000c0	89 44 24 58	 mov	 DWORD PTR l1$[rsp], eax
  000c4	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  000c9	74 44		 je	 SHORT $LN8@z900_subtr
  000cb	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  000d0	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000e5	48 03 c8	 add	 rcx, rax
  000e8	48 8b c1	 mov	 rax, rcx
  000eb	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000f0	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ff	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00104	48 23 c8	 and	 rcx, rax
  00107	48 8b c1	 mov	 rax, rcx
  0010a	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_subtr:
  0010f	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00114	74 50		 je	 SHORT $LN9@z900_subtr
  00116	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  0011b	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0012b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00133	48 03 c8	 add	 rcx, rax
  00136	48 8b c1	 mov	 rax, rcx
  00139	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00141	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00150	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00158	48 23 c8	 and	 rcx, rax
  0015b	48 8b c1	 mov	 rax, rcx
  0015e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_subtr:
$LN4@z900_subtr:
  00166	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00172	48 83 c0 06	 add	 rax, 6
  00176	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00182	33 c0		 xor	 eax, eax
  00184	83 f8 06	 cmp	 eax, 6
  00187	74 0f		 je	 SHORT $LN10@z900_subtr
  00189	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_subtr:
  00198	33 c0		 xor	 eax, eax
  0019a	85 c0		 test	 eax, eax
  0019c	75 c8		 jne	 SHORT $LN4@z900_subtr

; 1278 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  0019e	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  001a3	8b 54 24 48	 mov	 edx, DWORD PTR b1$[rsp]
  001a7	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001af	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_subtr:

; 1279 :     TXFC_INSTR_CHECK( regs );

  001b4	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001c3	85 c0		 test	 eax, eax
  001c5	74 3f		 je	 SHORT $LN11@z900_subtr
  001c7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001d5	0f ba e8 0f	 bts	 eax, 15
  001d9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001e7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193793
  001ee	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001f4	ba 02 00 00 00	 mov	 edx, 2
  001f9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_subtr:
  00206	33 c0		 xor	 eax, eax
  00208	85 c0		 test	 eax, eax
  0020a	75 a8		 jne	 SHORT $LN7@z900_subtr

; 1280 : 
; 1281 :     /* Load operands into work areas */
; 1282 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  0020c	48 8d 44 24 54	 lea	 rax, QWORD PTR sign1$[rsp]
  00211	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00216	48 8d 44 24 68	 lea	 rax, QWORD PTR count1$[rsp]
  0021b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00220	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00228	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022d	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00235	44 8b 44 24 48	 mov	 r8d, DWORD PTR b1$[rsp]
  0023a	8b 54 24 58	 mov	 edx, DWORD PTR l1$[rsp]
  0023e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00243	e8 00 00 00 00	 call	 z900_load_decimal

; 1283 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  00248	48 8d 44 24 70	 lea	 rax, QWORD PTR sign2$[rsp]
  0024d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00252	48 8d 44 24 6c	 lea	 rax, QWORD PTR count2$[rsp]
  00257	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025c	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  00264	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00269	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00271	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  00276	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR l2$[rsp]
  0027d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00285	e8 00 00 00 00	 call	 z900_load_decimal

; 1284 : 
; 1285 :     /* Add or subtract operand values */
; 1286 :     if (count2 == 0)

  0028a	83 7c 24 6c 00	 cmp	 DWORD PTR count2$[rsp], 0
  0028f	75 32		 jne	 SHORT $LN12@z900_subtr

; 1287 :     {
; 1288 :         /* If second operand is zero then result is first operand */
; 1289 :         memcpy (dec3, dec1, MAX_DECIMAL_DIGITS);

  00291	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00299	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  002a1	48 8b f8	 mov	 rdi, rax
  002a4	48 8b f1	 mov	 rsi, rcx
  002a7	b9 1f 00 00 00	 mov	 ecx, 31
  002ac	f3 a4		 rep movsb

; 1290 :         count3 = count1;

  002ae	8b 44 24 68	 mov	 eax, DWORD PTR count1$[rsp]
  002b2	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 1291 :         sign3 = sign1;

  002b6	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  002ba	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1292 :     }

  002be	e9 ab 00 00 00	 jmp	 $LN13@z900_subtr
$LN12@z900_subtr:

; 1293 :     else if (count1 == 0)

  002c3	83 7c 24 68 00	 cmp	 DWORD PTR count1$[rsp], 0
  002c8	75 31		 jne	 SHORT $LN14@z900_subtr

; 1294 :     {
; 1295 :         /* If first operand is zero then result is -second operand */
; 1296 :         memcpy (dec3, dec2, MAX_DECIMAL_DIGITS);

  002ca	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  002d2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR dec2$[rsp]
  002da	48 8b f8	 mov	 rdi, rax
  002dd	48 8b f1	 mov	 rsi, rcx
  002e0	b9 1f 00 00 00	 mov	 ecx, 31
  002e5	f3 a4		 rep movsb

; 1297 :         count3 = count2;

  002e7	8b 44 24 6c	 mov	 eax, DWORD PTR count2$[rsp]
  002eb	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 1298 :         sign3 = -sign2;

  002ef	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  002f3	f7 d8		 neg	 eax
  002f5	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1299 :     }

  002f9	eb 73		 jmp	 SHORT $LN15@z900_subtr
$LN14@z900_subtr:

; 1300 :     else if (sign1 != sign2)

  002fb	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  002ff	39 44 24 54	 cmp	 DWORD PTR sign1$[rsp], eax
  00303	74 2c		 je	 SHORT $LN16@z900_subtr

; 1301 :     {
; 1302 :         /* If signs are opposite then add operands */
; 1303 :         add_decimal (dec1, dec2, dec3, &count3);

  00305	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  0030a	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  00312	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  0031a	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00322	e8 00 00 00 00	 call	 add_decimal

; 1304 :         sign3 = sign1;

  00327	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  0032b	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1305 :     }

  0032f	eb 3d		 jmp	 SHORT $LN17@z900_subtr
$LN16@z900_subtr:

; 1306 :     else
; 1307 :     {
; 1308 :         /* If signs are equal then subtract operands */
; 1309 :         subtract_decimal (dec1, dec2, dec3, &count3, &sign3);

  00331	48 8d 44 24 40	 lea	 rax, QWORD PTR sign3$[rsp]
  00336	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033b	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  00340	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  00348	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  00350	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00358	e8 00 00 00 00	 call	 subtract_decimal

; 1310 :         if (sign1 < 0) sign3 = -sign3;

  0035d	83 7c 24 54 00	 cmp	 DWORD PTR sign1$[rsp], 0
  00362	7d 0a		 jge	 SHORT $LN18@z900_subtr
  00364	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  00368	f7 d8		 neg	 eax
  0036a	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax
$LN18@z900_subtr:
$LN17@z900_subtr:
$LN15@z900_subtr:
$LN13@z900_subtr:

; 1311 :     }
; 1312 : 
; 1313 :     /* Set condition code */
; 1314 :     cc = (count3 == 0) ? 0 : (sign3 < 1) ? 1 : 2;

  0036e	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  00373	75 0a		 jne	 SHORT $LN25@z900_subtr
  00375	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv203[rsp], 0
  0037d	eb 21		 jmp	 SHORT $LN26@z900_subtr
$LN25@z900_subtr:
  0037f	83 7c 24 40 01	 cmp	 DWORD PTR sign3$[rsp], 1
  00384	7d 0a		 jge	 SHORT $LN23@z900_subtr
  00386	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  0038e	eb 08		 jmp	 SHORT $LN24@z900_subtr
$LN23@z900_subtr:
  00390	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv202[rsp], 2
$LN24@z900_subtr:
  00398	8b 44 24 74	 mov	 eax, DWORD PTR tv202[rsp]
  0039c	89 44 24 78	 mov	 DWORD PTR tv203[rsp], eax
$LN26@z900_subtr:
  003a0	8b 44 24 78	 mov	 eax, DWORD PTR tv203[rsp]
  003a4	89 44 24 5c	 mov	 DWORD PTR cc$[rsp], eax

; 1315 : 
; 1316 :     /* Overflow if result exceeds first operand length */
; 1317 :     if (count3 > (l1+1) * 2 - 1)

  003a8	8b 44 24 58	 mov	 eax, DWORD PTR l1$[rsp]
  003ac	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  003b0	39 44 24 44	 cmp	 DWORD PTR count3$[rsp], eax
  003b4	7e 08		 jle	 SHORT $LN19@z900_subtr

; 1318 :         cc = 3;

  003b6	c7 44 24 5c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN19@z900_subtr:

; 1319 : 
; 1320 :     /* Set positive sign if result is zero */
; 1321 :     if (count3 == 0)

  003be	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  003c3	75 08		 jne	 SHORT $LN20@z900_subtr

; 1322 :         sign3 = 1;

  003c5	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR sign3$[rsp], 1
$LN20@z900_subtr:

; 1323 : 
; 1324 :     /* Store result into first operand location */
; 1325 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  003cd	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  003d1	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003d5	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  003dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e2	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003ea	44 8b 44 24 48	 mov	 r8d, DWORD PTR b1$[rsp]
  003ef	8b 54 24 58	 mov	 edx, DWORD PTR l1$[rsp]
  003f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  003f8	e8 00 00 00 00	 call	 z900_store_decimal

; 1326 : 
; 1327 :     /* Return condition code */
; 1328 :     regs->psw.cc = cc;

  003fd	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00405	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR cc$[rsp]
  0040a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1329 : 
; 1330 :     /* Program check if overflow and PSW program mask is set */
; 1331 :     if (cc == 3 && DOMASK(&regs->psw))

  0040d	83 7c 24 5c 03	 cmp	 DWORD PTR cc$[rsp], 3
  00412	75 25		 jne	 SHORT $LN21@z900_subtr
  00414	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041c	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00420	83 e0 04	 and	 eax, 4
  00423	85 c0		 test	 eax, eax
  00425	74 12		 je	 SHORT $LN21@z900_subtr

; 1332 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  00427	ba 0a 00 00 00	 mov	 edx, 10
  0042c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00434	e8 00 00 00 00	 call	 z900_program_interrupt
$LN21@z900_subtr:

; 1333 : 
; 1334 : } /* end DEF_INST(subtract_decimal) */

  00439	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00441	48 33 cc	 xor	 rcx, rsp
  00444	e8 00 00 00 00	 call	 __security_check_cookie
  00449	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00450	5f		 pop	 rdi
  00451	5e		 pop	 rsi
  00452	c3		 ret	 0
z900_subtract_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 64
j$ = 68
d$ = 72
effective_addr2$ = 80
count$ = 88
b1$ = 92
cc$ = 96
temp$1 = 100
sign$ = 104
l1$ = 108
effective_addr1$ = 112
b2$ = 120
tv171 = 124
tv172 = 128
tv191 = 132
i3$ = 136
tv201 = 140
tv212 = 144
carry$ = 148
tv223 = 152
tv224 = 156
dec$ = 160
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_shift_and_round_decimal PROC

; 1168 : {

$LN40:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1169 : int     l1, i3;                         /* Length and rounding       */
; 1170 : int     b1, b2;                         /* Base register numbers     */
; 1171 : VADR    effective_addr1,
; 1172 :         effective_addr2;                /* Effective addresses       */
; 1173 : int     cc;                             /* Condition code            */
; 1174 : BYTE    dec[MAX_DECIMAL_DIGITS];        /* Work area for operand     */
; 1175 : int     count;                          /* Significant digit counter */
; 1176 : int     sign;                           /* Sign of operand/result    */
; 1177 : int     i, j;                           /* Array subscripts          */
; 1178 : int     d;                              /* Decimal digit             */
; 1179 : int     carry;                          /* Carry indicator           */
; 1180 : 
; 1181 :     SS(inst, regs, l1, i3, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 64	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 64	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	8b c0		 mov	 eax, eax
  0004d	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00052	8b 44 24 64	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 78	 mov	 DWORD PTR b2$[rsp], eax
  00060	8b 44 24 64	 mov	 eax, DWORD PTR temp$1[rsp]
  00064	c1 e8 10	 shr	 eax, 16
  00067	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006c	8b c0		 mov	 eax, eax
  0006e	48 89 44 24 70	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00073	8b 44 24 64	 mov	 eax, DWORD PTR temp$1[rsp]
  00077	c1 e8 1c	 shr	 eax, 28
  0007a	83 e0 0f	 and	 eax, 15
  0007d	89 44 24 5c	 mov	 DWORD PTR b1$[rsp], eax
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00092	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00096	83 e0 0f	 and	 eax, 15
  00099	89 84 24 88 00
	00 00		 mov	 DWORD PTR i3$[rsp], eax
  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	48 6b c0 01	 imul	 rax, rax, 1
  000a9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000b1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b5	c1 f8 04	 sar	 eax, 4
  000b8	83 e0 0f	 and	 eax, 15
  000bb	89 44 24 6c	 mov	 DWORD PTR l1$[rsp], eax
  000bf	83 7c 24 5c 00	 cmp	 DWORD PTR b1$[rsp], 0
  000c4	74 44		 je	 SHORT $LN14@z900_shift
  000c6	48 63 44 24 5c	 movsxd	 rax, DWORD PTR b1$[rsp]
  000cb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000e0	48 03 c8	 add	 rcx, rax
  000e3	48 8b c1	 mov	 rax, rcx
  000e6	48 89 44 24 70	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000eb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000ff	48 23 c8	 and	 rcx, rax
  00102	48 8b c1	 mov	 rax, rcx
  00105	48 89 44 24 70	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN14@z900_shift:
  0010a	83 7c 24 78 00	 cmp	 DWORD PTR b2$[rsp], 0
  0010f	74 44		 je	 SHORT $LN15@z900_shift
  00111	48 63 44 24 78	 movsxd	 rax, DWORD PTR b2$[rsp]
  00116	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00126	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0012b	48 03 c8	 add	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00136	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00145	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014a	48 23 c8	 and	 rcx, rax
  0014d	48 8b c1	 mov	 rax, rcx
  00150	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN15@z900_shift:
$LN4@z900_shift:
  00155	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00161	48 83 c0 06	 add	 rax, 6
  00165	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00171	33 c0		 xor	 eax, eax
  00173	83 f8 06	 cmp	 eax, 6
  00176	74 0f		 je	 SHORT $LN16@z900_shift
  00178	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@z900_shift:
  00187	33 c0		 xor	 eax, eax
  00189	85 c0		 test	 eax, eax
  0018b	75 c8		 jne	 SHORT $LN4@z900_shift

; 1182 :     PER_ZEROADDR_XCHECK( regs, b1 );

  0018d	8b 54 24 5c	 mov	 edx, DWORD PTR b1$[rsp]
  00191	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_shift:

; 1183 :     TXFC_INSTR_CHECK( regs );

  0019e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001ad	85 c0		 test	 eax, eax
  001af	74 3f		 je	 SHORT $LN17@z900_shift
  001b1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001bf	0f ba e8 0f	 bts	 eax, 15
  001c3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001d1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193752
  001d8	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001de	ba 02 00 00 00	 mov	 edx, 2
  001e3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	e8 00 00 00 00	 call	 z900_abort_transaction
$LN17@z900_shift:
  001f0	33 c0		 xor	 eax, eax
  001f2	85 c0		 test	 eax, eax
  001f4	75 a8		 jne	 SHORT $LN7@z900_shift

; 1184 : 
; 1185 :     /* Load operand into work area */
; 1186 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec, &count, &sign);

  001f6	48 8d 44 24 68	 lea	 rax, QWORD PTR sign$[rsp]
  001fb	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00200	48 8d 44 24 58	 lea	 rax, QWORD PTR count$[rsp]
  00205	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0020a	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec$[rsp]
  00212	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00217	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0021f	44 8b 44 24 5c	 mov	 r8d, DWORD PTR b1$[rsp]
  00224	8b 54 24 6c	 mov	 edx, DWORD PTR l1$[rsp]
  00228	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0022d	e8 00 00 00 00	 call	 z900_load_decimal

; 1187 : 
; 1188 :     /* Program check if rounding digit is invalid */
; 1189 :     if (i3 > 9)

  00232	83 bc 24 88 00
	00 00 09	 cmp	 DWORD PTR i3$[rsp], 9
  0023a	7e 24		 jle	 SHORT $LN18@z900_shift

; 1190 :     {
; 1191 :         regs->dxc = DXC_DECIMAL;

  0023c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00244	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1192 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0024e	ba 07 00 00 00	 mov	 edx, 7
  00253	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN18@z900_shift:

; 1193 :     }
; 1194 : 
; 1195 :     /* Isolate low-order six bits of shift count */
; 1196 :     effective_addr2 &= 0x3F;

  00260	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00265	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  00269	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax

; 1197 : 
; 1198 :     /* Shift count 0-31 means shift left, 32-63 means shift right */
; 1199 :     if (effective_addr2 < 32)

  0026e	48 83 7c 24 50
	20		 cmp	 QWORD PTR effective_addr2$[rsp], 32 ; 00000020H
  00274	0f 83 d7 00 00
	00		 jae	 $LN19@z900_shift

; 1200 :     {
; 1201 :         /* Set condition code according to operand sign */
; 1202 :         cc = (count == 0) ? 0 : (sign < 0) ? 1 : 2;

  0027a	83 7c 24 58 00	 cmp	 DWORD PTR count$[rsp], 0
  0027f	75 0d		 jne	 SHORT $LN28@z900_shift
  00281	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv172[rsp], 0
  0028c	eb 24		 jmp	 SHORT $LN29@z900_shift
$LN28@z900_shift:
  0028e	83 7c 24 68 00	 cmp	 DWORD PTR sign$[rsp], 0
  00293	7d 0a		 jge	 SHORT $LN26@z900_shift
  00295	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  0029d	eb 08		 jmp	 SHORT $LN27@z900_shift
$LN26@z900_shift:
  0029f	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR tv171[rsp], 2
$LN27@z900_shift:
  002a7	8b 44 24 7c	 mov	 eax, DWORD PTR tv171[rsp]
  002ab	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv172[rsp], eax
$LN29@z900_shift:
  002b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv172[rsp]
  002b9	89 44 24 60	 mov	 DWORD PTR cc$[rsp], eax

; 1203 : 
; 1204 :         /* Set cc=3 if non-zero digits will be lost on left shift */
; 1205 :         if (count > 0 && effective_addr2 > (VADR)((l1+1)*2 - 1 - count))

  002bd	83 7c 24 58 00	 cmp	 DWORD PTR count$[rsp], 0
  002c2	7e 1d		 jle	 SHORT $LN21@z900_shift
  002c4	8b 44 24 6c	 mov	 eax, DWORD PTR l1$[rsp]
  002c8	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  002cc	2b 44 24 58	 sub	 eax, DWORD PTR count$[rsp]
  002d0	48 98		 cdqe
  002d2	48 39 44 24 50	 cmp	 QWORD PTR effective_addr2$[rsp], rax
  002d7	76 08		 jbe	 SHORT $LN21@z900_shift

; 1206 :             cc = 3;

  002d9	c7 44 24 60 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN21@z900_shift:

; 1207 : 
; 1208 :         /* Shift operand left */
; 1209 :         for (i=0, j=effective_addr2; i < MAX_DECIMAL_DIGITS; i++, j++)

  002e1	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002e9	8b 44 24 50	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  002ed	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
  002f1	eb 14		 jmp	 SHORT $LN10@z900_shift
$LN8@z900_shift:
  002f3	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  002f7	ff c0		 inc	 eax
  002f9	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  002fd	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  00301	ff c0		 inc	 eax
  00303	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN10@z900_shift:
  00307	83 7c 24 40 1f	 cmp	 DWORD PTR i$[rsp], 31
  0030c	7d 3e		 jge	 SHORT $LN9@z900_shift

; 1210 :             dec[i] = (j < MAX_DECIMAL_DIGITS) ? dec[j] : 0;

  0030e	83 7c 24 44 1f	 cmp	 DWORD PTR j$[rsp], 31
  00313	7d 16		 jge	 SHORT $LN30@z900_shift
  00315	48 63 44 24 44	 movsxd	 rax, DWORD PTR j$[rsp]
  0031a	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  00322	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv191[rsp], eax
  00329	eb 0b		 jmp	 SHORT $LN31@z900_shift
$LN30@z900_shift:
  0032b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv191[rsp], 0
$LN31@z900_shift:
  00336	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0033b	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR tv191[rsp]
  00343	88 8c 04 a0 00
	00 00		 mov	 BYTE PTR dec$[rsp+rax], cl
  0034a	eb a7		 jmp	 SHORT $LN8@z900_shift
$LN9@z900_shift:

; 1211 :     }

  0034c	e9 7a 01 00 00	 jmp	 $LN20@z900_shift
$LN19@z900_shift:

; 1212 :     else
; 1213 :     {
; 1214 :         /* Calculate number of digits (1-32) to shift right */
; 1215 :         effective_addr2 = 64 - effective_addr2;

  00351	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00356	48 2b 44 24 50	 sub	 rax, QWORD PTR effective_addr2$[rsp]
  0035b	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax

; 1216 : 
; 1217 :         /* Add the rounding digit to the leftmost of the digits
; 1218 :            to be shifted out and propagate the carry to the left */
; 1219 :         carry = (effective_addr2 > MAX_DECIMAL_DIGITS) ? 0 :

  00360	48 83 7c 24 50
	1f		 cmp	 QWORD PTR effective_addr2$[rsp], 31
  00366	76 0d		 jbe	 SHORT $LN32@z900_shift
  00368	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv201[rsp], 0
  00373	eb 28		 jmp	 SHORT $LN33@z900_shift
$LN32@z900_shift:
  00375	b8 1f 00 00 00	 mov	 eax, 31
  0037a	48 2b 44 24 50	 sub	 rax, QWORD PTR effective_addr2$[rsp]
  0037f	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  00387	03 84 24 88 00
	00 00		 add	 eax, DWORD PTR i3$[rsp]
  0038e	99		 cdq
  0038f	b9 0a 00 00 00	 mov	 ecx, 10
  00394	f7 f9		 idiv	 ecx
  00396	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv201[rsp], eax
$LN33@z900_shift:
  0039d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv201[rsp]
  003a4	89 84 24 94 00
	00 00		 mov	 DWORD PTR carry$[rsp], eax

; 1220 :                 (dec[MAX_DECIMAL_DIGITS - effective_addr2] + i3) / 10;
; 1221 :         count = 0;

  003ab	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0

; 1222 : 
; 1223 :         /* Shift operand right */
; 1224 :         for (i=MAX_DECIMAL_DIGITS-1, j=MAX_DECIMAL_DIGITS-1-effective_addr2;

  003b3	c7 44 24 40 1e
	00 00 00	 mov	 DWORD PTR i$[rsp], 30
  003bb	b8 1e 00 00 00	 mov	 eax, 30
  003c0	48 2b 44 24 50	 sub	 rax, QWORD PTR effective_addr2$[rsp]
  003c5	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
  003c9	eb 14		 jmp	 SHORT $LN13@z900_shift
$LN11@z900_shift:

; 1225 :                 i >= 0; i--, j--)

  003cb	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  003cf	ff c8		 dec	 eax
  003d1	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  003d5	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  003d9	ff c8		 dec	 eax
  003db	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN13@z900_shift:
  003df	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  003e4	0f 8c 95 00 00
	00		 jl	 $LN12@z900_shift

; 1226 :         {
; 1227 :             d = (j >= 0) ? dec[j] : 0;

  003ea	83 7c 24 44 00	 cmp	 DWORD PTR j$[rsp], 0
  003ef	7c 16		 jl	 SHORT $LN34@z900_shift
  003f1	48 63 44 24 44	 movsxd	 rax, DWORD PTR j$[rsp]
  003f6	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  003fe	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
  00405	eb 0b		 jmp	 SHORT $LN35@z900_shift
$LN34@z900_shift:
  00407	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN35@z900_shift:
  00412	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv212[rsp]
  00419	89 44 24 48	 mov	 DWORD PTR d$[rsp], eax

; 1228 :             d += carry;

  0041d	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR carry$[rsp]
  00424	8b 4c 24 48	 mov	 ecx, DWORD PTR d$[rsp]
  00428	03 c8		 add	 ecx, eax
  0042a	8b c1		 mov	 eax, ecx
  0042c	89 44 24 48	 mov	 DWORD PTR d$[rsp], eax

; 1229 :             carry = d / 10;

  00430	8b 44 24 48	 mov	 eax, DWORD PTR d$[rsp]
  00434	99		 cdq
  00435	b9 0a 00 00 00	 mov	 ecx, 10
  0043a	f7 f9		 idiv	 ecx
  0043c	89 84 24 94 00
	00 00		 mov	 DWORD PTR carry$[rsp], eax

; 1230 :             d %= 10;

  00443	8b 44 24 48	 mov	 eax, DWORD PTR d$[rsp]
  00447	99		 cdq
  00448	b9 0a 00 00 00	 mov	 ecx, 10
  0044d	f7 f9		 idiv	 ecx
  0044f	8b c2		 mov	 eax, edx
  00451	89 44 24 48	 mov	 DWORD PTR d$[rsp], eax

; 1231 :             dec[i] = d;

  00455	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0045a	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR d$[rsp]
  0045f	88 8c 04 a0 00
	00 00		 mov	 BYTE PTR dec$[rsp+rax], cl

; 1232 :             if (d != 0)

  00466	83 7c 24 48 00	 cmp	 DWORD PTR d$[rsp], 0
  0046b	74 0d		 je	 SHORT $LN22@z900_shift

; 1233 :                 count = MAX_DECIMAL_DIGITS - i;

  0046d	b8 1f 00 00 00	 mov	 eax, 31
  00472	2b 44 24 40	 sub	 eax, DWORD PTR i$[rsp]
  00476	89 44 24 58	 mov	 DWORD PTR count$[rsp], eax
$LN22@z900_shift:

; 1234 :         }

  0047a	e9 4c ff ff ff	 jmp	 $LN11@z900_shift
$LN12@z900_shift:

; 1235 : 
; 1236 :         /* Set condition code according to operand sign */
; 1237 :         cc = (count == 0) ? 0 : (sign < 0) ? 1 : 2;

  0047f	83 7c 24 58 00	 cmp	 DWORD PTR count$[rsp], 0
  00484	75 0d		 jne	 SHORT $LN38@z900_shift
  00486	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv224[rsp], 0
  00491	eb 2d		 jmp	 SHORT $LN39@z900_shift
$LN38@z900_shift:
  00493	83 7c 24 68 00	 cmp	 DWORD PTR sign$[rsp], 0
  00498	7d 0d		 jge	 SHORT $LN36@z900_shift
  0049a	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv223[rsp], 1
  004a5	eb 0b		 jmp	 SHORT $LN37@z900_shift
$LN36@z900_shift:
  004a7	c7 84 24 98 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv223[rsp], 2
$LN37@z900_shift:
  004b2	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv223[rsp]
  004b9	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
$LN39@z900_shift:
  004c0	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv224[rsp]
  004c7	89 44 24 60	 mov	 DWORD PTR cc$[rsp], eax
$LN20@z900_shift:

; 1238 :     }
; 1239 : 
; 1240 :     /* Make sign positive if result is zero */
; 1241 :     if (cc == 0)

  004cb	83 7c 24 60 00	 cmp	 DWORD PTR cc$[rsp], 0
  004d0	75 08		 jne	 SHORT $LN23@z900_shift

; 1242 :         sign = +1;

  004d2	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN23@z900_shift:

; 1243 : 
; 1244 :     /* Store result into operand location */
; 1245 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec, sign);

  004da	8b 44 24 68	 mov	 eax, DWORD PTR sign$[rsp]
  004de	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  004e2	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec$[rsp]
  004ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ef	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004f7	44 8b 44 24 5c	 mov	 r8d, DWORD PTR b1$[rsp]
  004fc	8b 54 24 6c	 mov	 edx, DWORD PTR l1$[rsp]
  00500	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00505	e8 00 00 00 00	 call	 z900_store_decimal

; 1246 : 
; 1247 :     /* Set condition code */
; 1248 :     regs->psw.cc = cc;

  0050a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00512	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR cc$[rsp]
  00517	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1249 : 
; 1250 :     /* Program check if overflow and PSW program mask is set */
; 1251 :     if (cc == 3 && DOMASK(&regs->psw))

  0051a	83 7c 24 60 03	 cmp	 DWORD PTR cc$[rsp], 3
  0051f	75 25		 jne	 SHORT $LN24@z900_shift
  00521	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00529	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  0052d	83 e0 04	 and	 eax, 4
  00530	85 c0		 test	 eax, eax
  00532	74 12		 je	 SHORT $LN24@z900_shift

; 1252 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  00534	ba 0a 00 00 00	 mov	 edx, 10
  00539	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00541	e8 00 00 00 00	 call	 z900_program_interrupt
$LN24@z900_shift:

; 1253 : 
; 1254 : } /* end DEF_INST(shift_and_round_decimal) */

  00546	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0054e	48 33 cc	 xor	 rcx, rsp
  00551	e8 00 00 00 00	 call	 __security_check_cookie
  00556	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0055d	c3		 ret	 0
z900_shift_and_round_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i2$ = 64
i3$ = 68
b1$ = 72
temp$1 = 76
b2$ = 80
l2$ = 84
l1$ = 88
i1$ = 92
effective_addr1$ = 96
d$ = 104
carry$ = 108
tv218 = 112
effective_addr2$ = 120
count1$ = 128
sign2$ = 132
sign1$ = 136
sign3$ = 140
count2$ = 144
dec3$ = 152
dec2$ = 184
dec1$ = 216
__$ArrayPad$ = 248
inst$ = 272
regs$ = 280
z900_multiply_decimal PROC

; 1096 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1097 : int     l1, l2;                         /* Length values             */
; 1098 : int     b1, b2;                         /* Base register numbers     */
; 1099 : VADR    effective_addr1,
; 1100 :         effective_addr2;                /* Effective addresses       */
; 1101 : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 1102 : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 1103 : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 1104 : int     count1, count2;                 /* Significant digit counters*/
; 1105 : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 1106 : int     d;                              /* Decimal digit             */
; 1107 : int     i1, i2, i3;                     /* Array subscripts          */
; 1108 : int     carry;                          /* Carry indicator           */
; 1109 : 
; 1110 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00024	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002c	48 83 c0 02	 add	 rax, 2
  00030	48 8b c8	 mov	 rcx, rax
  00033	e8 00 00 00 00	 call	 fetch_fw_noswap
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 _byteswap_ulong
  0003f	89 44 24 4c	 mov	 DWORD PTR temp$1[rsp], eax
  00043	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	8b c0		 mov	 eax, eax
  0004e	48 89 44 24 78	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00053	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 0c	 shr	 eax, 12
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00061	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 10	 shr	 eax, 16
  00068	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006d	8b c0		 mov	 eax, eax
  0006f	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00074	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00078	c1 e8 1c	 shr	 eax, 28
  0007b	83 e0 0f	 and	 eax, 15
  0007e	89 44 24 48	 mov	 DWORD PTR b1$[rsp], eax
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 01	 imul	 rax, rax, 1
  0008b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00093	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00097	83 e0 0f	 and	 eax, 15
  0009a	89 44 24 54	 mov	 DWORD PTR l2$[rsp], eax
  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	48 6b c0 01	 imul	 rax, rax, 1
  000a7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000af	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b3	c1 f8 04	 sar	 eax, 4
  000b6	83 e0 0f	 and	 eax, 15
  000b9	89 44 24 58	 mov	 DWORD PTR l1$[rsp], eax
  000bd	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  000c2	74 44		 je	 SHORT $LN14@z900_multi
  000c4	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c9	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000e9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000fd	48 23 c8	 and	 rcx, rax
  00100	48 8b c1	 mov	 rax, rcx
  00103	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN14@z900_multi:
  00108	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0010d	74 44		 je	 SHORT $LN15@z900_multi
  0010f	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00114	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00124	48 8b 4c 24 78	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 78	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00143	48 8b 4c 24 78	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00148	48 23 c8	 and	 rcx, rax
  0014b	48 8b c1	 mov	 rax, rcx
  0014e	48 89 44 24 78	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN15@z900_multi:
$LN4@z900_multi:
  00153	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0015f	48 83 c0 06	 add	 rax, 6
  00163	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016f	33 c0		 xor	 eax, eax
  00171	83 f8 06	 cmp	 eax, 6
  00174	74 0f		 je	 SHORT $LN16@z900_multi
  00176	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@z900_multi:
  00185	33 c0		 xor	 eax, eax
  00187	85 c0		 test	 eax, eax
  00189	75 c8		 jne	 SHORT $LN4@z900_multi

; 1111 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  0018b	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  00190	8b 54 24 48	 mov	 edx, DWORD PTR b1$[rsp]
  00194	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_multi:

; 1112 :     TXFC_INSTR_CHECK( regs );

  001a1	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001b0	85 c0		 test	 eax, eax
  001b2	74 3f		 je	 SHORT $LN17@z900_multi
  001b4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001c2	0f ba e8 0f	 bts	 eax, 15
  001c6	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001d4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193709
  001db	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001e1	ba 02 00 00 00	 mov	 edx, 2
  001e6	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ee	e8 00 00 00 00	 call	 z900_abort_transaction
$LN17@z900_multi:
  001f3	33 c0		 xor	 eax, eax
  001f5	85 c0		 test	 eax, eax
  001f7	75 a8		 jne	 SHORT $LN7@z900_multi

; 1113 : 
; 1114 :     /* Program check if the second operand length exceeds 15 digits
; 1115 :        or is equal to or greater than the first operand length */
; 1116 :     if (l2 > 7 || l2 >= l1)

  001f9	83 7c 24 54 07	 cmp	 DWORD PTR l2$[rsp], 7
  001fe	7f 0a		 jg	 SHORT $LN19@z900_multi
  00200	8b 44 24 58	 mov	 eax, DWORD PTR l1$[rsp]
  00204	39 44 24 54	 cmp	 DWORD PTR l2$[rsp], eax
  00208	7c 12		 jl	 SHORT $LN18@z900_multi
$LN19@z900_multi:

; 1117 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0020a	ba 06 00 00 00	 mov	 edx, 6
  0020f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00217	e8 00 00 00 00	 call	 z900_program_interrupt
$LN18@z900_multi:

; 1118 : 
; 1119 :     /* Load operands into work areas */
; 1120 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  0021c	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR sign1$[rsp]
  00224	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00229	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR count1$[rsp]
  00231	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00236	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  0023e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00243	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0024b	44 8b 44 24 48	 mov	 r8d, DWORD PTR b1$[rsp]
  00250	8b 54 24 58	 mov	 edx, DWORD PTR l1$[rsp]
  00254	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00259	e8 00 00 00 00	 call	 z900_load_decimal

; 1121 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  0025e	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR sign2$[rsp]
  00266	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0026b	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR count2$[rsp]
  00273	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00278	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  00280	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00285	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0028d	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  00292	8b 54 24 54	 mov	 edx, DWORD PTR l2$[rsp]
  00296	48 8b 4c 24 78	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0029b	e8 00 00 00 00	 call	 z900_load_decimal

; 1122 : 
; 1123 :     /* Program check if the number of bytes in the second operand
; 1124 :        is less than the number of bytes of high-order zeroes in the
; 1125 :        first operand; this ensures that overflow cannot occur */
; 1126 :     if (l2 > l1 - (count1/2 + 1))

  002a0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR count1$[rsp]
  002a7	99		 cdq
  002a8	2b c2		 sub	 eax, edx
  002aa	d1 f8		 sar	 eax, 1
  002ac	ff c0		 inc	 eax
  002ae	8b 4c 24 58	 mov	 ecx, DWORD PTR l1$[rsp]
  002b2	2b c8		 sub	 ecx, eax
  002b4	8b c1		 mov	 eax, ecx
  002b6	39 44 24 54	 cmp	 DWORD PTR l2$[rsp], eax
  002ba	7e 24		 jle	 SHORT $LN20@z900_multi

; 1127 :     {
; 1128 :         regs->dxc = DXC_DECIMAL;

  002bc	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c4	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1129 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002ce	ba 07 00 00 00	 mov	 edx, 7
  002d3	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	e8 00 00 00 00	 call	 z900_program_interrupt
$LN20@z900_multi:

; 1130 :     }
; 1131 : 
; 1132 :     /* Clear the result field */
; 1133 :     memset( dec3, 0, MAX_DECIMAL_DIGITS );

  002e0	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  002e8	48 8b f8	 mov	 rdi, rax
  002eb	33 c0		 xor	 eax, eax
  002ed	b9 1f 00 00 00	 mov	 ecx, 31
  002f2	f3 aa		 rep stosb

; 1134 : 
; 1135 :     /* Perform decimal multiplication */
; 1136 :     for (i2 = MAX_DECIMAL_DIGITS-1; i2 >= 0; i2--)

  002f4	c7 44 24 40 1e
	00 00 00	 mov	 DWORD PTR i2$[rsp], 30
  002fc	eb 0a		 jmp	 SHORT $LN10@z900_multi
$LN8@z900_multi:
  002fe	8b 44 24 40	 mov	 eax, DWORD PTR i2$[rsp]
  00302	ff c8		 dec	 eax
  00304	89 44 24 40	 mov	 DWORD PTR i2$[rsp], eax
$LN10@z900_multi:
  00308	83 7c 24 40 00	 cmp	 DWORD PTR i2$[rsp], 0
  0030d	0f 8c b3 00 00
	00		 jl	 $LN9@z900_multi

; 1137 :     {
; 1138 :         if (dec2[i2] != 0)

  00313	48 63 44 24 40	 movsxd	 rax, DWORD PTR i2$[rsp]
  00318	0f b6 84 04 b8
	00 00 00	 movzx	 eax, BYTE PTR dec2$[rsp+rax]
  00320	85 c0		 test	 eax, eax
  00322	0f 84 99 00 00
	00		 je	 $LN21@z900_multi

; 1139 :         {
; 1140 :             for (i1 = MAX_DECIMAL_DIGITS - 1, i3 = i2, carry = 0;

  00328	c7 44 24 5c 1e
	00 00 00	 mov	 DWORD PTR i1$[rsp], 30
  00330	8b 44 24 40	 mov	 eax, DWORD PTR i2$[rsp]
  00334	89 44 24 44	 mov	 DWORD PTR i3$[rsp], eax
  00338	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0
  00340	eb 14		 jmp	 SHORT $LN13@z900_multi
$LN11@z900_multi:

; 1141 :                         i3 >= 0; i1--, i3--)

  00342	8b 44 24 5c	 mov	 eax, DWORD PTR i1$[rsp]
  00346	ff c8		 dec	 eax
  00348	89 44 24 5c	 mov	 DWORD PTR i1$[rsp], eax
  0034c	8b 44 24 44	 mov	 eax, DWORD PTR i3$[rsp]
  00350	ff c8		 dec	 eax
  00352	89 44 24 44	 mov	 DWORD PTR i3$[rsp], eax
$LN13@z900_multi:
  00356	83 7c 24 44 00	 cmp	 DWORD PTR i3$[rsp], 0
  0035b	7c 64		 jl	 SHORT $LN12@z900_multi

; 1142 :             {
; 1143 :                 d = carry + dec1[i1]*dec2[i2] + dec3[i3];

  0035d	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i1$[rsp]
  00362	0f b6 84 04 d8
	00 00 00	 movzx	 eax, BYTE PTR dec1$[rsp+rax]
  0036a	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i2$[rsp]
  0036f	0f b6 8c 0c b8
	00 00 00	 movzx	 ecx, BYTE PTR dec2$[rsp+rcx]
  00377	0f af c1	 imul	 eax, ecx
  0037a	8b 4c 24 6c	 mov	 ecx, DWORD PTR carry$[rsp]
  0037e	03 c8		 add	 ecx, eax
  00380	8b c1		 mov	 eax, ecx
  00382	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR i3$[rsp]
  00387	0f b6 8c 0c 98
	00 00 00	 movzx	 ecx, BYTE PTR dec3$[rsp+rcx]
  0038f	03 c1		 add	 eax, ecx
  00391	89 44 24 68	 mov	 DWORD PTR d$[rsp], eax

; 1144 :                 dec3[i3] = d % 10;

  00395	8b 44 24 68	 mov	 eax, DWORD PTR d$[rsp]
  00399	99		 cdq
  0039a	b9 0a 00 00 00	 mov	 ecx, 10
  0039f	f7 f9		 idiv	 ecx
  003a1	8b c2		 mov	 eax, edx
  003a3	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR i3$[rsp]
  003a8	88 84 0c 98 00
	00 00		 mov	 BYTE PTR dec3$[rsp+rcx], al

; 1145 :                 carry = d / 10;

  003af	8b 44 24 68	 mov	 eax, DWORD PTR d$[rsp]
  003b3	99		 cdq
  003b4	b9 0a 00 00 00	 mov	 ecx, 10
  003b9	f7 f9		 idiv	 ecx
  003bb	89 44 24 6c	 mov	 DWORD PTR carry$[rsp], eax

; 1146 :             }

  003bf	eb 81		 jmp	 SHORT $LN11@z900_multi
$LN12@z900_multi:
$LN21@z900_multi:

; 1147 :         }
; 1148 :     } /* end for(i2) */

  003c1	e9 38 ff ff ff	 jmp	 $LN8@z900_multi
$LN9@z900_multi:

; 1149 : 
; 1150 :     /* Result is positive if operand signs are equal, and negative
; 1151 :        if operand signs are opposite, even if result is zero */
; 1152 :     sign3 = (sign1 == sign2) ? 1 : -1;

  003c6	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR sign2$[rsp]
  003cd	39 84 24 88 00
	00 00		 cmp	 DWORD PTR sign1$[rsp], eax
  003d4	75 0a		 jne	 SHORT $LN23@z900_multi
  003d6	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv218[rsp], 1
  003de	eb 08		 jmp	 SHORT $LN24@z900_multi
$LN23@z900_multi:
  003e0	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR tv218[rsp], -1
$LN24@z900_multi:
  003e8	8b 44 24 70	 mov	 eax, DWORD PTR tv218[rsp]
  003ec	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sign3$[rsp], eax

; 1153 : 
; 1154 :     /* Store result into first operand location */
; 1155 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  003f3	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sign3$[rsp]
  003fa	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003fe	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00406	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0040b	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00413	44 8b 44 24 48	 mov	 r8d, DWORD PTR b1$[rsp]
  00418	8b 54 24 58	 mov	 edx, DWORD PTR l1$[rsp]
  0041c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00421	e8 00 00 00 00	 call	 z900_store_decimal

; 1156 : 
; 1157 : } /* end DEF_INST(multiply_decimal) */

  00426	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0042e	48 33 cc	 xor	 rcx, rsp
  00431	e8 00 00 00 00	 call	 __security_check_cookie
  00436	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  0043d	5f		 pop	 rdi
  0043e	c3		 ret	 0
z900_multiply_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sbyte$ = 48
pbyte$ = 49
fbyte$ = 50
b1$ = 52
trial_run$ = 56
sig$ = 60
addr1$ = 64
rbyte$ = 72
h$ = 76
cc$ = 80
d$ = 84
temp$1 = 88
l$ = 92
i$ = 96
b2$ = 100
effective_addr1$ = 104
effective_addr2$ = 112
tv235 = 120
addr2$ = 128
inst$ = 160
regs$ = 168
z900_edit_x_edit_and_mark PROC

; 903  : {

$LN54:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 904  : int     l;                              /* Length value              */
; 905  : int     b1, b2;                         /* Base register numbers     */
; 906  : VADR    effective_addr1,
; 907  :         effective_addr2,                /* Effective addresses       */
; 908  :         addr1,
; 909  :         addr2;
; 910  : int     cc = 0;                         /* Condition code            */

  00011	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 911  : int     sig = 0;                        /* Significance indicator    */

  00019	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 912  : int     trial_run;                      /* 1=trial run               */
; 913  : int     i;                              /* Loop counter              */
; 914  : int     d;                              /* 1=Use right source digit  */
; 915  : int     h;                              /* Hexadecimal digit         */
; 916  : BYTE    sbyte;                          /* Source operand byte       */
; 917  : BYTE    fbyte;                          /* Fill byte                 */
; 918  : BYTE    pbyte;                          /* Pattern byte              */
; 919  : BYTE    rbyte;                          /* Result byte               */
; 920  : 
; 921  :     SS_L(inst, regs, l, b1, effective_addr1, b2, effective_addr2);

  00021	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00029	48 83 c0 02	 add	 rax, 2
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 fetch_fw_noswap
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 _byteswap_ulong
  0003c	89 44 24 58	 mov	 DWORD PTR temp$1[rsp], eax
  00040	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00049	8b c0		 mov	 eax, eax
  0004b	48 89 44 24 70	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00050	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 0c	 shr	 eax, 12
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 64	 mov	 DWORD PTR b2$[rsp], eax
  0005e	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 10	 shr	 eax, 16
  00065	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006a	8b c0		 mov	 eax, eax
  0006c	48 89 44 24 68	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00071	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00075	c1 e8 1c	 shr	 eax, 28
  00078	83 e0 0f	 and	 eax, 15
  0007b	89 44 24 34	 mov	 DWORD PTR b1$[rsp], eax
  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	48 6b c0 01	 imul	 rax, rax, 1
  00088	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00090	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00094	89 44 24 5c	 mov	 DWORD PTR l$[rsp], eax
  00098	83 7c 24 34 00	 cmp	 DWORD PTR b1$[rsp], 0
  0009d	74 44		 je	 SHORT $LN14@z900_edit_
  0009f	48 63 44 24 34	 movsxd	 rax, DWORD PTR b1$[rsp]
  000a4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000b9	48 03 c8	 add	 rcx, rax
  000bc	48 8b c1	 mov	 rax, rcx
  000bf	48 89 44 24 68	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000d8	48 23 c8	 and	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	48 89 44 24 68	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN14@z900_edit_:
  000e3	83 7c 24 64 00	 cmp	 DWORD PTR b2$[rsp], 0
  000e8	74 44		 je	 SHORT $LN15@z900_edit_
  000ea	48 63 44 24 64	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ef	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00104	48 03 c8	 add	 rcx, rax
  00107	48 8b c1	 mov	 rax, rcx
  0010a	48 89 44 24 70	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 70	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN15@z900_edit_:
$LN4@z900_edit_:
  0012e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0013a	48 83 c0 06	 add	 rax, 6
  0013e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00146	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014a	33 c0		 xor	 eax, eax
  0014c	83 f8 06	 cmp	 eax, 6
  0014f	74 0f		 je	 SHORT $LN16@z900_edit_
  00151	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@z900_edit_:
  00160	33 c0		 xor	 eax, eax
  00162	85 c0		 test	 eax, eax
  00164	75 c8		 jne	 SHORT $LN4@z900_edit_

; 922  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  00166	44 8b 44 24 64	 mov	 r8d, DWORD PTR b2$[rsp]
  0016b	8b 54 24 34	 mov	 edx, DWORD PTR b1$[rsp]
  0016f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_edit_:

; 923  :     TXFC_INSTR_CHECK( regs );

  0017c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00184	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0018b	85 c0		 test	 eax, eax
  0018d	74 3f		 je	 SHORT $LN17@z900_edit_
  0018f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00197	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0019d	0f ba e8 0f	 bts	 eax, 15
  001a1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001af	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193634
  001b6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001bc	ba 02 00 00 00	 mov	 edx, 2
  001c1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c9	e8 00 00 00 00	 call	 z900_abort_transaction
$LN17@z900_edit_:
  001ce	33 c0		 xor	 eax, eax
  001d0	85 c0		 test	 eax, eax
  001d2	75 a8		 jne	 SHORT $LN7@z900_edit_

; 924  : 
; 925  :     /* If addr1 crosses page, make sure both pages are accessible */
; 926  :     if((effective_addr1 & PAGEFRAME_PAGEMASK) !=

  001d4	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  001d9	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001df	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR l$[rsp]
  001e4	48 8b 54 24 68	 mov	 rdx, QWORD PTR effective_addr1$[rsp]
  001e9	48 03 d1	 add	 rdx, rcx
  001ec	48 8b ca	 mov	 rcx, rdx
  001ef	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  001f6	48 3b c1	 cmp	 rax, rcx
  001f9	74 26		 je	 SHORT $LN18@z900_edit_

; 927  :         ((effective_addr1 + l) & PAGEFRAME_PAGEMASK))
; 928  :         ARCH_DEP(validate_operand) (effective_addr1, b1, l, ACCTYPE_WRITE_SKP, regs);

  001fb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00203	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00208	41 b9 01 00 00
	00		 mov	 r9d, 1
  0020e	44 8b 44 24 5c	 mov	 r8d, DWORD PTR l$[rsp]
  00213	8b 54 24 34	 mov	 edx, DWORD PTR b1$[rsp]
  00217	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0021c	e8 00 00 00 00	 call	 z900_validate_operand
$LN18@z900_edit_:

; 929  : 
; 930  :     /* If addr2 might cross page, do a trial run to catch possible access rupts */
; 931  :     if((effective_addr2 & PAGEFRAME_PAGEMASK) !=

  00221	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00226	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0022c	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR l$[rsp]
  00231	48 8b 54 24 70	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00236	48 03 d1	 add	 rdx, rcx
  00239	48 8b ca	 mov	 rcx, rdx
  0023c	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00243	48 3b c1	 cmp	 rax, rcx
  00246	74 0a		 je	 SHORT $LN19@z900_edit_

; 932  :         ((effective_addr2 + l) & PAGEFRAME_PAGEMASK))
; 933  :         trial_run = 1;

  00248	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR trial_run$[rsp], 1
  00250	eb 08		 jmp	 SHORT $LN20@z900_edit_
$LN19@z900_edit_:

; 934  :     else
; 935  :         trial_run = 0;

  00252	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR trial_run$[rsp], 0
$LN20@z900_edit_:

; 936  : 
; 937  :     for(;trial_run >= 0; trial_run--)

  0025a	eb 0a		 jmp	 SHORT $LN10@z900_edit_
$LN8@z900_edit_:
  0025c	8b 44 24 38	 mov	 eax, DWORD PTR trial_run$[rsp]
  00260	ff c8		 dec	 eax
  00262	89 44 24 38	 mov	 DWORD PTR trial_run$[rsp], eax
$LN10@z900_edit_:
  00266	83 7c 24 38 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  0026b	0f 8c 5c 04 00
	00		 jl	 $LN9@z900_edit_

; 938  :     {
; 939  :         /* Initialize variables */
; 940  :         addr1 = effective_addr1;

  00271	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  00276	48 89 44 24 40	 mov	 QWORD PTR addr1$[rsp], rax

; 941  :         addr2 = effective_addr2;

  0027b	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00280	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax

; 942  :         cc = 0;

  00288	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 943  :         sig = 0;

  00290	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 944  :         sbyte = 0;

  00298	c6 44 24 30 00	 mov	 BYTE PTR sbyte$[rsp], 0

; 945  :         fbyte = 0;

  0029d	c6 44 24 32 00	 mov	 BYTE PTR fbyte$[rsp], 0

; 946  : 
; 947  :         /* Process first operand from left to right */
; 948  :         for (i = 0, d = 0; i < l+1; i++)

  002a2	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002aa	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
  002b2	eb 0a		 jmp	 SHORT $LN13@z900_edit_
$LN11@z900_edit_:
  002b4	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  002b8	ff c0		 inc	 eax
  002ba	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_edit_:
  002be	8b 44 24 5c	 mov	 eax, DWORD PTR l$[rsp]
  002c2	ff c0		 inc	 eax
  002c4	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  002c8	0f 8d fa 03 00
	00		 jge	 $LN12@z900_edit_

; 949  :         {
; 950  :             /* Fetch pattern byte from first operand */
; 951  :             pbyte = ARCH_DEP(vfetchb) ( addr1, b1, regs );

  002ce	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d6	8b 54 24 34	 mov	 edx, DWORD PTR b1$[rsp]
  002da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr1$[rsp]
  002df	e8 00 00 00 00	 call	 z900_vfetchb
  002e4	88 44 24 31	 mov	 BYTE PTR pbyte$[rsp], al

; 952  : 
; 953  :             /* The first pattern byte is also the fill byte */
; 954  :             if (i == 0) fbyte = pbyte;

  002e8	83 7c 24 60 00	 cmp	 DWORD PTR i$[rsp], 0
  002ed	75 09		 jne	 SHORT $LN21@z900_edit_
  002ef	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  002f4	88 44 24 32	 mov	 BYTE PTR fbyte$[rsp], al
$LN21@z900_edit_:

; 955  : 
; 956  :             /* If pattern byte is digit selector (X'20') or
; 957  :                significance starter (X'21') then fetch next
; 958  :                hexadecimal digit from the second operand */
; 959  :             if (pbyte == 0x20 || pbyte == 0x21)

  002f8	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  002fd	83 f8 20	 cmp	 eax, 32			; 00000020H
  00300	74 0e		 je	 SHORT $LN24@z900_edit_
  00302	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00307	83 f8 21	 cmp	 eax, 33			; 00000021H
  0030a	0f 85 84 02 00
	00		 jne	 $LN22@z900_edit_
$LN24@z900_edit_:

; 960  :             {
; 961  :                 if (d == 0)

  00310	83 7c 24 54 00	 cmp	 DWORD PTR d$[rsp], 0
  00315	0f 85 a2 00 00
	00		 jne	 $LN25@z900_edit_

; 962  :                 {
; 963  :                     /* Fetch source byte and extract left digit */
; 964  :                     sbyte = ARCH_DEP(vfetchb) ( addr2, b2, regs );

  0031b	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00323	8b 54 24 64	 mov	 edx, DWORD PTR b2$[rsp]
  00327	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  0032f	e8 00 00 00 00	 call	 z900_vfetchb
  00334	88 44 24 30	 mov	 BYTE PTR sbyte$[rsp], al

; 965  :                     h = sbyte >> 4;

  00338	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  0033d	c1 f8 04	 sar	 eax, 4
  00340	89 44 24 4c	 mov	 DWORD PTR h$[rsp], eax

; 966  :                     sbyte &= 0x0F;

  00344	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00349	83 e0 0f	 and	 eax, 15
  0034c	88 44 24 30	 mov	 BYTE PTR sbyte$[rsp], al

; 967  :                     d = 1;

  00350	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR d$[rsp], 1

; 968  : 
; 969  :                     /* Increment second operand address */
; 970  :                     addr2++;

  00358	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  00360	48 ff c0	 inc	 rax
  00363	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax

; 971  :                     addr2 &= ADDRESS_MAXWRAP(regs);

  0036b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00373	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0037a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  00382	48 23 c8	 and	 rcx, rax
  00385	48 8b c1	 mov	 rax, rcx
  00388	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax

; 972  : 
; 973  :                     /* Program check if left digit is not numeric */
; 974  :                     if (h > 9)

  00390	83 7c 24 4c 09	 cmp	 DWORD PTR h$[rsp], 9
  00395	7e 24		 jle	 SHORT $LN27@z900_edit_

; 975  :                     {
; 976  :                         regs->dxc = DXC_DECIMAL;

  00397	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039f	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 977  :                         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  003a9	ba 07 00 00 00	 mov	 edx, 7
  003ae	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b6	e8 00 00 00 00	 call	 z900_program_interrupt
$LN27@z900_edit_:

; 978  :                     }
; 979  : 
; 980  :                 }

  003bb	eb 11		 jmp	 SHORT $LN26@z900_edit_
$LN25@z900_edit_:

; 981  :                 else
; 982  :                 {
; 983  :                     /* Use right digit of source byte */
; 984  :                     h = sbyte;

  003bd	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  003c2	89 44 24 4c	 mov	 DWORD PTR h$[rsp], eax

; 985  :                     d = 0;

  003c6	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
$LN26@z900_edit_:

; 986  :                 }
; 987  : 
; 988  :                 /* For the EDMK instruction only, insert address of
; 989  :                    result byte into general register 1 if the digit
; 990  :                    is non-zero and significance indicator was off */
; 991  :                 if (!trial_run && (inst[0] == 0xDF) && h > 0 && sig == 0)

  003ce	83 7c 24 38 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  003d3	0f 85 e1 00 00
	00		 jne	 $LN28@z900_edit_
  003d9	b8 01 00 00 00	 mov	 eax, 1
  003de	48 6b c0 00	 imul	 rax, rax, 0
  003e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  003ea	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ee	3d df 00 00 00	 cmp	 eax, 223		; 000000dfH
  003f3	0f 85 c1 00 00
	00		 jne	 $LN28@z900_edit_
  003f9	83 7c 24 4c 00	 cmp	 DWORD PTR h$[rsp], 0
  003fe	0f 8e b6 00 00
	00		 jle	 $LN28@z900_edit_
  00404	83 7c 24 3c 00	 cmp	 DWORD PTR sig$[rsp], 0
  00409	0f 85 ab 00 00
	00		 jne	 $LN28@z900_edit_

; 992  :                 {
; 993  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 994  :                     if (regs->psw.amode64)

  0040f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00417	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0041d	83 e0 01	 and	 eax, 1
  00420	85 c0		 test	 eax, eax
  00422	74 20		 je	 SHORT $LN29@z900_edit_

; 995  :                         regs->GR_G(1) = addr1;

  00424	b8 08 00 00 00	 mov	 eax, 8
  00429	48 6b c0 01	 imul	 rax, rax, 1
  0042d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00435	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr1$[rsp]
  0043a	48 89 94 01 80
	02 00 00	 mov	 QWORD PTR [rcx+rax+640], rdx
  00442	eb 76		 jmp	 SHORT $LN30@z900_edit_
$LN29@z900_edit_:

; 996  :                     else
; 997  : #endif
; 998  :                     if ( regs->psw.amode )

  00444	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00452	d1 e8		 shr	 eax, 1
  00454	83 e0 01	 and	 eax, 1
  00457	85 c0		 test	 eax, eax
  00459	74 1e		 je	 SHORT $LN31@z900_edit_

; 999  :                         regs->GR_L(1) = addr1;

  0045b	b8 08 00 00 00	 mov	 eax, 8
  00460	48 6b c0 01	 imul	 rax, rax, 1
  00464	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046c	8b 54 24 40	 mov	 edx, DWORD PTR addr1$[rsp]
  00470	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
  00477	eb 41		 jmp	 SHORT $LN32@z900_edit_
$LN31@z900_edit_:

; 1000 :                     else
; 1001 :                         regs->GR_LA24(1) = addr1;

  00479	b8 08 00 00 00	 mov	 eax, 8
  0047e	48 6b c0 01	 imul	 rax, rax, 1
  00482	8b 4c 24 40	 mov	 ecx, DWORD PTR addr1$[rsp]
  00486	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0048c	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00494	8b 84 02 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+640]
  0049b	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  004a0	0b c1		 or	 eax, ecx
  004a2	b9 08 00 00 00	 mov	 ecx, 8
  004a7	48 6b c9 01	 imul	 rcx, rcx, 1
  004ab	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004b3	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax
$LN32@z900_edit_:
$LN30@z900_edit_:
$LN28@z900_edit_:

; 1002 :                 }
; 1003 : 
; 1004 :                 /* Replace the pattern byte by the fill character
; 1005 :                    or by a zoned decimal digit */
; 1006 :                 rbyte = (sig == 0 && h == 0) ? fbyte : (0xF0 | h);

  004ba	83 7c 24 3c 00	 cmp	 DWORD PTR sig$[rsp], 0
  004bf	75 12		 jne	 SHORT $LN52@z900_edit_
  004c1	83 7c 24 4c 00	 cmp	 DWORD PTR h$[rsp], 0
  004c6	75 0b		 jne	 SHORT $LN52@z900_edit_
  004c8	0f b6 44 24 32	 movzx	 eax, BYTE PTR fbyte$[rsp]
  004cd	89 44 24 78	 mov	 DWORD PTR tv235[rsp], eax
  004d1	eb 0d		 jmp	 SHORT $LN53@z900_edit_
$LN52@z900_edit_:
  004d3	8b 44 24 4c	 mov	 eax, DWORD PTR h$[rsp]
  004d7	0d f0 00 00 00	 or	 eax, 240		; 000000f0H
  004dc	89 44 24 78	 mov	 DWORD PTR tv235[rsp], eax
$LN53@z900_edit_:
  004e0	0f b6 44 24 78	 movzx	 eax, BYTE PTR tv235[rsp]
  004e5	88 44 24 48	 mov	 BYTE PTR rbyte$[rsp], al

; 1007 :                 if(!trial_run)

  004e9	83 7c 24 38 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  004ee	75 1e		 jne	 SHORT $LN33@z900_edit_

; 1008 :                     ARCH_DEP(vstoreb) ( rbyte, addr1, b1, regs );

  004f0	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004f8	44 8b 44 24 34	 mov	 r8d, DWORD PTR b1$[rsp]
  004fd	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr1$[rsp]
  00502	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR rbyte$[rsp]
  00507	e8 00 00 00 00	 call	 z900_vstoreb
  0050c	eb 24		 jmp	 SHORT $LN34@z900_edit_
$LN33@z900_edit_:

; 1009 :                 else
; 1010 :                     ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  0050e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00516	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0051b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00521	45 33 c0	 xor	 r8d, r8d
  00524	8b 54 24 34	 mov	 edx, DWORD PTR b1$[rsp]
  00528	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr1$[rsp]
  0052d	e8 00 00 00 00	 call	 z900_validate_operand
$LN34@z900_edit_:

; 1011 : 
; 1012 :                 /* Set condition code 2 if digit is non-zero */
; 1013 :                 if (h > 0) cc = 2;

  00532	83 7c 24 4c 00	 cmp	 DWORD PTR h$[rsp], 0
  00537	7e 08		 jle	 SHORT $LN35@z900_edit_
  00539	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN35@z900_edit_:

; 1014 : 
; 1015 :                 /* Turn on significance indicator if pattern
; 1016 :                    byte is significance starter or if source
; 1017 :                    digit is non-zero */
; 1018 :                 if (pbyte == 0x21 || h > 0)

  00541	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00546	83 f8 21	 cmp	 eax, 33			; 00000021H
  00549	74 07		 je	 SHORT $LN37@z900_edit_
  0054b	83 7c 24 4c 00	 cmp	 DWORD PTR h$[rsp], 0
  00550	7e 08		 jle	 SHORT $LN36@z900_edit_
$LN37@z900_edit_:

; 1019 :                     sig = 1;

  00552	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR sig$[rsp], 1
$LN36@z900_edit_:

; 1020 : 
; 1021 :                 /* Examine right digit for sign code */
; 1022 :                 if (d == 1 && sbyte > 9)

  0055a	83 7c 24 54 01	 cmp	 DWORD PTR d$[rsp], 1
  0055f	75 2e		 jne	 SHORT $LN38@z900_edit_
  00561	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00566	83 f8 09	 cmp	 eax, 9
  00569	7e 24		 jle	 SHORT $LN38@z900_edit_

; 1023 :                 {
; 1024 :                     /* Turn off the significance indicator if
; 1025 :                        the right digit is a plus sign code */
; 1026 :                     if (sbyte != 0x0B && sbyte != 0x0D)

  0056b	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00570	83 f8 0b	 cmp	 eax, 11
  00573	74 12		 je	 SHORT $LN39@z900_edit_
  00575	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  0057a	83 f8 0d	 cmp	 eax, 13
  0057d	74 08		 je	 SHORT $LN39@z900_edit_

; 1027 :                         sig = 0;

  0057f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0
$LN39@z900_edit_:

; 1028 : 
; 1029 :                     /* Take next digit from next source byte */
; 1030 :                     d = 0;

  00587	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
$LN38@z900_edit_:

; 1031 :                 }
; 1032 :             }

  0058f	e9 03 01 00 00	 jmp	 $LN23@z900_edit_
$LN22@z900_edit_:

; 1033 : 
; 1034 :             /* If pattern byte is field separator (X'22') then
; 1035 :                replace it by the fill character, turn off the
; 1036 :                significance indicator, and zeroize conditon code  */
; 1037 :             else if (pbyte == 0x22)

  00594	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00599	83 f8 22	 cmp	 eax, 34			; 00000022H
  0059c	75 5e		 jne	 SHORT $LN40@z900_edit_

; 1038 :             {
; 1039 :                 if(!trial_run)

  0059e	83 7c 24 38 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  005a3	75 1e		 jne	 SHORT $LN42@z900_edit_

; 1040 :                     ARCH_DEP(vstoreb) ( fbyte, addr1, b1, regs );

  005a5	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005ad	44 8b 44 24 34	 mov	 r8d, DWORD PTR b1$[rsp]
  005b2	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr1$[rsp]
  005b7	0f b6 4c 24 32	 movzx	 ecx, BYTE PTR fbyte$[rsp]
  005bc	e8 00 00 00 00	 call	 z900_vstoreb
  005c1	eb 24		 jmp	 SHORT $LN43@z900_edit_
$LN42@z900_edit_:

; 1041 :                 else
; 1042 :                     ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  005c3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005d0	41 b9 01 00 00
	00		 mov	 r9d, 1
  005d6	45 33 c0	 xor	 r8d, r8d
  005d9	8b 54 24 34	 mov	 edx, DWORD PTR b1$[rsp]
  005dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr1$[rsp]
  005e2	e8 00 00 00 00	 call	 z900_validate_operand
$LN43@z900_edit_:

; 1043 :                 sig = 0;

  005e7	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 1044 :                 cc = 0;

  005ef	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1045 :             }

  005f7	e9 9b 00 00 00	 jmp	 $LN41@z900_edit_
$LN40@z900_edit_:

; 1046 : 
; 1047 :             /* If pattern byte is a message byte (anything other
; 1048 :                than X'20', X'21', or X'22') then replace it by
; 1049 :                the fill byte if the significance indicator is off */
; 1050 :             else
; 1051 :             {
; 1052 :                 if (sig == 0)

  005fc	83 7c 24 3c 00	 cmp	 DWORD PTR sig$[rsp], 0
  00601	75 4b		 jne	 SHORT $LN44@z900_edit_

; 1053 :                 {
; 1054 :                     if (!trial_run)

  00603	83 7c 24 38 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  00608	75 1e		 jne	 SHORT $LN46@z900_edit_

; 1055 :                         ARCH_DEP(vstoreb) ( fbyte, addr1, b1, regs );

  0060a	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00612	44 8b 44 24 34	 mov	 r8d, DWORD PTR b1$[rsp]
  00617	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr1$[rsp]
  0061c	0f b6 4c 24 32	 movzx	 ecx, BYTE PTR fbyte$[rsp]
  00621	e8 00 00 00 00	 call	 z900_vstoreb
  00626	eb 24		 jmp	 SHORT $LN47@z900_edit_
$LN46@z900_edit_:

; 1056 :                     else
; 1057 :                         ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  00628	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00630	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00635	41 b9 01 00 00
	00		 mov	 r9d, 1
  0063b	45 33 c0	 xor	 r8d, r8d
  0063e	8b 54 24 34	 mov	 edx, DWORD PTR b1$[rsp]
  00642	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr1$[rsp]
  00647	e8 00 00 00 00	 call	 z900_validate_operand
$LN47@z900_edit_:

; 1058 :                 }

  0064c	eb 49		 jmp	 SHORT $LN45@z900_edit_
$LN44@z900_edit_:

; 1059 :                 else /* store message byte */
; 1060 :                 {
; 1061 :                     if (!trial_run)

  0064e	83 7c 24 38 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  00653	75 1e		 jne	 SHORT $LN48@z900_edit_

; 1062 :                         ARCH_DEP(vstoreb) ( pbyte, addr1, b1, regs );

  00655	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0065d	44 8b 44 24 34	 mov	 r8d, DWORD PTR b1$[rsp]
  00662	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr1$[rsp]
  00667	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR pbyte$[rsp]
  0066c	e8 00 00 00 00	 call	 z900_vstoreb
  00671	eb 24		 jmp	 SHORT $LN49@z900_edit_
$LN48@z900_edit_:

; 1063 :                     else
; 1064 :                         ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  00673	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00680	41 b9 01 00 00
	00		 mov	 r9d, 1
  00686	45 33 c0	 xor	 r8d, r8d
  00689	8b 54 24 34	 mov	 edx, DWORD PTR b1$[rsp]
  0068d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr1$[rsp]
  00692	e8 00 00 00 00	 call	 z900_validate_operand
$LN49@z900_edit_:
$LN45@z900_edit_:
$LN41@z900_edit_:
$LN23@z900_edit_:

; 1065 :                 }
; 1066 :             }
; 1067 : 
; 1068 :             /* Increment first operand address */
; 1069 :             addr1++;

  00697	48 8b 44 24 40	 mov	 rax, QWORD PTR addr1$[rsp]
  0069c	48 ff c0	 inc	 rax
  0069f	48 89 44 24 40	 mov	 QWORD PTR addr1$[rsp], rax

; 1070 :             addr1 &= ADDRESS_MAXWRAP(regs);

  006a4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ac	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  006b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr1$[rsp]
  006b8	48 23 c8	 and	 rcx, rax
  006bb	48 8b c1	 mov	 rax, rcx
  006be	48 89 44 24 40	 mov	 QWORD PTR addr1$[rsp], rax

; 1071 : 
; 1072 :         } /* end for(i) */

  006c3	e9 ec fb ff ff	 jmp	 $LN11@z900_edit_
$LN12@z900_edit_:

; 1073 : 
; 1074 :     } /* end for(trial_run) */

  006c8	e9 8f fb ff ff	 jmp	 $LN8@z900_edit_
$LN9@z900_edit_:

; 1075 : 
; 1076 :     /* Replace condition code 2 by condition code 1 if the
; 1077 :        significance indicator is on at the end of editing */
; 1078 :     if (sig && cc == 2) cc = 1;

  006cd	83 7c 24 3c 00	 cmp	 DWORD PTR sig$[rsp], 0
  006d2	74 0f		 je	 SHORT $LN50@z900_edit_
  006d4	83 7c 24 50 02	 cmp	 DWORD PTR cc$[rsp], 2
  006d9	75 08		 jne	 SHORT $LN50@z900_edit_
  006db	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1
$LN50@z900_edit_:

; 1079 : 
; 1080 :     /* Set condition code */
; 1081 :     regs->psw.cc = cc;

  006e3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006eb	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR cc$[rsp]
  006f0	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1082 : 
; 1083 : #if defined( FEATURE_PER1 )
; 1084 :     /* Check for PER 1 GRA event */
; 1085 :     if (inst[0] == 0xDF) // EDMK?
; 1086 :         PER_GRA_CHECK( regs, PER_GRA_MASK( 1 ));
; 1087 : #endif
; 1088 : 
; 1089 : } /* end DEF_INST(edit_x_edit_and_mark) */

  006f3	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  006fa	c3		 ret	 0
z900_edit_x_edit_and_mark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
l2$ = 64
b1$ = 68
l1$ = 72
temp$1 = 76
b2$ = 80
effective_addr1$ = 88
count2$ = 96
tv207 = 100
sign1$ = 104
effective_addr2$ = 112
count1$ = 120
sign2$ = 124
signr$ = 128
signq$ = 132
tv195 = 136
dec2$ = 144
dec1$ = 176
rem$ = 208
quot$ = 240
__$ArrayPad$ = 272
inst$ = 304
regs$ = 312
z900_divide_decimal PROC

; 834  : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 835  : int     l1, l2;                         /* Length values             */
; 836  : int     b1, b2;                         /* Base register numbers     */
; 837  : VADR    effective_addr1,
; 838  :         effective_addr2;                /* Effective addresses       */
; 839  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Operand 1 (dividend)      */
; 840  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Operand 2 (divisor)       */
; 841  : BYTE    quot[MAX_DECIMAL_DIGITS];       /* Quotient                  */
; 842  : BYTE    rem[MAX_DECIMAL_DIGITS];        /* Remainder                 */
; 843  : int     count1, count2;                 /* Significant digit counters*/
; 844  : int     sign1, sign2;                   /* Sign of operands          */
; 845  : int     signq, signr;                   /* Sign of quotient/remainder*/
; 846  : 
; 847  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 4c	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	8b c0		 mov	 eax, eax
  0004d	48 89 44 24 70	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00052	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00060	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00064	c1 e8 10	 shr	 eax, 16
  00067	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006c	8b c0		 mov	 eax, eax
  0006e	48 89 44 24 58	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00073	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00077	c1 e8 1c	 shr	 eax, 28
  0007a	83 e0 0f	 and	 eax, 15
  0007d	89 44 24 44	 mov	 DWORD PTR b1$[rsp], eax
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00092	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00096	83 e0 0f	 and	 eax, 15
  00099	89 44 24 40	 mov	 DWORD PTR l2$[rsp], eax
  0009d	b8 01 00 00 00	 mov	 eax, 1
  000a2	48 6b c0 01	 imul	 rax, rax, 1
  000a6	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000ae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b2	c1 f8 04	 sar	 eax, 4
  000b5	83 e0 0f	 and	 eax, 15
  000b8	89 44 24 48	 mov	 DWORD PTR l1$[rsp], eax
  000bc	83 7c 24 44 00	 cmp	 DWORD PTR b1$[rsp], 0
  000c1	74 44		 je	 SHORT $LN8@z900_divid
  000c3	48 63 44 24 44	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000dd	48 03 c8	 add	 rcx, rax
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 89 44 24 58	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000e8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000fc	48 23 c8	 and	 rcx, rax
  000ff	48 8b c1	 mov	 rax, rcx
  00102	48 89 44 24 58	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_divid:
  00107	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0010c	74 44		 je	 SHORT $LN9@z900_divid
  0010e	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00113	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00123	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00128	48 03 c8	 add	 rcx, rax
  0012b	48 8b c1	 mov	 rax, rcx
  0012e	48 89 44 24 70	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00133	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00142	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	48 23 c8	 and	 rcx, rax
  0014a	48 8b c1	 mov	 rax, rcx
  0014d	48 89 44 24 70	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_divid:
$LN4@z900_divid:
  00152	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0015e	48 83 c0 06	 add	 rax, 6
  00162	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016e	33 c0		 xor	 eax, eax
  00170	83 f8 06	 cmp	 eax, 6
  00173	74 0f		 je	 SHORT $LN10@z900_divid
  00175	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_divid:
  00184	33 c0		 xor	 eax, eax
  00186	85 c0		 test	 eax, eax
  00188	75 c8		 jne	 SHORT $LN4@z900_divid

; 848  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  0018a	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  0018f	8b 54 24 44	 mov	 edx, DWORD PTR b1$[rsp]
  00193	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_divid:

; 849  :     TXFC_INSTR_CHECK( regs );

  001a0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001af	85 c0		 test	 eax, eax
  001b1	74 3f		 je	 SHORT $LN11@z900_divid
  001b3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001c1	0f ba e8 0f	 bts	 eax, 15
  001c5	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193590
  001da	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001e0	ba 02 00 00 00	 mov	 edx, 2
  001e5	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_divid:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	75 a8		 jne	 SHORT $LN7@z900_divid

; 850  : 
; 851  :     /* Program check if the second operand length exceeds 15 digits
; 852  :        or is equal to or greater than the first operand length */
; 853  :     if (l2 > 7 || l2 >= l1)

  001f8	83 7c 24 40 07	 cmp	 DWORD PTR l2$[rsp], 7
  001fd	7f 0a		 jg	 SHORT $LN13@z900_divid
  001ff	8b 44 24 48	 mov	 eax, DWORD PTR l1$[rsp]
  00203	39 44 24 40	 cmp	 DWORD PTR l2$[rsp], eax
  00207	7c 12		 jl	 SHORT $LN12@z900_divid
$LN13@z900_divid:

; 854  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00209	ba 06 00 00 00	 mov	 edx, 6
  0020e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	e8 00 00 00 00	 call	 z900_program_interrupt
$LN12@z900_divid:

; 855  : 
; 856  :     /* Load operands into work areas */
; 857  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  0021b	48 8d 44 24 68	 lea	 rax, QWORD PTR sign1$[rsp]
  00220	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00225	48 8d 44 24 78	 lea	 rax, QWORD PTR count1$[rsp]
  0022a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0022f	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00237	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023c	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00244	44 8b 44 24 44	 mov	 r8d, DWORD PTR b1$[rsp]
  00249	8b 54 24 48	 mov	 edx, DWORD PTR l1$[rsp]
  0024d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00252	e8 00 00 00 00	 call	 z900_load_decimal

; 858  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  00257	48 8d 44 24 7c	 lea	 rax, QWORD PTR sign2$[rsp]
  0025c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00261	48 8d 44 24 60	 lea	 rax, QWORD PTR count2$[rsp]
  00266	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0026b	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  00273	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00278	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00280	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  00285	8b 54 24 40	 mov	 edx, DWORD PTR l2$[rsp]
  00289	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0028e	e8 00 00 00 00	 call	 z900_load_decimal

; 859  : 
; 860  :     /* Program check if second operand value is zero */
; 861  :     if (count2 == 0)

  00293	83 7c 24 60 00	 cmp	 DWORD PTR count2$[rsp], 0
  00298	75 12		 jne	 SHORT $LN14@z900_divid

; 862  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_DIVIDE_EXCEPTION);

  0029a	ba 0b 00 00 00	 mov	 edx, 11
  0029f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a7	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_divid:

; 863  : 
; 864  :     /* Perform trial comparison to determine potential overflow.
; 865  :        The leftmost digit of the divisor is aligned one digit to
; 866  :        the right of the leftmost dividend digit.  When the divisor,
; 867  :        so aligned, is less than or equal to the dividend, ignoring
; 868  :        signs, a divide exception is indicated.  As a result of this
; 869  :        comparison, it is also certain that the leftmost digit of the
; 870  :        dividend must be zero, and that the divisor cannot be zero */
; 871  :     if (memcmp(dec2 + (MAX_DECIMAL_DIGITS - l2*2 - 2),
; 872  :                 dec1 + (MAX_DECIMAL_DIGITS - l1*2 - 1),
; 873  :                 l2*2 + 2) <= 0)

  002ac	8b 44 24 40	 mov	 eax, DWORD PTR l2$[rsp]
  002b0	8d 44 00 02	 lea	 eax, DWORD PTR [rax+rax+2]
  002b4	48 98		 cdqe
  002b6	8b 4c 24 48	 mov	 ecx, DWORD PTR l1$[rsp]
  002ba	d1 e1		 shl	 ecx, 1
  002bc	ba 1f 00 00 00	 mov	 edx, 31
  002c1	2b d1		 sub	 edx, ecx
  002c3	8b ca		 mov	 ecx, edx
  002c5	ff c9		 dec	 ecx
  002c7	48 63 c9	 movsxd	 rcx, ecx
  002ca	48 8d 8c 0c b0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp+rcx]
  002d2	8b 54 24 40	 mov	 edx, DWORD PTR l2$[rsp]
  002d6	d1 e2		 shl	 edx, 1
  002d8	41 b8 1f 00 00
	00		 mov	 r8d, 31
  002de	44 2b c2	 sub	 r8d, edx
  002e1	41 8b d0	 mov	 edx, r8d
  002e4	83 ea 02	 sub	 edx, 2
  002e7	48 63 d2	 movsxd	 rdx, edx
  002ea	48 8d 94 14 90
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp+rdx]
  002f2	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR tv195[rsp], rdx
  002fa	4c 8b c0	 mov	 r8, rax
  002fd	48 8b d1	 mov	 rdx, rcx
  00300	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv195[rsp]
  00308	48 8b c8	 mov	 rcx, rax
  0030b	e8 00 00 00 00	 call	 memcmp
  00310	85 c0		 test	 eax, eax
  00312	7f 12		 jg	 SHORT $LN15@z900_divid

; 874  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_DIVIDE_EXCEPTION);

  00314	ba 0b 00 00 00	 mov	 edx, 11
  00319	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_divid:

; 875  : 
; 876  :     /* Perform decimal division */
; 877  :     divide_decimal (dec1, count1, dec2, count2, quot, rem);

  00326	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR rem$[rsp]
  0032e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00333	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR quot$[rsp]
  0033b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00340	44 8b 4c 24 60	 mov	 r9d, DWORD PTR count2$[rsp]
  00345	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR dec2$[rsp]
  0034d	8b 54 24 78	 mov	 edx, DWORD PTR count1$[rsp]
  00351	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00359	e8 00 00 00 00	 call	 divide_decimal

; 878  : 
; 879  :     /* Quotient is positive if operand signs are equal, and negative
; 880  :        if operand signs are opposite, even if quotient is zero */
; 881  :     signq = (sign1 == sign2) ? 1 : -1;

  0035e	8b 44 24 7c	 mov	 eax, DWORD PTR sign2$[rsp]
  00362	39 44 24 68	 cmp	 DWORD PTR sign1$[rsp], eax
  00366	75 0a		 jne	 SHORT $LN17@z900_divid
  00368	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  00370	eb 08		 jmp	 SHORT $LN18@z900_divid
$LN17@z900_divid:
  00372	c7 44 24 64 ff
	ff ff ff	 mov	 DWORD PTR tv207[rsp], -1
$LN18@z900_divid:
  0037a	8b 44 24 64	 mov	 eax, DWORD PTR tv207[rsp]
  0037e	89 84 24 84 00
	00 00		 mov	 DWORD PTR signq$[rsp], eax

; 882  : 
; 883  :     /* Remainder sign is same as dividend, even if remainder is zero */
; 884  :     signr = sign1;

  00385	8b 44 24 68	 mov	 eax, DWORD PTR sign1$[rsp]
  00389	89 84 24 80 00
	00 00		 mov	 DWORD PTR signr$[rsp], eax

; 885  : 
; 886  :     /* Store remainder into entire first operand location.  The entire
; 887  :        field will be filled in order to check for store protection.
; 888  :        Subsequently the quotient will be stored in the leftmost bytes
; 889  :        of the first operand location, overwriting high order zeroes */
; 890  :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, rem, signr);

  00390	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR signr$[rsp]
  00397	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0039b	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR rem$[rsp]
  003a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a8	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003b0	44 8b 44 24 44	 mov	 r8d, DWORD PTR b1$[rsp]
  003b5	8b 54 24 48	 mov	 edx, DWORD PTR l1$[rsp]
  003b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  003be	e8 00 00 00 00	 call	 z900_store_decimal

; 891  : 
; 892  :     /* Store quotient in leftmost bytes of first operand location */
; 893  :     ARCH_DEP(store_decimal) (effective_addr1, l1-l2-1, b1, regs, quot, signq);

  003c3	8b 44 24 40	 mov	 eax, DWORD PTR l2$[rsp]
  003c7	8b 4c 24 48	 mov	 ecx, DWORD PTR l1$[rsp]
  003cb	2b c8		 sub	 ecx, eax
  003cd	8b c1		 mov	 eax, ecx
  003cf	ff c8		 dec	 eax
  003d1	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR signq$[rsp]
  003d8	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  003dc	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR quot$[rsp]
  003e4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003e9	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003f1	44 8b 44 24 44	 mov	 r8d, DWORD PTR b1$[rsp]
  003f6	8b d0		 mov	 edx, eax
  003f8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  003fd	e8 00 00 00 00	 call	 z900_store_decimal

; 894  : 
; 895  : } /* end DEF_INST(divide_decimal) */

  00402	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0040a	48 33 cc	 xor	 rcx, rsp
  0040d	e8 00 00 00 00	 call	 __security_check_cookie
  00412	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00419	c3		 ret	 0
z900_divide_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
temp$1 = 64
b1$ = 68
b2$ = 72
sign1$ = 76
sign2$ = 80
tv189 = 84
rc$ = 88
tv194 = 92
effective_addr1$ = 96
effective_addr2$ = 104
l1$ = 112
l2$ = 116
count1$ = 120
count2$ = 124
dec2$ = 128
dec1$ = 160
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_compare_decimal PROC

; 775  : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 776  : int     l1, l2;                         /* Length values             */
; 777  : int     b1, b2;                         /* Base register numbers     */
; 778  : VADR    effective_addr1,
; 779  :         effective_addr2;                /* Effective addresses       */
; 780  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 781  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 782  : int     count1, count2;                 /* Significant digit counters*/
; 783  : int     sign1, sign2;                   /* Sign of each operand      */
; 784  : int     rc;                             /* Return code               */
; 785  : 
; 786  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	8b c0		 mov	 eax, eax
  0004d	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00052	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00056	c1 e8 0c	 shr	 eax, 12
  00059	83 e0 0f	 and	 eax, 15
  0005c	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00060	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00064	c1 e8 10	 shr	 eax, 16
  00067	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006c	8b c0		 mov	 eax, eax
  0006e	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00073	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00077	c1 e8 1c	 shr	 eax, 28
  0007a	83 e0 0f	 and	 eax, 15
  0007d	89 44 24 44	 mov	 DWORD PTR b1$[rsp], eax
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00092	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00096	83 e0 0f	 and	 eax, 15
  00099	89 44 24 74	 mov	 DWORD PTR l2$[rsp], eax
  0009d	b8 01 00 00 00	 mov	 eax, 1
  000a2	48 6b c0 01	 imul	 rax, rax, 1
  000a6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000ae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b2	c1 f8 04	 sar	 eax, 4
  000b5	83 e0 0f	 and	 eax, 15
  000b8	89 44 24 70	 mov	 DWORD PTR l1$[rsp], eax
  000bc	83 7c 24 44 00	 cmp	 DWORD PTR b1$[rsp], 0
  000c1	74 44		 je	 SHORT $LN8@z900_compa
  000c3	48 63 44 24 44	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000dd	48 03 c8	 add	 rcx, rax
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000e8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000f7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000fc	48 23 c8	 and	 rcx, rax
  000ff	48 8b c1	 mov	 rax, rcx
  00102	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_compa:
  00107	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  0010c	74 44		 je	 SHORT $LN9@z900_compa
  0010e	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00113	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00123	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00128	48 03 c8	 add	 rcx, rax
  0012b	48 8b c1	 mov	 rax, rcx
  0012e	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00133	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00142	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	48 23 c8	 and	 rcx, rax
  0014a	48 8b c1	 mov	 rax, rcx
  0014d	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_compa:
$LN4@z900_compa:
  00152	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0015e	48 83 c0 06	 add	 rax, 6
  00162	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016e	33 c0		 xor	 eax, eax
  00170	83 f8 06	 cmp	 eax, 6
  00173	74 0f		 je	 SHORT $LN10@z900_compa
  00175	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_compa:
  00184	33 c0		 xor	 eax, eax
  00186	85 c0		 test	 eax, eax
  00188	75 c8		 jne	 SHORT $LN4@z900_compa

; 787  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  0018a	44 8b 44 24 48	 mov	 r8d, DWORD PTR b2$[rsp]
  0018f	8b 54 24 44	 mov	 edx, DWORD PTR b1$[rsp]
  00193	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_compa:

; 788  :     TXFC_INSTR_CHECK( regs );

  001a0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001af	85 c0		 test	 eax, eax
  001b1	74 3f		 je	 SHORT $LN11@z900_compa
  001b3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001c1	0f ba e8 0f	 bts	 eax, 15
  001c5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193550
  001da	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001e0	ba 02 00 00 00	 mov	 edx, 2
  001e5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_compa:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	75 a8		 jne	 SHORT $LN7@z900_compa

; 789  : 
; 790  :     /* Load operands into work areas */
; 791  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  001f8	48 8d 44 24 4c	 lea	 rax, QWORD PTR sign1$[rsp]
  001fd	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00202	48 8d 44 24 78	 lea	 rax, QWORD PTR count1$[rsp]
  00207	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0020c	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00214	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00219	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00221	44 8b 44 24 44	 mov	 r8d, DWORD PTR b1$[rsp]
  00226	8b 54 24 70	 mov	 edx, DWORD PTR l1$[rsp]
  0022a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_load_decimal

; 792  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  00234	48 8d 44 24 50	 lea	 rax, QWORD PTR sign2$[rsp]
  00239	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0023e	48 8d 44 24 7c	 lea	 rax, QWORD PTR count2$[rsp]
  00243	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00248	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  00250	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00255	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0025d	44 8b 44 24 48	 mov	 r8d, DWORD PTR b2$[rsp]
  00262	8b 54 24 74	 mov	 edx, DWORD PTR l2$[rsp]
  00266	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0026b	e8 00 00 00 00	 call	 z900_load_decimal

; 793  : 
; 794  :     /* Result is equal if both operands are zero */
; 795  :     if (count1 == 0 && count2 == 0)

  00270	83 7c 24 78 00	 cmp	 DWORD PTR count1$[rsp], 0
  00275	75 18		 jne	 SHORT $LN12@z900_compa
  00277	83 7c 24 7c 00	 cmp	 DWORD PTR count2$[rsp], 0
  0027c	75 11		 jne	 SHORT $LN12@z900_compa

; 796  :     {
; 797  :         regs->psw.cc = 0;

  0027e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00286	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 798  :         return;

  0028a	e9 cd 00 00 00	 jmp	 $LN1@z900_compa
$LN12@z900_compa:

; 799  :     }
; 800  : 
; 801  :     /* Result is low if operand 1 is -ve and operand 2 is +ve */
; 802  :     if (sign1 < 0 && sign2 > 0)

  0028f	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  00294	7d 18		 jge	 SHORT $LN13@z900_compa
  00296	83 7c 24 50 00	 cmp	 DWORD PTR sign2$[rsp], 0
  0029b	7e 11		 jle	 SHORT $LN13@z900_compa

; 803  :     {
; 804  :         regs->psw.cc = 1;

  0029d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a5	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 805  :         return;

  002a9	e9 ae 00 00 00	 jmp	 $LN1@z900_compa
$LN13@z900_compa:

; 806  :     }
; 807  : 
; 808  :     /* Result is high if operand 1 is +ve and operand 2 is -ve */
; 809  :     if (sign1 > 0 && sign2 < 0)

  002ae	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  002b3	7e 18		 jle	 SHORT $LN14@z900_compa
  002b5	83 7c 24 50 00	 cmp	 DWORD PTR sign2$[rsp], 0
  002ba	7d 11		 jge	 SHORT $LN14@z900_compa

; 810  :     {
; 811  :         regs->psw.cc = 2;

  002bc	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c4	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 812  :         return;

  002c8	e9 8f 00 00 00	 jmp	 $LN1@z900_compa
$LN14@z900_compa:

; 813  :     }
; 814  : 
; 815  :     /* If signs are equal then compare the digits */
; 816  :     rc = memcmp (dec1, dec2, MAX_DECIMAL_DIGITS);

  002cd	41 b8 1f 00 00
	00		 mov	 r8d, 31
  002d3	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  002db	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  002e3	e8 00 00 00 00	 call	 memcmp
  002e8	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax

; 817  : 
; 818  :     /* Return low or high (depending on sign) if digits are unequal */
; 819  :     if (rc < 0)

  002ec	83 7c 24 58 00	 cmp	 DWORD PTR rc$[rsp], 0
  002f1	7d 2b		 jge	 SHORT $LN15@z900_compa

; 820  :         regs->psw.cc = (sign1 > 0) ? 1 : 2;

  002f3	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  002f8	7e 0a		 jle	 SHORT $LN20@z900_compa
  002fa	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv189[rsp], 1
  00302	eb 08		 jmp	 SHORT $LN21@z900_compa
$LN20@z900_compa:
  00304	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR tv189[rsp], 2
$LN21@z900_compa:
  0030c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00314	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR tv189[rsp]
  00319	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0031c	eb 3e		 jmp	 SHORT $LN16@z900_compa
$LN15@z900_compa:

; 821  :     else
; 822  :         if (rc > 0)

  0031e	83 7c 24 58 00	 cmp	 DWORD PTR rc$[rsp], 0
  00323	7e 2b		 jle	 SHORT $LN17@z900_compa

; 823  :             regs->psw.cc = (sign1 > 0) ? 2 : 1;

  00325	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  0032a	7e 0a		 jle	 SHORT $LN22@z900_compa
  0032c	c7 44 24 5c 02
	00 00 00	 mov	 DWORD PTR tv194[rsp], 2
  00334	eb 08		 jmp	 SHORT $LN23@z900_compa
$LN22@z900_compa:
  00336	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
$LN23@z900_compa:
  0033e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00346	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR tv194[rsp]
  0034b	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0034e	eb 0c		 jmp	 SHORT $LN18@z900_compa
$LN17@z900_compa:

; 824  :         else
; 825  :             regs->psw.cc = 0;

  00350	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00358	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN18@z900_compa:
$LN16@z900_compa:
$LN1@z900_compa:

; 826  : 
; 827  : } /* end DEF_INST(compare_decimal) */

  0035c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00364	48 33 cc	 xor	 rcx, rsp
  00367	e8 00 00 00 00	 call	 __security_check_cookie
  0036c	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00373	c3		 ret	 0
z900_compare_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sign3$ = 64
count3$ = 68
b1$ = 72
temp$1 = 76
b2$ = 80
sign1$ = 84
l1$ = 88
cc$ = 92
effective_addr1$ = 96
count1$ = 104
count2$ = 108
sign2$ = 112
tv201 = 116
tv202 = 120
effective_addr2$ = 128
l2$ = 136
dec3$ = 144
dec2$ = 176
dec1$ = 208
__$ArrayPad$ = 240
inst$ = 288
regs$ = 296
z900_add_decimal PROC

; 699  : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 700  : int     l1, l2;                         /* Length values             */
; 701  : int     b1, b2;                         /* Base register numbers     */
; 702  : VADR    effective_addr1,
; 703  :         effective_addr2;                /* Effective addresses       */
; 704  : int     cc;                             /* Condition code            */
; 705  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 706  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 707  : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 708  : int     count1, count2, count3;         /* Significant digit counters*/
; 709  : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 710  : 
; 711  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00025	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002d	48 83 c0 02	 add	 rax, 2
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 fetch_fw_noswap
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 _byteswap_ulong
  00040	89 44 24 4c	 mov	 DWORD PTR temp$1[rsp], eax
  00044	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	8b c0		 mov	 eax, eax
  0004f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00057	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	c1 e8 0c	 shr	 eax, 12
  0005e	83 e0 0f	 and	 eax, 15
  00061	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00065	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00069	c1 e8 10	 shr	 eax, 16
  0006c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00071	8b c0		 mov	 eax, eax
  00073	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00078	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 1c	 shr	 eax, 28
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 48	 mov	 DWORD PTR b1$[rsp], eax
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 01	 imul	 rax, rax, 1
  0008f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00097	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009b	83 e0 0f	 and	 eax, 15
  0009e	89 84 24 88 00
	00 00		 mov	 DWORD PTR l2$[rsp], eax
  000a5	b8 01 00 00 00	 mov	 eax, 1
  000aa	48 6b c0 01	 imul	 rax, rax, 1
  000ae	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ba	c1 f8 04	 sar	 eax, 4
  000bd	83 e0 0f	 and	 eax, 15
  000c0	89 44 24 58	 mov	 DWORD PTR l1$[rsp], eax
  000c4	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  000c9	74 44		 je	 SHORT $LN8@z900_add_d
  000cb	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  000d0	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000e5	48 03 c8	 add	 rcx, rax
  000e8	48 8b c1	 mov	 rax, rcx
  000eb	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000f0	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ff	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00104	48 23 c8	 and	 rcx, rax
  00107	48 8b c1	 mov	 rax, rcx
  0010a	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_add_d:
  0010f	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00114	74 50		 je	 SHORT $LN9@z900_add_d
  00116	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  0011b	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0012b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00133	48 03 c8	 add	 rcx, rax
  00136	48 8b c1	 mov	 rax, rcx
  00139	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00141	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00150	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00158	48 23 c8	 and	 rcx, rax
  0015b	48 8b c1	 mov	 rax, rcx
  0015e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_add_d:
$LN4@z900_add_d:
  00166	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00172	48 83 c0 06	 add	 rax, 6
  00176	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00182	33 c0		 xor	 eax, eax
  00184	83 f8 06	 cmp	 eax, 6
  00187	74 0f		 je	 SHORT $LN10@z900_add_d
  00189	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_add_d:
  00198	33 c0		 xor	 eax, eax
  0019a	85 c0		 test	 eax, eax
  0019c	75 c8		 jne	 SHORT $LN4@z900_add_d

; 712  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  0019e	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  001a3	8b 54 24 48	 mov	 edx, DWORD PTR b1$[rsp]
  001a7	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001af	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_add_d:

; 713  :     TXFC_INSTR_CHECK( regs );

  001b4	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001c3	85 c0		 test	 eax, eax
  001c5	74 3f		 je	 SHORT $LN11@z900_add_d
  001c7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001d5	0f ba e8 0f	 bts	 eax, 15
  001d9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001e7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193510
  001ee	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001f4	ba 02 00 00 00	 mov	 edx, 2
  001f9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_add_d:
  00206	33 c0		 xor	 eax, eax
  00208	85 c0		 test	 eax, eax
  0020a	75 a8		 jne	 SHORT $LN7@z900_add_d

; 714  : 
; 715  :     /* Load operands into work areas */
; 716  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  0020c	48 8d 44 24 54	 lea	 rax, QWORD PTR sign1$[rsp]
  00211	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00216	48 8d 44 24 68	 lea	 rax, QWORD PTR count1$[rsp]
  0021b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00220	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00228	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022d	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00235	44 8b 44 24 48	 mov	 r8d, DWORD PTR b1$[rsp]
  0023a	8b 54 24 58	 mov	 edx, DWORD PTR l1$[rsp]
  0023e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00243	e8 00 00 00 00	 call	 z900_load_decimal

; 717  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  00248	48 8d 44 24 70	 lea	 rax, QWORD PTR sign2$[rsp]
  0024d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00252	48 8d 44 24 6c	 lea	 rax, QWORD PTR count2$[rsp]
  00257	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025c	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  00264	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00269	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00271	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  00276	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR l2$[rsp]
  0027d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00285	e8 00 00 00 00	 call	 z900_load_decimal

; 718  : 
; 719  :     /* Add or subtract operand values */
; 720  :     if (count2 == 0)

  0028a	83 7c 24 6c 00	 cmp	 DWORD PTR count2$[rsp], 0
  0028f	75 32		 jne	 SHORT $LN12@z900_add_d

; 721  :     {
; 722  :         /* If second operand is zero then result is first operand */
; 723  :         memcpy (dec3, dec1, MAX_DECIMAL_DIGITS);

  00291	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00299	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  002a1	48 8b f8	 mov	 rdi, rax
  002a4	48 8b f1	 mov	 rsi, rcx
  002a7	b9 1f 00 00 00	 mov	 ecx, 31
  002ac	f3 a4		 rep movsb

; 724  :         count3 = count1;

  002ae	8b 44 24 68	 mov	 eax, DWORD PTR count1$[rsp]
  002b2	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 725  :         sign3 = sign1;

  002b6	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  002ba	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 726  :     }

  002be	e9 a9 00 00 00	 jmp	 $LN13@z900_add_d
$LN12@z900_add_d:

; 727  :     else if (count1 == 0)

  002c3	83 7c 24 68 00	 cmp	 DWORD PTR count1$[rsp], 0
  002c8	75 2f		 jne	 SHORT $LN14@z900_add_d

; 728  :     {
; 729  :         /* If first operand is zero then result is second operand */
; 730  :         memcpy (dec3, dec2, MAX_DECIMAL_DIGITS);

  002ca	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  002d2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR dec2$[rsp]
  002da	48 8b f8	 mov	 rdi, rax
  002dd	48 8b f1	 mov	 rsi, rcx
  002e0	b9 1f 00 00 00	 mov	 ecx, 31
  002e5	f3 a4		 rep movsb

; 731  :         count3 = count2;

  002e7	8b 44 24 6c	 mov	 eax, DWORD PTR count2$[rsp]
  002eb	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 732  :         sign3 = sign2;

  002ef	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  002f3	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 733  :     }

  002f7	eb 73		 jmp	 SHORT $LN15@z900_add_d
$LN14@z900_add_d:

; 734  :     else if (sign1 == sign2)

  002f9	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  002fd	39 44 24 54	 cmp	 DWORD PTR sign1$[rsp], eax
  00301	75 2c		 jne	 SHORT $LN16@z900_add_d

; 735  :     {
; 736  :         /* If signs are equal then add operands */
; 737  :         add_decimal (dec1, dec2, dec3, &count3);

  00303	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  00308	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  00310	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  00318	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00320	e8 00 00 00 00	 call	 add_decimal

; 738  :         sign3 = sign1;

  00325	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  00329	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 739  :     }

  0032d	eb 3d		 jmp	 SHORT $LN17@z900_add_d
$LN16@z900_add_d:

; 740  :     else
; 741  :     {
; 742  :         /* If signs are opposite then subtract operands */
; 743  :         subtract_decimal (dec1, dec2, dec3, &count3, &sign3);

  0032f	48 8d 44 24 40	 lea	 rax, QWORD PTR sign3$[rsp]
  00334	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00339	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  0033e	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  00346	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  0034e	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00356	e8 00 00 00 00	 call	 subtract_decimal

; 744  :         if (sign1 < 0) sign3 = -sign3;

  0035b	83 7c 24 54 00	 cmp	 DWORD PTR sign1$[rsp], 0
  00360	7d 0a		 jge	 SHORT $LN18@z900_add_d
  00362	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  00366	f7 d8		 neg	 eax
  00368	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax
$LN18@z900_add_d:
$LN17@z900_add_d:
$LN15@z900_add_d:
$LN13@z900_add_d:

; 745  :     }
; 746  : 
; 747  :     /* Set condition code */
; 748  :     cc = (count3 == 0) ? 0 : (sign3 < 1) ? 1 : 2;

  0036c	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  00371	75 0a		 jne	 SHORT $LN25@z900_add_d
  00373	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
  0037b	eb 21		 jmp	 SHORT $LN26@z900_add_d
$LN25@z900_add_d:
  0037d	83 7c 24 40 01	 cmp	 DWORD PTR sign3$[rsp], 1
  00382	7d 0a		 jge	 SHORT $LN23@z900_add_d
  00384	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv201[rsp], 1
  0038c	eb 08		 jmp	 SHORT $LN24@z900_add_d
$LN23@z900_add_d:
  0038e	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv201[rsp], 2
$LN24@z900_add_d:
  00396	8b 44 24 74	 mov	 eax, DWORD PTR tv201[rsp]
  0039a	89 44 24 78	 mov	 DWORD PTR tv202[rsp], eax
$LN26@z900_add_d:
  0039e	8b 44 24 78	 mov	 eax, DWORD PTR tv202[rsp]
  003a2	89 44 24 5c	 mov	 DWORD PTR cc$[rsp], eax

; 749  : 
; 750  :     /* Overflow if result exceeds first operand length */
; 751  :     if (count3 > (l1+1) * 2 - 1)

  003a6	8b 44 24 58	 mov	 eax, DWORD PTR l1$[rsp]
  003aa	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  003ae	39 44 24 44	 cmp	 DWORD PTR count3$[rsp], eax
  003b2	7e 08		 jle	 SHORT $LN19@z900_add_d

; 752  :         cc = 3;

  003b4	c7 44 24 5c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN19@z900_add_d:

; 753  : 
; 754  :     /* Set positive sign if result is zero */
; 755  :     if (count3 == 0)

  003bc	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  003c1	75 08		 jne	 SHORT $LN20@z900_add_d

; 756  :         sign3 = 1;

  003c3	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR sign3$[rsp], 1
$LN20@z900_add_d:

; 757  : 
; 758  :     /* Store result into first operand location */
; 759  :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  003cb	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  003cf	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003d3	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  003db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e0	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003e8	44 8b 44 24 48	 mov	 r8d, DWORD PTR b1$[rsp]
  003ed	8b 54 24 58	 mov	 edx, DWORD PTR l1$[rsp]
  003f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  003f6	e8 00 00 00 00	 call	 z900_store_decimal

; 760  : 
; 761  :     /* Set condition code */
; 762  :     regs->psw.cc = cc;

  003fb	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00403	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR cc$[rsp]
  00408	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 763  : 
; 764  :     /* Program check if overflow and PSW program mask is set */
; 765  :     if (cc == 3 && DOMASK(&regs->psw))

  0040b	83 7c 24 5c 03	 cmp	 DWORD PTR cc$[rsp], 3
  00410	75 25		 jne	 SHORT $LN21@z900_add_d
  00412	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041a	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  0041e	83 e0 04	 and	 eax, 4
  00421	85 c0		 test	 eax, eax
  00423	74 12		 je	 SHORT $LN21@z900_add_d

; 766  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  00425	ba 0a 00 00 00	 mov	 edx, 10
  0042a	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00432	e8 00 00 00 00	 call	 z900_program_interrupt
$LN21@z900_add_d:

; 767  : 
; 768  : } /* end DEF_INST(add_decimal) */

  00437	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043f	48 33 cc	 xor	 rcx, rsp
  00442	e8 00 00 00 00	 call	 __security_check_cookie
  00447	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  0044e	5f		 pop	 rdi
  0044f	5e		 pop	 rsi
  00450	c3		 ret	 0
z900_add_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 48
cc$ = 52
b1$ = 56
temp$1 = 60
l1$ = 64
effective_addr1$ = 72
pack$ = 80
__$ArrayPad$ = 96
inst$ = 128
regs$ = 136
z900_test_decimal PROC

; 1387 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1388 : int     l1;                             /* Length value              */
; 1389 : int     b1;                             /* Base register number      */
; 1390 : VADR    effective_addr1;                /* Effective address         */
; 1391 : int     i;                              /* Array subscript           */
; 1392 : int     cc = 0;                         /* Condition code            */

  0001d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1393 : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 1394 : 
; 1395 :     RSL(inst, regs, l1, b1, effective_addr1);

  00025	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 _byteswap_ulong
  00039	89 44 24 3c	 mov	 DWORD PTR temp$1[rsp], eax
  0003d	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00041	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00046	8b c0		 mov	 eax, eax
  00048	48 89 44 24 48	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0004d	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 0c	 shr	 eax, 12
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 38	 mov	 DWORD PTR b1$[rsp], eax
  0005b	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 14	 shr	 eax, 20
  00062	83 e0 0f	 and	 eax, 15
  00065	89 44 24 40	 mov	 DWORD PTR l1$[rsp], eax
  00069	83 7c 24 38 00	 cmp	 DWORD PTR b1$[rsp], 0
  0006e	74 44		 je	 SHORT $LN11@z900_test_
  00070	48 63 44 24 38	 movsxd	 rax, DWORD PTR b1$[rsp]
  00075	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00085	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0008a	48 03 c8	 add	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 89 44 24 48	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00095	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000a4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000a9	48 23 c8	 and	 rcx, rax
  000ac	48 8b c1	 mov	 rax, rcx
  000af	48 89 44 24 48	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN11@z900_test_:
$LN4@z900_test_:
  000b4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c0	48 83 c0 06	 add	 rax, 6
  000c4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d0	33 c0		 xor	 eax, eax
  000d2	83 f8 06	 cmp	 eax, 6
  000d5	74 0f		 je	 SHORT $LN12@z900_test_
  000d7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000df	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN12@z900_test_:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 c8		 jne	 SHORT $LN4@z900_test_

; 1396 :     PER_ZEROADDR_XCHECK( regs, b1 );

  000ec	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  000f0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_test_:

; 1397 : 
; 1398 :     TXFC_INSTR_CHECK( regs );

  000fd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00105	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0010c	85 c0		 test	 eax, eax
  0010e	74 3f		 je	 SHORT $LN13@z900_test_
  00110	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0011e	0f ba e8 0f	 bts	 eax, 15
  00122	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012a	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00130	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193859
  00137	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0013d	ba 02 00 00 00	 mov	 edx, 2
  00142	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	e8 00 00 00 00	 call	 z900_abort_transaction
$LN13@z900_test_:
  0014f	33 c0		 xor	 eax, eax
  00151	85 c0		 test	 eax, eax
  00153	75 a8		 jne	 SHORT $LN7@z900_test_

; 1399 : 
; 1400 :     /* Fetch the packed decimal operand into the work area */
; 1401 :     ARCH_DEP(vfetchc) (pack, l1, effective_addr1, b1, regs);

  00155	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00162	44 8b 4c 24 38	 mov	 r9d, DWORD PTR b1$[rsp]
  00167	4c 8b 44 24 48	 mov	 r8, QWORD PTR effective_addr1$[rsp]
  0016c	0f b6 54 24 40	 movzx	 edx, BYTE PTR l1$[rsp]
  00171	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pack$[rsp]
  00176	e8 00 00 00 00	 call	 z900_vfetchc

; 1402 : 
; 1403 :     /* Test each byte of the operand */
; 1404 :     for (i=0; ; i++)

  0017b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00183	eb 0a		 jmp	 SHORT $LN10@z900_test_
$LN8@z900_test_:
  00185	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00189	ff c0		 inc	 eax
  0018b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_test_:

; 1405 :     {
; 1406 :         /* Test the high-order digit of the byte */
; 1407 :         if ((pack[i] & 0xF0) > 0x90)

  0018f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00194	0f b6 44 04 50	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  00199	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0019e	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  001a3	7e 08		 jle	 SHORT $LN14@z900_test_

; 1408 :             cc = 2;

  001a5	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN14@z900_test_:

; 1409 : 
; 1410 :         /* Exit if this is the last byte */
; 1411 :         if (i == l1) break;

  001ad	8b 44 24 40	 mov	 eax, DWORD PTR l1$[rsp]
  001b1	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  001b5	75 02		 jne	 SHORT $LN15@z900_test_
  001b7	eb 1c		 jmp	 SHORT $LN9@z900_test_
$LN15@z900_test_:

; 1412 : 
; 1413 :         /* Test the low-order digit of the byte */
; 1414 :         if ((pack[i] & 0x0F) > 0x09)

  001b9	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  001be	0f b6 44 04 50	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  001c3	83 e0 0f	 and	 eax, 15
  001c6	83 f8 09	 cmp	 eax, 9
  001c9	7e 08		 jle	 SHORT $LN16@z900_test_

; 1415 :             cc = 2;

  001cb	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN16@z900_test_:

; 1416 :     }

  001d3	eb b0		 jmp	 SHORT $LN8@z900_test_
$LN9@z900_test_:

; 1417 : 
; 1418 :     /* Test the sign in the last byte */
; 1419 :     if ((pack[i] & 0x0F) < 0x0A)

  001d5	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  001da	0f b6 44 04 50	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  001df	83 e0 0f	 and	 eax, 15
  001e2	83 f8 0a	 cmp	 eax, 10
  001e5	7d 0b		 jge	 SHORT $LN17@z900_test_

; 1420 :         cc |= 1;

  001e7	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  001eb	83 c8 01	 or	 eax, 1
  001ee	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax
$LN17@z900_test_:

; 1421 : 
; 1422 :     /* Return condition code */
; 1423 :     regs->psw.cc = cc;

  001f2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fa	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR cc$[rsp]
  001ff	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1424 : 
; 1425 : } /* end DEF_INST(test_decimal) */

  00202	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00207	48 33 cc	 xor	 rcx, rsp
  0020a	e8 00 00 00 00	 call	 __security_check_cookie
  0020f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00213	c3		 ret	 0
z900_test_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 48
j$ = 52
tv135 = 56
pack$ = 64
__$ArrayPad$ = 88
addr$ = 112
len$ = 120
arn$ = 128
regs$ = 136
dec$ = 144
sign$ = 152
s390_store_decimal PROC

; 668  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 669  : int     i, j;                           /* Array subscripts          */
; 670  : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 671  : 
; 672  :     /* if operand crosses page, make sure both pages are accessible */
; 673  :     if((addr & PAGEFRAME_PAGEMASK) !=

  00025	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00029	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  0002e	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  00032	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  00036	03 d1		 add	 edx, ecx
  00038	8b ca		 mov	 ecx, edx
  0003a	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00040	3b c1		 cmp	 eax, ecx
  00042	74 28		 je	 SHORT $LN5@s390_store

; 674  :         ((addr + len) & PAGEFRAME_PAGEMASK))
; 675  :         ARCH_DEP(validate_operand) (addr, arn, len, ACCTYPE_WRITE_SKP, regs);

  00044	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	41 b9 01 00 00
	00		 mov	 r9d, 1
  00057	44 8b 44 24 78	 mov	 r8d, DWORD PTR len$[rsp]
  0005c	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR arn$[rsp]
  00063	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00067	e8 00 00 00 00	 call	 s390_validate_operand
$LN5@s390_store:

; 676  : 
; 677  :     /* Pack digits into packed decimal work area */
; 678  :     for (i=0, j=0; i < MAX_DECIMAL_DIGITS; i++)

  0006c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00074	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0007c	eb 0a		 jmp	 SHORT $LN4@s390_store
$LN2@s390_store:
  0007e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00082	ff c0		 inc	 eax
  00084	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_store:
  00088	83 7c 24 30 1f	 cmp	 DWORD PTR i$[rsp], 31
  0008d	7d 5c		 jge	 SHORT $LN3@s390_store

; 679  :     {
; 680  :         if (i & 1)

  0008f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00093	83 e0 01	 and	 eax, 1
  00096	85 c0		 test	 eax, eax
  00098	74 32		 je	 SHORT $LN6@s390_store

; 681  :             pack[j++] |= dec[i];

  0009a	48 63 44 24 34	 movsxd	 rax, DWORD PTR j$[rsp]
  0009f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a4	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dec$[rsp]
  000ac	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000b0	0f b6 44 04 40	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000b5	0b c1		 or	 eax, ecx
  000b7	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000bc	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al
  000c0	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  000c4	ff c0		 inc	 eax
  000c6	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
  000ca	eb 1d		 jmp	 SHORT $LN7@s390_store
$LN6@s390_store:

; 682  :         else
; 683  :             pack[j] = dec[i] << 4;

  000cc	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dec$[rsp]
  000d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000dd	c1 e0 04	 shl	 eax, 4
  000e0	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000e5	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al
$LN7@s390_store:

; 684  :     } /* end for */

  000e9	eb 93		 jmp	 SHORT $LN2@s390_store
$LN3@s390_store:

; 685  : 
; 686  :     /* Pack the sign into low-order digit of work area */
; 687  :     pack[MAX_DECIMAL_LENGTH-1] |= (sign < 0 ? 0x0D : 0x0C);

  000eb	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR sign$[rsp], 0
  000f3	7d 0a		 jge	 SHORT $LN9@s390_store
  000f5	c7 44 24 38 0d
	00 00 00	 mov	 DWORD PTR tv135[rsp], 13
  000fd	eb 08		 jmp	 SHORT $LN10@s390_store
$LN9@s390_store:
  000ff	c7 44 24 38 0c
	00 00 00	 mov	 DWORD PTR tv135[rsp], 12
$LN10@s390_store:
  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	48 6b c0 0f	 imul	 rax, rax, 15
  00110	0f b6 44 04 40	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  00115	0b 44 24 38	 or	 eax, DWORD PTR tv135[rsp]
  00119	b9 01 00 00 00	 mov	 ecx, 1
  0011e	48 6b c9 0f	 imul	 rcx, rcx, 15
  00122	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al

; 688  : 
; 689  :     /* Store the result at the operand location */
; 690  :     ARCH_DEP(vstorec) (pack+sizeof(pack)-len-1, len, addr, arn, regs);

  00126	48 8d 44 24 50	 lea	 rax, QWORD PTR pack$[rsp+16]
  0012b	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR len$[rsp]
  00130	48 2b c1	 sub	 rax, rcx
  00133	48 ff c8	 dec	 rax
  00136	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00143	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR arn$[rsp]
  0014b	44 8b 44 24 70	 mov	 r8d, DWORD PTR addr$[rsp]
  00150	0f b6 54 24 78	 movzx	 edx, BYTE PTR len$[rsp]
  00155	48 8b c8	 mov	 rcx, rax
  00158	e8 00 00 00 00	 call	 s390_vstorec

; 691  : 
; 692  : } /* end function ARCH_DEP(store_decimal) */

  0015d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00162	48 33 cc	 xor	 rcx, rsp
  00165	e8 00 00 00 00	 call	 __security_check_cookie
  0016a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0016e	c3		 ret	 0
s390_store_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
h$ = 48
i$ = 52
j$ = 56
n$ = 60
tv144 = 64
pack$ = 72
__$ArrayPad$ = 96
addr$ = 128
len$ = 136
arn$ = 144
regs$ = 152
result$ = 160
count$ = 168
sign$ = 176
s390_load_decimal PROC

; 596  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 597  : int     h;                              /* Hexadecimal digit         */
; 598  : int     i, j;                           /* Array subscripts          */
; 599  : int     n;                              /* Significant digit counter */
; 600  : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 601  : 
; 602  :     /* Fetch the packed decimal operand into work area */
; 603  :     memset( pack, 0, sizeof(pack) );

  00026	48 8d 44 24 48	 lea	 rax, QWORD PTR pack$[rsp]
  0002b	48 8b f8	 mov	 rdi, rax
  0002e	33 c0		 xor	 eax, eax
  00030	b9 10 00 00 00	 mov	 ecx, 16
  00035	f3 aa		 rep stosb

; 604  :     ARCH_DEP(vfetchc) (pack+sizeof(pack)-len-1, len, addr, arn, regs);

  00037	48 8d 44 24 58	 lea	 rax, QWORD PTR pack$[rsp+16]
  0003c	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR len$[rsp]
  00044	48 2b c1	 sub	 rax, rcx
  00047	48 ff c8	 dec	 rax
  0004a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00057	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR arn$[rsp]
  0005f	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR addr$[rsp]
  00067	0f b6 94 24 88
	00 00 00	 movzx	 edx, BYTE PTR len$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 s390_vfetchc

; 605  : 
; 606  :     /* Unpack digits into result */
; 607  :     for (i=0, j=0, n=0; i < MAX_DECIMAL_DIGITS; i++)

  00077	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00087	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0008f	eb 0a		 jmp	 SHORT $LN4@s390_load_
$LN2@s390_load_:
  00091	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00095	ff c0		 inc	 eax
  00097	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_load_:
  0009b	83 7c 24 34 1f	 cmp	 DWORD PTR i$[rsp], 31
  000a0	0f 8d 9b 00 00
	00		 jge	 $LN3@s390_load_

; 608  :     {
; 609  :         /* Load source digit */
; 610  :         if (i & 1)

  000a6	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  000aa	83 e0 01	 and	 eax, 1
  000ad	85 c0		 test	 eax, eax
  000af	74 1d		 je	 SHORT $LN5@s390_load_

; 611  :             h = pack[j++] & 0x0F;

  000b1	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  000b6	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000bb	83 e0 0f	 and	 eax, 15
  000be	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax
  000c2	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000c6	ff c0		 inc	 eax
  000c8	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
  000cc	eb 11		 jmp	 SHORT $LN6@s390_load_
$LN5@s390_load_:

; 612  :         else
; 613  :             h = pack[j] >> 4;

  000ce	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  000d3	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000d8	c1 f8 04	 sar	 eax, 4
  000db	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax
$LN6@s390_load_:

; 614  : 
; 615  :         /* Check for valid numeric */
; 616  :         if (h > 9)

  000df	83 7c 24 30 09	 cmp	 DWORD PTR h$[rsp], 9
  000e4	7e 29		 jle	 SHORT $LN7@s390_load_

; 617  :         {
; 618  :             regs->dxc = DXC_DECIMAL;

  000e6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 619  :             ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  000f8	ba 07 00 00 00	 mov	 edx, 7
  000fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	e8 00 00 00 00	 call	 s390_program_interrupt

; 620  :             return;

  0010a	e9 b0 00 00 00	 jmp	 $LN1@s390_load_
$LN7@s390_load_:

; 621  :         }
; 622  : 
; 623  :         /* Count significant digits */
; 624  :         if (n > 0 || h != 0)

  0010f	83 7c 24 3c 00	 cmp	 DWORD PTR n$[rsp], 0
  00114	7f 07		 jg	 SHORT $LN9@s390_load_
  00116	83 7c 24 30 00	 cmp	 DWORD PTR h$[rsp], 0
  0011b	74 0a		 je	 SHORT $LN8@s390_load_
$LN9@s390_load_:

; 625  :             n++;

  0011d	8b 44 24 3c	 mov	 eax, DWORD PTR n$[rsp]
  00121	ff c0		 inc	 eax
  00123	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax
$LN8@s390_load_:

; 626  : 
; 627  :         /* Store decimal digit in result */
; 628  :         result[i] = h;

  00127	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  0012c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00134	0f b6 54 24 30	 movzx	 edx, BYTE PTR h$[rsp]
  00139	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 629  : 
; 630  :     } /* end for */

  0013c	e9 50 ff ff ff	 jmp	 $LN2@s390_load_
$LN3@s390_load_:

; 631  : 
; 632  :     /* Check for valid sign */
; 633  :     h = pack[MAX_DECIMAL_LENGTH-1] & 0x0F;

  00141	b8 01 00 00 00	 mov	 eax, 1
  00146	48 6b c0 0f	 imul	 rax, rax, 15
  0014a	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  0014f	83 e0 0f	 and	 eax, 15
  00152	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax

; 634  :     if (h < 0x0A)

  00156	83 7c 24 30 0a	 cmp	 DWORD PTR h$[rsp], 10
  0015b	7d 26		 jge	 SHORT $LN10@s390_load_

; 635  :     {
; 636  :         regs->dxc = DXC_DECIMAL;

  0015d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 637  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0016f	ba 07 00 00 00	 mov	 edx, 7
  00174	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017c	e8 00 00 00 00	 call	 s390_program_interrupt

; 638  :         return;

  00181	eb 3c		 jmp	 SHORT $LN1@s390_load_
$LN10@s390_load_:

; 639  :     }
; 640  : 
; 641  :     /* Set number of significant digits */
; 642  :     *count = n;

  00183	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR count$[rsp]
  0018b	8b 4c 24 3c	 mov	 ecx, DWORD PTR n$[rsp]
  0018f	89 08		 mov	 DWORD PTR [rax], ecx

; 643  : 
; 644  :     /* Set sign of operand */
; 645  :     *sign = (h == 0x0B || h == 0x0D) ? -1 : 1;

  00191	83 7c 24 30 0b	 cmp	 DWORD PTR h$[rsp], 11
  00196	74 11		 je	 SHORT $LN12@s390_load_
  00198	83 7c 24 30 0d	 cmp	 DWORD PTR h$[rsp], 13
  0019d	74 0a		 je	 SHORT $LN12@s390_load_
  0019f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
  001a7	eb 08		 jmp	 SHORT $LN13@s390_load_
$LN12@s390_load_:
  001a9	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR tv144[rsp], -1
$LN13@s390_load_:
  001b1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  001b9	8b 4c 24 40	 mov	 ecx, DWORD PTR tv144[rsp]
  001bd	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@s390_load_:

; 646  : 
; 647  : } /* end function ARCH_DEP(load_decimal) */

  001bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c4	48 33 cc	 xor	 rcx, rsp
  001c7	e8 00 00 00 00	 call	 __security_check_cookie
  001cc	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001d0	5f		 pop	 rdi
  001d1	c3		 ret	 0
s390_load_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_validate_operand
_TEXT	SEGMENT
tv79 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s390_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN6@s390_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN7@s390_valid
$LN6@s390_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@s390_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 42		 je	 SHORT $LN2@s390_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00092	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00096	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  0009a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 s390_maddr_l
$LN2@s390_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
s390_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchb
_TEXT	SEGMENT
mn$ = 48
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetchb PROC					; COMDAT

; 667  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );
; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s390_maddr_l
  0003e	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
s390_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l
  00043	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00054	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00058	c3		 ret	 0
s390_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b2$ = 76
count$ = 80
sign$ = 84
b1$ = 88
cc$ = 92
tv150 = 96
tv151 = 100
l1$ = 104
l2$ = 108
dec$ = 112
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s390_zero_and_add PROC

; 1341 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1342 : int     l1, l2;                         /* Length values             */
; 1343 : int     b1, b2;                         /* Base register numbers     */
; 1344 : VADR    effective_addr1,
; 1345 :         effective_addr2;                /* Effective addresses       */
; 1346 : int     cc;                             /* Condition code            */
; 1347 : BYTE    dec[MAX_DECIMAL_DIGITS];        /* Work area for operand     */
; 1348 : int     count;                          /* Significant digit counter */
; 1349 : int     sign;                           /* Sign                      */
; 1350 : 
; 1351 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004f	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 4c	 mov	 DWORD PTR b2$[rsp], eax
  0005d	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00069	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006d	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00071	c1 e8 1c	 shr	 eax, 28
  00074	83 e0 0f	 and	 eax, 15
  00077	89 44 24 58	 mov	 DWORD PTR b1$[rsp], eax
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 6c	 mov	 DWORD PTR l2$[rsp], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	c1 f8 04	 sar	 eax, 4
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 68	 mov	 DWORD PTR l1$[rsp], eax
  000b6	83 7c 24 58 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bb	74 3a		 je	 SHORT $LN5@s390_zero_
  000bd	48 63 44 24 58	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d1	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d5	03 c8		 add	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000dd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000eb	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ef	23 c8		 and	 ecx, eax
  000f1	8b c1		 mov	 eax, ecx
  000f3	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s390_zero_:
  000f7	83 7c 24 4c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000fc	74 3a		 je	 SHORT $LN6@s390_zero_
  000fe	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00103	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00112	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00116	03 c8		 add	 ecx, eax
  00118	8b c1		 mov	 eax, ecx
  0011a	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0011e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0012c	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00130	23 c8		 and	 ecx, eax
  00132	8b c1		 mov	 eax, ecx
  00134	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_zero_:
$LN4@s390_zero_:
  00138	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00144	48 83 c0 06	 add	 rax, 6
  00148	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00154	33 c0		 xor	 eax, eax
  00156	83 f8 06	 cmp	 eax, 6
  00159	74 0f		 je	 SHORT $LN7@s390_zero_
  0015b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_zero_:
  0016a	33 c0		 xor	 eax, eax
  0016c	85 c0		 test	 eax, eax
  0016e	75 c8		 jne	 SHORT $LN4@s390_zero_

; 1352 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 1353 :     TXFC_INSTR_CHECK( regs );
; 1354 : 
; 1355 :     /* Load second operand into work area */
; 1356 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec, &count, &sign);

  00170	48 8d 44 24 54	 lea	 rax, QWORD PTR sign$[rsp]
  00175	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0017a	48 8d 44 24 50	 lea	 rax, QWORD PTR count$[rsp]
  0017f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00184	48 8d 44 24 70	 lea	 rax, QWORD PTR dec$[rsp]
  00189	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018e	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00196	44 8b 44 24 4c	 mov	 r8d, DWORD PTR b2$[rsp]
  0019b	8b 54 24 6c	 mov	 edx, DWORD PTR l2$[rsp]
  0019f	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001a3	e8 00 00 00 00	 call	 s390_load_decimal

; 1357 : 
; 1358 :     /* Set condition code */
; 1359 :     cc = (count == 0) ? 0 : (sign < 1) ? 1 : 2;

  001a8	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  001ad	75 0a		 jne	 SHORT $LN14@s390_zero_
  001af	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
  001b7	eb 21		 jmp	 SHORT $LN15@s390_zero_
$LN14@s390_zero_:
  001b9	83 7c 24 54 01	 cmp	 DWORD PTR sign$[rsp], 1
  001be	7d 0a		 jge	 SHORT $LN12@s390_zero_
  001c0	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  001c8	eb 08		 jmp	 SHORT $LN13@s390_zero_
$LN12@s390_zero_:
  001ca	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR tv150[rsp], 2
$LN13@s390_zero_:
  001d2	8b 44 24 60	 mov	 eax, DWORD PTR tv150[rsp]
  001d6	89 44 24 64	 mov	 DWORD PTR tv151[rsp], eax
$LN15@s390_zero_:
  001da	8b 44 24 64	 mov	 eax, DWORD PTR tv151[rsp]
  001de	89 44 24 5c	 mov	 DWORD PTR cc$[rsp], eax

; 1360 : 
; 1361 :     /* Overflow if result exceeds first operand length */
; 1362 :     if (count > (l1+1) * 2 - 1)

  001e2	8b 44 24 68	 mov	 eax, DWORD PTR l1$[rsp]
  001e6	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  001ea	39 44 24 50	 cmp	 DWORD PTR count$[rsp], eax
  001ee	7e 08		 jle	 SHORT $LN8@s390_zero_

; 1363 :         cc = 3;

  001f0	c7 44 24 5c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN8@s390_zero_:

; 1364 : 
; 1365 :     /* Set positive sign if result is zero */
; 1366 :     if (count == 0)

  001f8	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  001fd	75 08		 jne	 SHORT $LN9@s390_zero_

; 1367 :         sign = +1;

  001ff	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN9@s390_zero_:

; 1368 : 
; 1369 :     /* Store result into first operand location */
; 1370 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec, sign);

  00207	8b 44 24 54	 mov	 eax, DWORD PTR sign$[rsp]
  0020b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0020f	48 8d 44 24 70	 lea	 rax, QWORD PTR dec$[rsp]
  00214	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00219	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00221	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  00226	8b 54 24 68	 mov	 edx, DWORD PTR l1$[rsp]
  0022a	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0022e	e8 00 00 00 00	 call	 s390_store_decimal

; 1371 : 
; 1372 :     /* Return condition code */
; 1373 :     regs->psw.cc = cc;

  00233	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023b	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR cc$[rsp]
  00240	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1374 : 
; 1375 :     /* Program check if overflow and PSW program mask is set */
; 1376 :     if (cc == 3 && DOMASK(&regs->psw))

  00243	83 7c 24 5c 03	 cmp	 DWORD PTR cc$[rsp], 3
  00248	75 25		 jne	 SHORT $LN10@s390_zero_
  0024a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00252	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00256	83 e0 04	 and	 eax, 4
  00259	85 c0		 test	 eax, eax
  0025b	74 12		 je	 SHORT $LN10@s390_zero_

; 1377 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  0025d	ba 0a 00 00 00	 mov	 edx, 10
  00262	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026a	e8 00 00 00 00	 call	 s390_program_interrupt
$LN10@s390_zero_:

; 1378 : 
; 1379 : } /* end DEF_INST(zero_and_add) */

  0026f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00277	48 33 cc	 xor	 rcx, rsp
  0027a	e8 00 00 00 00	 call	 __security_check_cookie
  0027f	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00286	c3		 ret	 0
s390_zero_and_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sign3$ = 64
count3$ = 68
effective_addr1$ = 72
effective_addr2$ = 76
temp$1 = 80
sign1$ = 84
b1$ = 88
b2$ = 92
l1$ = 96
cc$ = 100
count1$ = 104
count2$ = 108
sign2$ = 112
tv186 = 116
tv187 = 120
l2$ = 124
dec3$ = 128
dec2$ = 160
dec1$ = 192
__$ArrayPad$ = 224
inst$ = 272
regs$ = 280
s390_subtract_decimal PROC

; 1265 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1266 : int     l1, l2;                         /* Length values             */
; 1267 : int     b1, b2;                         /* Base register numbers     */
; 1268 : VADR    effective_addr1,
; 1269 :         effective_addr2;                /* Effective addresses       */
; 1270 : int     cc;                             /* Condition code            */
; 1271 : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 1272 : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 1273 : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 1274 : int     count1, count2, count3;         /* Significant digit counters*/
; 1275 : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 1276 : 
; 1277 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00025	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002d	48 83 c0 02	 add	 rax, 2
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 fetch_fw_noswap
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 _byteswap_ulong
  00040	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00044	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 0c	 shr	 eax, 12
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 5c	 mov	 DWORD PTR b2$[rsp], eax
  0005f	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 10	 shr	 eax, 16
  00066	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006b	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006f	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00073	c1 e8 1c	 shr	 eax, 28
  00076	83 e0 0f	 and	 eax, 15
  00079	89 44 24 58	 mov	 DWORD PTR b1$[rsp], eax
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	48 6b c0 01	 imul	 rax, rax, 1
  00086	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 7c	 mov	 DWORD PTR l2$[rsp], eax
  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 01	 imul	 rax, rax, 1
  000a2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ae	c1 f8 04	 sar	 eax, 4
  000b1	83 e0 0f	 and	 eax, 15
  000b4	89 44 24 60	 mov	 DWORD PTR l1$[rsp], eax
  000b8	83 7c 24 58 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bd	74 3a		 je	 SHORT $LN5@s390_subtr
  000bf	48 63 44 24 58	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d3	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d7	03 c8		 add	 ecx, eax
  000d9	8b c1		 mov	 eax, ecx
  000db	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000df	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ed	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000f1	23 c8		 and	 ecx, eax
  000f3	8b c1		 mov	 eax, ecx
  000f5	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s390_subtr:
  000f9	83 7c 24 5c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000fe	74 3a		 je	 SHORT $LN6@s390_subtr
  00100	48 63 44 24 5c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00105	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00114	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00118	03 c8		 add	 ecx, eax
  0011a	8b c1		 mov	 eax, ecx
  0011c	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00120	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00128	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0012e	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00132	23 c8		 and	 ecx, eax
  00134	8b c1		 mov	 eax, ecx
  00136	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_subtr:
$LN4@s390_subtr:
  0013a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00142	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00146	48 83 c0 06	 add	 rax, 6
  0014a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00152	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00156	33 c0		 xor	 eax, eax
  00158	83 f8 06	 cmp	 eax, 6
  0015b	74 0f		 je	 SHORT $LN7@s390_subtr
  0015d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_subtr:
  0016c	33 c0		 xor	 eax, eax
  0016e	85 c0		 test	 eax, eax
  00170	75 c8		 jne	 SHORT $LN4@s390_subtr

; 1278 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 1279 :     TXFC_INSTR_CHECK( regs );
; 1280 : 
; 1281 :     /* Load operands into work areas */
; 1282 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00172	48 8d 44 24 54	 lea	 rax, QWORD PTR sign1$[rsp]
  00177	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0017c	48 8d 44 24 68	 lea	 rax, QWORD PTR count1$[rsp]
  00181	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00186	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  0018e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00193	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0019b	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  001a0	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  001a4	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001a8	e8 00 00 00 00	 call	 s390_load_decimal

; 1283 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  001ad	48 8d 44 24 70	 lea	 rax, QWORD PTR sign2$[rsp]
  001b2	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001b7	48 8d 44 24 6c	 lea	 rax, QWORD PTR count2$[rsp]
  001bc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c1	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  001c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ce	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001d6	44 8b 44 24 5c	 mov	 r8d, DWORD PTR b2$[rsp]
  001db	8b 54 24 7c	 mov	 edx, DWORD PTR l2$[rsp]
  001df	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001e3	e8 00 00 00 00	 call	 s390_load_decimal

; 1284 : 
; 1285 :     /* Add or subtract operand values */
; 1286 :     if (count2 == 0)

  001e8	83 7c 24 6c 00	 cmp	 DWORD PTR count2$[rsp], 0
  001ed	75 32		 jne	 SHORT $LN8@s390_subtr

; 1287 :     {
; 1288 :         /* If second operand is zero then result is first operand */
; 1289 :         memcpy (dec3, dec1, MAX_DECIMAL_DIGITS);

  001ef	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  001f7	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  001ff	48 8b f8	 mov	 rdi, rax
  00202	48 8b f1	 mov	 rsi, rcx
  00205	b9 1f 00 00 00	 mov	 ecx, 31
  0020a	f3 a4		 rep movsb

; 1290 :         count3 = count1;

  0020c	8b 44 24 68	 mov	 eax, DWORD PTR count1$[rsp]
  00210	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 1291 :         sign3 = sign1;

  00214	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  00218	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1292 :     }

  0021c	e9 ab 00 00 00	 jmp	 $LN9@s390_subtr
$LN8@s390_subtr:

; 1293 :     else if (count1 == 0)

  00221	83 7c 24 68 00	 cmp	 DWORD PTR count1$[rsp], 0
  00226	75 31		 jne	 SHORT $LN10@s390_subtr

; 1294 :     {
; 1295 :         /* If first operand is zero then result is -second operand */
; 1296 :         memcpy (dec3, dec2, MAX_DECIMAL_DIGITS);

  00228	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00230	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dec2$[rsp]
  00238	48 8b f8	 mov	 rdi, rax
  0023b	48 8b f1	 mov	 rsi, rcx
  0023e	b9 1f 00 00 00	 mov	 ecx, 31
  00243	f3 a4		 rep movsb

; 1297 :         count3 = count2;

  00245	8b 44 24 6c	 mov	 eax, DWORD PTR count2$[rsp]
  00249	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 1298 :         sign3 = -sign2;

  0024d	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  00251	f7 d8		 neg	 eax
  00253	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1299 :     }

  00257	eb 73		 jmp	 SHORT $LN11@s390_subtr
$LN10@s390_subtr:

; 1300 :     else if (sign1 != sign2)

  00259	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  0025d	39 44 24 54	 cmp	 DWORD PTR sign1$[rsp], eax
  00261	74 2c		 je	 SHORT $LN12@s390_subtr

; 1301 :     {
; 1302 :         /* If signs are opposite then add operands */
; 1303 :         add_decimal (dec1, dec2, dec3, &count3);

  00263	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  00268	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  00270	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  00278	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00280	e8 00 00 00 00	 call	 add_decimal

; 1304 :         sign3 = sign1;

  00285	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  00289	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1305 :     }

  0028d	eb 3d		 jmp	 SHORT $LN13@s390_subtr
$LN12@s390_subtr:

; 1306 :     else
; 1307 :     {
; 1308 :         /* If signs are equal then subtract operands */
; 1309 :         subtract_decimal (dec1, dec2, dec3, &count3, &sign3);

  0028f	48 8d 44 24 40	 lea	 rax, QWORD PTR sign3$[rsp]
  00294	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00299	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  0029e	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  002a6	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  002ae	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  002b6	e8 00 00 00 00	 call	 subtract_decimal

; 1310 :         if (sign1 < 0) sign3 = -sign3;

  002bb	83 7c 24 54 00	 cmp	 DWORD PTR sign1$[rsp], 0
  002c0	7d 0a		 jge	 SHORT $LN14@s390_subtr
  002c2	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  002c6	f7 d8		 neg	 eax
  002c8	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax
$LN14@s390_subtr:
$LN13@s390_subtr:
$LN11@s390_subtr:
$LN9@s390_subtr:

; 1311 :     }
; 1312 : 
; 1313 :     /* Set condition code */
; 1314 :     cc = (count3 == 0) ? 0 : (sign3 < 1) ? 1 : 2;

  002cc	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  002d1	75 0a		 jne	 SHORT $LN21@s390_subtr
  002d3	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
  002db	eb 21		 jmp	 SHORT $LN22@s390_subtr
$LN21@s390_subtr:
  002dd	83 7c 24 40 01	 cmp	 DWORD PTR sign3$[rsp], 1
  002e2	7d 0a		 jge	 SHORT $LN19@s390_subtr
  002e4	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv186[rsp], 1
  002ec	eb 08		 jmp	 SHORT $LN20@s390_subtr
$LN19@s390_subtr:
  002ee	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv186[rsp], 2
$LN20@s390_subtr:
  002f6	8b 44 24 74	 mov	 eax, DWORD PTR tv186[rsp]
  002fa	89 44 24 78	 mov	 DWORD PTR tv187[rsp], eax
$LN22@s390_subtr:
  002fe	8b 44 24 78	 mov	 eax, DWORD PTR tv187[rsp]
  00302	89 44 24 64	 mov	 DWORD PTR cc$[rsp], eax

; 1315 : 
; 1316 :     /* Overflow if result exceeds first operand length */
; 1317 :     if (count3 > (l1+1) * 2 - 1)

  00306	8b 44 24 60	 mov	 eax, DWORD PTR l1$[rsp]
  0030a	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0030e	39 44 24 44	 cmp	 DWORD PTR count3$[rsp], eax
  00312	7e 08		 jle	 SHORT $LN15@s390_subtr

; 1318 :         cc = 3;

  00314	c7 44 24 64 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN15@s390_subtr:

; 1319 : 
; 1320 :     /* Set positive sign if result is zero */
; 1321 :     if (count3 == 0)

  0031c	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  00321	75 08		 jne	 SHORT $LN16@s390_subtr

; 1322 :         sign3 = 1;

  00323	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR sign3$[rsp], 1
$LN16@s390_subtr:

; 1323 : 
; 1324 :     /* Store result into first operand location */
; 1325 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  0032b	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  0032f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00333	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  0033b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00340	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00348	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  0034d	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  00351	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00355	e8 00 00 00 00	 call	 s390_store_decimal

; 1326 : 
; 1327 :     /* Return condition code */
; 1328 :     regs->psw.cc = cc;

  0035a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00362	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR cc$[rsp]
  00367	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1329 : 
; 1330 :     /* Program check if overflow and PSW program mask is set */
; 1331 :     if (cc == 3 && DOMASK(&regs->psw))

  0036a	83 7c 24 64 03	 cmp	 DWORD PTR cc$[rsp], 3
  0036f	75 25		 jne	 SHORT $LN17@s390_subtr
  00371	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00379	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  0037d	83 e0 04	 and	 eax, 4
  00380	85 c0		 test	 eax, eax
  00382	74 12		 je	 SHORT $LN17@s390_subtr

; 1332 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  00384	ba 0a 00 00 00	 mov	 edx, 10
  00389	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00391	e8 00 00 00 00	 call	 s390_program_interrupt
$LN17@s390_subtr:

; 1333 : 
; 1334 : } /* end DEF_INST(subtract_decimal) */

  00396	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0039e	48 33 cc	 xor	 rcx, rsp
  003a1	e8 00 00 00 00	 call	 __security_check_cookie
  003a6	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  003ad	5f		 pop	 rdi
  003ae	5e		 pop	 rsi
  003af	c3		 ret	 0
s390_subtract_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
effective_addr2$ = 64
i$ = 68
j$ = 72
d$ = 76
count$ = 80
effective_addr1$ = 84
cc$ = 88
temp$1 = 92
sign$ = 96
b1$ = 100
l1$ = 104
b2$ = 108
tv156 = 112
tv157 = 116
tv175 = 120
i3$ = 124
tv186 = 128
tv196 = 132
carry$ = 136
tv207 = 140
tv208 = 144
dec$ = 152
__$ArrayPad$ = 184
inst$ = 208
regs$ = 216
s390_shift_and_round_decimal PROC

; 1168 : {

$LN36:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1169 : int     l1, i3;                         /* Length and rounding       */
; 1170 : int     b1, b2;                         /* Base register numbers     */
; 1171 : VADR    effective_addr1,
; 1172 :         effective_addr2;                /* Effective addresses       */
; 1173 : int     cc;                             /* Condition code            */
; 1174 : BYTE    dec[MAX_DECIMAL_DIGITS];        /* Work area for operand     */
; 1175 : int     count;                          /* Significant digit counter */
; 1176 : int     sign;                           /* Sign of operand/result    */
; 1177 : int     i, j;                           /* Array subscripts          */
; 1178 : int     d;                              /* Decimal digit             */
; 1179 : int     carry;                          /* Carry indicator           */
; 1180 : 
; 1181 :     SS(inst, regs, l1, i3, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 5c	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 5c	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004f	8b 44 24 5c	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 6c	 mov	 DWORD PTR b2$[rsp], eax
  0005d	8b 44 24 5c	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00069	89 44 24 54	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006d	8b 44 24 5c	 mov	 eax, DWORD PTR temp$1[rsp]
  00071	c1 e8 1c	 shr	 eax, 28
  00074	83 e0 0f	 and	 eax, 15
  00077	89 44 24 64	 mov	 DWORD PTR b1$[rsp], eax
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 7c	 mov	 DWORD PTR i3$[rsp], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	c1 f8 04	 sar	 eax, 4
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 68	 mov	 DWORD PTR l1$[rsp], eax
  000b6	83 7c 24 64 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bb	74 3a		 je	 SHORT $LN11@s390_shift
  000bd	48 63 44 24 64	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d1	8b 4c 24 54	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d5	03 c8		 add	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 54	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000dd	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000eb	8b 4c 24 54	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ef	23 c8		 and	 ecx, eax
  000f1	8b c1		 mov	 eax, ecx
  000f3	89 44 24 54	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN11@s390_shift:
  000f7	83 7c 24 6c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000fc	74 3a		 je	 SHORT $LN12@s390_shift
  000fe	48 63 44 24 6c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00103	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00112	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00116	03 c8		 add	 ecx, eax
  00118	8b c1		 mov	 eax, ecx
  0011a	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0011e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0012c	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00130	23 c8		 and	 ecx, eax
  00132	8b c1		 mov	 eax, ecx
  00134	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN12@s390_shift:
$LN4@s390_shift:
  00138	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00144	48 83 c0 06	 add	 rax, 6
  00148	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00154	33 c0		 xor	 eax, eax
  00156	83 f8 06	 cmp	 eax, 6
  00159	74 0f		 je	 SHORT $LN13@s390_shift
  0015b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@s390_shift:
  0016a	33 c0		 xor	 eax, eax
  0016c	85 c0		 test	 eax, eax
  0016e	75 c8		 jne	 SHORT $LN4@s390_shift

; 1182 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1183 :     TXFC_INSTR_CHECK( regs );
; 1184 : 
; 1185 :     /* Load operand into work area */
; 1186 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec, &count, &sign);

  00170	48 8d 44 24 60	 lea	 rax, QWORD PTR sign$[rsp]
  00175	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0017a	48 8d 44 24 50	 lea	 rax, QWORD PTR count$[rsp]
  0017f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00184	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dec$[rsp]
  0018c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00191	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00199	44 8b 44 24 64	 mov	 r8d, DWORD PTR b1$[rsp]
  0019e	8b 54 24 68	 mov	 edx, DWORD PTR l1$[rsp]
  001a2	8b 4c 24 54	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001a6	e8 00 00 00 00	 call	 s390_load_decimal

; 1187 : 
; 1188 :     /* Program check if rounding digit is invalid */
; 1189 :     if (i3 > 9)

  001ab	83 7c 24 7c 09	 cmp	 DWORD PTR i3$[rsp], 9
  001b0	7e 24		 jle	 SHORT $LN14@s390_shift

; 1190 :     {
; 1191 :         regs->dxc = DXC_DECIMAL;

  001b2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1192 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  001c4	ba 07 00 00 00	 mov	 edx, 7
  001c9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d1	e8 00 00 00 00	 call	 s390_program_interrupt
$LN14@s390_shift:

; 1193 :     }
; 1194 : 
; 1195 :     /* Isolate low-order six bits of shift count */
; 1196 :     effective_addr2 &= 0x3F;

  001d6	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001da	83 e0 3f	 and	 eax, 63			; 0000003fH
  001dd	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax

; 1197 : 
; 1198 :     /* Shift count 0-31 means shift left, 32-63 means shift right */
; 1199 :     if (effective_addr2 < 32)

  001e1	83 7c 24 40 20	 cmp	 DWORD PTR effective_addr2$[rsp], 32 ; 00000020H
  001e6	0f 83 c2 00 00
	00		 jae	 $LN15@s390_shift

; 1200 :     {
; 1201 :         /* Set condition code according to operand sign */
; 1202 :         cc = (count == 0) ? 0 : (sign < 0) ? 1 : 2;

  001ec	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  001f1	75 0a		 jne	 SHORT $LN24@s390_shift
  001f3	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
  001fb	eb 21		 jmp	 SHORT $LN25@s390_shift
$LN24@s390_shift:
  001fd	83 7c 24 60 00	 cmp	 DWORD PTR sign$[rsp], 0
  00202	7d 0a		 jge	 SHORT $LN22@s390_shift
  00204	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
  0020c	eb 08		 jmp	 SHORT $LN23@s390_shift
$LN22@s390_shift:
  0020e	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv156[rsp], 2
$LN23@s390_shift:
  00216	8b 44 24 70	 mov	 eax, DWORD PTR tv156[rsp]
  0021a	89 44 24 74	 mov	 DWORD PTR tv157[rsp], eax
$LN25@s390_shift:
  0021e	8b 44 24 74	 mov	 eax, DWORD PTR tv157[rsp]
  00222	89 44 24 58	 mov	 DWORD PTR cc$[rsp], eax

; 1203 : 
; 1204 :         /* Set cc=3 if non-zero digits will be lost on left shift */
; 1205 :         if (count > 0 && effective_addr2 > (VADR)((l1+1)*2 - 1 - count))

  00226	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  0022b	7e 1a		 jle	 SHORT $LN17@s390_shift
  0022d	8b 44 24 68	 mov	 eax, DWORD PTR l1$[rsp]
  00231	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  00235	2b 44 24 50	 sub	 eax, DWORD PTR count$[rsp]
  00239	39 44 24 40	 cmp	 DWORD PTR effective_addr2$[rsp], eax
  0023d	76 08		 jbe	 SHORT $LN17@s390_shift

; 1206 :             cc = 3;

  0023f	c7 44 24 58 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN17@s390_shift:

; 1207 : 
; 1208 :         /* Shift operand left */
; 1209 :         for (i=0, j=effective_addr2; i < MAX_DECIMAL_DIGITS; i++, j++)

  00247	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0024f	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00253	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
  00257	eb 14		 jmp	 SHORT $LN7@s390_shift
$LN5@s390_shift:
  00259	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  0025d	ff c0		 inc	 eax
  0025f	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
  00263	8b 44 24 48	 mov	 eax, DWORD PTR j$[rsp]
  00267	ff c0		 inc	 eax
  00269	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
$LN7@s390_shift:
  0026d	83 7c 24 44 1f	 cmp	 DWORD PTR i$[rsp], 31
  00272	7d 35		 jge	 SHORT $LN6@s390_shift

; 1210 :             dec[i] = (j < MAX_DECIMAL_DIGITS) ? dec[j] : 0;

  00274	83 7c 24 48 1f	 cmp	 DWORD PTR j$[rsp], 31
  00279	7d 13		 jge	 SHORT $LN26@s390_shift
  0027b	48 63 44 24 48	 movsxd	 rax, DWORD PTR j$[rsp]
  00280	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  00288	89 44 24 78	 mov	 DWORD PTR tv175[rsp], eax
  0028c	eb 08		 jmp	 SHORT $LN27@s390_shift
$LN26@s390_shift:
  0028e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN27@s390_shift:
  00296	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  0029b	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR tv175[rsp]
  002a0	88 8c 04 98 00
	00 00		 mov	 BYTE PTR dec$[rsp+rax], cl
  002a7	eb b0		 jmp	 SHORT $LN5@s390_shift
$LN6@s390_shift:

; 1211 :     }

  002a9	e9 74 01 00 00	 jmp	 $LN16@s390_shift
$LN15@s390_shift:

; 1212 :     else
; 1213 :     {
; 1214 :         /* Calculate number of digits (1-32) to shift right */
; 1215 :         effective_addr2 = 64 - effective_addr2;

  002ae	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  002b3	2b 44 24 40	 sub	 eax, DWORD PTR effective_addr2$[rsp]
  002b7	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax

; 1216 : 
; 1217 :         /* Add the rounding digit to the leftmost of the digits
; 1218 :            to be shifted out and propagate the carry to the left */
; 1219 :         carry = (effective_addr2 > MAX_DECIMAL_DIGITS) ? 0 :

  002bb	83 7c 24 40 1f	 cmp	 DWORD PTR effective_addr2$[rsp], 31
  002c0	76 0d		 jbe	 SHORT $LN28@s390_shift
  002c2	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv186[rsp], 0
  002cd	eb 26		 jmp	 SHORT $LN29@s390_shift
$LN28@s390_shift:
  002cf	b8 1f 00 00 00	 mov	 eax, 31
  002d4	2b 44 24 40	 sub	 eax, DWORD PTR effective_addr2$[rsp]
  002d8	8b c0		 mov	 eax, eax
  002da	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  002e2	03 44 24 7c	 add	 eax, DWORD PTR i3$[rsp]
  002e6	99		 cdq
  002e7	b9 0a 00 00 00	 mov	 ecx, 10
  002ec	f7 f9		 idiv	 ecx
  002ee	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv186[rsp], eax
$LN29@s390_shift:
  002f5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv186[rsp]
  002fc	89 84 24 88 00
	00 00		 mov	 DWORD PTR carry$[rsp], eax

; 1220 :                 (dec[MAX_DECIMAL_DIGITS - effective_addr2] + i3) / 10;
; 1221 :         count = 0;

  00303	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0

; 1222 : 
; 1223 :         /* Shift operand right */
; 1224 :         for (i=MAX_DECIMAL_DIGITS-1, j=MAX_DECIMAL_DIGITS-1-effective_addr2;

  0030b	c7 44 24 44 1e
	00 00 00	 mov	 DWORD PTR i$[rsp], 30
  00313	b8 1e 00 00 00	 mov	 eax, 30
  00318	2b 44 24 40	 sub	 eax, DWORD PTR effective_addr2$[rsp]
  0031c	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
  00320	eb 14		 jmp	 SHORT $LN10@s390_shift
$LN8@s390_shift:

; 1225 :                 i >= 0; i--, j--)

  00322	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00326	ff c8		 dec	 eax
  00328	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
  0032c	8b 44 24 48	 mov	 eax, DWORD PTR j$[rsp]
  00330	ff c8		 dec	 eax
  00332	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
$LN10@s390_shift:
  00336	83 7c 24 44 00	 cmp	 DWORD PTR i$[rsp], 0
  0033b	0f 8c 95 00 00
	00		 jl	 $LN9@s390_shift

; 1226 :         {
; 1227 :             d = (j >= 0) ? dec[j] : 0;

  00341	83 7c 24 48 00	 cmp	 DWORD PTR j$[rsp], 0
  00346	7c 16		 jl	 SHORT $LN30@s390_shift
  00348	48 63 44 24 48	 movsxd	 rax, DWORD PTR j$[rsp]
  0034d	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  00355	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv196[rsp], eax
  0035c	eb 0b		 jmp	 SHORT $LN31@s390_shift
$LN30@s390_shift:
  0035e	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv196[rsp], 0
$LN31@s390_shift:
  00369	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv196[rsp]
  00370	89 44 24 4c	 mov	 DWORD PTR d$[rsp], eax

; 1228 :             d += carry;

  00374	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR carry$[rsp]
  0037b	8b 4c 24 4c	 mov	 ecx, DWORD PTR d$[rsp]
  0037f	03 c8		 add	 ecx, eax
  00381	8b c1		 mov	 eax, ecx
  00383	89 44 24 4c	 mov	 DWORD PTR d$[rsp], eax

; 1229 :             carry = d / 10;

  00387	8b 44 24 4c	 mov	 eax, DWORD PTR d$[rsp]
  0038b	99		 cdq
  0038c	b9 0a 00 00 00	 mov	 ecx, 10
  00391	f7 f9		 idiv	 ecx
  00393	89 84 24 88 00
	00 00		 mov	 DWORD PTR carry$[rsp], eax

; 1230 :             d %= 10;

  0039a	8b 44 24 4c	 mov	 eax, DWORD PTR d$[rsp]
  0039e	99		 cdq
  0039f	b9 0a 00 00 00	 mov	 ecx, 10
  003a4	f7 f9		 idiv	 ecx
  003a6	8b c2		 mov	 eax, edx
  003a8	89 44 24 4c	 mov	 DWORD PTR d$[rsp], eax

; 1231 :             dec[i] = d;

  003ac	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  003b1	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR d$[rsp]
  003b6	88 8c 04 98 00
	00 00		 mov	 BYTE PTR dec$[rsp+rax], cl

; 1232 :             if (d != 0)

  003bd	83 7c 24 4c 00	 cmp	 DWORD PTR d$[rsp], 0
  003c2	74 0d		 je	 SHORT $LN18@s390_shift

; 1233 :                 count = MAX_DECIMAL_DIGITS - i;

  003c4	b8 1f 00 00 00	 mov	 eax, 31
  003c9	2b 44 24 44	 sub	 eax, DWORD PTR i$[rsp]
  003cd	89 44 24 50	 mov	 DWORD PTR count$[rsp], eax
$LN18@s390_shift:

; 1234 :         }

  003d1	e9 4c ff ff ff	 jmp	 $LN8@s390_shift
$LN9@s390_shift:

; 1235 : 
; 1236 :         /* Set condition code according to operand sign */
; 1237 :         cc = (count == 0) ? 0 : (sign < 0) ? 1 : 2;

  003d6	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  003db	75 0d		 jne	 SHORT $LN34@s390_shift
  003dd	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv208[rsp], 0
  003e8	eb 2d		 jmp	 SHORT $LN35@s390_shift
$LN34@s390_shift:
  003ea	83 7c 24 60 00	 cmp	 DWORD PTR sign$[rsp], 0
  003ef	7d 0d		 jge	 SHORT $LN32@s390_shift
  003f1	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv207[rsp], 1
  003fc	eb 0b		 jmp	 SHORT $LN33@s390_shift
$LN32@s390_shift:
  003fe	c7 84 24 8c 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv207[rsp], 2
$LN33@s390_shift:
  00409	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv207[rsp]
  00410	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv208[rsp], eax
$LN35@s390_shift:
  00417	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv208[rsp]
  0041e	89 44 24 58	 mov	 DWORD PTR cc$[rsp], eax
$LN16@s390_shift:

; 1238 :     }
; 1239 : 
; 1240 :     /* Make sign positive if result is zero */
; 1241 :     if (cc == 0)

  00422	83 7c 24 58 00	 cmp	 DWORD PTR cc$[rsp], 0
  00427	75 08		 jne	 SHORT $LN19@s390_shift

; 1242 :         sign = +1;

  00429	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN19@s390_shift:

; 1243 : 
; 1244 :     /* Store result into operand location */
; 1245 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec, sign);

  00431	8b 44 24 60	 mov	 eax, DWORD PTR sign$[rsp]
  00435	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00439	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dec$[rsp]
  00441	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00446	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0044e	44 8b 44 24 64	 mov	 r8d, DWORD PTR b1$[rsp]
  00453	8b 54 24 68	 mov	 edx, DWORD PTR l1$[rsp]
  00457	8b 4c 24 54	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0045b	e8 00 00 00 00	 call	 s390_store_decimal

; 1246 : 
; 1247 :     /* Set condition code */
; 1248 :     regs->psw.cc = cc;

  00460	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00468	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR cc$[rsp]
  0046d	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1249 : 
; 1250 :     /* Program check if overflow and PSW program mask is set */
; 1251 :     if (cc == 3 && DOMASK(&regs->psw))

  00470	83 7c 24 58 03	 cmp	 DWORD PTR cc$[rsp], 3
  00475	75 25		 jne	 SHORT $LN20@s390_shift
  00477	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047f	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00483	83 e0 04	 and	 eax, 4
  00486	85 c0		 test	 eax, eax
  00488	74 12		 je	 SHORT $LN20@s390_shift

; 1252 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  0048a	ba 0a 00 00 00	 mov	 edx, 10
  0048f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00497	e8 00 00 00 00	 call	 s390_program_interrupt
$LN20@s390_shift:

; 1253 : 
; 1254 : } /* end DEF_INST(shift_and_round_decimal) */

  0049c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a4	48 33 cc	 xor	 rcx, rsp
  004a7	e8 00 00 00 00	 call	 __security_check_cookie
  004ac	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  004b3	c3		 ret	 0
s390_shift_and_round_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i2$ = 64
effective_addr1$ = 68
effective_addr2$ = 72
i3$ = 76
temp$1 = 80
l2$ = 84
b1$ = 88
l1$ = 92
b2$ = 96
i1$ = 100
d$ = 104
carry$ = 108
tv202 = 112
count1$ = 116
sign2$ = 120
sign1$ = 124
sign3$ = 128
count2$ = 132
dec3$ = 136
dec2$ = 168
dec1$ = 200
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
s390_multiply_decimal PROC

; 1096 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1097 : int     l1, l2;                         /* Length values             */
; 1098 : int     b1, b2;                         /* Base register numbers     */
; 1099 : VADR    effective_addr1,
; 1100 :         effective_addr2;                /* Effective addresses       */
; 1101 : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 1102 : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 1103 : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 1104 : int     count1, count2;                 /* Significant digit counters*/
; 1105 : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 1106 : int     d;                              /* Decimal digit             */
; 1107 : int     i1, i2, i3;                     /* Array subscripts          */
; 1108 : int     carry;                          /* Carry indicator           */
; 1109 : 
; 1110 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00024	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002c	48 83 c0 02	 add	 rax, 2
  00030	48 8b c8	 mov	 rcx, rax
  00033	e8 00 00 00 00	 call	 fetch_fw_noswap
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 _byteswap_ulong
  0003f	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00043	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00050	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 0c	 shr	 eax, 12
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 60	 mov	 DWORD PTR b2$[rsp], eax
  0005e	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 10	 shr	 eax, 16
  00065	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006a	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006e	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00072	c1 e8 1c	 shr	 eax, 28
  00075	83 e0 0f	 and	 eax, 15
  00078	89 44 24 58	 mov	 DWORD PTR b1$[rsp], eax
  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	48 6b c0 01	 imul	 rax, rax, 1
  00085	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00091	83 e0 0f	 and	 eax, 15
  00094	89 44 24 54	 mov	 DWORD PTR l2$[rsp], eax
  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	48 6b c0 01	 imul	 rax, rax, 1
  000a1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ad	c1 f8 04	 sar	 eax, 4
  000b0	83 e0 0f	 and	 eax, 15
  000b3	89 44 24 5c	 mov	 DWORD PTR l1$[rsp], eax
  000b7	83 7c 24 58 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bc	74 3a		 je	 SHORT $LN11@s390_multi
  000be	48 63 44 24 58	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d2	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d6	03 c8		 add	 ecx, eax
  000d8	8b c1		 mov	 eax, ecx
  000da	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000de	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ec	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000f0	23 c8		 and	 ecx, eax
  000f2	8b c1		 mov	 eax, ecx
  000f4	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN11@s390_multi:
  000f8	83 7c 24 60 00	 cmp	 DWORD PTR b2$[rsp], 0
  000fd	74 3a		 je	 SHORT $LN12@s390_multi
  000ff	48 63 44 24 60	 movsxd	 rax, DWORD PTR b2$[rsp]
  00104	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00113	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00117	03 c8		 add	 ecx, eax
  00119	8b c1		 mov	 eax, ecx
  0011b	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0011f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00127	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0012d	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00131	23 c8		 and	 ecx, eax
  00133	8b c1		 mov	 eax, ecx
  00135	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN12@s390_multi:
$LN4@s390_multi:
  00139	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00141	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00145	48 83 c0 06	 add	 rax, 6
  00149	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00155	33 c0		 xor	 eax, eax
  00157	83 f8 06	 cmp	 eax, 6
  0015a	74 0f		 je	 SHORT $LN13@s390_multi
  0015c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00164	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@s390_multi:
  0016b	33 c0		 xor	 eax, eax
  0016d	85 c0		 test	 eax, eax
  0016f	75 c8		 jne	 SHORT $LN4@s390_multi

; 1111 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 1112 :     TXFC_INSTR_CHECK( regs );
; 1113 : 
; 1114 :     /* Program check if the second operand length exceeds 15 digits
; 1115 :        or is equal to or greater than the first operand length */
; 1116 :     if (l2 > 7 || l2 >= l1)

  00171	83 7c 24 54 07	 cmp	 DWORD PTR l2$[rsp], 7
  00176	7f 0a		 jg	 SHORT $LN15@s390_multi
  00178	8b 44 24 5c	 mov	 eax, DWORD PTR l1$[rsp]
  0017c	39 44 24 54	 cmp	 DWORD PTR l2$[rsp], eax
  00180	7c 12		 jl	 SHORT $LN14@s390_multi
$LN15@s390_multi:

; 1117 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00182	ba 06 00 00 00	 mov	 edx, 6
  00187	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	e8 00 00 00 00	 call	 s390_program_interrupt
$LN14@s390_multi:

; 1118 : 
; 1119 :     /* Load operands into work areas */
; 1120 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00194	48 8d 44 24 7c	 lea	 rax, QWORD PTR sign1$[rsp]
  00199	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0019e	48 8d 44 24 74	 lea	 rax, QWORD PTR count1$[rsp]
  001a3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a8	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  001b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b5	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001bd	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  001c2	8b 54 24 5c	 mov	 edx, DWORD PTR l1$[rsp]
  001c6	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001ca	e8 00 00 00 00	 call	 s390_load_decimal

; 1121 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  001cf	48 8d 44 24 78	 lea	 rax, QWORD PTR sign2$[rsp]
  001d4	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001d9	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR count2$[rsp]
  001e1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e6	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  001ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f3	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001fb	44 8b 44 24 60	 mov	 r8d, DWORD PTR b2$[rsp]
  00200	8b 54 24 54	 mov	 edx, DWORD PTR l2$[rsp]
  00204	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00208	e8 00 00 00 00	 call	 s390_load_decimal

; 1122 : 
; 1123 :     /* Program check if the number of bytes in the second operand
; 1124 :        is less than the number of bytes of high-order zeroes in the
; 1125 :        first operand; this ensures that overflow cannot occur */
; 1126 :     if (l2 > l1 - (count1/2 + 1))

  0020d	8b 44 24 74	 mov	 eax, DWORD PTR count1$[rsp]
  00211	99		 cdq
  00212	2b c2		 sub	 eax, edx
  00214	d1 f8		 sar	 eax, 1
  00216	ff c0		 inc	 eax
  00218	8b 4c 24 5c	 mov	 ecx, DWORD PTR l1$[rsp]
  0021c	2b c8		 sub	 ecx, eax
  0021e	8b c1		 mov	 eax, ecx
  00220	39 44 24 54	 cmp	 DWORD PTR l2$[rsp], eax
  00224	7e 24		 jle	 SHORT $LN16@s390_multi

; 1127 :     {
; 1128 :         regs->dxc = DXC_DECIMAL;

  00226	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022e	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1129 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00238	ba 07 00 00 00	 mov	 edx, 7
  0023d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00245	e8 00 00 00 00	 call	 s390_program_interrupt
$LN16@s390_multi:

; 1130 :     }
; 1131 : 
; 1132 :     /* Clear the result field */
; 1133 :     memset( dec3, 0, MAX_DECIMAL_DIGITS );

  0024a	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00252	48 8b f8	 mov	 rdi, rax
  00255	33 c0		 xor	 eax, eax
  00257	b9 1f 00 00 00	 mov	 ecx, 31
  0025c	f3 aa		 rep stosb

; 1134 : 
; 1135 :     /* Perform decimal multiplication */
; 1136 :     for (i2 = MAX_DECIMAL_DIGITS-1; i2 >= 0; i2--)

  0025e	c7 44 24 40 1e
	00 00 00	 mov	 DWORD PTR i2$[rsp], 30
  00266	eb 0a		 jmp	 SHORT $LN7@s390_multi
$LN5@s390_multi:
  00268	8b 44 24 40	 mov	 eax, DWORD PTR i2$[rsp]
  0026c	ff c8		 dec	 eax
  0026e	89 44 24 40	 mov	 DWORD PTR i2$[rsp], eax
$LN7@s390_multi:
  00272	83 7c 24 40 00	 cmp	 DWORD PTR i2$[rsp], 0
  00277	0f 8c b3 00 00
	00		 jl	 $LN6@s390_multi

; 1137 :     {
; 1138 :         if (dec2[i2] != 0)

  0027d	48 63 44 24 40	 movsxd	 rax, DWORD PTR i2$[rsp]
  00282	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR dec2$[rsp+rax]
  0028a	85 c0		 test	 eax, eax
  0028c	0f 84 99 00 00
	00		 je	 $LN17@s390_multi

; 1139 :         {
; 1140 :             for (i1 = MAX_DECIMAL_DIGITS - 1, i3 = i2, carry = 0;

  00292	c7 44 24 64 1e
	00 00 00	 mov	 DWORD PTR i1$[rsp], 30
  0029a	8b 44 24 40	 mov	 eax, DWORD PTR i2$[rsp]
  0029e	89 44 24 4c	 mov	 DWORD PTR i3$[rsp], eax
  002a2	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0
  002aa	eb 14		 jmp	 SHORT $LN10@s390_multi
$LN8@s390_multi:

; 1141 :                         i3 >= 0; i1--, i3--)

  002ac	8b 44 24 64	 mov	 eax, DWORD PTR i1$[rsp]
  002b0	ff c8		 dec	 eax
  002b2	89 44 24 64	 mov	 DWORD PTR i1$[rsp], eax
  002b6	8b 44 24 4c	 mov	 eax, DWORD PTR i3$[rsp]
  002ba	ff c8		 dec	 eax
  002bc	89 44 24 4c	 mov	 DWORD PTR i3$[rsp], eax
$LN10@s390_multi:
  002c0	83 7c 24 4c 00	 cmp	 DWORD PTR i3$[rsp], 0
  002c5	7c 64		 jl	 SHORT $LN9@s390_multi

; 1142 :             {
; 1143 :                 d = carry + dec1[i1]*dec2[i2] + dec3[i3];

  002c7	48 63 44 24 64	 movsxd	 rax, DWORD PTR i1$[rsp]
  002cc	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR dec1$[rsp+rax]
  002d4	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i2$[rsp]
  002d9	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR dec2$[rsp+rcx]
  002e1	0f af c1	 imul	 eax, ecx
  002e4	8b 4c 24 6c	 mov	 ecx, DWORD PTR carry$[rsp]
  002e8	03 c8		 add	 ecx, eax
  002ea	8b c1		 mov	 eax, ecx
  002ec	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR i3$[rsp]
  002f1	0f b6 8c 0c 88
	00 00 00	 movzx	 ecx, BYTE PTR dec3$[rsp+rcx]
  002f9	03 c1		 add	 eax, ecx
  002fb	89 44 24 68	 mov	 DWORD PTR d$[rsp], eax

; 1144 :                 dec3[i3] = d % 10;

  002ff	8b 44 24 68	 mov	 eax, DWORD PTR d$[rsp]
  00303	99		 cdq
  00304	b9 0a 00 00 00	 mov	 ecx, 10
  00309	f7 f9		 idiv	 ecx
  0030b	8b c2		 mov	 eax, edx
  0030d	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR i3$[rsp]
  00312	88 84 0c 88 00
	00 00		 mov	 BYTE PTR dec3$[rsp+rcx], al

; 1145 :                 carry = d / 10;

  00319	8b 44 24 68	 mov	 eax, DWORD PTR d$[rsp]
  0031d	99		 cdq
  0031e	b9 0a 00 00 00	 mov	 ecx, 10
  00323	f7 f9		 idiv	 ecx
  00325	89 44 24 6c	 mov	 DWORD PTR carry$[rsp], eax

; 1146 :             }

  00329	eb 81		 jmp	 SHORT $LN8@s390_multi
$LN9@s390_multi:
$LN17@s390_multi:

; 1147 :         }
; 1148 :     } /* end for(i2) */

  0032b	e9 38 ff ff ff	 jmp	 $LN5@s390_multi
$LN6@s390_multi:

; 1149 : 
; 1150 :     /* Result is positive if operand signs are equal, and negative
; 1151 :        if operand signs are opposite, even if result is zero */
; 1152 :     sign3 = (sign1 == sign2) ? 1 : -1;

  00330	8b 44 24 78	 mov	 eax, DWORD PTR sign2$[rsp]
  00334	39 44 24 7c	 cmp	 DWORD PTR sign1$[rsp], eax
  00338	75 0a		 jne	 SHORT $LN19@s390_multi
  0033a	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  00342	eb 08		 jmp	 SHORT $LN20@s390_multi
$LN19@s390_multi:
  00344	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR tv202[rsp], -1
$LN20@s390_multi:
  0034c	8b 44 24 70	 mov	 eax, DWORD PTR tv202[rsp]
  00350	89 84 24 80 00
	00 00		 mov	 DWORD PTR sign3$[rsp], eax

; 1153 : 
; 1154 :     /* Store result into first operand location */
; 1155 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  00357	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR sign3$[rsp]
  0035e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00362	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  0036a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0036f	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00377	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  0037c	8b 54 24 5c	 mov	 edx, DWORD PTR l1$[rsp]
  00380	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00384	e8 00 00 00 00	 call	 s390_store_decimal

; 1156 : 
; 1157 : } /* end DEF_INST(multiply_decimal) */

  00389	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00391	48 33 cc	 xor	 rcx, rsp
  00394	e8 00 00 00 00	 call	 __security_check_cookie
  00399	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  003a0	5f		 pop	 rdi
  003a1	c3		 ret	 0
s390_multiply_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sbyte$ = 48
pbyte$ = 49
fbyte$ = 50
addr1$ = 52
b1$ = 56
trial_run$ = 60
effective_addr1$ = 64
sig$ = 68
rbyte$ = 72
effective_addr2$ = 76
h$ = 80
cc$ = 84
addr2$ = 88
d$ = 92
temp$1 = 96
l$ = 100
i$ = 104
b2$ = 108
tv210 = 112
inst$ = 144
regs$ = 152
s390_edit_x_edit_and_mark PROC

; 903  : {

$LN48:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 904  : int     l;                              /* Length value              */
; 905  : int     b1, b2;                         /* Base register numbers     */
; 906  : VADR    effective_addr1,
; 907  :         effective_addr2,                /* Effective addresses       */
; 908  :         addr1,
; 909  :         addr2;
; 910  : int     cc = 0;                         /* Condition code            */

  00011	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 911  : int     sig = 0;                        /* Significance indicator    */

  00019	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 912  : int     trial_run;                      /* 1=trial run               */
; 913  : int     i;                              /* Loop counter              */
; 914  : int     d;                              /* 1=Use right source digit  */
; 915  : int     h;                              /* Hexadecimal digit         */
; 916  : BYTE    sbyte;                          /* Source operand byte       */
; 917  : BYTE    fbyte;                          /* Fill byte                 */
; 918  : BYTE    pbyte;                          /* Pattern byte              */
; 919  : BYTE    rbyte;                          /* Result byte               */
; 920  : 
; 921  :     SS_L(inst, regs, l, b1, effective_addr1, b2, effective_addr2);

  00021	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00029	48 83 c0 02	 add	 rax, 2
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 fetch_fw_noswap
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 _byteswap_ulong
  0003c	89 44 24 60	 mov	 DWORD PTR temp$1[rsp], eax
  00040	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00049	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004d	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 0c	 shr	 eax, 12
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 6c	 mov	 DWORD PTR b2$[rsp], eax
  0005b	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 10	 shr	 eax, 16
  00062	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00067	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006b	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  0006f	c1 e8 1c	 shr	 eax, 28
  00072	83 e0 0f	 and	 eax, 15
  00075	89 44 24 38	 mov	 DWORD PTR b1$[rsp], eax
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 01	 imul	 rax, rax, 1
  00082	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008e	89 44 24 64	 mov	 DWORD PTR l$[rsp], eax
  00092	83 7c 24 38 00	 cmp	 DWORD PTR b1$[rsp], 0
  00097	74 3a		 je	 SHORT $LN11@s390_edit_
  00099	48 63 44 24 38	 movsxd	 rax, DWORD PTR b1$[rsp]
  0009e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ad	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000b1	03 c8		 add	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000b9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000c7	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000cb	23 c8		 and	 ecx, eax
  000cd	8b c1		 mov	 eax, ecx
  000cf	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN11@s390_edit_:
  000d3	83 7c 24 6c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000d8	74 3a		 je	 SHORT $LN12@s390_edit_
  000da	48 63 44 24 6c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ee	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f2	03 c8		 add	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000fa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00108	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0010c	23 c8		 and	 ecx, eax
  0010e	8b c1		 mov	 eax, ecx
  00110	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN12@s390_edit_:
$LN4@s390_edit_:
  00114	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00120	48 83 c0 06	 add	 rax, 6
  00124	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00130	33 c0		 xor	 eax, eax
  00132	83 f8 06	 cmp	 eax, 6
  00135	74 0f		 je	 SHORT $LN13@s390_edit_
  00137	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@s390_edit_:
  00146	33 c0		 xor	 eax, eax
  00148	85 c0		 test	 eax, eax
  0014a	75 c8		 jne	 SHORT $LN4@s390_edit_

; 922  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 923  :     TXFC_INSTR_CHECK( regs );
; 924  : 
; 925  :     /* If addr1 crosses page, make sure both pages are accessible */
; 926  :     if((effective_addr1 & PAGEFRAME_PAGEMASK) !=

  0014c	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00150	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00155	8b 4c 24 64	 mov	 ecx, DWORD PTR l$[rsp]
  00159	8b 54 24 40	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  0015d	03 d1		 add	 edx, ecx
  0015f	8b ca		 mov	 ecx, edx
  00161	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00167	3b c1		 cmp	 eax, ecx
  00169	74 25		 je	 SHORT $LN14@s390_edit_

; 927  :         ((effective_addr1 + l) & PAGEFRAME_PAGEMASK))
; 928  :         ARCH_DEP(validate_operand) (effective_addr1, b1, l, ACCTYPE_WRITE_SKP, regs);

  0016b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00178	41 b9 01 00 00
	00		 mov	 r9d, 1
  0017e	44 8b 44 24 64	 mov	 r8d, DWORD PTR l$[rsp]
  00183	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00187	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0018b	e8 00 00 00 00	 call	 s390_validate_operand
$LN14@s390_edit_:

; 929  : 
; 930  :     /* If addr2 might cross page, do a trial run to catch possible access rupts */
; 931  :     if((effective_addr2 & PAGEFRAME_PAGEMASK) !=

  00190	8b 44 24 4c	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00194	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00199	8b 4c 24 64	 mov	 ecx, DWORD PTR l$[rsp]
  0019d	8b 54 24 4c	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  001a1	03 d1		 add	 edx, ecx
  001a3	8b ca		 mov	 ecx, edx
  001a5	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  001ab	3b c1		 cmp	 eax, ecx
  001ad	74 0a		 je	 SHORT $LN15@s390_edit_

; 932  :         ((effective_addr2 + l) & PAGEFRAME_PAGEMASK))
; 933  :         trial_run = 1;

  001af	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR trial_run$[rsp], 1
  001b7	eb 08		 jmp	 SHORT $LN16@s390_edit_
$LN15@s390_edit_:

; 934  :     else
; 935  :         trial_run = 0;

  001b9	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR trial_run$[rsp], 0
$LN16@s390_edit_:

; 936  : 
; 937  :     for(;trial_run >= 0; trial_run--)

  001c1	eb 0a		 jmp	 SHORT $LN7@s390_edit_
$LN5@s390_edit_:
  001c3	8b 44 24 3c	 mov	 eax, DWORD PTR trial_run$[rsp]
  001c7	ff c8		 dec	 eax
  001c9	89 44 24 3c	 mov	 DWORD PTR trial_run$[rsp], eax
$LN7@s390_edit_:
  001cd	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  001d2	0f 8c ef 03 00
	00		 jl	 $LN6@s390_edit_

; 938  :     {
; 939  :         /* Initialize variables */
; 940  :         addr1 = effective_addr1;

  001d8	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  001dc	89 44 24 34	 mov	 DWORD PTR addr1$[rsp], eax

; 941  :         addr2 = effective_addr2;

  001e0	8b 44 24 4c	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001e4	89 44 24 58	 mov	 DWORD PTR addr2$[rsp], eax

; 942  :         cc = 0;

  001e8	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 943  :         sig = 0;

  001f0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 944  :         sbyte = 0;

  001f8	c6 44 24 30 00	 mov	 BYTE PTR sbyte$[rsp], 0

; 945  :         fbyte = 0;

  001fd	c6 44 24 32 00	 mov	 BYTE PTR fbyte$[rsp], 0

; 946  : 
; 947  :         /* Process first operand from left to right */
; 948  :         for (i = 0, d = 0; i < l+1; i++)

  00202	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0020a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
  00212	eb 0a		 jmp	 SHORT $LN10@s390_edit_
$LN8@s390_edit_:
  00214	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00218	ff c0		 inc	 eax
  0021a	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_edit_:
  0021e	8b 44 24 64	 mov	 eax, DWORD PTR l$[rsp]
  00222	ff c0		 inc	 eax
  00224	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00228	0f 8d 94 03 00
	00		 jge	 $LN9@s390_edit_

; 949  :         {
; 950  :             /* Fetch pattern byte from first operand */
; 951  :             pbyte = ARCH_DEP(vfetchb) ( addr1, b1, regs );

  0022e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00236	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  0023a	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  0023e	e8 00 00 00 00	 call	 s390_vfetchb
  00243	88 44 24 31	 mov	 BYTE PTR pbyte$[rsp], al

; 952  : 
; 953  :             /* The first pattern byte is also the fill byte */
; 954  :             if (i == 0) fbyte = pbyte;

  00247	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  0024c	75 09		 jne	 SHORT $LN17@s390_edit_
  0024e	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00253	88 44 24 32	 mov	 BYTE PTR fbyte$[rsp], al
$LN17@s390_edit_:

; 955  : 
; 956  :             /* If pattern byte is digit selector (X'20') or
; 957  :                significance starter (X'21') then fetch next
; 958  :                hexadecimal digit from the second operand */
; 959  :             if (pbyte == 0x20 || pbyte == 0x21)

  00257	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  0025c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0025f	74 0e		 je	 SHORT $LN20@s390_edit_
  00261	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00266	83 f8 21	 cmp	 eax, 33			; 00000021H
  00269	0f 85 2d 02 00
	00		 jne	 $LN18@s390_edit_
$LN20@s390_edit_:

; 960  :             {
; 961  :                 if (d == 0)

  0026f	83 7c 24 5c 00	 cmp	 DWORD PTR d$[rsp], 0
  00274	0f 85 8a 00 00
	00		 jne	 $LN21@s390_edit_

; 962  :                 {
; 963  :                     /* Fetch source byte and extract left digit */
; 964  :                     sbyte = ARCH_DEP(vfetchb) ( addr2, b2, regs );

  0027a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00282	8b 54 24 6c	 mov	 edx, DWORD PTR b2$[rsp]
  00286	8b 4c 24 58	 mov	 ecx, DWORD PTR addr2$[rsp]
  0028a	e8 00 00 00 00	 call	 s390_vfetchb
  0028f	88 44 24 30	 mov	 BYTE PTR sbyte$[rsp], al

; 965  :                     h = sbyte >> 4;

  00293	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00298	c1 f8 04	 sar	 eax, 4
  0029b	89 44 24 50	 mov	 DWORD PTR h$[rsp], eax

; 966  :                     sbyte &= 0x0F;

  0029f	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  002a4	83 e0 0f	 and	 eax, 15
  002a7	88 44 24 30	 mov	 BYTE PTR sbyte$[rsp], al

; 967  :                     d = 1;

  002ab	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR d$[rsp], 1

; 968  : 
; 969  :                     /* Increment second operand address */
; 970  :                     addr2++;

  002b3	8b 44 24 58	 mov	 eax, DWORD PTR addr2$[rsp]
  002b7	ff c0		 inc	 eax
  002b9	89 44 24 58	 mov	 DWORD PTR addr2$[rsp], eax

; 971  :                     addr2 &= ADDRESS_MAXWRAP(regs);

  002bd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c5	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  002cb	8b 4c 24 58	 mov	 ecx, DWORD PTR addr2$[rsp]
  002cf	23 c8		 and	 ecx, eax
  002d1	8b c1		 mov	 eax, ecx
  002d3	89 44 24 58	 mov	 DWORD PTR addr2$[rsp], eax

; 972  : 
; 973  :                     /* Program check if left digit is not numeric */
; 974  :                     if (h > 9)

  002d7	83 7c 24 50 09	 cmp	 DWORD PTR h$[rsp], 9
  002dc	7e 24		 jle	 SHORT $LN23@s390_edit_

; 975  :                     {
; 976  :                         regs->dxc = DXC_DECIMAL;

  002de	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e6	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 977  :                         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002f0	ba 07 00 00 00	 mov	 edx, 7
  002f5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fd	e8 00 00 00 00	 call	 s390_program_interrupt
$LN23@s390_edit_:

; 978  :                     }
; 979  : 
; 980  :                 }

  00302	eb 11		 jmp	 SHORT $LN22@s390_edit_
$LN21@s390_edit_:

; 981  :                 else
; 982  :                 {
; 983  :                     /* Use right digit of source byte */
; 984  :                     h = sbyte;

  00304	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00309	89 44 24 50	 mov	 DWORD PTR h$[rsp], eax

; 985  :                     d = 0;

  0030d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
$LN22@s390_edit_:

; 986  :                 }
; 987  : 
; 988  :                 /* For the EDMK instruction only, insert address of
; 989  :                    result byte into general register 1 if the digit
; 990  :                    is non-zero and significance indicator was off */
; 991  :                 if (!trial_run && (inst[0] == 0xDF) && h > 0 && sig == 0)

  00315	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  0031a	0f 85 a4 00 00
	00		 jne	 $LN24@s390_edit_
  00320	b8 01 00 00 00	 mov	 eax, 1
  00325	48 6b c0 00	 imul	 rax, rax, 0
  00329	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00331	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00335	3d df 00 00 00	 cmp	 eax, 223		; 000000dfH
  0033a	0f 85 84 00 00
	00		 jne	 $LN24@s390_edit_
  00340	83 7c 24 50 00	 cmp	 DWORD PTR h$[rsp], 0
  00345	7e 7d		 jle	 SHORT $LN24@s390_edit_
  00347	83 7c 24 44 00	 cmp	 DWORD PTR sig$[rsp], 0
  0034c	75 76		 jne	 SHORT $LN24@s390_edit_

; 992  :                 {
; 993  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 994  :                     if (regs->psw.amode64)
; 995  :                         regs->GR_G(1) = addr1;
; 996  :                     else
; 997  : #endif
; 998  :                     if ( regs->psw.amode )

  0034e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00356	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0035c	d1 e8		 shr	 eax, 1
  0035e	83 e0 01	 and	 eax, 1
  00361	85 c0		 test	 eax, eax
  00363	74 1e		 je	 SHORT $LN25@s390_edit_

; 999  :                         regs->GR_L(1) = addr1;

  00365	b8 08 00 00 00	 mov	 eax, 8
  0036a	48 6b c0 01	 imul	 rax, rax, 1
  0036e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00376	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  0037a	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
  00381	eb 41		 jmp	 SHORT $LN26@s390_edit_
$LN25@s390_edit_:

; 1000 :                     else
; 1001 :                         regs->GR_LA24(1) = addr1;

  00383	b8 08 00 00 00	 mov	 eax, 8
  00388	48 6b c0 01	 imul	 rax, rax, 1
  0038c	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  00390	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00396	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0039e	8b 84 02 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+640]
  003a5	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  003aa	0b c1		 or	 eax, ecx
  003ac	b9 08 00 00 00	 mov	 ecx, 8
  003b1	48 6b c9 01	 imul	 rcx, rcx, 1
  003b5	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003bd	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax
$LN26@s390_edit_:
$LN24@s390_edit_:

; 1002 :                 }
; 1003 : 
; 1004 :                 /* Replace the pattern byte by the fill character
; 1005 :                    or by a zoned decimal digit */
; 1006 :                 rbyte = (sig == 0 && h == 0) ? fbyte : (0xF0 | h);

  003c4	83 7c 24 44 00	 cmp	 DWORD PTR sig$[rsp], 0
  003c9	75 12		 jne	 SHORT $LN46@s390_edit_
  003cb	83 7c 24 50 00	 cmp	 DWORD PTR h$[rsp], 0
  003d0	75 0b		 jne	 SHORT $LN46@s390_edit_
  003d2	0f b6 44 24 32	 movzx	 eax, BYTE PTR fbyte$[rsp]
  003d7	89 44 24 70	 mov	 DWORD PTR tv210[rsp], eax
  003db	eb 0d		 jmp	 SHORT $LN47@s390_edit_
$LN46@s390_edit_:
  003dd	8b 44 24 50	 mov	 eax, DWORD PTR h$[rsp]
  003e1	0d f0 00 00 00	 or	 eax, 240		; 000000f0H
  003e6	89 44 24 70	 mov	 DWORD PTR tv210[rsp], eax
$LN47@s390_edit_:
  003ea	0f b6 44 24 70	 movzx	 eax, BYTE PTR tv210[rsp]
  003ef	88 44 24 48	 mov	 BYTE PTR rbyte$[rsp], al

; 1007 :                 if(!trial_run)

  003f3	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  003f8	75 1d		 jne	 SHORT $LN27@s390_edit_

; 1008 :                     ARCH_DEP(vstoreb) ( rbyte, addr1, b1, regs );

  003fa	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00402	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  00407	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  0040b	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR rbyte$[rsp]
  00410	e8 00 00 00 00	 call	 s390_vstoreb
  00415	eb 23		 jmp	 SHORT $LN28@s390_edit_
$LN27@s390_edit_:

; 1009 :                 else
; 1010 :                     ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  00417	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00424	41 b9 01 00 00
	00		 mov	 r9d, 1
  0042a	45 33 c0	 xor	 r8d, r8d
  0042d	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00431	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  00435	e8 00 00 00 00	 call	 s390_validate_operand
$LN28@s390_edit_:

; 1011 : 
; 1012 :                 /* Set condition code 2 if digit is non-zero */
; 1013 :                 if (h > 0) cc = 2;

  0043a	83 7c 24 50 00	 cmp	 DWORD PTR h$[rsp], 0
  0043f	7e 08		 jle	 SHORT $LN29@s390_edit_
  00441	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN29@s390_edit_:

; 1014 : 
; 1015 :                 /* Turn on significance indicator if pattern
; 1016 :                    byte is significance starter or if source
; 1017 :                    digit is non-zero */
; 1018 :                 if (pbyte == 0x21 || h > 0)

  00449	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  0044e	83 f8 21	 cmp	 eax, 33			; 00000021H
  00451	74 07		 je	 SHORT $LN31@s390_edit_
  00453	83 7c 24 50 00	 cmp	 DWORD PTR h$[rsp], 0
  00458	7e 08		 jle	 SHORT $LN30@s390_edit_
$LN31@s390_edit_:

; 1019 :                     sig = 1;

  0045a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR sig$[rsp], 1
$LN30@s390_edit_:

; 1020 : 
; 1021 :                 /* Examine right digit for sign code */
; 1022 :                 if (d == 1 && sbyte > 9)

  00462	83 7c 24 5c 01	 cmp	 DWORD PTR d$[rsp], 1
  00467	75 2e		 jne	 SHORT $LN32@s390_edit_
  00469	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  0046e	83 f8 09	 cmp	 eax, 9
  00471	7e 24		 jle	 SHORT $LN32@s390_edit_

; 1023 :                 {
; 1024 :                     /* Turn off the significance indicator if
; 1025 :                        the right digit is a plus sign code */
; 1026 :                     if (sbyte != 0x0B && sbyte != 0x0D)

  00473	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00478	83 f8 0b	 cmp	 eax, 11
  0047b	74 12		 je	 SHORT $LN33@s390_edit_
  0047d	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00482	83 f8 0d	 cmp	 eax, 13
  00485	74 08		 je	 SHORT $LN33@s390_edit_

; 1027 :                         sig = 0;

  00487	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0
$LN33@s390_edit_:

; 1028 : 
; 1029 :                     /* Take next digit from next source byte */
; 1030 :                     d = 0;

  0048f	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
$LN32@s390_edit_:

; 1031 :                 }
; 1032 :             }

  00497	e9 fd 00 00 00	 jmp	 $LN19@s390_edit_
$LN18@s390_edit_:

; 1033 : 
; 1034 :             /* If pattern byte is field separator (X'22') then
; 1035 :                replace it by the fill character, turn off the
; 1036 :                significance indicator, and zeroize conditon code  */
; 1037 :             else if (pbyte == 0x22)

  0049c	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  004a1	83 f8 22	 cmp	 eax, 34			; 00000022H
  004a4	75 5c		 jne	 SHORT $LN34@s390_edit_

; 1038 :             {
; 1039 :                 if(!trial_run)

  004a6	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  004ab	75 1d		 jne	 SHORT $LN36@s390_edit_

; 1040 :                     ARCH_DEP(vstoreb) ( fbyte, addr1, b1, regs );

  004ad	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004b5	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  004ba	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  004be	0f b6 4c 24 32	 movzx	 ecx, BYTE PTR fbyte$[rsp]
  004c3	e8 00 00 00 00	 call	 s390_vstoreb
  004c8	eb 23		 jmp	 SHORT $LN37@s390_edit_
$LN36@s390_edit_:

; 1041 :                 else
; 1042 :                     ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  004ca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d7	41 b9 01 00 00
	00		 mov	 r9d, 1
  004dd	45 33 c0	 xor	 r8d, r8d
  004e0	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  004e4	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  004e8	e8 00 00 00 00	 call	 s390_validate_operand
$LN37@s390_edit_:

; 1043 :                 sig = 0;

  004ed	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 1044 :                 cc = 0;

  004f5	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1045 :             }

  004fd	e9 97 00 00 00	 jmp	 $LN35@s390_edit_
$LN34@s390_edit_:

; 1046 : 
; 1047 :             /* If pattern byte is a message byte (anything other
; 1048 :                than X'20', X'21', or X'22') then replace it by
; 1049 :                the fill byte if the significance indicator is off */
; 1050 :             else
; 1051 :             {
; 1052 :                 if (sig == 0)

  00502	83 7c 24 44 00	 cmp	 DWORD PTR sig$[rsp], 0
  00507	75 49		 jne	 SHORT $LN38@s390_edit_

; 1053 :                 {
; 1054 :                     if (!trial_run)

  00509	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  0050e	75 1d		 jne	 SHORT $LN40@s390_edit_

; 1055 :                         ARCH_DEP(vstoreb) ( fbyte, addr1, b1, regs );

  00510	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00518	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  0051d	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  00521	0f b6 4c 24 32	 movzx	 ecx, BYTE PTR fbyte$[rsp]
  00526	e8 00 00 00 00	 call	 s390_vstoreb
  0052b	eb 23		 jmp	 SHORT $LN41@s390_edit_
$LN40@s390_edit_:

; 1056 :                     else
; 1057 :                         ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  0052d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00535	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0053a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00540	45 33 c0	 xor	 r8d, r8d
  00543	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00547	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  0054b	e8 00 00 00 00	 call	 s390_validate_operand
$LN41@s390_edit_:

; 1058 :                 }

  00550	eb 47		 jmp	 SHORT $LN39@s390_edit_
$LN38@s390_edit_:

; 1059 :                 else /* store message byte */
; 1060 :                 {
; 1061 :                     if (!trial_run)

  00552	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  00557	75 1d		 jne	 SHORT $LN42@s390_edit_

; 1062 :                         ARCH_DEP(vstoreb) ( pbyte, addr1, b1, regs );

  00559	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00561	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  00566	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  0056a	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR pbyte$[rsp]
  0056f	e8 00 00 00 00	 call	 s390_vstoreb
  00574	eb 23		 jmp	 SHORT $LN43@s390_edit_
$LN42@s390_edit_:

; 1063 :                     else
; 1064 :                         ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  00576	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00583	41 b9 01 00 00
	00		 mov	 r9d, 1
  00589	45 33 c0	 xor	 r8d, r8d
  0058c	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00590	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  00594	e8 00 00 00 00	 call	 s390_validate_operand
$LN43@s390_edit_:
$LN39@s390_edit_:
$LN35@s390_edit_:
$LN19@s390_edit_:

; 1065 :                 }
; 1066 :             }
; 1067 : 
; 1068 :             /* Increment first operand address */
; 1069 :             addr1++;

  00599	8b 44 24 34	 mov	 eax, DWORD PTR addr1$[rsp]
  0059d	ff c0		 inc	 eax
  0059f	89 44 24 34	 mov	 DWORD PTR addr1$[rsp], eax

; 1070 :             addr1 &= ADDRESS_MAXWRAP(regs);

  005a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ab	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  005b1	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  005b5	23 c8		 and	 ecx, eax
  005b7	8b c1		 mov	 eax, ecx
  005b9	89 44 24 34	 mov	 DWORD PTR addr1$[rsp], eax

; 1071 : 
; 1072 :         } /* end for(i) */

  005bd	e9 52 fc ff ff	 jmp	 $LN8@s390_edit_
$LN9@s390_edit_:

; 1073 : 
; 1074 :     } /* end for(trial_run) */

  005c2	e9 fc fb ff ff	 jmp	 $LN5@s390_edit_
$LN6@s390_edit_:

; 1075 : 
; 1076 :     /* Replace condition code 2 by condition code 1 if the
; 1077 :        significance indicator is on at the end of editing */
; 1078 :     if (sig && cc == 2) cc = 1;

  005c7	83 7c 24 44 00	 cmp	 DWORD PTR sig$[rsp], 0
  005cc	74 0f		 je	 SHORT $LN44@s390_edit_
  005ce	83 7c 24 54 02	 cmp	 DWORD PTR cc$[rsp], 2
  005d3	75 08		 jne	 SHORT $LN44@s390_edit_
  005d5	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1
$LN44@s390_edit_:

; 1079 : 
; 1080 :     /* Set condition code */
; 1081 :     regs->psw.cc = cc;

  005dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e5	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR cc$[rsp]
  005ea	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1082 : 
; 1083 : #if defined( FEATURE_PER1 )
; 1084 :     /* Check for PER 1 GRA event */
; 1085 :     if (inst[0] == 0xDF) // EDMK?
; 1086 :         PER_GRA_CHECK( regs, PER_GRA_MASK( 1 ));
; 1087 : #endif
; 1088 : 
; 1089 : } /* end DEF_INST(edit_x_edit_and_mark) */

  005ed	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  005f4	c3		 ret	 0
s390_edit_x_edit_and_mark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
effective_addr1$ = 64
l2$ = 68
effective_addr2$ = 72
l1$ = 76
b1$ = 80
temp$1 = 84
b2$ = 88
count2$ = 92
tv191 = 96
sign1$ = 100
count1$ = 104
sign2$ = 108
signr$ = 112
signq$ = 116
tv179 = 120
dec2$ = 128
dec1$ = 160
rem$ = 192
quot$ = 224
__$ArrayPad$ = 256
inst$ = 288
regs$ = 296
s390_divide_decimal PROC

; 834  : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 835  : int     l1, l2;                         /* Length values             */
; 836  : int     b1, b2;                         /* Base register numbers     */
; 837  : VADR    effective_addr1,
; 838  :         effective_addr2;                /* Effective addresses       */
; 839  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Operand 1 (dividend)      */
; 840  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Operand 2 (divisor)       */
; 841  : BYTE    quot[MAX_DECIMAL_DIGITS];       /* Quotient                  */
; 842  : BYTE    rem[MAX_DECIMAL_DIGITS];        /* Remainder                 */
; 843  : int     count1, count2;                 /* Significant digit counters*/
; 844  : int     sign1, sign2;                   /* Sign of operands          */
; 845  : int     signq, signr;                   /* Sign of quotient/remainder*/
; 846  : 
; 847  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004f	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 58	 mov	 DWORD PTR b2$[rsp], eax
  0005d	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00069	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006d	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00071	c1 e8 1c	 shr	 eax, 28
  00074	83 e0 0f	 and	 eax, 15
  00077	89 44 24 50	 mov	 DWORD PTR b1$[rsp], eax
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 44	 mov	 DWORD PTR l2$[rsp], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	c1 f8 04	 sar	 eax, 4
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 4c	 mov	 DWORD PTR l1$[rsp], eax
  000b6	83 7c 24 50 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bb	74 3a		 je	 SHORT $LN5@s390_divid
  000bd	48 63 44 24 50	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c2	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d1	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d5	03 c8		 add	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000dd	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000eb	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ef	23 c8		 and	 ecx, eax
  000f1	8b c1		 mov	 eax, ecx
  000f3	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s390_divid:
  000f7	83 7c 24 58 00	 cmp	 DWORD PTR b2$[rsp], 0
  000fc	74 3a		 je	 SHORT $LN6@s390_divid
  000fe	48 63 44 24 58	 movsxd	 rax, DWORD PTR b2$[rsp]
  00103	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00112	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00116	03 c8		 add	 ecx, eax
  00118	8b c1		 mov	 eax, ecx
  0011a	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0011e	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0012c	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00130	23 c8		 and	 ecx, eax
  00132	8b c1		 mov	 eax, ecx
  00134	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_divid:
$LN4@s390_divid:
  00138	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00144	48 83 c0 06	 add	 rax, 6
  00148	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00154	33 c0		 xor	 eax, eax
  00156	83 f8 06	 cmp	 eax, 6
  00159	74 0f		 je	 SHORT $LN7@s390_divid
  0015b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_divid:
  0016a	33 c0		 xor	 eax, eax
  0016c	85 c0		 test	 eax, eax
  0016e	75 c8		 jne	 SHORT $LN4@s390_divid

; 848  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 849  :     TXFC_INSTR_CHECK( regs );
; 850  : 
; 851  :     /* Program check if the second operand length exceeds 15 digits
; 852  :        or is equal to or greater than the first operand length */
; 853  :     if (l2 > 7 || l2 >= l1)

  00170	83 7c 24 44 07	 cmp	 DWORD PTR l2$[rsp], 7
  00175	7f 0a		 jg	 SHORT $LN9@s390_divid
  00177	8b 44 24 4c	 mov	 eax, DWORD PTR l1$[rsp]
  0017b	39 44 24 44	 cmp	 DWORD PTR l2$[rsp], eax
  0017f	7c 12		 jl	 SHORT $LN8@s390_divid
$LN9@s390_divid:

; 854  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00181	ba 06 00 00 00	 mov	 edx, 6
  00186	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018e	e8 00 00 00 00	 call	 s390_program_interrupt
$LN8@s390_divid:

; 855  : 
; 856  :     /* Load operands into work areas */
; 857  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00193	48 8d 44 24 64	 lea	 rax, QWORD PTR sign1$[rsp]
  00198	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0019d	48 8d 44 24 68	 lea	 rax, QWORD PTR count1$[rsp]
  001a2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a7	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  001af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b4	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001bc	44 8b 44 24 50	 mov	 r8d, DWORD PTR b1$[rsp]
  001c1	8b 54 24 4c	 mov	 edx, DWORD PTR l1$[rsp]
  001c5	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001c9	e8 00 00 00 00	 call	 s390_load_decimal

; 858  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  001ce	48 8d 44 24 6c	 lea	 rax, QWORD PTR sign2$[rsp]
  001d3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001d8	48 8d 44 24 5c	 lea	 rax, QWORD PTR count2$[rsp]
  001dd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e2	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  001ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ef	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001f7	44 8b 44 24 58	 mov	 r8d, DWORD PTR b2$[rsp]
  001fc	8b 54 24 44	 mov	 edx, DWORD PTR l2$[rsp]
  00200	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00204	e8 00 00 00 00	 call	 s390_load_decimal

; 859  : 
; 860  :     /* Program check if second operand value is zero */
; 861  :     if (count2 == 0)

  00209	83 7c 24 5c 00	 cmp	 DWORD PTR count2$[rsp], 0
  0020e	75 12		 jne	 SHORT $LN10@s390_divid

; 862  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_DIVIDE_EXCEPTION);

  00210	ba 0b 00 00 00	 mov	 edx, 11
  00215	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021d	e8 00 00 00 00	 call	 s390_program_interrupt
$LN10@s390_divid:

; 863  : 
; 864  :     /* Perform trial comparison to determine potential overflow.
; 865  :        The leftmost digit of the divisor is aligned one digit to
; 866  :        the right of the leftmost dividend digit.  When the divisor,
; 867  :        so aligned, is less than or equal to the dividend, ignoring
; 868  :        signs, a divide exception is indicated.  As a result of this
; 869  :        comparison, it is also certain that the leftmost digit of the
; 870  :        dividend must be zero, and that the divisor cannot be zero */
; 871  :     if (memcmp(dec2 + (MAX_DECIMAL_DIGITS - l2*2 - 2),
; 872  :                 dec1 + (MAX_DECIMAL_DIGITS - l1*2 - 1),
; 873  :                 l2*2 + 2) <= 0)

  00222	8b 44 24 44	 mov	 eax, DWORD PTR l2$[rsp]
  00226	8d 44 00 02	 lea	 eax, DWORD PTR [rax+rax+2]
  0022a	48 98		 cdqe
  0022c	8b 4c 24 4c	 mov	 ecx, DWORD PTR l1$[rsp]
  00230	d1 e1		 shl	 ecx, 1
  00232	ba 1f 00 00 00	 mov	 edx, 31
  00237	2b d1		 sub	 edx, ecx
  00239	8b ca		 mov	 ecx, edx
  0023b	ff c9		 dec	 ecx
  0023d	48 63 c9	 movsxd	 rcx, ecx
  00240	48 8d 8c 0c a0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp+rcx]
  00248	8b 54 24 44	 mov	 edx, DWORD PTR l2$[rsp]
  0024c	d1 e2		 shl	 edx, 1
  0024e	41 b8 1f 00 00
	00		 mov	 r8d, 31
  00254	44 2b c2	 sub	 r8d, edx
  00257	41 8b d0	 mov	 edx, r8d
  0025a	83 ea 02	 sub	 edx, 2
  0025d	48 63 d2	 movsxd	 rdx, edx
  00260	48 8d 94 14 80
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp+rdx]
  00268	48 89 54 24 78	 mov	 QWORD PTR tv179[rsp], rdx
  0026d	4c 8b c0	 mov	 r8, rax
  00270	48 8b d1	 mov	 rdx, rcx
  00273	48 8b 44 24 78	 mov	 rax, QWORD PTR tv179[rsp]
  00278	48 8b c8	 mov	 rcx, rax
  0027b	e8 00 00 00 00	 call	 memcmp
  00280	85 c0		 test	 eax, eax
  00282	7f 12		 jg	 SHORT $LN11@s390_divid

; 874  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_DIVIDE_EXCEPTION);

  00284	ba 0b 00 00 00	 mov	 edx, 11
  00289	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00291	e8 00 00 00 00	 call	 s390_program_interrupt
$LN11@s390_divid:

; 875  : 
; 876  :     /* Perform decimal division */
; 877  :     divide_decimal (dec1, count1, dec2, count2, quot, rem);

  00296	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR rem$[rsp]
  0029e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002a3	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR quot$[rsp]
  002ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b0	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR count2$[rsp]
  002b5	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec2$[rsp]
  002bd	8b 54 24 68	 mov	 edx, DWORD PTR count1$[rsp]
  002c1	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  002c9	e8 00 00 00 00	 call	 divide_decimal

; 878  : 
; 879  :     /* Quotient is positive if operand signs are equal, and negative
; 880  :        if operand signs are opposite, even if quotient is zero */
; 881  :     signq = (sign1 == sign2) ? 1 : -1;

  002ce	8b 44 24 6c	 mov	 eax, DWORD PTR sign2$[rsp]
  002d2	39 44 24 64	 cmp	 DWORD PTR sign1$[rsp], eax
  002d6	75 0a		 jne	 SHORT $LN13@s390_divid
  002d8	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv191[rsp], 1
  002e0	eb 08		 jmp	 SHORT $LN14@s390_divid
$LN13@s390_divid:
  002e2	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR tv191[rsp], -1
$LN14@s390_divid:
  002ea	8b 44 24 60	 mov	 eax, DWORD PTR tv191[rsp]
  002ee	89 44 24 74	 mov	 DWORD PTR signq$[rsp], eax

; 882  : 
; 883  :     /* Remainder sign is same as dividend, even if remainder is zero */
; 884  :     signr = sign1;

  002f2	8b 44 24 64	 mov	 eax, DWORD PTR sign1$[rsp]
  002f6	89 44 24 70	 mov	 DWORD PTR signr$[rsp], eax

; 885  : 
; 886  :     /* Store remainder into entire first operand location.  The entire
; 887  :        field will be filled in order to check for store protection.
; 888  :        Subsequently the quotient will be stored in the leftmost bytes
; 889  :        of the first operand location, overwriting high order zeroes */
; 890  :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, rem, signr);

  002fa	8b 44 24 70	 mov	 eax, DWORD PTR signr$[rsp]
  002fe	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00302	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR rem$[rsp]
  0030a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030f	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00317	44 8b 44 24 50	 mov	 r8d, DWORD PTR b1$[rsp]
  0031c	8b 54 24 4c	 mov	 edx, DWORD PTR l1$[rsp]
  00320	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00324	e8 00 00 00 00	 call	 s390_store_decimal

; 891  : 
; 892  :     /* Store quotient in leftmost bytes of first operand location */
; 893  :     ARCH_DEP(store_decimal) (effective_addr1, l1-l2-1, b1, regs, quot, signq);

  00329	8b 44 24 44	 mov	 eax, DWORD PTR l2$[rsp]
  0032d	8b 4c 24 4c	 mov	 ecx, DWORD PTR l1$[rsp]
  00331	2b c8		 sub	 ecx, eax
  00333	8b c1		 mov	 eax, ecx
  00335	ff c8		 dec	 eax
  00337	8b 4c 24 74	 mov	 ecx, DWORD PTR signq$[rsp]
  0033b	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0033f	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR quot$[rsp]
  00347	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0034c	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00354	44 8b 44 24 50	 mov	 r8d, DWORD PTR b1$[rsp]
  00359	8b d0		 mov	 edx, eax
  0035b	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0035f	e8 00 00 00 00	 call	 s390_store_decimal

; 894  : 
; 895  : } /* end DEF_INST(divide_decimal) */

  00364	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0036c	48 33 cc	 xor	 rcx, rsp
  0036f	e8 00 00 00 00	 call	 __security_check_cookie
  00374	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0037b	c3		 ret	 0
s390_divide_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
effective_addr1$ = 64
effective_addr2$ = 68
temp$1 = 72
sign1$ = 76
b1$ = 80
b2$ = 84
sign2$ = 88
tv173 = 92
rc$ = 96
tv178 = 100
l1$ = 104
l2$ = 108
count1$ = 112
count2$ = 116
dec2$ = 120
dec1$ = 152
__$ArrayPad$ = 184
inst$ = 208
regs$ = 216
s390_compare_decimal PROC

; 775  : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 776  : int     l1, l2;                         /* Length values             */
; 777  : int     b1, b2;                         /* Base register numbers     */
; 778  : VADR    effective_addr1,
; 779  :         effective_addr2;                /* Effective addresses       */
; 780  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 781  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 782  : int     count1, count2;                 /* Significant digit counters*/
; 783  : int     sign1, sign2;                   /* Sign of each operand      */
; 784  : int     rc;                             /* Return code               */
; 785  : 
; 786  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004f	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 54	 mov	 DWORD PTR b2$[rsp], eax
  0005d	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00069	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006d	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00071	c1 e8 1c	 shr	 eax, 28
  00074	83 e0 0f	 and	 eax, 15
  00077	89 44 24 50	 mov	 DWORD PTR b1$[rsp], eax
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 6c	 mov	 DWORD PTR l2$[rsp], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	c1 f8 04	 sar	 eax, 4
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 68	 mov	 DWORD PTR l1$[rsp], eax
  000b6	83 7c 24 50 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bb	74 3a		 je	 SHORT $LN5@s390_compa
  000bd	48 63 44 24 50	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d1	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d5	03 c8		 add	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000dd	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000eb	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ef	23 c8		 and	 ecx, eax
  000f1	8b c1		 mov	 eax, ecx
  000f3	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s390_compa:
  000f7	83 7c 24 54 00	 cmp	 DWORD PTR b2$[rsp], 0
  000fc	74 3a		 je	 SHORT $LN6@s390_compa
  000fe	48 63 44 24 54	 movsxd	 rax, DWORD PTR b2$[rsp]
  00103	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00112	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00116	03 c8		 add	 ecx, eax
  00118	8b c1		 mov	 eax, ecx
  0011a	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0011e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0012c	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00130	23 c8		 and	 ecx, eax
  00132	8b c1		 mov	 eax, ecx
  00134	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_compa:
$LN4@s390_compa:
  00138	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00144	48 83 c0 06	 add	 rax, 6
  00148	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00154	33 c0		 xor	 eax, eax
  00156	83 f8 06	 cmp	 eax, 6
  00159	74 0f		 je	 SHORT $LN7@s390_compa
  0015b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_compa:
  0016a	33 c0		 xor	 eax, eax
  0016c	85 c0		 test	 eax, eax
  0016e	75 c8		 jne	 SHORT $LN4@s390_compa

; 787  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 788  :     TXFC_INSTR_CHECK( regs );
; 789  : 
; 790  :     /* Load operands into work areas */
; 791  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00170	48 8d 44 24 4c	 lea	 rax, QWORD PTR sign1$[rsp]
  00175	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0017a	48 8d 44 24 70	 lea	 rax, QWORD PTR count1$[rsp]
  0017f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00184	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  0018c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00191	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00199	44 8b 44 24 50	 mov	 r8d, DWORD PTR b1$[rsp]
  0019e	8b 54 24 68	 mov	 edx, DWORD PTR l1$[rsp]
  001a2	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001a6	e8 00 00 00 00	 call	 s390_load_decimal

; 792  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  001ab	48 8d 44 24 58	 lea	 rax, QWORD PTR sign2$[rsp]
  001b0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001b5	48 8d 44 24 74	 lea	 rax, QWORD PTR count2$[rsp]
  001ba	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001bf	48 8d 44 24 78	 lea	 rax, QWORD PTR dec2$[rsp]
  001c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c9	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001d1	44 8b 44 24 54	 mov	 r8d, DWORD PTR b2$[rsp]
  001d6	8b 54 24 6c	 mov	 edx, DWORD PTR l2$[rsp]
  001da	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001de	e8 00 00 00 00	 call	 s390_load_decimal

; 793  : 
; 794  :     /* Result is equal if both operands are zero */
; 795  :     if (count1 == 0 && count2 == 0)

  001e3	83 7c 24 70 00	 cmp	 DWORD PTR count1$[rsp], 0
  001e8	75 18		 jne	 SHORT $LN8@s390_compa
  001ea	83 7c 24 74 00	 cmp	 DWORD PTR count2$[rsp], 0
  001ef	75 11		 jne	 SHORT $LN8@s390_compa

; 796  :     {
; 797  :         regs->psw.cc = 0;

  001f1	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 798  :         return;

  001fd	e9 ca 00 00 00	 jmp	 $LN1@s390_compa
$LN8@s390_compa:

; 799  :     }
; 800  : 
; 801  :     /* Result is low if operand 1 is -ve and operand 2 is +ve */
; 802  :     if (sign1 < 0 && sign2 > 0)

  00202	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  00207	7d 18		 jge	 SHORT $LN9@s390_compa
  00209	83 7c 24 58 00	 cmp	 DWORD PTR sign2$[rsp], 0
  0020e	7e 11		 jle	 SHORT $LN9@s390_compa

; 803  :     {
; 804  :         regs->psw.cc = 1;

  00210	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00218	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 805  :         return;

  0021c	e9 ab 00 00 00	 jmp	 $LN1@s390_compa
$LN9@s390_compa:

; 806  :     }
; 807  : 
; 808  :     /* Result is high if operand 1 is +ve and operand 2 is -ve */
; 809  :     if (sign1 > 0 && sign2 < 0)

  00221	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  00226	7e 18		 jle	 SHORT $LN10@s390_compa
  00228	83 7c 24 58 00	 cmp	 DWORD PTR sign2$[rsp], 0
  0022d	7d 11		 jge	 SHORT $LN10@s390_compa

; 810  :     {
; 811  :         regs->psw.cc = 2;

  0022f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00237	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 812  :         return;

  0023b	e9 8c 00 00 00	 jmp	 $LN1@s390_compa
$LN10@s390_compa:

; 813  :     }
; 814  : 
; 815  :     /* If signs are equal then compare the digits */
; 816  :     rc = memcmp (dec1, dec2, MAX_DECIMAL_DIGITS);

  00240	41 b8 1f 00 00
	00		 mov	 r8d, 31
  00246	48 8d 54 24 78	 lea	 rdx, QWORD PTR dec2$[rsp]
  0024b	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00253	e8 00 00 00 00	 call	 memcmp
  00258	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 817  : 
; 818  :     /* Return low or high (depending on sign) if digits are unequal */
; 819  :     if (rc < 0)

  0025c	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00261	7d 2b		 jge	 SHORT $LN11@s390_compa

; 820  :         regs->psw.cc = (sign1 > 0) ? 1 : 2;

  00263	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  00268	7e 0a		 jle	 SHORT $LN16@s390_compa
  0026a	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv173[rsp], 1
  00272	eb 08		 jmp	 SHORT $LN17@s390_compa
$LN16@s390_compa:
  00274	c7 44 24 5c 02
	00 00 00	 mov	 DWORD PTR tv173[rsp], 2
$LN17@s390_compa:
  0027c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00284	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR tv173[rsp]
  00289	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  0028c	eb 3e		 jmp	 SHORT $LN12@s390_compa
$LN11@s390_compa:

; 821  :     else
; 822  :         if (rc > 0)

  0028e	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00293	7e 2b		 jle	 SHORT $LN13@s390_compa

; 823  :             regs->psw.cc = (sign1 > 0) ? 2 : 1;

  00295	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  0029a	7e 0a		 jle	 SHORT $LN18@s390_compa
  0029c	c7 44 24 64 02
	00 00 00	 mov	 DWORD PTR tv178[rsp], 2
  002a4	eb 08		 jmp	 SHORT $LN19@s390_compa
$LN18@s390_compa:
  002a6	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
$LN19@s390_compa:
  002ae	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b6	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR tv178[rsp]
  002bb	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  002be	eb 0c		 jmp	 SHORT $LN14@s390_compa
$LN13@s390_compa:

; 824  :         else
; 825  :             regs->psw.cc = 0;

  002c0	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN14@s390_compa:
$LN12@s390_compa:
$LN1@s390_compa:

; 826  : 
; 827  : } /* end DEF_INST(compare_decimal) */

  002cc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002d4	48 33 cc	 xor	 rcx, rsp
  002d7	e8 00 00 00 00	 call	 __security_check_cookie
  002dc	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  002e3	c3		 ret	 0
s390_compare_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sign3$ = 64
count3$ = 68
effective_addr1$ = 72
effective_addr2$ = 76
temp$1 = 80
sign1$ = 84
b1$ = 88
b2$ = 92
l1$ = 96
cc$ = 100
count1$ = 104
count2$ = 108
sign2$ = 112
tv185 = 116
tv186 = 120
l2$ = 124
dec3$ = 128
dec2$ = 160
dec1$ = 192
__$ArrayPad$ = 224
inst$ = 272
regs$ = 280
s390_add_decimal PROC

; 699  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 700  : int     l1, l2;                         /* Length values             */
; 701  : int     b1, b2;                         /* Base register numbers     */
; 702  : VADR    effective_addr1,
; 703  :         effective_addr2;                /* Effective addresses       */
; 704  : int     cc;                             /* Condition code            */
; 705  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 706  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 707  : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 708  : int     count1, count2, count3;         /* Significant digit counters*/
; 709  : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 710  : 
; 711  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00025	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002d	48 83 c0 02	 add	 rax, 2
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 fetch_fw_noswap
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 _byteswap_ulong
  00040	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00044	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 0c	 shr	 eax, 12
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 5c	 mov	 DWORD PTR b2$[rsp], eax
  0005f	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 10	 shr	 eax, 16
  00066	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006b	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006f	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00073	c1 e8 1c	 shr	 eax, 28
  00076	83 e0 0f	 and	 eax, 15
  00079	89 44 24 58	 mov	 DWORD PTR b1$[rsp], eax
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	48 6b c0 01	 imul	 rax, rax, 1
  00086	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 7c	 mov	 DWORD PTR l2$[rsp], eax
  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 01	 imul	 rax, rax, 1
  000a2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ae	c1 f8 04	 sar	 eax, 4
  000b1	83 e0 0f	 and	 eax, 15
  000b4	89 44 24 60	 mov	 DWORD PTR l1$[rsp], eax
  000b8	83 7c 24 58 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bd	74 3a		 je	 SHORT $LN5@s390_add_d
  000bf	48 63 44 24 58	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d3	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d7	03 c8		 add	 ecx, eax
  000d9	8b c1		 mov	 eax, ecx
  000db	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000df	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ed	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000f1	23 c8		 and	 ecx, eax
  000f3	8b c1		 mov	 eax, ecx
  000f5	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s390_add_d:
  000f9	83 7c 24 5c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000fe	74 3a		 je	 SHORT $LN6@s390_add_d
  00100	48 63 44 24 5c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00105	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00114	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00118	03 c8		 add	 ecx, eax
  0011a	8b c1		 mov	 eax, ecx
  0011c	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00120	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00128	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0012e	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00132	23 c8		 and	 ecx, eax
  00134	8b c1		 mov	 eax, ecx
  00136	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s390_add_d:
$LN4@s390_add_d:
  0013a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00142	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00146	48 83 c0 06	 add	 rax, 6
  0014a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00152	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00156	33 c0		 xor	 eax, eax
  00158	83 f8 06	 cmp	 eax, 6
  0015b	74 0f		 je	 SHORT $LN7@s390_add_d
  0015d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s390_add_d:
  0016c	33 c0		 xor	 eax, eax
  0016e	85 c0		 test	 eax, eax
  00170	75 c8		 jne	 SHORT $LN4@s390_add_d

; 712  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 713  :     TXFC_INSTR_CHECK( regs );
; 714  : 
; 715  :     /* Load operands into work areas */
; 716  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00172	48 8d 44 24 54	 lea	 rax, QWORD PTR sign1$[rsp]
  00177	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0017c	48 8d 44 24 68	 lea	 rax, QWORD PTR count1$[rsp]
  00181	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00186	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  0018e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00193	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0019b	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  001a0	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  001a4	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001a8	e8 00 00 00 00	 call	 s390_load_decimal

; 717  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  001ad	48 8d 44 24 70	 lea	 rax, QWORD PTR sign2$[rsp]
  001b2	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001b7	48 8d 44 24 6c	 lea	 rax, QWORD PTR count2$[rsp]
  001bc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c1	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  001c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ce	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001d6	44 8b 44 24 5c	 mov	 r8d, DWORD PTR b2$[rsp]
  001db	8b 54 24 7c	 mov	 edx, DWORD PTR l2$[rsp]
  001df	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001e3	e8 00 00 00 00	 call	 s390_load_decimal

; 718  : 
; 719  :     /* Add or subtract operand values */
; 720  :     if (count2 == 0)

  001e8	83 7c 24 6c 00	 cmp	 DWORD PTR count2$[rsp], 0
  001ed	75 32		 jne	 SHORT $LN8@s390_add_d

; 721  :     {
; 722  :         /* If second operand is zero then result is first operand */
; 723  :         memcpy (dec3, dec1, MAX_DECIMAL_DIGITS);

  001ef	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  001f7	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  001ff	48 8b f8	 mov	 rdi, rax
  00202	48 8b f1	 mov	 rsi, rcx
  00205	b9 1f 00 00 00	 mov	 ecx, 31
  0020a	f3 a4		 rep movsb

; 724  :         count3 = count1;

  0020c	8b 44 24 68	 mov	 eax, DWORD PTR count1$[rsp]
  00210	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 725  :         sign3 = sign1;

  00214	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  00218	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 726  :     }

  0021c	e9 a9 00 00 00	 jmp	 $LN9@s390_add_d
$LN8@s390_add_d:

; 727  :     else if (count1 == 0)

  00221	83 7c 24 68 00	 cmp	 DWORD PTR count1$[rsp], 0
  00226	75 2f		 jne	 SHORT $LN10@s390_add_d

; 728  :     {
; 729  :         /* If first operand is zero then result is second operand */
; 730  :         memcpy (dec3, dec2, MAX_DECIMAL_DIGITS);

  00228	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00230	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dec2$[rsp]
  00238	48 8b f8	 mov	 rdi, rax
  0023b	48 8b f1	 mov	 rsi, rcx
  0023e	b9 1f 00 00 00	 mov	 ecx, 31
  00243	f3 a4		 rep movsb

; 731  :         count3 = count2;

  00245	8b 44 24 6c	 mov	 eax, DWORD PTR count2$[rsp]
  00249	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 732  :         sign3 = sign2;

  0024d	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  00251	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 733  :     }

  00255	eb 73		 jmp	 SHORT $LN11@s390_add_d
$LN10@s390_add_d:

; 734  :     else if (sign1 == sign2)

  00257	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  0025b	39 44 24 54	 cmp	 DWORD PTR sign1$[rsp], eax
  0025f	75 2c		 jne	 SHORT $LN12@s390_add_d

; 735  :     {
; 736  :         /* If signs are equal then add operands */
; 737  :         add_decimal (dec1, dec2, dec3, &count3);

  00261	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  00266	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  0026e	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  00276	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  0027e	e8 00 00 00 00	 call	 add_decimal

; 738  :         sign3 = sign1;

  00283	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  00287	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 739  :     }

  0028b	eb 3d		 jmp	 SHORT $LN13@s390_add_d
$LN12@s390_add_d:

; 740  :     else
; 741  :     {
; 742  :         /* If signs are opposite then subtract operands */
; 743  :         subtract_decimal (dec1, dec2, dec3, &count3, &sign3);

  0028d	48 8d 44 24 40	 lea	 rax, QWORD PTR sign3$[rsp]
  00292	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00297	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  0029c	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  002a4	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  002ac	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  002b4	e8 00 00 00 00	 call	 subtract_decimal

; 744  :         if (sign1 < 0) sign3 = -sign3;

  002b9	83 7c 24 54 00	 cmp	 DWORD PTR sign1$[rsp], 0
  002be	7d 0a		 jge	 SHORT $LN14@s390_add_d
  002c0	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  002c4	f7 d8		 neg	 eax
  002c6	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax
$LN14@s390_add_d:
$LN13@s390_add_d:
$LN11@s390_add_d:
$LN9@s390_add_d:

; 745  :     }
; 746  : 
; 747  :     /* Set condition code */
; 748  :     cc = (count3 == 0) ? 0 : (sign3 < 1) ? 1 : 2;

  002ca	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  002cf	75 0a		 jne	 SHORT $LN21@s390_add_d
  002d1	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv186[rsp], 0
  002d9	eb 21		 jmp	 SHORT $LN22@s390_add_d
$LN21@s390_add_d:
  002db	83 7c 24 40 01	 cmp	 DWORD PTR sign3$[rsp], 1
  002e0	7d 0a		 jge	 SHORT $LN19@s390_add_d
  002e2	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv185[rsp], 1
  002ea	eb 08		 jmp	 SHORT $LN20@s390_add_d
$LN19@s390_add_d:
  002ec	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv185[rsp], 2
$LN20@s390_add_d:
  002f4	8b 44 24 74	 mov	 eax, DWORD PTR tv185[rsp]
  002f8	89 44 24 78	 mov	 DWORD PTR tv186[rsp], eax
$LN22@s390_add_d:
  002fc	8b 44 24 78	 mov	 eax, DWORD PTR tv186[rsp]
  00300	89 44 24 64	 mov	 DWORD PTR cc$[rsp], eax

; 749  : 
; 750  :     /* Overflow if result exceeds first operand length */
; 751  :     if (count3 > (l1+1) * 2 - 1)

  00304	8b 44 24 60	 mov	 eax, DWORD PTR l1$[rsp]
  00308	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0030c	39 44 24 44	 cmp	 DWORD PTR count3$[rsp], eax
  00310	7e 08		 jle	 SHORT $LN15@s390_add_d

; 752  :         cc = 3;

  00312	c7 44 24 64 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN15@s390_add_d:

; 753  : 
; 754  :     /* Set positive sign if result is zero */
; 755  :     if (count3 == 0)

  0031a	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  0031f	75 08		 jne	 SHORT $LN16@s390_add_d

; 756  :         sign3 = 1;

  00321	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR sign3$[rsp], 1
$LN16@s390_add_d:

; 757  : 
; 758  :     /* Store result into first operand location */
; 759  :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  00329	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  0032d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00331	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00339	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033e	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00346	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  0034b	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  0034f	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00353	e8 00 00 00 00	 call	 s390_store_decimal

; 760  : 
; 761  :     /* Set condition code */
; 762  :     regs->psw.cc = cc;

  00358	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00360	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR cc$[rsp]
  00365	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 763  : 
; 764  :     /* Program check if overflow and PSW program mask is set */
; 765  :     if (cc == 3 && DOMASK(&regs->psw))

  00368	83 7c 24 64 03	 cmp	 DWORD PTR cc$[rsp], 3
  0036d	75 25		 jne	 SHORT $LN17@s390_add_d
  0036f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00377	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  0037b	83 e0 04	 and	 eax, 4
  0037e	85 c0		 test	 eax, eax
  00380	74 12		 je	 SHORT $LN17@s390_add_d

; 766  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  00382	ba 0a 00 00 00	 mov	 edx, 10
  00387	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038f	e8 00 00 00 00	 call	 s390_program_interrupt
$LN17@s390_add_d:

; 767  : 
; 768  : } /* end DEF_INST(add_decimal) */

  00394	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0039c	48 33 cc	 xor	 rcx, rsp
  0039f	e8 00 00 00 00	 call	 __security_check_cookie
  003a4	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  003ab	5f		 pop	 rdi
  003ac	5e		 pop	 rsi
  003ad	c3		 ret	 0
s390_add_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 48
effective_addr1$ = 52
cc$ = 56
temp$1 = 60
b1$ = 64
l1$ = 68
pack$ = 72
__$ArrayPad$ = 88
inst$ = 112
regs$ = 120
s390_test_decimal PROC

; 1387 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1388 : int     l1;                             /* Length value              */
; 1389 : int     b1;                             /* Base register number      */
; 1390 : VADR    effective_addr1;                /* Effective address         */
; 1391 : int     i;                              /* Array subscript           */
; 1392 : int     cc = 0;                         /* Condition code            */

  0001d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1393 : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 1394 : 
; 1395 :     RSL(inst, regs, l1, b1, effective_addr1);

  00025	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 _byteswap_ulong
  00036	89 44 24 3c	 mov	 DWORD PTR temp$1[rsp], eax
  0003a	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  0003e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00043	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00047	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  0004b	c1 e8 0c	 shr	 eax, 12
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR b1$[rsp], eax
  00055	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 44	 mov	 DWORD PTR l1$[rsp], eax
  00063	83 7c 24 40 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 34		 je	 SHORT $LN8@s390_test_
  0006a	48 63 44 24 40	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00092	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00096	23 c8		 and	 ecx, eax
  00098	8b c1		 mov	 eax, ecx
  0009a	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s390_test_:
$LN4@s390_test_:
  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a7	48 83 c0 06	 add	 rax, 6
  000ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000b4	33 c0		 xor	 eax, eax
  000b6	83 f8 06	 cmp	 eax, 6
  000b9	74 0c		 je	 SHORT $LN9@s390_test_
  000bb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@s390_test_:
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 d1		 jne	 SHORT $LN4@s390_test_

; 1396 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1397 : 
; 1398 :     TXFC_INSTR_CHECK( regs );
; 1399 : 
; 1400 :     /* Fetch the packed decimal operand into the work area */
; 1401 :     ARCH_DEP(vfetchc) (pack, l1, effective_addr1, b1, regs);

  000cd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d7	44 8b 4c 24 40	 mov	 r9d, DWORD PTR b1$[rsp]
  000dc	44 8b 44 24 34	 mov	 r8d, DWORD PTR effective_addr1$[rsp]
  000e1	0f b6 54 24 44	 movzx	 edx, BYTE PTR l1$[rsp]
  000e6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR pack$[rsp]
  000eb	e8 00 00 00 00	 call	 s390_vfetchc

; 1402 : 
; 1403 :     /* Test each byte of the operand */
; 1404 :     for (i=0; ; i++)

  000f0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000f8	eb 0a		 jmp	 SHORT $LN7@s390_test_
$LN5@s390_test_:
  000fa	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000fe	ff c0		 inc	 eax
  00100	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_test_:

; 1405 :     {
; 1406 :         /* Test the high-order digit of the byte */
; 1407 :         if ((pack[i] & 0xF0) > 0x90)

  00104	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00109	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  0010e	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00113	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  00118	7e 08		 jle	 SHORT $LN10@s390_test_

; 1408 :             cc = 2;

  0011a	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN10@s390_test_:

; 1409 : 
; 1410 :         /* Exit if this is the last byte */
; 1411 :         if (i == l1) break;

  00122	8b 44 24 44	 mov	 eax, DWORD PTR l1$[rsp]
  00126	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0012a	75 02		 jne	 SHORT $LN11@s390_test_
  0012c	eb 1c		 jmp	 SHORT $LN6@s390_test_
$LN11@s390_test_:

; 1412 : 
; 1413 :         /* Test the low-order digit of the byte */
; 1414 :         if ((pack[i] & 0x0F) > 0x09)

  0012e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00133	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  00138	83 e0 0f	 and	 eax, 15
  0013b	83 f8 09	 cmp	 eax, 9
  0013e	7e 08		 jle	 SHORT $LN12@s390_test_

; 1415 :             cc = 2;

  00140	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN12@s390_test_:

; 1416 :     }

  00148	eb b0		 jmp	 SHORT $LN5@s390_test_
$LN6@s390_test_:

; 1417 : 
; 1418 :     /* Test the sign in the last byte */
; 1419 :     if ((pack[i] & 0x0F) < 0x0A)

  0014a	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0014f	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  00154	83 e0 0f	 and	 eax, 15
  00157	83 f8 0a	 cmp	 eax, 10
  0015a	7d 0b		 jge	 SHORT $LN13@s390_test_

; 1420 :         cc |= 1;

  0015c	8b 44 24 38	 mov	 eax, DWORD PTR cc$[rsp]
  00160	83 c8 01	 or	 eax, 1
  00163	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax
$LN13@s390_test_:

; 1421 : 
; 1422 :     /* Return condition code */
; 1423 :     regs->psw.cc = cc;

  00167	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR cc$[rsp]
  00171	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1424 : 
; 1425 : } /* end DEF_INST(test_decimal) */

  00174	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00179	48 33 cc	 xor	 rcx, rsp
  0017c	e8 00 00 00 00	 call	 __security_check_cookie
  00181	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00185	c3		 ret	 0
s390_test_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 48
j$ = 52
tv135 = 56
pack$ = 64
__$ArrayPad$ = 88
addr$ = 112
len$ = 120
arn$ = 128
regs$ = 136
dec$ = 144
sign$ = 152
s370_store_decimal PROC

; 668  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 669  : int     i, j;                           /* Array subscripts          */
; 670  : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 671  : 
; 672  :     /* if operand crosses page, make sure both pages are accessible */
; 673  :     if((addr & PAGEFRAME_PAGEMASK) !=

  00025	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00029	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0002e	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  00032	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  00036	03 d1		 add	 edx, ecx
  00038	8b ca		 mov	 ecx, edx
  0003a	81 e1 00 f8 ff
	7f		 and	 ecx, 2147481600		; 7ffff800H
  00040	3b c1		 cmp	 eax, ecx
  00042	74 28		 je	 SHORT $LN5@s370_store

; 674  :         ((addr + len) & PAGEFRAME_PAGEMASK))
; 675  :         ARCH_DEP(validate_operand) (addr, arn, len, ACCTYPE_WRITE_SKP, regs);

  00044	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	41 b9 01 00 00
	00		 mov	 r9d, 1
  00057	44 8b 44 24 78	 mov	 r8d, DWORD PTR len$[rsp]
  0005c	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR arn$[rsp]
  00063	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00067	e8 00 00 00 00	 call	 s370_validate_operand
$LN5@s370_store:

; 676  : 
; 677  :     /* Pack digits into packed decimal work area */
; 678  :     for (i=0, j=0; i < MAX_DECIMAL_DIGITS; i++)

  0006c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00074	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0007c	eb 0a		 jmp	 SHORT $LN4@s370_store
$LN2@s370_store:
  0007e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00082	ff c0		 inc	 eax
  00084	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_store:
  00088	83 7c 24 30 1f	 cmp	 DWORD PTR i$[rsp], 31
  0008d	7d 5c		 jge	 SHORT $LN3@s370_store

; 679  :     {
; 680  :         if (i & 1)

  0008f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00093	83 e0 01	 and	 eax, 1
  00096	85 c0		 test	 eax, eax
  00098	74 32		 je	 SHORT $LN6@s370_store

; 681  :             pack[j++] |= dec[i];

  0009a	48 63 44 24 34	 movsxd	 rax, DWORD PTR j$[rsp]
  0009f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a4	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dec$[rsp]
  000ac	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000b0	0f b6 44 04 40	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000b5	0b c1		 or	 eax, ecx
  000b7	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000bc	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al
  000c0	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  000c4	ff c0		 inc	 eax
  000c6	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
  000ca	eb 1d		 jmp	 SHORT $LN7@s370_store
$LN6@s370_store:

; 682  :         else
; 683  :             pack[j] = dec[i] << 4;

  000cc	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dec$[rsp]
  000d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000dd	c1 e0 04	 shl	 eax, 4
  000e0	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000e5	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al
$LN7@s370_store:

; 684  :     } /* end for */

  000e9	eb 93		 jmp	 SHORT $LN2@s370_store
$LN3@s370_store:

; 685  : 
; 686  :     /* Pack the sign into low-order digit of work area */
; 687  :     pack[MAX_DECIMAL_LENGTH-1] |= (sign < 0 ? 0x0D : 0x0C);

  000eb	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR sign$[rsp], 0
  000f3	7d 0a		 jge	 SHORT $LN9@s370_store
  000f5	c7 44 24 38 0d
	00 00 00	 mov	 DWORD PTR tv135[rsp], 13
  000fd	eb 08		 jmp	 SHORT $LN10@s370_store
$LN9@s370_store:
  000ff	c7 44 24 38 0c
	00 00 00	 mov	 DWORD PTR tv135[rsp], 12
$LN10@s370_store:
  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	48 6b c0 0f	 imul	 rax, rax, 15
  00110	0f b6 44 04 40	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  00115	0b 44 24 38	 or	 eax, DWORD PTR tv135[rsp]
  00119	b9 01 00 00 00	 mov	 ecx, 1
  0011e	48 6b c9 0f	 imul	 rcx, rcx, 15
  00122	88 44 0c 40	 mov	 BYTE PTR pack$[rsp+rcx], al

; 688  : 
; 689  :     /* Store the result at the operand location */
; 690  :     ARCH_DEP(vstorec) (pack+sizeof(pack)-len-1, len, addr, arn, regs);

  00126	48 8d 44 24 50	 lea	 rax, QWORD PTR pack$[rsp+16]
  0012b	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR len$[rsp]
  00130	48 2b c1	 sub	 rax, rcx
  00133	48 ff c8	 dec	 rax
  00136	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00143	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR arn$[rsp]
  0014b	44 8b 44 24 70	 mov	 r8d, DWORD PTR addr$[rsp]
  00150	0f b6 54 24 78	 movzx	 edx, BYTE PTR len$[rsp]
  00155	48 8b c8	 mov	 rcx, rax
  00158	e8 00 00 00 00	 call	 s370_vstorec

; 691  : 
; 692  : } /* end function ARCH_DEP(store_decimal) */

  0015d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00162	48 33 cc	 xor	 rcx, rsp
  00165	e8 00 00 00 00	 call	 __security_check_cookie
  0016a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0016e	c3		 ret	 0
s370_store_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
h$ = 48
i$ = 52
j$ = 56
n$ = 60
tv144 = 64
pack$ = 72
__$ArrayPad$ = 96
addr$ = 128
len$ = 136
arn$ = 144
regs$ = 152
result$ = 160
count$ = 168
sign$ = 176
s370_load_decimal PROC

; 596  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 597  : int     h;                              /* Hexadecimal digit         */
; 598  : int     i, j;                           /* Array subscripts          */
; 599  : int     n;                              /* Significant digit counter */
; 600  : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 601  : 
; 602  :     /* Fetch the packed decimal operand into work area */
; 603  :     memset( pack, 0, sizeof(pack) );

  00026	48 8d 44 24 48	 lea	 rax, QWORD PTR pack$[rsp]
  0002b	48 8b f8	 mov	 rdi, rax
  0002e	33 c0		 xor	 eax, eax
  00030	b9 10 00 00 00	 mov	 ecx, 16
  00035	f3 aa		 rep stosb

; 604  :     ARCH_DEP(vfetchc) (pack+sizeof(pack)-len-1, len, addr, arn, regs);

  00037	48 8d 44 24 58	 lea	 rax, QWORD PTR pack$[rsp+16]
  0003c	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR len$[rsp]
  00044	48 2b c1	 sub	 rax, rcx
  00047	48 ff c8	 dec	 rax
  0004a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00057	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR arn$[rsp]
  0005f	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR addr$[rsp]
  00067	0f b6 94 24 88
	00 00 00	 movzx	 edx, BYTE PTR len$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 s370_vfetchc

; 605  : 
; 606  :     /* Unpack digits into result */
; 607  :     for (i=0, j=0, n=0; i < MAX_DECIMAL_DIGITS; i++)

  00077	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00087	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0008f	eb 0a		 jmp	 SHORT $LN4@s370_load_
$LN2@s370_load_:
  00091	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00095	ff c0		 inc	 eax
  00097	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_load_:
  0009b	83 7c 24 34 1f	 cmp	 DWORD PTR i$[rsp], 31
  000a0	0f 8d 9b 00 00
	00		 jge	 $LN3@s370_load_

; 608  :     {
; 609  :         /* Load source digit */
; 610  :         if (i & 1)

  000a6	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  000aa	83 e0 01	 and	 eax, 1
  000ad	85 c0		 test	 eax, eax
  000af	74 1d		 je	 SHORT $LN5@s370_load_

; 611  :             h = pack[j++] & 0x0F;

  000b1	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  000b6	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000bb	83 e0 0f	 and	 eax, 15
  000be	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax
  000c2	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000c6	ff c0		 inc	 eax
  000c8	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
  000cc	eb 11		 jmp	 SHORT $LN6@s370_load_
$LN5@s370_load_:

; 612  :         else
; 613  :             h = pack[j] >> 4;

  000ce	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  000d3	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  000d8	c1 f8 04	 sar	 eax, 4
  000db	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax
$LN6@s370_load_:

; 614  : 
; 615  :         /* Check for valid numeric */
; 616  :         if (h > 9)

  000df	83 7c 24 30 09	 cmp	 DWORD PTR h$[rsp], 9
  000e4	7e 29		 jle	 SHORT $LN7@s370_load_

; 617  :         {
; 618  :             regs->dxc = DXC_DECIMAL;

  000e6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 619  :             ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  000f8	ba 07 00 00 00	 mov	 edx, 7
  000fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	e8 00 00 00 00	 call	 s370_program_interrupt

; 620  :             return;

  0010a	e9 b0 00 00 00	 jmp	 $LN1@s370_load_
$LN7@s370_load_:

; 621  :         }
; 622  : 
; 623  :         /* Count significant digits */
; 624  :         if (n > 0 || h != 0)

  0010f	83 7c 24 3c 00	 cmp	 DWORD PTR n$[rsp], 0
  00114	7f 07		 jg	 SHORT $LN9@s370_load_
  00116	83 7c 24 30 00	 cmp	 DWORD PTR h$[rsp], 0
  0011b	74 0a		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:

; 625  :             n++;

  0011d	8b 44 24 3c	 mov	 eax, DWORD PTR n$[rsp]
  00121	ff c0		 inc	 eax
  00123	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax
$LN8@s370_load_:

; 626  : 
; 627  :         /* Store decimal digit in result */
; 628  :         result[i] = h;

  00127	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  0012c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00134	0f b6 54 24 30	 movzx	 edx, BYTE PTR h$[rsp]
  00139	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 629  : 
; 630  :     } /* end for */

  0013c	e9 50 ff ff ff	 jmp	 $LN2@s370_load_
$LN3@s370_load_:

; 631  : 
; 632  :     /* Check for valid sign */
; 633  :     h = pack[MAX_DECIMAL_LENGTH-1] & 0x0F;

  00141	b8 01 00 00 00	 mov	 eax, 1
  00146	48 6b c0 0f	 imul	 rax, rax, 15
  0014a	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  0014f	83 e0 0f	 and	 eax, 15
  00152	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax

; 634  :     if (h < 0x0A)

  00156	83 7c 24 30 0a	 cmp	 DWORD PTR h$[rsp], 10
  0015b	7d 26		 jge	 SHORT $LN10@s370_load_

; 635  :     {
; 636  :         regs->dxc = DXC_DECIMAL;

  0015d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 637  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0016f	ba 07 00 00 00	 mov	 edx, 7
  00174	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017c	e8 00 00 00 00	 call	 s370_program_interrupt

; 638  :         return;

  00181	eb 3c		 jmp	 SHORT $LN1@s370_load_
$LN10@s370_load_:

; 639  :     }
; 640  : 
; 641  :     /* Set number of significant digits */
; 642  :     *count = n;

  00183	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR count$[rsp]
  0018b	8b 4c 24 3c	 mov	 ecx, DWORD PTR n$[rsp]
  0018f	89 08		 mov	 DWORD PTR [rax], ecx

; 643  : 
; 644  :     /* Set sign of operand */
; 645  :     *sign = (h == 0x0B || h == 0x0D) ? -1 : 1;

  00191	83 7c 24 30 0b	 cmp	 DWORD PTR h$[rsp], 11
  00196	74 11		 je	 SHORT $LN12@s370_load_
  00198	83 7c 24 30 0d	 cmp	 DWORD PTR h$[rsp], 13
  0019d	74 0a		 je	 SHORT $LN12@s370_load_
  0019f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
  001a7	eb 08		 jmp	 SHORT $LN13@s370_load_
$LN12@s370_load_:
  001a9	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR tv144[rsp], -1
$LN13@s370_load_:
  001b1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  001b9	8b 4c 24 40	 mov	 ecx, DWORD PTR tv144[rsp]
  001bd	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@s370_load_:

; 646  : 
; 647  : } /* end function ARCH_DEP(load_decimal) */

  001bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c4	48 33 cc	 xor	 rcx, rsp
  001c7	e8 00 00 00 00	 call	 __security_check_cookie
  001cc	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001d0	5f		 pop	 rdi
  001d1	c3		 ret	 0
s370_load_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
index1$ = 32
flag$ = 36
div$ = 40
index2$ = 44
index$ = 48
qtest$ = 52
scale$ = 56
num1$ = 64
num2$ = 72
temp2$ = 80
indexr$ = 84
tv180 = 88
tv202 = 92
tv217 = 96
temp3$ = 100
temp5$ = 104
indexq$ = 108
tv129 = 112
temp1$ = 116
temp4$ = 120
dec1$ = 160
count1$ = 168
dec2$ = 176
count2$ = 184
quot$ = 192
rem$ = 200
divide_decimal PROC

; 425  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 426  : BYTE   *num1;                           /* -> dividend digits        */
; 427  : BYTE   *num2;                           /* -> divisor digits         */
; 428  : int     div, flag, scale;               /* Work areas for algorithm  */
; 429  : int     index, index1, index2;          /* Work areas for algorithm  */
; 430  : int     indexq, indexr, temp1, temp2;   /* Work areas for algorithm  */
; 431  : int     temp3, temp4, temp5, qtest;     /* Work areas for algorithm  */
; 432  : 
; 433  :     /* Clear the result fields */
; 434  :     memset (quot, 0, MAX_DECIMAL_DIGITS);

  0001c	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR quot$[rsp]
  00024	33 c0		 xor	 eax, eax
  00026	b9 1f 00 00 00	 mov	 ecx, 31
  0002b	f3 aa		 rep stosb

; 435  :     memset (rem, 0, MAX_DECIMAL_DIGITS);

  0002d	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR rem$[rsp]
  00035	33 c0		 xor	 eax, eax
  00037	b9 1f 00 00 00	 mov	 ecx, 31
  0003c	f3 aa		 rep stosb

; 436  : 
; 437  :     /* If dividend is zero then return zero quotient and remainder */
; 438  :     if (count1 == 0)

  0003e	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR count1$[rsp], 0
  00046	75 05		 jne	 SHORT $LN25@divide_dec

; 439  :         return;

  00048	e9 75 06 00 00	 jmp	 $LN1@divide_dec
$LN25@divide_dec:

; 440  : 
; 441  :     /* If dividend is less than divisor then return zero quotient
; 442  :        and set remainder equal to dividend */
; 443  :     if (memcmp (dec1, dec2, MAX_DECIMAL_DIGITS) < 0)

  0004d	41 b8 1f 00 00
	00		 mov	 r8d, 31
  00053	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dec2$[rsp]
  0005b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dec1$[rsp]
  00063	e8 00 00 00 00	 call	 memcmp
  00068	85 c0		 test	 eax, eax
  0006a	7d 1c		 jge	 SHORT $LN26@divide_dec

; 444  :     {
; 445  :         memcpy (rem, dec1, MAX_DECIMAL_DIGITS);

  0006c	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR rem$[rsp]
  00074	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR dec1$[rsp]
  0007c	b9 1f 00 00 00	 mov	 ecx, 31
  00081	f3 a4		 rep movsb

; 446  :         return;

  00083	e9 3a 06 00 00	 jmp	 $LN1@divide_dec
$LN26@divide_dec:

; 447  :     }
; 448  : 
; 449  :     /* Adjust dividend digit count to give one leading zero */
; 450  :     count1++;

  00088	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR count1$[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 84 24 a8 00
	00 00		 mov	 DWORD PTR count1$[rsp], eax

; 451  : 
; 452  :     /* Point to significant digits of dividend with leading zero */
; 453  :     num1 = dec1 + MAX_DECIMAL_DIGITS - count1;

  00098	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dec1$[rsp]
  000a0	48 83 c0 1f	 add	 rax, 31
  000a4	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR count1$[rsp]
  000ac	48 2b c1	 sub	 rax, rcx
  000af	48 89 44 24 40	 mov	 QWORD PTR num1$[rsp], rax

; 454  : 
; 455  :     /* Point to significant digits of divisor */
; 456  :     num2 = dec2 + MAX_DECIMAL_DIGITS - count2;

  000b4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dec2$[rsp]
  000bc	48 83 c0 1f	 add	 rax, 31
  000c0	48 63 8c 24 b8
	00 00 00	 movsxd	 rcx, DWORD PTR count2$[rsp]
  000c8	48 2b c1	 sub	 rax, rcx
  000cb	48 89 44 24 48	 mov	 QWORD PTR num2$[rsp], rax

; 457  : 
; 458  :     scale = 10 / (num2[0] + 1);

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	48 6b c0 00	 imul	 rax, rax, 0
  000d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR num2$[rsp]
  000de	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e2	ff c0		 inc	 eax
  000e4	89 44 24 70	 mov	 DWORD PTR tv129[rsp], eax
  000e8	b8 0a 00 00 00	 mov	 eax, 10
  000ed	99		 cdq
  000ee	8b 4c 24 70	 mov	 ecx, DWORD PTR tv129[rsp]
  000f2	f7 f9		 idiv	 ecx
  000f4	89 44 24 38	 mov	 DWORD PTR scale$[rsp], eax

; 459  :     if (scale > 1)

  000f8	83 7c 24 38 01	 cmp	 DWORD PTR scale$[rsp], 1
  000fd	0f 8e f0 00 00
	00		 jle	 $LN27@divide_dec

; 460  :     {
; 461  :         for (index1 = count1-1, flag = 0; index1 >= 0; index1--)

  00103	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR count1$[rsp]
  0010a	ff c8		 dec	 eax
  0010c	89 44 24 20	 mov	 DWORD PTR index1$[rsp], eax
  00110	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0
  00118	eb 0a		 jmp	 SHORT $LN4@divide_dec
$LN2@divide_dec:
  0011a	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  0011e	ff c8		 dec	 eax
  00120	89 44 24 20	 mov	 DWORD PTR index1$[rsp], eax
$LN4@divide_dec:
  00124	83 7c 24 20 00	 cmp	 DWORD PTR index1$[rsp], 0
  00129	7c 50		 jl	 SHORT $LN3@divide_dec

; 462  :         {
; 463  :             div = flag + scale*num1[index1];

  0012b	48 63 44 24 20	 movsxd	 rax, DWORD PTR index1$[rsp]
  00130	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  00135	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00139	8b 4c 24 38	 mov	 ecx, DWORD PTR scale$[rsp]
  0013d	0f af c8	 imul	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	8b 4c 24 24	 mov	 ecx, DWORD PTR flag$[rsp]
  00146	03 c8		 add	 ecx, eax
  00148	8b c1		 mov	 eax, ecx
  0014a	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 464  :             num1[index1] = div % 10;

  0014e	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  00152	99		 cdq
  00153	b9 0a 00 00 00	 mov	 ecx, 10
  00158	f7 f9		 idiv	 ecx
  0015a	8b c2		 mov	 eax, edx
  0015c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR index1$[rsp]
  00161	48 8b 54 24 40	 mov	 rdx, QWORD PTR num1$[rsp]
  00166	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 465  :             flag = div / 10;

  00169	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  0016d	99		 cdq
  0016e	b9 0a 00 00 00	 mov	 ecx, 10
  00173	f7 f9		 idiv	 ecx
  00175	89 44 24 24	 mov	 DWORD PTR flag$[rsp], eax

; 466  :         } /* end for(index1) */

  00179	eb 9f		 jmp	 SHORT $LN2@divide_dec
$LN3@divide_dec:

; 467  : 
; 468  :         for (index2 = count2-1, flag = 0; index2 >= 0; index2--)

  0017b	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  00182	ff c8		 dec	 eax
  00184	89 44 24 2c	 mov	 DWORD PTR index2$[rsp], eax
  00188	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0
  00190	eb 0a		 jmp	 SHORT $LN7@divide_dec
$LN5@divide_dec:
  00192	8b 44 24 2c	 mov	 eax, DWORD PTR index2$[rsp]
  00196	ff c8		 dec	 eax
  00198	89 44 24 2c	 mov	 DWORD PTR index2$[rsp], eax
$LN7@divide_dec:
  0019c	83 7c 24 2c 00	 cmp	 DWORD PTR index2$[rsp], 0
  001a1	7c 50		 jl	 SHORT $LN6@divide_dec

; 469  :         {
; 470  :             div = flag + scale*num2[index2];

  001a3	48 63 44 24 2c	 movsxd	 rax, DWORD PTR index2$[rsp]
  001a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR num2$[rsp]
  001ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b1	8b 4c 24 38	 mov	 ecx, DWORD PTR scale$[rsp]
  001b5	0f af c8	 imul	 ecx, eax
  001b8	8b c1		 mov	 eax, ecx
  001ba	8b 4c 24 24	 mov	 ecx, DWORD PTR flag$[rsp]
  001be	03 c8		 add	 ecx, eax
  001c0	8b c1		 mov	 eax, ecx
  001c2	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 471  :             num2[index2] = div % 10;

  001c6	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  001ca	99		 cdq
  001cb	b9 0a 00 00 00	 mov	 ecx, 10
  001d0	f7 f9		 idiv	 ecx
  001d2	8b c2		 mov	 eax, edx
  001d4	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR index2$[rsp]
  001d9	48 8b 54 24 48	 mov	 rdx, QWORD PTR num2$[rsp]
  001de	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 472  :             flag = div / 10;

  001e1	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  001e5	99		 cdq
  001e6	b9 0a 00 00 00	 mov	 ecx, 10
  001eb	f7 f9		 idiv	 ecx
  001ed	89 44 24 24	 mov	 DWORD PTR flag$[rsp], eax

; 473  :         } /* end for(index2) */

  001f1	eb 9f		 jmp	 SHORT $LN5@divide_dec
$LN6@divide_dec:
$LN27@divide_dec:

; 474  : 
; 475  :     } /* end if(scale>1) */
; 476  : 
; 477  :     for (index1 = 0; index1 < count1-count2; index1++)

  001f3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR index1$[rsp], 0
  001fb	eb 0a		 jmp	 SHORT $LN10@divide_dec
$LN8@divide_dec:
  001fd	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  00201	ff c0		 inc	 eax
  00203	89 44 24 20	 mov	 DWORD PTR index1$[rsp], eax
$LN10@divide_dec:
  00207	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  0020e	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR count1$[rsp]
  00215	2b c8		 sub	 ecx, eax
  00217	8b c1		 mov	 eax, ecx
  00219	39 44 24 20	 cmp	 DWORD PTR index1$[rsp], eax
  0021d	0f 8d a2 03 00
	00		 jge	 $LN9@divide_dec

; 478  :     {
; 479  :         if (num2[0] == num1[index1])

  00223	b8 01 00 00 00	 mov	 eax, 1
  00228	48 6b c0 00	 imul	 rax, rax, 0
  0022c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR num2$[rsp]
  00231	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00235	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR index1$[rsp]
  0023a	48 8b 54 24 40	 mov	 rdx, QWORD PTR num1$[rsp]
  0023f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00243	3b c1		 cmp	 eax, ecx
  00245	75 0a		 jne	 SHORT $LN28@divide_dec

; 480  :             qtest = 9;

  00247	c7 44 24 34 09
	00 00 00	 mov	 DWORD PTR qtest$[rsp], 9
  0024f	eb 64		 jmp	 SHORT $LN29@divide_dec
$LN28@divide_dec:

; 481  :         else
; 482  :         {
; 483  :             temp2 = (index1+1 < count1) ? num1[index1+1] : 0;

  00251	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  00255	ff c0		 inc	 eax
  00257	3b 84 24 a8 00
	00 00		 cmp	 eax, DWORD PTR count1$[rsp]
  0025e	7d 17		 jge	 SHORT $LN42@divide_dec
  00260	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  00264	ff c0		 inc	 eax
  00266	48 98		 cdqe
  00268	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  0026d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00271	89 44 24 58	 mov	 DWORD PTR tv180[rsp], eax
  00275	eb 08		 jmp	 SHORT $LN43@divide_dec
$LN42@divide_dec:
  00277	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN43@divide_dec:
  0027f	8b 44 24 58	 mov	 eax, DWORD PTR tv180[rsp]
  00283	89 44 24 50	 mov	 DWORD PTR temp2$[rsp], eax

; 484  :             qtest = (10*num1[index1] + temp2) / num2[0];

  00287	48 63 44 24 20	 movsxd	 rax, DWORD PTR index1$[rsp]
  0028c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  00291	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00295	6b c0 0a	 imul	 eax, eax, 10
  00298	03 44 24 50	 add	 eax, DWORD PTR temp2$[rsp]
  0029c	b9 01 00 00 00	 mov	 ecx, 1
  002a1	48 6b c9 00	 imul	 rcx, rcx, 0
  002a5	48 8b 54 24 48	 mov	 rdx, QWORD PTR num2$[rsp]
  002aa	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002ae	99		 cdq
  002af	f7 f9		 idiv	 ecx
  002b1	89 44 24 34	 mov	 DWORD PTR qtest$[rsp], eax
$LN29@divide_dec:

; 485  :         }
; 486  :         temp2 = num1[index1];

  002b5	48 63 44 24 20	 movsxd	 rax, DWORD PTR index1$[rsp]
  002ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  002bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c3	89 44 24 50	 mov	 DWORD PTR temp2$[rsp], eax

; 487  :         temp4 = num2[0];

  002c7	b8 01 00 00 00	 mov	 eax, 1
  002cc	48 6b c0 00	 imul	 rax, rax, 0
  002d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR num2$[rsp]
  002d5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d9	89 44 24 78	 mov	 DWORD PTR temp4$[rsp], eax

; 488  :         temp1 = (count2 >= 2) ? num2[1] : 0;

  002dd	83 bc 24 b8 00
	00 00 02	 cmp	 DWORD PTR count2$[rsp], 2
  002e5	7c 18		 jl	 SHORT $LN44@divide_dec
  002e7	b8 01 00 00 00	 mov	 eax, 1
  002ec	48 6b c0 01	 imul	 rax, rax, 1
  002f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR num2$[rsp]
  002f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f9	89 44 24 5c	 mov	 DWORD PTR tv202[rsp], eax
  002fd	eb 08		 jmp	 SHORT $LN45@divide_dec
$LN44@divide_dec:
  002ff	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN45@divide_dec:
  00307	8b 44 24 5c	 mov	 eax, DWORD PTR tv202[rsp]
  0030b	89 44 24 74	 mov	 DWORD PTR temp1$[rsp], eax

; 489  :         if (index1+1 < count1)

  0030f	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  00313	ff c0		 inc	 eax
  00315	3b 84 24 a8 00
	00 00		 cmp	 eax, DWORD PTR count1$[rsp]
  0031c	7d 4f		 jge	 SHORT $LN30@divide_dec

; 490  :         {
; 491  :             temp3 = num1[index1+1];

  0031e	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  00322	ff c0		 inc	 eax
  00324	48 98		 cdqe
  00326	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  0032b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0032f	89 44 24 64	 mov	 DWORD PTR temp3$[rsp], eax

; 492  :             temp5 = (index1+2 < count1) ? num1[index1+2] : 0;

  00333	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  00337	83 c0 02	 add	 eax, 2
  0033a	3b 84 24 a8 00
	00 00		 cmp	 eax, DWORD PTR count1$[rsp]
  00341	7d 18		 jge	 SHORT $LN46@divide_dec
  00343	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  00347	83 c0 02	 add	 eax, 2
  0034a	48 98		 cdqe
  0034c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  00351	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00355	89 44 24 60	 mov	 DWORD PTR tv217[rsp], eax
  00359	eb 08		 jmp	 SHORT $LN47@divide_dec
$LN46@divide_dec:
  0035b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv217[rsp], 0
$LN47@divide_dec:
  00363	8b 44 24 60	 mov	 eax, DWORD PTR tv217[rsp]
  00367	89 44 24 68	 mov	 DWORD PTR temp5$[rsp], eax

; 493  :         }

  0036b	eb 10		 jmp	 SHORT $LN31@divide_dec
$LN30@divide_dec:

; 494  :         else
; 495  :         {
; 496  :             temp3 = 0;

  0036d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR temp3$[rsp], 0

; 497  :             temp5 = 0;

  00375	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR temp5$[rsp], 0
$LN31@divide_dec:
$LN11@divide_dec:

; 498  :         }
; 499  :         while (qtest*temp1 > (10*(10*temp2 + temp3

  0037d	8b 44 24 34	 mov	 eax, DWORD PTR qtest$[rsp]
  00381	0f af 44 24 74	 imul	 eax, DWORD PTR temp1$[rsp]
  00386	6b 4c 24 50 0a	 imul	 ecx, DWORD PTR temp2$[rsp], 10
  0038b	03 4c 24 64	 add	 ecx, DWORD PTR temp3$[rsp]
  0038f	8b 54 24 34	 mov	 edx, DWORD PTR qtest$[rsp]
  00393	0f af 54 24 78	 imul	 edx, DWORD PTR temp4$[rsp]
  00398	2b ca		 sub	 ecx, edx
  0039a	6b c9 0a	 imul	 ecx, ecx, 10
  0039d	03 4c 24 68	 add	 ecx, DWORD PTR temp5$[rsp]
  003a1	3b c1		 cmp	 eax, ecx
  003a3	7e 0c		 jle	 SHORT $LN12@divide_dec

; 500  :                             - qtest*temp4) + temp5))
; 501  :             --qtest;

  003a5	8b 44 24 34	 mov	 eax, DWORD PTR qtest$[rsp]
  003a9	ff c8		 dec	 eax
  003ab	89 44 24 34	 mov	 DWORD PTR qtest$[rsp], eax
  003af	eb cc		 jmp	 SHORT $LN11@divide_dec
$LN12@divide_dec:

; 502  : 
; 503  :         for (index = index1+count2, index2 = count2-1, flag = 0;

  003b1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  003b8	8b 4c 24 20	 mov	 ecx, DWORD PTR index1$[rsp]
  003bc	03 c8		 add	 ecx, eax
  003be	8b c1		 mov	 eax, ecx
  003c0	89 44 24 30	 mov	 DWORD PTR index$[rsp], eax
  003c4	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  003cb	ff c8		 dec	 eax
  003cd	89 44 24 2c	 mov	 DWORD PTR index2$[rsp], eax
  003d1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0
  003d9	eb 14		 jmp	 SHORT $LN15@divide_dec
$LN13@divide_dec:

; 504  :                 index >= index1; index--, index2--)

  003db	8b 44 24 30	 mov	 eax, DWORD PTR index$[rsp]
  003df	ff c8		 dec	 eax
  003e1	89 44 24 30	 mov	 DWORD PTR index$[rsp], eax
  003e5	8b 44 24 2c	 mov	 eax, DWORD PTR index2$[rsp]
  003e9	ff c8		 dec	 eax
  003eb	89 44 24 2c	 mov	 DWORD PTR index2$[rsp], eax
$LN15@divide_dec:
  003ef	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  003f3	39 44 24 30	 cmp	 DWORD PTR index$[rsp], eax
  003f7	0f 8c aa 00 00
	00		 jl	 $LN14@divide_dec

; 505  :         {
; 506  :             if (index2 >= 0)

  003fd	83 7c 24 2c 00	 cmp	 DWORD PTR index2$[rsp], 0
  00402	7c 23		 jl	 SHORT $LN32@divide_dec

; 507  :                 flag -= qtest*num2[index2];

  00404	48 63 44 24 2c	 movsxd	 rax, DWORD PTR index2$[rsp]
  00409	48 8b 4c 24 48	 mov	 rcx, QWORD PTR num2$[rsp]
  0040e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00412	8b 4c 24 34	 mov	 ecx, DWORD PTR qtest$[rsp]
  00416	0f af c8	 imul	 ecx, eax
  00419	8b c1		 mov	 eax, ecx
  0041b	8b 4c 24 24	 mov	 ecx, DWORD PTR flag$[rsp]
  0041f	2b c8		 sub	 ecx, eax
  00421	8b c1		 mov	 eax, ecx
  00423	89 44 24 24	 mov	 DWORD PTR flag$[rsp], eax
$LN32@divide_dec:

; 508  :             div = flag + num1[index];

  00427	48 63 44 24 30	 movsxd	 rax, DWORD PTR index$[rsp]
  0042c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  00431	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00435	8b 4c 24 24	 mov	 ecx, DWORD PTR flag$[rsp]
  00439	03 c8		 add	 ecx, eax
  0043b	8b c1		 mov	 eax, ecx
  0043d	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 509  :             if (div < 0)

  00441	83 7c 24 28 00	 cmp	 DWORD PTR div$[rsp], 0
  00446	7d 40		 jge	 SHORT $LN33@divide_dec

; 510  :             {
; 511  :                 flag = div / 10;

  00448	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  0044c	99		 cdq
  0044d	b9 0a 00 00 00	 mov	 ecx, 10
  00452	f7 f9		 idiv	 ecx
  00454	89 44 24 24	 mov	 DWORD PTR flag$[rsp], eax

; 512  :                 div %= 10;

  00458	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  0045c	99		 cdq
  0045d	b9 0a 00 00 00	 mov	 ecx, 10
  00462	f7 f9		 idiv	 ecx
  00464	8b c2		 mov	 eax, edx
  00466	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 513  :                 if (div < 0)

  0046a	83 7c 24 28 00	 cmp	 DWORD PTR div$[rsp], 0
  0046f	7d 15		 jge	 SHORT $LN35@divide_dec

; 514  :                 {
; 515  :                     div += 10;

  00471	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  00475	83 c0 0a	 add	 eax, 10
  00478	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 516  :                     --flag;

  0047c	8b 44 24 24	 mov	 eax, DWORD PTR flag$[rsp]
  00480	ff c8		 dec	 eax
  00482	89 44 24 24	 mov	 DWORD PTR flag$[rsp], eax
$LN35@divide_dec:

; 517  :                 }
; 518  :             }

  00486	eb 08		 jmp	 SHORT $LN34@divide_dec
$LN33@divide_dec:

; 519  :             else
; 520  :                 flag = 0;

  00488	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0
$LN34@divide_dec:

; 521  :             num1[index] = div;

  00490	48 63 44 24 30	 movsxd	 rax, DWORD PTR index$[rsp]
  00495	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  0049a	0f b6 54 24 28	 movzx	 edx, BYTE PTR div$[rsp]
  0049f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 522  :         } /* end for(index) */

  004a2	e9 34 ff ff ff	 jmp	 $LN13@divide_dec
$LN14@divide_dec:

; 523  : 
; 524  :         indexq = MAX_DECIMAL_DIGITS - (count1-count2) + index1;

  004a7	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  004ae	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR count1$[rsp]
  004b5	2b c8		 sub	 ecx, eax
  004b7	8b c1		 mov	 eax, ecx
  004b9	b9 1f 00 00 00	 mov	 ecx, 31
  004be	2b c8		 sub	 ecx, eax
  004c0	8b c1		 mov	 eax, ecx
  004c2	03 44 24 20	 add	 eax, DWORD PTR index1$[rsp]
  004c6	89 44 24 6c	 mov	 DWORD PTR indexq$[rsp], eax

; 525  :         if (flag != 0)

  004ca	83 7c 24 24 00	 cmp	 DWORD PTR flag$[rsp], 0
  004cf	0f 84 d6 00 00
	00		 je	 $LN36@divide_dec

; 526  :         {
; 527  :             quot[indexq] = qtest - 1;

  004d5	8b 44 24 34	 mov	 eax, DWORD PTR qtest$[rsp]
  004d9	ff c8		 dec	 eax
  004db	48 63 4c 24 6c	 movsxd	 rcx, DWORD PTR indexq$[rsp]
  004e0	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR quot$[rsp]
  004e8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 528  :             for (index = index1+count2, index2 = count2-1, flag = 0;

  004eb	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  004f2	8b 4c 24 20	 mov	 ecx, DWORD PTR index1$[rsp]
  004f6	03 c8		 add	 ecx, eax
  004f8	8b c1		 mov	 eax, ecx
  004fa	89 44 24 30	 mov	 DWORD PTR index$[rsp], eax
  004fe	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  00505	ff c8		 dec	 eax
  00507	89 44 24 2c	 mov	 DWORD PTR index2$[rsp], eax
  0050b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0
  00513	eb 14		 jmp	 SHORT $LN18@divide_dec
$LN16@divide_dec:

; 529  :                     index >= index1; index--, index2--)

  00515	8b 44 24 30	 mov	 eax, DWORD PTR index$[rsp]
  00519	ff c8		 dec	 eax
  0051b	89 44 24 30	 mov	 DWORD PTR index$[rsp], eax
  0051f	8b 44 24 2c	 mov	 eax, DWORD PTR index2$[rsp]
  00523	ff c8		 dec	 eax
  00525	89 44 24 2c	 mov	 DWORD PTR index2$[rsp], eax
$LN18@divide_dec:
  00529	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  0052d	39 44 24 30	 cmp	 DWORD PTR index$[rsp], eax
  00531	7c 76		 jl	 SHORT $LN17@divide_dec

; 530  :             {
; 531  :                 if (index2 >= 0)

  00533	83 7c 24 2c 00	 cmp	 DWORD PTR index2$[rsp], 0
  00538	7c 1a		 jl	 SHORT $LN38@divide_dec

; 532  :                     flag += num2[index2];

  0053a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR index2$[rsp]
  0053f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR num2$[rsp]
  00544	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00548	8b 4c 24 24	 mov	 ecx, DWORD PTR flag$[rsp]
  0054c	03 c8		 add	 ecx, eax
  0054e	8b c1		 mov	 eax, ecx
  00550	89 44 24 24	 mov	 DWORD PTR flag$[rsp], eax
$LN38@divide_dec:

; 533  :                 div = flag + num1[index];

  00554	48 63 44 24 30	 movsxd	 rax, DWORD PTR index$[rsp]
  00559	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  0055e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00562	8b 4c 24 24	 mov	 ecx, DWORD PTR flag$[rsp]
  00566	03 c8		 add	 ecx, eax
  00568	8b c1		 mov	 eax, ecx
  0056a	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 534  :                 if (div > 9)

  0056e	83 7c 24 28 09	 cmp	 DWORD PTR div$[rsp], 9
  00573	7e 15		 jle	 SHORT $LN39@divide_dec

; 535  :                 {
; 536  :                     div -= 10;

  00575	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  00579	83 e8 0a	 sub	 eax, 10
  0057c	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 537  :                     flag = 1;

  00580	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR flag$[rsp], 1

; 538  :                 }

  00588	eb 08		 jmp	 SHORT $LN40@divide_dec
$LN39@divide_dec:

; 539  :                 else
; 540  :                     flag = 0;

  0058a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0
$LN40@divide_dec:

; 541  :                 num1[index] = div;

  00592	48 63 44 24 30	 movsxd	 rax, DWORD PTR index$[rsp]
  00597	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  0059c	0f b6 54 24 28	 movzx	 edx, BYTE PTR div$[rsp]
  005a1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 542  :             } /* end for(index) */

  005a4	e9 6c ff ff ff	 jmp	 $LN16@divide_dec
$LN17@divide_dec:

; 543  :         }

  005a9	eb 15		 jmp	 SHORT $LN37@divide_dec
$LN36@divide_dec:

; 544  :         else
; 545  :             quot[indexq] = qtest;

  005ab	48 63 44 24 6c	 movsxd	 rax, DWORD PTR indexq$[rsp]
  005b0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR quot$[rsp]
  005b8	0f b6 54 24 34	 movzx	 edx, BYTE PTR qtest$[rsp]
  005bd	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
$LN37@divide_dec:

; 546  :     } /* end for(index1) */

  005c0	e9 38 fc ff ff	 jmp	 $LN8@divide_dec
$LN9@divide_dec:

; 547  : 
; 548  :     for (index1 = count1-count2,
; 549  :             indexr = MAX_DECIMAL_DIGITS-count2, flag = 0;

  005c5	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  005cc	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR count1$[rsp]
  005d3	2b c8		 sub	 ecx, eax
  005d5	8b c1		 mov	 eax, ecx
  005d7	89 44 24 20	 mov	 DWORD PTR index1$[rsp], eax
  005db	b8 1f 00 00 00	 mov	 eax, 31
  005e0	2b 84 24 b8 00
	00 00		 sub	 eax, DWORD PTR count2$[rsp]
  005e7	89 44 24 54	 mov	 DWORD PTR indexr$[rsp], eax
  005eb	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0
  005f3	eb 14		 jmp	 SHORT $LN21@divide_dec
$LN19@divide_dec:

; 550  :             index1 < count1; index1++, indexr++)

  005f5	8b 44 24 20	 mov	 eax, DWORD PTR index1$[rsp]
  005f9	ff c0		 inc	 eax
  005fb	89 44 24 20	 mov	 DWORD PTR index1$[rsp], eax
  005ff	8b 44 24 54	 mov	 eax, DWORD PTR indexr$[rsp]
  00603	ff c0		 inc	 eax
  00605	89 44 24 54	 mov	 DWORD PTR indexr$[rsp], eax
$LN21@divide_dec:
  00609	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR count1$[rsp]
  00610	39 44 24 20	 cmp	 DWORD PTR index1$[rsp], eax
  00614	7d 43		 jge	 SHORT $LN20@divide_dec

; 551  :     {
; 552  :         div = num1[index1] + 10*flag;

  00616	48 63 44 24 20	 movsxd	 rax, DWORD PTR index1$[rsp]
  0061b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num1$[rsp]
  00620	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00624	6b 4c 24 24 0a	 imul	 ecx, DWORD PTR flag$[rsp], 10
  00629	03 c1		 add	 eax, ecx
  0062b	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 553  :         rem[indexr] = div / scale;

  0062f	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  00633	99		 cdq
  00634	f7 7c 24 38	 idiv	 DWORD PTR scale$[rsp]
  00638	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR indexr$[rsp]
  0063d	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR rem$[rsp]
  00645	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 554  :         flag = div % scale;

  00648	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  0064c	99		 cdq
  0064d	f7 7c 24 38	 idiv	 DWORD PTR scale$[rsp]
  00651	8b c2		 mov	 eax, edx
  00653	89 44 24 24	 mov	 DWORD PTR flag$[rsp], eax

; 555  :     } /* end for(index1) */

  00657	eb 9c		 jmp	 SHORT $LN19@divide_dec
$LN20@divide_dec:

; 556  : 
; 557  :     for (index2 = 0, flag = 0; index2 < count2; index2++)

  00659	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR index2$[rsp], 0
  00661	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0
  00669	eb 0a		 jmp	 SHORT $LN24@divide_dec
$LN22@divide_dec:
  0066b	8b 44 24 2c	 mov	 eax, DWORD PTR index2$[rsp]
  0066f	ff c0		 inc	 eax
  00671	89 44 24 2c	 mov	 DWORD PTR index2$[rsp], eax
$LN24@divide_dec:
  00675	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count2$[rsp]
  0067c	39 44 24 2c	 cmp	 DWORD PTR index2$[rsp], eax
  00680	7d 40		 jge	 SHORT $LN23@divide_dec

; 558  :     {
; 559  :         div = num2[index2] + 10*flag;

  00682	48 63 44 24 2c	 movsxd	 rax, DWORD PTR index2$[rsp]
  00687	48 8b 4c 24 48	 mov	 rcx, QWORD PTR num2$[rsp]
  0068c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00690	6b 4c 24 24 0a	 imul	 ecx, DWORD PTR flag$[rsp], 10
  00695	03 c1		 add	 eax, ecx
  00697	89 44 24 28	 mov	 DWORD PTR div$[rsp], eax

; 560  :         num2[index2] = div / scale;

  0069b	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  0069f	99		 cdq
  006a0	f7 7c 24 38	 idiv	 DWORD PTR scale$[rsp]
  006a4	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR index2$[rsp]
  006a9	48 8b 54 24 48	 mov	 rdx, QWORD PTR num2$[rsp]
  006ae	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 561  :         flag = div % scale;

  006b1	8b 44 24 28	 mov	 eax, DWORD PTR div$[rsp]
  006b5	99		 cdq
  006b6	f7 7c 24 38	 idiv	 DWORD PTR scale$[rsp]
  006ba	8b c2		 mov	 eax, edx
  006bc	89 44 24 24	 mov	 DWORD PTR flag$[rsp], eax

; 562  :     } /* end for(index2) */

  006c0	eb a9		 jmp	 SHORT $LN22@divide_dec
$LN23@divide_dec:
$LN1@divide_dec:

; 563  : 
; 564  : } /* end function divide_decimal */

  006c2	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  006c9	5f		 pop	 rdi
  006ca	5e		 pop	 rsi
  006cb	c3		 ret	 0
divide_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 32
d$ = 36
borrow$ = 40
rc$ = 44
n$ = 48
higher$ = 56
lower$ = 64
dec1$ = 96
dec2$ = 104
result$ = 112
count$ = 120
sign$ = 128
subtract_decimal PROC

; 340  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 341  : int     d;                              /* Decimal digit             */
; 342  : int     i;                              /* Array subscript           */
; 343  : int     n = 0;                          /* Significant digit counter */

  00019	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 344  : int     borrow = 0;                     /* Borrow indicator          */

  00021	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR borrow$[rsp], 0

; 345  : int     rc;                             /* Return code               */
; 346  : BYTE   *higher;                         /* -> Higher value operand   */
; 347  : BYTE   *lower;                          /* -> Lower value operand    */
; 348  : 
; 349  :     /* Compare digits to find which operand has higher numeric value */
; 350  :     rc = memcmp (dec1, dec2, MAX_DECIMAL_DIGITS);

  00029	41 b8 1f 00 00
	00		 mov	 r8d, 31
  0002f	48 8b 54 24 68	 mov	 rdx, QWORD PTR dec2$[rsp]
  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dec1$[rsp]
  00039	e8 00 00 00 00	 call	 memcmp
  0003e	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax

; 351  : 
; 352  :     /* Return positive zero result if both operands are equal */
; 353  :     if (rc == 0) {

  00042	83 7c 24 2c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00047	75 2c		 jne	 SHORT $LN5@subtract_d

; 354  :         memset (result, 0, MAX_DECIMAL_DIGITS);

  00049	48 8b 7c 24 70	 mov	 rdi, QWORD PTR result$[rsp]
  0004e	33 c0		 xor	 eax, eax
  00050	b9 1f 00 00 00	 mov	 ecx, 31
  00055	f3 aa		 rep stosb

; 355  :         *count = 0;

  00057	48 8b 44 24 78	 mov	 rax, QWORD PTR count$[rsp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 356  :         *sign = +1;

  00062	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  0006a	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 357  :         return;

  00070	e9 e8 00 00 00	 jmp	 $LN1@subtract_d
$LN5@subtract_d:

; 358  :     }
; 359  : 
; 360  :     /* Point to higher and lower value operands and set sign */
; 361  :     if (rc > 0) {

  00075	83 7c 24 2c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0007a	7e 24		 jle	 SHORT $LN6@subtract_d

; 362  :         higher = dec1;

  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR dec1$[rsp]
  00081	48 89 44 24 38	 mov	 QWORD PTR higher$[rsp], rax

; 363  :         lower = dec2;

  00086	48 8b 44 24 68	 mov	 rax, QWORD PTR dec2$[rsp]
  0008b	48 89 44 24 40	 mov	 QWORD PTR lower$[rsp], rax

; 364  :        *sign = +1;

  00090	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  00098	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 365  :     } else {

  0009e	eb 22		 jmp	 SHORT $LN7@subtract_d
$LN6@subtract_d:

; 366  :         lower = dec1;

  000a0	48 8b 44 24 60	 mov	 rax, QWORD PTR dec1$[rsp]
  000a5	48 89 44 24 40	 mov	 QWORD PTR lower$[rsp], rax

; 367  :         higher = dec2;

  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR dec2$[rsp]
  000af	48 89 44 24 38	 mov	 QWORD PTR higher$[rsp], rax

; 368  :        *sign = -1;

  000b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  000bc	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
$LN7@subtract_d:

; 369  :     }
; 370  : 
; 371  :     /* Subtract digits from right to left */
; 372  :     for (i = MAX_DECIMAL_DIGITS - 1; i >= 0; i--)

  000c2	c7 44 24 20 1e
	00 00 00	 mov	 DWORD PTR i$[rsp], 30
  000ca	eb 0a		 jmp	 SHORT $LN4@subtract_d
$LN2@subtract_d:
  000cc	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000d0	ff c8		 dec	 eax
  000d2	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@subtract_d:
  000d6	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  000db	7c 75		 jl	 SHORT $LN3@subtract_d

; 373  :     {
; 374  :         /* Subtract lower operand digit from higher operand digit */
; 375  :         d = higher[i] - lower[i] - borrow;

  000dd	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR higher$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f0	48 8b 54 24 40	 mov	 rdx, QWORD PTR lower$[rsp]
  000f5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000f9	2b c1		 sub	 eax, ecx
  000fb	2b 44 24 28	 sub	 eax, DWORD PTR borrow$[rsp]
  000ff	89 44 24 24	 mov	 DWORD PTR d$[rsp], eax

; 376  : 
; 377  :         /* Check for borrow from next digit */
; 378  :         if (d < 0) {

  00103	83 7c 24 24 00	 cmp	 DWORD PTR d$[rsp], 0
  00108	7d 15		 jge	 SHORT $LN8@subtract_d

; 379  :             d += 10;

  0010a	8b 44 24 24	 mov	 eax, DWORD PTR d$[rsp]
  0010e	83 c0 0a	 add	 eax, 10
  00111	89 44 24 24	 mov	 DWORD PTR d$[rsp], eax

; 380  :             borrow = 1;

  00115	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR borrow$[rsp], 1

; 381  :         } else {

  0011d	eb 08		 jmp	 SHORT $LN9@subtract_d
$LN8@subtract_d:

; 382  :             borrow = 0;

  0011f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR borrow$[rsp], 0
$LN9@subtract_d:

; 383  :         }
; 384  : 
; 385  :         /* Check for significant digit */
; 386  :         if (d != 0)

  00127	83 7c 24 24 00	 cmp	 DWORD PTR d$[rsp], 0
  0012c	74 0d		 je	 SHORT $LN10@subtract_d

; 387  :             n = MAX_DECIMAL_DIGITS - i;

  0012e	b8 1f 00 00 00	 mov	 eax, 31
  00133	2b 44 24 20	 sub	 eax, DWORD PTR i$[rsp]
  00137	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
$LN10@subtract_d:

; 388  : 
; 389  :         /* Store digit in result */
; 390  :         result[i] = d;

  0013b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00140	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  00145	0f b6 54 24 24	 movzx	 edx, BYTE PTR d$[rsp]
  0014a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 391  : 
; 392  :     } /* end for */

  0014d	e9 7a ff ff ff	 jmp	 $LN2@subtract_d
$LN3@subtract_d:

; 393  : 
; 394  :     /* Return significant digit counter */
; 395  :     *count = n;

  00152	48 8b 44 24 78	 mov	 rax, QWORD PTR count$[rsp]
  00157	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  0015b	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@subtract_d:

; 396  : 
; 397  : } /* end function subtract_decimal */

  0015d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00161	5f		 pop	 rdi
  00162	c3		 ret	 0
subtract_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 0
d$ = 4
carry$ = 8
n$ = 12
dec1$ = 32
dec2$ = 40
result$ = 48
count$ = 56
add_decimal PROC

; 280  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 281  : int     d;                              /* Decimal digit             */
; 282  : int     i;                              /* Array subscript           */
; 283  : int     n = 0;                          /* Significant digit counter */

  00018	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 284  : int     carry = 0;                      /* Carry indicator           */

  00020	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0

; 285  : 
; 286  :     /* Add digits from right to left */
; 287  :     for (i = MAX_DECIMAL_DIGITS - 1; i >= 0; i--)

  00028	c7 04 24 1e 00
	00 00		 mov	 DWORD PTR i$[rsp], 30
  0002f	eb 08		 jmp	 SHORT $LN4@add_decima
$LN2@add_decima:
  00031	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c8		 dec	 eax
  00036	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@add_decima:
  00039	83 3c 24 00	 cmp	 DWORD PTR i$[rsp], 0
  0003d	7c 77		 jl	 SHORT $LN3@add_decima

; 288  :     {
; 289  :         /* Add digits from first and second operands */
; 290  :         d = dec1[i] + dec2[i] + carry;

  0003f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dec1$[rsp]
  00048	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004c	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00050	48 8b 54 24 28	 mov	 rdx, QWORD PTR dec2$[rsp]
  00055	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00059	8b 54 24 08	 mov	 edx, DWORD PTR carry$[rsp]
  0005d	03 d0		 add	 edx, eax
  0005f	8b c2		 mov	 eax, edx
  00061	03 c8		 add	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	89 44 24 04	 mov	 DWORD PTR d$[rsp], eax

; 291  : 
; 292  :         /* Check for carry into next digit */
; 293  :         if (d > 9) {

  00069	83 7c 24 04 09	 cmp	 DWORD PTR d$[rsp], 9
  0006e	7e 15		 jle	 SHORT $LN5@add_decima

; 294  :             d -= 10;

  00070	8b 44 24 04	 mov	 eax, DWORD PTR d$[rsp]
  00074	83 e8 0a	 sub	 eax, 10
  00077	89 44 24 04	 mov	 DWORD PTR d$[rsp], eax

; 295  :             carry = 1;

  0007b	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR carry$[rsp], 1

; 296  :         } else {

  00083	eb 08		 jmp	 SHORT $LN6@add_decima
$LN5@add_decima:

; 297  :             carry = 0;

  00085	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0
$LN6@add_decima:

; 298  :         }
; 299  : 
; 300  :         /* Check for significant digit */
; 301  :         if (d != 0)

  0008d	83 7c 24 04 00	 cmp	 DWORD PTR d$[rsp], 0
  00092	74 0c		 je	 SHORT $LN7@add_decima

; 302  :             n = MAX_DECIMAL_DIGITS - i;

  00094	b8 1f 00 00 00	 mov	 eax, 31
  00099	2b 04 24	 sub	 eax, DWORD PTR i$[rsp]
  0009c	89 44 24 0c	 mov	 DWORD PTR n$[rsp], eax
$LN7@add_decima:

; 303  : 
; 304  :         /* Store digit in result */
; 305  :         result[i] = d;

  000a0	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000a9	0f b6 54 24 04	 movzx	 edx, BYTE PTR d$[rsp]
  000ae	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 306  : 
; 307  :     } /* end for */

  000b1	e9 7b ff ff ff	 jmp	 $LN2@add_decima
$LN3@add_decima:

; 308  : 
; 309  :     /* Check for carry out of leftmost digit */
; 310  :     if (carry)

  000b6	83 7c 24 08 00	 cmp	 DWORD PTR carry$[rsp], 0
  000bb	74 08		 je	 SHORT $LN8@add_decima

; 311  :         n = MAX_DECIMAL_DIGITS + 1;

  000bd	c7 44 24 0c 20
	00 00 00	 mov	 DWORD PTR n$[rsp], 32	; 00000020H
$LN8@add_decima:

; 312  : 
; 313  :     /* Return significant digit counter */
; 314  :     *count = n;

  000c5	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  000ca	8b 4c 24 0c	 mov	 ecx, DWORD PTR n$[rsp]
  000ce	89 08		 mov	 DWORD PTR [rax], ecx

; 315  : 
; 316  : } /* end function add_decimal */

  000d0	48 83 c4 18	 add	 rsp, 24
  000d4	c3		 ret	 0
add_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_validate_operand
_TEXT	SEGMENT
tv79 = 48
tv94 = 52
tv138 = 56
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s370_validate_operand PROC				; COMDAT

; 1376 : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0004c	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN11@s370_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN12@s370_valid
$LN11@s370_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN12@s370_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 3e		 je	 SHORT $LN5@s370_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0008c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00090	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  00094	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00098	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0009d	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a2	ba 01 00 00 00	 mov	 edx, 1
  000a7	8b c8		 mov	 ecx, eax
  000a9	e8 00 00 00 00	 call	 s370_maddr_l

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }

  000ae	eb 5a		 jmp	 SHORT $LN6@s370_valid
$LN5@s370_valid:
$LN4@s370_valid:

; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );

  000b0	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b5	73 0a		 jae	 SHORT $LN15@s370_valid
  000b7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN16@s370_valid
$LN15@s370_valid:
  000c1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN16@s370_valid:
  000c9	83 7c 24 34 00	 cmp	 DWORD PTR tv94[rsp], 0
  000ce	74 1b		 je	 SHORT $LN17@s370_valid
  000d0	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  000d4	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000d8	03 c8		 add	 ecx, eax
  000da	8b c1		 mov	 eax, ecx
  000dc	83 f8 50	 cmp	 eax, 80			; 00000050H
  000df	72 0a		 jb	 SHORT $LN17@s370_valid
  000e1	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  000e9	eb 08		 jmp	 SHORT $LN23@s370_valid
$LN17@s370_valid:
  000eb	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN23@s370_valid:
  000f3	83 7c 24 38 00	 cmp	 DWORD PTR tv138[rsp], 0
  000f8	74 0a		 je	 SHORT $LN7@s370_valid
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_valid:
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 a6		 jne	 SHORT $LN4@s370_valid
$LN6@s370_valid:

; 1389 : #endif
; 1390 : }

  0010a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010e	c3		 ret	 0
s370_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchb
_TEXT	SEGMENT
tv68 = 48
tv78 = 52
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s370_vfetchb PROC					; COMDAT

; 667  : {

$LN18:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370_vfetc:

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );

  00011	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00016	73 0a		 jae	 SHORT $LN9@s370_vfetc
  00018	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00020	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00022	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN10@s370_vfetc:
  0002a	83 7c 24 30 00	 cmp	 DWORD PTR tv68[rsp], 0
  0002f	74 11		 je	 SHORT $LN11@s370_vfetc
  00031	83 7c 24 50 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00036	72 0a		 jb	 SHORT $LN11@s370_vfetc
  00038	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00040	eb 08		 jmp	 SHORT $LN17@s370_vfetc
$LN11@s370_vfetc:
  00042	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN17@s370_vfetc:
  0004a	83 7c 24 34 00	 cmp	 DWORD PTR tv78[rsp], 0
  0004f	74 0a		 je	 SHORT $LN5@s370_vfetc
  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	e8 00 00 00 00	 call	 s370_store_int_timer
$LN5@s370_vfetc:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 b0		 jne	 SHORT $LN4@s370_vfetc

; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00061	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00066	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00076	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00080	ba 01 00 00 00	 mov	 edx, 1
  00085	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00089	e8 00 00 00 00	 call	 s370_maddr_l
  0008e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00098	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0009b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009f	c3		 ret	 0
s370_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv80 = 56
tv94 = 60
main1$ = 64
main2$ = 72
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetchc PROC					; COMDAT

; 631  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN11@s370_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN12@s370_vfetc
$LN11@s370_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	0f 84 c6 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );

  00054	83 bc 24 80 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0005c	73 0a		 jae	 SHORT $LN15@s370_vfetc
  0005e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN16@s370_vfetc
$LN15@s370_vfetc:
  00068	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@s370_vfetc:
  00070	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00075	74 1f		 je	 SHORT $LN17@s370_vfetc
  00077	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008a	72 0a		 jb	 SHORT $LN17@s370_vfetc
  0008c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00094	eb 08		 jmp	 SHORT $LN23@s370_vfetc
$LN17@s370_vfetc:
  00096	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN23@s370_vfetc:
  0009e	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000a3	74 0d		 je	 SHORT $LN7@s370_vfetc
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 9c		 jne	 SHORT $LN4@s370_vfetc

; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b8	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  000bd	ff c0		 inc	 eax
  000bf	48 98		 cdqe
  000c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000cd	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000d1	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d9	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e1	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	e8 00 00 00 00	 call	 s370_maddr_l
  000f8	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  000fd	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00102	ff c0		 inc	 eax
  00104	48 98		 cdqe
  00106	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  0010b	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  00110	48 8b c8	 mov	 rcx, rax
  00113	f3 a4		 rep movsb

; 640  :     }

  00115	e9 ef 00 00 00	 jmp	 $LN6@s370_vfetc
$LN5@s370_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0011a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00121	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00126	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0012b	2b c8		 sub	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00133	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00138	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00144	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00148	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00150	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00158	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00160	48 8b d0	 mov	 rdx, rax
  00163	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_maddr_l
  0016f	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00174	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00179	ff c0		 inc	 eax
  0017b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0017f	48 98		 cdqe
  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00185	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0018c	03 d1		 add	 edx, ecx
  0018e	8b ca		 mov	 ecx, edx
  00190	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00196	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001a2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001a6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001ae	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001be	48 8b d0	 mov	 rdx, rax
  001c1	e8 00 00 00 00	 call	 s370_maddr_l
  001c6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  001cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001d0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  001d5	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  001da	48 8b c8	 mov	 rcx, rax
  001dd	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  001df	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  001e4	ff c0		 inc	 eax
  001e6	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001ea	48 98		 cdqe
  001ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001f6	48 03 d1	 add	 rdx, rcx
  001f9	48 8b ca	 mov	 rcx, rdx
  001fc	48 8b f9	 mov	 rdi, rcx
  001ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR main2$[rsp]
  00204	48 8b c8	 mov	 rcx, rax
  00207	f3 a4		 rep movsb
$LN6@s370_vfetc:

; 649  :     }
; 650  : }

  00209	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020d	5f		 pop	 rdi
  0020e	5e		 pop	 rsi
  0020f	c3		 ret	 0
s370_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstoreb
_TEXT	SEGMENT
tv76 = 48
tv86 = 52
main1$ = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s370_vstoreb PROC					; COMDAT

; 529  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l
  00043	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl
$LN4@s370_vstor:

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );

  00054	83 7c 24 58 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00059	73 0a		 jae	 SHORT $LN9@s370_vstor
  0005b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00063	eb 08		 jmp	 SHORT $LN10@s370_vstor
$LN9@s370_vstor:
  00065	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN10@s370_vstor:
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR tv76[rsp], 0
  00072	74 11		 je	 SHORT $LN11@s370_vstor
  00074	83 7c 24 58 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00079	72 0a		 jb	 SHORT $LN11@s370_vstor
  0007b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00083	eb 08		 jmp	 SHORT $LN17@s370_vstor
$LN11@s370_vstor:
  00085	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN17@s370_vstor:
  0008d	83 7c 24 34 00	 cmp	 DWORD PTR tv86[rsp], 0
  00092	74 0a		 je	 SHORT $LN5@s370_vstor
  00094	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN5@s370_vstor:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 b0		 jne	 SHORT $LN4@s370_vstor

; 535  : }

  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
s370_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per1_gra
_TEXT	SEGMENT
regs$ = 48
s370_per1_gra PROC					; COMDAT

; 546  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 547  : #if !defined( FEATURE_PER1 )
; 548  :     UNREFERENCED( regs );
; 549  : #else
; 550  :     OBTAIN_INTLOCK( regs );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@OMLMFJCF@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00015	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 551  :     {
; 552  :         regs->peradr = regs->periaddr;

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00024	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0002b	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@s370_per1_:

; 553  :         ON_IC_PER_GRA( regs );

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0003a	0f ba e8 14	 bts	 eax, 20
  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 e6		 jne	 SHORT $LN4@s370_per1_

; 554  :     }
; 555  :     RELEASE_INTLOCK( regs );

  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@JBMLKNGA@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 556  : 
; 557  :     if (OPEN_IC_PER_GRA( regs ))

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00062	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00067	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0006a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0006d	23 c1		 and	 eax, ecx
  0006f	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00074	85 c0		 test	 eax, eax
  00076	74 18		 je	 SHORT $LN5@s370_per1_

; 558  :         RETURN_INTCHECK( regs );

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00083	ba ff ff ff ff	 mov	 edx, -1
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 longjmp
$LN5@s370_per1_:
$LN6@s370_per1_:

; 559  : #endif
; 560  : }

  00090	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00094	c3		 ret	 0
s370_per1_gra ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b2$ = 76
count$ = 80
sign$ = 84
b1$ = 88
cc$ = 92
tv148 = 96
tv149 = 100
l1$ = 104
l2$ = 108
dec$ = 112
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_zero_and_add PROC

; 1341 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1342 : int     l1, l2;                         /* Length values             */
; 1343 : int     b1, b2;                         /* Base register numbers     */
; 1344 : VADR    effective_addr1,
; 1345 :         effective_addr2;                /* Effective addresses       */
; 1346 : int     cc;                             /* Condition code            */
; 1347 : BYTE    dec[MAX_DECIMAL_DIGITS];        /* Work area for operand     */
; 1348 : int     count;                          /* Significant digit counter */
; 1349 : int     sign;                           /* Sign                      */
; 1350 : 
; 1351 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004f	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 4c	 mov	 DWORD PTR b2$[rsp], eax
  0005d	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00069	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006d	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00071	c1 e8 1c	 shr	 eax, 28
  00074	83 e0 0f	 and	 eax, 15
  00077	89 44 24 58	 mov	 DWORD PTR b1$[rsp], eax
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 6c	 mov	 DWORD PTR l2$[rsp], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	c1 f8 04	 sar	 eax, 4
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 68	 mov	 DWORD PTR l1$[rsp], eax
  000b6	83 7c 24 58 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bb	74 2d		 je	 SHORT $LN5@s370_zero_
  000bd	48 63 44 24 58	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d1	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d5	03 c8		 add	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000dd	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000e1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e6	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_zero_:
  000ea	83 7c 24 4c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ef	74 2d		 je	 SHORT $LN6@s370_zero_
  000f1	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000f6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00105	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00109	03 c8		 add	 ecx, eax
  0010b	8b c1		 mov	 eax, ecx
  0010d	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00111	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00115	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011a	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_zero_:
$LN4@s370_zero_:
  0011e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012a	48 83 c0 06	 add	 rax, 6
  0012e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013a	33 c0		 xor	 eax, eax
  0013c	83 f8 06	 cmp	 eax, 6
  0013f	74 0f		 je	 SHORT $LN7@s370_zero_
  00141	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_zero_:
  00150	33 c0		 xor	 eax, eax
  00152	85 c0		 test	 eax, eax
  00154	75 c8		 jne	 SHORT $LN4@s370_zero_

; 1352 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 1353 :     TXFC_INSTR_CHECK( regs );
; 1354 : 
; 1355 :     /* Load second operand into work area */
; 1356 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec, &count, &sign);

  00156	48 8d 44 24 54	 lea	 rax, QWORD PTR sign$[rsp]
  0015b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00160	48 8d 44 24 50	 lea	 rax, QWORD PTR count$[rsp]
  00165	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016a	48 8d 44 24 70	 lea	 rax, QWORD PTR dec$[rsp]
  0016f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00174	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017c	44 8b 44 24 4c	 mov	 r8d, DWORD PTR b2$[rsp]
  00181	8b 54 24 6c	 mov	 edx, DWORD PTR l2$[rsp]
  00185	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00189	e8 00 00 00 00	 call	 s370_load_decimal

; 1357 : 
; 1358 :     /* Set condition code */
; 1359 :     cc = (count == 0) ? 0 : (sign < 1) ? 1 : 2;

  0018e	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  00193	75 0a		 jne	 SHORT $LN14@s370_zero_
  00195	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
  0019d	eb 21		 jmp	 SHORT $LN15@s370_zero_
$LN14@s370_zero_:
  0019f	83 7c 24 54 01	 cmp	 DWORD PTR sign$[rsp], 1
  001a4	7d 0a		 jge	 SHORT $LN12@s370_zero_
  001a6	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv148[rsp], 1
  001ae	eb 08		 jmp	 SHORT $LN13@s370_zero_
$LN12@s370_zero_:
  001b0	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR tv148[rsp], 2
$LN13@s370_zero_:
  001b8	8b 44 24 60	 mov	 eax, DWORD PTR tv148[rsp]
  001bc	89 44 24 64	 mov	 DWORD PTR tv149[rsp], eax
$LN15@s370_zero_:
  001c0	8b 44 24 64	 mov	 eax, DWORD PTR tv149[rsp]
  001c4	89 44 24 5c	 mov	 DWORD PTR cc$[rsp], eax

; 1360 : 
; 1361 :     /* Overflow if result exceeds first operand length */
; 1362 :     if (count > (l1+1) * 2 - 1)

  001c8	8b 44 24 68	 mov	 eax, DWORD PTR l1$[rsp]
  001cc	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  001d0	39 44 24 50	 cmp	 DWORD PTR count$[rsp], eax
  001d4	7e 08		 jle	 SHORT $LN8@s370_zero_

; 1363 :         cc = 3;

  001d6	c7 44 24 5c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN8@s370_zero_:

; 1364 : 
; 1365 :     /* Set positive sign if result is zero */
; 1366 :     if (count == 0)

  001de	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  001e3	75 08		 jne	 SHORT $LN9@s370_zero_

; 1367 :         sign = +1;

  001e5	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN9@s370_zero_:

; 1368 : 
; 1369 :     /* Store result into first operand location */
; 1370 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec, sign);

  001ed	8b 44 24 54	 mov	 eax, DWORD PTR sign$[rsp]
  001f1	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001f5	48 8d 44 24 70	 lea	 rax, QWORD PTR dec$[rsp]
  001fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ff	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00207	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  0020c	8b 54 24 68	 mov	 edx, DWORD PTR l1$[rsp]
  00210	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00214	e8 00 00 00 00	 call	 s370_store_decimal

; 1371 : 
; 1372 :     /* Return condition code */
; 1373 :     regs->psw.cc = cc;

  00219	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00221	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR cc$[rsp]
  00226	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1374 : 
; 1375 :     /* Program check if overflow and PSW program mask is set */
; 1376 :     if (cc == 3 && DOMASK(&regs->psw))

  00229	83 7c 24 5c 03	 cmp	 DWORD PTR cc$[rsp], 3
  0022e	75 25		 jne	 SHORT $LN10@s370_zero_
  00230	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00238	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  0023c	83 e0 04	 and	 eax, 4
  0023f	85 c0		 test	 eax, eax
  00241	74 12		 je	 SHORT $LN10@s370_zero_

; 1377 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  00243	ba 0a 00 00 00	 mov	 edx, 10
  00248	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00250	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_zero_:

; 1378 : 
; 1379 : } /* end DEF_INST(zero_and_add) */

  00255	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0025d	48 33 cc	 xor	 rcx, rsp
  00260	e8 00 00 00 00	 call	 __security_check_cookie
  00265	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0026c	c3		 ret	 0
s370_zero_and_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sign3$ = 64
count3$ = 68
effective_addr1$ = 72
effective_addr2$ = 76
temp$1 = 80
sign1$ = 84
b1$ = 88
b2$ = 92
l1$ = 96
cc$ = 100
count1$ = 104
count2$ = 108
sign2$ = 112
tv184 = 116
tv185 = 120
l2$ = 124
dec3$ = 128
dec2$ = 160
dec1$ = 192
__$ArrayPad$ = 224
inst$ = 272
regs$ = 280
s370_subtract_decimal PROC

; 1265 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1266 : int     l1, l2;                         /* Length values             */
; 1267 : int     b1, b2;                         /* Base register numbers     */
; 1268 : VADR    effective_addr1,
; 1269 :         effective_addr2;                /* Effective addresses       */
; 1270 : int     cc;                             /* Condition code            */
; 1271 : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 1272 : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 1273 : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 1274 : int     count1, count2, count3;         /* Significant digit counters*/
; 1275 : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 1276 : 
; 1277 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00025	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002d	48 83 c0 02	 add	 rax, 2
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 fetch_fw_noswap
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 _byteswap_ulong
  00040	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00044	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 0c	 shr	 eax, 12
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 5c	 mov	 DWORD PTR b2$[rsp], eax
  0005f	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 10	 shr	 eax, 16
  00066	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006b	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006f	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00073	c1 e8 1c	 shr	 eax, 28
  00076	83 e0 0f	 and	 eax, 15
  00079	89 44 24 58	 mov	 DWORD PTR b1$[rsp], eax
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	48 6b c0 01	 imul	 rax, rax, 1
  00086	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 7c	 mov	 DWORD PTR l2$[rsp], eax
  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 01	 imul	 rax, rax, 1
  000a2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ae	c1 f8 04	 sar	 eax, 4
  000b1	83 e0 0f	 and	 eax, 15
  000b4	89 44 24 60	 mov	 DWORD PTR l1$[rsp], eax
  000b8	83 7c 24 58 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bd	74 2d		 je	 SHORT $LN5@s370_subtr
  000bf	48 63 44 24 58	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d3	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d7	03 c8		 add	 ecx, eax
  000d9	8b c1		 mov	 eax, ecx
  000db	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000df	8b 44 24 48	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000e3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e8	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_subtr:
  000ec	83 7c 24 5c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000f1	74 2d		 je	 SHORT $LN6@s370_subtr
  000f3	48 63 44 24 5c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000f8	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00107	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0010b	03 c8		 add	 ecx, eax
  0010d	8b c1		 mov	 eax, ecx
  0010f	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00113	8b 44 24 4c	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00117	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011c	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_subtr:
$LN4@s370_subtr:
  00120	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00128	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012c	48 83 c0 06	 add	 rax, 6
  00130	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013c	33 c0		 xor	 eax, eax
  0013e	83 f8 06	 cmp	 eax, 6
  00141	74 0f		 je	 SHORT $LN7@s370_subtr
  00143	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_subtr:
  00152	33 c0		 xor	 eax, eax
  00154	85 c0		 test	 eax, eax
  00156	75 c8		 jne	 SHORT $LN4@s370_subtr

; 1278 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 1279 :     TXFC_INSTR_CHECK( regs );
; 1280 : 
; 1281 :     /* Load operands into work areas */
; 1282 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00158	48 8d 44 24 54	 lea	 rax, QWORD PTR sign1$[rsp]
  0015d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00162	48 8d 44 24 68	 lea	 rax, QWORD PTR count1$[rsp]
  00167	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016c	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00174	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00179	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00181	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  00186	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  0018a	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0018e	e8 00 00 00 00	 call	 s370_load_decimal

; 1283 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  00193	48 8d 44 24 70	 lea	 rax, QWORD PTR sign2$[rsp]
  00198	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0019d	48 8d 44 24 6c	 lea	 rax, QWORD PTR count2$[rsp]
  001a2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a7	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  001af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b4	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001bc	44 8b 44 24 5c	 mov	 r8d, DWORD PTR b2$[rsp]
  001c1	8b 54 24 7c	 mov	 edx, DWORD PTR l2$[rsp]
  001c5	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001c9	e8 00 00 00 00	 call	 s370_load_decimal

; 1284 : 
; 1285 :     /* Add or subtract operand values */
; 1286 :     if (count2 == 0)

  001ce	83 7c 24 6c 00	 cmp	 DWORD PTR count2$[rsp], 0
  001d3	75 32		 jne	 SHORT $LN8@s370_subtr

; 1287 :     {
; 1288 :         /* If second operand is zero then result is first operand */
; 1289 :         memcpy (dec3, dec1, MAX_DECIMAL_DIGITS);

  001d5	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  001dd	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  001e5	48 8b f8	 mov	 rdi, rax
  001e8	48 8b f1	 mov	 rsi, rcx
  001eb	b9 1f 00 00 00	 mov	 ecx, 31
  001f0	f3 a4		 rep movsb

; 1290 :         count3 = count1;

  001f2	8b 44 24 68	 mov	 eax, DWORD PTR count1$[rsp]
  001f6	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 1291 :         sign3 = sign1;

  001fa	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  001fe	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1292 :     }

  00202	e9 ab 00 00 00	 jmp	 $LN9@s370_subtr
$LN8@s370_subtr:

; 1293 :     else if (count1 == 0)

  00207	83 7c 24 68 00	 cmp	 DWORD PTR count1$[rsp], 0
  0020c	75 31		 jne	 SHORT $LN10@s370_subtr

; 1294 :     {
; 1295 :         /* If first operand is zero then result is -second operand */
; 1296 :         memcpy (dec3, dec2, MAX_DECIMAL_DIGITS);

  0020e	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00216	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dec2$[rsp]
  0021e	48 8b f8	 mov	 rdi, rax
  00221	48 8b f1	 mov	 rsi, rcx
  00224	b9 1f 00 00 00	 mov	 ecx, 31
  00229	f3 a4		 rep movsb

; 1297 :         count3 = count2;

  0022b	8b 44 24 6c	 mov	 eax, DWORD PTR count2$[rsp]
  0022f	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 1298 :         sign3 = -sign2;

  00233	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  00237	f7 d8		 neg	 eax
  00239	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1299 :     }

  0023d	eb 73		 jmp	 SHORT $LN11@s370_subtr
$LN10@s370_subtr:

; 1300 :     else if (sign1 != sign2)

  0023f	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  00243	39 44 24 54	 cmp	 DWORD PTR sign1$[rsp], eax
  00247	74 2c		 je	 SHORT $LN12@s370_subtr

; 1301 :     {
; 1302 :         /* If signs are opposite then add operands */
; 1303 :         add_decimal (dec1, dec2, dec3, &count3);

  00249	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  0024e	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  00256	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  0025e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00266	e8 00 00 00 00	 call	 add_decimal

; 1304 :         sign3 = sign1;

  0026b	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  0026f	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 1305 :     }

  00273	eb 3d		 jmp	 SHORT $LN13@s370_subtr
$LN12@s370_subtr:

; 1306 :     else
; 1307 :     {
; 1308 :         /* If signs are equal then subtract operands */
; 1309 :         subtract_decimal (dec1, dec2, dec3, &count3, &sign3);

  00275	48 8d 44 24 40	 lea	 rax, QWORD PTR sign3$[rsp]
  0027a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027f	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  00284	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  0028c	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  00294	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  0029c	e8 00 00 00 00	 call	 subtract_decimal

; 1310 :         if (sign1 < 0) sign3 = -sign3;

  002a1	83 7c 24 54 00	 cmp	 DWORD PTR sign1$[rsp], 0
  002a6	7d 0a		 jge	 SHORT $LN14@s370_subtr
  002a8	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  002ac	f7 d8		 neg	 eax
  002ae	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax
$LN14@s370_subtr:
$LN13@s370_subtr:
$LN11@s370_subtr:
$LN9@s370_subtr:

; 1311 :     }
; 1312 : 
; 1313 :     /* Set condition code */
; 1314 :     cc = (count3 == 0) ? 0 : (sign3 < 1) ? 1 : 2;

  002b2	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  002b7	75 0a		 jne	 SHORT $LN21@s370_subtr
  002b9	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
  002c1	eb 21		 jmp	 SHORT $LN22@s370_subtr
$LN21@s370_subtr:
  002c3	83 7c 24 40 01	 cmp	 DWORD PTR sign3$[rsp], 1
  002c8	7d 0a		 jge	 SHORT $LN19@s370_subtr
  002ca	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv184[rsp], 1
  002d2	eb 08		 jmp	 SHORT $LN20@s370_subtr
$LN19@s370_subtr:
  002d4	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv184[rsp], 2
$LN20@s370_subtr:
  002dc	8b 44 24 74	 mov	 eax, DWORD PTR tv184[rsp]
  002e0	89 44 24 78	 mov	 DWORD PTR tv185[rsp], eax
$LN22@s370_subtr:
  002e4	8b 44 24 78	 mov	 eax, DWORD PTR tv185[rsp]
  002e8	89 44 24 64	 mov	 DWORD PTR cc$[rsp], eax

; 1315 : 
; 1316 :     /* Overflow if result exceeds first operand length */
; 1317 :     if (count3 > (l1+1) * 2 - 1)

  002ec	8b 44 24 60	 mov	 eax, DWORD PTR l1$[rsp]
  002f0	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  002f4	39 44 24 44	 cmp	 DWORD PTR count3$[rsp], eax
  002f8	7e 08		 jle	 SHORT $LN15@s370_subtr

; 1318 :         cc = 3;

  002fa	c7 44 24 64 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN15@s370_subtr:

; 1319 : 
; 1320 :     /* Set positive sign if result is zero */
; 1321 :     if (count3 == 0)

  00302	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  00307	75 08		 jne	 SHORT $LN16@s370_subtr

; 1322 :         sign3 = 1;

  00309	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR sign3$[rsp], 1
$LN16@s370_subtr:

; 1323 : 
; 1324 :     /* Store result into first operand location */
; 1325 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  00311	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  00315	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00319	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00321	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00326	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0032e	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  00333	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  00337	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0033b	e8 00 00 00 00	 call	 s370_store_decimal

; 1326 : 
; 1327 :     /* Return condition code */
; 1328 :     regs->psw.cc = cc;

  00340	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00348	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR cc$[rsp]
  0034d	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1329 : 
; 1330 :     /* Program check if overflow and PSW program mask is set */
; 1331 :     if (cc == 3 && DOMASK(&regs->psw))

  00350	83 7c 24 64 03	 cmp	 DWORD PTR cc$[rsp], 3
  00355	75 25		 jne	 SHORT $LN17@s370_subtr
  00357	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035f	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00363	83 e0 04	 and	 eax, 4
  00366	85 c0		 test	 eax, eax
  00368	74 12		 je	 SHORT $LN17@s370_subtr

; 1332 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  0036a	ba 0a 00 00 00	 mov	 edx, 10
  0036f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00377	e8 00 00 00 00	 call	 s370_program_interrupt
$LN17@s370_subtr:

; 1333 : 
; 1334 : } /* end DEF_INST(subtract_decimal) */

  0037c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00384	48 33 cc	 xor	 rcx, rsp
  00387	e8 00 00 00 00	 call	 __security_check_cookie
  0038c	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00393	5f		 pop	 rdi
  00394	5e		 pop	 rsi
  00395	c3		 ret	 0
s370_subtract_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
effective_addr2$ = 64
i$ = 68
j$ = 72
d$ = 76
count$ = 80
effective_addr1$ = 84
cc$ = 88
temp$1 = 92
sign$ = 96
b1$ = 100
l1$ = 104
b2$ = 108
tv154 = 112
tv155 = 116
tv173 = 120
i3$ = 124
tv184 = 128
tv194 = 132
carry$ = 136
tv205 = 140
tv206 = 144
dec$ = 152
__$ArrayPad$ = 184
inst$ = 208
regs$ = 216
s370_shift_and_round_decimal PROC

; 1168 : {

$LN36:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1169 : int     l1, i3;                         /* Length and rounding       */
; 1170 : int     b1, b2;                         /* Base register numbers     */
; 1171 : VADR    effective_addr1,
; 1172 :         effective_addr2;                /* Effective addresses       */
; 1173 : int     cc;                             /* Condition code            */
; 1174 : BYTE    dec[MAX_DECIMAL_DIGITS];        /* Work area for operand     */
; 1175 : int     count;                          /* Significant digit counter */
; 1176 : int     sign;                           /* Sign of operand/result    */
; 1177 : int     i, j;                           /* Array subscripts          */
; 1178 : int     d;                              /* Decimal digit             */
; 1179 : int     carry;                          /* Carry indicator           */
; 1180 : 
; 1181 :     SS(inst, regs, l1, i3, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 5c	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 5c	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004f	8b 44 24 5c	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 6c	 mov	 DWORD PTR b2$[rsp], eax
  0005d	8b 44 24 5c	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00069	89 44 24 54	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006d	8b 44 24 5c	 mov	 eax, DWORD PTR temp$1[rsp]
  00071	c1 e8 1c	 shr	 eax, 28
  00074	83 e0 0f	 and	 eax, 15
  00077	89 44 24 64	 mov	 DWORD PTR b1$[rsp], eax
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 7c	 mov	 DWORD PTR i3$[rsp], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	c1 f8 04	 sar	 eax, 4
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 68	 mov	 DWORD PTR l1$[rsp], eax
  000b6	83 7c 24 64 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bb	74 2d		 je	 SHORT $LN11@s370_shift
  000bd	48 63 44 24 64	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d1	8b 4c 24 54	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d5	03 c8		 add	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 54	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000dd	8b 44 24 54	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000e1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e6	89 44 24 54	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN11@s370_shift:
  000ea	83 7c 24 6c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ef	74 2d		 je	 SHORT $LN12@s370_shift
  000f1	48 63 44 24 6c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000f6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00105	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00109	03 c8		 add	 ecx, eax
  0010b	8b c1		 mov	 eax, ecx
  0010d	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00111	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00115	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011a	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN12@s370_shift:
$LN4@s370_shift:
  0011e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012a	48 83 c0 06	 add	 rax, 6
  0012e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013a	33 c0		 xor	 eax, eax
  0013c	83 f8 06	 cmp	 eax, 6
  0013f	74 0f		 je	 SHORT $LN13@s370_shift
  00141	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@s370_shift:
  00150	33 c0		 xor	 eax, eax
  00152	85 c0		 test	 eax, eax
  00154	75 c8		 jne	 SHORT $LN4@s370_shift

; 1182 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1183 :     TXFC_INSTR_CHECK( regs );
; 1184 : 
; 1185 :     /* Load operand into work area */
; 1186 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec, &count, &sign);

  00156	48 8d 44 24 60	 lea	 rax, QWORD PTR sign$[rsp]
  0015b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00160	48 8d 44 24 50	 lea	 rax, QWORD PTR count$[rsp]
  00165	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016a	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dec$[rsp]
  00172	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00177	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017f	44 8b 44 24 64	 mov	 r8d, DWORD PTR b1$[rsp]
  00184	8b 54 24 68	 mov	 edx, DWORD PTR l1$[rsp]
  00188	8b 4c 24 54	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0018c	e8 00 00 00 00	 call	 s370_load_decimal

; 1187 : 
; 1188 :     /* Program check if rounding digit is invalid */
; 1189 :     if (i3 > 9)

  00191	83 7c 24 7c 09	 cmp	 DWORD PTR i3$[rsp], 9
  00196	7e 24		 jle	 SHORT $LN14@s370_shift

; 1190 :     {
; 1191 :         regs->dxc = DXC_DECIMAL;

  00198	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a0	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1192 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  001aa	ba 07 00 00 00	 mov	 edx, 7
  001af	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_shift:

; 1193 :     }
; 1194 : 
; 1195 :     /* Isolate low-order six bits of shift count */
; 1196 :     effective_addr2 &= 0x3F;

  001bc	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001c0	83 e0 3f	 and	 eax, 63			; 0000003fH
  001c3	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax

; 1197 : 
; 1198 :     /* Shift count 0-31 means shift left, 32-63 means shift right */
; 1199 :     if (effective_addr2 < 32)

  001c7	83 7c 24 40 20	 cmp	 DWORD PTR effective_addr2$[rsp], 32 ; 00000020H
  001cc	0f 83 c2 00 00
	00		 jae	 $LN15@s370_shift

; 1200 :     {
; 1201 :         /* Set condition code according to operand sign */
; 1202 :         cc = (count == 0) ? 0 : (sign < 0) ? 1 : 2;

  001d2	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  001d7	75 0a		 jne	 SHORT $LN24@s370_shift
  001d9	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
  001e1	eb 21		 jmp	 SHORT $LN25@s370_shift
$LN24@s370_shift:
  001e3	83 7c 24 60 00	 cmp	 DWORD PTR sign$[rsp], 0
  001e8	7d 0a		 jge	 SHORT $LN22@s370_shift
  001ea	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001f2	eb 08		 jmp	 SHORT $LN23@s370_shift
$LN22@s370_shift:
  001f4	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv154[rsp], 2
$LN23@s370_shift:
  001fc	8b 44 24 70	 mov	 eax, DWORD PTR tv154[rsp]
  00200	89 44 24 74	 mov	 DWORD PTR tv155[rsp], eax
$LN25@s370_shift:
  00204	8b 44 24 74	 mov	 eax, DWORD PTR tv155[rsp]
  00208	89 44 24 58	 mov	 DWORD PTR cc$[rsp], eax

; 1203 : 
; 1204 :         /* Set cc=3 if non-zero digits will be lost on left shift */
; 1205 :         if (count > 0 && effective_addr2 > (VADR)((l1+1)*2 - 1 - count))

  0020c	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  00211	7e 1a		 jle	 SHORT $LN17@s370_shift
  00213	8b 44 24 68	 mov	 eax, DWORD PTR l1$[rsp]
  00217	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0021b	2b 44 24 50	 sub	 eax, DWORD PTR count$[rsp]
  0021f	39 44 24 40	 cmp	 DWORD PTR effective_addr2$[rsp], eax
  00223	76 08		 jbe	 SHORT $LN17@s370_shift

; 1206 :             cc = 3;

  00225	c7 44 24 58 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN17@s370_shift:

; 1207 : 
; 1208 :         /* Shift operand left */
; 1209 :         for (i=0, j=effective_addr2; i < MAX_DECIMAL_DIGITS; i++, j++)

  0022d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00235	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00239	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
  0023d	eb 14		 jmp	 SHORT $LN7@s370_shift
$LN5@s370_shift:
  0023f	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00243	ff c0		 inc	 eax
  00245	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
  00249	8b 44 24 48	 mov	 eax, DWORD PTR j$[rsp]
  0024d	ff c0		 inc	 eax
  0024f	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
$LN7@s370_shift:
  00253	83 7c 24 44 1f	 cmp	 DWORD PTR i$[rsp], 31
  00258	7d 35		 jge	 SHORT $LN6@s370_shift

; 1210 :             dec[i] = (j < MAX_DECIMAL_DIGITS) ? dec[j] : 0;

  0025a	83 7c 24 48 1f	 cmp	 DWORD PTR j$[rsp], 31
  0025f	7d 13		 jge	 SHORT $LN26@s370_shift
  00261	48 63 44 24 48	 movsxd	 rax, DWORD PTR j$[rsp]
  00266	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  0026e	89 44 24 78	 mov	 DWORD PTR tv173[rsp], eax
  00272	eb 08		 jmp	 SHORT $LN27@s370_shift
$LN26@s370_shift:
  00274	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN27@s370_shift:
  0027c	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00281	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR tv173[rsp]
  00286	88 8c 04 98 00
	00 00		 mov	 BYTE PTR dec$[rsp+rax], cl
  0028d	eb b0		 jmp	 SHORT $LN5@s370_shift
$LN6@s370_shift:

; 1211 :     }

  0028f	e9 74 01 00 00	 jmp	 $LN16@s370_shift
$LN15@s370_shift:

; 1212 :     else
; 1213 :     {
; 1214 :         /* Calculate number of digits (1-32) to shift right */
; 1215 :         effective_addr2 = 64 - effective_addr2;

  00294	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00299	2b 44 24 40	 sub	 eax, DWORD PTR effective_addr2$[rsp]
  0029d	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax

; 1216 : 
; 1217 :         /* Add the rounding digit to the leftmost of the digits
; 1218 :            to be shifted out and propagate the carry to the left */
; 1219 :         carry = (effective_addr2 > MAX_DECIMAL_DIGITS) ? 0 :

  002a1	83 7c 24 40 1f	 cmp	 DWORD PTR effective_addr2$[rsp], 31
  002a6	76 0d		 jbe	 SHORT $LN28@s370_shift
  002a8	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv184[rsp], 0
  002b3	eb 26		 jmp	 SHORT $LN29@s370_shift
$LN28@s370_shift:
  002b5	b8 1f 00 00 00	 mov	 eax, 31
  002ba	2b 44 24 40	 sub	 eax, DWORD PTR effective_addr2$[rsp]
  002be	8b c0		 mov	 eax, eax
  002c0	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  002c8	03 44 24 7c	 add	 eax, DWORD PTR i3$[rsp]
  002cc	99		 cdq
  002cd	b9 0a 00 00 00	 mov	 ecx, 10
  002d2	f7 f9		 idiv	 ecx
  002d4	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
$LN29@s370_shift:
  002db	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv184[rsp]
  002e2	89 84 24 88 00
	00 00		 mov	 DWORD PTR carry$[rsp], eax

; 1220 :                 (dec[MAX_DECIMAL_DIGITS - effective_addr2] + i3) / 10;
; 1221 :         count = 0;

  002e9	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0

; 1222 : 
; 1223 :         /* Shift operand right */
; 1224 :         for (i=MAX_DECIMAL_DIGITS-1, j=MAX_DECIMAL_DIGITS-1-effective_addr2;

  002f1	c7 44 24 44 1e
	00 00 00	 mov	 DWORD PTR i$[rsp], 30
  002f9	b8 1e 00 00 00	 mov	 eax, 30
  002fe	2b 44 24 40	 sub	 eax, DWORD PTR effective_addr2$[rsp]
  00302	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
  00306	eb 14		 jmp	 SHORT $LN10@s370_shift
$LN8@s370_shift:

; 1225 :                 i >= 0; i--, j--)

  00308	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  0030c	ff c8		 dec	 eax
  0030e	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
  00312	8b 44 24 48	 mov	 eax, DWORD PTR j$[rsp]
  00316	ff c8		 dec	 eax
  00318	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
$LN10@s370_shift:
  0031c	83 7c 24 44 00	 cmp	 DWORD PTR i$[rsp], 0
  00321	0f 8c 95 00 00
	00		 jl	 $LN9@s370_shift

; 1226 :         {
; 1227 :             d = (j >= 0) ? dec[j] : 0;

  00327	83 7c 24 48 00	 cmp	 DWORD PTR j$[rsp], 0
  0032c	7c 16		 jl	 SHORT $LN30@s370_shift
  0032e	48 63 44 24 48	 movsxd	 rax, DWORD PTR j$[rsp]
  00333	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR dec$[rsp+rax]
  0033b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  00342	eb 0b		 jmp	 SHORT $LN31@s370_shift
$LN30@s370_shift:
  00344	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv194[rsp], 0
$LN31@s370_shift:
  0034f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv194[rsp]
  00356	89 44 24 4c	 mov	 DWORD PTR d$[rsp], eax

; 1228 :             d += carry;

  0035a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR carry$[rsp]
  00361	8b 4c 24 4c	 mov	 ecx, DWORD PTR d$[rsp]
  00365	03 c8		 add	 ecx, eax
  00367	8b c1		 mov	 eax, ecx
  00369	89 44 24 4c	 mov	 DWORD PTR d$[rsp], eax

; 1229 :             carry = d / 10;

  0036d	8b 44 24 4c	 mov	 eax, DWORD PTR d$[rsp]
  00371	99		 cdq
  00372	b9 0a 00 00 00	 mov	 ecx, 10
  00377	f7 f9		 idiv	 ecx
  00379	89 84 24 88 00
	00 00		 mov	 DWORD PTR carry$[rsp], eax

; 1230 :             d %= 10;

  00380	8b 44 24 4c	 mov	 eax, DWORD PTR d$[rsp]
  00384	99		 cdq
  00385	b9 0a 00 00 00	 mov	 ecx, 10
  0038a	f7 f9		 idiv	 ecx
  0038c	8b c2		 mov	 eax, edx
  0038e	89 44 24 4c	 mov	 DWORD PTR d$[rsp], eax

; 1231 :             dec[i] = d;

  00392	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00397	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR d$[rsp]
  0039c	88 8c 04 98 00
	00 00		 mov	 BYTE PTR dec$[rsp+rax], cl

; 1232 :             if (d != 0)

  003a3	83 7c 24 4c 00	 cmp	 DWORD PTR d$[rsp], 0
  003a8	74 0d		 je	 SHORT $LN18@s370_shift

; 1233 :                 count = MAX_DECIMAL_DIGITS - i;

  003aa	b8 1f 00 00 00	 mov	 eax, 31
  003af	2b 44 24 44	 sub	 eax, DWORD PTR i$[rsp]
  003b3	89 44 24 50	 mov	 DWORD PTR count$[rsp], eax
$LN18@s370_shift:

; 1234 :         }

  003b7	e9 4c ff ff ff	 jmp	 $LN8@s370_shift
$LN9@s370_shift:

; 1235 : 
; 1236 :         /* Set condition code according to operand sign */
; 1237 :         cc = (count == 0) ? 0 : (sign < 0) ? 1 : 2;

  003bc	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  003c1	75 0d		 jne	 SHORT $LN34@s370_shift
  003c3	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv206[rsp], 0
  003ce	eb 2d		 jmp	 SHORT $LN35@s370_shift
$LN34@s370_shift:
  003d0	83 7c 24 60 00	 cmp	 DWORD PTR sign$[rsp], 0
  003d5	7d 0d		 jge	 SHORT $LN32@s370_shift
  003d7	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv205[rsp], 1
  003e2	eb 0b		 jmp	 SHORT $LN33@s370_shift
$LN32@s370_shift:
  003e4	c7 84 24 8c 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv205[rsp], 2
$LN33@s370_shift:
  003ef	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv205[rsp]
  003f6	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv206[rsp], eax
$LN35@s370_shift:
  003fd	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv206[rsp]
  00404	89 44 24 58	 mov	 DWORD PTR cc$[rsp], eax
$LN16@s370_shift:

; 1238 :     }
; 1239 : 
; 1240 :     /* Make sign positive if result is zero */
; 1241 :     if (cc == 0)

  00408	83 7c 24 58 00	 cmp	 DWORD PTR cc$[rsp], 0
  0040d	75 08		 jne	 SHORT $LN19@s370_shift

; 1242 :         sign = +1;

  0040f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN19@s370_shift:

; 1243 : 
; 1244 :     /* Store result into operand location */
; 1245 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec, sign);

  00417	8b 44 24 60	 mov	 eax, DWORD PTR sign$[rsp]
  0041b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0041f	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dec$[rsp]
  00427	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0042c	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00434	44 8b 44 24 64	 mov	 r8d, DWORD PTR b1$[rsp]
  00439	8b 54 24 68	 mov	 edx, DWORD PTR l1$[rsp]
  0043d	8b 4c 24 54	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00441	e8 00 00 00 00	 call	 s370_store_decimal

; 1246 : 
; 1247 :     /* Set condition code */
; 1248 :     regs->psw.cc = cc;

  00446	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044e	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR cc$[rsp]
  00453	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1249 : 
; 1250 :     /* Program check if overflow and PSW program mask is set */
; 1251 :     if (cc == 3 && DOMASK(&regs->psw))

  00456	83 7c 24 58 03	 cmp	 DWORD PTR cc$[rsp], 3
  0045b	75 25		 jne	 SHORT $LN20@s370_shift
  0045d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00465	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00469	83 e0 04	 and	 eax, 4
  0046c	85 c0		 test	 eax, eax
  0046e	74 12		 je	 SHORT $LN20@s370_shift

; 1252 :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  00470	ba 0a 00 00 00	 mov	 edx, 10
  00475	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047d	e8 00 00 00 00	 call	 s370_program_interrupt
$LN20@s370_shift:

; 1253 : 
; 1254 : } /* end DEF_INST(shift_and_round_decimal) */

  00482	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0048a	48 33 cc	 xor	 rcx, rsp
  0048d	e8 00 00 00 00	 call	 __security_check_cookie
  00492	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00499	c3		 ret	 0
s370_shift_and_round_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i2$ = 64
effective_addr1$ = 68
effective_addr2$ = 72
i3$ = 76
temp$1 = 80
l2$ = 84
b1$ = 88
l1$ = 92
b2$ = 96
i1$ = 100
d$ = 104
carry$ = 108
tv200 = 112
count1$ = 116
sign2$ = 120
sign1$ = 124
sign3$ = 128
count2$ = 132
dec3$ = 136
dec2$ = 168
dec1$ = 200
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
s370_multiply_decimal PROC

; 1096 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1097 : int     l1, l2;                         /* Length values             */
; 1098 : int     b1, b2;                         /* Base register numbers     */
; 1099 : VADR    effective_addr1,
; 1100 :         effective_addr2;                /* Effective addresses       */
; 1101 : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 1102 : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 1103 : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 1104 : int     count1, count2;                 /* Significant digit counters*/
; 1105 : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 1106 : int     d;                              /* Decimal digit             */
; 1107 : int     i1, i2, i3;                     /* Array subscripts          */
; 1108 : int     carry;                          /* Carry indicator           */
; 1109 : 
; 1110 :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00024	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002c	48 83 c0 02	 add	 rax, 2
  00030	48 8b c8	 mov	 rcx, rax
  00033	e8 00 00 00 00	 call	 fetch_fw_noswap
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 _byteswap_ulong
  0003f	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00043	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00050	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 0c	 shr	 eax, 12
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 60	 mov	 DWORD PTR b2$[rsp], eax
  0005e	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 10	 shr	 eax, 16
  00065	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006a	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006e	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00072	c1 e8 1c	 shr	 eax, 28
  00075	83 e0 0f	 and	 eax, 15
  00078	89 44 24 58	 mov	 DWORD PTR b1$[rsp], eax
  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	48 6b c0 01	 imul	 rax, rax, 1
  00085	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00091	83 e0 0f	 and	 eax, 15
  00094	89 44 24 54	 mov	 DWORD PTR l2$[rsp], eax
  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	48 6b c0 01	 imul	 rax, rax, 1
  000a1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ad	c1 f8 04	 sar	 eax, 4
  000b0	83 e0 0f	 and	 eax, 15
  000b3	89 44 24 5c	 mov	 DWORD PTR l1$[rsp], eax
  000b7	83 7c 24 58 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bc	74 2d		 je	 SHORT $LN11@s370_multi
  000be	48 63 44 24 58	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d2	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d6	03 c8		 add	 ecx, eax
  000d8	8b c1		 mov	 eax, ecx
  000da	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000de	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000e2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e7	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN11@s370_multi:
  000eb	83 7c 24 60 00	 cmp	 DWORD PTR b2$[rsp], 0
  000f0	74 2d		 je	 SHORT $LN12@s370_multi
  000f2	48 63 44 24 60	 movsxd	 rax, DWORD PTR b2$[rsp]
  000f7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00106	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0010a	03 c8		 add	 ecx, eax
  0010c	8b c1		 mov	 eax, ecx
  0010e	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00112	8b 44 24 48	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00116	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011b	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN12@s370_multi:
$LN4@s370_multi:
  0011f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012b	48 83 c0 06	 add	 rax, 6
  0012f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00137	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013b	33 c0		 xor	 eax, eax
  0013d	83 f8 06	 cmp	 eax, 6
  00140	74 0f		 je	 SHORT $LN13@s370_multi
  00142	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@s370_multi:
  00151	33 c0		 xor	 eax, eax
  00153	85 c0		 test	 eax, eax
  00155	75 c8		 jne	 SHORT $LN4@s370_multi

; 1111 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 1112 :     TXFC_INSTR_CHECK( regs );
; 1113 : 
; 1114 :     /* Program check if the second operand length exceeds 15 digits
; 1115 :        or is equal to or greater than the first operand length */
; 1116 :     if (l2 > 7 || l2 >= l1)

  00157	83 7c 24 54 07	 cmp	 DWORD PTR l2$[rsp], 7
  0015c	7f 0a		 jg	 SHORT $LN15@s370_multi
  0015e	8b 44 24 5c	 mov	 eax, DWORD PTR l1$[rsp]
  00162	39 44 24 54	 cmp	 DWORD PTR l2$[rsp], eax
  00166	7c 12		 jl	 SHORT $LN14@s370_multi
$LN15@s370_multi:

; 1117 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00168	ba 06 00 00 00	 mov	 edx, 6
  0016d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_multi:

; 1118 : 
; 1119 :     /* Load operands into work areas */
; 1120 :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  0017a	48 8d 44 24 7c	 lea	 rax, QWORD PTR sign1$[rsp]
  0017f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00184	48 8d 44 24 74	 lea	 rax, QWORD PTR count1$[rsp]
  00189	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018e	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00196	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019b	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  001a8	8b 54 24 5c	 mov	 edx, DWORD PTR l1$[rsp]
  001ac	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001b0	e8 00 00 00 00	 call	 s370_load_decimal

; 1121 :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  001b5	48 8d 44 24 78	 lea	 rax, QWORD PTR sign2$[rsp]
  001ba	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001bf	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR count2$[rsp]
  001c7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001cc	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  001d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d9	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e1	44 8b 44 24 60	 mov	 r8d, DWORD PTR b2$[rsp]
  001e6	8b 54 24 54	 mov	 edx, DWORD PTR l2$[rsp]
  001ea	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001ee	e8 00 00 00 00	 call	 s370_load_decimal

; 1122 : 
; 1123 :     /* Program check if the number of bytes in the second operand
; 1124 :        is less than the number of bytes of high-order zeroes in the
; 1125 :        first operand; this ensures that overflow cannot occur */
; 1126 :     if (l2 > l1 - (count1/2 + 1))

  001f3	8b 44 24 74	 mov	 eax, DWORD PTR count1$[rsp]
  001f7	99		 cdq
  001f8	2b c2		 sub	 eax, edx
  001fa	d1 f8		 sar	 eax, 1
  001fc	ff c0		 inc	 eax
  001fe	8b 4c 24 5c	 mov	 ecx, DWORD PTR l1$[rsp]
  00202	2b c8		 sub	 ecx, eax
  00204	8b c1		 mov	 eax, ecx
  00206	39 44 24 54	 cmp	 DWORD PTR l2$[rsp], eax
  0020a	7e 24		 jle	 SHORT $LN16@s370_multi

; 1127 :     {
; 1128 :         regs->dxc = DXC_DECIMAL;

  0020c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00214	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1129 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0021e	ba 07 00 00 00	 mov	 edx, 7
  00223	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022b	e8 00 00 00 00	 call	 s370_program_interrupt
$LN16@s370_multi:

; 1130 :     }
; 1131 : 
; 1132 :     /* Clear the result field */
; 1133 :     memset( dec3, 0, MAX_DECIMAL_DIGITS );

  00230	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00238	48 8b f8	 mov	 rdi, rax
  0023b	33 c0		 xor	 eax, eax
  0023d	b9 1f 00 00 00	 mov	 ecx, 31
  00242	f3 aa		 rep stosb

; 1134 : 
; 1135 :     /* Perform decimal multiplication */
; 1136 :     for (i2 = MAX_DECIMAL_DIGITS-1; i2 >= 0; i2--)

  00244	c7 44 24 40 1e
	00 00 00	 mov	 DWORD PTR i2$[rsp], 30
  0024c	eb 0a		 jmp	 SHORT $LN7@s370_multi
$LN5@s370_multi:
  0024e	8b 44 24 40	 mov	 eax, DWORD PTR i2$[rsp]
  00252	ff c8		 dec	 eax
  00254	89 44 24 40	 mov	 DWORD PTR i2$[rsp], eax
$LN7@s370_multi:
  00258	83 7c 24 40 00	 cmp	 DWORD PTR i2$[rsp], 0
  0025d	0f 8c b3 00 00
	00		 jl	 $LN6@s370_multi

; 1137 :     {
; 1138 :         if (dec2[i2] != 0)

  00263	48 63 44 24 40	 movsxd	 rax, DWORD PTR i2$[rsp]
  00268	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR dec2$[rsp+rax]
  00270	85 c0		 test	 eax, eax
  00272	0f 84 99 00 00
	00		 je	 $LN17@s370_multi

; 1139 :         {
; 1140 :             for (i1 = MAX_DECIMAL_DIGITS - 1, i3 = i2, carry = 0;

  00278	c7 44 24 64 1e
	00 00 00	 mov	 DWORD PTR i1$[rsp], 30
  00280	8b 44 24 40	 mov	 eax, DWORD PTR i2$[rsp]
  00284	89 44 24 4c	 mov	 DWORD PTR i3$[rsp], eax
  00288	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0
  00290	eb 14		 jmp	 SHORT $LN10@s370_multi
$LN8@s370_multi:

; 1141 :                         i3 >= 0; i1--, i3--)

  00292	8b 44 24 64	 mov	 eax, DWORD PTR i1$[rsp]
  00296	ff c8		 dec	 eax
  00298	89 44 24 64	 mov	 DWORD PTR i1$[rsp], eax
  0029c	8b 44 24 4c	 mov	 eax, DWORD PTR i3$[rsp]
  002a0	ff c8		 dec	 eax
  002a2	89 44 24 4c	 mov	 DWORD PTR i3$[rsp], eax
$LN10@s370_multi:
  002a6	83 7c 24 4c 00	 cmp	 DWORD PTR i3$[rsp], 0
  002ab	7c 64		 jl	 SHORT $LN9@s370_multi

; 1142 :             {
; 1143 :                 d = carry + dec1[i1]*dec2[i2] + dec3[i3];

  002ad	48 63 44 24 64	 movsxd	 rax, DWORD PTR i1$[rsp]
  002b2	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR dec1$[rsp+rax]
  002ba	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i2$[rsp]
  002bf	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR dec2$[rsp+rcx]
  002c7	0f af c1	 imul	 eax, ecx
  002ca	8b 4c 24 6c	 mov	 ecx, DWORD PTR carry$[rsp]
  002ce	03 c8		 add	 ecx, eax
  002d0	8b c1		 mov	 eax, ecx
  002d2	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR i3$[rsp]
  002d7	0f b6 8c 0c 88
	00 00 00	 movzx	 ecx, BYTE PTR dec3$[rsp+rcx]
  002df	03 c1		 add	 eax, ecx
  002e1	89 44 24 68	 mov	 DWORD PTR d$[rsp], eax

; 1144 :                 dec3[i3] = d % 10;

  002e5	8b 44 24 68	 mov	 eax, DWORD PTR d$[rsp]
  002e9	99		 cdq
  002ea	b9 0a 00 00 00	 mov	 ecx, 10
  002ef	f7 f9		 idiv	 ecx
  002f1	8b c2		 mov	 eax, edx
  002f3	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR i3$[rsp]
  002f8	88 84 0c 88 00
	00 00		 mov	 BYTE PTR dec3$[rsp+rcx], al

; 1145 :                 carry = d / 10;

  002ff	8b 44 24 68	 mov	 eax, DWORD PTR d$[rsp]
  00303	99		 cdq
  00304	b9 0a 00 00 00	 mov	 ecx, 10
  00309	f7 f9		 idiv	 ecx
  0030b	89 44 24 6c	 mov	 DWORD PTR carry$[rsp], eax

; 1146 :             }

  0030f	eb 81		 jmp	 SHORT $LN8@s370_multi
$LN9@s370_multi:
$LN17@s370_multi:

; 1147 :         }
; 1148 :     } /* end for(i2) */

  00311	e9 38 ff ff ff	 jmp	 $LN5@s370_multi
$LN6@s370_multi:

; 1149 : 
; 1150 :     /* Result is positive if operand signs are equal, and negative
; 1151 :        if operand signs are opposite, even if result is zero */
; 1152 :     sign3 = (sign1 == sign2) ? 1 : -1;

  00316	8b 44 24 78	 mov	 eax, DWORD PTR sign2$[rsp]
  0031a	39 44 24 7c	 cmp	 DWORD PTR sign1$[rsp], eax
  0031e	75 0a		 jne	 SHORT $LN19@s370_multi
  00320	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  00328	eb 08		 jmp	 SHORT $LN20@s370_multi
$LN19@s370_multi:
  0032a	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR tv200[rsp], -1
$LN20@s370_multi:
  00332	8b 44 24 70	 mov	 eax, DWORD PTR tv200[rsp]
  00336	89 84 24 80 00
	00 00		 mov	 DWORD PTR sign3$[rsp], eax

; 1153 : 
; 1154 :     /* Store result into first operand location */
; 1155 :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  0033d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR sign3$[rsp]
  00344	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00348	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00350	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00355	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0035d	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  00362	8b 54 24 5c	 mov	 edx, DWORD PTR l1$[rsp]
  00366	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0036a	e8 00 00 00 00	 call	 s370_store_decimal

; 1156 : 
; 1157 : } /* end DEF_INST(multiply_decimal) */

  0036f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00377	48 33 cc	 xor	 rcx, rsp
  0037a	e8 00 00 00 00	 call	 __security_check_cookie
  0037f	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  00386	5f		 pop	 rdi
  00387	c3		 ret	 0
s370_multiply_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sbyte$ = 48
pbyte$ = 49
fbyte$ = 50
addr1$ = 52
b1$ = 56
trial_run$ = 60
effective_addr1$ = 64
sig$ = 68
rbyte$ = 72
effective_addr2$ = 76
h$ = 80
cc$ = 84
addr2$ = 88
d$ = 92
temp$1 = 96
l$ = 100
i$ = 104
b2$ = 108
tv207 = 112
tv283 = 116
inst$ = 144
regs$ = 152
s370_edit_x_edit_and_mark PROC

; 903  : {

$LN57:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 904  : int     l;                              /* Length value              */
; 905  : int     b1, b2;                         /* Base register numbers     */
; 906  : VADR    effective_addr1,
; 907  :         effective_addr2,                /* Effective addresses       */
; 908  :         addr1,
; 909  :         addr2;
; 910  : int     cc = 0;                         /* Condition code            */

  00011	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 911  : int     sig = 0;                        /* Significance indicator    */

  00019	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 912  : int     trial_run;                      /* 1=trial run               */
; 913  : int     i;                              /* Loop counter              */
; 914  : int     d;                              /* 1=Use right source digit  */
; 915  : int     h;                              /* Hexadecimal digit         */
; 916  : BYTE    sbyte;                          /* Source operand byte       */
; 917  : BYTE    fbyte;                          /* Fill byte                 */
; 918  : BYTE    pbyte;                          /* Pattern byte              */
; 919  : BYTE    rbyte;                          /* Result byte               */
; 920  : 
; 921  :     SS_L(inst, regs, l, b1, effective_addr1, b2, effective_addr2);

  00021	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00029	48 83 c0 02	 add	 rax, 2
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 fetch_fw_noswap
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 _byteswap_ulong
  0003c	89 44 24 60	 mov	 DWORD PTR temp$1[rsp], eax
  00040	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00049	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004d	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 0c	 shr	 eax, 12
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 6c	 mov	 DWORD PTR b2$[rsp], eax
  0005b	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 10	 shr	 eax, 16
  00062	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00067	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006b	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  0006f	c1 e8 1c	 shr	 eax, 28
  00072	83 e0 0f	 and	 eax, 15
  00075	89 44 24 38	 mov	 DWORD PTR b1$[rsp], eax
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 01	 imul	 rax, rax, 1
  00082	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008e	89 44 24 64	 mov	 DWORD PTR l$[rsp], eax
  00092	83 7c 24 38 00	 cmp	 DWORD PTR b1$[rsp], 0
  00097	74 2d		 je	 SHORT $LN14@s370_edit_
  00099	48 63 44 24 38	 movsxd	 rax, DWORD PTR b1$[rsp]
  0009e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ad	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000b1	03 c8		 add	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000b9	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000bd	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c2	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN14@s370_edit_:
  000c6	83 7c 24 6c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000cb	74 2d		 je	 SHORT $LN15@s370_edit_
  000cd	48 63 44 24 6c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000d2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000da	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000e1	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000e5	03 c8		 add	 ecx, eax
  000e7	8b c1		 mov	 eax, ecx
  000e9	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000ed	8b 44 24 4c	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000f1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000f6	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN15@s370_edit_:
$LN4@s370_edit_:
  000fa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00106	48 83 c0 06	 add	 rax, 6
  0010a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00116	33 c0		 xor	 eax, eax
  00118	83 f8 06	 cmp	 eax, 6
  0011b	74 0f		 je	 SHORT $LN16@s370_edit_
  0011d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00125	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@s370_edit_:
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 c8		 jne	 SHORT $LN4@s370_edit_

; 922  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 923  :     TXFC_INSTR_CHECK( regs );
; 924  : 
; 925  :     /* If addr1 crosses page, make sure both pages are accessible */
; 926  :     if((effective_addr1 & PAGEFRAME_PAGEMASK) !=

  00132	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00136	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0013b	8b 4c 24 64	 mov	 ecx, DWORD PTR l$[rsp]
  0013f	8b 54 24 40	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00143	03 d1		 add	 edx, ecx
  00145	8b ca		 mov	 ecx, edx
  00147	81 e1 00 f8 ff
	7f		 and	 ecx, 2147481600		; 7ffff800H
  0014d	3b c1		 cmp	 eax, ecx
  0014f	74 25		 je	 SHORT $LN17@s370_edit_

; 927  :         ((effective_addr1 + l) & PAGEFRAME_PAGEMASK))
; 928  :         ARCH_DEP(validate_operand) (effective_addr1, b1, l, ACCTYPE_WRITE_SKP, regs);

  00151	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00164	44 8b 44 24 64	 mov	 r8d, DWORD PTR l$[rsp]
  00169	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  0016d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00171	e8 00 00 00 00	 call	 s370_validate_operand
$LN17@s370_edit_:

; 929  : 
; 930  :     /* If addr2 might cross page, do a trial run to catch possible access rupts */
; 931  :     if((effective_addr2 & PAGEFRAME_PAGEMASK) !=

  00176	8b 44 24 4c	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0017a	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0017f	8b 4c 24 64	 mov	 ecx, DWORD PTR l$[rsp]
  00183	8b 54 24 4c	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00187	03 d1		 add	 edx, ecx
  00189	8b ca		 mov	 ecx, edx
  0018b	81 e1 00 f8 ff
	7f		 and	 ecx, 2147481600		; 7ffff800H
  00191	3b c1		 cmp	 eax, ecx
  00193	74 0a		 je	 SHORT $LN18@s370_edit_

; 932  :         ((effective_addr2 + l) & PAGEFRAME_PAGEMASK))
; 933  :         trial_run = 1;

  00195	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR trial_run$[rsp], 1
  0019d	eb 08		 jmp	 SHORT $LN19@s370_edit_
$LN18@s370_edit_:

; 934  :     else
; 935  :         trial_run = 0;

  0019f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR trial_run$[rsp], 0
$LN19@s370_edit_:

; 936  : 
; 937  :     for(;trial_run >= 0; trial_run--)

  001a7	eb 0a		 jmp	 SHORT $LN7@s370_edit_
$LN5@s370_edit_:
  001a9	8b 44 24 3c	 mov	 eax, DWORD PTR trial_run$[rsp]
  001ad	ff c8		 dec	 eax
  001af	89 44 24 3c	 mov	 DWORD PTR trial_run$[rsp], eax
$LN7@s370_edit_:
  001b3	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  001b8	0f 8c d1 03 00
	00		 jl	 $LN6@s370_edit_

; 938  :     {
; 939  :         /* Initialize variables */
; 940  :         addr1 = effective_addr1;

  001be	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  001c2	89 44 24 34	 mov	 DWORD PTR addr1$[rsp], eax

; 941  :         addr2 = effective_addr2;

  001c6	8b 44 24 4c	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001ca	89 44 24 58	 mov	 DWORD PTR addr2$[rsp], eax

; 942  :         cc = 0;

  001ce	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 943  :         sig = 0;

  001d6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 944  :         sbyte = 0;

  001de	c6 44 24 30 00	 mov	 BYTE PTR sbyte$[rsp], 0

; 945  :         fbyte = 0;

  001e3	c6 44 24 32 00	 mov	 BYTE PTR fbyte$[rsp], 0

; 946  : 
; 947  :         /* Process first operand from left to right */
; 948  :         for (i = 0, d = 0; i < l+1; i++)

  001e8	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001f0	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
  001f8	eb 0a		 jmp	 SHORT $LN10@s370_edit_
$LN8@s370_edit_:
  001fa	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  001fe	ff c0		 inc	 eax
  00200	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_edit_:
  00204	8b 44 24 64	 mov	 eax, DWORD PTR l$[rsp]
  00208	ff c0		 inc	 eax
  0020a	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  0020e	0f 8d 76 03 00
	00		 jge	 $LN9@s370_edit_

; 949  :         {
; 950  :             /* Fetch pattern byte from first operand */
; 951  :             pbyte = ARCH_DEP(vfetchb) ( addr1, b1, regs );

  00214	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0021c	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00220	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  00224	e8 00 00 00 00	 call	 s370_vfetchb
  00229	88 44 24 31	 mov	 BYTE PTR pbyte$[rsp], al

; 952  : 
; 953  :             /* The first pattern byte is also the fill byte */
; 954  :             if (i == 0) fbyte = pbyte;

  0022d	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  00232	75 09		 jne	 SHORT $LN20@s370_edit_
  00234	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00239	88 44 24 32	 mov	 BYTE PTR fbyte$[rsp], al
$LN20@s370_edit_:

; 955  : 
; 956  :             /* If pattern byte is digit selector (X'20') or
; 957  :                significance starter (X'21') then fetch next
; 958  :                hexadecimal digit from the second operand */
; 959  :             if (pbyte == 0x20 || pbyte == 0x21)

  0023d	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00242	83 f8 20	 cmp	 eax, 32			; 00000020H
  00245	74 0e		 je	 SHORT $LN23@s370_edit_
  00247	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  0024c	83 f8 21	 cmp	 eax, 33			; 00000021H
  0024f	0f 85 1c 02 00
	00		 jne	 $LN21@s370_edit_
$LN23@s370_edit_:

; 960  :             {
; 961  :                 if (d == 0)

  00255	83 7c 24 5c 00	 cmp	 DWORD PTR d$[rsp], 0
  0025a	75 7d		 jne	 SHORT $LN24@s370_edit_

; 962  :                 {
; 963  :                     /* Fetch source byte and extract left digit */
; 964  :                     sbyte = ARCH_DEP(vfetchb) ( addr2, b2, regs );

  0025c	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00264	8b 54 24 6c	 mov	 edx, DWORD PTR b2$[rsp]
  00268	8b 4c 24 58	 mov	 ecx, DWORD PTR addr2$[rsp]
  0026c	e8 00 00 00 00	 call	 s370_vfetchb
  00271	88 44 24 30	 mov	 BYTE PTR sbyte$[rsp], al

; 965  :                     h = sbyte >> 4;

  00275	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  0027a	c1 f8 04	 sar	 eax, 4
  0027d	89 44 24 50	 mov	 DWORD PTR h$[rsp], eax

; 966  :                     sbyte &= 0x0F;

  00281	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00286	83 e0 0f	 and	 eax, 15
  00289	88 44 24 30	 mov	 BYTE PTR sbyte$[rsp], al

; 967  :                     d = 1;

  0028d	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR d$[rsp], 1

; 968  : 
; 969  :                     /* Increment second operand address */
; 970  :                     addr2++;

  00295	8b 44 24 58	 mov	 eax, DWORD PTR addr2$[rsp]
  00299	ff c0		 inc	 eax
  0029b	89 44 24 58	 mov	 DWORD PTR addr2$[rsp], eax

; 971  :                     addr2 &= ADDRESS_MAXWRAP(regs);

  0029f	8b 44 24 58	 mov	 eax, DWORD PTR addr2$[rsp]
  002a3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002a8	89 44 24 58	 mov	 DWORD PTR addr2$[rsp], eax

; 972  : 
; 973  :                     /* Program check if left digit is not numeric */
; 974  :                     if (h > 9)

  002ac	83 7c 24 50 09	 cmp	 DWORD PTR h$[rsp], 9
  002b1	7e 24		 jle	 SHORT $LN26@s370_edit_

; 975  :                     {
; 976  :                         regs->dxc = DXC_DECIMAL;

  002b3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bb	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 977  :                         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002c5	ba 07 00 00 00	 mov	 edx, 7
  002ca	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	e8 00 00 00 00	 call	 s370_program_interrupt
$LN26@s370_edit_:

; 978  :                     }
; 979  : 
; 980  :                 }

  002d7	eb 11		 jmp	 SHORT $LN25@s370_edit_
$LN24@s370_edit_:

; 981  :                 else
; 982  :                 {
; 983  :                     /* Use right digit of source byte */
; 984  :                     h = sbyte;

  002d9	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  002de	89 44 24 50	 mov	 DWORD PTR h$[rsp], eax

; 985  :                     d = 0;

  002e2	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
$LN25@s370_edit_:

; 986  :                 }
; 987  : 
; 988  :                 /* For the EDMK instruction only, insert address of
; 989  :                    result byte into general register 1 if the digit
; 990  :                    is non-zero and significance indicator was off */
; 991  :                 if (!trial_run && (inst[0] == 0xDF) && h > 0 && sig == 0)

  002ea	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  002ef	0f 85 a4 00 00
	00		 jne	 $LN27@s370_edit_
  002f5	b8 01 00 00 00	 mov	 eax, 1
  002fa	48 6b c0 00	 imul	 rax, rax, 0
  002fe	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00306	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0030a	3d df 00 00 00	 cmp	 eax, 223		; 000000dfH
  0030f	0f 85 84 00 00
	00		 jne	 $LN27@s370_edit_
  00315	83 7c 24 50 00	 cmp	 DWORD PTR h$[rsp], 0
  0031a	7e 7d		 jle	 SHORT $LN27@s370_edit_
  0031c	83 7c 24 44 00	 cmp	 DWORD PTR sig$[rsp], 0
  00321	75 76		 jne	 SHORT $LN27@s370_edit_

; 992  :                 {
; 993  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 994  :                     if (regs->psw.amode64)
; 995  :                         regs->GR_G(1) = addr1;
; 996  :                     else
; 997  : #endif
; 998  :                     if ( regs->psw.amode )

  00323	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00331	d1 e8		 shr	 eax, 1
  00333	83 e0 01	 and	 eax, 1
  00336	85 c0		 test	 eax, eax
  00338	74 1e		 je	 SHORT $LN28@s370_edit_

; 999  :                         regs->GR_L(1) = addr1;

  0033a	b8 08 00 00 00	 mov	 eax, 8
  0033f	48 6b c0 01	 imul	 rax, rax, 1
  00343	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034b	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  0034f	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
  00356	eb 41		 jmp	 SHORT $LN29@s370_edit_
$LN28@s370_edit_:

; 1000 :                     else
; 1001 :                         regs->GR_LA24(1) = addr1;

  00358	b8 08 00 00 00	 mov	 eax, 8
  0035d	48 6b c0 01	 imul	 rax, rax, 1
  00361	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  00365	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0036b	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00373	8b 84 02 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+640]
  0037a	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0037f	0b c1		 or	 eax, ecx
  00381	b9 08 00 00 00	 mov	 ecx, 8
  00386	48 6b c9 01	 imul	 rcx, rcx, 1
  0038a	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00392	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax
$LN29@s370_edit_:
$LN27@s370_edit_:

; 1002 :                 }
; 1003 : 
; 1004 :                 /* Replace the pattern byte by the fill character
; 1005 :                    or by a zoned decimal digit */
; 1006 :                 rbyte = (sig == 0 && h == 0) ? fbyte : (0xF0 | h);

  00399	83 7c 24 44 00	 cmp	 DWORD PTR sig$[rsp], 0
  0039e	75 12		 jne	 SHORT $LN51@s370_edit_
  003a0	83 7c 24 50 00	 cmp	 DWORD PTR h$[rsp], 0
  003a5	75 0b		 jne	 SHORT $LN51@s370_edit_
  003a7	0f b6 44 24 32	 movzx	 eax, BYTE PTR fbyte$[rsp]
  003ac	89 44 24 70	 mov	 DWORD PTR tv207[rsp], eax
  003b0	eb 0d		 jmp	 SHORT $LN52@s370_edit_
$LN51@s370_edit_:
  003b2	8b 44 24 50	 mov	 eax, DWORD PTR h$[rsp]
  003b6	0d f0 00 00 00	 or	 eax, 240		; 000000f0H
  003bb	89 44 24 70	 mov	 DWORD PTR tv207[rsp], eax
$LN52@s370_edit_:
  003bf	0f b6 44 24 70	 movzx	 eax, BYTE PTR tv207[rsp]
  003c4	88 44 24 48	 mov	 BYTE PTR rbyte$[rsp], al

; 1007 :                 if(!trial_run)

  003c8	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  003cd	75 1d		 jne	 SHORT $LN30@s370_edit_

; 1008 :                     ARCH_DEP(vstoreb) ( rbyte, addr1, b1, regs );

  003cf	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003d7	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  003dc	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  003e0	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR rbyte$[rsp]
  003e5	e8 00 00 00 00	 call	 s370_vstoreb
  003ea	eb 23		 jmp	 SHORT $LN31@s370_edit_
$LN30@s370_edit_:

; 1009 :                 else
; 1010 :                     ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  003ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f9	41 b9 01 00 00
	00		 mov	 r9d, 1
  003ff	45 33 c0	 xor	 r8d, r8d
  00402	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00406	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  0040a	e8 00 00 00 00	 call	 s370_validate_operand
$LN31@s370_edit_:

; 1011 : 
; 1012 :                 /* Set condition code 2 if digit is non-zero */
; 1013 :                 if (h > 0) cc = 2;

  0040f	83 7c 24 50 00	 cmp	 DWORD PTR h$[rsp], 0
  00414	7e 08		 jle	 SHORT $LN32@s370_edit_
  00416	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN32@s370_edit_:

; 1014 : 
; 1015 :                 /* Turn on significance indicator if pattern
; 1016 :                    byte is significance starter or if source
; 1017 :                    digit is non-zero */
; 1018 :                 if (pbyte == 0x21 || h > 0)

  0041e	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00423	83 f8 21	 cmp	 eax, 33			; 00000021H
  00426	74 07		 je	 SHORT $LN34@s370_edit_
  00428	83 7c 24 50 00	 cmp	 DWORD PTR h$[rsp], 0
  0042d	7e 08		 jle	 SHORT $LN33@s370_edit_
$LN34@s370_edit_:

; 1019 :                     sig = 1;

  0042f	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR sig$[rsp], 1
$LN33@s370_edit_:

; 1020 : 
; 1021 :                 /* Examine right digit for sign code */
; 1022 :                 if (d == 1 && sbyte > 9)

  00437	83 7c 24 5c 01	 cmp	 DWORD PTR d$[rsp], 1
  0043c	75 2e		 jne	 SHORT $LN35@s370_edit_
  0043e	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00443	83 f8 09	 cmp	 eax, 9
  00446	7e 24		 jle	 SHORT $LN35@s370_edit_

; 1023 :                 {
; 1024 :                     /* Turn off the significance indicator if
; 1025 :                        the right digit is a plus sign code */
; 1026 :                     if (sbyte != 0x0B && sbyte != 0x0D)

  00448	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  0044d	83 f8 0b	 cmp	 eax, 11
  00450	74 12		 je	 SHORT $LN36@s370_edit_
  00452	0f b6 44 24 30	 movzx	 eax, BYTE PTR sbyte$[rsp]
  00457	83 f8 0d	 cmp	 eax, 13
  0045a	74 08		 je	 SHORT $LN36@s370_edit_

; 1027 :                         sig = 0;

  0045c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0
$LN36@s370_edit_:

; 1028 : 
; 1029 :                     /* Take next digit from next source byte */
; 1030 :                     d = 0;

  00464	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR d$[rsp], 0
$LN35@s370_edit_:

; 1031 :                 }
; 1032 :             }

  0046c	e9 fd 00 00 00	 jmp	 $LN22@s370_edit_
$LN21@s370_edit_:

; 1033 : 
; 1034 :             /* If pattern byte is field separator (X'22') then
; 1035 :                replace it by the fill character, turn off the
; 1036 :                significance indicator, and zeroize conditon code  */
; 1037 :             else if (pbyte == 0x22)

  00471	0f b6 44 24 31	 movzx	 eax, BYTE PTR pbyte$[rsp]
  00476	83 f8 22	 cmp	 eax, 34			; 00000022H
  00479	75 5c		 jne	 SHORT $LN37@s370_edit_

; 1038 :             {
; 1039 :                 if(!trial_run)

  0047b	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  00480	75 1d		 jne	 SHORT $LN39@s370_edit_

; 1040 :                     ARCH_DEP(vstoreb) ( fbyte, addr1, b1, regs );

  00482	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0048a	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  0048f	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  00493	0f b6 4c 24 32	 movzx	 ecx, BYTE PTR fbyte$[rsp]
  00498	e8 00 00 00 00	 call	 s370_vstoreb
  0049d	eb 23		 jmp	 SHORT $LN40@s370_edit_
$LN39@s370_edit_:

; 1041 :                 else
; 1042 :                     ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  0049f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ac	41 b9 01 00 00
	00		 mov	 r9d, 1
  004b2	45 33 c0	 xor	 r8d, r8d
  004b5	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  004b9	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  004bd	e8 00 00 00 00	 call	 s370_validate_operand
$LN40@s370_edit_:

; 1043 :                 sig = 0;

  004c2	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sig$[rsp], 0

; 1044 :                 cc = 0;

  004ca	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1045 :             }

  004d2	e9 97 00 00 00	 jmp	 $LN38@s370_edit_
$LN37@s370_edit_:

; 1046 : 
; 1047 :             /* If pattern byte is a message byte (anything other
; 1048 :                than X'20', X'21', or X'22') then replace it by
; 1049 :                the fill byte if the significance indicator is off */
; 1050 :             else
; 1051 :             {
; 1052 :                 if (sig == 0)

  004d7	83 7c 24 44 00	 cmp	 DWORD PTR sig$[rsp], 0
  004dc	75 49		 jne	 SHORT $LN41@s370_edit_

; 1053 :                 {
; 1054 :                     if (!trial_run)

  004de	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  004e3	75 1d		 jne	 SHORT $LN43@s370_edit_

; 1055 :                         ARCH_DEP(vstoreb) ( fbyte, addr1, b1, regs );

  004e5	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004ed	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  004f2	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  004f6	0f b6 4c 24 32	 movzx	 ecx, BYTE PTR fbyte$[rsp]
  004fb	e8 00 00 00 00	 call	 s370_vstoreb
  00500	eb 23		 jmp	 SHORT $LN44@s370_edit_
$LN43@s370_edit_:

; 1056 :                     else
; 1057 :                         ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  00502	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0050f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00515	45 33 c0	 xor	 r8d, r8d
  00518	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  0051c	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  00520	e8 00 00 00 00	 call	 s370_validate_operand
$LN44@s370_edit_:

; 1058 :                 }

  00525	eb 47		 jmp	 SHORT $LN42@s370_edit_
$LN41@s370_edit_:

; 1059 :                 else /* store message byte */
; 1060 :                 {
; 1061 :                     if (!trial_run)

  00527	83 7c 24 3c 00	 cmp	 DWORD PTR trial_run$[rsp], 0
  0052c	75 1d		 jne	 SHORT $LN45@s370_edit_

; 1062 :                         ARCH_DEP(vstoreb) ( pbyte, addr1, b1, regs );

  0052e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00536	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  0053b	8b 54 24 34	 mov	 edx, DWORD PTR addr1$[rsp]
  0053f	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR pbyte$[rsp]
  00544	e8 00 00 00 00	 call	 s370_vstoreb
  00549	eb 23		 jmp	 SHORT $LN46@s370_edit_
$LN45@s370_edit_:

; 1063 :                     else
; 1064 :                         ARCH_DEP(validate_operand) (addr1, b1, 0, ACCTYPE_WRITE_SKP, regs);

  0054b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00553	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00558	41 b9 01 00 00
	00		 mov	 r9d, 1
  0055e	45 33 c0	 xor	 r8d, r8d
  00561	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00565	8b 4c 24 34	 mov	 ecx, DWORD PTR addr1$[rsp]
  00569	e8 00 00 00 00	 call	 s370_validate_operand
$LN46@s370_edit_:
$LN42@s370_edit_:
$LN38@s370_edit_:
$LN22@s370_edit_:

; 1065 :                 }
; 1066 :             }
; 1067 : 
; 1068 :             /* Increment first operand address */
; 1069 :             addr1++;

  0056e	8b 44 24 34	 mov	 eax, DWORD PTR addr1$[rsp]
  00572	ff c0		 inc	 eax
  00574	89 44 24 34	 mov	 DWORD PTR addr1$[rsp], eax

; 1070 :             addr1 &= ADDRESS_MAXWRAP(regs);

  00578	8b 44 24 34	 mov	 eax, DWORD PTR addr1$[rsp]
  0057c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00581	89 44 24 34	 mov	 DWORD PTR addr1$[rsp], eax

; 1071 : 
; 1072 :         } /* end for(i) */

  00585	e9 70 fc ff ff	 jmp	 $LN8@s370_edit_
$LN9@s370_edit_:

; 1073 : 
; 1074 :     } /* end for(trial_run) */

  0058a	e9 1a fc ff ff	 jmp	 $LN5@s370_edit_
$LN6@s370_edit_:

; 1075 : 
; 1076 :     /* Replace condition code 2 by condition code 1 if the
; 1077 :        significance indicator is on at the end of editing */
; 1078 :     if (sig && cc == 2) cc = 1;

  0058f	83 7c 24 44 00	 cmp	 DWORD PTR sig$[rsp], 0
  00594	74 0f		 je	 SHORT $LN47@s370_edit_
  00596	83 7c 24 54 02	 cmp	 DWORD PTR cc$[rsp], 2
  0059b	75 08		 jne	 SHORT $LN47@s370_edit_
  0059d	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1
$LN47@s370_edit_:

; 1079 : 
; 1080 :     /* Set condition code */
; 1081 :     regs->psw.cc = cc;

  005a5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ad	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR cc$[rsp]
  005b2	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1082 : 
; 1083 : #if defined( FEATURE_PER1 )
; 1084 :     /* Check for PER 1 GRA event */
; 1085 :     if (inst[0] == 0xDF) // EDMK?

  005b5	b8 01 00 00 00	 mov	 eax, 1
  005ba	48 6b c0 00	 imul	 rax, rax, 0
  005be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  005c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005ca	3d df 00 00 00	 cmp	 eax, 223		; 000000dfH
  005cf	0f 85 89 00 00
	00		 jne	 $LN48@s370_edit_
$LN13@s370_edit_:

; 1086 :         PER_GRA_CHECK( regs, PER_GRA_MASK( 1 ));

  005d5	33 c0		 xor	 eax, eax
  005d7	83 f8 01	 cmp	 eax, 1
  005da	74 78		 je	 SHORT $LN49@s370_edit_
  005dc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  005ea	c1 e8 02	 shr	 eax, 2
  005ed	83 e0 01	 and	 eax, 1
  005f0	85 c0		 test	 eax, eax
  005f2	74 0a		 je	 SHORT $LN55@s370_edit_
  005f4	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv283[rsp], 1
  005fc	eb 08		 jmp	 SHORT $LN56@s370_edit_
$LN55@s370_edit_:
  005fe	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv283[rsp], 0
$LN56@s370_edit_:
  00606	83 7c 24 74 00	 cmp	 DWORD PTR tv283[rsp], 0
  0060b	74 47		 je	 SHORT $LN49@s370_edit_
  0060d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00615	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00618	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  0061d	85 c0		 test	 eax, eax
  0061f	74 33		 je	 SHORT $LN49@s370_edit_
  00621	b8 08 00 00 00	 mov	 eax, 8
  00626	48 6b c0 0a	 imul	 rax, rax, 10
  0062a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00632	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00639	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0063e	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00643	85 c0		 test	 eax, eax
  00645	74 0d		 je	 SHORT $LN49@s370_edit_
  00647	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0064f	e8 00 00 00 00	 call	 s370_per1_gra
$LN49@s370_edit_:
  00654	33 c0		 xor	 eax, eax
  00656	85 c0		 test	 eax, eax
  00658	0f 85 77 ff ff
	ff		 jne	 $LN13@s370_edit_
$LN48@s370_edit_:

; 1087 : #endif
; 1088 : 
; 1089 : } /* end DEF_INST(edit_x_edit_and_mark) */

  0065e	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00665	c3		 ret	 0
s370_edit_x_edit_and_mark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
effective_addr1$ = 64
l2$ = 68
effective_addr2$ = 72
l1$ = 76
b1$ = 80
temp$1 = 84
b2$ = 88
count2$ = 92
tv189 = 96
sign1$ = 100
count1$ = 104
sign2$ = 108
signr$ = 112
signq$ = 116
tv177 = 120
dec2$ = 128
dec1$ = 160
rem$ = 192
quot$ = 224
__$ArrayPad$ = 256
inst$ = 288
regs$ = 296
s370_divide_decimal PROC

; 834  : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 835  : int     l1, l2;                         /* Length values             */
; 836  : int     b1, b2;                         /* Base register numbers     */
; 837  : VADR    effective_addr1,
; 838  :         effective_addr2;                /* Effective addresses       */
; 839  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Operand 1 (dividend)      */
; 840  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Operand 2 (divisor)       */
; 841  : BYTE    quot[MAX_DECIMAL_DIGITS];       /* Quotient                  */
; 842  : BYTE    rem[MAX_DECIMAL_DIGITS];        /* Remainder                 */
; 843  : int     count1, count2;                 /* Significant digit counters*/
; 844  : int     sign1, sign2;                   /* Sign of operands          */
; 845  : int     signq, signr;                   /* Sign of quotient/remainder*/
; 846  : 
; 847  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004f	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 58	 mov	 DWORD PTR b2$[rsp], eax
  0005d	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00069	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006d	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00071	c1 e8 1c	 shr	 eax, 28
  00074	83 e0 0f	 and	 eax, 15
  00077	89 44 24 50	 mov	 DWORD PTR b1$[rsp], eax
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 44	 mov	 DWORD PTR l2$[rsp], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	c1 f8 04	 sar	 eax, 4
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 4c	 mov	 DWORD PTR l1$[rsp], eax
  000b6	83 7c 24 50 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bb	74 2d		 je	 SHORT $LN5@s370_divid
  000bd	48 63 44 24 50	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c2	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d1	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d5	03 c8		 add	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000dd	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000e1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e6	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_divid:
  000ea	83 7c 24 58 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ef	74 2d		 je	 SHORT $LN6@s370_divid
  000f1	48 63 44 24 58	 movsxd	 rax, DWORD PTR b2$[rsp]
  000f6	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00105	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00109	03 c8		 add	 ecx, eax
  0010b	8b c1		 mov	 eax, ecx
  0010d	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00111	8b 44 24 48	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00115	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011a	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_divid:
$LN4@s370_divid:
  0011e	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012a	48 83 c0 06	 add	 rax, 6
  0012e	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013a	33 c0		 xor	 eax, eax
  0013c	83 f8 06	 cmp	 eax, 6
  0013f	74 0f		 je	 SHORT $LN7@s370_divid
  00141	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_divid:
  00150	33 c0		 xor	 eax, eax
  00152	85 c0		 test	 eax, eax
  00154	75 c8		 jne	 SHORT $LN4@s370_divid

; 848  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 849  :     TXFC_INSTR_CHECK( regs );
; 850  : 
; 851  :     /* Program check if the second operand length exceeds 15 digits
; 852  :        or is equal to or greater than the first operand length */
; 853  :     if (l2 > 7 || l2 >= l1)

  00156	83 7c 24 44 07	 cmp	 DWORD PTR l2$[rsp], 7
  0015b	7f 0a		 jg	 SHORT $LN9@s370_divid
  0015d	8b 44 24 4c	 mov	 eax, DWORD PTR l1$[rsp]
  00161	39 44 24 44	 cmp	 DWORD PTR l2$[rsp], eax
  00165	7c 12		 jl	 SHORT $LN8@s370_divid
$LN9@s370_divid:

; 854  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00167	ba 06 00 00 00	 mov	 edx, 6
  0016c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_divid:

; 855  : 
; 856  :     /* Load operands into work areas */
; 857  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00179	48 8d 44 24 64	 lea	 rax, QWORD PTR sign1$[rsp]
  0017e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00183	48 8d 44 24 68	 lea	 rax, QWORD PTR count1$[rsp]
  00188	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018d	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00195	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019a	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001a2	44 8b 44 24 50	 mov	 r8d, DWORD PTR b1$[rsp]
  001a7	8b 54 24 4c	 mov	 edx, DWORD PTR l1$[rsp]
  001ab	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001af	e8 00 00 00 00	 call	 s370_load_decimal

; 858  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  001b4	48 8d 44 24 6c	 lea	 rax, QWORD PTR sign2$[rsp]
  001b9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001be	48 8d 44 24 5c	 lea	 rax, QWORD PTR count2$[rsp]
  001c3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c8	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  001d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d5	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001dd	44 8b 44 24 58	 mov	 r8d, DWORD PTR b2$[rsp]
  001e2	8b 54 24 44	 mov	 edx, DWORD PTR l2$[rsp]
  001e6	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001ea	e8 00 00 00 00	 call	 s370_load_decimal

; 859  : 
; 860  :     /* Program check if second operand value is zero */
; 861  :     if (count2 == 0)

  001ef	83 7c 24 5c 00	 cmp	 DWORD PTR count2$[rsp], 0
  001f4	75 12		 jne	 SHORT $LN10@s370_divid

; 862  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_DIVIDE_EXCEPTION);

  001f6	ba 0b 00 00 00	 mov	 edx, 11
  001fb	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_divid:

; 863  : 
; 864  :     /* Perform trial comparison to determine potential overflow.
; 865  :        The leftmost digit of the divisor is aligned one digit to
; 866  :        the right of the leftmost dividend digit.  When the divisor,
; 867  :        so aligned, is less than or equal to the dividend, ignoring
; 868  :        signs, a divide exception is indicated.  As a result of this
; 869  :        comparison, it is also certain that the leftmost digit of the
; 870  :        dividend must be zero, and that the divisor cannot be zero */
; 871  :     if (memcmp(dec2 + (MAX_DECIMAL_DIGITS - l2*2 - 2),
; 872  :                 dec1 + (MAX_DECIMAL_DIGITS - l1*2 - 1),
; 873  :                 l2*2 + 2) <= 0)

  00208	8b 44 24 44	 mov	 eax, DWORD PTR l2$[rsp]
  0020c	8d 44 00 02	 lea	 eax, DWORD PTR [rax+rax+2]
  00210	48 98		 cdqe
  00212	8b 4c 24 4c	 mov	 ecx, DWORD PTR l1$[rsp]
  00216	d1 e1		 shl	 ecx, 1
  00218	ba 1f 00 00 00	 mov	 edx, 31
  0021d	2b d1		 sub	 edx, ecx
  0021f	8b ca		 mov	 ecx, edx
  00221	ff c9		 dec	 ecx
  00223	48 63 c9	 movsxd	 rcx, ecx
  00226	48 8d 8c 0c a0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp+rcx]
  0022e	8b 54 24 44	 mov	 edx, DWORD PTR l2$[rsp]
  00232	d1 e2		 shl	 edx, 1
  00234	41 b8 1f 00 00
	00		 mov	 r8d, 31
  0023a	44 2b c2	 sub	 r8d, edx
  0023d	41 8b d0	 mov	 edx, r8d
  00240	83 ea 02	 sub	 edx, 2
  00243	48 63 d2	 movsxd	 rdx, edx
  00246	48 8d 94 14 80
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp+rdx]
  0024e	48 89 54 24 78	 mov	 QWORD PTR tv177[rsp], rdx
  00253	4c 8b c0	 mov	 r8, rax
  00256	48 8b d1	 mov	 rdx, rcx
  00259	48 8b 44 24 78	 mov	 rax, QWORD PTR tv177[rsp]
  0025e	48 8b c8	 mov	 rcx, rax
  00261	e8 00 00 00 00	 call	 memcmp
  00266	85 c0		 test	 eax, eax
  00268	7f 12		 jg	 SHORT $LN11@s370_divid

; 874  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_DIVIDE_EXCEPTION);

  0026a	ba 0b 00 00 00	 mov	 edx, 11
  0026f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00277	e8 00 00 00 00	 call	 s370_program_interrupt
$LN11@s370_divid:

; 875  : 
; 876  :     /* Perform decimal division */
; 877  :     divide_decimal (dec1, count1, dec2, count2, quot, rem);

  0027c	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR rem$[rsp]
  00284	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00289	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR quot$[rsp]
  00291	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00296	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR count2$[rsp]
  0029b	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec2$[rsp]
  002a3	8b 54 24 68	 mov	 edx, DWORD PTR count1$[rsp]
  002a7	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  002af	e8 00 00 00 00	 call	 divide_decimal

; 878  : 
; 879  :     /* Quotient is positive if operand signs are equal, and negative
; 880  :        if operand signs are opposite, even if quotient is zero */
; 881  :     signq = (sign1 == sign2) ? 1 : -1;

  002b4	8b 44 24 6c	 mov	 eax, DWORD PTR sign2$[rsp]
  002b8	39 44 24 64	 cmp	 DWORD PTR sign1$[rsp], eax
  002bc	75 0a		 jne	 SHORT $LN13@s370_divid
  002be	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv189[rsp], 1
  002c6	eb 08		 jmp	 SHORT $LN14@s370_divid
$LN13@s370_divid:
  002c8	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR tv189[rsp], -1
$LN14@s370_divid:
  002d0	8b 44 24 60	 mov	 eax, DWORD PTR tv189[rsp]
  002d4	89 44 24 74	 mov	 DWORD PTR signq$[rsp], eax

; 882  : 
; 883  :     /* Remainder sign is same as dividend, even if remainder is zero */
; 884  :     signr = sign1;

  002d8	8b 44 24 64	 mov	 eax, DWORD PTR sign1$[rsp]
  002dc	89 44 24 70	 mov	 DWORD PTR signr$[rsp], eax

; 885  : 
; 886  :     /* Store remainder into entire first operand location.  The entire
; 887  :        field will be filled in order to check for store protection.
; 888  :        Subsequently the quotient will be stored in the leftmost bytes
; 889  :        of the first operand location, overwriting high order zeroes */
; 890  :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, rem, signr);

  002e0	8b 44 24 70	 mov	 eax, DWORD PTR signr$[rsp]
  002e4	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002e8	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR rem$[rsp]
  002f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f5	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002fd	44 8b 44 24 50	 mov	 r8d, DWORD PTR b1$[rsp]
  00302	8b 54 24 4c	 mov	 edx, DWORD PTR l1$[rsp]
  00306	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0030a	e8 00 00 00 00	 call	 s370_store_decimal

; 891  : 
; 892  :     /* Store quotient in leftmost bytes of first operand location */
; 893  :     ARCH_DEP(store_decimal) (effective_addr1, l1-l2-1, b1, regs, quot, signq);

  0030f	8b 44 24 44	 mov	 eax, DWORD PTR l2$[rsp]
  00313	8b 4c 24 4c	 mov	 ecx, DWORD PTR l1$[rsp]
  00317	2b c8		 sub	 ecx, eax
  00319	8b c1		 mov	 eax, ecx
  0031b	ff c8		 dec	 eax
  0031d	8b 4c 24 74	 mov	 ecx, DWORD PTR signq$[rsp]
  00321	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00325	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR quot$[rsp]
  0032d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00332	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0033a	44 8b 44 24 50	 mov	 r8d, DWORD PTR b1$[rsp]
  0033f	8b d0		 mov	 edx, eax
  00341	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00345	e8 00 00 00 00	 call	 s370_store_decimal

; 894  : 
; 895  : } /* end DEF_INST(divide_decimal) */

  0034a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00352	48 33 cc	 xor	 rcx, rsp
  00355	e8 00 00 00 00	 call	 __security_check_cookie
  0035a	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00361	c3		 ret	 0
s370_divide_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
effective_addr1$ = 64
effective_addr2$ = 68
temp$1 = 72
sign1$ = 76
b1$ = 80
b2$ = 84
sign2$ = 88
tv171 = 92
rc$ = 96
tv176 = 100
l1$ = 104
l2$ = 108
count1$ = 112
count2$ = 116
dec2$ = 120
dec1$ = 152
__$ArrayPad$ = 184
inst$ = 208
regs$ = 216
s370_compare_decimal PROC

; 775  : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 776  : int     l1, l2;                         /* Length values             */
; 777  : int     b1, b2;                         /* Base register numbers     */
; 778  : VADR    effective_addr1,
; 779  :         effective_addr2;                /* Effective addresses       */
; 780  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 781  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 782  : int     count1, count2;                 /* Significant digit counters*/
; 783  : int     sign1, sign2;                   /* Sign of each operand      */
; 784  : int     rc;                             /* Return code               */
; 785  : 
; 786  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00023	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002b	48 83 c0 02	 add	 rax, 2
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 fetch_fw_noswap
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 _byteswap_ulong
  0003e	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00042	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004b	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004f	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 54	 mov	 DWORD PTR b2$[rsp], eax
  0005d	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00069	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006d	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00071	c1 e8 1c	 shr	 eax, 28
  00074	83 e0 0f	 and	 eax, 15
  00077	89 44 24 50	 mov	 DWORD PTR b1$[rsp], eax
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 01	 imul	 rax, rax, 1
  00084	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 6c	 mov	 DWORD PTR l2$[rsp], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	c1 f8 04	 sar	 eax, 4
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 68	 mov	 DWORD PTR l1$[rsp], eax
  000b6	83 7c 24 50 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bb	74 2d		 je	 SHORT $LN5@s370_compa
  000bd	48 63 44 24 50	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d1	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d5	03 c8		 add	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000dd	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000e1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e6	89 44 24 40	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_compa:
  000ea	83 7c 24 54 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ef	74 2d		 je	 SHORT $LN6@s370_compa
  000f1	48 63 44 24 54	 movsxd	 rax, DWORD PTR b2$[rsp]
  000f6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00105	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00109	03 c8		 add	 ecx, eax
  0010b	8b c1		 mov	 eax, ecx
  0010d	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00111	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00115	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011a	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_compa:
$LN4@s370_compa:
  0011e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012a	48 83 c0 06	 add	 rax, 6
  0012e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013a	33 c0		 xor	 eax, eax
  0013c	83 f8 06	 cmp	 eax, 6
  0013f	74 0f		 je	 SHORT $LN7@s370_compa
  00141	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_compa:
  00150	33 c0		 xor	 eax, eax
  00152	85 c0		 test	 eax, eax
  00154	75 c8		 jne	 SHORT $LN4@s370_compa

; 787  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 788  :     TXFC_INSTR_CHECK( regs );
; 789  : 
; 790  :     /* Load operands into work areas */
; 791  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00156	48 8d 44 24 4c	 lea	 rax, QWORD PTR sign1$[rsp]
  0015b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00160	48 8d 44 24 70	 lea	 rax, QWORD PTR count1$[rsp]
  00165	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016a	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00172	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00177	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017f	44 8b 44 24 50	 mov	 r8d, DWORD PTR b1$[rsp]
  00184	8b 54 24 68	 mov	 edx, DWORD PTR l1$[rsp]
  00188	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0018c	e8 00 00 00 00	 call	 s370_load_decimal

; 792  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  00191	48 8d 44 24 58	 lea	 rax, QWORD PTR sign2$[rsp]
  00196	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0019b	48 8d 44 24 74	 lea	 rax, QWORD PTR count2$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	48 8d 44 24 78	 lea	 rax, QWORD PTR dec2$[rsp]
  001aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001af	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b7	44 8b 44 24 54	 mov	 r8d, DWORD PTR b2$[rsp]
  001bc	8b 54 24 6c	 mov	 edx, DWORD PTR l2$[rsp]
  001c0	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001c4	e8 00 00 00 00	 call	 s370_load_decimal

; 793  : 
; 794  :     /* Result is equal if both operands are zero */
; 795  :     if (count1 == 0 && count2 == 0)

  001c9	83 7c 24 70 00	 cmp	 DWORD PTR count1$[rsp], 0
  001ce	75 18		 jne	 SHORT $LN8@s370_compa
  001d0	83 7c 24 74 00	 cmp	 DWORD PTR count2$[rsp], 0
  001d5	75 11		 jne	 SHORT $LN8@s370_compa

; 796  :     {
; 797  :         regs->psw.cc = 0;

  001d7	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001df	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 798  :         return;

  001e3	e9 ca 00 00 00	 jmp	 $LN1@s370_compa
$LN8@s370_compa:

; 799  :     }
; 800  : 
; 801  :     /* Result is low if operand 1 is -ve and operand 2 is +ve */
; 802  :     if (sign1 < 0 && sign2 > 0)

  001e8	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  001ed	7d 18		 jge	 SHORT $LN9@s370_compa
  001ef	83 7c 24 58 00	 cmp	 DWORD PTR sign2$[rsp], 0
  001f4	7e 11		 jle	 SHORT $LN9@s370_compa

; 803  :     {
; 804  :         regs->psw.cc = 1;

  001f6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fe	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 805  :         return;

  00202	e9 ab 00 00 00	 jmp	 $LN1@s370_compa
$LN9@s370_compa:

; 806  :     }
; 807  : 
; 808  :     /* Result is high if operand 1 is +ve and operand 2 is -ve */
; 809  :     if (sign1 > 0 && sign2 < 0)

  00207	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  0020c	7e 18		 jle	 SHORT $LN10@s370_compa
  0020e	83 7c 24 58 00	 cmp	 DWORD PTR sign2$[rsp], 0
  00213	7d 11		 jge	 SHORT $LN10@s370_compa

; 810  :     {
; 811  :         regs->psw.cc = 2;

  00215	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021d	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 812  :         return;

  00221	e9 8c 00 00 00	 jmp	 $LN1@s370_compa
$LN10@s370_compa:

; 813  :     }
; 814  : 
; 815  :     /* If signs are equal then compare the digits */
; 816  :     rc = memcmp (dec1, dec2, MAX_DECIMAL_DIGITS);

  00226	41 b8 1f 00 00
	00		 mov	 r8d, 31
  0022c	48 8d 54 24 78	 lea	 rdx, QWORD PTR dec2$[rsp]
  00231	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00239	e8 00 00 00 00	 call	 memcmp
  0023e	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 817  : 
; 818  :     /* Return low or high (depending on sign) if digits are unequal */
; 819  :     if (rc < 0)

  00242	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00247	7d 2b		 jge	 SHORT $LN11@s370_compa

; 820  :         regs->psw.cc = (sign1 > 0) ? 1 : 2;

  00249	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  0024e	7e 0a		 jle	 SHORT $LN16@s370_compa
  00250	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  00258	eb 08		 jmp	 SHORT $LN17@s370_compa
$LN16@s370_compa:
  0025a	c7 44 24 5c 02
	00 00 00	 mov	 DWORD PTR tv171[rsp], 2
$LN17@s370_compa:
  00262	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026a	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR tv171[rsp]
  0026f	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00272	eb 3e		 jmp	 SHORT $LN12@s370_compa
$LN11@s370_compa:

; 821  :     else
; 822  :         if (rc > 0)

  00274	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00279	7e 2b		 jle	 SHORT $LN13@s370_compa

; 823  :             regs->psw.cc = (sign1 > 0) ? 2 : 1;

  0027b	83 7c 24 4c 00	 cmp	 DWORD PTR sign1$[rsp], 0
  00280	7e 0a		 jle	 SHORT $LN18@s370_compa
  00282	c7 44 24 64 02
	00 00 00	 mov	 DWORD PTR tv176[rsp], 2
  0028a	eb 08		 jmp	 SHORT $LN19@s370_compa
$LN18@s370_compa:
  0028c	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv176[rsp], 1
$LN19@s370_compa:
  00294	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029c	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR tv176[rsp]
  002a1	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  002a4	eb 0c		 jmp	 SHORT $LN14@s370_compa
$LN13@s370_compa:

; 824  :         else
; 825  :             regs->psw.cc = 0;

  002a6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ae	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN14@s370_compa:
$LN12@s370_compa:
$LN1@s370_compa:

; 826  : 
; 827  : } /* end DEF_INST(compare_decimal) */

  002b2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ba	48 33 cc	 xor	 rcx, rsp
  002bd	e8 00 00 00 00	 call	 __security_check_cookie
  002c2	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  002c9	c3		 ret	 0
s370_compare_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
sign3$ = 64
count3$ = 68
effective_addr1$ = 72
effective_addr2$ = 76
temp$1 = 80
sign1$ = 84
b1$ = 88
b2$ = 92
l1$ = 96
cc$ = 100
count1$ = 104
count2$ = 108
sign2$ = 112
tv183 = 116
tv184 = 120
l2$ = 124
dec3$ = 128
dec2$ = 160
dec1$ = 192
__$ArrayPad$ = 224
inst$ = 272
regs$ = 280
s370_add_decimal PROC

; 699  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 700  : int     l1, l2;                         /* Length values             */
; 701  : int     b1, b2;                         /* Base register numbers     */
; 702  : VADR    effective_addr1,
; 703  :         effective_addr2;                /* Effective addresses       */
; 704  : int     cc;                             /* Condition code            */
; 705  : BYTE    dec1[MAX_DECIMAL_DIGITS];       /* Work area for operand 1   */
; 706  : BYTE    dec2[MAX_DECIMAL_DIGITS];       /* Work area for operand 2   */
; 707  : BYTE    dec3[MAX_DECIMAL_DIGITS];       /* Work area for result      */
; 708  : int     count1, count2, count3;         /* Significant digit counters*/
; 709  : int     sign1, sign2, sign3;            /* Sign of operands & result */
; 710  : 
; 711  :     SS(inst, regs, l1, l2, b1, effective_addr1, b2, effective_addr2);

  00025	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0002d	48 83 c0 02	 add	 rax, 2
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 fetch_fw_noswap
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 _byteswap_ulong
  00040	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00044	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00048	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004d	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00051	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00055	c1 e8 0c	 shr	 eax, 12
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 5c	 mov	 DWORD PTR b2$[rsp], eax
  0005f	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 10	 shr	 eax, 16
  00066	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006b	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006f	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  00073	c1 e8 1c	 shr	 eax, 28
  00076	83 e0 0f	 and	 eax, 15
  00079	89 44 24 58	 mov	 DWORD PTR b1$[rsp], eax
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	48 6b c0 01	 imul	 rax, rax, 1
  00086	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0008e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 7c	 mov	 DWORD PTR l2$[rsp], eax
  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 01	 imul	 rax, rax, 1
  000a2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ae	c1 f8 04	 sar	 eax, 4
  000b1	83 e0 0f	 and	 eax, 15
  000b4	89 44 24 60	 mov	 DWORD PTR l1$[rsp], eax
  000b8	83 7c 24 58 00	 cmp	 DWORD PTR b1$[rsp], 0
  000bd	74 2d		 je	 SHORT $LN5@s370_add_d
  000bf	48 63 44 24 58	 movsxd	 rax, DWORD PTR b1$[rsp]
  000c4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d3	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000d7	03 c8		 add	 ecx, eax
  000d9	8b c1		 mov	 eax, ecx
  000db	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000df	8b 44 24 48	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000e3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e8	89 44 24 48	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_add_d:
  000ec	83 7c 24 5c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000f1	74 2d		 je	 SHORT $LN6@s370_add_d
  000f3	48 63 44 24 5c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000f8	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00107	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0010b	03 c8		 add	 ecx, eax
  0010d	8b c1		 mov	 eax, ecx
  0010f	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00113	8b 44 24 4c	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00117	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011c	89 44 24 4c	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_add_d:
$LN4@s370_add_d:
  00120	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00128	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012c	48 83 c0 06	 add	 rax, 6
  00130	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013c	33 c0		 xor	 eax, eax
  0013e	83 f8 06	 cmp	 eax, 6
  00141	74 0f		 je	 SHORT $LN7@s370_add_d
  00143	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_add_d:
  00152	33 c0		 xor	 eax, eax
  00154	85 c0		 test	 eax, eax
  00156	75 c8		 jne	 SHORT $LN4@s370_add_d

; 712  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 713  :     TXFC_INSTR_CHECK( regs );
; 714  : 
; 715  :     /* Load operands into work areas */
; 716  :     ARCH_DEP(load_decimal) (effective_addr1, l1, b1, regs, dec1, &count1, &sign1);

  00158	48 8d 44 24 54	 lea	 rax, QWORD PTR sign1$[rsp]
  0015d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00162	48 8d 44 24 68	 lea	 rax, QWORD PTR count1$[rsp]
  00167	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016c	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dec1$[rsp]
  00174	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00179	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00181	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  00186	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  0018a	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0018e	e8 00 00 00 00	 call	 s370_load_decimal

; 717  :     ARCH_DEP(load_decimal) (effective_addr2, l2, b2, regs, dec2, &count2, &sign2);

  00193	48 8d 44 24 70	 lea	 rax, QWORD PTR sign2$[rsp]
  00198	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0019d	48 8d 44 24 6c	 lea	 rax, QWORD PTR count2$[rsp]
  001a2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a7	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dec2$[rsp]
  001af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b4	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001bc	44 8b 44 24 5c	 mov	 r8d, DWORD PTR b2$[rsp]
  001c1	8b 54 24 7c	 mov	 edx, DWORD PTR l2$[rsp]
  001c5	8b 4c 24 4c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001c9	e8 00 00 00 00	 call	 s370_load_decimal

; 718  : 
; 719  :     /* Add or subtract operand values */
; 720  :     if (count2 == 0)

  001ce	83 7c 24 6c 00	 cmp	 DWORD PTR count2$[rsp], 0
  001d3	75 32		 jne	 SHORT $LN8@s370_add_d

; 721  :     {
; 722  :         /* If second operand is zero then result is first operand */
; 723  :         memcpy (dec3, dec1, MAX_DECIMAL_DIGITS);

  001d5	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  001dd	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  001e5	48 8b f8	 mov	 rdi, rax
  001e8	48 8b f1	 mov	 rsi, rcx
  001eb	b9 1f 00 00 00	 mov	 ecx, 31
  001f0	f3 a4		 rep movsb

; 724  :         count3 = count1;

  001f2	8b 44 24 68	 mov	 eax, DWORD PTR count1$[rsp]
  001f6	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 725  :         sign3 = sign1;

  001fa	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  001fe	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 726  :     }

  00202	e9 a9 00 00 00	 jmp	 $LN9@s370_add_d
$LN8@s370_add_d:

; 727  :     else if (count1 == 0)

  00207	83 7c 24 68 00	 cmp	 DWORD PTR count1$[rsp], 0
  0020c	75 2f		 jne	 SHORT $LN10@s370_add_d

; 728  :     {
; 729  :         /* If first operand is zero then result is second operand */
; 730  :         memcpy (dec3, dec2, MAX_DECIMAL_DIGITS);

  0020e	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  00216	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dec2$[rsp]
  0021e	48 8b f8	 mov	 rdi, rax
  00221	48 8b f1	 mov	 rsi, rcx
  00224	b9 1f 00 00 00	 mov	 ecx, 31
  00229	f3 a4		 rep movsb

; 731  :         count3 = count2;

  0022b	8b 44 24 6c	 mov	 eax, DWORD PTR count2$[rsp]
  0022f	89 44 24 44	 mov	 DWORD PTR count3$[rsp], eax

; 732  :         sign3 = sign2;

  00233	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  00237	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 733  :     }

  0023b	eb 73		 jmp	 SHORT $LN11@s370_add_d
$LN10@s370_add_d:

; 734  :     else if (sign1 == sign2)

  0023d	8b 44 24 70	 mov	 eax, DWORD PTR sign2$[rsp]
  00241	39 44 24 54	 cmp	 DWORD PTR sign1$[rsp], eax
  00245	75 2c		 jne	 SHORT $LN12@s370_add_d

; 735  :     {
; 736  :         /* If signs are equal then add operands */
; 737  :         add_decimal (dec1, dec2, dec3, &count3);

  00247	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  0024c	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  00254	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  0025c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  00264	e8 00 00 00 00	 call	 add_decimal

; 738  :         sign3 = sign1;

  00269	8b 44 24 54	 mov	 eax, DWORD PTR sign1$[rsp]
  0026d	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax

; 739  :     }

  00271	eb 3d		 jmp	 SHORT $LN13@s370_add_d
$LN12@s370_add_d:

; 740  :     else
; 741  :     {
; 742  :         /* If signs are opposite then subtract operands */
; 743  :         subtract_decimal (dec1, dec2, dec3, &count3, &sign3);

  00273	48 8d 44 24 40	 lea	 rax, QWORD PTR sign3$[rsp]
  00278	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027d	4c 8d 4c 24 44	 lea	 r9, QWORD PTR count3$[rsp]
  00282	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dec3$[rsp]
  0028a	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dec2$[rsp]
  00292	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dec1$[rsp]
  0029a	e8 00 00 00 00	 call	 subtract_decimal

; 744  :         if (sign1 < 0) sign3 = -sign3;

  0029f	83 7c 24 54 00	 cmp	 DWORD PTR sign1$[rsp], 0
  002a4	7d 0a		 jge	 SHORT $LN14@s370_add_d
  002a6	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  002aa	f7 d8		 neg	 eax
  002ac	89 44 24 40	 mov	 DWORD PTR sign3$[rsp], eax
$LN14@s370_add_d:
$LN13@s370_add_d:
$LN11@s370_add_d:
$LN9@s370_add_d:

; 745  :     }
; 746  : 
; 747  :     /* Set condition code */
; 748  :     cc = (count3 == 0) ? 0 : (sign3 < 1) ? 1 : 2;

  002b0	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  002b5	75 0a		 jne	 SHORT $LN21@s370_add_d
  002b7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
  002bf	eb 21		 jmp	 SHORT $LN22@s370_add_d
$LN21@s370_add_d:
  002c1	83 7c 24 40 01	 cmp	 DWORD PTR sign3$[rsp], 1
  002c6	7d 0a		 jge	 SHORT $LN19@s370_add_d
  002c8	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
  002d0	eb 08		 jmp	 SHORT $LN20@s370_add_d
$LN19@s370_add_d:
  002d2	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv183[rsp], 2
$LN20@s370_add_d:
  002da	8b 44 24 74	 mov	 eax, DWORD PTR tv183[rsp]
  002de	89 44 24 78	 mov	 DWORD PTR tv184[rsp], eax
$LN22@s370_add_d:
  002e2	8b 44 24 78	 mov	 eax, DWORD PTR tv184[rsp]
  002e6	89 44 24 64	 mov	 DWORD PTR cc$[rsp], eax

; 749  : 
; 750  :     /* Overflow if result exceeds first operand length */
; 751  :     if (count3 > (l1+1) * 2 - 1)

  002ea	8b 44 24 60	 mov	 eax, DWORD PTR l1$[rsp]
  002ee	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  002f2	39 44 24 44	 cmp	 DWORD PTR count3$[rsp], eax
  002f6	7e 08		 jle	 SHORT $LN15@s370_add_d

; 752  :         cc = 3;

  002f8	c7 44 24 64 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN15@s370_add_d:

; 753  : 
; 754  :     /* Set positive sign if result is zero */
; 755  :     if (count3 == 0)

  00300	83 7c 24 44 00	 cmp	 DWORD PTR count3$[rsp], 0
  00305	75 08		 jne	 SHORT $LN16@s370_add_d

; 756  :         sign3 = 1;

  00307	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR sign3$[rsp], 1
$LN16@s370_add_d:

; 757  : 
; 758  :     /* Store result into first operand location */
; 759  :     ARCH_DEP(store_decimal) (effective_addr1, l1, b1, regs, dec3, sign3);

  0030f	8b 44 24 40	 mov	 eax, DWORD PTR sign3$[rsp]
  00313	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00317	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dec3$[rsp]
  0031f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00324	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0032c	44 8b 44 24 58	 mov	 r8d, DWORD PTR b1$[rsp]
  00331	8b 54 24 60	 mov	 edx, DWORD PTR l1$[rsp]
  00335	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00339	e8 00 00 00 00	 call	 s370_store_decimal

; 760  : 
; 761  :     /* Set condition code */
; 762  :     regs->psw.cc = cc;

  0033e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00346	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR cc$[rsp]
  0034b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 763  : 
; 764  :     /* Program check if overflow and PSW program mask is set */
; 765  :     if (cc == 3 && DOMASK(&regs->psw))

  0034e	83 7c 24 64 03	 cmp	 DWORD PTR cc$[rsp], 3
  00353	75 25		 jne	 SHORT $LN17@s370_add_d
  00355	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035d	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00361	83 e0 04	 and	 eax, 4
  00364	85 c0		 test	 eax, eax
  00366	74 12		 je	 SHORT $LN17@s370_add_d

; 766  :         ARCH_DEP(program_interrupt) (regs, PGM_DECIMAL_OVERFLOW_EXCEPTION);

  00368	ba 0a 00 00 00	 mov	 edx, 10
  0036d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00375	e8 00 00 00 00	 call	 s370_program_interrupt
$LN17@s370_add_d:

; 767  : 
; 768  : } /* end DEF_INST(add_decimal) */

  0037a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00382	48 33 cc	 xor	 rcx, rsp
  00385	e8 00 00 00 00	 call	 __security_check_cookie
  0038a	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00391	5f		 pop	 rdi
  00392	5e		 pop	 rsi
  00393	c3		 ret	 0
s370_add_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
i$ = 48
effective_addr1$ = 52
cc$ = 56
temp$1 = 60
b1$ = 64
l1$ = 68
pack$ = 72
__$ArrayPad$ = 88
inst$ = 112
regs$ = 120
s370_test_decimal PROC

; 1387 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1388 : int     l1;                             /* Length value              */
; 1389 : int     b1;                             /* Base register number      */
; 1390 : VADR    effective_addr1;                /* Effective address         */
; 1391 : int     i;                              /* Array subscript           */
; 1392 : int     cc = 0;                         /* Condition code            */

  0001d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1393 : BYTE    pack[MAX_DECIMAL_LENGTH];       /* Packed decimal work area  */
; 1394 : 
; 1395 :     RSL(inst, regs, l1, b1, effective_addr1);

  00025	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 _byteswap_ulong
  00036	89 44 24 3c	 mov	 DWORD PTR temp$1[rsp], eax
  0003a	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  0003e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00043	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00047	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  0004b	c1 e8 0c	 shr	 eax, 12
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR b1$[rsp], eax
  00055	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 44	 mov	 DWORD PTR l1$[rsp], eax
  00063	83 7c 24 40 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_test_
  0006a	48 63 44 24 40	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 34	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_test_:
$LN4@s370_test_:
  00094	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00099	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009d	48 83 c0 06	 add	 rax, 6
  000a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000aa	33 c0		 xor	 eax, eax
  000ac	83 f8 06	 cmp	 eax, 6
  000af	74 0c		 je	 SHORT $LN9@s370_test_
  000b1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@s370_test_:
  000bd	33 c0		 xor	 eax, eax
  000bf	85 c0		 test	 eax, eax
  000c1	75 d1		 jne	 SHORT $LN4@s370_test_

; 1396 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1397 : 
; 1398 :     TXFC_INSTR_CHECK( regs );
; 1399 : 
; 1400 :     /* Fetch the packed decimal operand into the work area */
; 1401 :     ARCH_DEP(vfetchc) (pack, l1, effective_addr1, b1, regs);

  000c3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cd	44 8b 4c 24 40	 mov	 r9d, DWORD PTR b1$[rsp]
  000d2	44 8b 44 24 34	 mov	 r8d, DWORD PTR effective_addr1$[rsp]
  000d7	0f b6 54 24 44	 movzx	 edx, BYTE PTR l1$[rsp]
  000dc	48 8d 4c 24 48	 lea	 rcx, QWORD PTR pack$[rsp]
  000e1	e8 00 00 00 00	 call	 s370_vfetchc

; 1402 : 
; 1403 :     /* Test each byte of the operand */
; 1404 :     for (i=0; ; i++)

  000e6	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ee	eb 0a		 jmp	 SHORT $LN7@s370_test_
$LN5@s370_test_:
  000f0	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000f4	ff c0		 inc	 eax
  000f6	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_test_:

; 1405 :     {
; 1406 :         /* Test the high-order digit of the byte */
; 1407 :         if ((pack[i] & 0xF0) > 0x90)

  000fa	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000ff	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  00104	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00109	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  0010e	7e 08		 jle	 SHORT $LN10@s370_test_

; 1408 :             cc = 2;

  00110	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN10@s370_test_:

; 1409 : 
; 1410 :         /* Exit if this is the last byte */
; 1411 :         if (i == l1) break;

  00118	8b 44 24 44	 mov	 eax, DWORD PTR l1$[rsp]
  0011c	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00120	75 02		 jne	 SHORT $LN11@s370_test_
  00122	eb 1c		 jmp	 SHORT $LN6@s370_test_
$LN11@s370_test_:

; 1412 : 
; 1413 :         /* Test the low-order digit of the byte */
; 1414 :         if ((pack[i] & 0x0F) > 0x09)

  00124	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00129	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  0012e	83 e0 0f	 and	 eax, 15
  00131	83 f8 09	 cmp	 eax, 9
  00134	7e 08		 jle	 SHORT $LN12@s370_test_

; 1415 :             cc = 2;

  00136	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
$LN12@s370_test_:

; 1416 :     }

  0013e	eb b0		 jmp	 SHORT $LN5@s370_test_
$LN6@s370_test_:

; 1417 : 
; 1418 :     /* Test the sign in the last byte */
; 1419 :     if ((pack[i] & 0x0F) < 0x0A)

  00140	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00145	0f b6 44 04 48	 movzx	 eax, BYTE PTR pack$[rsp+rax]
  0014a	83 e0 0f	 and	 eax, 15
  0014d	83 f8 0a	 cmp	 eax, 10
  00150	7d 0b		 jge	 SHORT $LN13@s370_test_

; 1420 :         cc |= 1;

  00152	8b 44 24 38	 mov	 eax, DWORD PTR cc$[rsp]
  00156	83 c8 01	 or	 eax, 1
  00159	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax
$LN13@s370_test_:

; 1421 : 
; 1422 :     /* Return condition code */
; 1423 :     regs->psw.cc = cc;

  0015d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00162	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR cc$[rsp]
  00167	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1424 : 
; 1425 : } /* end DEF_INST(test_decimal) */

  0016a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016f	48 33 cc	 xor	 rcx, rsp
  00172	e8 00 00 00 00	 call	 __security_check_cookie
  00177	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017b	c3		 ret	 0
s370_test_decimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
d$ = 0
i$ = 4
bin$ = 48
result$ = 56
binary_to_packed PROC

; 217  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 18	 sub	 rsp, 24

; 218  : int     i;                              /* Array subscript           */
; 219  : int     d;                              /* Decimal digit or sign     */
; 220  : 
; 221  :     /* Special case when input is maximum negative value */
; 222  :     if ((U64)bin == 0x8000000000000000ULL)

  00010	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0001a	48 39 44 24 30	 cmp	 QWORD PTR bin$[rsp], rax
  0001f	75 1b		 jne	 SHORT $LN5@binary_to_

; 223  :     {
; 224  :         memcpy (result,

  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169595
  00028	48 8b 7c 24 38	 mov	 rdi, QWORD PTR result$[rsp]
  0002d	48 8b f0	 mov	 rsi, rax
  00030	b9 10 00 00 00	 mov	 ecx, 16
  00035	f3 a4		 rep movsb

; 225  :                 "\x00\x00\x00\x00\x00\x00\x92\x23"
; 226  :                 "\x37\x20\x36\x85\x47\x75\x80\x8D",
; 227  :                 16);
; 228  :     }

  00037	e9 ed 00 00 00	 jmp	 $LN6@binary_to_
$LN5@binary_to_:

; 229  :     else
; 230  :     {
; 231  :         /* Load absolute value and generate sign */
; 232  :         if ((U64)bin < 0x8000000000000000ULL)

  0003c	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00046	48 39 44 24 30	 cmp	 QWORD PTR bin$[rsp], rax
  0004b	73 09		 jae	 SHORT $LN7@binary_to_

; 233  :         {
; 234  :             /* Value is positive */
; 235  :             d = 0x0C;

  0004d	c7 04 24 0c 00
	00 00		 mov	 DWORD PTR d$[rsp], 12

; 236  :         }

  00054	eb 14		 jmp	 SHORT $LN8@binary_to_
$LN7@binary_to_:

; 237  :         else
; 238  :         {
; 239  :             /* Value is negative */
; 240  :             bin = -bin;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR bin$[rsp]
  0005b	48 f7 d8	 neg	 rax
  0005e	48 89 44 24 30	 mov	 QWORD PTR bin$[rsp], rax

; 241  :             d = 0x0D;

  00063	c7 04 24 0d 00
	00 00		 mov	 DWORD PTR d$[rsp], 13
$LN8@binary_to_:

; 242  :         }
; 243  : 
; 244  :         /* Store sign and decimal digits from right to left */
; 245  :         memset (result, 0, 16);

  0006a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR result$[rsp]
  0006f	33 c0		 xor	 eax, eax
  00071	b9 10 00 00 00	 mov	 ecx, 16
  00076	f3 aa		 rep stosb

; 246  :         for (i = 16 - 1; d != 0 || bin != 0; i--)

  00078	c7 44 24 04 0f
	00 00 00	 mov	 DWORD PTR i$[rsp], 15
  00080	eb 0a		 jmp	 SHORT $LN4@binary_to_
$LN2@binary_to_:
  00082	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00086	ff c8		 dec	 eax
  00088	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@binary_to_:
  0008c	83 3c 24 00	 cmp	 DWORD PTR d$[rsp], 0
  00090	75 0c		 jne	 SHORT $LN9@binary_to_
  00092	48 83 7c 24 30
	00		 cmp	 QWORD PTR bin$[rsp], 0
  00098	0f 84 8b 00 00
	00		 je	 $LN3@binary_to_
$LN9@binary_to_:

; 247  :         {
; 248  :             result[i] = d;

  0009e	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  000a8	0f b6 14 24	 movzx	 edx, BYTE PTR d$[rsp]
  000ac	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 249  :             d = bin % 10;

  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR bin$[rsp]
  000b4	48 99		 cdq
  000b6	b9 0a 00 00 00	 mov	 ecx, 10
  000bb	48 f7 f9	 idiv	 rcx
  000be	48 8b c2	 mov	 rax, rdx
  000c1	89 04 24	 mov	 DWORD PTR d$[rsp], eax

; 250  :             bin /= 10;

  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR bin$[rsp]
  000c9	48 99		 cdq
  000cb	b9 0a 00 00 00	 mov	 ecx, 10
  000d0	48 f7 f9	 idiv	 rcx
  000d3	48 89 44 24 30	 mov	 QWORD PTR bin$[rsp], rax

; 251  :             result[i] |= (d << 4);

  000d8	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000dd	8b 0c 24	 mov	 ecx, DWORD PTR d$[rsp]
  000e0	c1 e1 04	 shl	 ecx, 4
  000e3	48 8b 54 24 38	 mov	 rdx, QWORD PTR result$[rsp]
  000e8	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  000ec	0b c1		 or	 eax, ecx
  000ee	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f3	48 8b 54 24 38	 mov	 rdx, QWORD PTR result$[rsp]
  000f8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 252  :             d = bin % 10;

  000fb	48 8b 44 24 30	 mov	 rax, QWORD PTR bin$[rsp]
  00100	48 99		 cdq
  00102	b9 0a 00 00 00	 mov	 ecx, 10
  00107	48 f7 f9	 idiv	 rcx
  0010a	48 8b c2	 mov	 rax, rdx
  0010d	89 04 24	 mov	 DWORD PTR d$[rsp], eax

; 253  :             bin /= 10;

  00110	48 8b 44 24 30	 mov	 rax, QWORD PTR bin$[rsp]
  00115	48 99		 cdq
  00117	b9 0a 00 00 00	 mov	 ecx, 10
  0011c	48 f7 f9	 idiv	 rcx
  0011f	48 89 44 24 30	 mov	 QWORD PTR bin$[rsp], rax

; 254  :         }

  00124	e9 59 ff ff ff	 jmp	 $LN2@binary_to_
$LN3@binary_to_:
$LN6@binary_to_:

; 255  :     }
; 256  : 
; 257  : } /* end function(binary_to_packed) */

  00129	48 83 c4 18	 add	 rsp, 24
  0012d	5f		 pop	 rdi
  0012e	5e		 pop	 rsi
  0012f	c3		 ret	 0
binary_to_packed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\decimal.c
_TEXT	SEGMENT
d$ = 0
i$ = 4
h$ = 8
inter_u64max_rem10$ = 12
dreg$ = 16
inter_u64max_div10$ = 24
neg_u64max$ = 32
pos_u64max$ = 40
dec$ = 64
len$ = 72
result$ = 80
ovf$ = 88
dxf$ = 96
packed_to_binary PROC

; 79   : {

$LN26:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 80   : U64     dreg;                           /* 64-bit result accumulator */
; 81   : int     i;                              /* Loop counter              */
; 82   : int     h, d=0;                         /* Decimal digits            */

  00017	c7 04 24 00 00
	00 00		 mov	 DWORD PTR d$[rsp], 0

; 83   : U64     inter_u64max_div10;
; 84   : int     inter_u64max_rem10;
; 85   : U64     pos_u64max = 9223372036854775807ULL;  // (LLONG_MAX)

  0001e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00028	48 89 44 24 28	 mov	 QWORD PTR pos_u64max$[rsp], rax

; 86   : U64     neg_u64max = 9223372036854775808ULL;  // (LLONG_MIN)

  0002d	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00037	48 89 44 24 20	 mov	 QWORD PTR neg_u64max$[rsp], rax

; 87   : 
; 88   :     /* Initialize result flags */
; 89   :     *ovf = 0;

  0003c	48 8b 44 24 58	 mov	 rax, QWORD PTR ovf$[rsp]
  00041	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 90   :     *dxf = 0;

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR dxf$[rsp]
  0004c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 91   : 
; 92   :     /* Initialize 64-bit result accumulator */
; 93   :     dreg = 0;

  00052	48 c7 44 24 10
	00 00 00 00	 mov	 QWORD PTR dreg$[rsp], 0

; 94   : 
; 95   :     /* Initialize max unsigned intermediate value for overflow check */
; 96   :     if ((dec[len] & 0x0F) == 0x0B ||

  0005b	48 63 44 24 48	 movsxd	 rax, DWORD PTR len$[rsp]
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dec$[rsp]
  00065	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00069	83 e0 0f	 and	 eax, 15
  0006c	83 f8 0b	 cmp	 eax, 11
  0006f	74 16		 je	 SHORT $LN7@packed_to_
  00071	48 63 44 24 48	 movsxd	 rax, DWORD PTR len$[rsp]
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dec$[rsp]
  0007b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007f	83 e0 0f	 and	 eax, 15
  00082	83 f8 0d	 cmp	 eax, 13
  00085	75 2c		 jne	 SHORT $LN5@packed_to_
$LN7@packed_to_:

; 97   :         (dec[len] & 0x0F) == 0x0D)
; 98   :     {
; 99   :         inter_u64max_div10 =       (neg_u64max / 10);

  00087	33 d2		 xor	 edx, edx
  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR neg_u64max$[rsp]
  0008e	b9 0a 00 00 00	 mov	 ecx, 10
  00093	48 f7 f1	 div	 rcx
  00096	48 89 44 24 18	 mov	 QWORD PTR inter_u64max_div10$[rsp], rax

; 100  :         inter_u64max_rem10 = (int) (neg_u64max % 10);

  0009b	33 d2		 xor	 edx, edx
  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR neg_u64max$[rsp]
  000a2	b9 0a 00 00 00	 mov	 ecx, 10
  000a7	48 f7 f1	 div	 rcx
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	89 44 24 0c	 mov	 DWORD PTR inter_u64max_rem10$[rsp], eax

; 101  :     }

  000b1	eb 52		 jmp	 SHORT $LN6@packed_to_
$LN5@packed_to_:

; 102  :     else if ((dec[len] & 0x0F) < 0x0A)

  000b3	48 63 44 24 48	 movsxd	 rax, DWORD PTR len$[rsp]
  000b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dec$[rsp]
  000bd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c1	83 e0 0f	 and	 eax, 15
  000c4	83 f8 0a	 cmp	 eax, 10
  000c7	7d 12		 jge	 SHORT $LN8@packed_to_

; 103  :     {
; 104  :         *dxf = 1;

  000c9	48 8b 44 24 60	 mov	 rax, QWORD PTR dxf$[rsp]
  000ce	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 105  :         return;

  000d4	e9 bd 01 00 00	 jmp	 $LN1@packed_to_

; 106  :     }

  000d9	eb 2a		 jmp	 SHORT $LN9@packed_to_
$LN8@packed_to_:

; 107  :     else
; 108  :     {
; 109  :         inter_u64max_div10 =       (pos_u64max / 10);

  000db	33 d2		 xor	 edx, edx
  000dd	48 8b 44 24 28	 mov	 rax, QWORD PTR pos_u64max$[rsp]
  000e2	b9 0a 00 00 00	 mov	 ecx, 10
  000e7	48 f7 f1	 div	 rcx
  000ea	48 89 44 24 18	 mov	 QWORD PTR inter_u64max_div10$[rsp], rax

; 110  :         inter_u64max_rem10 = (int) (pos_u64max % 10);

  000ef	33 d2		 xor	 edx, edx
  000f1	48 8b 44 24 28	 mov	 rax, QWORD PTR pos_u64max$[rsp]
  000f6	b9 0a 00 00 00	 mov	 ecx, 10
  000fb	48 f7 f1	 div	 rcx
  000fe	48 8b c2	 mov	 rax, rdx
  00101	89 44 24 0c	 mov	 DWORD PTR inter_u64max_rem10$[rsp], eax
$LN9@packed_to_:
$LN6@packed_to_:

; 111  :     }
; 112  : 
; 113  :     /* Convert decimal digits to binary */
; 114  :     for (i = 0; i <= len; i++)

  00105	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0010d	eb 0a		 jmp	 SHORT $LN4@packed_to_
$LN2@packed_to_:
  0010f	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00113	ff c0		 inc	 eax
  00115	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@packed_to_:
  00119	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  0011d	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  00121	0f 8f 17 01 00
	00		 jg	 $LN3@packed_to_

; 115  :     {
; 116  :         /* Isolate high-order and low-order digits */
; 117  :         h = (dec[i] & 0xF0) >> 4;

  00127	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0012c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dec$[rsp]
  00131	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00135	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0013a	c1 f8 04	 sar	 eax, 4
  0013d	89 44 24 08	 mov	 DWORD PTR h$[rsp], eax

; 118  :         d = dec[i] & 0x0F;

  00141	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00146	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dec$[rsp]
  0014b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0014f	83 e0 0f	 and	 eax, 15
  00152	89 04 24	 mov	 DWORD PTR d$[rsp], eax

; 119  : 
; 120  :         /* Data exception if high-order digit is invalid */
; 121  :         if (h > 9)

  00155	83 7c 24 08 09	 cmp	 DWORD PTR h$[rsp], 9
  0015a	7e 10		 jle	 SHORT $LN10@packed_to_

; 122  :         {
; 123  :             *dxf = 1;

  0015c	48 8b 44 24 60	 mov	 rax, QWORD PTR dxf$[rsp]
  00161	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 124  :             return;

  00167	e9 2a 01 00 00	 jmp	 $LN1@packed_to_
$LN10@packed_to_:

; 125  :         }
; 126  : 
; 127  :         /* Check for overflow before accumulating */
; 128  :         if ( dreg >  inter_u64max_div10 ||

  0016c	48 8b 44 24 18	 mov	 rax, QWORD PTR inter_u64max_div10$[rsp]
  00171	48 39 44 24 10	 cmp	 QWORD PTR dreg$[rsp], rax
  00176	77 16		 ja	 SHORT $LN12@packed_to_
  00178	48 8b 44 24 18	 mov	 rax, QWORD PTR inter_u64max_div10$[rsp]
  0017d	48 39 44 24 10	 cmp	 QWORD PTR dreg$[rsp], rax
  00182	75 15		 jne	 SHORT $LN11@packed_to_
  00184	8b 44 24 0c	 mov	 eax, DWORD PTR inter_u64max_rem10$[rsp]
  00188	39 44 24 08	 cmp	 DWORD PTR h$[rsp], eax
  0018c	7e 0b		 jle	 SHORT $LN11@packed_to_
$LN12@packed_to_:

; 129  :             (dreg == inter_u64max_div10 &&
; 130  :                 h >  inter_u64max_rem10)) // (NOTE: 'h', not 'd')
; 131  :         {
; 132  :             *ovf = 1;

  0018e	48 8b 44 24 58	 mov	 rax, QWORD PTR ovf$[rsp]
  00193	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN11@packed_to_:

; 133  :         }
; 134  : 
; 135  :         /* Accumulate high-order digit into result */
; 136  :         dreg *= 10;

  00199	48 6b 44 24 10
	0a		 imul	 rax, QWORD PTR dreg$[rsp], 10
  0019f	48 89 44 24 10	 mov	 QWORD PTR dreg$[rsp], rax

; 137  :         dreg += h;

  001a4	48 63 44 24 08	 movsxd	 rax, DWORD PTR h$[rsp]
  001a9	48 8b 4c 24 10	 mov	 rcx, QWORD PTR dreg$[rsp]
  001ae	48 03 c8	 add	 rcx, rax
  001b1	48 8b c1	 mov	 rax, rcx
  001b4	48 89 44 24 10	 mov	 QWORD PTR dreg$[rsp], rax

; 138  : 
; 139  :         /* Check for valid low-order digit or sign */
; 140  :         if (i < len)

  001b9	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  001bd	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  001c1	7d 63		 jge	 SHORT $LN13@packed_to_

; 141  :         {
; 142  :             /* Data exception if low-order digit is invalid */
; 143  :             if (d > 9)

  001c3	83 3c 24 09	 cmp	 DWORD PTR d$[rsp], 9
  001c7	7e 10		 jle	 SHORT $LN15@packed_to_

; 144  :             {
; 145  :                 *dxf = 1;

  001c9	48 8b 44 24 60	 mov	 rax, QWORD PTR dxf$[rsp]
  001ce	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 146  :                 return;

  001d4	e9 bd 00 00 00	 jmp	 $LN1@packed_to_
$LN15@packed_to_:

; 147  :             }
; 148  : 
; 149  :             /* Check for overflow before accumulating */
; 150  :             if ( dreg >  inter_u64max_div10 ||

  001d9	48 8b 44 24 18	 mov	 rax, QWORD PTR inter_u64max_div10$[rsp]
  001de	48 39 44 24 10	 cmp	 QWORD PTR dreg$[rsp], rax
  001e3	77 15		 ja	 SHORT $LN17@packed_to_
  001e5	48 8b 44 24 18	 mov	 rax, QWORD PTR inter_u64max_div10$[rsp]
  001ea	48 39 44 24 10	 cmp	 QWORD PTR dreg$[rsp], rax
  001ef	75 14		 jne	 SHORT $LN16@packed_to_
  001f1	8b 44 24 0c	 mov	 eax, DWORD PTR inter_u64max_rem10$[rsp]
  001f5	39 04 24	 cmp	 DWORD PTR d$[rsp], eax
  001f8	7e 0b		 jle	 SHORT $LN16@packed_to_
$LN17@packed_to_:

; 151  :                 (dreg == inter_u64max_div10 &&
; 152  :                     d >  inter_u64max_rem10)) // (NOTE: 'd', not 'h')
; 153  :             {
; 154  :                 *ovf = 1;

  001fa	48 8b 44 24 58	 mov	 rax, QWORD PTR ovf$[rsp]
  001ff	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN16@packed_to_:

; 155  :             }
; 156  : 
; 157  :             /* Accumulate low-order digit into result */
; 158  :             dreg *= 10;

  00205	48 6b 44 24 10
	0a		 imul	 rax, QWORD PTR dreg$[rsp], 10
  0020b	48 89 44 24 10	 mov	 QWORD PTR dreg$[rsp], rax

; 159  :             dreg += d;

  00210	48 63 04 24	 movsxd	 rax, DWORD PTR d$[rsp]
  00214	48 8b 4c 24 10	 mov	 rcx, QWORD PTR dreg$[rsp]
  00219	48 03 c8	 add	 rcx, rax
  0021c	48 8b c1	 mov	 rax, rcx
  0021f	48 89 44 24 10	 mov	 QWORD PTR dreg$[rsp], rax

; 160  :         }

  00224	eb 13		 jmp	 SHORT $LN14@packed_to_
$LN13@packed_to_:

; 161  :         else
; 162  :         {
; 163  :             /* Data exception if sign is invalid */
; 164  :             if (d < 10)

  00226	83 3c 24 0a	 cmp	 DWORD PTR d$[rsp], 10
  0022a	7d 0d		 jge	 SHORT $LN18@packed_to_

; 165  :             {
; 166  :                 *dxf = 1;

  0022c	48 8b 44 24 60	 mov	 rax, QWORD PTR dxf$[rsp]
  00231	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 167  :                 return;

  00237	eb 5d		 jmp	 SHORT $LN1@packed_to_
$LN18@packed_to_:
$LN14@packed_to_:

; 168  :             }
; 169  :         }
; 170  : 
; 171  :     } /* end for(i) */

  00239	e9 d1 fe ff ff	 jmp	 $LN2@packed_to_
$LN3@packed_to_:

; 172  : 
; 173  :     /* Result is negative if sign is X'B' or X'D' */
; 174  :     if (d == 0x0B || d == 0x0D)

  0023e	83 3c 24 0b	 cmp	 DWORD PTR d$[rsp], 11
  00242	74 06		 je	 SHORT $LN21@packed_to_
  00244	83 3c 24 0d	 cmp	 DWORD PTR d$[rsp], 13
  00248	75 28		 jne	 SHORT $LN19@packed_to_
$LN21@packed_to_:

; 175  :     {
; 176  :         /* Check for UNDERflow (less than min negative) */
; 177  :         if ( dreg > neg_u64max )

  0024a	48 8b 44 24 20	 mov	 rax, QWORD PTR neg_u64max$[rsp]
  0024f	48 39 44 24 10	 cmp	 QWORD PTR dreg$[rsp], rax
  00254	76 0d		 jbe	 SHORT $LN22@packed_to_

; 178  :             *ovf = 1;

  00256	48 8b 44 24 58	 mov	 rax, QWORD PTR ovf$[rsp]
  0025b	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
  00261	eb 0d		 jmp	 SHORT $LN23@packed_to_
$LN22@packed_to_:

; 179  :         else
; 180  :         dreg = -((S64)dreg);

  00263	48 8b 44 24 10	 mov	 rax, QWORD PTR dreg$[rsp]
  00268	48 f7 d8	 neg	 rax
  0026b	48 89 44 24 10	 mov	 QWORD PTR dreg$[rsp], rax
$LN23@packed_to_:

; 181  :     }

  00270	eb 17		 jmp	 SHORT $LN20@packed_to_
$LN19@packed_to_:

; 182  :     else
; 183  :     {
; 184  :         /* Check for OVERflow (greater than max positive) */
; 185  :         if ( dreg > pos_u64max )

  00272	48 8b 44 24 28	 mov	 rax, QWORD PTR pos_u64max$[rsp]
  00277	48 39 44 24 10	 cmp	 QWORD PTR dreg$[rsp], rax
  0027c	76 0b		 jbe	 SHORT $LN24@packed_to_

; 186  :             *ovf = 1;

  0027e	48 8b 44 24 58	 mov	 rax, QWORD PTR ovf$[rsp]
  00283	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN24@packed_to_:
$LN20@packed_to_:

; 187  :     }
; 188  : 
; 189  :     /* Set result field and return */
; 190  :     *result = dreg;

  00289	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0028e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR dreg$[rsp]
  00293	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@packed_to_:

; 191  : 
; 192  : } /* end function packed_to_binary */

  00296	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0029a	c3		 ret	 0
packed_to_binary ENDP
_TEXT	ENDS
END
