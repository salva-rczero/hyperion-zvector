; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s390_page_in
PUBLIC	s390_page_out
PUBLIC	s390_move_page
PUBLIC	s390_invalidate_expanded_storage_block_entry
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key_by_ptr
PUBLIC	s390_maddr_l
PUBLIC	z900_page_in
PUBLIC	z900_page_out
PUBLIC	z900_move_page
PUBLIC	z900_invalidate_expanded_storage_block_entry
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key_by_ptr
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_check
PUBLIC	z900_per3_zero_check2
PUBLIC	z900_maddr_l
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	apply_host_prefixing:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	s390_translate_addr:PROC
EXTRN	z900_translate_addr:PROC
EXTRN	s390_invalidate_pte:PROC
EXTRN	z900_invalidate_pte:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$synchronize_cpus DD imagerel synchronize_cpus
	DD	imagerel synchronize_cpus+583
	DD	imagerel $unwind$synchronize_cpus
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
pdata	SEGMENT
$pdata$s390_page_in DD imagerel $LN21
	DD	imagerel $LN21+914
	DD	imagerel $unwind$s390_page_in
$pdata$s390_page_out DD imagerel $LN21
	DD	imagerel $LN21+914
	DD	imagerel $unwind$s390_page_out
$pdata$s390_move_page DD imagerel $LN87
	DD	imagerel $LN87+4560
	DD	imagerel $unwind$s390_move_page
$pdata$s390_invalidate_expanded_storage_block_entry DD imagerel $LN13
	DD	imagerel $LN13+389
	DD	imagerel $unwind$s390_invalidate_expanded_storage_block_entry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key_by_ptr DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$s390_or_storage_key_by_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
pdata	SEGMENT
$pdata$z900_page_in DD imagerel $LN24
	DD	imagerel $LN24+946
	DD	imagerel $unwind$z900_page_in
$pdata$z900_page_out DD imagerel $LN24
	DD	imagerel $LN24+946
	DD	imagerel $unwind$z900_page_out
$pdata$z900_move_page DD imagerel $LN79
	DD	imagerel $LN79+4141
	DD	imagerel $unwind$z900_move_page
$pdata$z900_invalidate_expanded_storage_block_entry DD imagerel $LN17
	DD	imagerel $LN17+465
	DD	imagerel $unwind$z900_invalidate_expanded_storage_block_entry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key_by_ptr DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$z900_or_storage_key_by_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_check DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$z900_per3_zero_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_check2 DD imagerel $LN9
	DD	imagerel $LN9+189
	DD	imagerel $unwind$z900_per3_zero_check2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
_DATA	SEGMENT
$SG179597 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:62', 00H
	ORG $+1
$SG179598 DB	'*PGIN', 00H
	ORG $+6
$SG179601 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:72', 00H
	ORG $+1
$SG179602 DB	'*PGIN', 00H
	ORG $+6
$SG179645 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:129', 00H
$SG179646 DB	'*PGOUT', 00H
	ORG $+5
$SG179649 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:139', 00H
$SG179650 DB	'*PGOUT', 00H
	ORG $+5
$SG179670 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:181', 00H
	ORG $+4
$SG179671 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:183', 00H
	ORG $+4
$SG179672 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:188', 00H
	ORG $+4
$SG179789 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:584', 00H
$SG179790 DB	'*MVPG', 00H
	ORG $+6
$SG192729 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:42', 00H
	ORG $+5
$SG192735 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:62', 00H
	ORG $+1
$SG192736 DB	'*PGIN', 00H
	ORG $+6
$SG192739 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:72', 00H
	ORG $+1
$SG192740 DB	'*PGIN', 00H
	ORG $+6
$SG192781 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:109', 00H
	ORG $+4
$SG192787 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:129', 00H
$SG192788 DB	'*PGOUT', 00H
	ORG $+5
$SG192791 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:139', 00H
$SG192792 DB	'*PGOUT', 00H
	ORG $+5
$SG192813 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:171', 00H
	ORG $+4
$SG192817 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:181', 00H
	ORG $+4
$SG192818 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:183', 00H
	ORG $+4
$SG192819 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:188', 00H
	ORG $+4
$SG192879 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:225', 00H
	ORG $+4
$SG192937 DB	'C:\papa\MyGit\hyperion-zvector\xstore.c:584', 00H
$SG192938 DB	'*MVPG', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_check2 DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_check DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key_by_ptr DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key_by_ptr DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
xdata	SEGMENT
$unwind$synchronize_cpus DD 010e01H
	DD	0a20eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$s390_page_in DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$s390_page_out DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$s390_move_page DD 041301H
	DD	01f0113H
	DD	0600b700cH
$unwind$s390_invalidate_expanded_storage_block_entry DD 010e01H
	DD	0a20eH
$unwind$z900_page_in DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$z900_page_out DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$z900_move_page DD 041301H
	DD	01d0113H
	DD	0600b700cH
$unwind$z900_invalidate_expanded_storage_block_entry DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_check2
_TEXT	SEGMENT
tv79 = 32
tv95 = 40
regs$ = 64
r1$ = 72
r2$ = 80
z900_per3_zero_check2 PROC				; COMDAT

; 640  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 642  :     if (0
; 643  :         || GR_A( r1, regs ) == 0
; 644  :         || GR_A( r2, regs ) == 0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 92 00 00
	00		 jne	 $LN3@z900_per3_
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 19		 je	 SHORT $LN5@z900_per3_
  0002e	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00040	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  00045	eb 16		 jmp	 SHORT $LN6@z900_per3_
$LN5@z900_per3_:
  00047	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00058	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN6@z900_per3_:
  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  00063	74 49		 je	 SHORT $LN3@z900_per3_
  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	74 19		 je	 SHORT $LN7@z900_per3_
  00077	48 63 44 24 50	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00089	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
  0008e	eb 16		 jmp	 SHORT $LN8@z900_per3_
$LN7@z900_per3_:
  00090	48 63 44 24 50	 movsxd	 rax, DWORD PTR r2$[rsp]
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a1	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
$LN8@z900_per3_:
  000a6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv95[rsp], 0
  000ac	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN3@z900_per3_:

; 645  :     )
; 646  :         ARCH_DEP( per3_zero )( regs );

  000ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 647  : #else
; 648  :     UNREFERENCED( regs );
; 649  :     UNREFERENCED( r1 );
; 650  :     UNREFERENCED( r2 );
; 651  : #endif
; 652  : }

  000b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bc	c3		 ret	 0
z900_per3_zero_check2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_check
_TEXT	SEGMENT
tv78 = 32
regs$ = 64
r1$ = 72
z900_per3_zero_check PROC				; COMDAT

; 629  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 630  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 631  :     if (GR_A( r1, regs ) == 0)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 19		 je	 SHORT $LN4@z900_per3_
  0001f	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00029	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00031	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  00036	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  00038	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00049	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
$LN5@z900_per3_:
  0004e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv78[rsp], 0
  00054	75 0a		 jne	 SHORT $LN2@z900_per3_

; 632  :         ARCH_DEP( per3_zero )( regs );

  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 633  : #else
; 634  :     UNREFERENCED( regs );
; 635  :     UNREFERENCED( r1 );
; 636  : #endif
; 637  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
z900_per3_zero_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key_by_ptr
_TEXT	SEGMENT
abs$ = 32
skey_ptr$ = 64
bits$ = 72
z900_or_storage_key_by_ptr PROC				; COMDAT

; 328  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 329  :     U64 abs = (skey_ptr - sysblk.storkeys) << _STORKEY_ARRAY_SHIFTAMT;

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR skey_ptr$[rsp]
  00020	48 2b c8	 sub	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 c1 e0 0b	 shl	 rax, 11
  0002a	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 330  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 331  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 332  : #else
; 333  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0002f	0f b6 54 24 48	 movzx	 edx, BYTE PTR bits$[rsp]
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00039	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 334  : #endif
; 335  : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
z900_or_storage_key_by_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\xstore.c
_TEXT	SEGMENT
i$1 = 48
r2$ = 52
r1$ = 56
tv163 = 64
inst$ = 96
regs$ = 104
z900_invalidate_expanded_storage_block_entry PROC

; 166  : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 167  : int     r1, r2;                         /* Operand register numbers  */
; 168  : 
; 169  :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_inval:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN11@z900_inval
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_inval:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_inval
$LN7@z900_inval:

; 170  : 
; 171  :     TXF_INSTR_CHECK( regs );

  0006c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00078	85 c0		 test	 eax, eax
  0007a	74 36		 je	 SHORT $LN12@z900_inval
  0007c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00087	0f ba e8 0c	 bts	 eax, 12
  0008b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192813
  0009d	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000a3	ba 02 00 00 00	 mov	 edx, 2
  000a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_inval:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 b4		 jne	 SHORT $LN7@z900_inval

; 172  :     PRIV_CHECK( regs );

  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000c1	83 e0 01	 and	 eax, 1
  000c4	85 c0		 test	 eax, eax
  000c6	74 15		 je	 SHORT $LN13@z900_inval
  000c8	ba 02 00 00 00	 mov	 edx, 2
  000cd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_inval:

; 173  : 
; 174  : #if defined( _FEATURE_SIE )
; 175  :     if (SIE_STATE_BIT_OFF( regs, EC0, MVPG ))

  000dd	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e8	d1 e8		 shr	 eax, 1
  000ea	83 e0 01	 and	 eax, 1
  000ed	85 c0		 test	 eax, eax
  000ef	74 53		 je	 SHORT $LN14@z900_inval
  000f1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000fd	b9 01 00 00 00	 mov	 ecx, 1
  00102	48 6b c9 00	 imul	 rcx, rcx, 0
  00106	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  0010b	83 e0 01	 and	 eax, 1
  0010e	85 c0		 test	 eax, eax
  00110	75 32		 jne	 SHORT $LN14@z900_inval
$LN10@z900_inval:

; 176  :         SIE_INTERCEPT( regs );

  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00117	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011d	d1 e8		 shr	 eax, 1
  0011f	83 e0 01	 and	 eax, 1
  00122	85 c0		 test	 eax, eax
  00124	74 18		 je	 SHORT $LN15@z900_inval
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00131	ba fc ff ff ff	 mov	 edx, -4
  00136	48 8b c8	 mov	 rcx, rax
  00139	e8 00 00 00 00	 call	 longjmp
$LN15@z900_inval:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	75 ce		 jne	 SHORT $LN10@z900_inval
$LN14@z900_inval:

; 177  : #endif
; 178  : 
; 179  :     PERFORM_SERIALIZATION( regs );

  00144	0f ae f0	 mfence

; 180  :     {
; 181  :         OBTAIN_INTLOCK( regs );

  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192817
  0014e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 182  :         {
; 183  :             SYNCHRONIZE_CPUS( regs );

  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192818
  0015f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00164	e8 00 00 00 00	 call	 synchronize_cpus

; 184  : 
; 185  :             /* Invalidate page table entry */
; 186  :             ARCH_DEP( invalidate_pte )( inst[1], regs->GR_G( r1 ), regs->GR( r2 ), regs, false );

  00169	48 63 44 24 34	 movsxd	 rax, DWORD PTR r2$[rsp]
  0016e	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00173	ba 01 00 00 00	 mov	 edx, 1
  00178	48 6b d2 01	 imul	 rdx, rdx, 1
  0017c	48 89 54 24 40	 mov	 QWORD PTR tv163[rsp], rdx
  00181	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00186	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0018b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00190	4d 8b 84 c0 80
	02 00 00	 mov	 r8, QWORD PTR [r8+rax*8+640]
  00198	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0019d	48 8b 94 c8 80
	02 00 00	 mov	 rdx, QWORD PTR [rax+rcx*8+640]
  001a5	48 8b 44 24 60	 mov	 rax, QWORD PTR inst$[rsp]
  001aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv163[rsp]
  001af	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  001b3	e8 00 00 00 00	 call	 z900_invalidate_pte

; 187  :         }
; 188  :         RELEASE_INTLOCK( regs );

  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192819
  001bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001c4	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 189  :     }
; 190  :     PERFORM_SERIALIZATION( regs );

  001c9	0f ae f0	 mfence
$LN16@z900_inval:

; 191  : 
; 192  : } /* end DEF_INST( invalidate_expanded_storage_block_entry ) */

  001cc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d0	c3		 ret	 0
z900_invalidate_expanded_storage_block_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\xstore.c
_TEXT	SEGMENT
akey2$ = 64
akey1$ = 65
akey$ = 66
xpkey1$ = 67
xpkey2$ = 68
rc$ = 72
cc$ = 76
xpvalid1$ = 80
r1$ = 84
r2$ = 88
xpvalid2$ = 92
xpblk2$ = 96
xpblk1$ = 100
raddr2$ = 104
raddr1$ = 112
pte1$ = 120
vaddr1$ = 128
vaddr2$ = 136
pte2$ = 144
i$1 = 152
tv413 = 156
xpkeya$ = 160
main2$ = 168
sk1$ = 176
main1$ = 184
tv235 = 192
tv327 = 200
tv609 = 208
tv602 = 216
inst$ = 256
regs$ = 264
z900_move_page PROC

; 206  : {

$LN79:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 207  : int     r1, r2;                         /* Register values           */
; 208  : int     rc = 0;                         /* Return code               */

  00013	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 209  : int     cc = 0;                         /* Condition code            */

  0001b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 210  : VADR    vaddr1, vaddr2;                 /* Virtual addresses         */
; 211  : RADR    raddr1=0, raddr2=0, xpkeya;     /* Real addresses            */

  00023	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR raddr1$[rsp], 0
  0002c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR raddr2$[rsp], 0

; 212  : BYTE   *main1 = NULL, *main2 = NULL;    /* Mainstor addresses        */

  00035	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR main1$[rsp], 0
  00041	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR main2$[rsp], 0

; 213  : BYTE   *sk1;                            /* Storage key address       */
; 214  : BYTE    akey;                           /* Access key in register 0  */
; 215  : BYTE    akey1, akey2;                   /* Access keys for operands  */
; 216  : #if defined(FEATURE_EXPANDED_STORAGE)
; 217  : int     xpvalid1 = 0, xpvalid2 = 0;     /* 1=Operand in expanded stg */

  0004d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR xpvalid1$[rsp], 0
  00055	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR xpvalid2$[rsp], 0

; 218  : CREG    pte1 = 0, pte2 = 0;             /* Page table entry          */

  0005d	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pte1$[rsp], 0
  00066	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pte2$[rsp], 0

; 219  : U32     xpblk1 = 0, xpblk2 = 0;         /* Expanded storage block#   */

  00072	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR xpblk1$[rsp], 0
  0007a	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR xpblk2$[rsp], 0

; 220  : BYTE    xpkey1 = 0, xpkey2 = 0;         /* Expanded storage keys     */

  00082	c6 44 24 43 00	 mov	 BYTE PTR xpkey1$[rsp], 0
  00087	c6 44 24 44 00	 mov	 BYTE PTR xpkey2$[rsp], 0

; 221  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 222  : 
; 223  :     RRE(inst, regs, r1, r2);

  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 03	 imul	 rax, rax, 3
  00095	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0009d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a1	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
  000a8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  000af	83 e0 0f	 and	 eax, 15
  000b2	89 44 24 58	 mov	 DWORD PTR r2$[rsp], eax
  000b6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  000bd	c1 f8 04	 sar	 eax, 4
  000c0	83 e0 0f	 and	 eax, 15
  000c3	89 44 24 54	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_move_:
  000c7	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d3	48 83 c0 04	 add	 rax, 4
  000d7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e3	33 c0		 xor	 eax, eax
  000e5	83 f8 04	 cmp	 eax, 4
  000e8	74 0f		 je	 SHORT $LN11@z900_move_
  000ea	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_move_:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 c8		 jne	 SHORT $LN4@z900_move_

; 224  :     PER_ZEROADDR_CHECK2( regs, r1, r2 );

  000ff	44 8b 44 24 58	 mov	 r8d, DWORD PTR r2$[rsp]
  00104	8b 54 24 54	 mov	 edx, DWORD PTR r1$[rsp]
  00108	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 z900_per3_zero_check2
$LN7@z900_move_:

; 225  :     TXF_INSTR_CHECK( regs );

  00115	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00124	85 c0		 test	 eax, eax
  00126	74 3f		 je	 SHORT $LN12@z900_move_
  00128	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00130	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00136	0f ba e8 0c	 bts	 eax, 12
  0013a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00142	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00148	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192879
  0014f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00155	ba 02 00 00 00	 mov	 edx, 2
  0015a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_move_:
  00167	33 c0		 xor	 eax, eax
  00169	85 c0		 test	 eax, eax
  0016b	75 a8		 jne	 SHORT $LN7@z900_move_

; 226  : 
; 227  : #if defined(_FEATURE_SIE)
; 228  :     if(SIE_STATE_BIT_OFF(regs, EC0, MVPG))

  0016d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00175	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017b	d1 e8		 shr	 eax, 1
  0017d	83 e0 01	 and	 eax, 1
  00180	85 c0		 test	 eax, eax
  00182	74 3f		 je	 SHORT $LN13@z900_move_
  00184	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00193	b9 01 00 00 00	 mov	 ecx, 1
  00198	48 6b c9 00	 imul	 rcx, rcx, 0
  0019c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  001a1	83 e0 01	 and	 eax, 1
  001a4	85 c0		 test	 eax, eax
  001a6	75 1b		 jne	 SHORT $LN13@z900_move_

; 229  :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  001a8	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001b6	ba fc ff ff ff	 mov	 edx, -4
  001bb	48 8b c8	 mov	 rcx, rax
  001be	e8 00 00 00 00	 call	 longjmp
$LN13@z900_move_:

; 230  : #endif /*defined(_FEATURE_SIE)*/
; 231  : 
; 232  :     /* Use PSW key as access key for both operands */
; 233  :     akey1 = akey2 = regs->psw.pkey;

  001c3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001cf	88 44 24 40	 mov	 BYTE PTR akey2$[rsp], al
  001d3	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey2$[rsp]
  001d8	88 44 24 41	 mov	 BYTE PTR akey1$[rsp], al

; 234  : 
; 235  :     /* If register 0 bit 20 or 21 is one, get access key from R0 */
; 236  :     if (regs->GR_L(0) & (GR0_MVPG_FIRST | GR0_MVPG_SECOND))

  001dc	b8 08 00 00 00	 mov	 eax, 8
  001e1	48 6b c0 00	 imul	 rax, rax, 0
  001e5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001f4	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  001f9	85 c0		 test	 eax, eax
  001fb	0f 84 d4 00 00
	00		 je	 $LN14@z900_move_

; 237  :     {
; 238  :         /* Extract the access key from register 0 bits 24-27 */
; 239  :         akey = regs->GR_L(0) & GR0_MVPG_KEY;

  00201	b8 08 00 00 00	 mov	 eax, 8
  00206	48 6b c0 00	 imul	 rax, rax, 0
  0020a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00219	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0021e	88 44 24 42	 mov	 BYTE PTR akey$[rsp], al

; 240  : 
; 241  :         /* Priviliged operation exception if in problem state, and
; 242  :            the specified key is not permitted by the PSW key mask */
; 243  :         if ( PROBSTATE(&regs->psw)
; 244  :             && ((regs->CR(3) << (akey >> 4)) & 0x80000000) == 0 )

  00222	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0022e	83 e0 01	 and	 eax, 1
  00231	85 c0		 test	 eax, eax
  00233	74 4c		 je	 SHORT $LN15@z900_move_
  00235	b8 08 00 00 00	 mov	 eax, 8
  0023a	48 6b c0 04	 imul	 rax, rax, 4
  0023e	0f b6 4c 24 42	 movzx	 ecx, BYTE PTR akey$[rsp]
  00243	c1 f9 04	 sar	 ecx, 4
  00246	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0024e	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  00256	48 d3 e0	 shl	 rax, cl
  00259	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0025e	48 23 c1	 and	 rax, rcx
  00261	48 85 c0	 test	 rax, rax
  00264	75 1b		 jne	 SHORT $LN15@z900_move_

; 245  :             regs->program_interrupt (regs, PGM_PRIVILEGED_OPERATION_EXCEPTION);

  00266	ba 02 00 00 00	 mov	 edx, 2
  0026b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_move_:

; 246  : 
; 247  :         /* If register 0 bit 20 is one, use R0 key for operand 1 */
; 248  :         if (regs->GR_L(0) & GR0_MVPG_FIRST)

  00281	b8 08 00 00 00	 mov	 eax, 8
  00286	48 6b c0 00	 imul	 rax, rax, 0
  0028a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00292	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00299	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0029e	85 c0		 test	 eax, eax
  002a0	74 09		 je	 SHORT $LN16@z900_move_

; 249  :             akey1 = akey;

  002a2	0f b6 44 24 42	 movzx	 eax, BYTE PTR akey$[rsp]
  002a7	88 44 24 41	 mov	 BYTE PTR akey1$[rsp], al
$LN16@z900_move_:

; 250  : 
; 251  :         /* If register 0 bit 21 is one, use R0 key for operand 2 */
; 252  :         if (regs->GR_L(0) & GR0_MVPG_SECOND)

  002ab	b8 08 00 00 00	 mov	 eax, 8
  002b0	48 6b c0 00	 imul	 rax, rax, 0
  002b4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002c3	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  002c8	85 c0		 test	 eax, eax
  002ca	74 09		 je	 SHORT $LN17@z900_move_

; 253  :             akey2 = akey;

  002cc	0f b6 44 24 42	 movzx	 eax, BYTE PTR akey$[rsp]
  002d1	88 44 24 40	 mov	 BYTE PTR akey2$[rsp], al
$LN17@z900_move_:
$LN14@z900_move_:

; 254  :     }
; 255  : 
; 256  :     /* Specification exception if register 0 bits 16-19 are
; 257  :        not all zero, or if bits 20 and 21 are both ones */
; 258  :     if ((regs->GR_L(0) & GR0_MVPG_RSRVD) != 0
; 259  :         || (regs->GR_L(0) & (GR0_MVPG_FIRST | GR0_MVPG_SECOND))

  002d5	b8 08 00 00 00	 mov	 eax, 8
  002da	48 6b c0 00	 imul	 rax, rax, 0
  002de	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002ed	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  002f2	85 c0		 test	 eax, eax
  002f4	75 24		 jne	 SHORT $LN19@z900_move_
  002f6	b8 08 00 00 00	 mov	 eax, 8
  002fb	48 6b c0 00	 imul	 rax, rax, 0
  002ff	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00307	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0030e	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  00313	3d 00 0c 00 00	 cmp	 eax, 3072		; 00000c00H
  00318	75 1b		 jne	 SHORT $LN18@z900_move_
$LN19@z900_move_:

; 260  :                          == (GR0_MVPG_FIRST | GR0_MVPG_SECOND))
; 261  :         regs->program_interrupt (regs, PGM_SPECIFICATION_EXCEPTION);

  0031a	ba 06 00 00 00	 mov	 edx, 6
  0031f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00327	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN18@z900_move_:

; 262  : 
; 263  :     /* Determine the logical addresses of each operand */
; 264  :     vaddr1 = regs->GR(r1) & ADDRESS_MAXWRAP(regs);

  00335	48 63 44 24 54	 movsxd	 rax, DWORD PTR r1$[rsp]
  0033a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00342	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0034a	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00351	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00359	48 23 c2	 and	 rax, rdx
  0035c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR vaddr1$[rsp], rax

; 265  :     vaddr2 = regs->GR(r2) & ADDRESS_MAXWRAP(regs);

  00364	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  00369	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00371	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00379	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00380	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00388	48 23 c2	 and	 rax, rdx
  0038b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR vaddr2$[rsp], rax

; 266  : 
; 267  :     /* Isolate the page addresses of each operand */
; 268  :     vaddr1 &= XSTORE_PAGEMASK;

  00393	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR vaddr1$[rsp]
  0039b	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  003a1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR vaddr1$[rsp], rax

; 269  :     vaddr2 &= XSTORE_PAGEMASK;

  003a9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR vaddr2$[rsp]
  003b1	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  003b7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR vaddr2$[rsp], rax

; 270  : 
; 271  :     /* Obtain the real or expanded address of each operand */
; 272  :     if ( !REAL_MODE(&regs->psw) || SIE_MODE(regs) )

  003bf	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c7	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  003cb	83 e0 04	 and	 eax, 4
  003ce	85 c0		 test	 eax, eax
  003d0	75 1b		 jne	 SHORT $LN21@z900_move_
  003d2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003da	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003e0	d1 e8		 shr	 eax, 1
  003e2	83 e0 01	 and	 eax, 1
  003e5	85 c0		 test	 eax, eax
  003e7	0f 84 41 07 00
	00		 je	 $LN20@z900_move_
$LN21@z900_move_:

; 273  :     {
; 274  :         /* Translate the second operand address to a real address */
; 275  :         if(!REAL_MODE(&regs->psw))

  003ed	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f5	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  003f9	83 e0 04	 and	 eax, 4
  003fc	85 c0		 test	 eax, eax
  003fe	74 39		 je	 SHORT $LN22@z900_move_

; 276  :         {
; 277  :             rc = ARCH_DEP(translate_addr) (vaddr2, r2, regs, ACCTYPE_READ);

  00400	41 b9 04 00 00
	00		 mov	 r9d, 4
  00406	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0040e	8b 54 24 58	 mov	 edx, DWORD PTR r2$[rsp]
  00412	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR vaddr2$[rsp]
  0041a	e8 00 00 00 00	 call	 z900_translate_addr
  0041f	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 278  :             raddr2 = regs->dat.raddr;

  00423	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042b	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  00432	48 89 44 24 68	 mov	 QWORD PTR raddr2$[rsp], rax

; 279  :         }

  00437	eb 0d		 jmp	 SHORT $LN23@z900_move_
$LN22@z900_move_:

; 280  :         else
; 281  :             raddr2 = vaddr2;

  00439	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR vaddr2$[rsp]
  00441	48 89 44 24 68	 mov	 QWORD PTR raddr2$[rsp], rax
$LN23@z900_move_:

; 282  : 
; 283  :         if(rc != 0 && rc != 2)

  00446	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  0044b	74 0c		 je	 SHORT $LN24@z900_move_
  0044d	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  00452	74 05		 je	 SHORT $LN24@z900_move_

; 284  :             goto mvpg_progck;

  00454	e9 81 0a 00 00	 jmp	 $mvpg_progck$80
$LN24@z900_move_:

; 285  : 
; 286  :         raddr2 = APPLY_PREFIXING (raddr2, regs->PX);

  00459	48 8b 44 24 68	 mov	 rax, QWORD PTR raddr2$[rsp]
  0045e	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00464	48 85 c0	 test	 rax, rax
  00467	74 28		 je	 SHORT $LN73@z900_move_
  00469	48 8b 44 24 68	 mov	 rax, QWORD PTR raddr2$[rsp]
  0046e	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00474	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047c	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00480	74 0f		 je	 SHORT $LN73@z900_move_
  00482	48 8b 44 24 68	 mov	 rax, QWORD PTR raddr2$[rsp]
  00487	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv235[rsp], rax
  0048f	eb 1f		 jmp	 SHORT $LN74@z900_move_
$LN73@z900_move_:
  00491	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00499	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0049d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR raddr2$[rsp]
  004a2	48 33 c8	 xor	 rcx, rax
  004a5	48 8b c1	 mov	 rax, rcx
  004a8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv235[rsp], rax
$LN74@z900_move_:
  004b0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv235[rsp]
  004b8	48 89 44 24 68	 mov	 QWORD PTR raddr2$[rsp], rax

; 287  : 
; 288  :         if (raddr2 > regs->mainlim)

  004bd	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c5	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  004cc	48 39 44 24 68	 cmp	 QWORD PTR raddr2$[rsp], rax
  004d1	76 1b		 jbe	 SHORT $LN25@z900_move_

; 289  :             regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  004d3	ba 05 00 00 00	 mov	 edx, 5
  004d8	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e0	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@z900_move_:

; 290  : 
; 291  : #if defined(_FEATURE_SIE)
; 292  :         if(SIE_MODE(regs)  && !regs->sie_pref)

  004ee	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004fc	d1 e8		 shr	 eax, 1
  004fe	83 e0 01	 and	 eax, 1
  00501	85 c0		 test	 eax, eax
  00503	0f 84 ce 00 00
	00		 je	 $LN26@z900_move_
  00509	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00511	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00517	c1 e8 02	 shr	 eax, 2
  0051a	83 e0 01	 and	 eax, 1
  0051d	85 c0		 test	 eax, eax
  0051f	0f 85 b2 00 00
	00		 jne	 $LN26@z900_move_

; 293  :         {
; 294  : #if defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)
; 295  :             if (SIE_TRANSLATE_ADDR (regs->sie_mso + raddr2,
; 296  :                 (SIE_STATE_BIT_ON(regs, MX, XC) && AR_BIT(&regs->psw) && r2 > 0)
; 297  :                 ? r2 : USE_PRIMARY_SPACE, HOSTREGS, ACCTYPE_SIE))
; 298  : #else /*!defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 299  :             if (SIE_TRANSLATE_ADDR (regs->sie_mso + raddr2,

  00525	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052d	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00534	48 03 44 24 68	 add	 rax, QWORD PTR raddr2$[rsp]
  00539	45 33 c9	 xor	 r9d, r9d
  0053c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00544	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0054b	ba fd ff ff ff	 mov	 edx, -3
  00550	48 8b c8	 mov	 rcx, rax
  00553	e8 00 00 00 00	 call	 z900_translate_addr
  00558	85 c0		 test	 eax, eax
  0055a	74 4c		 je	 SHORT $LN27@z900_move_

; 300  :                     USE_PRIMARY_SPACE, HOSTREGS, ACCTYPE_SIE))
; 301  : #endif /*!defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 302  :                 (HOSTREGS->program_interrupt) (HOSTREGS, HOSTREGS->dat.xcode);

  0055c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00564	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0056b	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00572	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057a	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00581	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR tv609[rsp], rcx
  00589	8b d0		 mov	 edx, eax
  0058b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00593	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0059a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv609[rsp]
  005a2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN27@z900_move_:

; 303  : 
; 304  :             /* Convert host real address to host absolute address */
; 305  :             raddr2 = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );

  005a8	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  005b7	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  005be	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c6	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  005cd	e8 00 00 00 00	 call	 apply_host_prefixing
  005d2	48 89 44 24 68	 mov	 QWORD PTR raddr2$[rsp], rax
$LN26@z900_move_:

; 306  :         } /* SIE_MODE */
; 307  : #endif /*defined(_FEATURE_SIE)*/
; 308  : 
; 309  : #if defined(FEATURE_EXPANDED_STORAGE)
; 310  :         if(rc == 2)

  005d7	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  005dc	0f 85 2e 01 00
	00		 jne	 $LN28@z900_move_

; 311  :         {
; 312  :             FETCH_W(pte2,regs->mainstor + raddr2);

  005e2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ea	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  005f1	48 03 44 24 68	 add	 rax, QWORD PTR raddr2$[rsp]
  005f6	48 8b c8	 mov	 rcx, rax
  005f9	e8 00 00 00 00	 call	 fetch_dw_noswap
  005fe	48 8b c8	 mov	 rcx, rax
  00601	e8 00 00 00 00	 call	 _byteswap_uint64
  00606	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pte2$[rsp], rax

; 313  :             /* If page is invalid in real storage but valid in expanded
; 314  :                storage then xpblk2 now contains expanded storage block# */
; 315  :             if(pte2 & PAGETAB_ESVALID)

  0060e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pte2$[rsp]
  00616	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  0061c	48 85 c0	 test	 rax, rax
  0061f	0f 84 de 00 00
	00		 je	 $LN29@z900_move_

; 316  :             {
; 317  :                 xpblk2 = (pte2 & ZPGETAB_PFRA) >> 12;

  00625	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pte2$[rsp]
  0062d	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00633	48 c1 e8 0c	 shr	 rax, 12
  00637	89 44 24 60	 mov	 DWORD PTR xpblk2$[rsp], eax

; 318  : #if defined(_FEATURE_SIE)
; 319  :                 if(SIE_MODE(regs))

  0063b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00643	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00649	d1 e8		 shr	 eax, 1
  0064b	83 e0 01	 and	 eax, 1
  0064e	85 c0		 test	 eax, eax
  00650	74 39		 je	 SHORT $LN31@z900_move_

; 320  :                 {
; 321  :                     /* Add expanded storage origin for this guest */
; 322  :                     xpblk2 += regs->sie_xso;

  00652	8b 44 24 60	 mov	 eax, DWORD PTR xpblk2$[rsp]
  00656	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0065e	48 03 81 a0 08
	00 00		 add	 rax, QWORD PTR [rcx+2208]
  00665	89 44 24 60	 mov	 DWORD PTR xpblk2$[rsp], eax

; 323  :                     /* If the block lies beyond this guests limit
; 324  :                        then we must terminate the instruction */
; 325  :                     if(xpblk2 >= regs->sie_xsl)

  00669	8b 44 24 60	 mov	 eax, DWORD PTR xpblk2$[rsp]
  0066d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00675	48 3b 81 a8 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2216]
  0067c	72 0d		 jb	 SHORT $LN32@z900_move_

; 326  :                     {
; 327  :                         cc = 2;

  0067e	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 328  :                         goto mvpg_progck;

  00686	e9 4f 08 00 00	 jmp	 $mvpg_progck$80
$LN32@z900_move_:
$LN31@z900_move_:

; 329  :                     }
; 330  :                 } /* SIE_MODE */
; 331  : #endif /*defined(_FEATURE_SIE)*/
; 332  : 
; 333  :                 rc = 0;

  0068b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 334  :                 xpvalid2 = 1;

  00693	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR xpvalid2$[rsp], 1

; 335  :                 xpkeya = raddr2 +

  0069b	48 8b 44 24 68	 mov	 rax, QWORD PTR raddr2$[rsp]
  006a0	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  006a6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR xpkeya$[rsp], rax

; 336  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 337  :                                    2048;
; 338  : #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 339  :                 /* For ESA/390 mode, the XPTE lies directly beyond
; 340  :                    the PTE, and each entry is 12 bytes long, we must
; 341  :                    therefor add 1024 + 8 times the page index */
; 342  :                                  1024 + ((vaddr2 & 0x000FF000) >> 9);
; 343  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 344  :                 if (xpkeya > regs->mainlim)

  006ae	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b6	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  006bd	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR xpkeya$[rsp], rax
  006c5	76 1b		 jbe	 SHORT $LN33@z900_move_

; 345  :                     regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  006c7	ba 05 00 00 00	 mov	 edx, 5
  006cc	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006d4	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006dc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN33@z900_move_:

; 346  :                 xpkey2 = regs->mainstor[xpkeya];

  006e2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ea	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  006f1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR xpkeya$[rsp]
  006f9	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  006fd	88 44 24 44	 mov	 BYTE PTR xpkey2$[rsp], al

; 347  : 
; 348  : /*DEBUG logmsg("MVPG pte2 = " F_CREG ", xkey2 = %2.2X, xpblk2 = %5.5X, akey2 = %2.2X\n",
; 349  :                   pte2,xpkey2,xpblk2,akey2);  */
; 350  :             }

  00701	eb 0d		 jmp	 SHORT $LN30@z900_move_
$LN29@z900_move_:

; 351  :             else
; 352  :             {
; 353  :                 cc = 2;

  00703	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 354  :                 goto mvpg_progck;

  0070b	e9 ca 07 00 00	 jmp	 $mvpg_progck$80
$LN30@z900_move_:
$LN28@z900_move_:

; 355  :             }
; 356  :         }
; 357  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 358  : 
; 359  :         /* Program check if second operand is not valid
; 360  :            in either main storage or expanded storage */
; 361  :         if (rc)

  00710	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00715	74 0d		 je	 SHORT $LN34@z900_move_

; 362  :         {
; 363  :             cc = 2;

  00717	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 364  :             goto mvpg_progck;

  0071f	e9 b6 07 00 00	 jmp	 $mvpg_progck$80
$LN34@z900_move_:

; 365  :         }
; 366  : 
; 367  :         /* Reset protection indication before calling translate_addr() */
; 368  :         regs->dat.protect = 0;

  00724	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072c	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00732	83 e0 f9	 and	 eax, -7			; fffffff9H
  00735	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0073d	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 369  :         /* Translate the first operand address to a real address */
; 370  :         if(!REAL_MODE(&regs->psw))

  00743	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0074f	83 e0 04	 and	 eax, 4
  00752	85 c0		 test	 eax, eax
  00754	74 39		 je	 SHORT $LN35@z900_move_

; 371  :         {
; 372  :             rc = ARCH_DEP(translate_addr) (vaddr1, r1, regs, ACCTYPE_WRITE);

  00756	41 b9 02 00 00
	00		 mov	 r9d, 2
  0075c	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00764	8b 54 24 54	 mov	 edx, DWORD PTR r1$[rsp]
  00768	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR vaddr1$[rsp]
  00770	e8 00 00 00 00	 call	 z900_translate_addr
  00775	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 373  :             raddr1 = regs->dat.raddr;

  00779	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00781	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  00788	48 89 44 24 70	 mov	 QWORD PTR raddr1$[rsp], rax

; 374  :         }

  0078d	eb 0d		 jmp	 SHORT $LN36@z900_move_
$LN35@z900_move_:

; 375  :         else
; 376  :             raddr1 = vaddr1;

  0078f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR vaddr1$[rsp]
  00797	48 89 44 24 70	 mov	 QWORD PTR raddr1$[rsp], rax
$LN36@z900_move_:

; 377  : 
; 378  :         if(rc != 0 && rc != 2)

  0079c	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  007a1	74 0c		 je	 SHORT $LN37@z900_move_
  007a3	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  007a8	74 05		 je	 SHORT $LN37@z900_move_

; 379  :             goto mvpg_progck;

  007aa	e9 2b 07 00 00	 jmp	 $mvpg_progck$80
$LN37@z900_move_:

; 380  : 
; 381  :         raddr1 = APPLY_PREFIXING (raddr1, regs->PX);

  007af	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr1$[rsp]
  007b4	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  007ba	48 85 c0	 test	 rax, rax
  007bd	74 28		 je	 SHORT $LN75@z900_move_
  007bf	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr1$[rsp]
  007c4	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  007ca	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007d2	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  007d6	74 0f		 je	 SHORT $LN75@z900_move_
  007d8	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr1$[rsp]
  007dd	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv327[rsp], rax
  007e5	eb 1f		 jmp	 SHORT $LN76@z900_move_
$LN75@z900_move_:
  007e7	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ef	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  007f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr1$[rsp]
  007f8	48 33 c8	 xor	 rcx, rax
  007fb	48 8b c1	 mov	 rax, rcx
  007fe	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv327[rsp], rax
$LN76@z900_move_:
  00806	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv327[rsp]
  0080e	48 89 44 24 70	 mov	 QWORD PTR raddr1$[rsp], rax

; 382  : 
; 383  :         if (raddr1 > regs->mainlim)

  00813	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081b	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00822	48 39 44 24 70	 cmp	 QWORD PTR raddr1$[rsp], rax
  00827	76 1b		 jbe	 SHORT $LN38@z900_move_

; 384  :             regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  00829	ba 05 00 00 00	 mov	 edx, 5
  0082e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00836	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0083e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN38@z900_move_:

; 385  : 
; 386  : #if defined(_FEATURE_SIE)
; 387  :         if(SIE_MODE(regs)  && !regs->sie_pref)

  00844	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0084c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00852	d1 e8		 shr	 eax, 1
  00854	83 e0 01	 and	 eax, 1
  00857	85 c0		 test	 eax, eax
  00859	0f 84 ce 00 00
	00		 je	 $LN39@z900_move_
  0085f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00867	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0086d	c1 e8 02	 shr	 eax, 2
  00870	83 e0 01	 and	 eax, 1
  00873	85 c0		 test	 eax, eax
  00875	0f 85 b2 00 00
	00		 jne	 $LN39@z900_move_

; 388  :         {
; 389  : #if defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)
; 390  :             if (SIE_TRANSLATE_ADDR (regs->sie_mso + raddr1,
; 391  :                 (SIE_STATE_BIT_ON(regs, MX, XC) && AR_BIT(&regs->psw) && r1 > 0)
; 392  :                 ? r1 : USE_PRIMARY_SPACE, HOSTREGS, ACCTYPE_SIE))
; 393  : #else /*!defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 394  :             if (SIE_TRANSLATE_ADDR (regs->sie_mso + raddr1,

  0087b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00883	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0088a	48 03 44 24 70	 add	 rax, QWORD PTR raddr1$[rsp]
  0088f	45 33 c9	 xor	 r9d, r9d
  00892	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0089a	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  008a1	ba fd ff ff ff	 mov	 edx, -3
  008a6	48 8b c8	 mov	 rcx, rax
  008a9	e8 00 00 00 00	 call	 z900_translate_addr
  008ae	85 c0		 test	 eax, eax
  008b0	74 4c		 je	 SHORT $LN40@z900_move_

; 395  :                     USE_PRIMARY_SPACE, HOSTREGS, ACCTYPE_SIE))
; 396  : #endif /*!defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 397  :                 (HOSTREGS->program_interrupt) (HOSTREGS, HOSTREGS->dat.xcode);

  008b2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ba	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  008c1	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  008c8	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008d0	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  008d7	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv602[rsp], rcx
  008df	8b d0		 mov	 edx, eax
  008e1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e9	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  008f0	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv602[rsp]
  008f8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN40@z900_move_:

; 398  : 
; 399  :             /* Convert host real address to host absolute address */
; 400  :             raddr1 = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );

  008fe	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00906	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0090d	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  00914	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0091c	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00923	e8 00 00 00 00	 call	 apply_host_prefixing
  00928	48 89 44 24 70	 mov	 QWORD PTR raddr1$[rsp], rax
$LN39@z900_move_:

; 401  :         } /* SIE_MODE */
; 402  : #endif /*defined(_FEATURE_SIE)*/
; 403  : 
; 404  : #if defined(FEATURE_EXPANDED_STORAGE)
; 405  :         if(rc == 2)

  0092d	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  00932	0f 85 25 01 00
	00		 jne	 $LN41@z900_move_

; 406  :         {
; 407  :             FETCH_W(pte1,regs->mainstor + raddr1);

  00938	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00940	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00947	48 03 44 24 70	 add	 rax, QWORD PTR raddr1$[rsp]
  0094c	48 8b c8	 mov	 rcx, rax
  0094f	e8 00 00 00 00	 call	 fetch_dw_noswap
  00954	48 8b c8	 mov	 rcx, rax
  00957	e8 00 00 00 00	 call	 _byteswap_uint64
  0095c	48 89 44 24 78	 mov	 QWORD PTR pte1$[rsp], rax

; 408  :             /* If page is invalid in real storage but valid in expanded
; 409  :                storage then xpblk1 now contains expanded storage block# */
; 410  :             if(pte1 & PAGETAB_ESVALID)

  00961	48 8b 44 24 78	 mov	 rax, QWORD PTR pte1$[rsp]
  00966	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  0096c	48 85 c0	 test	 rax, rax
  0096f	0f 84 db 00 00
	00		 je	 $LN42@z900_move_

; 411  :             {
; 412  :                 xpblk1 = (pte1 & ZPGETAB_PFRA) >> 12;

  00975	48 8b 44 24 78	 mov	 rax, QWORD PTR pte1$[rsp]
  0097a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00980	48 c1 e8 0c	 shr	 rax, 12
  00984	89 44 24 64	 mov	 DWORD PTR xpblk1$[rsp], eax

; 413  : #if defined(_FEATURE_SIE)
; 414  :                 if(SIE_MODE(regs))

  00988	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00990	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00996	d1 e8		 shr	 eax, 1
  00998	83 e0 01	 and	 eax, 1
  0099b	85 c0		 test	 eax, eax
  0099d	74 39		 je	 SHORT $LN44@z900_move_

; 415  :                 {
; 416  :                     /* Add expanded storage origin for this guest */
; 417  :                     xpblk1 += regs->sie_xso;

  0099f	8b 44 24 64	 mov	 eax, DWORD PTR xpblk1$[rsp]
  009a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ab	48 03 81 a0 08
	00 00		 add	 rax, QWORD PTR [rcx+2208]
  009b2	89 44 24 64	 mov	 DWORD PTR xpblk1$[rsp], eax

; 418  :                     /* If the block lies beyond this guests limit
; 419  :                        then we must terminate the instruction */
; 420  :                     if(xpblk1 >= regs->sie_xsl)

  009b6	8b 44 24 64	 mov	 eax, DWORD PTR xpblk1$[rsp]
  009ba	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c2	48 3b 81 a8 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2216]
  009c9	72 0d		 jb	 SHORT $LN45@z900_move_

; 421  :                     {
; 422  :                         cc = 1;

  009cb	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 423  :                         goto mvpg_progck;

  009d3	e9 02 05 00 00	 jmp	 $mvpg_progck$80
$LN45@z900_move_:
$LN44@z900_move_:

; 424  :                     }
; 425  :                 }
; 426  : #endif /*defined(_FEATURE_SIE)*/
; 427  : 
; 428  :                 rc = 0;

  009d8	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 429  :                 xpvalid1 = 1;

  009e0	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR xpvalid1$[rsp], 1

; 430  :                 xpkeya = raddr1 +

  009e8	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr1$[rsp]
  009ed	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  009f3	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR xpkeya$[rsp], rax

; 431  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 432  :                                   2048;
; 433  : #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 434  :                 /* For ESA/390 mode, the XPTE lies directly beyond
; 435  :                    the PTE, and each entry is 12 bytes long, we must
; 436  :                    therefor add 1024 + 8 times the page index */
; 437  :                               1024 + ((vaddr1 & 0x000FF000) >> 9);
; 438  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 439  :                 if (xpkeya > regs->mainlim)

  009fb	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a03	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00a0a	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR xpkeya$[rsp], rax
  00a12	76 1b		 jbe	 SHORT $LN46@z900_move_

; 440  :                     regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  00a14	ba 05 00 00 00	 mov	 edx, 5
  00a19	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a21	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a29	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN46@z900_move_:

; 441  :                 xpkey1 = regs->mainstor[xpkeya];

  00a2f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a37	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00a3e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR xpkeya$[rsp]
  00a46	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00a4a	88 44 24 43	 mov	 BYTE PTR xpkey1$[rsp], al

; 442  : 
; 443  : /*DEBUG  logmsg("MVPG pte1 = " F_CREG ", xkey1 = %2.2X, xpblk1 = %5.5X, akey1 = %2.2X\n",
; 444  :                   pte1,xpkey1,xpblk1,akey1);  */
; 445  :             }

  00a4e	eb 0d		 jmp	 SHORT $LN43@z900_move_
$LN42@z900_move_:

; 446  :             else
; 447  :             {
; 448  :                 cc = 1;

  00a50	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 449  :                 goto mvpg_progck;

  00a58	e9 7d 04 00 00	 jmp	 $mvpg_progck$80
$LN43@z900_move_:
$LN41@z900_move_:

; 450  :             }
; 451  :         }
; 452  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 453  : 
; 454  :         /* Program check if operand not valid in main or expanded */
; 455  :         if (rc)

  00a5d	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a62	74 0d		 je	 SHORT $LN47@z900_move_

; 456  :         {
; 457  :             cc = 1;

  00a64	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 458  :             goto mvpg_progck;

  00a6c	e9 69 04 00 00	 jmp	 $mvpg_progck$80
$LN47@z900_move_:

; 459  :         }
; 460  : 
; 461  :         /* Program check if page protection or access-list controlled
; 462  :            protection applies to the first operand */
; 463  :         if (regs->dat.protect || (xpvalid1 && (pte1 & PAGETAB_PROT)))

  00a71	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a79	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00a7f	d1 e8		 shr	 eax, 1
  00a81	83 e0 03	 and	 eax, 3
  00a84	85 c0		 test	 eax, eax
  00a86	75 1f		 jne	 SHORT $LN49@z900_move_
  00a88	83 7c 24 50 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00a8d	0f 84 9b 00 00
	00		 je	 $LN48@z900_move_
  00a93	48 8b 44 24 78	 mov	 rax, QWORD PTR pte1$[rsp]
  00a98	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00a9e	48 85 c0	 test	 rax, rax
  00aa1	0f 84 87 00 00
	00		 je	 $LN48@z900_move_
$LN49@z900_move_:

; 464  :         {
; 465  :             regs->TEA = vaddr1 | TEA_PROT_AP | regs->dat.stid;

  00aa7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR vaddr1$[rsp]
  00aaf	48 83 c8 04	 or	 rax, 4
  00ab3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00abb	48 63 89 20 08
	00 00		 movsxd	 rcx, DWORD PTR [rcx+2080]
  00ac2	48 0b c1	 or	 rax, rcx
  00ac5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00acd	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 466  :             regs->excarid = (ACCESS_REGISTER_MODE(&regs->psw)) ? r1 : 0;

  00ad4	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00adc	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00ae0	83 f8 40	 cmp	 eax, 64			; 00000040H
  00ae3	75 0d		 jne	 SHORT $LN77@z900_move_
  00ae5	8b 44 24 54	 mov	 eax, DWORD PTR r1$[rsp]
  00ae9	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv413[rsp], eax
  00af0	eb 0b		 jmp	 SHORT $LN78@z900_move_
$LN77@z900_move_:
  00af2	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv413[rsp], 0
$LN78@z900_move_:
  00afd	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b05	0f b6 8c 24 9c
	00 00 00	 movzx	 ecx, BYTE PTR tv413[rsp]
  00b0d	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 467  :             regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  00b13	ba 04 00 00 00	 mov	 edx, 4
  00b18	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b20	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b28	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN48@z900_move_:
$LN20@z900_move_:

; 468  :         }
; 469  : 
; 470  :     } /* end if(!REAL_MODE) */
; 471  : 
; 472  : #if defined(FEATURE_EXPANDED_STORAGE)
; 473  :     /* Program check if both operands are in expanded storage,
; 474  :        or if first operand is in expanded storage and the Destination
; 475  :        Reference Intention (DRI) bit (register 0 bit 22) is set to one,
; 476  :        or if first operand is in expanded storage and PTE lock bit on,
; 477  :        or if first operand is in expanded storage and frame invalid */
; 478  :     if ((xpvalid1 && xpvalid2)
; 479  :         || (xpvalid1 && (regs->GR_L(0) & GR0_MVPG_DRI))
; 480  :         || (xpvalid1 && (pte1 & PAGETAB_PGLOCK))
; 481  :         || (xpvalid1 && (xpblk1 >= sysblk.xpndsize)))

  00b2e	83 7c 24 50 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00b33	74 07		 je	 SHORT $LN52@z900_move_
  00b35	83 7c 24 5c 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00b3a	75 57		 jne	 SHORT $LN51@z900_move_
$LN52@z900_move_:
  00b3c	83 7c 24 50 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00b41	74 21		 je	 SHORT $LN53@z900_move_
  00b43	b8 08 00 00 00	 mov	 eax, 8
  00b48	48 6b c0 00	 imul	 rax, rax, 0
  00b4c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b54	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00b5b	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00b60	85 c0		 test	 eax, eax
  00b62	75 2f		 jne	 SHORT $LN51@z900_move_
$LN53@z900_move_:
  00b64	83 7c 24 50 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00b69	74 0e		 je	 SHORT $LN54@z900_move_
  00b6b	48 8b 44 24 78	 mov	 rax, QWORD PTR pte1$[rsp]
  00b70	48 83 e0 01	 and	 rax, 1
  00b74	48 85 c0	 test	 rax, rax
  00b77	75 1a		 jne	 SHORT $LN51@z900_move_
$LN54@z900_move_:
  00b79	83 7c 24 50 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00b7e	74 3c		 je	 SHORT $LN50@z900_move_
  00b80	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b87	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  00b8d	39 44 24 64	 cmp	 DWORD PTR xpblk1$[rsp], eax
  00b91	72 29		 jb	 SHORT $LN50@z900_move_
$LN51@z900_move_:

; 482  :     {
; 483  :         regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  00b93	b8 11 00 00 00	 mov	 eax, 17
  00b98	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ba0	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 484  :         rc = 2;

  00ba7	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR rc$[rsp], 2

; 485  :         cc = 1;

  00baf	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 486  :         goto mvpg_progck;

  00bb7	e9 1e 03 00 00	 jmp	 $mvpg_progck$80
$LN50@z900_move_:

; 487  :     }
; 488  :     /* More Program check checking, but at lower priority:
; 489  :        if second operand is in expanded storage and pte lock bit on, or
; 490  :        if second operand is in expanded storage and frame invalid */
; 491  :     if ((xpvalid2 && (pte2 & PAGETAB_PGLOCK))
; 492  :         || (xpvalid2 && (xpblk2 >= sysblk.xpndsize)))

  00bbc	83 7c 24 5c 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00bc1	74 11		 je	 SHORT $LN57@z900_move_
  00bc3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pte2$[rsp]
  00bcb	48 83 e0 01	 and	 rax, 1
  00bcf	48 85 c0	 test	 rax, rax
  00bd2	75 1a		 jne	 SHORT $LN56@z900_move_
$LN57@z900_move_:
  00bd4	83 7c 24 5c 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00bd9	74 57		 je	 SHORT $LN55@z900_move_
  00bdb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00be2	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  00be8	39 44 24 60	 cmp	 DWORD PTR xpblk2$[rsp], eax
  00bec	72 44		 jb	 SHORT $LN55@z900_move_
$LN56@z900_move_:

; 493  :     {
; 494  :         /* re-do translation to set up TEA */
; 495  :         rc = ARCH_DEP(translate_addr) (vaddr2, r2, regs, ACCTYPE_READ);

  00bee	41 b9 04 00 00
	00		 mov	 r9d, 4
  00bf4	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00bfc	8b 54 24 58	 mov	 edx, DWORD PTR r2$[rsp]
  00c00	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR vaddr2$[rsp]
  00c08	e8 00 00 00 00	 call	 z900_translate_addr
  00c0d	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 496  :         regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  00c11	b8 11 00 00 00	 mov	 eax, 17
  00c16	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c1e	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 497  :         cc = 1;

  00c25	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 498  :         goto mvpg_progck;

  00c2d	e9 a8 02 00 00	 jmp	 $mvpg_progck$80
$LN55@z900_move_:

; 499  :     }
; 500  : 
; 501  :     /* Perform protection checks */
; 502  :     if (xpvalid1)

  00c32	83 7c 24 50 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00c37	0f 84 8b 00 00
	00		 je	 $LN58@z900_move_

; 503  :     {
; 504  :         /* Key check on expanded storage block if NoKey bit off in PTE */
; 505  :         if (akey1 != 0 && akey1 != (xpkey1 & STORKEY_KEY)
; 506  :             && (pte1 & PAGETAB_ESNK) == 0
; 507  :             && !((regs->CR(0) & CR0_STORE_OVRD) && ((xpkey1 & STORKEY_KEY) == 0x90)))

  00c3d	0f b6 44 24 41	 movzx	 eax, BYTE PTR akey1$[rsp]
  00c42	85 c0		 test	 eax, eax
  00c44	74 74		 je	 SHORT $LN60@z900_move_
  00c46	0f b6 44 24 41	 movzx	 eax, BYTE PTR akey1$[rsp]
  00c4b	0f b6 4c 24 43	 movzx	 ecx, BYTE PTR xpkey1$[rsp]
  00c50	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00c56	3b c1		 cmp	 eax, ecx
  00c58	74 60		 je	 SHORT $LN60@z900_move_
  00c5a	48 8b 44 24 78	 mov	 rax, QWORD PTR pte1$[rsp]
  00c5f	48 25 00 08 00
	00		 and	 rax, 2048		; 00000800H
  00c65	48 85 c0	 test	 rax, rax
  00c68	75 50		 jne	 SHORT $LN60@z900_move_
  00c6a	b8 08 00 00 00	 mov	 eax, 8
  00c6f	48 6b c0 01	 imul	 rax, rax, 1
  00c73	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c7b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00c83	48 25 00 00 00
	01		 and	 rax, 16777216		; 01000000H
  00c89	48 85 c0	 test	 rax, rax
  00c8c	74 11		 je	 SHORT $LN61@z900_move_
  00c8e	0f b6 44 24 43	 movzx	 eax, BYTE PTR xpkey1$[rsp]
  00c93	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00c98	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  00c9d	74 1b		 je	 SHORT $LN60@z900_move_
$LN61@z900_move_:

; 508  :         {
; 509  :             regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  00c9f	ba 04 00 00 00	 mov	 edx, 4
  00ca4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cac	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cb4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN60@z900_move_:

; 510  :         }
; 511  :         sk1=NULL;

  00cba	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR sk1$[rsp], 0

; 512  :     }

  00cc6	eb 4f		 jmp	 SHORT $LN59@z900_move_
$LN58@z900_move_:

; 513  :     else
; 514  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 515  :     {
; 516  :         /* Obtain absolute address of main storage block,
; 517  :            check protection, and set reference and change bits */
; 518  :         main1 = MADDRL (vaddr1, _4K, r1, regs, ACCTYPE_WRITE_SKP, akey1);

  00cc8	0f b6 44 24 41	 movzx	 eax, BYTE PTR akey1$[rsp]
  00ccd	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00cd1	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00cd9	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00ce1	44 8b 44 24 54	 mov	 r8d, DWORD PTR r1$[rsp]
  00ce6	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00ceb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR vaddr1$[rsp]
  00cf3	e8 00 00 00 00	 call	 z900_maddr_l
  00cf8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR main1$[rsp], rax

; 519  :         sk1 = regs->dat.storkey;

  00d00	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d08	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00d0f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR sk1$[rsp], rax
$LN59@z900_move_:

; 520  :     }
; 521  : 
; 522  : #if defined(FEATURE_EXPANDED_STORAGE)
; 523  :     if (xpvalid2)

  00d17	83 7c 24 5c 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00d1c	74 59		 je	 SHORT $LN62@z900_move_

; 524  :     {
; 525  :         /* Key check on expanded storage block if NoKey bit off in PTE */
; 526  :         if (akey2 != 0 && (xpkey2 & STORKEY_FETCH)
; 527  :             && akey2 != (xpkey2 & STORKEY_KEY)
; 528  :             && (pte2 & PAGETAB_ESNK) == 0)

  00d1e	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey2$[rsp]
  00d23	85 c0		 test	 eax, eax
  00d25	74 4e		 je	 SHORT $LN64@z900_move_
  00d27	0f b6 44 24 44	 movzx	 eax, BYTE PTR xpkey2$[rsp]
  00d2c	83 e0 08	 and	 eax, 8
  00d2f	85 c0		 test	 eax, eax
  00d31	74 42		 je	 SHORT $LN64@z900_move_
  00d33	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey2$[rsp]
  00d38	0f b6 4c 24 44	 movzx	 ecx, BYTE PTR xpkey2$[rsp]
  00d3d	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00d43	3b c1		 cmp	 eax, ecx
  00d45	74 2e		 je	 SHORT $LN64@z900_move_
  00d47	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pte2$[rsp]
  00d4f	48 25 00 08 00
	00		 and	 rax, 2048		; 00000800H
  00d55	48 85 c0	 test	 rax, rax
  00d58	75 1b		 jne	 SHORT $LN64@z900_move_

; 529  :         {
; 530  :             regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  00d5a	ba 04 00 00 00	 mov	 edx, 4
  00d5f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d67	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d6f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN64@z900_move_:

; 531  :         }
; 532  :     }

  00d75	eb 57		 jmp	 SHORT $LN63@z900_move_
$LN62@z900_move_:

; 533  :     else
; 534  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 535  :     {
; 536  :         /* Obtain absolute address of main storage block,
; 537  :            check protection, and set reference bit.
; 538  :            Use last byte of page to avoid FPO area.  */
; 539  :         main2 = MADDR (vaddr2 | 0xFFF, r2, regs, ACCTYPE_READ, akey2);

  00d77	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR vaddr2$[rsp]
  00d7f	48 0d ff 0f 00
	00		 or	 rax, 4095		; 00000fffH
  00d85	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR akey2$[rsp]
  00d8a	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00d8e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00d96	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d9e	44 8b 44 24 58	 mov	 r8d, DWORD PTR r2$[rsp]
  00da3	ba 01 00 00 00	 mov	 edx, 1
  00da8	48 8b c8	 mov	 rcx, rax
  00dab	e8 00 00 00 00	 call	 z900_maddr_l
  00db0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR main2$[rsp], rax

; 540  :         main2 -= 0xFFF;

  00db8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR main2$[rsp]
  00dc0	48 2d ff 0f 00
	00		 sub	 rax, 4095		; 00000fffH
  00dc6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR main2$[rsp], rax
$LN63@z900_move_:

; 541  :     }
; 542  : 
; 543  : #if defined(FEATURE_EXPANDED_STORAGE)
; 544  :     /* Perform page movement */
; 545  :     if (xpvalid2)

  00dce	83 7c 24 5c 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00dd3	74 6c		 je	 SHORT $LN65@z900_move_

; 546  :     {
; 547  :         /* Set the main storage reference and change bits */
; 548  :         ARCH_DEP( or_storage_key_by_ptr )( sk1, (STORKEY_REF | STORKEY_CHANGE) );

  00dd5	b2 06		 mov	 dl, 6
  00dd7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sk1$[rsp]
  00ddf	e8 00 00 00 00	 call	 z900_or_storage_key_by_ptr

; 549  : 
; 550  :         /* Set Expanded Storage reference bit in the PTE */
; 551  :         STORE_W(regs->mainstor + raddr2, pte2 | PAGETAB_ESREF);

  00de4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pte2$[rsp]
  00dec	48 83 c8 04	 or	 rax, 4
  00df0	48 8b c8	 mov	 rcx, rax
  00df3	e8 00 00 00 00	 call	 _byteswap_uint64
  00df8	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e00	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00e07	48 03 4c 24 68	 add	 rcx, QWORD PTR raddr2$[rsp]
  00e0c	48 8b d0	 mov	 rdx, rax
  00e0f	e8 00 00 00 00	 call	 store_dw_noswap

; 552  : 
; 553  :         /* Move 4K bytes from expanded storage to main storage */
; 554  :         memcpy (main1,

  00e14	8b 44 24 60	 mov	 eax, DWORD PTR xpblk2$[rsp]
  00e18	48 c1 e0 0c	 shl	 rax, 12
  00e1c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e23	48 03 81 b0 00
	00 00		 add	 rax, QWORD PTR [rcx+176]
  00e2a	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR main1$[rsp]
  00e32	48 8b f0	 mov	 rsi, rax
  00e35	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00e3a	f3 a4		 rep movsb

; 555  :                 sysblk.xpndstor + ((size_t)xpblk2 << XSTORE_PAGESHIFT),
; 556  :                 XSTORE_PAGESIZE);
; 557  :     }

  00e3c	e9 88 00 00 00	 jmp	 $LN66@z900_move_
$LN65@z900_move_:

; 558  :     else if (xpvalid1)

  00e41	83 7c 24 50 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00e46	74 5b		 je	 SHORT $LN67@z900_move_

; 559  :     {
; 560  :         /* Set Expanded Storage reference and change bits in the PTE */
; 561  :         STORE_W(regs->mainstor + raddr1, pte1 | PAGETAB_ESREF | PAGETAB_ESCHA);

  00e48	48 8b 44 24 78	 mov	 rax, QWORD PTR pte1$[rsp]
  00e4d	48 83 c8 04	 or	 rax, 4
  00e51	48 83 c8 02	 or	 rax, 2
  00e55	48 8b c8	 mov	 rcx, rax
  00e58	e8 00 00 00 00	 call	 _byteswap_uint64
  00e5d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e65	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00e6c	48 03 4c 24 70	 add	 rcx, QWORD PTR raddr1$[rsp]
  00e71	48 8b d0	 mov	 rdx, rax
  00e74	e8 00 00 00 00	 call	 store_dw_noswap

; 562  : 
; 563  :         /* Move 4K bytes from main storage to expanded storage */
; 564  :         memcpy (sysblk.xpndstor + ((size_t)xpblk1 << XSTORE_PAGESHIFT),

  00e79	8b 44 24 64	 mov	 eax, DWORD PTR xpblk1$[rsp]
  00e7d	48 c1 e0 0c	 shl	 rax, 12
  00e81	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e88	48 03 81 b0 00
	00 00		 add	 rax, QWORD PTR [rcx+176]
  00e8f	48 8b f8	 mov	 rdi, rax
  00e92	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR main2$[rsp]
  00e9a	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00e9f	f3 a4		 rep movsb

; 565  :                 main2,
; 566  :                 XSTORE_PAGESIZE);
; 567  :     }

  00ea1	eb 26		 jmp	 SHORT $LN68@z900_move_
$LN67@z900_move_:

; 568  :     else
; 569  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 570  :     {
; 571  :         /* Set the main storage reference and change bits */
; 572  :         ARCH_DEP( or_storage_key_by_ptr )( sk1, (STORKEY_REF | STORKEY_CHANGE) );

  00ea3	b2 06		 mov	 dl, 6
  00ea5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sk1$[rsp]
  00ead	e8 00 00 00 00	 call	 z900_or_storage_key_by_ptr

; 573  : 
; 574  :         /* Move 4K bytes from main storage to main storage */
; 575  :         memcpy (main1, main2, XSTORE_PAGESIZE);

  00eb2	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR main1$[rsp]
  00eba	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR main2$[rsp]
  00ec2	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00ec7	f3 a4		 rep movsb
$LN68@z900_move_:
$LN66@z900_move_:

; 576  :     }
; 577  : 
; 578  :     /* Return condition code zero */
; 579  :     regs->psw.cc = 0;

  00ec9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ed1	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 580  :     return;

  00ed5	e9 49 01 00 00	 jmp	 $LN1@z900_move_
$mvpg_progck$80:
$LN10@z900_move_:

; 581  : 
; 582  : mvpg_progck:
; 583  : 
; 584  :     PTT_ERR("*MVPG",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00eda	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00ee1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ee4	48 83 e0 10	 and	 rax, 16
  00ee8	48 85 c0	 test	 rax, rax
  00eeb	74 68		 je	 SHORT $LN69@z900_move_
  00eed	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ef5	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00efb	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00f00	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00f08	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00f0f	48 63 54 24 54	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00f14	48 8b bc 24 08
	01 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00f1c	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  00f23	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00f2c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00f31	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192937
  00f38	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f3d	44 8b c9	 mov	 r9d, ecx
  00f40	44 8b c2	 mov	 r8d, edx
  00f43	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192938
  00f4a	b9 10 00 00 00	 mov	 ecx, 16
  00f4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN69@z900_move_:
  00f55	33 c0		 xor	 eax, eax
  00f57	85 c0		 test	 eax, eax
  00f59	0f 85 7b ff ff
	ff		 jne	 $LN10@z900_move_

; 585  : 
; 586  :     /* If page translation exception (PTE invalid) and Condition Code
; 587  :         Option (CCO) bit (register 0 bit 23) is set, return condition code */
; 588  :     if ((regs->GR_L(0) & GR0_MVPG_CCO)
; 589  :         && regs->dat.xcode == PGM_PAGE_TRANSLATION_EXCEPTION
; 590  :         && rc == 2)

  00f5f	b8 08 00 00 00	 mov	 eax, 8
  00f64	48 6b c0 00	 imul	 rax, rax, 0
  00f68	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f70	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00f77	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00f7c	85 c0		 test	 eax, eax
  00f7e	74 2d		 je	 SHORT $LN70@z900_move_
  00f80	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f88	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00f8f	83 f8 11	 cmp	 eax, 17
  00f92	75 19		 jne	 SHORT $LN70@z900_move_
  00f94	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  00f99	75 12		 jne	 SHORT $LN70@z900_move_

; 591  :     {
; 592  :         regs->psw.cc = cc;

  00f9b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fa3	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR cc$[rsp]
  00fa8	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 593  :         return;

  00fab	eb 76		 jmp	 SHORT $LN1@z900_move_
$LN70@z900_move_:

; 594  :     }
; 595  : 
; 596  :     /* Otherwise generate program check */
; 597  :     /* (Bit 29 of TEA is on for PIC 11 & operand ID also stored) */
; 598  :     if (regs->dat.xcode == PGM_PAGE_TRANSLATION_EXCEPTION)

  00fad	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fb5	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00fbc	83 f8 11	 cmp	 eax, 17
  00fbf	75 3b		 jne	 SHORT $LN71@z900_move_

; 599  :     {
; 600  :         regs->TEA |= TEA_MVPG;

  00fc1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fc9	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  00fd0	48 83 c8 04	 or	 rax, 4
  00fd4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fdc	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 601  :         regs->opndrid = (r1 << 4) | r2;

  00fe3	8b 44 24 54	 mov	 eax, DWORD PTR r1$[rsp]
  00fe7	c1 e0 04	 shl	 eax, 4
  00fea	0b 44 24 58	 or	 eax, DWORD PTR r2$[rsp]
  00fee	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ff6	88 81 3f 08 00
	00		 mov	 BYTE PTR [rcx+2111], al
$LN71@z900_move_:

; 602  :     }
; 603  :     regs->program_interrupt (regs, regs->dat.xcode);

  00ffc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01004	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  0100b	8b d0		 mov	 edx, eax
  0100d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01015	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0101d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN1@z900_move_:
$LN72@z900_move_:

; 604  : 
; 605  : } /* end DEF_INST(move_page) */

  01023	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0102a	5f		 pop	 rdi
  0102b	5e		 pop	 rsi
  0102c	c3		 ret	 0
z900_move_page ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\xstore.c
_TEXT	SEGMENT
xaddr$ = 64
r1$ = 68
r2$ = 72
i$1 = 76
vaddr$ = 80
xoffs$ = 88
maddr$ = 96
inst$ = 144
regs$ = 152
z900_page_out PROC

; 99   : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 100  : int     r1, r2;                         /* Values of R fields        */
; 101  : VADR    vaddr;                          /* Virtual storage address   */
; 102  : BYTE   *maddr;                          /* Main storage address      */
; 103  : U32     xaddr;                          /* Expanded storage block#   */
; 104  : size_t  xoffs;                          /* Byte offset into xpndstor */
; 105  : 
; 106  :     RRE(inst, regs, r1, r2);

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	48 6b c0 03	 imul	 rax, rax, 3
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00025	89 44 24 4c	 mov	 DWORD PTR i$1[rsp], eax
  00029	8b 44 24 4c	 mov	 eax, DWORD PTR i$1[rsp]
  0002d	83 e0 0f	 and	 eax, 15
  00030	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  00034	8b 44 24 4c	 mov	 eax, DWORD PTR i$1[rsp]
  00038	c1 f8 04	 sar	 eax, 4
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_page_:
  00042	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005e	33 c0		 xor	 eax, eax
  00060	83 f8 04	 cmp	 eax, 4
  00063	74 0f		 je	 SHORT $LN14@z900_page_
  00065	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN14@z900_page_:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 c8		 jne	 SHORT $LN4@z900_page_

; 107  :     PER_ZEROADDR_CHECK( regs, r1 );

  0007a	8b 54 24 44	 mov	 edx, DWORD PTR r1$[rsp]
  0007e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00086	e8 00 00 00 00	 call	 z900_per3_zero_check
$LN7@z900_page_:

; 108  : 
; 109  :     TXF_INSTR_CHECK( regs );

  0008b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00093	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0009a	85 c0		 test	 eax, eax
  0009c	74 3f		 je	 SHORT $LN15@z900_page_
  0009e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ac	0f ba e8 0c	 bts	 eax, 12
  000b0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192781
  000c5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000cb	ba 02 00 00 00	 mov	 edx, 2
  000d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	e8 00 00 00 00	 call	 z900_abort_transaction
$LN15@z900_page_:
  000dd	33 c0		 xor	 eax, eax
  000df	85 c0		 test	 eax, eax
  000e1	75 a8		 jne	 SHORT $LN7@z900_page_

; 110  :     PRIV_CHECK(regs);

  000e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000ef	83 e0 01	 and	 eax, 1
  000f2	85 c0		 test	 eax, eax
  000f4	74 1b		 je	 SHORT $LN16@z900_page_
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00103	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_page_:

; 111  : 
; 112  :     if(SIE_STATE_BIT_ON(regs, IC3, PGX))

  00111	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00119	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011f	d1 e8		 shr	 eax, 1
  00121	83 e0 01	 and	 eax, 1
  00124	85 c0		 test	 eax, eax
  00126	74 3f		 je	 SHORT $LN17@z900_page_
  00128	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00130	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00137	b9 01 00 00 00	 mov	 ecx, 1
  0013c	48 6b c9 03	 imul	 rcx, rcx, 3
  00140	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  00145	83 e0 02	 and	 eax, 2
  00148	85 c0		 test	 eax, eax
  0014a	74 1b		 je	 SHORT $LN17@z900_page_

; 113  :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  0014c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00154	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0015a	ba fc ff ff ff	 mov	 edx, -4
  0015f	48 8b c8	 mov	 rcx, rax
  00162	e8 00 00 00 00	 call	 longjmp
$LN17@z900_page_:

; 114  : 
; 115  : #if defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)
; 116  :     /* Cannot perform xstore page movement in XC mode */
; 117  :     if(SIE_STATE_BIT_ON(regs, MX, XC))
; 118  :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);
; 119  : #endif /*defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 120  : 
; 121  :     /* expanded storage block number */
; 122  :     xaddr = regs->GR_L(r2);

  00167	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  0016c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	89 44 24 40	 mov	 DWORD PTR xaddr$[rsp], eax

; 123  : 
; 124  :     if(SIE_MODE(regs))

  0017f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00187	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0018d	d1 e8		 shr	 eax, 1
  0018f	83 e0 01	 and	 eax, 1
  00192	85 c0		 test	 eax, eax
  00194	0f 84 c7 00 00
	00		 je	 $LN18@z900_page_

; 125  :     {
; 126  :         xaddr += regs->sie_xso;

  0019a	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  0019e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 03 81 a0 08
	00 00		 add	 rax, QWORD PTR [rcx+2208]
  001ad	89 44 24 40	 mov	 DWORD PTR xaddr$[rsp], eax

; 127  :         if(xaddr >= regs->sie_xsl)

  001b1	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  001b5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	48 3b 81 a8 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2216]
  001c4	0f 82 97 00 00
	00		 jb	 $LN19@z900_page_
$LN10@z900_page_:

; 128  :         {
; 129  :             PTT_ERR("*PGOUT",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  001ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d4	48 83 e0 10	 and	 rax, 16
  001d8	48 85 c0	 test	 rax, rax
  001db	74 69		 je	 SHORT $LN20@z900_page_
  001dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e5	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001eb	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR r2$[rsp]
  001f0	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f8	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  001ff	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00204	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020c	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00214	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0021d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00222	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192787
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	44 8b c9	 mov	 r9d, ecx
  00231	44 8b c2	 mov	 r8d, edx
  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192788
  0023b	b9 10 00 00 00	 mov	 ecx, 16
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@z900_page_:
  00246	33 c0		 xor	 eax, eax
  00248	85 c0		 test	 eax, eax
  0024a	0f 85 7a ff ff
	ff		 jne	 $LN10@z900_page_

; 130  :             regs->psw.cc = 3;

  00250	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00258	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 131  :             return;

  0025c	e9 4a 01 00 00	 jmp	 $LN1@z900_page_
$LN19@z900_page_:
$LN18@z900_page_:

; 132  :         }
; 133  :     }
; 134  : 
; 135  :     /* If the expanded storage block is not configured then
; 136  :        terminate with cc3 */
; 137  :     if (xaddr >= sysblk.xpndsize)

  00261	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00268	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  0026e	39 44 24 40	 cmp	 DWORD PTR xaddr$[rsp], eax
  00272	0f 82 97 00 00
	00		 jb	 $LN21@z900_page_
$LN13@z900_page_:

; 138  :     {
; 139  :         PTT_ERR("*PGOUT",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00278	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0027f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00282	48 83 e0 10	 and	 rax, 16
  00286	48 85 c0	 test	 rax, rax
  00289	74 69		 je	 SHORT $LN22@z900_page_
  0028b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00293	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00299	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0029e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002a6	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  002ad	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  002b2	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ba	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  002c2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192791
  002d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002dc	44 8b c9	 mov	 r9d, ecx
  002df	44 8b c2	 mov	 r8d, edx
  002e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192792
  002e9	b9 10 00 00 00	 mov	 ecx, 16
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@z900_page_:
  002f4	33 c0		 xor	 eax, eax
  002f6	85 c0		 test	 eax, eax
  002f8	0f 85 7a ff ff
	ff		 jne	 $LN13@z900_page_

; 140  :         regs->psw.cc = 3;

  002fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00306	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 141  :         return;

  0030a	e9 9c 00 00 00	 jmp	 $LN1@z900_page_
$LN21@z900_page_:

; 142  :     }
; 143  : 
; 144  :     /* Byte offset in expanded storage */
; 145  :     xoffs = (size_t)xaddr << XSTORE_PAGESHIFT;

  0030f	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  00313	48 c1 e0 0c	 shl	 rax, 12
  00317	48 89 44 24 58	 mov	 QWORD PTR xoffs$[rsp], rax

; 146  : 
; 147  :     /* Obtain abs address, verify access and set ref/change bits */
; 148  :     vaddr = (regs->GR(r1) & ADDRESS_MAXWRAP(regs)) & XSTORE_PAGEMASK;

  0031c	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  00321	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00329	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00331	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00338	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00340	48 23 c2	 and	 rax, rdx
  00343	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00349	48 89 44 24 50	 mov	 QWORD PTR vaddr$[rsp], rax

; 149  :     maddr = MADDR (vaddr, USE_REAL_ADDR, regs, ACCTYPE_READ, 0);

  0034e	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00353	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0035b	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00363	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00369	ba 01 00 00 00	 mov	 edx, 1
  0036e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR vaddr$[rsp]
  00373	e8 00 00 00 00	 call	 z900_maddr_l
  00378	48 89 44 24 60	 mov	 QWORD PTR maddr$[rsp], rax

; 150  : 
; 151  :     /* Copy data from main to expanded */
; 152  :     memcpy (sysblk.xpndstor + xoffs, maddr, XSTORE_PAGESIZE);

  0037d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00384	48 8b 80 b0 00
	00 00		 mov	 rax, QWORD PTR [rax+176]
  0038b	48 03 44 24 58	 add	 rax, QWORD PTR xoffs$[rsp]
  00390	48 8b f8	 mov	 rdi, rax
  00393	48 8b 74 24 60	 mov	 rsi, QWORD PTR maddr$[rsp]
  00398	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0039d	f3 a4		 rep movsb

; 153  : 
; 154  :     /* cc0 means pgout ok */
; 155  :     regs->psw.cc = 0;

  0039f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a7	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_page_:
$LN23@z900_page_:

; 156  : 
; 157  : } /* end DEF_INST(page_out) */

  003ab	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003af	5f		 pop	 rdi
  003b0	5e		 pop	 rsi
  003b1	c3		 ret	 0
z900_page_out ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\xstore.c
_TEXT	SEGMENT
xaddr$ = 64
r1$ = 68
r2$ = 72
i$1 = 76
vaddr$ = 80
xoffs$ = 88
maddr$ = 96
inst$ = 144
regs$ = 152
z900_page_in PROC

; 32   : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 33   : int     r1, r2;                         /* Values of R fields        */
; 34   : VADR    vaddr;                          /* Virtual storage address   */
; 35   : BYTE   *maddr;                          /* Main storage address      */
; 36   : U32     xaddr;                          /* Expanded storage block#   */
; 37   : size_t  xoffs;                          /* Byte offset into xpndstor */
; 38   : 
; 39   :     RRE(inst, regs, r1, r2);

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	48 6b c0 03	 imul	 rax, rax, 3
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00025	89 44 24 4c	 mov	 DWORD PTR i$1[rsp], eax
  00029	8b 44 24 4c	 mov	 eax, DWORD PTR i$1[rsp]
  0002d	83 e0 0f	 and	 eax, 15
  00030	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  00034	8b 44 24 4c	 mov	 eax, DWORD PTR i$1[rsp]
  00038	c1 f8 04	 sar	 eax, 4
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_page_:
  00042	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005e	33 c0		 xor	 eax, eax
  00060	83 f8 04	 cmp	 eax, 4
  00063	74 0f		 je	 SHORT $LN14@z900_page_
  00065	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN14@z900_page_:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 c8		 jne	 SHORT $LN4@z900_page_

; 40   :     PER_ZEROADDR_CHECK( regs, r1 );

  0007a	8b 54 24 44	 mov	 edx, DWORD PTR r1$[rsp]
  0007e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00086	e8 00 00 00 00	 call	 z900_per3_zero_check
$LN7@z900_page_:

; 41   : 
; 42   :     TXF_INSTR_CHECK( regs );

  0008b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00093	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0009a	85 c0		 test	 eax, eax
  0009c	74 3f		 je	 SHORT $LN15@z900_page_
  0009e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ac	0f ba e8 0c	 bts	 eax, 12
  000b0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192729
  000c5	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000cb	ba 02 00 00 00	 mov	 edx, 2
  000d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	e8 00 00 00 00	 call	 z900_abort_transaction
$LN15@z900_page_:
  000dd	33 c0		 xor	 eax, eax
  000df	85 c0		 test	 eax, eax
  000e1	75 a8		 jne	 SHORT $LN7@z900_page_

; 43   :     PRIV_CHECK(regs);

  000e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000ef	83 e0 01	 and	 eax, 1
  000f2	85 c0		 test	 eax, eax
  000f4	74 1b		 je	 SHORT $LN16@z900_page_
  000f6	ba 02 00 00 00	 mov	 edx, 2
  000fb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00103	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_page_:

; 44   : 
; 45   :     if(SIE_STATE_BIT_ON(regs, IC3, PGX))

  00111	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00119	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011f	d1 e8		 shr	 eax, 1
  00121	83 e0 01	 and	 eax, 1
  00124	85 c0		 test	 eax, eax
  00126	74 3f		 je	 SHORT $LN17@z900_page_
  00128	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00130	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00137	b9 01 00 00 00	 mov	 ecx, 1
  0013c	48 6b c9 03	 imul	 rcx, rcx, 3
  00140	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  00145	83 e0 02	 and	 eax, 2
  00148	85 c0		 test	 eax, eax
  0014a	74 1b		 je	 SHORT $LN17@z900_page_

; 46   :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  0014c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00154	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0015a	ba fc ff ff ff	 mov	 edx, -4
  0015f	48 8b c8	 mov	 rcx, rax
  00162	e8 00 00 00 00	 call	 longjmp
$LN17@z900_page_:

; 47   : 
; 48   : #if defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)
; 49   :     /* Cannot perform xstore page movement in XC mode */
; 50   :     if(SIE_STATE_BIT_ON(regs, MX, XC))
; 51   :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);
; 52   : #endif /*defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 53   : 
; 54   :     /* expanded storage block number */
; 55   :     xaddr = regs->GR_L(r2);

  00167	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  0016c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	89 44 24 40	 mov	 DWORD PTR xaddr$[rsp], eax

; 56   : 
; 57   :     if(SIE_MODE(regs))

  0017f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00187	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0018d	d1 e8		 shr	 eax, 1
  0018f	83 e0 01	 and	 eax, 1
  00192	85 c0		 test	 eax, eax
  00194	0f 84 c7 00 00
	00		 je	 $LN18@z900_page_

; 58   :     {
; 59   :         xaddr += regs->sie_xso;

  0019a	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  0019e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 03 81 a0 08
	00 00		 add	 rax, QWORD PTR [rcx+2208]
  001ad	89 44 24 40	 mov	 DWORD PTR xaddr$[rsp], eax

; 60   :         if(xaddr >= regs->sie_xsl)

  001b1	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  001b5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	48 3b 81 a8 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2216]
  001c4	0f 82 97 00 00
	00		 jb	 $LN19@z900_page_
$LN10@z900_page_:

; 61   :         {
; 62   :             PTT_ERR("*PGIN",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  001ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d4	48 83 e0 10	 and	 rax, 16
  001d8	48 85 c0	 test	 rax, rax
  001db	74 69		 je	 SHORT $LN20@z900_page_
  001dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e5	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001eb	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR r2$[rsp]
  001f0	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f8	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  001ff	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00204	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020c	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00214	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0021d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00222	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192735
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	44 8b c9	 mov	 r9d, ecx
  00231	44 8b c2	 mov	 r8d, edx
  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192736
  0023b	b9 10 00 00 00	 mov	 ecx, 16
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@z900_page_:
  00246	33 c0		 xor	 eax, eax
  00248	85 c0		 test	 eax, eax
  0024a	0f 85 7a ff ff
	ff		 jne	 $LN10@z900_page_

; 63   :             regs->psw.cc = 3;

  00250	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00258	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 64   :             return;

  0025c	e9 4a 01 00 00	 jmp	 $LN1@z900_page_
$LN19@z900_page_:
$LN18@z900_page_:

; 65   :         }
; 66   :     }
; 67   : 
; 68   :     /* If the expanded storage block is not configured then
; 69   :        terminate with cc3 */
; 70   :     if (xaddr >= sysblk.xpndsize)

  00261	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00268	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  0026e	39 44 24 40	 cmp	 DWORD PTR xaddr$[rsp], eax
  00272	0f 82 97 00 00
	00		 jb	 $LN21@z900_page_
$LN13@z900_page_:

; 71   :     {
; 72   :         PTT_ERR("*PGIN",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00278	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0027f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00282	48 83 e0 10	 and	 rax, 16
  00286	48 85 c0	 test	 rax, rax
  00289	74 69		 je	 SHORT $LN22@z900_page_
  0028b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00293	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00299	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0029e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002a6	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  002ad	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  002b2	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ba	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  002c2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192739
  002d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002dc	44 8b c9	 mov	 r9d, ecx
  002df	44 8b c2	 mov	 r8d, edx
  002e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192740
  002e9	b9 10 00 00 00	 mov	 ecx, 16
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@z900_page_:
  002f4	33 c0		 xor	 eax, eax
  002f6	85 c0		 test	 eax, eax
  002f8	0f 85 7a ff ff
	ff		 jne	 $LN13@z900_page_

; 73   :         regs->psw.cc = 3;

  002fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00306	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 74   :         return;

  0030a	e9 9c 00 00 00	 jmp	 $LN1@z900_page_
$LN21@z900_page_:

; 75   :     }
; 76   : 
; 77   :     /* Byte offset in expanded storage */
; 78   :     xoffs = (size_t)xaddr << XSTORE_PAGESHIFT;

  0030f	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  00313	48 c1 e0 0c	 shl	 rax, 12
  00317	48 89 44 24 58	 mov	 QWORD PTR xoffs$[rsp], rax

; 79   : 
; 80   :     /* Obtain abs address, verify access and set ref/change bits */
; 81   :     vaddr = (regs->GR(r1) & ADDRESS_MAXWRAP(regs)) & XSTORE_PAGEMASK;

  0031c	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  00321	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00329	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00331	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00338	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00340	48 23 c2	 and	 rax, rdx
  00343	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00349	48 89 44 24 50	 mov	 QWORD PTR vaddr$[rsp], rax

; 82   :     maddr = MADDRL (vaddr, 4096, USE_REAL_ADDR, regs, ACCTYPE_WRITE, 0);

  0034e	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00353	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0035b	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00363	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00369	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0036e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR vaddr$[rsp]
  00373	e8 00 00 00 00	 call	 z900_maddr_l
  00378	48 89 44 24 60	 mov	 QWORD PTR maddr$[rsp], rax

; 83   : 
; 84   :     /* Copy data from expanded to main */
; 85   :     memcpy (maddr, sysblk.xpndstor + xoffs, XSTORE_PAGESIZE);

  0037d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00384	48 8b 80 b0 00
	00 00		 mov	 rax, QWORD PTR [rax+176]
  0038b	48 03 44 24 58	 add	 rax, QWORD PTR xoffs$[rsp]
  00390	48 8b 7c 24 60	 mov	 rdi, QWORD PTR maddr$[rsp]
  00395	48 8b f0	 mov	 rsi, rax
  00398	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0039d	f3 a4		 rep movsb

; 86   : 
; 87   :     /* cc0 means pgin ok */
; 88   :     regs->psw.cc = 0;

  0039f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a7	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_page_:
$LN23@z900_page_:

; 89   : 
; 90   : } /* end DEF_INST(page_in) */

  003ab	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003af	5f		 pop	 rdi
  003b0	5e		 pop	 rsi
  003b1	c3		 ret	 0
z900_page_in ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key_by_ptr
_TEXT	SEGMENT
abs$ = 32
skey_ptr$ = 64
bits$ = 72
s390_or_storage_key_by_ptr PROC				; COMDAT

; 328  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 329  :     U64 abs = (skey_ptr - sysblk.storkeys) << _STORKEY_ARRAY_SHIFTAMT;

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR skey_ptr$[rsp]
  00020	48 2b c8	 sub	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 c1 e0 0b	 shl	 rax, 11
  0002a	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 330  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 331  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 332  : #else
; 333  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0002f	0f b6 54 24 48	 movzx	 edx, BYTE PTR bits$[rsp]
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00039	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 334  : #endif
; 335  : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
s390_or_storage_key_by_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\xstore.c
_TEXT	SEGMENT
i$1 = 48
r2$ = 52
r1$ = 56
tv152 = 64
inst$ = 96
regs$ = 104
s390_invalidate_expanded_storage_block_entry PROC

; 166  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 167  : int     r1, r2;                         /* Operand register numbers  */
; 168  : 
; 169  :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_inval:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@s390_inval
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_inval:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s390_inval

; 170  : 
; 171  :     TXF_INSTR_CHECK( regs );
; 172  :     PRIV_CHECK( regs );

  0006c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00075	83 e0 01	 and	 eax, 1
  00078	85 c0		 test	 eax, eax
  0007a	74 15		 je	 SHORT $LN9@s390_inval
  0007c	ba 02 00 00 00	 mov	 edx, 2
  00081	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00086	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_inval:

; 173  : 
; 174  : #if defined( _FEATURE_SIE )
; 175  :     if (SIE_STATE_BIT_OFF( regs, EC0, MVPG ))

  00091	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00096	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009c	d1 e8		 shr	 eax, 1
  0009e	83 e0 01	 and	 eax, 1
  000a1	85 c0		 test	 eax, eax
  000a3	74 53		 je	 SHORT $LN10@s390_inval
  000a5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000b1	b9 01 00 00 00	 mov	 ecx, 1
  000b6	48 6b c9 00	 imul	 rcx, rcx, 0
  000ba	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  000bf	83 e0 01	 and	 eax, 1
  000c2	85 c0		 test	 eax, eax
  000c4	75 32		 jne	 SHORT $LN10@s390_inval
$LN7@s390_inval:

; 176  :         SIE_INTERCEPT( regs );

  000c6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d1	d1 e8		 shr	 eax, 1
  000d3	83 e0 01	 and	 eax, 1
  000d6	85 c0		 test	 eax, eax
  000d8	74 18		 je	 SHORT $LN11@s390_inval
  000da	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000df	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000e5	ba fc ff ff ff	 mov	 edx, -4
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 longjmp
$LN11@s390_inval:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 ce		 jne	 SHORT $LN7@s390_inval
$LN10@s390_inval:

; 177  : #endif
; 178  : 
; 179  :     PERFORM_SERIALIZATION( regs );

  000f8	0f ae f0	 mfence

; 180  :     {
; 181  :         OBTAIN_INTLOCK( regs );

  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179670
  00102	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00107	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 182  :         {
; 183  :             SYNCHRONIZE_CPUS( regs );

  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179671
  00113	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	e8 00 00 00 00	 call	 synchronize_cpus

; 184  : 
; 185  :             /* Invalidate page table entry */
; 186  :             ARCH_DEP( invalidate_pte )( inst[1], regs->GR_G( r1 ), regs->GR( r2 ), regs, false );

  0011d	48 63 44 24 34	 movsxd	 rax, DWORD PTR r2$[rsp]
  00122	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00127	ba 01 00 00 00	 mov	 edx, 1
  0012c	48 6b d2 01	 imul	 rdx, rdx, 1
  00130	48 89 54 24 40	 mov	 QWORD PTR tv152[rsp], rdx
  00135	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0013a	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0013f	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00144	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  0014c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00151	48 8b 94 c8 80
	02 00 00	 mov	 rdx, QWORD PTR [rax+rcx*8+640]
  00159	48 8b 44 24 60	 mov	 rax, QWORD PTR inst$[rsp]
  0015e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv152[rsp]
  00163	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00167	e8 00 00 00 00	 call	 s390_invalidate_pte

; 187  :         }
; 188  :         RELEASE_INTLOCK( regs );

  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179672
  00173	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 189  :     }
; 190  :     PERFORM_SERIALIZATION( regs );

  0017d	0f ae f0	 mfence
$LN12@s390_inval:

; 191  : 
; 192  : } /* end DEF_INST( invalidate_expanded_storage_block_entry ) */

  00180	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00184	c3		 ret	 0
s390_invalidate_expanded_storage_block_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\xstore.c
_TEXT	SEGMENT
akey2$ = 64
akey1$ = 65
akey$ = 66
xpkey1$ = 67
xpkey2$ = 68
rc$ = 72
r1$ = 76
r2$ = 80
cc$ = 84
xpvalid1$ = 88
vaddr1$ = 92
vaddr2$ = 96
pte1$ = 100
raddr2$ = 104
raddr1$ = 112
xpvalid2$ = 120
pte2$ = 124
xpblk2$ = 128
xpblk1$ = 132
tv289 = 136
tv294 = 140
tv410 = 144
tv434 = 148
tv439 = 152
tv508 = 156
i$1 = 160
tv265 = 164
xpkeya$ = 168
main2$ = 176
sk1$ = 184
main1$ = 192
tv230 = 200
tv375 = 208
tv708 = 216
tv697 = 224
inst$ = 272
regs$ = 280
s390_move_page PROC

; 206  : {

$LN87:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 207  : int     r1, r2;                         /* Register values           */
; 208  : int     rc = 0;                         /* Return code               */

  00013	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 209  : int     cc = 0;                         /* Condition code            */

  0001b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 210  : VADR    vaddr1, vaddr2;                 /* Virtual addresses         */
; 211  : RADR    raddr1=0, raddr2=0, xpkeya;     /* Real addresses            */

  00023	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR raddr1$[rsp], 0
  0002c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR raddr2$[rsp], 0

; 212  : BYTE   *main1 = NULL, *main2 = NULL;    /* Mainstor addresses        */

  00035	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR main1$[rsp], 0
  00041	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR main2$[rsp], 0

; 213  : BYTE   *sk1;                            /* Storage key address       */
; 214  : BYTE    akey;                           /* Access key in register 0  */
; 215  : BYTE    akey1, akey2;                   /* Access keys for operands  */
; 216  : #if defined(FEATURE_EXPANDED_STORAGE)
; 217  : int     xpvalid1 = 0, xpvalid2 = 0;     /* 1=Operand in expanded stg */

  0004d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR xpvalid1$[rsp], 0
  00055	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR xpvalid2$[rsp], 0

; 218  : CREG    pte1 = 0, pte2 = 0;             /* Page table entry          */

  0005d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR pte1$[rsp], 0
  00065	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR pte2$[rsp], 0

; 219  : U32     xpblk1 = 0, xpblk2 = 0;         /* Expanded storage block#   */

  0006d	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xpblk1$[rsp], 0
  00078	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xpblk2$[rsp], 0

; 220  : BYTE    xpkey1 = 0, xpkey2 = 0;         /* Expanded storage keys     */

  00083	c6 44 24 43 00	 mov	 BYTE PTR xpkey1$[rsp], 0
  00088	c6 44 24 44 00	 mov	 BYTE PTR xpkey2$[rsp], 0

; 221  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 222  : 
; 223  :     RRE(inst, regs, r1, r2);

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	48 6b c0 03	 imul	 rax, rax, 3
  00096	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0009e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a2	89 84 24 a0 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
  000a9	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  000b0	83 e0 0f	 and	 eax, 15
  000b3	89 44 24 50	 mov	 DWORD PTR r2$[rsp], eax
  000b7	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  000be	c1 f8 04	 sar	 eax, 4
  000c1	83 e0 0f	 and	 eax, 15
  000c4	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_move_:
  000c8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 83 c0 04	 add	 rax, 4
  000d8	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e0	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e4	33 c0		 xor	 eax, eax
  000e6	83 f8 04	 cmp	 eax, 4
  000e9	74 0f		 je	 SHORT $LN8@s390_move_
  000eb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s390_move_:
  000fa	33 c0		 xor	 eax, eax
  000fc	85 c0		 test	 eax, eax
  000fe	75 c8		 jne	 SHORT $LN4@s390_move_

; 224  :     PER_ZEROADDR_CHECK2( regs, r1, r2 );
; 225  :     TXF_INSTR_CHECK( regs );
; 226  : 
; 227  : #if defined(_FEATURE_SIE)
; 228  :     if(SIE_STATE_BIT_OFF(regs, EC0, MVPG))

  00100	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00108	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010e	d1 e8		 shr	 eax, 1
  00110	83 e0 01	 and	 eax, 1
  00113	85 c0		 test	 eax, eax
  00115	74 3f		 je	 SHORT $LN9@s390_move_
  00117	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00126	b9 01 00 00 00	 mov	 ecx, 1
  0012b	48 6b c9 00	 imul	 rcx, rcx, 0
  0012f	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	75 1b		 jne	 SHORT $LN9@s390_move_

; 229  :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  0013b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00143	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00149	ba fc ff ff ff	 mov	 edx, -4
  0014e	48 8b c8	 mov	 rcx, rax
  00151	e8 00 00 00 00	 call	 longjmp
$LN9@s390_move_:

; 230  : #endif /*defined(_FEATURE_SIE)*/
; 231  : 
; 232  :     /* Use PSW key as access key for both operands */
; 233  :     akey1 = akey2 = regs->psw.pkey;

  00156	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015e	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00162	88 44 24 40	 mov	 BYTE PTR akey2$[rsp], al
  00166	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey2$[rsp]
  0016b	88 44 24 41	 mov	 BYTE PTR akey1$[rsp], al

; 234  : 
; 235  :     /* If register 0 bit 20 or 21 is one, get access key from R0 */
; 236  :     if (regs->GR_L(0) & (GR0_MVPG_FIRST | GR0_MVPG_SECOND))

  0016f	b8 08 00 00 00	 mov	 eax, 8
  00174	48 6b c0 00	 imul	 rax, rax, 0
  00178	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00180	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00187	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  0018c	85 c0		 test	 eax, eax
  0018e	0f 84 ce 00 00
	00		 je	 $LN10@s390_move_

; 237  :     {
; 238  :         /* Extract the access key from register 0 bits 24-27 */
; 239  :         akey = regs->GR_L(0) & GR0_MVPG_KEY;

  00194	b8 08 00 00 00	 mov	 eax, 8
  00199	48 6b c0 00	 imul	 rax, rax, 0
  0019d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a5	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001ac	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  001b1	88 44 24 42	 mov	 BYTE PTR akey$[rsp], al

; 240  : 
; 241  :         /* Priviliged operation exception if in problem state, and
; 242  :            the specified key is not permitted by the PSW key mask */
; 243  :         if ( PROBSTATE(&regs->psw)
; 244  :             && ((regs->CR(3) << (akey >> 4)) & 0x80000000) == 0 )

  001b5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  001c1	83 e0 01	 and	 eax, 1
  001c4	85 c0		 test	 eax, eax
  001c6	74 46		 je	 SHORT $LN11@s390_move_
  001c8	b8 08 00 00 00	 mov	 eax, 8
  001cd	48 6b c0 04	 imul	 rax, rax, 4
  001d1	0f b6 4c 24 42	 movzx	 ecx, BYTE PTR akey$[rsp]
  001d6	c1 f9 04	 sar	 ecx, 4
  001d9	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e1	8b 84 02 00 06
	00 00		 mov	 eax, DWORD PTR [rdx+rax+1536]
  001e8	d3 e0		 shl	 eax, cl
  001ea	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001ef	85 c0		 test	 eax, eax
  001f1	75 1b		 jne	 SHORT $LN11@s390_move_

; 245  :             regs->program_interrupt (regs, PGM_PRIVILEGED_OPERATION_EXCEPTION);

  001f3	ba 02 00 00 00	 mov	 edx, 2
  001f8	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00200	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00208	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_move_:

; 246  : 
; 247  :         /* If register 0 bit 20 is one, use R0 key for operand 1 */
; 248  :         if (regs->GR_L(0) & GR0_MVPG_FIRST)

  0020e	b8 08 00 00 00	 mov	 eax, 8
  00213	48 6b c0 00	 imul	 rax, rax, 0
  00217	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00226	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0022b	85 c0		 test	 eax, eax
  0022d	74 09		 je	 SHORT $LN12@s390_move_

; 249  :             akey1 = akey;

  0022f	0f b6 44 24 42	 movzx	 eax, BYTE PTR akey$[rsp]
  00234	88 44 24 41	 mov	 BYTE PTR akey1$[rsp], al
$LN12@s390_move_:

; 250  : 
; 251  :         /* If register 0 bit 21 is one, use R0 key for operand 2 */
; 252  :         if (regs->GR_L(0) & GR0_MVPG_SECOND)

  00238	b8 08 00 00 00	 mov	 eax, 8
  0023d	48 6b c0 00	 imul	 rax, rax, 0
  00241	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00250	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00255	85 c0		 test	 eax, eax
  00257	74 09		 je	 SHORT $LN13@s390_move_

; 253  :             akey2 = akey;

  00259	0f b6 44 24 42	 movzx	 eax, BYTE PTR akey$[rsp]
  0025e	88 44 24 40	 mov	 BYTE PTR akey2$[rsp], al
$LN13@s390_move_:
$LN10@s390_move_:

; 254  :     }
; 255  : 
; 256  :     /* Specification exception if register 0 bits 16-19 are
; 257  :        not all zero, or if bits 20 and 21 are both ones */
; 258  :     if ((regs->GR_L(0) & GR0_MVPG_RSRVD) != 0
; 259  :         || (regs->GR_L(0) & (GR0_MVPG_FIRST | GR0_MVPG_SECOND))

  00262	b8 08 00 00 00	 mov	 eax, 8
  00267	48 6b c0 00	 imul	 rax, rax, 0
  0026b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0027a	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  0027f	85 c0		 test	 eax, eax
  00281	75 24		 jne	 SHORT $LN15@s390_move_
  00283	b8 08 00 00 00	 mov	 eax, 8
  00288	48 6b c0 00	 imul	 rax, rax, 0
  0028c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0029b	25 00 0c 00 00	 and	 eax, 3072		; 00000c00H
  002a0	3d 00 0c 00 00	 cmp	 eax, 3072		; 00000c00H
  002a5	75 1b		 jne	 SHORT $LN14@s390_move_
$LN15@s390_move_:

; 260  :                          == (GR0_MVPG_FIRST | GR0_MVPG_SECOND))
; 261  :         regs->program_interrupt (regs, PGM_SPECIFICATION_EXCEPTION);

  002a7	ba 06 00 00 00	 mov	 edx, 6
  002ac	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@s390_move_:

; 262  : 
; 263  :     /* Determine the logical addresses of each operand */
; 264  :     vaddr1 = regs->GR(r1) & ADDRESS_MAXWRAP(regs);

  002c2	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r1$[rsp]
  002c7	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cf	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002d7	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  002dd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002e4	23 c2		 and	 eax, edx
  002e6	89 44 24 5c	 mov	 DWORD PTR vaddr1$[rsp], eax

; 265  :     vaddr2 = regs->GR(r2) & ADDRESS_MAXWRAP(regs);

  002ea	48 63 44 24 50	 movsxd	 rax, DWORD PTR r2$[rsp]
  002ef	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002ff	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00305	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0030c	23 c2		 and	 eax, edx
  0030e	89 44 24 60	 mov	 DWORD PTR vaddr2$[rsp], eax

; 266  : 
; 267  :     /* Isolate the page addresses of each operand */
; 268  :     vaddr1 &= XSTORE_PAGEMASK;

  00312	8b 44 24 5c	 mov	 eax, DWORD PTR vaddr1$[rsp]
  00316	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0031c	89 44 24 5c	 mov	 DWORD PTR vaddr1$[rsp], eax

; 269  :     vaddr2 &= XSTORE_PAGEMASK;

  00320	8b 44 24 60	 mov	 eax, DWORD PTR vaddr2$[rsp]
  00324	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0032a	89 44 24 60	 mov	 DWORD PTR vaddr2$[rsp], eax

; 270  : 
; 271  :     /* Obtain the real or expanded address of each operand */
; 272  :     if ( !REAL_MODE(&regs->psw) || SIE_MODE(regs) )

  0032e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00336	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0033a	83 e0 04	 and	 eax, 4
  0033d	85 c0		 test	 eax, eax
  0033f	75 1b		 jne	 SHORT $LN17@s390_move_
  00341	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00349	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0034f	d1 e8		 shr	 eax, 1
  00351	83 e0 01	 and	 eax, 1
  00354	85 c0		 test	 eax, eax
  00356	0f 84 9b 09 00
	00		 je	 $LN16@s390_move_
$LN17@s390_move_:

; 273  :     {
; 274  :         /* Translate the second operand address to a real address */
; 275  :         if(!REAL_MODE(&regs->psw))

  0035c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00364	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00368	83 e0 04	 and	 eax, 4
  0036b	85 c0		 test	 eax, eax
  0036d	74 35		 je	 SHORT $LN18@s390_move_

; 276  :         {
; 277  :             rc = ARCH_DEP(translate_addr) (vaddr2, r2, regs, ACCTYPE_READ);

  0036f	41 b9 04 00 00
	00		 mov	 r9d, 4
  00375	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0037d	8b 54 24 50	 mov	 edx, DWORD PTR r2$[rsp]
  00381	8b 4c 24 60	 mov	 ecx, DWORD PTR vaddr2$[rsp]
  00385	e8 00 00 00 00	 call	 s390_translate_addr
  0038a	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 278  :             raddr2 = regs->dat.raddr;

  0038e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00396	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  0039d	48 89 44 24 68	 mov	 QWORD PTR raddr2$[rsp], rax

; 279  :         }

  003a2	eb 09		 jmp	 SHORT $LN19@s390_move_
$LN18@s390_move_:

; 280  :         else
; 281  :             raddr2 = vaddr2;

  003a4	8b 44 24 60	 mov	 eax, DWORD PTR vaddr2$[rsp]
  003a8	48 89 44 24 68	 mov	 QWORD PTR raddr2$[rsp], rax
$LN19@s390_move_:

; 282  : 
; 283  :         if(rc != 0 && rc != 2)

  003ad	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  003b2	74 0c		 je	 SHORT $LN20@s390_move_
  003b4	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  003b9	74 05		 je	 SHORT $LN20@s390_move_

; 284  :             goto mvpg_progck;

  003bb	e9 c0 0c 00 00	 jmp	 $mvpg_progck$88
$LN20@s390_move_:

; 285  : 
; 286  :         raddr2 = APPLY_PREFIXING (raddr2, regs->PX);

  003c0	8b 44 24 68	 mov	 eax, DWORD PTR raddr2$[rsp]
  003c4	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  003ca	48 85 c0	 test	 rax, rax
  003cd	74 29		 je	 SHORT $LN69@s390_move_
  003cf	8b 44 24 68	 mov	 eax, DWORD PTR raddr2$[rsp]
  003d3	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  003d9	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e1	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  003e4	48 3b c1	 cmp	 rax, rcx
  003e7	74 0f		 je	 SHORT $LN69@s390_move_
  003e9	48 8b 44 24 68	 mov	 rax, QWORD PTR raddr2$[rsp]
  003ee	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv230[rsp], rax
  003f6	eb 1d		 jmp	 SHORT $LN70@s390_move_
$LN69@s390_move_:
  003f8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00400	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00403	8b 4c 24 68	 mov	 ecx, DWORD PTR raddr2$[rsp]
  00407	33 c8		 xor	 ecx, eax
  00409	8b c1		 mov	 eax, ecx
  0040b	8b c0		 mov	 eax, eax
  0040d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv230[rsp], rax
$LN70@s390_move_:
  00415	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv230[rsp]
  0041d	48 89 44 24 68	 mov	 QWORD PTR raddr2$[rsp], rax

; 287  : 
; 288  :         if (raddr2 > regs->mainlim)

  00422	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042a	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00431	48 39 44 24 68	 cmp	 QWORD PTR raddr2$[rsp], rax
  00436	76 1b		 jbe	 SHORT $LN21@s390_move_

; 289  :             regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  00438	ba 05 00 00 00	 mov	 edx, 5
  0043d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00445	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN21@s390_move_:

; 290  : 
; 291  : #if defined(_FEATURE_SIE)
; 292  :         if(SIE_MODE(regs)  && !regs->sie_pref)

  00453	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00461	d1 e8		 shr	 eax, 1
  00463	83 e0 01	 and	 eax, 1
  00466	85 c0		 test	 eax, eax
  00468	0f 84 fc 01 00
	00		 je	 $LN22@s390_move_
  0046e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00476	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0047c	c1 e8 02	 shr	 eax, 2
  0047f	83 e0 01	 and	 eax, 1
  00482	85 c0		 test	 eax, eax
  00484	0f 85 e0 01 00
	00		 jne	 $LN22@s390_move_

; 293  :         {
; 294  : #if defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)
; 295  :             if (SIE_TRANSLATE_ADDR (regs->sie_mso + raddr2,

  0048a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00492	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00499	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  0049d	0f 85 a3 00 00
	00		 jne	 $LN75@s390_move_
  004a3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ab	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004b1	d1 e8		 shr	 eax, 1
  004b3	83 e0 01	 and	 eax, 1
  004b6	85 c0		 test	 eax, eax
  004b8	74 41		 je	 SHORT $LN71@s390_move_
  004ba	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c2	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  004c9	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  004cd	83 e0 01	 and	 eax, 1
  004d0	85 c0		 test	 eax, eax
  004d2	74 27		 je	 SHORT $LN71@s390_move_
  004d4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004dc	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  004e0	83 e0 40	 and	 eax, 64			; 00000040H
  004e3	85 c0		 test	 eax, eax
  004e5	74 14		 je	 SHORT $LN71@s390_move_
  004e7	83 7c 24 50 00	 cmp	 DWORD PTR r2$[rsp], 0
  004ec	7e 0d		 jle	 SHORT $LN71@s390_move_
  004ee	8b 44 24 50	 mov	 eax, DWORD PTR r2$[rsp]
  004f2	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv265[rsp], eax
  004f9	eb 0b		 jmp	 SHORT $LN72@s390_move_
$LN71@s390_move_:
  004fb	c7 84 24 a4 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR tv265[rsp], -3
$LN72@s390_move_:
  00506	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050e	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00515	48 03 44 24 68	 add	 rax, QWORD PTR raddr2$[rsp]
  0051a	45 33 c9	 xor	 r9d, r9d
  0051d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00525	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0052c	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR tv265[rsp]
  00533	8b c8		 mov	 ecx, eax
  00535	e8 00 00 00 00	 call	 s390_translate_addr
  0053a	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv294[rsp], eax
  00541	e9 9f 00 00 00	 jmp	 $LN76@s390_move_
$LN75@s390_move_:
  00546	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00554	d1 e8		 shr	 eax, 1
  00556	83 e0 01	 and	 eax, 1
  00559	85 c0		 test	 eax, eax
  0055b	74 41		 je	 SHORT $LN73@s390_move_
  0055d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00565	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0056c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00570	83 e0 01	 and	 eax, 1
  00573	85 c0		 test	 eax, eax
  00575	74 27		 je	 SHORT $LN73@s390_move_
  00577	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057f	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00583	83 e0 40	 and	 eax, 64			; 00000040H
  00586	85 c0		 test	 eax, eax
  00588	74 14		 je	 SHORT $LN73@s390_move_
  0058a	83 7c 24 50 00	 cmp	 DWORD PTR r2$[rsp], 0
  0058f	7e 0d		 jle	 SHORT $LN73@s390_move_
  00591	8b 44 24 50	 mov	 eax, DWORD PTR r2$[rsp]
  00595	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv289[rsp], eax
  0059c	eb 0b		 jmp	 SHORT $LN74@s390_move_
$LN73@s390_move_:
  0059e	c7 84 24 88 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR tv289[rsp], -3
$LN74@s390_move_:
  005a9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b1	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  005b8	48 03 44 24 68	 add	 rax, QWORD PTR raddr2$[rsp]
  005bd	45 33 c9	 xor	 r9d, r9d
  005c0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c8	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  005cf	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR tv289[rsp]
  005d6	48 8b c8	 mov	 rcx, rax
  005d9	e8 00 00 00 00	 call	 z900_translate_addr
  005de	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv294[rsp], eax
$LN76@s390_move_:
  005e5	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv294[rsp], 0
  005ed	74 4c		 je	 SHORT $LN23@s390_move_

; 296  :                 (SIE_STATE_BIT_ON(regs, MX, XC) && AR_BIT(&regs->psw) && r2 > 0)
; 297  :                 ? r2 : USE_PRIMARY_SPACE, HOSTREGS, ACCTYPE_SIE))
; 298  : #else /*!defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 299  :             if (SIE_TRANSLATE_ADDR (regs->sie_mso + raddr2,
; 300  :                     USE_PRIMARY_SPACE, HOSTREGS, ACCTYPE_SIE))
; 301  : #endif /*!defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 302  :                 (HOSTREGS->program_interrupt) (HOSTREGS, HOSTREGS->dat.xcode);

  005ef	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  005fe	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00605	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060d	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00614	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv708[rsp], rcx
  0061c	8b d0		 mov	 edx, eax
  0061e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00626	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0062d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv708[rsp]
  00635	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN23@s390_move_:

; 303  : 
; 304  :             /* Convert host real address to host absolute address */
; 305  :             raddr2 = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );

  0063b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00643	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0064a	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  00651	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00659	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00660	e8 00 00 00 00	 call	 apply_host_prefixing
  00665	48 89 44 24 68	 mov	 QWORD PTR raddr2$[rsp], rax
$LN22@s390_move_:

; 306  :         } /* SIE_MODE */
; 307  : #endif /*defined(_FEATURE_SIE)*/
; 308  : 
; 309  : #if defined(FEATURE_EXPANDED_STORAGE)
; 310  :         if(rc == 2)

  0066a	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  0066f	0f 85 3b 01 00
	00		 jne	 $LN24@s390_move_

; 311  :         {
; 312  :             FETCH_W(pte2,regs->mainstor + raddr2);

  00675	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067d	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00684	48 03 44 24 68	 add	 rax, QWORD PTR raddr2$[rsp]
  00689	48 8b c8	 mov	 rcx, rax
  0068c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00691	8b c8		 mov	 ecx, eax
  00693	e8 00 00 00 00	 call	 _byteswap_ulong
  00698	89 44 24 7c	 mov	 DWORD PTR pte2$[rsp], eax

; 313  :             /* If page is invalid in real storage but valid in expanded
; 314  :                storage then xpblk2 now contains expanded storage block# */
; 315  :             if(pte2 & PAGETAB_ESVALID)

  0069c	8b 44 24 7c	 mov	 eax, DWORD PTR pte2$[rsp]
  006a0	25 00 01 00 00	 and	 eax, 256		; 00000100H
  006a5	85 c0		 test	 eax, eax
  006a7	0f 84 f6 00 00
	00		 je	 $LN25@s390_move_

; 316  :             {
; 317  :                 xpblk2 = (pte2 & ZPGETAB_PFRA) >> 12;

  006ad	8b 44 24 7c	 mov	 eax, DWORD PTR pte2$[rsp]
  006b1	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  006b7	48 c1 e8 0c	 shr	 rax, 12
  006bb	89 84 24 80 00
	00 00		 mov	 DWORD PTR xpblk2$[rsp], eax

; 318  : #if defined(_FEATURE_SIE)
; 319  :                 if(SIE_MODE(regs))

  006c2	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ca	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  006d0	d1 e8		 shr	 eax, 1
  006d2	83 e0 01	 and	 eax, 1
  006d5	85 c0		 test	 eax, eax
  006d7	74 42		 je	 SHORT $LN27@s390_move_

; 320  :                 {
; 321  :                     /* Add expanded storage origin for this guest */
; 322  :                     xpblk2 += regs->sie_xso;

  006d9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR xpblk2$[rsp]
  006e0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e8	48 03 81 a0 08
	00 00		 add	 rax, QWORD PTR [rcx+2208]
  006ef	89 84 24 80 00
	00 00		 mov	 DWORD PTR xpblk2$[rsp], eax

; 323  :                     /* If the block lies beyond this guests limit
; 324  :                        then we must terminate the instruction */
; 325  :                     if(xpblk2 >= regs->sie_xsl)

  006f6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR xpblk2$[rsp]
  006fd	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00705	48 3b 81 a8 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2216]
  0070c	72 0d		 jb	 SHORT $LN28@s390_move_

; 326  :                     {
; 327  :                         cc = 2;

  0070e	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 328  :                         goto mvpg_progck;

  00716	e9 65 09 00 00	 jmp	 $mvpg_progck$88
$LN28@s390_move_:
$LN27@s390_move_:

; 329  :                     }
; 330  :                 } /* SIE_MODE */
; 331  : #endif /*defined(_FEATURE_SIE)*/
; 332  : 
; 333  :                 rc = 0;

  0071b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 334  :                 xpvalid2 = 1;

  00723	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR xpvalid2$[rsp], 1

; 335  :                 xpkeya = raddr2 +

  0072b	8b 44 24 60	 mov	 eax, DWORD PTR vaddr2$[rsp]
  0072f	25 00 f0 0f 00	 and	 eax, 1044480		; 000ff000H
  00734	c1 e8 09	 shr	 eax, 9
  00737	8b c0		 mov	 eax, eax
  00739	48 8b 4c 24 68	 mov	 rcx, QWORD PTR raddr2$[rsp]
  0073e	48 8d 84 01 00
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1024]
  00746	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR xpkeya$[rsp], rax

; 336  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 337  :                                    2048;
; 338  : #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 339  :                 /* For ESA/390 mode, the XPTE lies directly beyond
; 340  :                    the PTE, and each entry is 12 bytes long, we must
; 341  :                    therefor add 1024 + 8 times the page index */
; 342  :                                  1024 + ((vaddr2 & 0x000FF000) >> 9);
; 343  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 344  :                 if (xpkeya > regs->mainlim)

  0074e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00756	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0075d	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR xpkeya$[rsp], rax
  00765	76 1b		 jbe	 SHORT $LN29@s390_move_

; 345  :                     regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  00767	ba 05 00 00 00	 mov	 edx, 5
  0076c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00774	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0077c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@s390_move_:

; 346  :                 xpkey2 = regs->mainstor[xpkeya];

  00782	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078a	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00791	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR xpkeya$[rsp]
  00799	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0079d	88 44 24 44	 mov	 BYTE PTR xpkey2$[rsp], al

; 347  : 
; 348  : /*DEBUG logmsg("MVPG pte2 = " F_CREG ", xkey2 = %2.2X, xpblk2 = %5.5X, akey2 = %2.2X\n",
; 349  :                   pte2,xpkey2,xpblk2,akey2);  */
; 350  :             }

  007a1	eb 0d		 jmp	 SHORT $LN26@s390_move_
$LN25@s390_move_:

; 351  :             else
; 352  :             {
; 353  :                 cc = 2;

  007a3	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 354  :                 goto mvpg_progck;

  007ab	e9 d0 08 00 00	 jmp	 $mvpg_progck$88
$LN26@s390_move_:
$LN24@s390_move_:

; 355  :             }
; 356  :         }
; 357  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 358  : 
; 359  :         /* Program check if second operand is not valid
; 360  :            in either main storage or expanded storage */
; 361  :         if (rc)

  007b0	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  007b5	74 0d		 je	 SHORT $LN30@s390_move_

; 362  :         {
; 363  :             cc = 2;

  007b7	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 364  :             goto mvpg_progck;

  007bf	e9 bc 08 00 00	 jmp	 $mvpg_progck$88
$LN30@s390_move_:

; 365  :         }
; 366  : 
; 367  :         /* Reset protection indication before calling translate_addr() */
; 368  :         regs->dat.protect = 0;

  007c4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007cc	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  007d2	83 e0 f9	 and	 eax, -7			; fffffff9H
  007d5	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007dd	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 369  :         /* Translate the first operand address to a real address */
; 370  :         if(!REAL_MODE(&regs->psw))

  007e3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007eb	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  007ef	83 e0 04	 and	 eax, 4
  007f2	85 c0		 test	 eax, eax
  007f4	74 35		 je	 SHORT $LN31@s390_move_

; 371  :         {
; 372  :             rc = ARCH_DEP(translate_addr) (vaddr1, r1, regs, ACCTYPE_WRITE);

  007f6	41 b9 02 00 00
	00		 mov	 r9d, 2
  007fc	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00804	8b 54 24 4c	 mov	 edx, DWORD PTR r1$[rsp]
  00808	8b 4c 24 5c	 mov	 ecx, DWORD PTR vaddr1$[rsp]
  0080c	e8 00 00 00 00	 call	 s390_translate_addr
  00811	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 373  :             raddr1 = regs->dat.raddr;

  00815	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081d	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  00824	48 89 44 24 70	 mov	 QWORD PTR raddr1$[rsp], rax

; 374  :         }

  00829	eb 09		 jmp	 SHORT $LN32@s390_move_
$LN31@s390_move_:

; 375  :         else
; 376  :             raddr1 = vaddr1;

  0082b	8b 44 24 5c	 mov	 eax, DWORD PTR vaddr1$[rsp]
  0082f	48 89 44 24 70	 mov	 QWORD PTR raddr1$[rsp], rax
$LN32@s390_move_:

; 377  : 
; 378  :         if(rc != 0 && rc != 2)

  00834	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00839	74 0c		 je	 SHORT $LN33@s390_move_
  0083b	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  00840	74 05		 je	 SHORT $LN33@s390_move_

; 379  :             goto mvpg_progck;

  00842	e9 39 08 00 00	 jmp	 $mvpg_progck$88
$LN33@s390_move_:

; 380  : 
; 381  :         raddr1 = APPLY_PREFIXING (raddr1, regs->PX);

  00847	8b 44 24 70	 mov	 eax, DWORD PTR raddr1$[rsp]
  0084b	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00851	48 85 c0	 test	 rax, rax
  00854	74 29		 je	 SHORT $LN77@s390_move_
  00856	8b 44 24 70	 mov	 eax, DWORD PTR raddr1$[rsp]
  0085a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00860	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00868	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0086b	48 3b c1	 cmp	 rax, rcx
  0086e	74 0f		 je	 SHORT $LN77@s390_move_
  00870	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr1$[rsp]
  00875	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv375[rsp], rax
  0087d	eb 1d		 jmp	 SHORT $LN78@s390_move_
$LN77@s390_move_:
  0087f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00887	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0088a	8b 4c 24 70	 mov	 ecx, DWORD PTR raddr1$[rsp]
  0088e	33 c8		 xor	 ecx, eax
  00890	8b c1		 mov	 eax, ecx
  00892	8b c0		 mov	 eax, eax
  00894	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv375[rsp], rax
$LN78@s390_move_:
  0089c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv375[rsp]
  008a4	48 89 44 24 70	 mov	 QWORD PTR raddr1$[rsp], rax

; 382  : 
; 383  :         if (raddr1 > regs->mainlim)

  008a9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b1	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  008b8	48 39 44 24 70	 cmp	 QWORD PTR raddr1$[rsp], rax
  008bd	76 1b		 jbe	 SHORT $LN34@s390_move_

; 384  :             regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  008bf	ba 05 00 00 00	 mov	 edx, 5
  008c4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008cc	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN34@s390_move_:

; 385  : 
; 386  : #if defined(_FEATURE_SIE)
; 387  :         if(SIE_MODE(regs)  && !regs->sie_pref)

  008da	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  008e8	d1 e8		 shr	 eax, 1
  008ea	83 e0 01	 and	 eax, 1
  008ed	85 c0		 test	 eax, eax
  008ef	0f 84 fc 01 00
	00		 je	 $LN35@s390_move_
  008f5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00903	c1 e8 02	 shr	 eax, 2
  00906	83 e0 01	 and	 eax, 1
  00909	85 c0		 test	 eax, eax
  0090b	0f 85 e0 01 00
	00		 jne	 $LN35@s390_move_

; 388  :         {
; 389  : #if defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)
; 390  :             if (SIE_TRANSLATE_ADDR (regs->sie_mso + raddr1,

  00911	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00919	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00920	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00924	0f 85 a3 00 00
	00		 jne	 $LN83@s390_move_
  0092a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00932	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00938	d1 e8		 shr	 eax, 1
  0093a	83 e0 01	 and	 eax, 1
  0093d	85 c0		 test	 eax, eax
  0093f	74 41		 je	 SHORT $LN79@s390_move_
  00941	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00949	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00950	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00954	83 e0 01	 and	 eax, 1
  00957	85 c0		 test	 eax, eax
  00959	74 27		 je	 SHORT $LN79@s390_move_
  0095b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00963	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00967	83 e0 40	 and	 eax, 64			; 00000040H
  0096a	85 c0		 test	 eax, eax
  0096c	74 14		 je	 SHORT $LN79@s390_move_
  0096e	83 7c 24 4c 00	 cmp	 DWORD PTR r1$[rsp], 0
  00973	7e 0d		 jle	 SHORT $LN79@s390_move_
  00975	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  00979	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv410[rsp], eax
  00980	eb 0b		 jmp	 SHORT $LN80@s390_move_
$LN79@s390_move_:
  00982	c7 84 24 90 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR tv410[rsp], -3
$LN80@s390_move_:
  0098d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00995	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0099c	48 03 44 24 70	 add	 rax, QWORD PTR raddr1$[rsp]
  009a1	45 33 c9	 xor	 r9d, r9d
  009a4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ac	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  009b3	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR tv410[rsp]
  009ba	8b c8		 mov	 ecx, eax
  009bc	e8 00 00 00 00	 call	 s390_translate_addr
  009c1	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv439[rsp], eax
  009c8	e9 9f 00 00 00	 jmp	 $LN84@s390_move_
$LN83@s390_move_:
  009cd	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  009db	d1 e8		 shr	 eax, 1
  009dd	83 e0 01	 and	 eax, 1
  009e0	85 c0		 test	 eax, eax
  009e2	74 41		 je	 SHORT $LN81@s390_move_
  009e4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009ec	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009f3	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  009f7	83 e0 01	 and	 eax, 1
  009fa	85 c0		 test	 eax, eax
  009fc	74 27		 je	 SHORT $LN81@s390_move_
  009fe	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a06	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00a0a	83 e0 40	 and	 eax, 64			; 00000040H
  00a0d	85 c0		 test	 eax, eax
  00a0f	74 14		 je	 SHORT $LN81@s390_move_
  00a11	83 7c 24 4c 00	 cmp	 DWORD PTR r1$[rsp], 0
  00a16	7e 0d		 jle	 SHORT $LN81@s390_move_
  00a18	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  00a1c	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv434[rsp], eax
  00a23	eb 0b		 jmp	 SHORT $LN82@s390_move_
$LN81@s390_move_:
  00a25	c7 84 24 94 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR tv434[rsp], -3
$LN82@s390_move_:
  00a30	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a38	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00a3f	48 03 44 24 70	 add	 rax, QWORD PTR raddr1$[rsp]
  00a44	45 33 c9	 xor	 r9d, r9d
  00a47	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a4f	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00a56	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR tv434[rsp]
  00a5d	48 8b c8	 mov	 rcx, rax
  00a60	e8 00 00 00 00	 call	 z900_translate_addr
  00a65	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv439[rsp], eax
$LN84@s390_move_:
  00a6c	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv439[rsp], 0
  00a74	74 4c		 je	 SHORT $LN36@s390_move_

; 391  :                 (SIE_STATE_BIT_ON(regs, MX, XC) && AR_BIT(&regs->psw) && r1 > 0)
; 392  :                 ? r1 : USE_PRIMARY_SPACE, HOSTREGS, ACCTYPE_SIE))
; 393  : #else /*!defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 394  :             if (SIE_TRANSLATE_ADDR (regs->sie_mso + raddr1,
; 395  :                     USE_PRIMARY_SPACE, HOSTREGS, ACCTYPE_SIE))
; 396  : #endif /*!defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 397  :                 (HOSTREGS->program_interrupt) (HOSTREGS, HOSTREGS->dat.xcode);

  00a76	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a7e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00a85	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00a8c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a94	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00a9b	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv697[rsp], rcx
  00aa3	8b d0		 mov	 edx, eax
  00aa5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aad	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00ab4	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv697[rsp]
  00abc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN36@s390_move_:

; 398  : 
; 399  :             /* Convert host real address to host absolute address */
; 400  :             raddr1 = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );

  00ac2	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aca	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00ad1	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  00ad8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ae0	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00ae7	e8 00 00 00 00	 call	 apply_host_prefixing
  00aec	48 89 44 24 70	 mov	 QWORD PTR raddr1$[rsp], rax
$LN35@s390_move_:

; 401  :         } /* SIE_MODE */
; 402  : #endif /*defined(_FEATURE_SIE)*/
; 403  : 
; 404  : #if defined(FEATURE_EXPANDED_STORAGE)
; 405  :         if(rc == 2)

  00af1	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  00af6	0f 85 3b 01 00
	00		 jne	 $LN37@s390_move_

; 406  :         {
; 407  :             FETCH_W(pte1,regs->mainstor + raddr1);

  00afc	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b04	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00b0b	48 03 44 24 70	 add	 rax, QWORD PTR raddr1$[rsp]
  00b10	48 8b c8	 mov	 rcx, rax
  00b13	e8 00 00 00 00	 call	 fetch_fw_noswap
  00b18	8b c8		 mov	 ecx, eax
  00b1a	e8 00 00 00 00	 call	 _byteswap_ulong
  00b1f	89 44 24 64	 mov	 DWORD PTR pte1$[rsp], eax

; 408  :             /* If page is invalid in real storage but valid in expanded
; 409  :                storage then xpblk1 now contains expanded storage block# */
; 410  :             if(pte1 & PAGETAB_ESVALID)

  00b23	8b 44 24 64	 mov	 eax, DWORD PTR pte1$[rsp]
  00b27	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00b2c	85 c0		 test	 eax, eax
  00b2e	0f 84 f6 00 00
	00		 je	 $LN38@s390_move_

; 411  :             {
; 412  :                 xpblk1 = (pte1 & ZPGETAB_PFRA) >> 12;

  00b34	8b 44 24 64	 mov	 eax, DWORD PTR pte1$[rsp]
  00b38	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00b3e	48 c1 e8 0c	 shr	 rax, 12
  00b42	89 84 24 84 00
	00 00		 mov	 DWORD PTR xpblk1$[rsp], eax

; 413  : #if defined(_FEATURE_SIE)
; 414  :                 if(SIE_MODE(regs))

  00b49	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b51	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00b57	d1 e8		 shr	 eax, 1
  00b59	83 e0 01	 and	 eax, 1
  00b5c	85 c0		 test	 eax, eax
  00b5e	74 42		 je	 SHORT $LN40@s390_move_

; 415  :                 {
; 416  :                     /* Add expanded storage origin for this guest */
; 417  :                     xpblk1 += regs->sie_xso;

  00b60	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR xpblk1$[rsp]
  00b67	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b6f	48 03 81 a0 08
	00 00		 add	 rax, QWORD PTR [rcx+2208]
  00b76	89 84 24 84 00
	00 00		 mov	 DWORD PTR xpblk1$[rsp], eax

; 418  :                     /* If the block lies beyond this guests limit
; 419  :                        then we must terminate the instruction */
; 420  :                     if(xpblk1 >= regs->sie_xsl)

  00b7d	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR xpblk1$[rsp]
  00b84	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b8c	48 3b 81 a8 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2216]
  00b93	72 0d		 jb	 SHORT $LN41@s390_move_

; 421  :                     {
; 422  :                         cc = 1;

  00b95	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 423  :                         goto mvpg_progck;

  00b9d	e9 de 04 00 00	 jmp	 $mvpg_progck$88
$LN41@s390_move_:
$LN40@s390_move_:

; 424  :                     }
; 425  :                 }
; 426  : #endif /*defined(_FEATURE_SIE)*/
; 427  : 
; 428  :                 rc = 0;

  00ba2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 429  :                 xpvalid1 = 1;

  00baa	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR xpvalid1$[rsp], 1

; 430  :                 xpkeya = raddr1 +

  00bb2	8b 44 24 5c	 mov	 eax, DWORD PTR vaddr1$[rsp]
  00bb6	25 00 f0 0f 00	 and	 eax, 1044480		; 000ff000H
  00bbb	c1 e8 09	 shr	 eax, 9
  00bbe	8b c0		 mov	 eax, eax
  00bc0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr1$[rsp]
  00bc5	48 8d 84 01 00
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1024]
  00bcd	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR xpkeya$[rsp], rax

; 431  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 432  :                                   2048;
; 433  : #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 434  :                 /* For ESA/390 mode, the XPTE lies directly beyond
; 435  :                    the PTE, and each entry is 12 bytes long, we must
; 436  :                    therefor add 1024 + 8 times the page index */
; 437  :                               1024 + ((vaddr1 & 0x000FF000) >> 9);
; 438  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 439  :                 if (xpkeya > regs->mainlim)

  00bd5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bdd	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00be4	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR xpkeya$[rsp], rax
  00bec	76 1b		 jbe	 SHORT $LN42@s390_move_

; 440  :                     regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  00bee	ba 05 00 00 00	 mov	 edx, 5
  00bf3	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bfb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c03	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN42@s390_move_:

; 441  :                 xpkey1 = regs->mainstor[xpkeya];

  00c09	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c11	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00c18	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR xpkeya$[rsp]
  00c20	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00c24	88 44 24 43	 mov	 BYTE PTR xpkey1$[rsp], al

; 442  : 
; 443  : /*DEBUG  logmsg("MVPG pte1 = " F_CREG ", xkey1 = %2.2X, xpblk1 = %5.5X, akey1 = %2.2X\n",
; 444  :                   pte1,xpkey1,xpblk1,akey1);  */
; 445  :             }

  00c28	eb 0d		 jmp	 SHORT $LN39@s390_move_
$LN38@s390_move_:

; 446  :             else
; 447  :             {
; 448  :                 cc = 1;

  00c2a	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 449  :                 goto mvpg_progck;

  00c32	e9 49 04 00 00	 jmp	 $mvpg_progck$88
$LN39@s390_move_:
$LN37@s390_move_:

; 450  :             }
; 451  :         }
; 452  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 453  : 
; 454  :         /* Program check if operand not valid in main or expanded */
; 455  :         if (rc)

  00c37	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00c3c	74 0d		 je	 SHORT $LN43@s390_move_

; 456  :         {
; 457  :             cc = 1;

  00c3e	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 458  :             goto mvpg_progck;

  00c46	e9 35 04 00 00	 jmp	 $mvpg_progck$88
$LN43@s390_move_:

; 459  :         }
; 460  : 
; 461  :         /* Program check if page protection or access-list controlled
; 462  :            protection applies to the first operand */
; 463  :         if (regs->dat.protect || (xpvalid1 && (pte1 & PAGETAB_PROT)))

  00c4b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c53	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00c59	d1 e8		 shr	 eax, 1
  00c5b	83 e0 03	 and	 eax, 3
  00c5e	85 c0		 test	 eax, eax
  00c60	75 18		 jne	 SHORT $LN45@s390_move_
  00c62	83 7c 24 58 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00c67	0f 84 8a 00 00
	00		 je	 $LN44@s390_move_
  00c6d	8b 44 24 64	 mov	 eax, DWORD PTR pte1$[rsp]
  00c71	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00c76	85 c0		 test	 eax, eax
  00c78	74 7d		 je	 SHORT $LN44@s390_move_
$LN45@s390_move_:

; 464  :         {
; 465  :             regs->TEA = vaddr1 | TEA_PROT_AP | regs->dat.stid;

  00c7a	8b 44 24 5c	 mov	 eax, DWORD PTR vaddr1$[rsp]
  00c7e	83 c8 04	 or	 eax, 4
  00c81	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c89	0b 81 20 08 00
	00		 or	 eax, DWORD PTR [rcx+2080]
  00c8f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c97	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 466  :             regs->excarid = (ACCESS_REGISTER_MODE(&regs->psw)) ? r1 : 0;

  00c9d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ca5	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00ca9	83 f8 40	 cmp	 eax, 64			; 00000040H
  00cac	75 0d		 jne	 SHORT $LN85@s390_move_
  00cae	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  00cb2	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv508[rsp], eax
  00cb9	eb 0b		 jmp	 SHORT $LN86@s390_move_
$LN85@s390_move_:
  00cbb	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv508[rsp], 0
$LN86@s390_move_:
  00cc6	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cce	0f b6 8c 24 9c
	00 00 00	 movzx	 ecx, BYTE PTR tv508[rsp]
  00cd6	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 467  :             regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  00cdc	ba 04 00 00 00	 mov	 edx, 4
  00ce1	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ce9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cf1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN44@s390_move_:
$LN16@s390_move_:

; 468  :         }
; 469  : 
; 470  :     } /* end if(!REAL_MODE) */
; 471  : 
; 472  : #if defined(FEATURE_EXPANDED_STORAGE)
; 473  :     /* Program check if both operands are in expanded storage,
; 474  :        or if first operand is in expanded storage and the Destination
; 475  :        Reference Intention (DRI) bit (register 0 bit 22) is set to one,
; 476  :        or if first operand is in expanded storage and PTE lock bit on,
; 477  :        or if first operand is in expanded storage and frame invalid */
; 478  :     if ((xpvalid1 && xpvalid2)
; 479  :         || (xpvalid1 && (regs->GR_L(0) & GR0_MVPG_DRI))
; 480  :         || (xpvalid1 && (pte1 & PAGETAB_PGLOCK))
; 481  :         || (xpvalid1 && (xpblk1 >= sysblk.xpndsize)))

  00cf7	83 7c 24 58 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00cfc	74 07		 je	 SHORT $LN48@s390_move_
  00cfe	83 7c 24 78 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00d03	75 57		 jne	 SHORT $LN47@s390_move_
$LN48@s390_move_:
  00d05	83 7c 24 58 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00d0a	74 21		 je	 SHORT $LN49@s390_move_
  00d0c	b8 08 00 00 00	 mov	 eax, 8
  00d11	48 6b c0 00	 imul	 rax, rax, 0
  00d15	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d1d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00d24	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00d29	85 c0		 test	 eax, eax
  00d2b	75 2f		 jne	 SHORT $LN47@s390_move_
$LN49@s390_move_:
  00d2d	83 7c 24 58 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00d32	74 0b		 je	 SHORT $LN50@s390_move_
  00d34	8b 44 24 64	 mov	 eax, DWORD PTR pte1$[rsp]
  00d38	83 e0 01	 and	 eax, 1
  00d3b	85 c0		 test	 eax, eax
  00d3d	75 1d		 jne	 SHORT $LN47@s390_move_
$LN50@s390_move_:
  00d3f	83 7c 24 58 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00d44	74 3f		 je	 SHORT $LN46@s390_move_
  00d46	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d4d	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  00d53	39 84 24 84 00
	00 00		 cmp	 DWORD PTR xpblk1$[rsp], eax
  00d5a	72 29		 jb	 SHORT $LN46@s390_move_
$LN47@s390_move_:

; 482  :     {
; 483  :         regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  00d5c	b8 11 00 00 00	 mov	 eax, 17
  00d61	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d69	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 484  :         rc = 2;

  00d70	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR rc$[rsp], 2

; 485  :         cc = 1;

  00d78	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 486  :         goto mvpg_progck;

  00d80	e9 fb 02 00 00	 jmp	 $mvpg_progck$88
$LN46@s390_move_:

; 487  :     }
; 488  :     /* More Program check checking, but at lower priority:
; 489  :        if second operand is in expanded storage and pte lock bit on, or
; 490  :        if second operand is in expanded storage and frame invalid */
; 491  :     if ((xpvalid2 && (pte2 & PAGETAB_PGLOCK))
; 492  :         || (xpvalid2 && (xpblk2 >= sysblk.xpndsize)))

  00d85	83 7c 24 78 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00d8a	74 0b		 je	 SHORT $LN53@s390_move_
  00d8c	8b 44 24 7c	 mov	 eax, DWORD PTR pte2$[rsp]
  00d90	83 e0 01	 and	 eax, 1
  00d93	85 c0		 test	 eax, eax
  00d95	75 1d		 jne	 SHORT $LN52@s390_move_
$LN53@s390_move_:
  00d97	83 7c 24 78 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00d9c	74 56		 je	 SHORT $LN51@s390_move_
  00d9e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00da5	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  00dab	39 84 24 80 00
	00 00		 cmp	 DWORD PTR xpblk2$[rsp], eax
  00db2	72 40		 jb	 SHORT $LN51@s390_move_
$LN52@s390_move_:

; 493  :     {
; 494  :         /* re-do translation to set up TEA */
; 495  :         rc = ARCH_DEP(translate_addr) (vaddr2, r2, regs, ACCTYPE_READ);

  00db4	41 b9 04 00 00
	00		 mov	 r9d, 4
  00dba	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00dc2	8b 54 24 50	 mov	 edx, DWORD PTR r2$[rsp]
  00dc6	8b 4c 24 60	 mov	 ecx, DWORD PTR vaddr2$[rsp]
  00dca	e8 00 00 00 00	 call	 s390_translate_addr
  00dcf	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 496  :         regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  00dd3	b8 11 00 00 00	 mov	 eax, 17
  00dd8	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00de0	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 497  :         cc = 1;

  00de7	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 498  :         goto mvpg_progck;

  00def	e9 8c 02 00 00	 jmp	 $mvpg_progck$88
$LN51@s390_move_:

; 499  :     }
; 500  : 
; 501  :     /* Perform protection checks */
; 502  :     if (xpvalid1)

  00df4	83 7c 24 58 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00df9	0f 84 85 00 00
	00		 je	 $LN54@s390_move_

; 503  :     {
; 504  :         /* Key check on expanded storage block if NoKey bit off in PTE */
; 505  :         if (akey1 != 0 && akey1 != (xpkey1 & STORKEY_KEY)
; 506  :             && (pte1 & PAGETAB_ESNK) == 0
; 507  :             && !((regs->CR(0) & CR0_STORE_OVRD) && ((xpkey1 & STORKEY_KEY) == 0x90)))

  00dff	0f b6 44 24 41	 movzx	 eax, BYTE PTR akey1$[rsp]
  00e04	85 c0		 test	 eax, eax
  00e06	74 6e		 je	 SHORT $LN56@s390_move_
  00e08	0f b6 44 24 41	 movzx	 eax, BYTE PTR akey1$[rsp]
  00e0d	0f b6 4c 24 43	 movzx	 ecx, BYTE PTR xpkey1$[rsp]
  00e12	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00e18	3b c1		 cmp	 eax, ecx
  00e1a	74 5a		 je	 SHORT $LN56@s390_move_
  00e1c	8b 44 24 64	 mov	 eax, DWORD PTR pte1$[rsp]
  00e20	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00e25	85 c0		 test	 eax, eax
  00e27	75 4d		 jne	 SHORT $LN56@s390_move_
  00e29	b8 08 00 00 00	 mov	 eax, 8
  00e2e	48 6b c0 01	 imul	 rax, rax, 1
  00e32	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e3a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00e41	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00e46	85 c0		 test	 eax, eax
  00e48	74 11		 je	 SHORT $LN57@s390_move_
  00e4a	0f b6 44 24 43	 movzx	 eax, BYTE PTR xpkey1$[rsp]
  00e4f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00e54	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  00e59	74 1b		 je	 SHORT $LN56@s390_move_
$LN57@s390_move_:

; 508  :         {
; 509  :             regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  00e5b	ba 04 00 00 00	 mov	 edx, 4
  00e60	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e68	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e70	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN56@s390_move_:

; 510  :         }
; 511  :         sk1=NULL;

  00e76	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR sk1$[rsp], 0

; 512  :     }

  00e82	eb 4b		 jmp	 SHORT $LN55@s390_move_
$LN54@s390_move_:

; 513  :     else
; 514  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 515  :     {
; 516  :         /* Obtain absolute address of main storage block,
; 517  :            check protection, and set reference and change bits */
; 518  :         main1 = MADDRL (vaddr1, _4K, r1, regs, ACCTYPE_WRITE_SKP, akey1);

  00e84	0f b6 44 24 41	 movzx	 eax, BYTE PTR akey1$[rsp]
  00e89	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00e8d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00e95	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00e9d	44 8b 44 24 4c	 mov	 r8d, DWORD PTR r1$[rsp]
  00ea2	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00ea7	8b 4c 24 5c	 mov	 ecx, DWORD PTR vaddr1$[rsp]
  00eab	e8 00 00 00 00	 call	 s390_maddr_l
  00eb0	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR main1$[rsp], rax

; 519  :         sk1 = regs->dat.storkey;

  00eb8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ec0	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00ec7	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR sk1$[rsp], rax
$LN55@s390_move_:

; 520  :     }
; 521  : 
; 522  : #if defined(FEATURE_EXPANDED_STORAGE)
; 523  :     if (xpvalid2)

  00ecf	83 7c 24 78 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00ed4	74 53		 je	 SHORT $LN58@s390_move_

; 524  :     {
; 525  :         /* Key check on expanded storage block if NoKey bit off in PTE */
; 526  :         if (akey2 != 0 && (xpkey2 & STORKEY_FETCH)
; 527  :             && akey2 != (xpkey2 & STORKEY_KEY)
; 528  :             && (pte2 & PAGETAB_ESNK) == 0)

  00ed6	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey2$[rsp]
  00edb	85 c0		 test	 eax, eax
  00edd	74 48		 je	 SHORT $LN60@s390_move_
  00edf	0f b6 44 24 44	 movzx	 eax, BYTE PTR xpkey2$[rsp]
  00ee4	83 e0 08	 and	 eax, 8
  00ee7	85 c0		 test	 eax, eax
  00ee9	74 3c		 je	 SHORT $LN60@s390_move_
  00eeb	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey2$[rsp]
  00ef0	0f b6 4c 24 44	 movzx	 ecx, BYTE PTR xpkey2$[rsp]
  00ef5	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00efb	3b c1		 cmp	 eax, ecx
  00efd	74 28		 je	 SHORT $LN60@s390_move_
  00eff	8b 44 24 7c	 mov	 eax, DWORD PTR pte2$[rsp]
  00f03	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00f08	85 c0		 test	 eax, eax
  00f0a	75 1b		 jne	 SHORT $LN60@s390_move_

; 529  :         {
; 530  :             regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  00f0c	ba 04 00 00 00	 mov	 edx, 4
  00f11	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f19	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f21	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN60@s390_move_:

; 531  :         }
; 532  :     }

  00f27	eb 51		 jmp	 SHORT $LN59@s390_move_
$LN58@s390_move_:

; 533  :     else
; 534  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 535  :     {
; 536  :         /* Obtain absolute address of main storage block,
; 537  :            check protection, and set reference bit.
; 538  :            Use last byte of page to avoid FPO area.  */
; 539  :         main2 = MADDR (vaddr2 | 0xFFF, r2, regs, ACCTYPE_READ, akey2);

  00f29	8b 44 24 60	 mov	 eax, DWORD PTR vaddr2$[rsp]
  00f2d	0d ff 0f 00 00	 or	 eax, 4095		; 00000fffH
  00f32	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR akey2$[rsp]
  00f37	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00f3b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00f43	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f4b	44 8b 44 24 50	 mov	 r8d, DWORD PTR r2$[rsp]
  00f50	ba 01 00 00 00	 mov	 edx, 1
  00f55	8b c8		 mov	 ecx, eax
  00f57	e8 00 00 00 00	 call	 s390_maddr_l
  00f5c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR main2$[rsp], rax

; 540  :         main2 -= 0xFFF;

  00f64	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR main2$[rsp]
  00f6c	48 2d ff 0f 00
	00		 sub	 rax, 4095		; 00000fffH
  00f72	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR main2$[rsp], rax
$LN59@s390_move_:

; 541  :     }
; 542  : 
; 543  : #if defined(FEATURE_EXPANDED_STORAGE)
; 544  :     /* Perform page movement */
; 545  :     if (xpvalid2)

  00f7a	83 7c 24 78 00	 cmp	 DWORD PTR xpvalid2$[rsp], 0
  00f7f	74 68		 je	 SHORT $LN61@s390_move_

; 546  :     {
; 547  :         /* Set the main storage reference and change bits */
; 548  :         ARCH_DEP( or_storage_key_by_ptr )( sk1, (STORKEY_REF | STORKEY_CHANGE) );

  00f81	b2 06		 mov	 dl, 6
  00f83	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR sk1$[rsp]
  00f8b	e8 00 00 00 00	 call	 s390_or_storage_key_by_ptr

; 549  : 
; 550  :         /* Set Expanded Storage reference bit in the PTE */
; 551  :         STORE_W(regs->mainstor + raddr2, pte2 | PAGETAB_ESREF);

  00f90	8b 44 24 7c	 mov	 eax, DWORD PTR pte2$[rsp]
  00f94	83 c8 04	 or	 eax, 4
  00f97	8b c8		 mov	 ecx, eax
  00f99	e8 00 00 00 00	 call	 _byteswap_ulong
  00f9e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fa6	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00fad	48 03 4c 24 68	 add	 rcx, QWORD PTR raddr2$[rsp]
  00fb2	8b d0		 mov	 edx, eax
  00fb4	e8 00 00 00 00	 call	 store_fw_noswap

; 552  : 
; 553  :         /* Move 4K bytes from expanded storage to main storage */
; 554  :         memcpy (main1,

  00fb9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR xpblk2$[rsp]
  00fc0	48 c1 e0 0c	 shl	 rax, 12
  00fc4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00fcb	48 03 81 b0 00
	00 00		 add	 rax, QWORD PTR [rcx+176]
  00fd2	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR main1$[rsp]
  00fda	48 8b f0	 mov	 rsi, rax
  00fdd	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00fe2	f3 a4		 rep movsb

; 555  :                 sysblk.xpndstor + ((size_t)xpblk2 << XSTORE_PAGESHIFT),
; 556  :                 XSTORE_PAGESIZE);
; 557  :     }

  00fe4	e9 86 00 00 00	 jmp	 $LN62@s390_move_
$LN61@s390_move_:

; 558  :     else if (xpvalid1)

  00fe9	83 7c 24 58 00	 cmp	 DWORD PTR xpvalid1$[rsp], 0
  00fee	74 59		 je	 SHORT $LN63@s390_move_

; 559  :     {
; 560  :         /* Set Expanded Storage reference and change bits in the PTE */
; 561  :         STORE_W(regs->mainstor + raddr1, pte1 | PAGETAB_ESREF | PAGETAB_ESCHA);

  00ff0	8b 44 24 64	 mov	 eax, DWORD PTR pte1$[rsp]
  00ff4	83 c8 04	 or	 eax, 4
  00ff7	83 c8 02	 or	 eax, 2
  00ffa	8b c8		 mov	 ecx, eax
  00ffc	e8 00 00 00 00	 call	 _byteswap_ulong
  01001	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01009	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  01010	48 03 4c 24 70	 add	 rcx, QWORD PTR raddr1$[rsp]
  01015	8b d0		 mov	 edx, eax
  01017	e8 00 00 00 00	 call	 store_fw_noswap

; 562  : 
; 563  :         /* Move 4K bytes from main storage to expanded storage */
; 564  :         memcpy (sysblk.xpndstor + ((size_t)xpblk1 << XSTORE_PAGESHIFT),

  0101c	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR xpblk1$[rsp]
  01023	48 c1 e0 0c	 shl	 rax, 12
  01027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0102e	48 03 81 b0 00
	00 00		 add	 rax, QWORD PTR [rcx+176]
  01035	48 8b f8	 mov	 rdi, rax
  01038	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR main2$[rsp]
  01040	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  01045	f3 a4		 rep movsb

; 565  :                 main2,
; 566  :                 XSTORE_PAGESIZE);
; 567  :     }

  01047	eb 26		 jmp	 SHORT $LN64@s390_move_
$LN63@s390_move_:

; 568  :     else
; 569  : #endif /*defined(FEATURE_EXPANDED_STORAGE)*/
; 570  :     {
; 571  :         /* Set the main storage reference and change bits */
; 572  :         ARCH_DEP( or_storage_key_by_ptr )( sk1, (STORKEY_REF | STORKEY_CHANGE) );

  01049	b2 06		 mov	 dl, 6
  0104b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR sk1$[rsp]
  01053	e8 00 00 00 00	 call	 s390_or_storage_key_by_ptr

; 573  : 
; 574  :         /* Move 4K bytes from main storage to main storage */
; 575  :         memcpy (main1, main2, XSTORE_PAGESIZE);

  01058	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR main1$[rsp]
  01060	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR main2$[rsp]
  01068	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0106d	f3 a4		 rep movsb
$LN64@s390_move_:
$LN62@s390_move_:

; 576  :     }
; 577  : 
; 578  :     /* Return condition code zero */
; 579  :     regs->psw.cc = 0;

  0106f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01077	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 580  :     return;

  0107b	e9 46 01 00 00	 jmp	 $LN1@s390_move_
$mvpg_progck$88:
$LN7@s390_move_:

; 581  : 
; 582  : mvpg_progck:
; 583  : 
; 584  :     PTT_ERR("*MVPG",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  01080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01087	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0108a	48 83 e0 10	 and	 rax, 16
  0108e	48 85 c0	 test	 rax, rax
  01091	74 68		 je	 SHORT $LN65@s390_move_
  01093	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0109b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  010a1	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR r2$[rsp]
  010a6	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  010ae	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  010b5	48 63 54 24 4c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  010ba	48 8b bc 24 18
	01 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  010c2	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  010c9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  010d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  010d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179789
  010de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010e3	44 8b c9	 mov	 r9d, ecx
  010e6	44 8b c2	 mov	 r8d, edx
  010e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179790
  010f0	b9 10 00 00 00	 mov	 ecx, 16
  010f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN65@s390_move_:
  010fb	33 c0		 xor	 eax, eax
  010fd	85 c0		 test	 eax, eax
  010ff	0f 85 7b ff ff
	ff		 jne	 $LN7@s390_move_

; 585  : 
; 586  :     /* If page translation exception (PTE invalid) and Condition Code
; 587  :         Option (CCO) bit (register 0 bit 23) is set, return condition code */
; 588  :     if ((regs->GR_L(0) & GR0_MVPG_CCO)
; 589  :         && regs->dat.xcode == PGM_PAGE_TRANSLATION_EXCEPTION
; 590  :         && rc == 2)

  01105	b8 08 00 00 00	 mov	 eax, 8
  0110a	48 6b c0 00	 imul	 rax, rax, 0
  0110e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01116	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0111d	25 00 01 00 00	 and	 eax, 256		; 00000100H
  01122	85 c0		 test	 eax, eax
  01124	74 2d		 je	 SHORT $LN66@s390_move_
  01126	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0112e	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  01135	83 f8 11	 cmp	 eax, 17
  01138	75 19		 jne	 SHORT $LN66@s390_move_
  0113a	83 7c 24 48 02	 cmp	 DWORD PTR rc$[rsp], 2
  0113f	75 12		 jne	 SHORT $LN66@s390_move_

; 591  :     {
; 592  :         regs->psw.cc = cc;

  01141	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01149	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR cc$[rsp]
  0114e	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 593  :         return;

  01151	eb 73		 jmp	 SHORT $LN1@s390_move_
$LN66@s390_move_:

; 594  :     }
; 595  : 
; 596  :     /* Otherwise generate program check */
; 597  :     /* (Bit 29 of TEA is on for PIC 11 & operand ID also stored) */
; 598  :     if (regs->dat.xcode == PGM_PAGE_TRANSLATION_EXCEPTION)

  01153	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0115b	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  01162	83 f8 11	 cmp	 eax, 17
  01165	75 38		 jne	 SHORT $LN67@s390_move_

; 599  :     {
; 600  :         regs->TEA |= TEA_MVPG;

  01167	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0116f	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  01175	83 c8 04	 or	 eax, 4
  01178	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01180	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 601  :         regs->opndrid = (r1 << 4) | r2;

  01186	8b 44 24 4c	 mov	 eax, DWORD PTR r1$[rsp]
  0118a	c1 e0 04	 shl	 eax, 4
  0118d	0b 44 24 50	 or	 eax, DWORD PTR r2$[rsp]
  01191	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01199	88 81 3f 08 00
	00		 mov	 BYTE PTR [rcx+2111], al
$LN67@s390_move_:

; 602  :     }
; 603  :     regs->program_interrupt (regs, regs->dat.xcode);

  0119f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011a7	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  011ae	8b d0		 mov	 edx, eax
  011b0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011b8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011c0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN1@s390_move_:
$LN68@s390_move_:

; 604  : 
; 605  : } /* end DEF_INST(move_page) */

  011c6	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  011cd	5f		 pop	 rdi
  011ce	5e		 pop	 rsi
  011cf	c3		 ret	 0
s390_move_page ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\xstore.c
_TEXT	SEGMENT
xaddr$ = 64
r2$ = 68
r1$ = 72
i$1 = 76
vaddr$ = 80
xoffs$ = 88
maddr$ = 96
inst$ = 144
regs$ = 152
s390_page_out PROC

; 99   : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 100  : int     r1, r2;                         /* Values of R fields        */
; 101  : VADR    vaddr;                          /* Virtual storage address   */
; 102  : BYTE   *maddr;                          /* Main storage address      */
; 103  : U32     xaddr;                          /* Expanded storage block#   */
; 104  : size_t  xoffs;                          /* Byte offset into xpndstor */
; 105  : 
; 106  :     RRE(inst, regs, r1, r2);

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	48 6b c0 03	 imul	 rax, rax, 3
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00025	89 44 24 4c	 mov	 DWORD PTR i$1[rsp], eax
  00029	8b 44 24 4c	 mov	 eax, DWORD PTR i$1[rsp]
  0002d	83 e0 0f	 and	 eax, 15
  00030	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00034	8b 44 24 4c	 mov	 eax, DWORD PTR i$1[rsp]
  00038	c1 f8 04	 sar	 eax, 4
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_page_:
  00042	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005e	33 c0		 xor	 eax, eax
  00060	83 f8 04	 cmp	 eax, 4
  00063	74 0f		 je	 SHORT $LN11@s390_page_
  00065	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s390_page_:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 c8		 jne	 SHORT $LN4@s390_page_

; 107  :     PER_ZEROADDR_CHECK( regs, r1 );
; 108  : 
; 109  :     TXF_INSTR_CHECK( regs );
; 110  :     PRIV_CHECK(regs);

  0007a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00086	83 e0 01	 and	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	74 1b		 je	 SHORT $LN12@s390_page_
  0008d	ba 02 00 00 00	 mov	 edx, 2
  00092	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_page_:

; 111  : 
; 112  :     if(SIE_STATE_BIT_ON(regs, IC3, PGX))

  000a8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b6	d1 e8		 shr	 eax, 1
  000b8	83 e0 01	 and	 eax, 1
  000bb	85 c0		 test	 eax, eax
  000bd	74 3f		 je	 SHORT $LN13@s390_page_
  000bf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000ce	b9 01 00 00 00	 mov	 ecx, 1
  000d3	48 6b c9 03	 imul	 rcx, rcx, 3
  000d7	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  000dc	83 e0 02	 and	 eax, 2
  000df	85 c0		 test	 eax, eax
  000e1	74 1b		 je	 SHORT $LN13@s390_page_

; 113  :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  000e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000f1	ba fc ff ff ff	 mov	 edx, -4
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	e8 00 00 00 00	 call	 longjmp
$LN13@s390_page_:

; 114  : 
; 115  : #if defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)
; 116  :     /* Cannot perform xstore page movement in XC mode */
; 117  :     if(SIE_STATE_BIT_ON(regs, MX, XC))

  000fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00106	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010c	d1 e8		 shr	 eax, 1
  0010e	83 e0 01	 and	 eax, 1
  00111	85 c0		 test	 eax, eax
  00113	74 35		 je	 SHORT $LN14@s390_page_
  00115	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00124	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00128	83 e0 01	 and	 eax, 1
  0012b	85 c0		 test	 eax, eax
  0012d	74 1b		 je	 SHORT $LN14@s390_page_

; 118  :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  0012f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0013d	ba fc ff ff ff	 mov	 edx, -4
  00142	48 8b c8	 mov	 rcx, rax
  00145	e8 00 00 00 00	 call	 longjmp
$LN14@s390_page_:

; 119  : #endif /*defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 120  : 
; 121  :     /* expanded storage block number */
; 122  :     xaddr = regs->GR_L(r2);

  0014a	48 63 44 24 44	 movsxd	 rax, DWORD PTR r2$[rsp]
  0014f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0015e	89 44 24 40	 mov	 DWORD PTR xaddr$[rsp], eax

; 123  : 
; 124  :     if(SIE_MODE(regs))

  00162	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	0f 84 c7 00 00
	00		 je	 $LN15@s390_page_

; 125  :     {
; 126  :         xaddr += regs->sie_xso;

  0017d	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  00181	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	48 03 81 a0 08
	00 00		 add	 rax, QWORD PTR [rcx+2208]
  00190	89 44 24 40	 mov	 DWORD PTR xaddr$[rsp], eax

; 127  :         if(xaddr >= regs->sie_xsl)

  00194	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  00198	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 3b 81 a8 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2216]
  001a7	0f 82 97 00 00
	00		 jb	 $LN16@s390_page_
$LN7@s390_page_:

; 128  :         {
; 129  :             PTT_ERR("*PGOUT",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  001ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b7	48 83 e0 10	 and	 rax, 16
  001bb	48 85 c0	 test	 rax, rax
  001be	74 69		 je	 SHORT $LN17@s390_page_
  001c0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001ce	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR r2$[rsp]
  001d3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001db	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  001e2	48 63 54 24 48	 movsxd	 rdx, DWORD PTR r1$[rsp]
  001e7	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ef	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  001f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00200	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00205	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179645
  0020c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00211	44 8b c9	 mov	 r9d, ecx
  00214	44 8b c2	 mov	 r8d, edx
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179646
  0021e	b9 10 00 00 00	 mov	 ecx, 16
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN17@s390_page_:
  00229	33 c0		 xor	 eax, eax
  0022b	85 c0		 test	 eax, eax
  0022d	0f 85 7a ff ff
	ff		 jne	 $LN7@s390_page_

; 130  :             regs->psw.cc = 3;

  00233	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023b	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 131  :             return;

  0023f	e9 47 01 00 00	 jmp	 $LN1@s390_page_
$LN16@s390_page_:
$LN15@s390_page_:

; 132  :         }
; 133  :     }
; 134  : 
; 135  :     /* If the expanded storage block is not configured then
; 136  :        terminate with cc3 */
; 137  :     if (xaddr >= sysblk.xpndsize)

  00244	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0024b	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  00251	39 44 24 40	 cmp	 DWORD PTR xaddr$[rsp], eax
  00255	0f 82 97 00 00
	00		 jb	 $LN18@s390_page_
$LN10@s390_page_:

; 138  :     {
; 139  :         PTT_ERR("*PGOUT",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  0025b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00262	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00265	48 83 e0 10	 and	 rax, 16
  00269	48 85 c0	 test	 rax, rax
  0026c	74 69		 je	 SHORT $LN19@s390_page_
  0026e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00276	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0027c	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00281	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00289	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00290	48 63 54 24 48	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00295	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0029d	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  002a5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179649
  002ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bf	44 8b c9	 mov	 r9d, ecx
  002c2	44 8b c2	 mov	 r8d, edx
  002c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179650
  002cc	b9 10 00 00 00	 mov	 ecx, 16
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@s390_page_:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	0f 85 7a ff ff
	ff		 jne	 $LN10@s390_page_

; 140  :         regs->psw.cc = 3;

  002e1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e9	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 141  :         return;

  002ed	e9 99 00 00 00	 jmp	 $LN1@s390_page_
$LN18@s390_page_:

; 142  :     }
; 143  : 
; 144  :     /* Byte offset in expanded storage */
; 145  :     xoffs = (size_t)xaddr << XSTORE_PAGESHIFT;

  002f2	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  002f6	48 c1 e0 0c	 shl	 rax, 12
  002fa	48 89 44 24 58	 mov	 QWORD PTR xoffs$[rsp], rax

; 146  : 
; 147  :     /* Obtain abs address, verify access and set ref/change bits */
; 148  :     vaddr = (regs->GR(r1) & ADDRESS_MAXWRAP(regs)) & XSTORE_PAGEMASK;

  002ff	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00304	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030c	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00314	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0031a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00321	23 c2		 and	 eax, edx
  00323	8b c0		 mov	 eax, eax
  00325	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0032b	89 44 24 50	 mov	 DWORD PTR vaddr$[rsp], eax

; 149  :     maddr = MADDR (vaddr, USE_REAL_ADDR, regs, ACCTYPE_READ, 0);

  0032f	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00334	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0033c	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00344	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0034a	ba 01 00 00 00	 mov	 edx, 1
  0034f	8b 4c 24 50	 mov	 ecx, DWORD PTR vaddr$[rsp]
  00353	e8 00 00 00 00	 call	 s390_maddr_l
  00358	48 89 44 24 60	 mov	 QWORD PTR maddr$[rsp], rax

; 150  : 
; 151  :     /* Copy data from main to expanded */
; 152  :     memcpy (sysblk.xpndstor + xoffs, maddr, XSTORE_PAGESIZE);

  0035d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00364	48 8b 80 b0 00
	00 00		 mov	 rax, QWORD PTR [rax+176]
  0036b	48 03 44 24 58	 add	 rax, QWORD PTR xoffs$[rsp]
  00370	48 8b f8	 mov	 rdi, rax
  00373	48 8b 74 24 60	 mov	 rsi, QWORD PTR maddr$[rsp]
  00378	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0037d	f3 a4		 rep movsb

; 153  : 
; 154  :     /* cc0 means pgout ok */
; 155  :     regs->psw.cc = 0;

  0037f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00387	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s390_page_:
$LN20@s390_page_:

; 156  : 
; 157  : } /* end DEF_INST(page_out) */

  0038b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0038f	5f		 pop	 rdi
  00390	5e		 pop	 rsi
  00391	c3		 ret	 0
s390_page_out ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\xstore.c
_TEXT	SEGMENT
xaddr$ = 64
r2$ = 68
r1$ = 72
i$1 = 76
vaddr$ = 80
xoffs$ = 88
maddr$ = 96
inst$ = 144
regs$ = 152
s390_page_in PROC

; 32   : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 33   : int     r1, r2;                         /* Values of R fields        */
; 34   : VADR    vaddr;                          /* Virtual storage address   */
; 35   : BYTE   *maddr;                          /* Main storage address      */
; 36   : U32     xaddr;                          /* Expanded storage block#   */
; 37   : size_t  xoffs;                          /* Byte offset into xpndstor */
; 38   : 
; 39   :     RRE(inst, regs, r1, r2);

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	48 6b c0 03	 imul	 rax, rax, 3
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00025	89 44 24 4c	 mov	 DWORD PTR i$1[rsp], eax
  00029	8b 44 24 4c	 mov	 eax, DWORD PTR i$1[rsp]
  0002d	83 e0 0f	 and	 eax, 15
  00030	89 44 24 44	 mov	 DWORD PTR r2$[rsp], eax
  00034	8b 44 24 4c	 mov	 eax, DWORD PTR i$1[rsp]
  00038	c1 f8 04	 sar	 eax, 4
  0003b	83 e0 0f	 and	 eax, 15
  0003e	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_page_:
  00042	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 83 c0 04	 add	 rax, 4
  00052	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005e	33 c0		 xor	 eax, eax
  00060	83 f8 04	 cmp	 eax, 4
  00063	74 0f		 je	 SHORT $LN11@s390_page_
  00065	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@s390_page_:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 c8		 jne	 SHORT $LN4@s390_page_

; 40   :     PER_ZEROADDR_CHECK( regs, r1 );
; 41   : 
; 42   :     TXF_INSTR_CHECK( regs );
; 43   :     PRIV_CHECK(regs);

  0007a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00086	83 e0 01	 and	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	74 1b		 je	 SHORT $LN12@s390_page_
  0008d	ba 02 00 00 00	 mov	 edx, 2
  00092	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_page_:

; 44   : 
; 45   :     if(SIE_STATE_BIT_ON(regs, IC3, PGX))

  000a8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000b6	d1 e8		 shr	 eax, 1
  000b8	83 e0 01	 and	 eax, 1
  000bb	85 c0		 test	 eax, eax
  000bd	74 3f		 je	 SHORT $LN13@s390_page_
  000bf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000ce	b9 01 00 00 00	 mov	 ecx, 1
  000d3	48 6b c9 03	 imul	 rcx, rcx, 3
  000d7	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  000dc	83 e0 02	 and	 eax, 2
  000df	85 c0		 test	 eax, eax
  000e1	74 1b		 je	 SHORT $LN13@s390_page_

; 46   :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  000e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000f1	ba fc ff ff ff	 mov	 edx, -4
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	e8 00 00 00 00	 call	 longjmp
$LN13@s390_page_:

; 47   : 
; 48   : #if defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)
; 49   :     /* Cannot perform xstore page movement in XC mode */
; 50   :     if(SIE_STATE_BIT_ON(regs, MX, XC))

  000fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00106	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010c	d1 e8		 shr	 eax, 1
  0010e	83 e0 01	 and	 eax, 1
  00111	85 c0		 test	 eax, eax
  00113	74 35		 je	 SHORT $LN14@s390_page_
  00115	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00124	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00128	83 e0 01	 and	 eax, 1
  0012b	85 c0		 test	 eax, eax
  0012d	74 1b		 je	 SHORT $LN14@s390_page_

; 51   :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  0012f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0013d	ba fc ff ff ff	 mov	 edx, -4
  00142	48 8b c8	 mov	 rcx, rax
  00145	e8 00 00 00 00	 call	 longjmp
$LN14@s390_page_:

; 52   : #endif /*defined(FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE)*/
; 53   : 
; 54   :     /* expanded storage block number */
; 55   :     xaddr = regs->GR_L(r2);

  0014a	48 63 44 24 44	 movsxd	 rax, DWORD PTR r2$[rsp]
  0014f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0015e	89 44 24 40	 mov	 DWORD PTR xaddr$[rsp], eax

; 56   : 
; 57   :     if(SIE_MODE(regs))

  00162	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	0f 84 c7 00 00
	00		 je	 $LN15@s390_page_

; 58   :     {
; 59   :         xaddr += regs->sie_xso;

  0017d	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  00181	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	48 03 81 a0 08
	00 00		 add	 rax, QWORD PTR [rcx+2208]
  00190	89 44 24 40	 mov	 DWORD PTR xaddr$[rsp], eax

; 60   :         if(xaddr >= regs->sie_xsl)

  00194	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  00198	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 3b 81 a8 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2216]
  001a7	0f 82 97 00 00
	00		 jb	 $LN16@s390_page_
$LN7@s390_page_:

; 61   :         {
; 62   :             PTT_ERR("*PGIN",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  001ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b7	48 83 e0 10	 and	 rax, 16
  001bb	48 85 c0	 test	 rax, rax
  001be	74 69		 je	 SHORT $LN17@s390_page_
  001c0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001ce	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR r2$[rsp]
  001d3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001db	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  001e2	48 63 54 24 48	 movsxd	 rdx, DWORD PTR r1$[rsp]
  001e7	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ef	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  001f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00200	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00205	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179597
  0020c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00211	44 8b c9	 mov	 r9d, ecx
  00214	44 8b c2	 mov	 r8d, edx
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179598
  0021e	b9 10 00 00 00	 mov	 ecx, 16
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN17@s390_page_:
  00229	33 c0		 xor	 eax, eax
  0022b	85 c0		 test	 eax, eax
  0022d	0f 85 7a ff ff
	ff		 jne	 $LN7@s390_page_

; 63   :             regs->psw.cc = 3;

  00233	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023b	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 64   :             return;

  0023f	e9 47 01 00 00	 jmp	 $LN1@s390_page_
$LN16@s390_page_:
$LN15@s390_page_:

; 65   :         }
; 66   :     }
; 67   : 
; 68   :     /* If the expanded storage block is not configured then
; 69   :        terminate with cc3 */
; 70   :     if (xaddr >= sysblk.xpndsize)

  00244	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0024b	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  00251	39 44 24 40	 cmp	 DWORD PTR xaddr$[rsp], eax
  00255	0f 82 97 00 00
	00		 jb	 $LN18@s390_page_
$LN10@s390_page_:

; 71   :     {
; 72   :         PTT_ERR("*PGIN",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  0025b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00262	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00265	48 83 e0 10	 and	 rax, 16
  00269	48 85 c0	 test	 rax, rax
  0026c	74 69		 je	 SHORT $LN19@s390_page_
  0026e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00276	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0027c	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00281	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00289	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00290	48 63 54 24 48	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00295	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0029d	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  002a5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179601
  002ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bf	44 8b c9	 mov	 r9d, ecx
  002c2	44 8b c2	 mov	 r8d, edx
  002c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179602
  002cc	b9 10 00 00 00	 mov	 ecx, 16
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@s390_page_:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	0f 85 7a ff ff
	ff		 jne	 $LN10@s390_page_

; 73   :         regs->psw.cc = 3;

  002e1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e9	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 74   :         return;

  002ed	e9 99 00 00 00	 jmp	 $LN1@s390_page_
$LN18@s390_page_:

; 75   :     }
; 76   : 
; 77   :     /* Byte offset in expanded storage */
; 78   :     xoffs = (size_t)xaddr << XSTORE_PAGESHIFT;

  002f2	8b 44 24 40	 mov	 eax, DWORD PTR xaddr$[rsp]
  002f6	48 c1 e0 0c	 shl	 rax, 12
  002fa	48 89 44 24 58	 mov	 QWORD PTR xoffs$[rsp], rax

; 79   : 
; 80   :     /* Obtain abs address, verify access and set ref/change bits */
; 81   :     vaddr = (regs->GR(r1) & ADDRESS_MAXWRAP(regs)) & XSTORE_PAGEMASK;

  002ff	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00304	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030c	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00314	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0031a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00321	23 c2		 and	 eax, edx
  00323	8b c0		 mov	 eax, eax
  00325	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0032b	89 44 24 50	 mov	 DWORD PTR vaddr$[rsp], eax

; 82   :     maddr = MADDRL (vaddr, 4096, USE_REAL_ADDR, regs, ACCTYPE_WRITE, 0);

  0032f	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00334	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0033c	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00344	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0034a	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0034f	8b 4c 24 50	 mov	 ecx, DWORD PTR vaddr$[rsp]
  00353	e8 00 00 00 00	 call	 s390_maddr_l
  00358	48 89 44 24 60	 mov	 QWORD PTR maddr$[rsp], rax

; 83   : 
; 84   :     /* Copy data from expanded to main */
; 85   :     memcpy (maddr, sysblk.xpndstor + xoffs, XSTORE_PAGESIZE);

  0035d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00364	48 8b 80 b0 00
	00 00		 mov	 rax, QWORD PTR [rax+176]
  0036b	48 03 44 24 58	 add	 rax, QWORD PTR xoffs$[rsp]
  00370	48 8b 7c 24 60	 mov	 rdi, QWORD PTR maddr$[rsp]
  00375	48 8b f0	 mov	 rsi, rax
  00378	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0037d	f3 a4		 rep movsb

; 86   : 
; 87   :     /* cc0 means pgin ok */
; 88   :     regs->psw.cc = 0;

  0037f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00387	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s390_page_:
$LN20@s390_page_:

; 89   : 
; 90   : } /* end DEF_INST(page_in) */

  0038b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0038f	5f		 pop	 rdi
  00390	5e		 pop	 rsi
  00391	c3		 ret	 0
s390_page_in ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
n$ = 36
mask$ = 40
i_regs$ = 48
tv176 = 56
tv181 = 64
regs$ = 96
location$ = 104
synchronize_cpus PROC

; 201  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 202  :     int i, n = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 203  :     REGS*  i_regs;
; 204  : 
; 205  :     CPU_BITMAP mask = sysblk.started_mask;

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001d	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00024	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 206  : 
; 207  :     /* Deselect current processor and waiting processors from mask */
; 208  :     mask &= ~(sysblk.waiting_mask | HOSTREGS->cpubit);

  00029	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  00047	48 0b c8	 or	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 f7 d0	 not	 rax
  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mask$[rsp]
  00055	48 23 c8	 and	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 209  : 
; 210  :     /* Deselect processors at a syncpoint and count active processors
; 211  :      */
; 212  :     for (i=0; mask && i < sysblk.hicpu; ++i)

  00060	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00068	eb 0a		 jmp	 SHORT $LN4@synchroniz
$LN2@synchroniz:
  0006a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0006e	ff c0		 inc	 eax
  00070	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@synchroniz:
  00074	48 83 7c 24 28
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0007a	0f 84 04 01 00
	00		 je	 $LN3@synchroniz
  00080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00087	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  0008d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00091	0f 8d ed 00 00
	00		 jge	 $LN3@synchroniz

; 213  :     {
; 214  :         i_regs = sysblk.regs[i];

  00097	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a3	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000ab	48 89 44 24 30	 mov	 QWORD PTR i_regs$[rsp], rax

; 215  : 
; 216  :         if (mask & CPU_BIT( i ))

  000b0	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 89 4c 24 38	 mov	 QWORD PTR tv176[rsp], rcx
  000be	0f b6 c8	 movzx	 ecx, al
  000c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv176[rsp]
  000c6	48 d3 e0	 shl	 rax, cl
  000c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mask$[rsp]
  000ce	48 23 c8	 and	 rcx, rax
  000d1	48 8b c1	 mov	 rax, rcx
  000d4	48 85 c0	 test	 rax, rax
  000d7	0f 84 a2 00 00
	00		 je	 $LN11@synchroniz

; 217  :         {
; 218  :             if (AT_SYNCPOINT( i_regs ))

  000dd	48 8b 44 24 30	 mov	 rax, QWORD PTR i_regs$[rsp]
  000e2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e9	0f b6 80 f0 08
	00 00		 movzx	 eax, BYTE PTR [rax+2288]
  000f0	85 c0		 test	 eax, eax
  000f2	74 2b		 je	 SHORT $LN12@synchroniz

; 219  :             {
; 220  :                 /* Remove CPU already at syncpoint */
; 221  :                 mask ^= CPU_BIT(i);

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f8	b9 01 00 00 00	 mov	 ecx, 1
  000fd	48 89 4c 24 40	 mov	 QWORD PTR tv181[rsp], rcx
  00102	0f b6 c8	 movzx	 ecx, al
  00105	48 8b 44 24 40	 mov	 rax, QWORD PTR tv181[rsp]
  0010a	48 d3 e0	 shl	 rax, cl
  0010d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mask$[rsp]
  00112	48 33 c8	 xor	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 222  :             }

  0011d	eb 60		 jmp	 SHORT $LN13@synchroniz
$LN12@synchroniz:

; 223  :             else
; 224  :             {
; 225  :                 /* Update count of active processors */
; 226  :                 ++n;

  0011f	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00123	ff c0		 inc	 eax
  00125	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
$LN7@synchroniz:

; 227  : 
; 228  :                 /* Test and set interrupt pending conditions */
; 229  :                 ON_IC_INTERRUPT( i_regs );

  00129	48 8b 44 24 30	 mov	 rax, QWORD PTR i_regs$[rsp]
  0012e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00131	0f ba e8 1f	 bts	 eax, 31
  00135	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i_regs$[rsp]
  0013a	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 e6		 jne	 SHORT $LN7@synchroniz

; 230  : 
; 231  :                 if (SIE_MODE( i_regs ))

  00143	48 8b 44 24 30	 mov	 rax, QWORD PTR i_regs$[rsp]
  00148	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014e	d1 e8		 shr	 eax, 1
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 28		 je	 SHORT $LN14@synchroniz
$LN10@synchroniz:

; 232  :                     ON_IC_INTERRUPT( GUEST( i_regs ));

  00157	48 8b 44 24 30	 mov	 rax, QWORD PTR i_regs$[rsp]
  0015c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00163	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00166	0f ba e8 1f	 bts	 eax, 31
  0016a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i_regs$[rsp]
  0016f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00176	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00179	33 c0		 xor	 eax, eax
  0017b	85 c0		 test	 eax, eax
  0017d	75 d8		 jne	 SHORT $LN10@synchroniz
$LN14@synchroniz:
$LN13@synchroniz:
$LN11@synchroniz:

; 233  :             }
; 234  :         }
; 235  :     }

  0017f	e9 e6 fe ff ff	 jmp	 $LN2@synchroniz
$LN3@synchroniz:

; 236  : 
; 237  :     /* If any interrupts are pending with active processors, other than
; 238  :      * self, open an interrupt window for those processors prior to
; 239  :      * considering self as synchronized.
; 240  :      */
; 241  :     if (n && mask)

  00184	83 7c 24 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00189	0f 84 b3 00 00
	00		 je	 $LN15@synchroniz
  0018f	48 83 7c 24 28
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00195	0f 84 a7 00 00
	00		 je	 $LN15@synchroniz

; 242  :     {
; 243  :         sysblk.sync_mask = mask;

  0019b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mask$[rsp]
  001a7	48 89 88 80 13
	00 00		 mov	 QWORD PTR [rax+4992], rcx

; 244  :         sysblk.syncing   = true;

  001ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b5	c6 80 7c 13 00
	00 01		 mov	 BYTE PTR [rax+4988], 1

; 245  : 
; 246  :         sysblk.intowner  = LOCK_OWNER_NONE;

  001bc	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c8	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 247  :         {
; 248  :             hthread_wait_condition( &sysblk.all_synced_cond, &sysblk.intlock, location );

  001cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d6	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  001dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001e3	48 81 c1 88 13
	00 00		 add	 rcx, 5000		; 00001388H
  001ea	4c 8b 44 24 68	 mov	 r8, QWORD PTR location$[rsp]
  001ef	48 8b d0	 mov	 rdx, rax
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 249  :         }
; 250  :         sysblk.intowner  = HOSTREGS->cpuad;

  001f8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0020b	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00212	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 251  : 
; 252  :         sysblk.syncing   = false;

  00219	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00220	c6 80 7c 13 00
	00 00		 mov	 BYTE PTR [rax+4988], 0

; 253  :         hthread_broadcast_condition( &sysblk.sync_done_cond, location );

  00227	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0022e	48 05 90 13 00
	00		 add	 rax, 5008		; 00001390H
  00234	48 8b 54 24 68	 mov	 rdx, QWORD PTR location$[rsp]
  00239	48 8b c8	 mov	 rcx, rax
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN15@synchroniz:

; 254  :     }
; 255  :     /* All active processors other than self, are now waiting at their
; 256  :      * respective sync point. We may now safely proceed doing whatever
; 257  :      * it is we need to do.
; 258  :      */
; 259  : }

  00242	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00246	c3		 ret	 0
synchronize_cpus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
END
