; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	curr_progress_time
PUBLIC	prev_progress_time
_DATA	SEGMENT
COMM	pgm:QWORD
_DATA	ENDS
_BSS	SEGMENT
curr_progress_time DQ 01H DUP (?)
prev_progress_time DQ 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	len:DWORD
COMM	prevlen:DWORD
COMM	bytes_written:QWORD
COMM	devnamein:QWORD
COMM	devnameout:QWORD
COMM	filenamein:QWORD
COMM	filenameout:QWORD
_DATA	ENDS
_DATA	SEGMENT
$SG169204 DB	'Unknown type of tape device', 00H
	ORG $+4
$SG169205 DB	'Generic QIC-02 tape streamer', 00H
	ORG $+3
$SG169206 DB	'Wangtek 5150, QIC-150', 00H
	ORG $+2
$SG169207 DB	'Archive 5945L-2', 00H
$SG169208 DB	'CMS Jumbo 500', 00H
	ORG $+2
$SG169209 DB	'Tandberg TDC 3610, QIC-24', 00H
	ORG $+6
$SG169210 DB	'Archive VP60i, QIC-02', 00H
	ORG $+2
$SG169211 DB	'Archive Viper 2150L', 00H
	ORG $+4
$SG169212 DB	'Archive Viper 2060L', 00H
	ORG $+4
$SG169213 DB	'Archive SC-499 QIC-36 controller', 00H
	ORG $+3
$SG169244 DB	'DDS-2', 00H
	ORG $+6
$SG169214 DB	'Generic QIC-02 tape, all features', 00H
	ORG $+6
$SG169215 DB	'Wangtek 5099-een24, 60MB', 00H
	ORG $+7
$SG169216 DB	'Teac MT-2ST 155mb data cassette drive', 00H
	ORG $+2
$SG169217 DB	'Everex FT40A, QIC-40', 00H
	ORG $+3
$SG169218 DB	'OnStream SC-, DI-, DP-, or USB tape drive', 00H
	ORG $+6
$SG169219 DB	'Generic SCSI-1 tape', 00H
	ORG $+4
$SG169220 DB	'Generic SCSI-2 tape', 00H
	ORG $+4
$SG169223 DB	'NRZI (800 bpi)', 00H
	ORG $+1
$SG169224 DB	'PE (1600 bpi)', 00H
	ORG $+2
$SG169225 DB	'GCR (6250 bpi)', 00H
	ORG $+1
$SG169226 DB	'QIC-45/60 (GCR, 8000 bpi)', 00H
	ORG $+6
$SG169227 DB	'PE (3200 bpi)', 00H
	ORG $+2
$SG169228 DB	'IMFM (6400 bpi)', 00H
$SG169229 DB	'GCR (8000 bpi)', 00H
	ORG $+1
$SG169230 DB	'GCR (37871 bpi)', 00H
$SG169231 DB	'MFM (6667 bpi)', 00H
	ORG $+1
$SG169232 DB	'PE (1600 bpi)', 00H
	ORG $+2
$SG169233 DB	'GCR (12960 bpi)', 00H
$SG169234 DB	'GCR (25380 bpi)', 00H
$SG169235 DB	'QIC-120 (GCR 10000 bpi)', 00H
$SG169236 DB	'QIC-150/250 (GCR 10000 bpi)', 00H
	ORG $+4
$SG169237 DB	'QIC-320/525 (GCR 16000 bpi)', 00H
	ORG $+4
$SG169238 DB	'QIC-1350 (RLL 51667 bpi)', 00H
	ORG $+7
$SG169239 DB	'DDS (61000 bpi)', 00H
$SG169240 DB	'EXB-8200 (RLL 43245 bpi)', 00H
	ORG $+7
$SG169241 DB	'EXB-8500 (RLL 45434 bpi)', 00H
	ORG $+7
$SG169242 DB	'MFM 10000 bpi', 00H
	ORG $+2
$SG169243 DB	'MFM 42500 bpi', 00H
	ORG $+2
$SG169245 DB	'EXB-8505 compressed', 00H
	ORG $+4
$SG169246 DB	'EXB-8205 compressed', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	read_scsi_tape
PUBLIC	read_aws_disk
PUBLIC	write_scsi_tape
PUBLIC	write_aws_disk
PUBLIC	write_tapemark_scsi_tape
PUBLIC	write_tapemark_aws_disk
PUBLIC	main
PUBLIC	__real@4130000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_w32_open_tape:PROC
EXTRN	__imp_w32_ioctl_tape:PROC
EXTRN	__imp_w32_close_tape:PROC
EXTRN	__imp_w32_read_tape:PROC
EXTRN	__imp_w32_write_tape:PROC
EXTRN	gstat2str:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
buf	DB	0200000H DUP (?)
$SG169273 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$delayed_exit DD imagerel delayed_exit
	DD	imagerel delayed_exit+112
	DD	imagerel $unwind$delayed_exit
$pdata$print_status DD imagerel print_status
	DD	imagerel print_status+222
	DD	imagerel $unwind$print_status
$pdata$print_usage DD imagerel print_usage
	DD	imagerel print_usage+346
	DD	imagerel $unwind$print_usage
$pdata$obtain_status DD imagerel obtain_status
	DD	imagerel obtain_status+343
	DD	imagerel $unwind$obtain_status
$pdata$read_scsi_tape DD imagerel $LN14
	DD	imagerel $LN14+477
	DD	imagerel $unwind$read_scsi_tape
$pdata$read_aws_disk DD imagerel $LN13
	DD	imagerel $LN13+962
	DD	imagerel $unwind$read_aws_disk
$pdata$write_scsi_tape DD imagerel $LN4
	DD	imagerel $LN4+260
	DD	imagerel $unwind$write_scsi_tape
$pdata$write_aws_disk DD imagerel $LN5
	DD	imagerel $LN5+680
	DD	imagerel $unwind$write_aws_disk
$pdata$write_tapemark_scsi_tape DD imagerel $LN4
	DD	imagerel $LN4+231
	DD	imagerel $unwind$write_tapemark_scsi_tape
$pdata$write_tapemark_aws_disk DD imagerel $LN4
	DD	imagerel $LN4+374
	DD	imagerel $unwind$write_tapemark_aws_disk
$pdata$main DD	imagerel $LN149
	DD	imagerel $LN149+5818
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@4130000000000000
CONST	SEGMENT
__real@4130000000000000 DQ 04130000000000000r	; 1.04858e+06
CONST	ENDS
_DATA	SEGMENT
vollbl	DB	0e5H, 0d6H, 0d3H, 00H
hdrlbl	DB	0c8H, 0c4H, 0d9H, 00H
eoflbl	DB	0c5H, 0d6H, 0c6H, 00H
eovlbl	DB	0c5H, 0d6H, 0e5H, 00H
$SG169260 DB	'E', 00H
	ORG $+2
tapeinfo DD	01H
	ORG $+4
	DQ	FLAT:$SG169204
	DD	02H
	ORG $+4
	DQ	FLAT:$SG169205
	DD	03H
	ORG $+4
	DQ	FLAT:$SG169206
	DD	04H
	ORG $+4
	DQ	FLAT:$SG169207
	DD	05H
	ORG $+4
	DQ	FLAT:$SG169208
	DD	06H
	ORG $+4
	DQ	FLAT:$SG169209
	DD	07H
	ORG $+4
	DQ	FLAT:$SG169210
	DD	08H
	ORG $+4
	DQ	FLAT:$SG169211
	DD	09H
	ORG $+4
	DQ	FLAT:$SG169212
	DD	0aH
	ORG $+4
	DQ	FLAT:$SG169213
	DD	0fH
	ORG $+4
	DQ	FLAT:$SG169214
	DD	011H
	ORG $+4
	DQ	FLAT:$SG169215
	DD	012H
	ORG $+4
	DQ	FLAT:$SG169216
	DD	032H
	ORG $+4
	DQ	FLAT:$SG169217
	DD	061H
	ORG $+4
	DQ	FLAT:$SG169218
	DD	071H
	ORG $+4
	DQ	FLAT:$SG169219
	DD	072H
	ORG $+4
	DQ	FLAT:$SG169220
	DD	00H
	ORG $+4
	DQ	0000000000000000H
densinfo DD	01H
	ORG $+4
	DQ	FLAT:$SG169223
	DD	02H
	ORG $+4
	DQ	FLAT:$SG169224
	DD	03H
	ORG $+4
	DQ	FLAT:$SG169225
	DD	05H
	ORG $+4
	DQ	FLAT:$SG169226
	DD	06H
	ORG $+4
	DQ	FLAT:$SG169227
	DD	07H
	ORG $+4
	DQ	FLAT:$SG169228
	DD	08H
	ORG $+4
	DQ	FLAT:$SG169229
	DD	09H
	ORG $+4
	DQ	FLAT:$SG169230
	DD	0aH
	ORG $+4
	DQ	FLAT:$SG169231
	DD	0bH
	ORG $+4
	DQ	FLAT:$SG169232
	DD	0cH
	ORG $+4
	DQ	FLAT:$SG169233
	DD	0dH
	ORG $+4
	DQ	FLAT:$SG169234
	DD	0fH
	ORG $+4
	DQ	FLAT:$SG169235
	DD	010H
	ORG $+4
	DQ	FLAT:$SG169236
	DD	011H
	ORG $+4
	DQ	FLAT:$SG169237
	DD	012H
	ORG $+4
	DQ	FLAT:$SG169238
	DD	013H
	ORG $+4
	DQ	FLAT:$SG169239
	DD	014H
	ORG $+4
	DQ	FLAT:$SG169240
	DD	015H
	ORG $+4
	DQ	FLAT:$SG169241
	DD	016H
	ORG $+4
	DQ	FLAT:$SG169242
	DD	017H
	ORG $+4
	DQ	FLAT:$SG169243
	DD	024H
	ORG $+4
	DQ	FLAT:$SG169244
	DD	08cH
	ORG $+4
	DQ	FLAT:$SG169245
	DD	090H
	ORG $+4
	DQ	FLAT:$SG169246
	DD	00H
	ORG $+4
	DQ	0000000000000000H
$SG169261 DB	'HHC02701%s Abnormal termination', 0aH, 00H
	ORG $+3
$SG169274 DB	'I', 00H
	ORG $+2
$SG169262 DB	'delayed_exit', 00H
	ORG $+3
$SG169263 DB	'tapecopy.c', 00H
	ORG $+1
$SG169284 DB	'I', 00H
	ORG $+2
$SG169275 DB	'HHC02702%s Tape %s: %smt_gstat 0x%8.8X %s', 0aH, 00H
	ORG $+1
$SG169303 DB	'E', 00H
	ORG $+2
$SG169276 DB	'print_status', 00H
	ORG $+3
$SG169277 DB	'tapecopy.c', 00H
	ORG $+1
$SG169338 DB	'I', 00H
	ORG $+2
$SG169282 DB	'/dev" or "\\.\Tape', 00H
	ORG $+5
$SG169283 DB	'Usage:', 0aH, 'HHC02760I ', 0aH, 'HHC02760I    %s  [tape'
	DB	'drive] [awsfile] or', 0aH, 'HHC02760I    %s  [awsfile] [taped'
	DB	'rive]', 0aH, 'HHC02760I ', 0aH, 'HHC02760I Where:', 0aH, 'HHC'
	DB	'02760I ', 0aH, 'HHC02760I    tapedrive    specifies the devic'
	DB	'e filename of the SCSI tape drive.', 0aH, 'HHC02760I         '
	DB	'        Must begin with "%s" to be recognized.', 0aH, 'HHC027'
	DB	'60I    awsfile      specifies the filename of the AWS emulate'
	DB	'd tape file.', 0aH, 'HHC02760I ', 0aH, 'HHC02760I The first f'
	DB	'ilename is the input; the second is the output.', 0aH, 'HHC02'
	DB	'760I ', 0aH, 'HHC02760I If the input file is a SCSI tape, it '
	DB	'is read and processed until physical EOD', 0aH, 'HHC02760I (e'
	DB	'nd-of-data) is reached (i.e. it does not stop whenever multip'
	DB	'le tapemarks or', 0aH, 'HHC02760I filemarks are read; it cont'
	DB	'inues processing until the SCSI tape drive says', 0aH, 'HHC02'
	DB	'760I there is no more data on the tape). The resulting AWS eu'
	DB	'mulated tape O/P file,', 0aH, 'HHC02760I when specified for t'
	DB	'he filename on a Hercules tape device configuration', 0aH, 'H'
	DB	'HC02760I statement, can then be used instead in order for the'
	DB	' Hercules guest O/S to', 0aH, 'HHC02760I read the exact same '
	DB	'data without having to have a SCSI tape drive physically', 0aH
	DB	'HHC02760I attached to the host system. This allows you to eas'
	DB	'ily transfer SCSI tape data', 0aH, 'HHC02760I to other system'
	DB	's that may not have SCSI tape drives attached to them by simp'
	DB	'ly', 0aH, 'HHC02760I using the AWS emulated tape file instead'
	DB	', or allows systems without SCSI tape', 0aH, 'HHC02760I drive'
	DB	's to create tape output (in the form of an AWS tape file) whi'
	DB	'ch can then', 0aH, 'HHC02760I be copied to a SCSI tape (via %'
	DB	's) by a system which DOES have one.', 0aH, 'HHC02760I ', 0aH, 'H'
	DB	'HC02760I The possible return codes and their meaning are:', 0aH
	DB	'HHC02760I ', 0aH, 'HHC02760I    %2d           Successful comp'
	DB	'letion.', 0aH, 'HHC02760I    %2d           Invalid arguments '
	DB	'or no arguments given.', 0aH, 'HHC02760I    %2d           Una'
	DB	'ble to open SCSI tape drive device file.', 0aH, 'HHC02760I   '
	DB	' %2d           Unable to open AWS emulated tape file.', 0aH, 'H'
	DB	'HC02760I    %2d           Unrecoverable I/O error setting var'
	DB	'iable length block', 0aH, 'HHC02760I                 processi'
	DB	'ng for SCSI tape device.', 0aH, 'HHC02760I    %2d           U'
	DB	'nrecoverable I/O error rewinding SCSI tape device.', 0aH, 'HH'
	DB	'C02760I    %2d           Unrecoverable I/O error obtaining st'
	DB	'atus of SCSI device.', 0aH, 'HHC02760I    %2d           Unrec'
	DB	'overable I/O error reading block header', 0aH, 'HHC02760I    '
	DB	'             from AWS emulated tape file.', 0aH, 'HHC02760I  '
	DB	'  %2d           Unrecoverable I/O error reading data block.', 0aH
	DB	'HHC02760I    %2d           AWS emulated tape block size too l'
	DB	'arge.', 0aH, 'HHC02760I    %2d           Unrecoverable I/O er'
	DB	'ror writing tapemark.', 0aH, 'HHC02760I    %2d           Unre'
	DB	'coverable I/O error writing block header', 0aH, 'HHC02760I   '
	DB	'              to AWS emulated tape file.', 0aH, 'HHC02760I   '
	DB	' %2d           Unrecoverable I/O error writing data block.', 0aH
	DB	00H
$SG169342 DB	'E', 00H
	ORG $+2
$SG169285 DB	'HHC02760%s %s', 0aH, 00H
	ORG $+1
$SG169286 DB	'print_usage', 00H
$SG169370 DB	'I', 00H
	ORG $+2
$SG169287 DB	'tapecopy.c', 00H
	ORG $+1
$SG169376 DB	'E', 00H
	ORG $+2
$SG169304 DB	'HHC02703%s Tape %s: Error reading status: rc=%d, errno=%'
	DB	'd: %s', 0aH, 00H
	ORG $+1
$SG169305 DB	'obtain_status', 00H
	ORG $+2
$SG169306 DB	'tapecopy.c', 00H
	ORG $+1
$SG169383 DB	'E', 00H
	ORG $+2
$SG169329 DB	'read_scsi_tape', 00H
	ORG $+1
$SG169330 DB	'tapecopy.c', 00H
	ORG $+5
$SG169333 DB	'read_scsi_tape', 00H
	ORG $+1
$SG169339 DB	'HHC02704%s End of tape', 0aH, 00H
$SG169331 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169334 DB	'tapecopy.c', 00H
	ORG $+5
$SG169340 DB	'read_scsi_tape', 00H
	ORG $+1
$SG169343 DB	'HHC02705%s Tape %s: Error reading tape: errno=%d: %s', 0aH
	DB	00H
	ORG $+2
$SG169335 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169341 DB	'tapecopy.c', 00H
	ORG $+1
$SG169389 DB	'E', 00H
	ORG $+2
$SG169344 DB	'read_scsi_tape', 00H
	ORG $+1
$SG169345 DB	'tapecopy.c', 00H
	ORG $+1
$SG169405 DB	'E', 00H
	ORG $+2
$SG169369 DB	'AWS emulated tape', 00H
	ORG $+2
$SG169426 DB	'E', 00H
	ORG $+2
$SG169371 DB	'HHC02706%s File %s: End of %s input', 0aH, 00H
	ORG $+3
$SG169372 DB	'read_aws_disk', 00H
	ORG $+2
$SG169373 DB	'tapecopy.c', 00H
	ORG $+1
$SG169432 DB	'E', 00H
	ORG $+2
$SG169375 DB	'AWS eumulated tape file', 00H
$SG169377 DB	'HHC02707%s File %s: Error reading %s header: rc=%d, errn'
	DB	'o=%d: %s', 0aH, 00H
	ORG $+2
$SG169446 DB	'E', 00H
	ORG $+2
$SG169378 DB	'read_aws_disk', 00H
	ORG $+2
$SG169379 DB	'tapecopy.c', 00H
	ORG $+1
$SG169461 DB	'E', 00H
	ORG $+2
$SG169382 DB	'AWS emulated', 00H
	ORG $+3
$SG169385 DB	'read_aws_disk', 00H
	ORG $+2
$SG169388 DB	'AWS emulated tape', 00H
	ORG $+6
$SG169384 DB	'HHC02708%s File %s: Block too large for %s tape: block s'
	DB	'ize=%d, maximum=%d', 0aH, 00H
$SG169600 DB	'E', 00H
	ORG $+2
$SG169386 DB	'tapecopy.c', 00H
	ORG $+5
$SG169390 DB	'HHC02709%s File %s: Error reading %s data block: rc=%d, '
	DB	'errno=%d: %s', 0aH, 00H
	ORG $+2
$SG169391 DB	'read_aws_disk', 00H
	ORG $+2
$SG169392 DB	'tapecopy.c', 00H
	ORG $+5
$SG169407 DB	'write_scsi_tape', 00H
$SG169425 DB	'AWS emulated tape file', 00H
	ORG $+1
$SG169406 DB	'HHC02710%s Tape %s: Error writing data block: rc=%d, err'
	DB	'no=%d: %s', 0aH, 00H
	ORG $+1
$SG169605 DB	'E', 00H
	ORG $+2
$SG169408 DB	'tapecopy.c', 00H
	ORG $+5
$SG169428 DB	'write_aws_disk', 00H
	ORG $+1
$SG169431 DB	'AWS emulated tape', 00H
	ORG $+6
$SG169427 DB	'HHC02711%s File %s: Error writing %s header: rc=%d, errn'
	DB	'o=%d: %s', 0aH, 00H
	ORG $+2
$SG169610 DB	'E', 00H
	ORG $+2
$SG169429 DB	'tapecopy.c', 00H
	ORG $+5
$SG169434 DB	'write_aws_disk', 00H
	ORG $+1
$SG169463 DB	'write_tapemark_aws_disk', 00H
$SG169433 DB	'HHC02712%s File %s: Error writing %s data block: rc=%d, '
	DB	'errno=%d: %s', 0aH, 00H
	ORG $+2
$SG169435 DB	'tapecopy.c', 00H
	ORG $+5
$SG169460 DB	'AWS emulated', 00H
	ORG $+3
$SG169572 DB	'Copy SCSI tape to/from AWS tape file', 00H
	ORG $+3
$SG169447 DB	'HHC02713%s Tape %s: Error writing tapemark: rc=%d, errno'
	DB	'=%d: %s', 0aH, 00H
	ORG $+3
$SG169580 DB	'/dev/', 00H
	ORG $+2
$SG169619 DB	'I', 00H
	ORG $+2
$SG169448 DB	'write_tapemark_scsi_tape', 00H
	ORG $+3
$SG169582 DB	'\dev\', 00H
	ORG $+2
$SG169627 DB	'I', 00H
	ORG $+2
$SG169449 DB	'tapecopy.c', 00H
	ORG $+1
$SG169583 DB	'\\.\', 00H
	ORG $+7
$SG169462 DB	'HHC02714%s File %s: Error writing %s tapemark: rc=%d, er'
	DB	'rno=%d: %s', 0aH, 00H
$SG169635 DB	'E', 00H
	ORG $+2
$SG169464 DB	'tapecopy.c', 00H
	ORG $+1
$SG169681 DB	'I', 00H
	ORG $+2
$SG169573 DB	'tapecopy', 00H
	ORG $+3
$SG169590 DB	'/dev/', 00H
	ORG $+2
$SG169592 DB	'\dev\', 00H
	ORG $+2
$SG169593 DB	'\\.\', 00H
	ORG $+3
$SG169694 DB	'I', 00H
	ORG $+2
$SG169601 DB	'HHC02715%s Tape %s: Error opening: errno=%d: %s', 0aH, 00H
	ORG $+3
$SG169602 DB	'main', 00H
	ORG $+3
$SG169705 DB	'I', 00H
	ORG $+2
$SG169603 DB	'tapecopy.c', 00H
	ORG $+5
$SG169606 DB	'HHC02716%s Tape %s: Error setting attributes: rc=%d, err'
	DB	'no=%d: %s', 0aH, 00H
	ORG $+1
$SG169607 DB	'main', 00H
	ORG $+3
$SG169719 DB	'I', 00H
	ORG $+2
$SG169608 DB	'tapecopy.c', 00H
	ORG $+1
$SG169721 DB	'%s', 0dH, 00H
$SG169611 DB	'HHC02717%s Tape %s: Error rewinding: rc=%d, errno=%d: %s'
	DB	0aH, 00H
	ORG $+2
$SG169612 DB	'main', 00H
	ORG $+3
$SG169724 DB	'I', 00H
	ORG $+2
$SG169613 DB	'tapecopy.c', 00H
	ORG $+1
$SG169617 DB	': %s', 00H
	ORG $+3
$SG169728 DB	'I', 00H
	ORG $+2
$SG169618 DB	' code: 0x%lX', 00H
	ORG $+3
$SG169620 DB	'HHC02718%s Tape %s: Device type%s', 0aH, 00H
	ORG $+1
$SG169621 DB	'main', 00H
	ORG $+3
$SG169732 DB	'I', 00H
	ORG $+2
$SG169622 DB	'tapecopy.c', 00H
	ORG $+1
$SG169625 DB	': %s', 00H
	ORG $+3
$SG169737 DB	'E', 00H
	ORG $+2
$SG169626 DB	' code: 0x%lX', 00H
	ORG $+3
$SG169628 DB	'HHC02719%s Tape %s: Device density%s', 0aH, 00H
	ORG $+2
$SG169629 DB	'main', 00H
	ORG $+3
$SG169630 DB	'tapecopy.c', 00H
	ORG $+5
$SG169636 DB	'HHC02720%s File %s: Error opening: errno=%d: %s', 0aH, 00H
	ORG $+3
$SG169637 DB	'main', 00H
	ORG $+7
$SG169638 DB	'tapecopy.c', 00H
	ORG $+1
$SG169641 DB	'main', 00H
	ORG $+7
$SG169642 DB	'tapecopy.c', 00H
	ORG $+5
$SG169643 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169645 DB	'main', 00H
	ORG $+3
$SG169646 DB	'tapecopy.c', 00H
	ORG $+5
$SG169647 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169652 DB	'BLKS=%d', 0aH, 00H
	ORG $+7
$SG169654 DB	'BLKS=%d', 0aH, 00H
	ORG $+7
$SG169661 DB	'BLK=%ld', 0aH, 00H
	ORG $+7
$SG169663 DB	'BLK=%ld', 0aH, 00H
	ORG $+3
$SG169673 DB	'main', 00H
	ORG $+7
$SG169674 DB	'tapecopy.c', 00H
	ORG $+5
$SG169675 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169677 DB	'main', 00H
	ORG $+3
$SG169678 DB	'tapecopy.c', 00H
	ORG $+5
$SG169679 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169683 DB	'main', 00H
	ORG $+3
$SG169682 DB	'HHC02721%s File No. %u: Blocks=%u, Bytes=%lld, Block siz'
	DB	'e min=%u, max=%u, avg=%u', 0aH, 00H
	ORG $+6
$SG169684 DB	'tapecopy.c', 00H
	ORG $+1
$SG169686 DB	'main', 00H
	ORG $+7
$SG169687 DB	'tapecopy.c', 00H
	ORG $+5
$SG169688 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169690 DB	'main', 00H
	ORG $+3
$SG169691 DB	'tapecopy.c', 00H
	ORG $+5
$SG169692 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169695 DB	'HHC02731%s           (tapemark)', 0aH, 00H
	ORG $+3
$SG169696 DB	'main', 00H
	ORG $+7
$SG169697 DB	'tapecopy.c', 00H
	ORG $+5
$SG169706 DB	'HHC02722%s Tape Label: %s', 0aH, 00H
	ORG $+1
$SG169707 DB	'main', 00H
	ORG $+7
$SG169708 DB	'tapecopy.c', 00H
	ORG $+1
$SG169710 DB	'main', 00H
	ORG $+7
$SG169711 DB	'tapecopy.c', 00H
	ORG $+1
$SG169714 DB	'main', 00H
	ORG $+7
$SG169712 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169715 DB	'tapecopy.c', 00H
	ORG $+5
$SG169720 DB	'HHC02723%s File No. %u: Block %u', 00H
	ORG $+7
$SG169716 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169725 DB	'HHC02724%s Successful completion', 0aH, 00H
	ORG $+2
$SG169726 DB	'main', 00H
	ORG $+7
$SG169727 DB	'tapecopy.c', 00H
	ORG $+5
$SG169729 DB	'HHC02732%s Bytes read:    %lld (%3.1f MB), Blocks=%u, av'
	DB	'g=%u', 0aH, 00H
	ORG $+2
$SG169730 DB	'main', 00H
	ORG $+3
$SG169731 DB	'tapecopy.c', 00H
	ORG $+5
$SG169733 DB	'HHC02733%s Bytes written: %lld (%3.1f MB)', 0aH, 00H
	ORG $+1
$SG169734 DB	'main', 00H
	ORG $+7
$SG169735 DB	'tapecopy.c', 00H
	ORG $+5
$SG169738 DB	'HHC02717%s Tape %s: Error rewinding: rc=%d, errno=%d: %s'
	DB	0aH, 00H
	ORG $+2
$SG169739 DB	'main', 00H
	ORG $+7
$SG169740 DB	'tapecopy.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	016a2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:write_tapemark_aws_disk
	DD	015H
	DD	015eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:write_aws_disk
	DD	01fH
	DD	0290H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:read_aws_disk
	DD	01fH
	DD	03aaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:print_usage
	DD	017H
	DD	0142H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:print_status
	DD	01bH
	DD	0c5H
voltbl	ENDS
xdata	SEGMENT
$unwind$time DD	010901H
	DD	04209H
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$delayed_exit DD 010801H
	DD	08208H
$unwind$print_status DD 032319H
	DD	0400111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	01f0H
$unwind$print_usage DD 021f19H
	DD	0219010dH
	DD	imagerel __GSHandlerCheck
	DD	010b0H
$unwind$obtain_status DD 021501H
	DD	0110115H
$unwind$read_scsi_tape DD 011701H
	DD	0e217H
$unwind$read_aws_disk DD 022719H
	DD	0170115H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$write_scsi_tape DD 021501H
	DD	0110115H
$unwind$write_aws_disk DD 022719H
	DD	0150115H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$write_tapemark_scsi_tape DD 020b01H
	DD	011010bH
$unwind$write_tapemark_aws_disk DD 021d19H
	DD	013010bH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$main DD	022219H
	DD	0830110H
	DD	imagerel __GSHandlerCheck
	DD	0400H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
i$ = 112
devfd$ = 116
blkcount$ = 120
rc$ = 124
diskfd$ = 128
totalblks$ = 132
minblksz$ = 136
mtpos$ = 140
maxblksz$ = 144
fileno$ = 148
opblk$ = 152
is3590$ = 160
file_bytes$ = 168
density$ = 176
tv473 = 180
tv764 = 184
bytes_read$ = 192
tv506 = 200
tv582 = 204
tv223 = 208
tv249 = 216
tv275 = 224
tv292 = 232
tv326 = 240
tv401 = 248
tv415 = 256
tv439 = 264
$T1 = 272
tv841 = 280
tv216 = 288
tv220 = 296
tv241 = 304
tv245 = 312
tv267 = 320
tv271 = 328
tv432 = 336
tv436 = 344
tv801 = 352
tv815 = 360
tv833 = 368
tv837 = 376
mtget$ = 384
msgbuf$2 = 416
msgbuf$3 = 480
labelrec$ = 544
pathname$ = 640
msgbuf$4 = 912
__$ArrayPad$ = 1024
argc$ = 1056
argv$ = 1064
main	PROC

; 506  : {

$LN149:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 18 04
	00 00		 sub	 rsp, 1048		; 00000418H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 00
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 507  : int             rc;                     /* Return code               */
; 508  : int             i;                      /* Array subscript           */
; 509  : int             devfd;                  /* Tape file descriptor      */
; 510  : int             diskfd = -1;            /* Disk file descriptor      */

  00022	c7 84 24 80 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR diskfd$[rsp], -1

; 511  : int             fileno;                 /* Tape file number          */
; 512  : int             blkcount;               /* Block count               */
; 513  : int             totalblks = 0;          /* Block count               */

  0002d	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR totalblks$[rsp], 0

; 514  : int             minblksz;               /* Minimum block size        */
; 515  : int             maxblksz;               /* Maximum block size        */
; 516  : struct mtop     opblk;                  /* Area for MTIOCTOP ioctl   */
; 517  : long            density;                /* Tape density code         */
; 518  : BYTE            labelrec[81];           /* Standard label (ASCIIZ)   */
; 519  : int64_t         bytes_read;             /* Bytes read from i/p file  */
; 520  : int64_t         file_bytes;             /* Byte count for curr file  */
; 521  : char            pathname[MAX_PATH];     /* file name in host format  */
; 522  : struct mtget    mtget;                  /* Area for MTIOCGET ioctl   */
; 523  : struct mtpos    mtpos;                  /* Area for MTIOCPOS ioctl   */
; 524  : int             is3590 = 0;             /* 1 == 3590, 0 == 3480/3490 */

  00038	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR is3590$[rsp], 0

; 525  : 
; 526  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:pgm
  0004a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169572
  00056	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169573
  0005d	48 8b 94 24 28
	04 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00065	8b 8c 24 20 04
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00072	89 84 24 20 04
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 527  : 
; 528  :     /* The first argument is the input file name
; 529  :        (either AWS disk file or SCSI tape device)
; 530  :     */
; 531  :     if ((argc < 2) || (argv[1] == NULL))

  00079	83 bc 24 20 04
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00081	7c 18		 jl	 SHORT $LN50@main
  00083	b8 08 00 00 00	 mov	 eax, 8
  00088	48 6b c0 01	 imul	 rax, rax, 1
  0008c	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00094	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00099	75 0c		 jne	 SHORT $LN49@main
$LN50@main:

; 532  :         DELAYED_EXIT( print_usage());

  0009b	e8 00 00 00 00	 call	 print_usage
  000a0	8b c8		 mov	 ecx, eax
  000a2	e8 00 00 00 00	 call	 delayed_exit
$LN49@main:

; 533  : 
; 534  :     if (0
; 535  :         || ( strlen( argv[1] ) > 5 && strnfilenamecmp( argv[1], "/dev/",   5 ) == 0 )
; 536  : #if defined(_MSVC_)
; 537  :         || ( strlen( argv[1] ) > 5 && strnfilenamecmp( argv[1], "\\dev\\", 5 ) == 0 )
; 538  : #endif
; 539  :         || ( strlen( argv[1] ) > 4 && strnfilenamecmp( argv[1], "\\\\.\\", 4 ) == 0 )

  000a7	33 c0		 xor	 eax, eax
  000a9	85 c0		 test	 eax, eax
  000ab	0f 85 e8 00 00
	00		 jne	 $LN53@main
  000b1	b8 08 00 00 00	 mov	 eax, 8
  000b6	48 6b c0 01	 imul	 rax, rax, 1
  000ba	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000c2	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000c6	e8 00 00 00 00	 call	 strlen
  000cb	48 83 f8 05	 cmp	 rax, 5
  000cf	76 30		 jbe	 SHORT $LN54@main
  000d1	b8 08 00 00 00	 mov	 eax, 8
  000d6	48 6b c0 01	 imul	 rax, rax, 1
  000da	41 b8 05 00 00
	00		 mov	 r8d, 5
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169580
  000e7	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000ef	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000f9	85 c0		 test	 eax, eax
  000fb	0f 84 98 00 00
	00		 je	 $LN53@main
$LN54@main:
  00101	b8 08 00 00 00	 mov	 eax, 8
  00106	48 6b c0 01	 imul	 rax, rax, 1
  0010a	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00112	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00116	e8 00 00 00 00	 call	 strlen
  0011b	48 83 f8 05	 cmp	 rax, 5
  0011f	76 2c		 jbe	 SHORT $LN55@main
  00121	b8 08 00 00 00	 mov	 eax, 8
  00126	48 6b c0 01	 imul	 rax, rax, 1
  0012a	41 b8 05 00 00
	00		 mov	 r8d, 5
  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169582
  00137	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0013f	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00149	85 c0		 test	 eax, eax
  0014b	74 4c		 je	 SHORT $LN53@main
$LN55@main:
  0014d	b8 08 00 00 00	 mov	 eax, 8
  00152	48 6b c0 01	 imul	 rax, rax, 1
  00156	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0015e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00162	e8 00 00 00 00	 call	 strlen
  00167	48 83 f8 04	 cmp	 rax, 4
  0016b	76 55		 jbe	 SHORT $LN51@main
  0016d	b8 08 00 00 00	 mov	 eax, 8
  00172	48 6b c0 01	 imul	 rax, rax, 1
  00176	41 b8 04 00 00
	00		 mov	 r8d, 4
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169583
  00183	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0018b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00195	85 c0		 test	 eax, eax
  00197	75 29		 jne	 SHORT $LN51@main
$LN53@main:

; 540  :     )
; 541  :     {
; 542  :         devnamein = argv[1];

  00199	b8 08 00 00 00	 mov	 eax, 8
  0019e	48 6b c0 01	 imul	 rax, rax, 1
  001a2	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001aa	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  001ae	48 89 05 00 00
	00 00		 mov	 QWORD PTR devnamein, rax

; 543  :         filenamein = NULL;

  001b5	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR filenamein, 0

; 544  :     }

  001c0	eb 27		 jmp	 SHORT $LN52@main
$LN51@main:

; 545  :     else
; 546  :     {
; 547  :         filenamein = argv[1];

  001c2	b8 08 00 00 00	 mov	 eax, 8
  001c7	48 6b c0 01	 imul	 rax, rax, 1
  001cb	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001d3	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  001d7	48 89 05 00 00
	00 00		 mov	 QWORD PTR filenamein, rax

; 548  :         devnamein = NULL;

  001de	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR devnamein, 0
$LN52@main:

; 549  :     }
; 550  : 
; 551  :     /* The second argument is the output file name
; 552  :        (either AWS disk file or SCSI tape device)
; 553  :     */
; 554  :     if (argc > 2 && argv[2] )

  001e9	83 bc 24 20 04
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  001f1	0f 8e 60 01 00
	00		 jle	 $LN56@main
  001f7	b8 08 00 00 00	 mov	 eax, 8
  001fc	48 6b c0 02	 imul	 rax, rax, 2
  00200	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00208	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0020d	0f 84 44 01 00
	00		 je	 $LN56@main

; 555  :     {
; 556  :         if (0
; 557  :             || ( strlen( argv[2] ) > 5 && strnfilenamecmp( argv[2], "/dev/",   5 ) == 0 )
; 558  : #if defined(_MSVC_)
; 559  :             || ( strlen( argv[2] ) > 5 && strnfilenamecmp( argv[2], "\\dev\\",   5 ) == 0 )
; 560  : #endif
; 561  :             || ( strlen( argv[2] ) > 4 && strnfilenamecmp( argv[2], "\\\\.\\", 4 ) == 0 )

  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 e8 00 00
	00		 jne	 $LN60@main
  0021d	b8 08 00 00 00	 mov	 eax, 8
  00222	48 6b c0 02	 imul	 rax, rax, 2
  00226	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00232	e8 00 00 00 00	 call	 strlen
  00237	48 83 f8 05	 cmp	 rax, 5
  0023b	76 30		 jbe	 SHORT $LN61@main
  0023d	b8 08 00 00 00	 mov	 eax, 8
  00242	48 6b c0 02	 imul	 rax, rax, 2
  00246	41 b8 05 00 00
	00		 mov	 r8d, 5
  0024c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169590
  00253	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0025b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00265	85 c0		 test	 eax, eax
  00267	0f 84 98 00 00
	00		 je	 $LN60@main
$LN61@main:
  0026d	b8 08 00 00 00	 mov	 eax, 8
  00272	48 6b c0 02	 imul	 rax, rax, 2
  00276	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0027e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00282	e8 00 00 00 00	 call	 strlen
  00287	48 83 f8 05	 cmp	 rax, 5
  0028b	76 2c		 jbe	 SHORT $LN62@main
  0028d	b8 08 00 00 00	 mov	 eax, 8
  00292	48 6b c0 02	 imul	 rax, rax, 2
  00296	41 b8 05 00 00
	00		 mov	 r8d, 5
  0029c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169592
  002a3	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002ab	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  002b5	85 c0		 test	 eax, eax
  002b7	74 4c		 je	 SHORT $LN60@main
$LN62@main:
  002b9	b8 08 00 00 00	 mov	 eax, 8
  002be	48 6b c0 02	 imul	 rax, rax, 2
  002c2	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002ca	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002ce	e8 00 00 00 00	 call	 strlen
  002d3	48 83 f8 04	 cmp	 rax, 4
  002d7	76 55		 jbe	 SHORT $LN58@main
  002d9	b8 08 00 00 00	 mov	 eax, 8
  002de	48 6b c0 02	 imul	 rax, rax, 2
  002e2	41 b8 04 00 00
	00		 mov	 r8d, 4
  002e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169593
  002ef	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002f7	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00301	85 c0		 test	 eax, eax
  00303	75 29		 jne	 SHORT $LN58@main
$LN60@main:

; 562  :         )
; 563  :         {
; 564  :             devnameout = argv[2];

  00305	b8 08 00 00 00	 mov	 eax, 8
  0030a	48 6b c0 02	 imul	 rax, rax, 2
  0030e	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00316	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0031a	48 89 05 00 00
	00 00		 mov	 QWORD PTR devnameout, rax

; 565  :             filenameout = NULL;

  00321	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR filenameout, 0

; 566  :         }

  0032c	eb 27		 jmp	 SHORT $LN59@main
$LN58@main:

; 567  :         else
; 568  :         {
; 569  :             filenameout = argv[2];

  0032e	b8 08 00 00 00	 mov	 eax, 8
  00333	48 6b c0 02	 imul	 rax, rax, 2
  00337	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0033f	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00343	48 89 05 00 00
	00 00		 mov	 QWORD PTR filenameout, rax

; 570  :             devnameout = NULL;

  0034a	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR devnameout, 0
$LN59@main:

; 571  :         }
; 572  :     }

  00355	eb 0c		 jmp	 SHORT $LN57@main
$LN56@main:

; 573  :     else
; 574  :         DELAYED_EXIT( print_usage());

  00357	e8 00 00 00 00	 call	 print_usage
  0035c	8b c8		 mov	 ecx, eax
  0035e	e8 00 00 00 00	 call	 delayed_exit
$LN57@main:

; 575  : 
; 576  :     /* Check input arguments and disallow tape-to-tape or disk-to-disk copy */
; 577  :     if ((!devnamein && !devnameout) || (!filenamein && !filenameout))

  00363	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  0036b	75 0a		 jne	 SHORT $LN65@main
  0036d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnameout, 0
  00375	74 14		 je	 SHORT $LN64@main
$LN65@main:
  00377	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR filenamein, 0
  0037f	75 16		 jne	 SHORT $LN63@main
  00381	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR filenameout, 0
  00389	75 0c		 jne	 SHORT $LN63@main
$LN64@main:

; 578  :         DELAYED_EXIT( print_usage());

  0038b	e8 00 00 00 00	 call	 print_usage
  00390	8b c8		 mov	 ecx, eax
  00392	e8 00 00 00 00	 call	 delayed_exit
$LN63@main:

; 579  : 
; 580  :     /* Open the SCSI tape device */
; 581  :     if (devnamein)

  00397	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  0039f	74 34		 je	 SHORT $LN66@main

; 582  :     {
; 583  :         hostpath( pathname, devnamein, sizeof(pathname) );

  003a1	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  003a7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR devnamein
  003ae	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  003b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 584  :         devfd = open_tape (pathname, O_RDONLY|O_BINARY);

  003bc	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  003c1	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  003c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_open_tape
  003cf	89 44 24 74	 mov	 DWORD PTR devfd$[rsp], eax

; 585  :     }

  003d3	eb 32		 jmp	 SHORT $LN67@main
$LN66@main:

; 586  :     else // (devnameout)
; 587  :     {
; 588  :         hostpath( pathname, devnameout, sizeof(pathname) );

  003d5	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  003db	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR devnameout
  003e2	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  003ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 589  :         devfd = open_tape (pathname, O_RDWR|O_BINARY);

  003f0	ba 02 80 00 00	 mov	 edx, 32770		; 00008002H
  003f5	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  003fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_open_tape
  00403	89 44 24 74	 mov	 DWORD PTR devfd$[rsp], eax
$LN67@main:

; 590  :     }
; 591  :     if (devfd < 0)

  00407	83 7c 24 74 00	 cmp	 DWORD PTR devfd$[rsp], 0
  0040c	0f 8d c7 00 00
	00		 jge	 $LN68@main

; 592  :     {
; 593  :         // "Tape %s: Error opening: errno=%d: %s"
; 594  :         FWRMSG( stderr, HHC02715, "E", (devnamein ? devnamein : devnameout),

  00412	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  0041a	74 11		 je	 SHORT $LN124@main
  0041c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnamein
  00423	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
  0042b	eb 0f		 jmp	 SHORT $LN125@main
$LN124@main:
  0042d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnameout
  00434	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
$LN125@main:
  0043c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00442	8b 08		 mov	 ecx, DWORD PTR [rax]
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0044a	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv216[rsp], rax
  00452	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00458	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv220[rsp], rax
  00460	b9 02 00 00 00	 mov	 ecx, 2
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0046b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv216[rsp]
  00473	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00478	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv220[rsp]
  00480	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00482	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00486	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv223[rsp]
  0048e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00493	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169600
  0049a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169601
  004a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169602
  004bd	ba 53 02 00 00	 mov	 edx, 595		; 00000253H
  004c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169603
  004c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 595  :             errno, strerror( errno ));
; 596  :         DELAYED_EXIT( RC_ERROR_OPENING_SCSI_DEVICE );

  004cf	b9 03 00 00 00	 mov	 ecx, 3
  004d4	e8 00 00 00 00	 call	 delayed_exit
$LN68@main:

; 597  :     }
; 598  : 
; 599  :     usleep(50000);

  004d9	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  004de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 600  : 
; 601  :     /* Set the tape device to process variable length blocks */
; 602  :     opblk.mt_op = MTSETBLK;

  004e4	b8 14 00 00 00	 mov	 eax, 20
  004e9	66 89 84 24 98
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 603  :     opblk.mt_count = 0;

  004f1	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 0

; 604  :     rc = ioctl_tape (devfd, MTIOCTOP, (char*)&opblk);

  004fc	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  00504	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  00509	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  0050d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00513	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 605  :     if (rc < 0)

  00517	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0051c	0f 8d cf 00 00
	00		 jge	 $LN69@main

; 606  :     {
; 607  :         // "Tape %s: Error setting attributes: rc=%d, errno=%d: %s"
; 608  :         FWRMSG( stderr, HHC02716, "E", (devnamein ? devnamein : devnameout),

  00522	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  0052a	74 11		 je	 SHORT $LN126@main
  0052c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnamein
  00533	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  0053b	eb 0f		 jmp	 SHORT $LN127@main
$LN126@main:
  0053d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnameout
  00544	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
$LN127@main:
  0054c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00552	8b 08		 mov	 ecx, DWORD PTR [rax]
  00554	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0055a	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv241[rsp], rax
  00562	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00568	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv245[rsp], rax
  00570	b9 02 00 00 00	 mov	 ecx, 2
  00575	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv241[rsp]
  00583	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00588	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv245[rsp]
  00590	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00592	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00596	8b 4c 24 7c	 mov	 ecx, DWORD PTR rc$[rsp]
  0059a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0059e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv249[rsp]
  005a6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169605
  005b2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169606
  005be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c8	41 b9 03 00 00
	00		 mov	 r9d, 3
  005ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169607
  005d5	ba 61 02 00 00	 mov	 edx, 609		; 00000261H
  005da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169608
  005e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 609  :             rc, errno, strerror( errno ));
; 610  :         DELAYED_EXIT( RC_ERROR_SETTING_SCSI_VARBLK_PROCESSING );

  005e7	b9 05 00 00 00	 mov	 ecx, 5
  005ec	e8 00 00 00 00	 call	 delayed_exit
$LN69@main:

; 611  :     }
; 612  : 
; 613  :     usleep(50000);

  005f1	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  005f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 614  : 
; 615  :     /* Rewind the tape to the beginning */
; 616  :     opblk.mt_op = MTREW;

  005fc	b8 06 00 00 00	 mov	 eax, 6
  00601	66 89 84 24 98
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 617  :     opblk.mt_count = 1;

  00609	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 1

; 618  :     rc = ioctl_tape (devfd, MTIOCTOP, (char*)&opblk);

  00614	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  0061c	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  00621	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  00625	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0062b	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 619  :     if (rc < 0)

  0062f	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00634	0f 8d cf 00 00
	00		 jge	 $LN70@main

; 620  :     {
; 621  :         // "Tape %s: Error rewinding: rc=%d, errno=%d: %s"
; 622  :         FWRMSG( stderr, HHC02717, "E", (devnamein ? devnamein : devnameout),

  0063a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  00642	74 11		 je	 SHORT $LN128@main
  00644	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnamein
  0064b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
  00653	eb 0f		 jmp	 SHORT $LN129@main
$LN128@main:
  00655	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnameout
  0065c	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
$LN129@main:
  00664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0066a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0066c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00672	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv267[rsp], rax
  0067a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00680	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv271[rsp], rax
  00688	b9 02 00 00 00	 mov	 ecx, 2
  0068d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00693	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv267[rsp]
  0069b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006a0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv271[rsp]
  006a8	8b 09		 mov	 ecx, DWORD PTR [rcx]
  006aa	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  006ae	8b 4c 24 7c	 mov	 ecx, DWORD PTR rc$[rsp]
  006b2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006b6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv275[rsp]
  006be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169610
  006ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169611
  006d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  006e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169612
  006ed	ba 6f 02 00 00	 mov	 edx, 623		; 0000026fH
  006f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169613
  006f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 623  :             rc, errno, strerror( errno ));
; 624  :         DELAYED_EXIT( RC_ERROR_REWINDING_SCSI );

  006ff	b9 06 00 00 00	 mov	 ecx, 6
  00704	e8 00 00 00 00	 call	 delayed_exit
$LN70@main:

; 625  :     }
; 626  : 
; 627  :     usleep(50000);

  00709	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  0070e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 628  : 
; 629  :     /* Obtain the tape status */
; 630  :     rc = obtain_status ((devnamein ? devnamein : devnameout), devfd, &mtget);

  00714	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  0071c	74 11		 je	 SHORT $LN130@main
  0071e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnamein
  00725	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv292[rsp], rax
  0072d	eb 0f		 jmp	 SHORT $LN131@main
$LN130@main:
  0072f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnameout
  00736	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv292[rsp], rax
$LN131@main:
  0073e	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR mtget$[rsp]
  00746	8b 54 24 74	 mov	 edx, DWORD PTR devfd$[rsp]
  0074a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv292[rsp]
  00752	e8 00 00 00 00	 call	 obtain_status
  00757	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 631  :     if (rc < 0)

  0075b	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00760	7d 0a		 jge	 SHORT $LN71@main

; 632  :         DELAYED_EXIT( RC_ERROR_OBTAINING_SCSI_STATUS );

  00762	b9 07 00 00 00	 mov	 ecx, 7
  00767	e8 00 00 00 00	 call	 delayed_exit
$LN71@main:

; 633  : 
; 634  :     /* Display tape status information */
; 635  :     for (i = 0; tapeinfo[i].t_type != 0

  0076c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00774	eb 0a		 jmp	 SHORT $LN4@main
$LN2@main:

; 636  :                 && tapeinfo[i].t_type != mtget.mt_type; i++)

  00776	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0077a	ff c0		 inc	 eax
  0077c	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN4@main:
  00780	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00785	48 6b c0 10	 imul	 rax, rax, 16
  00789	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tapeinfo
  00790	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00794	74 1e		 je	 SHORT $LN3@main
  00796	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0079b	48 6b c0 10	 imul	 rax, rax, 16
  0079f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tapeinfo
  007a6	8b 94 24 80 01
	00 00		 mov	 edx, DWORD PTR mtget$[rsp]
  007ad	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  007b0	74 02		 je	 SHORT $LN3@main

; 637  :         /* empty */ ;

  007b2	eb c2		 jmp	 SHORT $LN2@main
$LN3@main:

; 638  : 
; 639  :     {
; 640  :         char msgbuf[64];
; 641  : 
; 642  :         if (tapeinfo[i].t_name)

  007b4	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  007b9	48 6b c0 10	 imul	 rax, rax, 16
  007bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tapeinfo
  007c4	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  007ca	74 31		 je	 SHORT $LN72@main

; 643  :             MSGBUF( msgbuf, ": %s", tapeinfo[i].t_name);

  007cc	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  007d1	48 6b c0 10	 imul	 rax, rax, 16
  007d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tapeinfo
  007dc	4c 8b 4c 01 08	 mov	 r9, QWORD PTR [rcx+rax+8]
  007e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169617
  007e8	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  007ed	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR msgbuf$2[rsp]
  007f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  007fb	eb 22		 jmp	 SHORT $LN73@main
$LN72@main:

; 644  :         else
; 645  :             MSGBUF( msgbuf, " code: 0x%lX", mtget.mt_type);

  007fd	44 8b 8c 24 80
	01 00 00	 mov	 r9d, DWORD PTR mtget$[rsp]
  00805	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169618
  0080c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00811	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR msgbuf$2[rsp]
  00819	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN73@main:

; 646  : 
; 647  :         // "Tape %s: Device type%s"
; 648  :         WRMSG( HHC02718, "I", (devnamein ? devnamein : devnameout), msgbuf );

  0081f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  00827	74 11		 je	 SHORT $LN132@main
  00829	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnamein
  00830	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv326[rsp], rax
  00838	eb 0f		 jmp	 SHORT $LN133@main
$LN132@main:
  0083a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnameout
  00841	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv326[rsp], rax
$LN133@main:
  00849	b9 01 00 00 00	 mov	 ecx, 1
  0084e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00854	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR msgbuf$2[rsp]
  0085c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00861	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv326[rsp]
  00869	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0086e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169619
  00875	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0087a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169620
  00881	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00886	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0088b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00891	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169621
  00898	ba 88 02 00 00	 mov	 edx, 648		; 00000288H
  0089d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169622
  008a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 649  :     }
; 650  : 
; 651  :     density = (mtget.mt_dsreg & MT_ST_DENSITY_MASK)

  008aa	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR mtget$[rsp+8]
  008b1	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  008b6	c1 e8 18	 shr	 eax, 24
  008b9	89 84 24 b0 00
	00 00		 mov	 DWORD PTR density$[rsp], eax

; 652  :                 >> MT_ST_DENSITY_SHIFT;
; 653  : 
; 654  :     for (i = 0; densinfo[i].t_type != 0

  008c0	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  008c8	eb 0a		 jmp	 SHORT $LN7@main
$LN5@main:

; 655  :                 && densinfo[i].t_type != density; i++)

  008ca	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  008ce	ff c0		 inc	 eax
  008d0	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN7@main:
  008d4	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  008d9	48 6b c0 10	 imul	 rax, rax, 16
  008dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:densinfo
  008e4	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  008e8	74 1e		 je	 SHORT $LN6@main
  008ea	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  008ef	48 6b c0 10	 imul	 rax, rax, 16
  008f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:densinfo
  008fa	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR density$[rsp]
  00901	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  00904	74 02		 je	 SHORT $LN6@main

; 656  :          /* empty */ ;

  00906	eb c2		 jmp	 SHORT $LN5@main
$LN6@main:

; 657  : 
; 658  :     {
; 659  :         char msgbuf[64];
; 660  : 
; 661  :         if (densinfo[i].t_name)

  00908	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0090d	48 6b c0 10	 imul	 rax, rax, 16
  00911	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:densinfo
  00918	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  0091e	74 31		 je	 SHORT $LN74@main

; 662  :             MSGBUF( msgbuf, ": %s", densinfo[i].t_name );

  00920	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00925	48 6b c0 10	 imul	 rax, rax, 16
  00929	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:densinfo
  00930	4c 8b 4c 01 08	 mov	 r9, QWORD PTR [rcx+rax+8]
  00935	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169625
  0093c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00941	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  00949	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0094f	eb 22		 jmp	 SHORT $LN75@main
$LN74@main:

; 663  :         else
; 664  :             MSGBUF( msgbuf, " code: 0x%lX", density );

  00951	44 8b 8c 24 b0
	00 00 00	 mov	 r9d, DWORD PTR density$[rsp]
  00959	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169626
  00960	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00965	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  0096d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN75@main:

; 665  : 
; 666  :         // "Tape %s: Device density%s"
; 667  :         WRMSG( HHC02719, "I", (devnamein ? devnamein : devnameout), msgbuf );

  00973	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  0097b	74 11		 je	 SHORT $LN134@main
  0097d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnamein
  00984	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv401[rsp], rax
  0098c	eb 0f		 jmp	 SHORT $LN135@main
$LN134@main:
  0098e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnameout
  00995	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv401[rsp], rax
$LN135@main:
  0099d	b9 01 00 00 00	 mov	 ecx, 1
  009a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009a8	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  009b0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  009b5	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv401[rsp]
  009bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169627
  009c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169628
  009d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009df	41 b9 03 00 00
	00		 mov	 r9d, 3
  009e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169629
  009ec	ba 9b 02 00 00	 mov	 edx, 667		; 0000029bH
  009f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169630
  009f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 668  :     }
; 669  : 
; 670  :     if (mtget.mt_gstat != 0)

  009fe	83 bc 24 8c 01
	00 00 00	 cmp	 DWORD PTR mtget$[rsp+12], 0
  00a06	74 3e		 je	 SHORT $LN76@main

; 671  :         print_status ((devnamein ? devnamein : devnameout), mtget.mt_gstat);

  00a08	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  00a10	74 11		 je	 SHORT $LN136@main
  00a12	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnamein
  00a19	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv415[rsp], rax
  00a21	eb 0f		 jmp	 SHORT $LN137@main
$LN136@main:
  00a23	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnameout
  00a2a	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv415[rsp], rax
$LN137@main:
  00a32	8b 94 24 8c 01
	00 00		 mov	 edx, DWORD PTR mtget$[rsp+12]
  00a39	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv415[rsp]
  00a41	e8 00 00 00 00	 call	 print_status
$LN76@main:

; 672  : 
; 673  :     /* Open the disk file */
; 674  :     if (filenamein)

  00a46	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR filenamein, 0
  00a4e	74 37		 je	 SHORT $LN77@main

; 675  :     {
; 676  :         hostpath( pathname, filenamein, sizeof(pathname) );

  00a50	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00a56	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR filenamein
  00a5d	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00a65	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 677  :         diskfd = HOPEN (pathname, O_RDONLY | O_BINARY);

  00a6b	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00a70	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00a78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00a7e	89 84 24 80 00
	00 00		 mov	 DWORD PTR diskfd$[rsp], eax

; 678  :     }

  00a85	eb 3b		 jmp	 SHORT $LN78@main
$LN77@main:

; 679  :     else
; 680  :     {
; 681  :         hostpath( pathname, filenameout, sizeof(pathname) );

  00a87	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00a8d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR filenameout
  00a94	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00a9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 682  :         diskfd = HOPEN (pathname, O_WRONLY | O_CREAT | O_BINARY,

  00aa2	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00aa8	ba 01 81 00 00	 mov	 edx, 33025		; 00008101H
  00aad	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00ab5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00abb	89 84 24 80 00
	00 00		 mov	 DWORD PTR diskfd$[rsp], eax
$LN78@main:

; 683  :                         S_IRUSR | S_IWUSR | S_IRGRP);
; 684  :     }
; 685  :     if (diskfd < 0)

  00ac2	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR diskfd$[rsp], 0
  00aca	0f 8d c7 00 00
	00		 jge	 $LN79@main

; 686  :     {
; 687  :         // "File %s: Error opening: errno=%d: %s"
; 688  :         FWRMSG( stderr, HHC02720, "E", (filenamein ? filenamein : filenameout),

  00ad0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR filenamein, 0
  00ad8	74 11		 je	 SHORT $LN138@main
  00ada	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR filenamein
  00ae1	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv439[rsp], rax
  00ae9	eb 0f		 jmp	 SHORT $LN139@main
$LN138@main:
  00aeb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR filenameout
  00af2	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv439[rsp], rax
$LN139@main:
  00afa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b00	8b 08		 mov	 ecx, DWORD PTR [rax]
  00b02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00b08	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv432[rsp], rax
  00b10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b16	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv436[rsp], rax
  00b1e	b9 02 00 00 00	 mov	 ecx, 2
  00b23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b29	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv432[rsp]
  00b31	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b36	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv436[rsp]
  00b3e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00b40	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b44	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv439[rsp]
  00b4c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b51	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169635
  00b58	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b5d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169636
  00b64	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b69	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b6e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b74	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169637
  00b7b	ba b1 02 00 00	 mov	 edx, 689		; 000002b1H
  00b80	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169638
  00b87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 689  :             errno, strerror( errno ));
; 690  :         DELAYED_EXIT( RC_ERROR_OPENING_AWS_FILE );

  00b8d	b9 04 00 00 00	 mov	 ecx, 4
  00b92	e8 00 00 00 00	 call	 delayed_exit
$LN79@main:

; 691  :     }
; 692  : 
; 693  :     /* Copy blocks from input to output */
; 694  :     fileno = 1;

  00b97	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fileno$[rsp], 1

; 695  :     blkcount = 0;

  00ba2	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR blkcount$[rsp], 0

; 696  :     totalblks = 0;

  00baa	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR totalblks$[rsp], 0

; 697  :     minblksz = 0;

  00bb5	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR minblksz$[rsp], 0

; 698  :     maxblksz = 0;

  00bc0	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR maxblksz$[rsp], 0

; 699  :     len = 0;

  00bcb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR len, 0

; 700  :     bytes_read = 0;

  00bd5	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR bytes_read$[rsp], 0

; 701  :     bytes_written = 0;

  00be1	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR bytes_written, 0

; 702  :     file_bytes = 0;

  00bec	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR file_bytes$[rsp], 0

; 703  : 
; 704  :     // Notify the GUI of the high-end of the copy-progress range...
; 705  :     if ( extgui )

  00bf8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00bff	83 38 00	 cmp	 DWORD PTR [rax], 0
  00c02	0f 84 36 01 00
	00		 je	 $LN80@main
$LN10@main:

; 706  :     {
; 707  :         // Retrieve BOT block-id...
; 708  :         VERIFY( 0 == ioctl_tape( devfd, MTIOCPOS, (char*)&mtpos ) );

  00c08	4c 8d 84 24 8c
	00 00 00	 lea	 r8, QWORD PTR mtpos$[rsp]
  00c10	ba 03 6d 04 40	 mov	 edx, 1074031875		; 40046d03H
  00c15	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  00c19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00c1f	85 c0		 test	 eax, eax
  00c21	74 5c		 je	 SHORT $LN81@main
$LN13@main:
  00c23	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169641
  00c2a	41 b8 c4 02 00
	00		 mov	 r8d, 708		; 000002c4H
  00c30	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169642
  00c37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169643
  00c3e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00c44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c4a	85 c0		 test	 eax, eax
  00c4c	74 20		 je	 SHORT $LN82@main
  00c4e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169645
  00c55	41 b8 c4 02 00
	00		 mov	 r8d, 708		; 000002c4H
  00c5b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169646
  00c62	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169647
  00c69	e8 00 00 00 00	 call	 DebuggerTrace
$LN82@main:
  00c6e	33 c0		 xor	 eax, eax
  00c70	85 c0		 test	 eax, eax
  00c72	75 af		 jne	 SHORT $LN13@main
  00c74	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c7a	85 c0		 test	 eax, eax
  00c7c	74 01		 je	 SHORT $LN83@main
  00c7e	cc		 int	 3
$LN83@main:
$LN81@main:
  00c7f	33 c0		 xor	 eax, eax
  00c81	85 c0		 test	 eax, eax
  00c83	75 83		 jne	 SHORT $LN10@main

; 709  : 
; 710  :         is3590 = ((mtpos.mt_blkno & 0x7F000000) != 0x01000000) ? 1 : 0;

  00c85	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR mtpos$[rsp]
  00c8c	25 00 00 00 7f	 and	 eax, 2130706432		; 7f000000H
  00c91	3d 00 00 00 01	 cmp	 eax, 16777216		; 01000000H
  00c96	74 0d		 je	 SHORT $LN140@main
  00c98	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv473[rsp], 1
  00ca3	eb 0b		 jmp	 SHORT $LN141@main
$LN140@main:
  00ca5	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv473[rsp], 0
$LN141@main:
  00cb0	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv473[rsp]
  00cb7	89 84 24 a0 00
	00 00		 mov	 DWORD PTR is3590$[rsp], eax

; 711  : 
; 712  :         if (!is3590)

  00cbe	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR is3590$[rsp], 0
  00cc6	75 35		 jne	 SHORT $LN84@main
$LN16@main:

; 713  :         {
; 714  :             // The seg# portion the SCSI tape physical
; 715  :             // block-id number values ranges from 1 to 95...
; 716  :             EXTGUIMSG( "BLKS=%d\n", 95 );

  00cc8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00ccf	83 38 00	 cmp	 DWORD PTR [rax], 0
  00cd2	74 21		 je	 SHORT $LN86@main
  00cd4	b9 02 00 00 00	 mov	 ecx, 2
  00cd9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cdf	41 b8 5f 00 00
	00		 mov	 r8d, 95			; 0000005fH
  00ce5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169652
  00cec	48 8b c8	 mov	 rcx, rax
  00cef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN86@main:
  00cf5	33 c0		 xor	 eax, eax
  00cf7	85 c0		 test	 eax, eax
  00cf9	75 cd		 jne	 SHORT $LN16@main

; 717  :         }

  00cfb	eb 33		 jmp	 SHORT $LN85@main
$LN84@main:
$LN19@main:

; 718  :         else
; 719  :         {
; 720  :             // FIXME: 3590s (e.g. Magstar) use 32-bit block addressing,
; 721  :             // and thus its block-id does not contain a seg# value, so
; 722  :             // we must use some other technique. For now, we'll simply
; 723  :             // presume the last block on the tape is block# 0x003FFFFF
; 724  :             // (just to keep things simple).
; 725  : 
; 726  :             EXTGUIMSG( "BLKS=%d\n", 0x003FFFFF );

  00cfd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00d04	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d07	74 21		 je	 SHORT $LN87@main
  00d09	b9 02 00 00 00	 mov	 ecx, 2
  00d0e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d14	41 b8 ff ff 3f
	00		 mov	 r8d, 4194303		; 003fffffH
  00d1a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169654
  00d21	48 8b c8	 mov	 rcx, rax
  00d24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN87@main:
  00d2a	33 c0		 xor	 eax, eax
  00d2c	85 c0		 test	 eax, eax
  00d2e	75 cd		 jne	 SHORT $LN19@main
$LN85@main:

; 727  :         }
; 728  : 
; 729  :         // Init time of last issued progress message
; 730  :         prev_progress_time = time( NULL );

  00d30	33 c9		 xor	 ecx, ecx
  00d32	e8 00 00 00 00	 call	 time
  00d37	48 89 05 00 00
	00 00		 mov	 QWORD PTR prev_progress_time, rax
$LN80@main:
$LN148@main:
$LN20@main:

; 731  :     }
; 732  : 
; 733  :     /* Perform the copy... */
; 734  : 
; 735  :     while (1)

  00d3e	33 c0		 xor	 eax, eax
  00d40	83 f8 01	 cmp	 eax, 1
  00d43	0f 84 98 06 00
	00		 je	 $LN21@main

; 736  :     {
; 737  :         /* Issue a progress message every few seconds... */
; 738  :         if ( extgui )

  00d49	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00d50	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d53	0f 84 df 00 00
	00		 je	 $LN88@main

; 739  :         {
; 740  :             if ( ( curr_progress_time = time( NULL ) ) >=

  00d59	33 c9		 xor	 ecx, ecx
  00d5b	e8 00 00 00 00	 call	 time
  00d60	48 89 05 00 00
	00 00		 mov	 QWORD PTR curr_progress_time, rax
  00d67	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR prev_progress_time
  00d6e	48 83 c0 03	 add	 rax, 3
  00d72	48 39 05 00 00
	00 00		 cmp	 QWORD PTR curr_progress_time, rax
  00d79	0f 8c b9 00 00
	00		 jl	 $LN89@main

; 741  :                 ( prev_progress_time + PROGRESS_INTERVAL_SECS ) )
; 742  :             {
; 743  :                 prev_progress_time = curr_progress_time;

  00d7f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curr_progress_time
  00d86	48 89 05 00 00
	00 00		 mov	 QWORD PTR prev_progress_time, rax

; 744  :                 if ( ioctl_tape( devfd, MTIOCPOS, (char*)&mtpos ) == 0 )

  00d8d	4c 8d 84 24 8c
	00 00 00	 lea	 r8, QWORD PTR mtpos$[rsp]
  00d95	ba 03 6d 04 40	 mov	 edx, 1074031875		; 40046d03H
  00d9a	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  00d9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00da4	85 c0		 test	 eax, eax
  00da6	0f 85 8c 00 00
	00		 jne	 $LN90@main

; 745  :                 {
; 746  :                     if (!is3590)

  00dac	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR is3590$[rsp], 0
  00db4	75 4d		 jne	 SHORT $LN91@main
$LN24@main:

; 747  :                         EXTGUIMSG( "BLK=%ld\n", (mtpos.mt_blkno >> 24) & 0x0000007F );

  00db6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00dbd	83 38 00	 cmp	 DWORD PTR [rax], 0
  00dc0	74 39		 je	 SHORT $LN93@main
  00dc2	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR mtpos$[rsp]
  00dc9	c1 f8 18	 sar	 eax, 24
  00dcc	83 e0 7f	 and	 eax, 127		; 0000007fH
  00dcf	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv506[rsp], eax
  00dd6	b9 02 00 00 00	 mov	 ecx, 2
  00ddb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00de1	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv506[rsp]
  00de8	44 8b c1	 mov	 r8d, ecx
  00deb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169661
  00df2	48 8b c8	 mov	 rcx, rax
  00df5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN93@main:
  00dfb	33 c0		 xor	 eax, eax
  00dfd	85 c0		 test	 eax, eax
  00dff	75 b5		 jne	 SHORT $LN24@main
  00e01	eb 35		 jmp	 SHORT $LN92@main
$LN91@main:
$LN27@main:

; 748  :                     else
; 749  :                         EXTGUIMSG( "BLK=%ld\n", mtpos.mt_blkno );

  00e03	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00e0a	83 38 00	 cmp	 DWORD PTR [rax], 0
  00e0d	74 23		 je	 SHORT $LN94@main
  00e0f	b9 02 00 00 00	 mov	 ecx, 2
  00e14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e1a	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR mtpos$[rsp]
  00e22	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169663
  00e29	48 8b c8	 mov	 rcx, rax
  00e2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN94@main:
  00e32	33 c0		 xor	 eax, eax
  00e34	85 c0		 test	 eax, eax
  00e36	75 cb		 jne	 SHORT $LN27@main
$LN92@main:
$LN90@main:
$LN89@main:
$LN88@main:

; 750  :                 }
; 751  :             }
; 752  :         }
; 753  : 
; 754  :         /* Save previous block length */
; 755  :         prevlen = len;

  00e38	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR len
  00e3e	89 05 00 00 00
	00		 mov	 DWORD PTR prevlen, eax

; 756  : 
; 757  :         /* Read a block */
; 758  :         if (devnamein)

  00e44	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  00e4c	74 26		 je	 SHORT $LN95@main

; 759  :             len = read_scsi_tape(devfd, buf, sizeof(buf), &mtget);

  00e4e	4c 8d 8c 24 80
	01 00 00	 lea	 r9, QWORD PTR mtget$[rsp]
  00e56	41 b8 00 00 20
	00		 mov	 r8d, 2097152		; 00200000H
  00e5c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  00e63	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  00e67	e8 00 00 00 00	 call	 read_scsi_tape
  00e6c	89 05 00 00 00
	00		 mov	 DWORD PTR len, eax
  00e72	eb 1f		 jmp	 SHORT $LN96@main
$LN95@main:

; 760  :         else
; 761  :             len = read_aws_disk(diskfd, buf, sizeof(buf));

  00e74	41 b8 00 00 20
	00		 mov	 r8d, 2097152		; 00200000H
  00e7a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  00e81	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  00e88	e8 00 00 00 00	 call	 read_aws_disk
  00e8d	89 05 00 00 00
	00		 mov	 DWORD PTR len, eax
$LN96@main:

; 762  : 
; 763  :         /* If returned with -1, end of tape; errors are handled by the
; 764  :             read functions themselves */
; 765  :         if (len < 0)

  00e93	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR len, 0
  00e9a	7d 05		 jge	 SHORT $LN97@main

; 766  :             break;

  00e9c	e9 40 05 00 00	 jmp	 $LN21@main
$LN97@main:

; 767  : 
; 768  :         /* Check for tape mark */
; 769  :         if (len == 0)

  00ea1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR len, 0
  00ea8	0f 85 30 02 00
	00		 jne	 $LN98@main

; 770  :         {
; 771  :             /* Write tape mark to output file */
; 772  :             if (filenameout)

  00eae	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR filenameout, 0
  00eb6	74 0e		 je	 SHORT $LN99@main

; 773  :                 write_tapemark_aws_disk(diskfd);

  00eb8	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  00ebf	e8 00 00 00 00	 call	 write_tapemark_aws_disk
  00ec4	eb 09		 jmp	 SHORT $LN100@main
$LN99@main:

; 774  :             else
; 775  :                 write_tapemark_scsi_tape(devfd);

  00ec6	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  00eca	e8 00 00 00 00	 call	 write_tapemark_scsi_tape
$LN100@main:

; 776  : 
; 777  :             /* Print summary of current file */
; 778  :             if (blkcount)

  00ecf	83 7c 24 78 00	 cmp	 DWORD PTR blkcount$[rsp], 0
  00ed4	0f 84 0a 01 00
	00		 je	 $LN101@main
$LN30@main:

; 779  :             {
; 780  :                 ASSERT( file_bytes ); // (sanity check)

  00eda	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR file_bytes$[rsp], 0
  00ee3	75 5c		 jne	 SHORT $LN103@main
$LN33@main:
  00ee5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169673
  00eec	41 b8 0c 03 00
	00		 mov	 r8d, 780		; 0000030cH
  00ef2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169674
  00ef9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169675
  00f00	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00f06	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00f0c	85 c0		 test	 eax, eax
  00f0e	74 20		 je	 SHORT $LN104@main
  00f10	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169677
  00f17	41 b8 0c 03 00
	00		 mov	 r8d, 780		; 0000030cH
  00f1d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169678
  00f24	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169679
  00f2b	e8 00 00 00 00	 call	 DebuggerTrace
$LN104@main:
  00f30	33 c0		 xor	 eax, eax
  00f32	85 c0		 test	 eax, eax
  00f34	75 af		 jne	 SHORT $LN33@main
  00f36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00f3c	85 c0		 test	 eax, eax
  00f3e	74 01		 je	 SHORT $LN105@main
  00f40	cc		 int	 3
$LN105@main:
$LN103@main:
  00f41	33 c0		 xor	 eax, eax
  00f43	85 c0		 test	 eax, eax
  00f45	75 93		 jne	 SHORT $LN30@main

; 781  : 
; 782  :                 // "File No. %u: Blocks=%u, Bytes=%"PRId64", Block size min=%u, max=%u, avg=%u"
; 783  :                 WRMSG( HHC02721, "I", fileno, blkcount, file_bytes, minblksz, maxblksz, (int)file_bytes/blkcount );

  00f47	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR file_bytes$[rsp]
  00f4e	99		 cdq
  00f4f	f7 7c 24 78	 idiv	 DWORD PTR blkcount$[rsp]
  00f53	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv582[rsp], eax
  00f5a	b9 01 00 00 00	 mov	 ecx, 1
  00f5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f65	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv582[rsp]
  00f6c	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00f70	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR maxblksz$[rsp]
  00f77	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00f7b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR minblksz$[rsp]
  00f82	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00f86	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR file_bytes$[rsp]
  00f8e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f93	8b 4c 24 78	 mov	 ecx, DWORD PTR blkcount$[rsp]
  00f97	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f9b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR fileno$[rsp]
  00fa2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00fa6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169681
  00fad	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fb2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169682
  00fb9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fbe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fc3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fc9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169683
  00fd0	ba 0f 03 00 00	 mov	 edx, 783		; 0000030fH
  00fd5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169684
  00fdc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 784  :             }

  00fe2	eb 6d		 jmp	 SHORT $LN102@main
$LN101@main:
$LN36@main:

; 785  :             else
; 786  :             {
; 787  :                 ASSERT( !file_bytes ); // (sanity check)

  00fe4	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR file_bytes$[rsp], 0
  00fed	74 5c		 je	 SHORT $LN106@main
$LN39@main:
  00fef	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169686
  00ff6	41 b8 13 03 00
	00		 mov	 r8d, 787		; 00000313H
  00ffc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169687
  01003	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169688
  0100a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01016	85 c0		 test	 eax, eax
  01018	74 20		 je	 SHORT $LN107@main
  0101a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169690
  01021	41 b8 13 03 00
	00		 mov	 r8d, 787		; 00000313H
  01027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169691
  0102e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169692
  01035	e8 00 00 00 00	 call	 DebuggerTrace
$LN107@main:
  0103a	33 c0		 xor	 eax, eax
  0103c	85 c0		 test	 eax, eax
  0103e	75 af		 jne	 SHORT $LN39@main
  01040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01046	85 c0		 test	 eax, eax
  01048	74 01		 je	 SHORT $LN108@main
  0104a	cc		 int	 3
$LN108@main:
$LN106@main:
  0104b	33 c0		 xor	 eax, eax
  0104d	85 c0		 test	 eax, eax
  0104f	75 93		 jne	 SHORT $LN36@main
$LN102@main:

; 788  :             }
; 789  : 
; 790  :             /* Show the 'tapemark' AFTER the above file summary since
; 791  :                that's the actual physical sequence of events; i.e. the
; 792  :                file data came first THEN it was followed by a tapemark
; 793  :             */
; 794  :             WRMSG( HHC02731, "I" );     // "(tapemark)"

  01051	b9 01 00 00 00	 mov	 ecx, 1
  01056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0105c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169694
  01063	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169695
  0106f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01074	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01079	41 b9 03 00 00
	00		 mov	 r9d, 3
  0107f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169696
  01086	ba 1a 03 00 00	 mov	 edx, 794		; 0000031aH
  0108b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169697
  01092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 795  : 
; 796  :             /* Reset counters for next file */
; 797  :             if (blkcount)

  01098	83 7c 24 78 00	 cmp	 DWORD PTR blkcount$[rsp], 0
  0109d	74 10		 je	 SHORT $LN109@main

; 798  :                 fileno++;

  0109f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fileno$[rsp]
  010a6	ff c0		 inc	 eax
  010a8	89 84 24 94 00
	00 00		 mov	 DWORD PTR fileno$[rsp], eax
$LN109@main:

; 799  :             minblksz = 0;

  010af	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR minblksz$[rsp], 0

; 800  :             maxblksz = 0;

  010ba	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR maxblksz$[rsp], 0

; 801  :             blkcount = 0;

  010c5	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR blkcount$[rsp], 0

; 802  :             file_bytes = 0;

  010cd	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR file_bytes$[rsp], 0

; 803  :             continue;

  010d9	e9 60 fc ff ff	 jmp	 $LN20@main
$LN98@main:

; 804  :         }
; 805  : 
; 806  :         /* Count blocks and block sizes */
; 807  :         blkcount++;

  010de	8b 44 24 78	 mov	 eax, DWORD PTR blkcount$[rsp]
  010e2	ff c0		 inc	 eax
  010e4	89 44 24 78	 mov	 DWORD PTR blkcount$[rsp], eax

; 808  :         totalblks++;

  010e8	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR totalblks$[rsp]
  010ef	ff c0		 inc	 eax
  010f1	89 84 24 84 00
	00 00		 mov	 DWORD PTR totalblks$[rsp], eax

; 809  :         bytes_read += len;

  010f8	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR len
  010ff	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR bytes_read$[rsp]
  01107	48 03 c8	 add	 rcx, rax
  0110a	48 8b c1	 mov	 rax, rcx
  0110d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR bytes_read$[rsp], rax

; 810  :         file_bytes += len;

  01115	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR len
  0111c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR file_bytes$[rsp]
  01124	48 03 c8	 add	 rcx, rax
  01127	48 8b c1	 mov	 rax, rcx
  0112a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR file_bytes$[rsp], rax

; 811  :         if (len > maxblksz) maxblksz = len;

  01132	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR maxblksz$[rsp]
  01139	39 05 00 00 00
	00		 cmp	 DWORD PTR len, eax
  0113f	7e 0d		 jle	 SHORT $LN110@main
  01141	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR len
  01147	89 84 24 90 00
	00 00		 mov	 DWORD PTR maxblksz$[rsp], eax
$LN110@main:

; 812  :         if (minblksz == 0 || len < minblksz) minblksz = len;

  0114e	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR minblksz$[rsp], 0
  01156	74 0f		 je	 SHORT $LN112@main
  01158	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR minblksz$[rsp]
  0115f	39 05 00 00 00
	00		 cmp	 DWORD PTR len, eax
  01165	7d 0d		 jge	 SHORT $LN111@main
$LN112@main:
  01167	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR len
  0116d	89 84 24 88 00
	00 00		 mov	 DWORD PTR minblksz$[rsp], eax
$LN111@main:

; 813  : 
; 814  :         /* Print standard labels */
; 815  :         if (1
; 816  :             && blkcount < 4
; 817  :             && len == 80
; 818  :             && (0

  01174	33 c0		 xor	 eax, eax
  01176	83 f8 01	 cmp	 eax, 1
  01179	0f 84 5d 01 00
	00		 je	 $LN113@main
  0117f	83 7c 24 78 04	 cmp	 DWORD PTR blkcount$[rsp], 4
  01184	0f 8d 52 01 00
	00		 jge	 $LN113@main
  0118a	83 3d 00 00 00
	00 50		 cmp	 DWORD PTR len, 80	; 00000050H
  01191	0f 85 45 01 00
	00		 jne	 $LN113@main
  01197	33 c0		 xor	 eax, eax
  01199	85 c0		 test	 eax, eax
  0119b	75 78		 jne	 SHORT $LN115@main
  0119d	41 b8 03 00 00
	00		 mov	 r8d, 3
  011a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:vollbl
  011aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  011b1	e8 00 00 00 00	 call	 memcmp
  011b6	85 c0		 test	 eax, eax
  011b8	74 5b		 je	 SHORT $LN115@main
  011ba	41 b8 03 00 00
	00		 mov	 r8d, 3
  011c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hdrlbl
  011c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  011ce	e8 00 00 00 00	 call	 memcmp
  011d3	85 c0		 test	 eax, eax
  011d5	74 3e		 je	 SHORT $LN115@main
  011d7	41 b8 03 00 00
	00		 mov	 r8d, 3
  011dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:eoflbl
  011e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  011eb	e8 00 00 00 00	 call	 memcmp
  011f0	85 c0		 test	 eax, eax
  011f2	74 21		 je	 SHORT $LN115@main
  011f4	41 b8 03 00 00
	00		 mov	 r8d, 3
  011fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:eovlbl
  01201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  01208	e8 00 00 00 00	 call	 memcmp
  0120d	85 c0		 test	 eax, eax
  0120f	0f 85 c7 00 00
	00		 jne	 $LN113@main
$LN115@main:

; 819  :                 || memcmp( buf, vollbl, 3 ) == 0
; 820  :                 || memcmp( buf, hdrlbl, 3 ) == 0
; 821  :                 || memcmp( buf, eoflbl, 3 ) == 0
; 822  :                 || memcmp( buf, eovlbl, 3 ) == 0
; 823  :                )
; 824  :         )
; 825  :         {
; 826  :             for (i=0; i < 80; i++)

  01215	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0121d	eb 0a		 jmp	 SHORT $LN42@main
$LN40@main:
  0121f	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  01223	ff c0		 inc	 eax
  01225	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN42@main:
  01229	83 7c 24 70 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  0122e	7d 24		 jge	 SHORT $LN41@main

; 827  :                 labelrec[i] = guest_to_host(buf[i]);

  01230	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  01235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0123c	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  01240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  01246	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  0124b	88 84 0c 20 02
	00 00		 mov	 BYTE PTR labelrec$[rsp+rcx], al
  01252	eb cb		 jmp	 SHORT $LN40@main
$LN41@main:

; 828  :             labelrec[i] = '\0';

  01254	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  01259	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR $T1[rsp], rax
  01261	48 83 bc 24 10
	01 00 00 51	 cmp	 QWORD PTR $T1[rsp], 81	; 00000051H
  0126a	73 02		 jae	 SHORT $LN142@main
  0126c	eb 05		 jmp	 SHORT $LN143@main
$LN142@main:
  0126e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN143@main:
  01273	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  0127b	c6 84 04 20 02
	00 00 00	 mov	 BYTE PTR labelrec$[rsp+rax], 0

; 829  :             // "Tape Label: %s"
; 830  :             WRMSG( HHC02722, "I", labelrec );

  01283	b9 01 00 00 00	 mov	 ecx, 1
  01288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0128e	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR labelrec$[rsp]
  01296	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0129b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169705
  012a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169706
  012ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  012be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169707
  012c5	ba 3e 03 00 00	 mov	 edx, 830		; 0000033eH
  012ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169708
  012d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 831  :         }

  012d7	e9 bd 00 00 00	 jmp	 $LN114@main
$LN113@main:
$LN45@main:

; 832  :         else
; 833  :         {
; 834  :             ASSERT(blkcount);

  012dc	83 7c 24 78 00	 cmp	 DWORD PTR blkcount$[rsp], 0
  012e1	75 5c		 jne	 SHORT $LN116@main
$LN48@main:
  012e3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169710
  012ea	41 b8 42 03 00
	00		 mov	 r8d, 834		; 00000342H
  012f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169711
  012f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169712
  012fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0130a	85 c0		 test	 eax, eax
  0130c	74 20		 je	 SHORT $LN117@main
  0130e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169714
  01315	41 b8 42 03 00
	00		 mov	 r8d, 834		; 00000342H
  0131b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169715
  01322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169716
  01329	e8 00 00 00 00	 call	 DebuggerTrace
$LN117@main:
  0132e	33 c0		 xor	 eax, eax
  01330	85 c0		 test	 eax, eax
  01332	75 af		 jne	 SHORT $LN48@main
  01334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0133a	85 c0		 test	 eax, eax
  0133c	74 01		 je	 SHORT $LN118@main
  0133e	cc		 int	 3
$LN118@main:
$LN116@main:
  0133f	33 c0		 xor	 eax, eax
  01341	85 c0		 test	 eax, eax
  01343	75 97		 jne	 SHORT $LN45@main

; 835  : 
; 836  :             if (!extgui)

  01345	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0134c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0134f	75 48		 jne	 SHORT $LN119@main

; 837  :             {
; 838  :                 char msgbuf[100];
; 839  :                 // "File No. %u: Block %u"
; 840  :                 MSGBUF( msgbuf, MSG_C( HHC02723, "I", fileno, blkcount ));

  01351	8b 44 24 78	 mov	 eax, DWORD PTR blkcount$[rsp]
  01355	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01359	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fileno$[rsp]
  01360	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01364	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169719
  0136b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169720
  01372	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  01377	48 8d 8c 24 90
	03 00 00	 lea	 rcx, QWORD PTR msgbuf$4[rsp]
  0137f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 841  :                 printf( "%s\r", msgbuf );

  01385	48 8d 94 24 90
	03 00 00	 lea	 rdx, QWORD PTR msgbuf$4[rsp]
  0138d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169721
  01394	e8 00 00 00 00	 call	 printf
$LN119@main:
$LN114@main:

; 842  :             }
; 843  :         }
; 844  : 
; 845  :         /* Write block to output file */
; 846  :         if (filenameout)

  01399	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR filenameout, 0
  013a1	74 1f		 je	 SHORT $LN120@main

; 847  :             write_aws_disk(diskfd, buf, len);

  013a3	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR len
  013aa	4c 8b c0	 mov	 r8, rax
  013ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  013b4	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  013bb	e8 00 00 00 00	 call	 write_aws_disk
  013c0	eb 1a		 jmp	 SHORT $LN121@main
$LN120@main:

; 848  :         else
; 849  :             write_scsi_tape(devfd, buf, len);

  013c2	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR len
  013c9	4c 8b c0	 mov	 r8, rax
  013cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  013d3	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  013d7	e8 00 00 00 00	 call	 write_scsi_tape
$LN121@main:

; 850  : 
; 851  :     } /* end while */

  013dc	e9 5d f9 ff ff	 jmp	 $LN148@main
$LN21@main:

; 852  : 
; 853  :     /* Print run totals, close files, and exit... */
; 854  : 
; 855  :     // "Successful completion"
; 856  :     WRMSG( HHC02724, "I" );

  013e1	b9 01 00 00 00	 mov	 ecx, 1
  013e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169724
  013f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169725
  013ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01404	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01409	41 b9 03 00 00
	00		 mov	 r9d, 3
  0140f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169726
  01416	ba 58 03 00 00	 mov	 edx, 856		; 00000358H
  0141b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169727
  01422	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 857  : 
; 858  :     // "Bytes read:    %"PRId64" (%3.1f MB), Blocks=%u, avg=%u"
; 859  :     WRMSG( HHC02732, "I",

  01428	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR totalblks$[rsp], 0
  01430	74 18		 je	 SHORT $LN144@main
  01432	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR bytes_read$[rsp]
  01439	99		 cdq
  0143a	f7 bc 24 84 00
	00 00		 idiv	 DWORD PTR totalblks$[rsp]
  01441	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv764[rsp], eax
  01448	eb 0b		 jmp	 SHORT $LN145@main
$LN144@main:
  0144a	c7 84 24 b8 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv764[rsp], -1
$LN145@main:
  01455	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR bytes_read$[rsp]
  0145d	48 05 00 00 08
	00		 add	 rax, 524288		; 00080000H
  01463	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  01468	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4130000000000000
  01470	f2 0f 11 84 24
	60 01 00 00	 movsd	 QWORD PTR tv801[rsp], xmm0
  01479	b9 01 00 00 00	 mov	 ecx, 1
  0147e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01484	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv764[rsp]
  0148b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0148f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR totalblks$[rsp]
  01496	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0149a	f2 0f 10 84 24
	60 01 00 00	 movsd	 xmm0, QWORD PTR tv801[rsp]
  014a3	f2 0f 11 44 24
	40		 movsd	 QWORD PTR [rsp+64], xmm0
  014a9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR bytes_read$[rsp]
  014b1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  014b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169728
  014bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169729
  014c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  014d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169730
  014e0	ba 5f 03 00 00	 mov	 edx, 863		; 0000035fH
  014e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169731
  014ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 860  :         bytes_read,
; 861  :         (double) (bytes_read + HALF_MEGABYTE) / (double) ONE_MEGABYTE,
; 862  :         totalblks,
; 863  :         totalblks ? (int) bytes_read/totalblks : -1 );
; 864  : 
; 865  :     // "Bytes written: %"PRId64" (%3.1f MB)"
; 866  :     WRMSG( HHC02733, "I",

  014f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR bytes_written
  014f9	48 05 00 00 08
	00		 add	 rax, 524288		; 00080000H
  014ff	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  01504	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4130000000000000
  0150c	f2 0f 11 84 24
	68 01 00 00	 movsd	 QWORD PTR tv815[rsp], xmm0
  01515	b9 01 00 00 00	 mov	 ecx, 1
  0151a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01520	f2 0f 10 84 24
	68 01 00 00	 movsd	 xmm0, QWORD PTR tv815[rsp]
  01529	f2 0f 11 44 24
	40		 movsd	 QWORD PTR [rsp+64], xmm0
  0152f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bytes_written
  01536	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0153b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169732
  01542	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01547	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169733
  0154e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01553	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01558	41 b9 03 00 00
	00		 mov	 r9d, 3
  0155e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169734
  01565	ba 64 03 00 00	 mov	 edx, 868		; 00000364H
  0156a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169735
  01571	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 867  :         bytes_written,
; 868  :         (double) (bytes_written + HALF_MEGABYTE) / (double) ONE_MEGABYTE );
; 869  : 
; 870  :     close (diskfd);

  01577	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  0157e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 871  : 
; 872  :     /* Rewind the tape back to the beginning again before exiting */
; 873  : 
; 874  :     opblk.mt_op = MTREW;

  01584	b8 06 00 00 00	 mov	 eax, 6
  01589	66 89 84 24 98
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 875  :     opblk.mt_count = 1;

  01591	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 1

; 876  : 
; 877  :     rc = ioctl_tape (devfd, MTIOCTOP, (char*)&opblk);

  0159c	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  015a4	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  015a9	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  015ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  015b3	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 878  : 
; 879  :     if (rc < 0)

  015b7	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  015bc	0f 8d cf 00 00
	00		 jge	 $LN122@main

; 880  :     {
; 881  :         // "Tape %s: Error rewinding: rc=%d, errno=%d: %s"
; 882  :         FWRMSG( stderr, HHC02717, "E", (devnamein ? devnamein : devnameout),

  015c2	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  015ca	74 11		 je	 SHORT $LN146@main
  015cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnamein
  015d3	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv841[rsp], rax
  015db	eb 0f		 jmp	 SHORT $LN147@main
$LN146@main:
  015dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR devnameout
  015e4	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv841[rsp], rax
$LN147@main:
  015ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  015f2	8b 08		 mov	 ecx, DWORD PTR [rax]
  015f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  015fa	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv833[rsp], rax
  01602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01608	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv837[rsp], rax
  01610	b9 02 00 00 00	 mov	 ecx, 2
  01615	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0161b	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv833[rsp]
  01623	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01628	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv837[rsp]
  01630	8b 09		 mov	 ecx, DWORD PTR [rcx]
  01632	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01636	8b 4c 24 7c	 mov	 ecx, DWORD PTR rc$[rsp]
  0163a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0163e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv841[rsp]
  01646	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0164b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169737
  01652	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01657	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169738
  0165e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01663	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01668	41 b9 03 00 00
	00		 mov	 r9d, 3
  0166e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169739
  01675	ba 73 03 00 00	 mov	 edx, 883		; 00000373H
  0167a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169740
  01681	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 883  :             rc, errno, strerror( errno ));
; 884  :         DELAYED_EXIT( RC_ERROR_REWINDING_SCSI );

  01687	b9 06 00 00 00	 mov	 ecx, 6
  0168c	e8 00 00 00 00	 call	 delayed_exit
$LN122@main:

; 885  :     }
; 886  : 
; 887  :     close_tape (devfd);

  01691	8b 4c 24 74	 mov	 ecx, DWORD PTR devfd$[rsp]
  01695	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_tape

; 888  : 
; 889  :     DELAYED_EXIT( RC_SUCCESS );

  0169b	33 c9		 xor	 ecx, ecx
  0169d	e8 00 00 00 00	 call	 delayed_exit
$LN123@main:

; 890  :     UNREACHABLE_CODE( return RC_SUCCESS );
; 891  : 
; 892  : } /* end function main */

  016a2	48 8b 8c 24 00
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  016aa	48 33 cc	 xor	 rcx, rsp
  016ad	e8 00 00 00 00	 call	 __security_check_cookie
  016b2	48 81 c4 18 04
	00 00		 add	 rsp, 1048		; 00000418H
  016b9	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
rc$ = 96
tv82 = 104
tv86 = 112
awshdr$ = 120
__$ArrayPad$ = 128
diskfd$ = 160
write_tapemark_aws_disk PROC

; 476  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 477  :     AWSTAPE_BLKHDR  awshdr;             /* AWSTAPE block header      */
; 478  :     int             rc;
; 479  : 
; 480  :     /* Build block header for tape mark */
; 481  :     awshdr.curblkl[0] = 0;

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 00	 imul	 rax, rax, 0
  00026	c6 44 04 78 00	 mov	 BYTE PTR awshdr$[rsp+rax], 0

; 482  :     awshdr.curblkl[1] = 0;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 01	 imul	 rax, rax, 1
  00034	c6 44 04 78 00	 mov	 BYTE PTR awshdr$[rsp+rax], 0

; 483  :     awshdr.prvblkl[0] =   prevlen        & 0xFF;

  00039	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR prevlen
  0003f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	48 6b c9 00	 imul	 rcx, rcx, 0
  0004d	88 44 0c 7a	 mov	 BYTE PTR awshdr$[rsp+rcx+2], al

; 484  :     awshdr.prvblkl[1] = ( prevlen >> 8 ) & 0xFF;

  00051	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR prevlen
  00057	c1 f8 08	 sar	 eax, 8
  0005a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	48 6b c9 01	 imul	 rcx, rcx, 1
  00068	88 44 0c 7a	 mov	 BYTE PTR awshdr$[rsp+rcx+2], al

; 485  :     awshdr.flags1     = AWSTAPE_FLAG1_TAPEMARK;

  0006c	c6 44 24 7c 40	 mov	 BYTE PTR awshdr$[rsp+4], 64 ; 00000040H

; 486  :     awshdr.flags2     = 0;

  00071	c6 44 24 7d 00	 mov	 BYTE PTR awshdr$[rsp+5], 0

; 487  : 
; 488  :     /* Write block header to output file */
; 489  :     rc = write (diskfd, &awshdr, sizeof(AWSTAPE_BLKHDR));

  00076	41 b8 06 00 00
	00		 mov	 r8d, 6
  0007c	48 8d 54 24 78	 lea	 rdx, QWORD PTR awshdr$[rsp]
  00081	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0008e	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 490  :     if (rc < (int)sizeof(AWSTAPE_BLKHDR))

  00092	83 7c 24 60 06	 cmp	 DWORD PTR rc$[rsp], 6
  00097	0f 8d a4 00 00
	00		 jge	 $LN2@write_tape

; 491  :     {
; 492  :         // "File %s: Error writing %s tapemark: rc=%d, errno=%d: %s"
; 493  :         FWRMSG( stderr, HHC02714, "E", filenameout, "AWS emulated",

  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a3	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000ab	48 89 44 24 68	 mov	 QWORD PTR tv82[rsp], rax
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b6	48 89 44 24 70	 mov	 QWORD PTR tv86[rsp], rax
  000bb	b9 02 00 00 00	 mov	 ecx, 2
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv82[rsp]
  000cb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv86[rsp]
  000d5	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000d7	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000db	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  000df	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169460
  000ea	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR filenameout
  000f6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169461
  00102	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169462
  0010e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00113	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00118	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169463
  00125	ba ee 01 00 00	 mov	 edx, 494		; 000001eeH
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169464
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 494  :             rc, errno, strerror( errno ));
; 495  :         DELAYED_EXIT( RC_ERROR_WRITING_TAPEMARK );

  00137	b9 0b 00 00 00	 mov	 ecx, 11
  0013c	e8 00 00 00 00	 call	 delayed_exit
$LN2@write_tape:

; 496  :     } /* end if(rc) */
; 497  : 
; 498  :     bytes_written += rc;

  00141	48 63 44 24 60	 movsxd	 rax, DWORD PTR rc$[rsp]
  00146	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bytes_written
  0014d	48 03 c8	 add	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	48 89 05 00 00
	00 00		 mov	 QWORD PTR bytes_written, rax

; 499  :     return(rc);

  0015a	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]

; 500  : } /* end function write_tapemark_aws_disk */

  0015e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00166	48 33 cc	 xor	 rcx, rsp
  00169	e8 00 00 00 00	 call	 __security_check_cookie
  0016e	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00175	c3		 ret	 0
write_tapemark_aws_disk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
rc$ = 96
opblk$ = 104
tv69 = 112
tv73 = 120
devfd$ = 144
write_tapemark_scsi_tape PROC

; 454  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 455  :     struct mtop     opblk;              /* Area for MTIOCTOP ioctl   */
; 456  :     int             rc;
; 457  : 
; 458  :     opblk.mt_op = MTWEOF;

  0000b	b8 05 00 00 00	 mov	 eax, 5
  00010	66 89 44 24 68	 mov	 WORD PTR opblk$[rsp], ax

; 459  :     opblk.mt_count = 1;

  00015	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR opblk$[rsp+4], 1

; 460  :     rc = ioctl_tape (devfd, MTIOCTOP, (char*)&opblk);

  0001d	4c 8d 44 24 68	 lea	 r8, QWORD PTR opblk$[rsp]
  00022	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  00027	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR devfd$[rsp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00034	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 461  :     if (rc < 0)

  00038	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0003d	0f 8d 98 00 00
	00		 jge	 $LN2@write_tape

; 462  :     {
; 463  :         // "Tape %s: Error writing tapemark: rc=%d, errno=%d: %s"
; 464  :         FWRMSG( stderr, HHC02713, "E", devnameout,

  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00049	8b 08		 mov	 ecx, DWORD PTR [rax]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00051	48 89 44 24 70	 mov	 QWORD PTR tv69[rsp], rax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005c	48 89 44 24 78	 mov	 QWORD PTR tv73[rsp], rax
  00061	b9 02 00 00 00	 mov	 ecx, 2
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv69[rsp]
  00071	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00076	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv73[rsp]
  0007b	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0007d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00081	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  00085	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR devnameout
  00090	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169446
  0009c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169447
  000a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169448
  000bf	ba d1 01 00 00	 mov	 edx, 465		; 000001d1H
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169449
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 465  :             rc, errno, strerror( errno ));
; 466  :         DELAYED_EXIT( RC_ERROR_WRITING_TAPEMARK );

  000d1	b9 0b 00 00 00	 mov	 ecx, 11
  000d6	e8 00 00 00 00	 call	 delayed_exit
$LN2@write_tape:

; 467  :     }
; 468  :     return(rc);

  000db	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]

; 469  : 
; 470  : } /* end function write_tapemark_scsi_tape */

  000df	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000e6	c3		 ret	 0
write_tapemark_scsi_tape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
rc$ = 96
tv87 = 104
tv91 = 112
tv145 = 120
tv149 = 128
awshdr$ = 136
__$ArrayPad$ = 144
diskfd$ = 176
buf$ = 184
len$ = 192
write_aws_disk PROC

; 404  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 405  :     AWSTAPE_BLKHDR  awshdr;             /* AWSTAPE block header      */
; 406  :     int             rc;
; 407  : 
; 408  :     /* Build the block header */
; 409  :     awshdr.curblkl[0] =   len            & 0xFF;

  00027	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0002f	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00035	b9 01 00 00 00	 mov	 ecx, 1
  0003a	48 6b c9 00	 imul	 rcx, rcx, 0
  0003e	88 84 0c 88 00
	00 00		 mov	 BYTE PTR awshdr$[rsp+rcx], al

; 410  :     awshdr.curblkl[1] = ( len     >> 8 ) & 0xFF;

  00045	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0004d	48 c1 e8 08	 shr	 rax, 8
  00051	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00057	b9 01 00 00 00	 mov	 ecx, 1
  0005c	48 6b c9 01	 imul	 rcx, rcx, 1
  00060	88 84 0c 88 00
	00 00		 mov	 BYTE PTR awshdr$[rsp+rcx], al

; 411  :     awshdr.prvblkl[0] =   prevlen        & 0xFF;

  00067	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR prevlen
  0006d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00072	b9 01 00 00 00	 mov	 ecx, 1
  00077	48 6b c9 00	 imul	 rcx, rcx, 0
  0007b	88 84 0c 8a 00
	00 00		 mov	 BYTE PTR awshdr$[rsp+rcx+2], al

; 412  :     awshdr.prvblkl[1] = ( prevlen >> 8 ) & 0xFF;

  00082	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR prevlen
  00088	c1 f8 08	 sar	 eax, 8
  0008b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	48 6b c9 01	 imul	 rcx, rcx, 1
  00099	88 84 0c 8a 00
	00 00		 mov	 BYTE PTR awshdr$[rsp+rcx+2], al

; 413  :     awshdr.flags1     = 0

  000a0	c6 84 24 8c 00
	00 00 a0	 mov	 BYTE PTR awshdr$[rsp+4], 160 ; 000000a0H

; 414  :                         | AWSTAPE_FLAG1_NEWREC
; 415  :                         | AWSTAPE_FLAG1_ENDREC
; 416  :                         ;
; 417  :     awshdr.flags2     = 0;

  000a8	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR awshdr$[rsp+5], 0

; 418  : 
; 419  :     /* Write block header to output file */
; 420  :     rc = write (diskfd, &awshdr, sizeof(AWSTAPE_BLKHDR));

  000b0	41 b8 06 00 00
	00		 mov	 r8d, 6
  000b6	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR awshdr$[rsp]
  000be	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  000cb	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 421  :     if (rc < (int)sizeof(AWSTAPE_BLKHDR))

  000cf	83 7c 24 60 06	 cmp	 DWORD PTR rc$[rsp], 6
  000d4	0f 8d a4 00 00
	00		 jge	 $LN2@write_aws_

; 422  :     {
; 423  :         // "File %s: Error writing %s header: rc=%d, errno=%d: %s"
; 424  :         FWRMSG( stderr, HHC02711, "E", filenameout, "AWS emulated tape file",

  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e0	8b 08		 mov	 ecx, DWORD PTR [rax]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000e8	48 89 44 24 68	 mov	 QWORD PTR tv87[rsp], rax
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f3	48 89 44 24 70	 mov	 QWORD PTR tv91[rsp], rax
  000f8	b9 02 00 00 00	 mov	 ecx, 2
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv87[rsp]
  00108	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0010d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv91[rsp]
  00112	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00114	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00118	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  0011c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169425
  00127	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0012c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR filenameout
  00133	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169426
  0013f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169427
  0014b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00150	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00155	41 b9 03 00 00
	00		 mov	 r9d, 3
  0015b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169428
  00162	ba a9 01 00 00	 mov	 edx, 425		; 000001a9H
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169429
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 425  :             rc, errno, strerror( errno ));
; 426  :         DELAYED_EXIT( RC_ERROR_WRITING_OUTPUT_AWS_HEADER_BLOCK );

  00174	b9 0c 00 00 00	 mov	 ecx, 12
  00179	e8 00 00 00 00	 call	 delayed_exit
$LN2@write_aws_:

; 427  :     } /* end if(rc) */
; 428  : 
; 429  :     bytes_written += rc;

  0017e	48 63 44 24 60	 movsxd	 rax, DWORD PTR rc$[rsp]
  00183	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bytes_written
  0018a	48 03 c8	 add	 rcx, rax
  0018d	48 8b c1	 mov	 rax, rcx
  00190	48 89 05 00 00
	00 00		 mov	 QWORD PTR bytes_written, rax

; 430  : 
; 431  :     /* Write data block to output file */
; 432  : #if defined( _MSVC_ )
; 433  :     rc = write (diskfd, buf, (u_int)len);

  00197	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0019f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001a7	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  001b4	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 434  : #else
; 435  :     rc = write (diskfd, buf, len);
; 436  : #endif
; 437  :     if (rc < (int)len)

  001b8	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001bf	39 44 24 60	 cmp	 DWORD PTR rc$[rsp], eax
  001c3	0f 8d aa 00 00
	00		 jge	 $LN3@write_aws_

; 438  :     {
; 439  :         // "File %s: Error writing %s data block: rc=%d, errno=%d: %s"
; 440  :         FWRMSG( stderr, HHC02712, "E", filenameout, "AWS emulated tape",

  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001cf	8b 08		 mov	 ecx, DWORD PTR [rax]
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001d7	48 89 44 24 78	 mov	 QWORD PTR tv145[rsp], rax
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001e2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
  001ea	b9 02 00 00 00	 mov	 ecx, 2
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv145[rsp]
  001fa	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001ff	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv149[rsp]
  00207	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00209	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0020d	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  00211	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169431
  0021c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00221	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR filenameout
  00228	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169432
  00234	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00239	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169433
  00240	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00245	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00250	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169434
  00257	ba b9 01 00 00	 mov	 edx, 441		; 000001b9H
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169435
  00263	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 441  :             rc, errno, strerror( errno ));
; 442  :         DELAYED_EXIT( RC_ERROR_WRITING_DATA );

  00269	b9 0d 00 00 00	 mov	 ecx, 13
  0026e	e8 00 00 00 00	 call	 delayed_exit
$LN3@write_aws_:

; 443  :     } /* end if(rc) */
; 444  : 
; 445  :     bytes_written += rc;

  00273	48 63 44 24 60	 movsxd	 rax, DWORD PTR rc$[rsp]
  00278	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bytes_written
  0027f	48 03 c8	 add	 rcx, rax
  00282	48 8b c1	 mov	 rax, rcx
  00285	48 89 05 00 00
	00 00		 mov	 QWORD PTR bytes_written, rax

; 446  : 
; 447  :     return(rc);

  0028c	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]

; 448  : } /* end function write_aws_disk */

  00290	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00298	48 33 cc	 xor	 rcx, rsp
  0029b	e8 00 00 00 00	 call	 __security_check_cookie
  002a0	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002a7	c3		 ret	 0
write_aws_disk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
rc$ = 96
tv70 = 104
tv74 = 112
devfd$ = 144
buf$ = 152
len$ = 160
write_scsi_tape PROC

; 382  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 383  :     int                 rc;
; 384  : 
; 385  :     rc = write_tape (devfd, buf, len);

  00015	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  0001d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00025	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR devfd$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_write_tape
  00032	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 386  :     if (rc < (int)len)

  00036	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0003d	39 44 24 60	 cmp	 DWORD PTR rc$[rsp], eax
  00041	0f 8d 98 00 00
	00		 jge	 $LN2@write_scsi

; 387  :     {
; 388  :         // "Tape %s: Error writing data block: rc=%d, errno=%d: %s"
; 389  :         FWRMSG( stderr, HHC02710, "E", devnameout,

  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00055	48 89 44 24 68	 mov	 QWORD PTR tv70[rsp], rax
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00060	48 89 44 24 70	 mov	 QWORD PTR tv74[rsp], rax
  00065	b9 02 00 00 00	 mov	 ecx, 2
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00070	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv70[rsp]
  00075	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0007a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv74[rsp]
  0007f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00081	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00085	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  00089	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0008d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR devnameout
  00094	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169405
  000a0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169406
  000ac	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169407
  000c3	ba 86 01 00 00	 mov	 edx, 390		; 00000186H
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169408
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 390  :             rc, errno, strerror( errno ));
; 391  :         DELAYED_EXIT( RC_ERROR_WRITING_DATA );

  000d5	b9 0d 00 00 00	 mov	 ecx, 13
  000da	e8 00 00 00 00	 call	 delayed_exit
$LN2@write_scsi:

; 392  :     } /* end if(rc) */
; 393  : 
; 394  :     bytes_written += rc;

  000df	48 63 44 24 60	 movsxd	 rax, DWORD PTR rc$[rsp]
  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bytes_written
  000eb	48 03 c8	 add	 rcx, rax
  000ee	48 8b c1	 mov	 rax, rcx
  000f1	48 89 05 00 00
	00 00		 mov	 QWORD PTR bytes_written, rax

; 395  : 
; 396  :     return(rc);

  000f8	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]

; 397  : 
; 398  : } /* end function write_scsi_tape */

  000fc	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00103	c3		 ret	 0
write_scsi_tape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
blksize$ = 96
rc$ = 100
count_read$ = 104
tv144 = 108
tv150 = 112
end_block$ = 116
bufptr$ = 120
tv82 = 128
tv86 = 136
tv169 = 144
tv173 = 152
awshdr$ = 160
__$ArrayPad$ = 168
diskfd$ = 192
buf$ = 200
bufsize$ = 208
read_aws_disk PROC

; 315  : {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 316  :     AWSTAPE_BLKHDR  awshdr;                 /* AWSTAPE block header      */
; 317  :     int             rc;
; 318  :     unsigned int    count_read = 0;

  00027	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR count_read$[rsp], 0

; 319  :     unsigned int    blksize;
; 320  :     int             end_block;
; 321  :     BYTE           *bufptr = buf;

  0002f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00037	48 89 44 24 78	 mov	 QWORD PTR bufptr$[rsp], rax
$LN2@read_aws_d:

; 322  : 
; 323  :     while (1)

  0003c	33 c0		 xor	 eax, eax
  0003e	83 f8 01	 cmp	 eax, 1
  00041	0f 84 5f 03 00
	00		 je	 $LN3@read_aws_d

; 324  :     {
; 325  :         /* Read block header */
; 326  :         rc = read (diskfd, &awshdr, sizeof(AWSTAPE_BLKHDR));

  00047	41 b8 06 00 00
	00		 mov	 r8d, 6
  0004d	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR awshdr$[rsp]
  00055	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00062	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 327  :         if (rc == 0)

  00066	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  0006b	75 69		 jne	 SHORT $LN4@read_aws_d

; 328  :         {
; 329  :             // "File %s: End of %s input"
; 330  :             WRMSG( HHC02706, "I", filenamein, "AWS emulated tape" );

  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169369
  0007f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00084	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR filenamein
  0008b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169370
  00097	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169371
  000a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169372
  000ba	ba 4a 01 00 00	 mov	 edx, 330		; 0000014aH
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169373
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 331  :             return (-1);

  000cc	b8 ff ff ff ff	 mov	 eax, -1
  000d1	e9 d4 02 00 00	 jmp	 $LN1@read_aws_d
$LN4@read_aws_d:

; 332  :         }
; 333  :         if (rc < (int)sizeof(AWSTAPE_BLKHDR))

  000d6	83 7c 24 64 06	 cmp	 DWORD PTR rc$[rsp], 6
  000db	0f 8d b0 00 00
	00		 jge	 $LN5@read_aws_d

; 334  :         {
; 335  :             // "File %s: Error reading %s header: rc=%d, errno=%d: %s"
; 336  :             FWRMSG( stderr, HHC02707, "E", filenamein, "AWS eumulated tape file",

  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e7	8b 08		 mov	 ecx, DWORD PTR [rax]
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000ef	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000fd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  00105	b9 02 00 00 00	 mov	 ecx, 2
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  00118	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0011d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  00125	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00127	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0012b	8b 4c 24 64	 mov	 ecx, DWORD PTR rc$[rsp]
  0012f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169375
  0013a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0013f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR filenamein
  00146	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169376
  00152	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169377
  0015e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00163	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00168	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169378
  00175	ba 51 01 00 00	 mov	 edx, 337		; 00000151H
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169379
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 337  :                 rc, errno, strerror( errno ));
; 338  :             DELAYED_EXIT( RC_ERROR_READING_AWS_HEADER );

  00187	b9 08 00 00 00	 mov	 ecx, 8
  0018c	e8 00 00 00 00	 call	 delayed_exit
$LN5@read_aws_d:

; 339  :         } /* end if(rc) */
; 340  : 
; 341  :         /* Interpret the block header */
; 342  :         blksize = ((int)awshdr.curblkl[1] << 8) + awshdr.curblkl[0];

  00191	b8 01 00 00 00	 mov	 eax, 1
  00196	48 6b c0 01	 imul	 rax, rax, 1
  0019a	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR awshdr$[rsp+rax]
  001a2	c1 e0 08	 shl	 eax, 8
  001a5	b9 01 00 00 00	 mov	 ecx, 1
  001aa	48 6b c9 00	 imul	 rcx, rcx, 0
  001ae	0f b6 8c 0c a0
	00 00 00	 movzx	 ecx, BYTE PTR awshdr$[rsp+rcx]
  001b6	03 c1		 add	 eax, ecx
  001b8	89 44 24 60	 mov	 DWORD PTR blksize$[rsp], eax

; 343  :         end_block = (awshdr.flags1 & AWSTAPE_FLAG1_ENDREC) != 0;

  001bc	0f b6 84 24 a4
	00 00 00	 movzx	 eax, BYTE PTR awshdr$[rsp+4]
  001c4	83 e0 20	 and	 eax, 32			; 00000020H
  001c7	85 c0		 test	 eax, eax
  001c9	74 0a		 je	 SHORT $LN11@read_aws_d
  001cb	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
  001d3	eb 08		 jmp	 SHORT $LN12@read_aws_d
$LN11@read_aws_d:
  001d5	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN12@read_aws_d:
  001dd	8b 44 24 6c	 mov	 eax, DWORD PTR tv144[rsp]
  001e1	89 44 24 74	 mov	 DWORD PTR end_block$[rsp], eax

; 344  : 
; 345  :         /* If this is a tapemark, return immediately */
; 346  :         if (blksize == 0)

  001e5	83 7c 24 60 00	 cmp	 DWORD PTR blksize$[rsp], 0
  001ea	75 07		 jne	 SHORT $LN6@read_aws_d

; 347  :             return (0);

  001ec	33 c0		 xor	 eax, eax
  001ee	e9 b7 01 00 00	 jmp	 $LN1@read_aws_d
$LN6@read_aws_d:

; 348  : 
; 349  :         /* Check maximum block length */
; 350  :         if ((count_read + blksize) > bufsize)

  001f3	8b 44 24 60	 mov	 eax, DWORD PTR blksize$[rsp]
  001f7	8b 4c 24 68	 mov	 ecx, DWORD PTR count_read$[rsp]
  001fb	03 c8		 add	 ecx, eax
  001fd	8b c1		 mov	 eax, ecx
  001ff	8b c0		 mov	 eax, eax
  00201	48 3b 84 24 d0
	00 00 00	 cmp	 rax, QWORD PTR bufsize$[rsp]
  00209	0f 86 8c 00 00
	00		 jbe	 $LN7@read_aws_d

; 351  :         {
; 352  :             // "File %s: Block too large for %s tape: block size=%d, maximum=%d"
; 353  :             FWRMSG( stderr, HHC02708, "E", filenamein, "AWS emulated",

  0020f	8b 44 24 60	 mov	 eax, DWORD PTR blksize$[rsp]
  00213	8b 4c 24 68	 mov	 ecx, DWORD PTR count_read$[rsp]
  00217	03 c8		 add	 ecx, eax
  00219	8b c1		 mov	 eax, ecx
  0021b	89 44 24 70	 mov	 DWORD PTR tv150[rsp], eax
  0021f	b9 02 00 00 00	 mov	 ecx, 2
  00224	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022a	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR bufsize$[rsp]
  00231	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00235	8b 4c 24 70	 mov	 ecx, DWORD PTR tv150[rsp]
  00239	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169382
  00244	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00249	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR filenamein
  00250	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169383
  0025c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169384
  00268	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0026d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00272	41 b9 03 00 00
	00		 mov	 r9d, 3
  00278	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169385
  0027f	ba 62 01 00 00	 mov	 edx, 354		; 00000162H
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169386
  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 354  :                 count_read+blksize, (int)bufsize );
; 355  :             DELAYED_EXIT( RC_ERROR_AWSTAPE_BLOCK_TOO_LARGE );

  00291	b9 0a 00 00 00	 mov	 ecx, 10
  00296	e8 00 00 00 00	 call	 delayed_exit
$LN7@read_aws_d:

; 356  :         } /* end if(count) */
; 357  : 
; 358  :         /* Read data block */
; 359  :         rc = read (diskfd, bufptr, blksize);

  0029b	44 8b 44 24 60	 mov	 r8d, DWORD PTR blksize$[rsp]
  002a0	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufptr$[rsp]
  002a5	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR diskfd$[rsp]
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  002b2	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 360  :         if (rc < (int)blksize)

  002b6	8b 44 24 60	 mov	 eax, DWORD PTR blksize$[rsp]
  002ba	39 44 24 64	 cmp	 DWORD PTR rc$[rsp], eax
  002be	0f 8d b0 00 00
	00		 jge	 $LN8@read_aws_d

; 361  :         {
; 362  :             // "File %s: Error reading %s data block: rc=%d, errno=%d: %s"
; 363  :             FWRMSG( stderr, HHC02709, "E", filenamein, "AWS emulated tape",

  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002ca	8b 08		 mov	 ecx, DWORD PTR [rax]
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002d2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv169[rsp], rax
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002e0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
  002e8	b9 02 00 00 00	 mov	 ecx, 2
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv169[rsp]
  002fb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00300	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  00308	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0030a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0030e	8b 4c 24 64	 mov	 ecx, DWORD PTR rc$[rsp]
  00312	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169388
  0031d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00322	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR filenamein
  00329	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169389
  00335	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0033a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169390
  00341	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00346	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00351	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169391
  00358	ba 6c 01 00 00	 mov	 edx, 364		; 0000016cH
  0035d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169392
  00364	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 364  :                 rc, errno, strerror( errno ));
; 365  :             DELAYED_EXIT( RC_ERROR_READING_DATA );

  0036a	b9 09 00 00 00	 mov	 ecx, 9
  0036f	e8 00 00 00 00	 call	 delayed_exit
$LN8@read_aws_d:

; 366  :         } /* end if(rc) */
; 367  : 
; 368  :         bufptr += blksize;

  00374	8b 44 24 60	 mov	 eax, DWORD PTR blksize$[rsp]
  00378	48 8b 4c 24 78	 mov	 rcx, QWORD PTR bufptr$[rsp]
  0037d	48 03 c8	 add	 rcx, rax
  00380	48 8b c1	 mov	 rax, rcx
  00383	48 89 44 24 78	 mov	 QWORD PTR bufptr$[rsp], rax

; 369  :         count_read += blksize;

  00388	8b 44 24 60	 mov	 eax, DWORD PTR blksize$[rsp]
  0038c	8b 4c 24 68	 mov	 ecx, DWORD PTR count_read$[rsp]
  00390	03 c8		 add	 ecx, eax
  00392	8b c1		 mov	 eax, ecx
  00394	89 44 24 68	 mov	 DWORD PTR count_read$[rsp], eax

; 370  :         if (end_block)

  00398	83 7c 24 74 00	 cmp	 DWORD PTR end_block$[rsp], 0
  0039d	74 02		 je	 SHORT $LN9@read_aws_d

; 371  :             break;

  0039f	eb 05		 jmp	 SHORT $LN3@read_aws_d
$LN9@read_aws_d:

; 372  :     }

  003a1	e9 96 fc ff ff	 jmp	 $LN2@read_aws_d
$LN3@read_aws_d:

; 373  : 
; 374  :     return(count_read);

  003a6	8b 44 24 68	 mov	 eax, DWORD PTR count_read$[rsp]
$LN1@read_aws_d:

; 375  : 
; 376  : } /* end function read_aws_disk */

  003aa	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003b2	48 33 cc	 xor	 rcx, rsp
  003b5	e8 00 00 00 00	 call	 __security_check_cookie
  003ba	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003c1	c3		 ret	 0
read_aws_disk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
rc$ = 80
save_errno$ = 84
tv133 = 88
tv137 = 96
devfd$ = 128
buf$ = 136
bufsize$ = 144
mtget$ = 152
read_scsi_tape PROC

; 285  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 286  :     int rc;
; 287  :     int save_errno;
; 288  : 
; 289  :     len = read_tape (devfd, buf, bufsize);

  00017	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR bufsize$[rsp]
  0001f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00027	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR devfd$[rsp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_read_tape
  00034	89 05 00 00 00
	00		 mov	 DWORD PTR len, eax

; 290  :     if (len < 0)

  0003a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR len, 0
  00041	0f 8d 8b 01 00
	00		 jge	 $LN8@read_scsi_

; 291  :     {
; 292  :         /* Determine whether end-of-tape has been read */
; 293  :         save_errno = errno;

  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004d	8b 00		 mov	 eax, DWORD PTR [rax]
  0004f	89 44 24 54	 mov	 DWORD PTR save_errno$[rsp], eax
$LN4@read_scsi_:

; 294  :         ASSERT( devnamein );

  00053	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR devnamein, 0
  0005b	75 5c		 jne	 SHORT $LN9@read_scsi_
$LN7@read_scsi_:
  0005d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169329
  00064	41 b8 26 01 00
	00		 mov	 r8d, 294		; 00000126H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169330
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169331
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00084	85 c0		 test	 eax, eax
  00086	74 20		 je	 SHORT $LN10@read_scsi_
  00088	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169333
  0008f	41 b8 26 01 00
	00		 mov	 r8d, 294		; 00000126H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169334
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169335
  000a3	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@read_scsi_:
  000a8	33 c0		 xor	 eax, eax
  000aa	85 c0		 test	 eax, eax
  000ac	75 af		 jne	 SHORT $LN7@read_scsi_
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000b4	85 c0		 test	 eax, eax
  000b6	74 01		 je	 SHORT $LN11@read_scsi_
  000b8	cc		 int	 3
$LN11@read_scsi_:
$LN9@read_scsi_:
  000b9	33 c0		 xor	 eax, eax
  000bb	85 c0		 test	 eax, eax
  000bd	75 94		 jne	 SHORT $LN4@read_scsi_

; 295  :         rc = obtain_status (devnamein, devfd, mtget);

  000bf	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR mtget$[rsp]
  000c7	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR devfd$[rsp]
  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR devnamein
  000d5	e8 00 00 00 00	 call	 obtain_status
  000da	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 296  :         if (rc == +1)

  000de	83 7c 24 50 01	 cmp	 DWORD PTR rc$[rsp], 1
  000e3	75 5d		 jne	 SHORT $LN12@read_scsi_

; 297  :         {
; 298  :             // "End of tape"
; 299  :             WRMSG( HHC02704, "I" );

  000e5	b9 01 00 00 00	 mov	 ecx, 1
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169338
  000f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169339
  00103	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00108	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00113	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169340
  0011a	ba 2b 01 00 00	 mov	 edx, 299		; 0000012bH
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169341
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 300  :             errno = save_errno;

  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00132	8b 4c 24 54	 mov	 ecx, DWORD PTR save_errno$[rsp]
  00136	89 08		 mov	 DWORD PTR [rax], ecx

; 301  :             return(-1);

  00138	b8 ff ff ff ff	 mov	 eax, -1
  0013d	e9 96 00 00 00	 jmp	 $LN1@read_scsi_
$LN12@read_scsi_:

; 302  :         }
; 303  :         // "Tape %s: Error reading tape: errno=%d: %s"
; 304  :         FWRMSG( stderr, HHC02705, "E", devnamein, errno, strerror( errno ));

  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00148	8b 08		 mov	 ecx, DWORD PTR [rax]
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00150	48 89 44 24 58	 mov	 QWORD PTR tv133[rsp], rax
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0015b	48 89 44 24 60	 mov	 QWORD PTR tv137[rsp], rax
  00160	b9 02 00 00 00	 mov	 ecx, 2
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0016b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv133[rsp]
  00170	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00175	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv137[rsp]
  0017a	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0017c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00180	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR devnamein
  00187	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169342
  00193	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169343
  0019f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  001af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169344
  001b6	ba 30 01 00 00	 mov	 edx, 304		; 00000130H
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169345
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 305  :         DELAYED_EXIT( RC_ERROR_READING_DATA );

  001c8	b9 09 00 00 00	 mov	 ecx, 9
  001cd	e8 00 00 00 00	 call	 delayed_exit
$LN8@read_scsi_:

; 306  :     }
; 307  : 
; 308  :     return(len);

  001d2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR len
$LN1@read_scsi_:

; 309  : } /* end function read_scsi_tape */

  001d8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001dc	c3		 ret	 0
read_scsi_tape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
rc$ = 96
tv79 = 104
tv83 = 112
devname$ = 144
devfd$ = 152
mtget$ = 160
obtain_status PROC

; 254  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 255  : int rc;                                 /* Return code               */
; 256  : 
; 257  :     rc = ioctl_tape (devfd, MTIOCGET, (char*)mtget);

  00015	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR mtget$[rsp]
  0001d	ba 02 6d 1c 40	 mov	 edx, 1075604738		; 401c6d02H
  00022	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR devfd$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0002f	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 258  :     if (rc < 0)

  00033	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00038	0f 8d e0 00 00
	00		 jge	 $LN2@obtain_sta

; 259  :     {
; 260  :         if (1
; 261  :             && EIO == errno
; 262  :             && (0

  0003e	33 c0		 xor	 eax, eax
  00040	83 f8 01	 cmp	 eax, 1
  00043	74 43		 je	 SHORT $LN3@obtain_sta
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004b	83 38 05	 cmp	 DWORD PTR [rax], 5
  0004e	75 38		 jne	 SHORT $LN3@obtain_sta
  00050	33 c0		 xor	 eax, eax
  00052	85 c0		 test	 eax, eax
  00054	75 28		 jne	 SHORT $LN4@obtain_sta
  00056	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  0005e	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00061	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00066	85 c0		 test	 eax, eax
  00068	75 14		 jne	 SHORT $LN4@obtain_sta
  0006a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  00072	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00075	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0007a	85 c0		 test	 eax, eax
  0007c	74 0a		 je	 SHORT $LN3@obtain_sta
$LN4@obtain_sta:

; 263  :                 || GMT_EOD( mtget->mt_gstat )
; 264  :                 || GMT_EOT( mtget->mt_gstat )
; 265  :             )
; 266  :         )
; 267  :             return +1;

  0007e	b8 01 00 00 00	 mov	 eax, 1
  00083	e9 c7 00 00 00	 jmp	 $LN1@obtain_sta
$LN3@obtain_sta:

; 268  : 
; 269  :         // "Tape %s: Error reading status: rc=%d, errno=%d: %s"
; 270  :         FWRMSG( stderr, HHC02703, "E", devname, rc, errno, strerror( errno ));

  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00096	48 89 44 24 68	 mov	 QWORD PTR tv79[rsp], rax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a1	48 89 44 24 70	 mov	 QWORD PTR tv83[rsp], rax
  000a6	b9 02 00 00 00	 mov	 ecx, 2
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv79[rsp]
  000b6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv83[rsp]
  000c0	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000c2	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000c6	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  000ca	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000ce	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR devname$[rsp]
  000d6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169303
  000e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169304
  000ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169305
  00105	ba 0e 01 00 00	 mov	 edx, 270		; 0000010eH
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169306
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 271  :         return -1;

  00117	b8 ff ff ff ff	 mov	 eax, -1
  0011c	eb 31		 jmp	 SHORT $LN1@obtain_sta
$LN2@obtain_sta:

; 272  :     }
; 273  : 
; 274  :     if (GMT_EOD( mtget->mt_gstat ) ||

  0011e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  00126	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00129	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0012e	85 c0		 test	 eax, eax
  00130	75 14		 jne	 SHORT $LN6@obtain_sta
  00132	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mtget$[rsp]
  0013a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0013d	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00142	85 c0		 test	 eax, eax
  00144	74 07		 je	 SHORT $LN5@obtain_sta
$LN6@obtain_sta:

; 275  :         GMT_EOT( mtget->mt_gstat ))
; 276  :         return +1;

  00146	b8 01 00 00 00	 mov	 eax, 1
  0014b	eb 02		 jmp	 SHORT $LN1@obtain_sta
$LN5@obtain_sta:

; 277  : 
; 278  :     return 0;

  0014d	33 c0		 xor	 eax, eax
$LN1@obtain_sta:

; 279  : } /* end function obtain_status */

  0014f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00156	c3		 ret	 0
obtain_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
devname$ = 160
usage$ = 176
__$ArrayPad$ = 4272
print_usage PROC

; 157  : {

  00000	b8 c8 10 00 00	 mov	 eax, 4296		; 000010c8H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	48 2b e0	 sub	 rsp, rax
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 b0
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 158  :     // "HHC02760I Usage..."
; 159  : 
; 160  : #define MSGNUM  "HHC02760I "
; 161  : 
; 162  :     char usage[4096];
; 163  : 
; 164  : #if defined( _MSVC_ )
; 165  :     char* devname = "/dev\" or \"\\\\.\\Tape";

  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169282
  00026	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR devname$[rsp], rax

; 166  : #else
; 167  :     char* devname = "/dev";
; 168  : #endif
; 169  : 
; 170  :     MSGBUF( usage,

  0002e	c7 84 24 98 00
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rsp+152], 13
  00039	c7 84 24 90 00
	00 00 0c 00 00
	00		 mov	 DWORD PTR [rsp+144], 12
  00044	c7 84 24 88 00
	00 00 0b 00 00
	00		 mov	 DWORD PTR [rsp+136], 11
  0004f	c7 84 24 80 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR [rsp+128], 10
  0005a	c7 44 24 78 09
	00 00 00	 mov	 DWORD PTR [rsp+120], 9
  00062	c7 44 24 70 08
	00 00 00	 mov	 DWORD PTR [rsp+112], 8
  0006a	c7 44 24 68 07
	00 00 00	 mov	 DWORD PTR [rsp+104], 7
  00072	c7 44 24 60 06
	00 00 00	 mov	 DWORD PTR [rsp+96], 6
  0007a	c7 44 24 58 05
	00 00 00	 mov	 DWORD PTR [rsp+88], 5
  00082	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR [rsp+80], 4
  0008a	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR [rsp+72], 3
  00092	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR [rsp+64], 1
  0009a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  000a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pgm
  000aa	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000af	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR devname$[rsp]
  000b7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pgm
  000c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c8	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR pgm
  000cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169283
  000d6	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  000db	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR usage$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 171  : 
; 172  : //       1...5...10...15...20...25...30...35...40...45...50...55...60...65...70...75...80
; 173  :         "Usage:\n"
; 174  :         MSGNUM "\n"
; 175  :         MSGNUM "   %s  [tapedrive] [awsfile] or\n"
; 176  :         MSGNUM "   %s  [awsfile] [tapedrive]\n"
; 177  :         MSGNUM "\n"
; 178  :         MSGNUM "Where:\n"
; 179  :         MSGNUM "\n"
; 180  :         MSGNUM "   tapedrive    specifies the device filename of the SCSI tape drive.\n"
; 181  :         MSGNUM "                Must begin with \"%s\" to be recognized.\n"
; 182  :         MSGNUM "   awsfile      specifies the filename of the AWS emulated tape file.\n"
; 183  :         MSGNUM "\n"
; 184  :         MSGNUM "The first filename is the input; the second is the output.\n"
; 185  :         MSGNUM "\n"
; 186  :         MSGNUM "If the input file is a SCSI tape, it is read and processed until physical EOD\n"
; 187  :         MSGNUM "(end-of-data) is reached (i.e. it does not stop whenever multiple tapemarks or\n"
; 188  :         MSGNUM "filemarks are read; it continues processing until the SCSI tape drive says\n"
; 189  :         MSGNUM "there is no more data on the tape). The resulting AWS eumulated tape O/P file,\n"
; 190  :         MSGNUM "when specified for the filename on a Hercules tape device configuration\n"
; 191  :         MSGNUM "statement, can then be used instead in order for the Hercules guest O/S to\n"
; 192  :         MSGNUM "read the exact same data without having to have a SCSI tape drive physically\n"
; 193  :         MSGNUM "attached to the host system. This allows you to easily transfer SCSI tape data\n"
; 194  :         MSGNUM "to other systems that may not have SCSI tape drives attached to them by simply\n"
; 195  :         MSGNUM "using the AWS emulated tape file instead, or allows systems without SCSI tape\n"
; 196  :         MSGNUM "drives to create tape output (in the form of an AWS tape file) which can then\n"
; 197  :         MSGNUM "be copied to a SCSI tape (via %s) by a system which DOES have one.\n"
; 198  :         MSGNUM "\n"
; 199  :         MSGNUM "The possible return codes and their meaning are:\n"
; 200  :         MSGNUM "\n"
; 201  :         MSGNUM "   %2d           Successful completion.\n"
; 202  :         MSGNUM "   %2d           Invalid arguments or no arguments given.\n"
; 203  :         MSGNUM "   %2d           Unable to open SCSI tape drive device file.\n"
; 204  :         MSGNUM "   %2d           Unable to open AWS emulated tape file.\n"
; 205  :         MSGNUM "   %2d           Unrecoverable I/O error setting variable length block\n"
; 206  :         MSGNUM "                processing for SCSI tape device.\n"
; 207  :         MSGNUM "   %2d           Unrecoverable I/O error rewinding SCSI tape device.\n"
; 208  :         MSGNUM "   %2d           Unrecoverable I/O error obtaining status of SCSI device.\n"
; 209  :         MSGNUM "   %2d           Unrecoverable I/O error reading block header\n"
; 210  :         MSGNUM "                from AWS emulated tape file.\n"
; 211  :         MSGNUM "   %2d           Unrecoverable I/O error reading data block.\n"
; 212  :         MSGNUM "   %2d           AWS emulated tape block size too large.\n"
; 213  :         MSGNUM "   %2d           Unrecoverable I/O error writing tapemark.\n"
; 214  :         MSGNUM "   %2d           Unrecoverable I/O error writing block header\n"
; 215  :         MSGNUM "                to AWS emulated tape file.\n"
; 216  :         MSGNUM "   %2d           Unrecoverable I/O error writing data block.\n"
; 217  : 
; 218  :         ,pgm
; 219  :         ,pgm
; 220  :         ,devname
; 221  :         ,pgm
; 222  :         ,RC_SUCCESS
; 223  :         ,RC_ERROR_BAD_ARGUMENTS
; 224  :         ,RC_ERROR_OPENING_SCSI_DEVICE
; 225  :         ,RC_ERROR_OPENING_AWS_FILE
; 226  :         ,RC_ERROR_SETTING_SCSI_VARBLK_PROCESSING
; 227  : 
; 228  :         ,RC_ERROR_REWINDING_SCSI
; 229  :         ,RC_ERROR_OBTAINING_SCSI_STATUS
; 230  :         ,RC_ERROR_READING_AWS_HEADER
; 231  :         ,RC_ERROR_READING_DATA
; 232  :         ,RC_ERROR_AWSTAPE_BLOCK_TOO_LARGE
; 233  :         ,RC_ERROR_WRITING_TAPEMARK
; 234  : 
; 235  :         ,RC_ERROR_WRITING_OUTPUT_AWS_HEADER_BLOCK
; 236  : 
; 237  :         ,RC_ERROR_WRITING_DATA
; 238  :     );
; 239  : 
; 240  :     WRMSG( HHC02760, "I", usage );

  000e9	b9 01 00 00 00	 mov	 ecx, 1
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f4	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR usage$[rsp]
  000fc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169284
  00108	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169285
  00114	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00119	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00124	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169286
  0012b	ba f0 00 00 00	 mov	 edx, 240		; 000000f0H
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169287
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 241  : 
; 242  :     return RC_ERROR_BAD_ARGUMENTS;

  0013d	b8 01 00 00 00	 mov	 eax, 1

; 243  : 
; 244  : } /* end function print_usage */

  00142	48 8b 8c 24 b0
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014a	48 33 cc	 xor	 rcx, rsp
  0014d	e8 00 00 00 00	 call	 __security_check_cookie
  00152	48 81 c4 c8 10
	00 00		 add	 rsp, 4296		; 000010c8H
  00159	c3		 ret	 0
print_usage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
tv64 = 96
buffer$ = 112
__$ArrayPad$ = 496
devname$ = 528
_stat64$ = 536
print_status PROC

; 144  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 00 02
	00 00		 sub	 rsp, 512		; 00000200H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 145  :     char buffer[ 384 ] = {0};

  00023	48 8d 44 24 70	 lea	 rax, QWORD PTR buffer$[rsp]
  00028	48 8b f8	 mov	 rdi, rax
  0002b	33 c0		 xor	 eax, eax
  0002d	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00032	f3 aa		 rep stosb

; 146  : 
; 147  :     // "Tape %s: %smt_gstat 0x%8.8"PRIX32" %s"
; 148  :     WRMSG( HHC02702, "I", devname, "",

  00034	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  0003a	48 8d 54 24 70	 lea	 rdx, QWORD PTR buffer$[rsp]
  0003f	8b 8c 24 18 02
	00 00		 mov	 ecx, DWORD PTR _stat64$[rsp]
  00046	e8 00 00 00 00	 call	 gstat2str
  0004b	48 89 44 24 60	 mov	 QWORD PTR tv64[rsp], rax
  00050	b9 01 00 00 00	 mov	 ecx, 1
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0005b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv64[rsp]
  00060	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00065	8b 8c 24 18 02
	00 00		 mov	 ecx, DWORD PTR _stat64$[rsp]
  0006c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169273
  00077	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0007c	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR devname$[rsp]
  00084	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169274
  00090	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169275
  0009c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169276
  000b3	ba 95 00 00 00	 mov	 edx, 149		; 00000095H
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169277
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 149  :         (U32) stat, gstat2str( (U32) stat, buffer, sizeof( buffer )));
; 150  : 
; 151  : } /* end function print_status */

  000c5	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000cd	48 33 cc	 xor	 rcx, rsp
  000d0	e8 00 00 00 00	 call	 __security_check_cookie
  000d5	48 81 c4 00 02
	00 00		 add	 rsp, 512		; 00000200H
  000dc	5f		 pop	 rdi
  000dd	c3		 ret	 0
print_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapecopy.c
_TEXT	SEGMENT
exit_code$ = 80
delayed_exit PROC

; 128  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 129  :     if (RC_SUCCESS != exit_code)

  00008	83 7c 24 50 00	 cmp	 DWORD PTR exit_code$[rsp], 0
  0000d	74 47		 je	 SHORT $LN2@delayed_ex

; 130  :         // "Abnormal termination"
; 131  :         FWRMSG( stderr, HHC02701, "E" );

  0000f	b9 02 00 00 00	 mov	 ecx, 2
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169260
  00021	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169261
  0002d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	41 b9 03 00 00
	00		 mov	 r9d, 3
  0003d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169262
  00044	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169263
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@delayed_ex:

; 132  : 
; 133  :     /* Delay exiting is to give the system
; 134  :      * time to display the error message. */
; 135  :     usleep(100000);

  00056	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 136  :     exit(exit_code);

  00061	8b 4c 24 50	 mov	 ecx, DWORD PTR exit_code$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN3@delayed_ex:

; 137  : }

  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
delayed_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
