; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	store_hw_noswap
PUBLIC	syntax
PUBLIC	status
PUBLIC	nulltrk
PUBLIC	main
PUBLIC	__real@4059000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_vsnprintf:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_dasd_lookup:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_open_ckd_image:PROC
EXTRN	__imp_open_fba_image:PROC
EXTRN	__imp_close_ckd_image:PROC
EXTRN	__imp_create_ckd:PROC
EXTRN	__imp_create_fba:PROC
EXTRN	__imp_dh_devid_typ:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG168917 DB	01H DUP (?)
$SG168918 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$syntax DD imagerel $LN34
	DD	imagerel $LN34+1684
	DD	imagerel $unwind$syntax
$pdata$status DD imagerel $LN13
	DD	imagerel $LN13+198
	DD	imagerel $unwind$status
$pdata$nulltrk DD imagerel $LN9
	DD	imagerel $LN9+667
	DD	imagerel $unwind$nulltrk
$pdata$main DD	imagerel $LN168
	DD	imagerel $LN168+7239
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
_DATA	SEGMENT
$SG168724 DB	'DASD copy/convert', 00H
	ORG $+6
$SG168725 DB	'dasdcopy', 00H
	ORG $+3
$SG168740 DB	'-h', 00H
	ORG $+1
$SG168728 DB	'ckd2cckd', 00H
	ORG $+3
$SG168744 DB	'-q', 00H
	ORG $+1
$SG168731 DB	'cckd2ckd', 00H
	ORG $+3
$SG168745 DB	'-quiet', 00H
	ORG $+1
$SG168748 DB	'-r', 00H
	ORG $+1
$SG168734 DB	'fba2cfba', 00H
	ORG $+3
$SG168751 DB	'-z', 00H
	ORG $+1
$SG168736 DB	'cfba2fba', 00H
	ORG $+3
$SG168754 DB	'-bz2', 00H
	ORG $+3
$SG168757 DB	'-0', 00H
	ORG $+1
$SG168761 DB	'-cyl', 00H
	ORG $+3
$SG168762 DB	'-cyls', 00H
	ORG $+2
$SG168765 DB	'(missing)', 00H
	ORG $+2
$SG168766 DB	'-cyls', 00H
	ORG $+2
$SG168781 DB	'-a', 00H
	ORG $+1
$SG168767 DB	'invalid %s argument: %s', 00H
$SG168771 DB	'-blk', 00H
	ORG $+3
$SG168772 DB	'-blks', 00H
	ORG $+2
$SG168775 DB	'(missing)', 00H
	ORG $+2
$SG168776 DB	'-blks', 00H
	ORG $+2
$SG168789 DB	'-o', 00H
	ORG $+1
$SG168777 DB	'invalid %s argument: %s', 00H
$SG168782 DB	'-alt', 00H
	ORG $+3
$SG168783 DB	'-alts', 00H
	ORG $+2
$SG168786 DB	'-lfs', 00H
	ORG $+3
$SG168791 DB	'(missing)', 00H
	ORG $+2
$SG168792 DB	'-o', 00H
	ORG $+1
$SG168793 DB	'invalid %s argument: %s', 00H
$SG168795 DB	'already previously specified', 00H
	ORG $+3
$SG168796 DB	'-o', 00H
	ORG $+1
$SG168800 DB	'ckd', 00H
$SG168797 DB	'invalid %s argument: %s', 00H
$SG168803 DB	'cckd', 00H
	ORG $+3
$SG168806 DB	'fba', 00H
$SG168809 DB	'cfba', 00H
	ORG $+3
$SG168810 DB	'-o', 00H
	ORG $+1
$SG168811 DB	'invalid %s argument: %s', 00H
$SG168812 DB	'unrecognized/unsupported option: %s', 00H
$SG168815 DB	'%s', 00H
	ORG $+1
$SG168814 DB	'missing input-file specification', 00H
	ORG $+3
$SG168822 DB	'sf=', 00H
$SG168817 DB	'extraneous parameter: %s', 00H
	ORG $+3
$SG168826 DB	'open()', 00H
	ORG $+1
$SG168827 DB	'E', 00H
	ORG $+2
$SG168823 DB	'invalid shadow file specification: %s', 00H
	ORG $+2
$SG168828 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168829 DB	'main', 00H
	ORG $+3
$SG168830 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168832 DB	'read()', 00H
	ORG $+1
$SG168833 DB	'E', 00H
	ORG $+2
$SG168834 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168835 DB	'main', 00H
	ORG $+3
$SG168836 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168845 DB	'E', 00H
	ORG $+2
$SG168846 DB	'HHC02424%s Dasd image file format unsupported or unrecog'
	DB	'nized: %s', 0aH, 00H
	ORG $+1
$SG168847 DB	'main', 00H
	ORG $+3
$SG168865 DB	'%s', 00H
	ORG $+1
$SG168848 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168868 DB	'%s', 00H
	ORG $+1
$SG168864 DB	'shadow files invalid if input not compressed', 00H
	ORG $+3
$SG168867 DB	'compress type invalid for uncompressed output', 00H
	ORG $+2
$SG168870 DB	'-lfs invalid if output is compressed', 00H
	ORG $+3
$SG168871 DB	'%s', 00H
	ORG $+1
$SG168874 DB	'%s', 00H
	ORG $+1
$SG168873 DB	'-cyls invalid for fba input', 00H
$SG168877 DB	'%s', 00H
	ORG $+1
$SG168876 DB	'-blks invalid for ckd input', 00H
$SG168880 DB	'%s', 00H
	ORG $+1
$SG168879 DB	'-a invalid for fba input', 00H
	ORG $+3
$SG168885 DB	'%s', 00H
	ORG $+1
$SG168884 DB	'cannot copy ckd to fba or vice versa', 00H
	ORG $+3
$SG168889 DB	'E', 00H
	ORG $+2
$SG168900 DB	'E', 00H
	ORG $+2
$SG168890 DB	'HHC02403%s Failed opening %s', 0aH, 00H
	ORG $+2
$SG168891 DB	'main', 00H
	ORG $+3
$SG168892 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168910 DB	'E', 00H
	ORG $+2
$SG168901 DB	'HHC02430%s CKD lookup failed: device type %04X cyls %d', 0aH
	DB	00H
$SG168902 DB	'main', 00H
	ORG $+3
$SG168903 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168920 DB	'E', 00H
	ORG $+2
$SG168911 DB	'HHC02431%s FBA lookup failed: blks %d', 0aH, 00H
	ORG $+1
$SG168912 DB	'main', 00H
	ORG $+3
$SG168913 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168927 DB	'E', 00H
	ORG $+2
$SG168921 DB	'HHC02432%s Failed creating %s', 0aH, 00H
	ORG $+1
$SG168922 DB	'main', 00H
	ORG $+3
$SG168923 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168947 DB	'E', 00H
	ORG $+2
$SG168928 DB	'HHC02403%s Failed opening %s', 0aH, 00H
	ORG $+2
$SG168929 DB	'main', 00H
	ORG $+3
$SG168930 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168973 DB	'E', 00H
	ORG $+2
$SG168932 DB	'TRKS=%d', 0aH, 00H
	ORG $+3
$SG168943 DB	'track', 00H
	ORG $+2
$SG168980 DB	0dH, 00H
	ORG $+2
$SG168935 DB	'  %3d%% %7d of %d', 00H
	ORG $+2
$SG168944 DB	'block', 00H
	ORG $+2
$SG168945 DB	'track', 00H
	ORG $+2
$SG168946 DB	'block', 00H
	ORG $+6
$SG168948 DB	'HHC02433%s Read error on file %s: %s %d stat=%2.2X, null'
	DB	' %s substituted', 0aH, 00H
	ORG $+3
$SG168949 DB	'main', 00H
	ORG $+3
$SG168971 DB	'track', 00H
	ORG $+2
$SG168982 DB	'I', 00H
	ORG $+2
$SG168950 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168986 DB	'I', 00H
	ORG $+2
$SG168955 DB	'  %3d%% %7d of %d', 00H
	ORG $+2
$SG168962 DB	'main', 00H
	ORG $+3
$SG168972 DB	'block', 00H
	ORG $+2
$SG169066 DB	'E', 00H
	ORG $+2
$SG168963 DB	'dasdcopy.c', 00H
	ORG $+1
$SG168966 DB	'main', 00H
	ORG $+7
$SG168964 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168967 DB	'dasdcopy.c', 00H
	ORG $+5
$SG168974 DB	'HHC02434%s Write error on file %s: %s %d stat=%2.2X', 0aH
	DB	00H
	ORG $+3
$SG168968 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168975 DB	'main', 00H
	ORG $+3
$SG168976 DB	'dasdcopy.c', 00H
	ORG $+1
$SG169082 DB	'I', 00H
	ORG $+2
$SG168983 DB	'HHC02595%s Shadow file data successfully merged into out'
	DB	'put', 0aH, 00H
	ORG $+3
$SG168984 DB	'main', 00H
	ORG $+3
$SG168985 DB	'dasdcopy.c', 00H
	ORG $+1
$SG169093 DB	'I', 00H
	ORG $+2
$SG168987 DB	'HHC02423%s DASD operation completed', 0aH, 00H
	ORG $+3
$SG168988 DB	'main', 00H
	ORG $+3
$SG168989 DB	'dasdcopy.c', 00H
	ORG $+1
$SG169108 DB	'I', 00H
	ORG $+2
$SG169067 DB	'HHC02594%s Syntax error: %s', 0aH, 00H
	ORG $+3
$SG169068 DB	'syntax', 00H
	ORG $+1
$SG169069 DB	'dasdcopy.c', 00H
	ORG $+1
$SG169119 DB	'I', 00H
	ORG $+2
$SG169073 DB	'ckd2cckd', 00H
	ORG $+3
$SG169077 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG169084 DB	'syntax', 00H
	ORG $+1
$SG169136 DB	'I', 00H
	ORG $+2
$SG169075 DB	'  -z       compress using zlib [default]', 00H
	ORG $+3
$SG169081 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG169095 DB	'syntax', 00H
	ORG $+5
$SG169076 DB	'HHC02435I ', 00H
	ORG $+5
$SG169079 DB	'  -bz2     compress using bzip2', 00H
$SG169080 DB	'HHC02435I ', 00H
	ORG $+5
$SG169083 DB	'HHC02435%s Usage: ckd2cckd [-options] ifile ofile', 0aH, 'H'
	DB	'HC02435I Copy a ckd dasd file to a compressed ckd dasd file', 0aH
	DB	'HHC02435I   ifile    input ckd dasd file', 0aH, 'HHC02435I   '
	DB	'ofile    output compressed ckd dasd file', 0aH, 'HHC02435I op'
	DB	'tions:', 0aH, 'HHC02435I   -h       display this help and qui'
	DB	't', 0aH, 'HHC02435I   -q       quiet mode, don''t display sta'
	DB	'tus', 0aH, 'HHC02435I   -r       replace the output file if i'
	DB	't exists', 0aH, '%s%sHHC02435I   -0       don''t compress tra'
	DB	'ck images', 0aH, 'HHC02435I   -cyls n  size of output file', 0aH
	DB	'HHC02435I   -a       output file will have alt cyls', 0aH, 00H
	ORG $+5
$SG169085 DB	'dasdcopy.c', 00H
	ORG $+5
$SG169088 DB	'cckd2ckd', 00H
	ORG $+7
$SG169090 DB	'  -lfs     create single large output file', 00H
	ORG $+5
$SG169091 DB	'HHC02436I ', 00H
	ORG $+1
$SG169092 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169094 DB	'HHC02436%s Usage: cckd2ckd [-options] ifile [sf=sfile] o'
	DB	'file', 0aH, 'HHC02436I Copy a compressed ckd file to a ckd fi'
	DB	'le', 0aH, 'HHC02436I   ifile    input compressed ckd dasd fil'
	DB	'e', 0aH, 'HHC02436I   sfile    input compressed ckd shadow fi'
	DB	'le (optional)', 0aH, 'HHC02436I   ofile    output ckd dasd fi'
	DB	'le', 0aH, 'HHC02436I options:', 0aH, 'HHC02436I   -h       di'
	DB	'splay this help and quit', 0aH, 'HHC02436I   -q       quiet m'
	DB	'ode, don''t display status', 0aH, 'HHC02436I   -r       repla'
	DB	'ce the output file if it exists', 0aH, '%sHHC02436I   -cyls n'
	DB	'  size of output file', 0aH, 'HHC02436I   -a       output fil'
	DB	'e will have alt cyls', 0aH, 00H
	ORG $+6
$SG169096 DB	'dasdcopy.c', 00H
	ORG $+5
$SG169099 DB	'fba2cfba', 00H
	ORG $+7
$SG169101 DB	'  -z       compress using zlib [default]', 00H
	ORG $+7
$SG169102 DB	'HHC02437I ', 00H
	ORG $+1
$SG169103 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169105 DB	'  -bz2     compress using bzip2', 00H
$SG169106 DB	'HHC02437I ', 00H
	ORG $+1
$SG169107 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG169110 DB	'syntax', 00H
	ORG $+5
$SG169109 DB	'HHC02437%s Usage: fba2cfba [-options] ifile ofile', 0aH, 'H'
	DB	'HC02437I Copy a fba dasd file to a compressed fba dasd file', 0aH
	DB	'HHC02437I   ifile    input fba dasd file', 0aH, 'HHC02437I   '
	DB	'ofile    output compressed fba dasd file', 0aH, 'HHC02437I op'
	DB	'tions:', 0aH, 'HHC02437I   -h       display this help and qui'
	DB	't', 0aH, 'HHC02437I   -q       quiet mode, don''t display sta'
	DB	'tus', 0aH, 'HHC02437I   -r       replace the output file if i'
	DB	't exists', 0aH, '%s%sHHC02437I   -0       don''t compress tra'
	DB	'ck images', 0aH, 'HHC02437I   -blks n  size of output file', 0aH
	DB	00H
	ORG $+1
$SG169111 DB	'dasdcopy.c', 00H
	ORG $+5
$SG169114 DB	'cfba2fba', 00H
	ORG $+7
$SG169116 DB	'  -lfs     create single large output file', 00H
	ORG $+5
$SG169117 DB	'HHC02438I ', 00H
	ORG $+1
$SG169118 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG169121 DB	'syntax', 00H
	ORG $+5
$SG169120 DB	'HHC02438%s Usage: cfba2fba [-options] ifile [sf=sfile] o'
	DB	'file', 0aH, 'HHC02438I Copy a compressed fba file to a fba fi'
	DB	'le', 0aH, 'HHC02438I   ifile    input compressed fba dasd fil'
	DB	'e', 0aH, 'HHC02438I   sfile    input compressed fba shadow fi'
	DB	'le (optional)', 0aH, 'HHC02438I   ofile    output fba dasd fi'
	DB	'le', 0aH, 'HHC02438I options:', 0aH, 'HHC02438I   -h       di'
	DB	'splay this help and quit', 0aH, 'HHC02438I   -q       quiet m'
	DB	'ode, don''t display status', 0aH, 'HHC02438I   -r       repla'
	DB	'ce the output file if it exists', 0aH, '%sHHC02438I   -blks n'
	DB	'  size of output file', 0aH, 00H
	ORG $+2
$SG169122 DB	'dasdcopy.c', 00H
	ORG $+5
$SG169124 DB	'  -z       compress using zlib [default]', 00H
	ORG $+7
$SG169125 DB	'HHC02439I ', 00H
	ORG $+1
$SG169126 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169128 DB	'  -bz2     compress using bzip2', 00H
$SG169129 DB	'HHC02439I ', 00H
	ORG $+1
$SG169130 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169132 DB	'  -lfs     create single large output file', 00H
	ORG $+5
$SG169133 DB	'HHC02439I ', 00H
	ORG $+1
$SG169134 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169135 DB	'CKD, CCKD, FBA, CFBA', 00H
	ORG $+3
$SG169137 DB	'HHC02439%s Usage: %s [-options] ifile [sf=sfile] ofile', 0aH
	DB	'HHC02439I Copy a dasd file to another dasd file', 0aH, 'HHC02'
	DB	'439I   ifile    input dasd file   (required)', 0aH, 'HHC02439'
	DB	'I   sfile    input shadow file (optional) (see note)', 0aH, 'H'
	DB	'HC02439I   ofile    output dasd file  (required)', 0aH, 'HHC0'
	DB	'2439I Options:', 0aH, 'HHC02439I   -h       display this help'
	DB	' and quit', 0aH, 'HHC02439I   -q       quiet mode, don''t dis'
	DB	'play status', 0aH, 'HHC02439I   -r       replace the output f'
	DB	'ile if it exists', 0aH, '%s%sHHC02439I   -0       don''t comp'
	DB	'ress output', 0aH, 'HHC02439I   -blks n  size of output fba f'
	DB	'ile', 0aH, 'HHC02439I   -cyls n  size of output ckd file', 0aH
	DB	'HHC02439I   -a       output ckd file will have alt cyls', 0aH
	DB	'%sHHC02439I   -o type  output file type (%s)', 0aH, 'HHC02439'
	DB	'I', 0aH, 'HHC02439I Note: input shadow files will, as part of'
	DB	' the copy', 0aH, 'HHC02439I operation, have their data automa'
	DB	'tically merged into', 0aH, 'HHC02439I the resulting output fi'
	DB	'le.', 0aH, 00H
	ORG $+3
$SG169138 DB	'syntax', 00H
	ORG $+1
$SG169139 DB	'dasdcopy.c', 00H
	ORG $+1
?indic@?5??status@@9@9 DB '|/-\', 00H			; `status'::`6'::indic
	ORG $+7
$SG169158 DB	'TRK=%d', 0aH, 00H
$SG169159 DB	0dH, '%c %3d%% %7d', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01bH
	DD	01c2eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:syntax
	DD	025H
	DD	067cH
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$syntax DD 022d19H
	DD	037011bH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$status DD 010c01H
	DD	0620cH
$unwind$nulltrk DD 011701H
	DD	0a217H
$unwind$main DD	032319H
	DD	0520111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0280H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcopy.c
_TEXT	SEGMENT
unitstat$ = 112
out$ = 116
idev$ = 120
in$ = 128
i$ = 132
n$ = 136
cyls$ = 140
rc$ = 144
blks$ = 148
ckddasd$ = 152
pgm$ = 160
comp$ = 168
max$ = 172
lfs$ = 176
quiet$ = 180
imgtyp$ = 184
fd$ = 188
tv455 = 192
nullfmt$ = 196
icif$ = 200
ofile$ = 208
fba_bytes_remaining$ = 216
alt$ = 224
r$ = 228
ckd$ = 232
ifile$ = 240
odev$ = 248
ocif$ = 256
sfile$ = 264
tv853 = 272
tv600 = 276
tv978 = 280
fba$ = 288
tv196 = 296
tv226 = 304
tv851 = 312
tv857 = 320
tv982 = 328
tv396 = 336
tv415 = 344
tv826 = 352
buf$1 = 360
pathname$ = 368
__$ArrayPad$ = 640
argc$ = 672
argv$ = 680
main	PROC

; 55   : {

$LN168:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 81 ec 90 02
	00 00		 sub	 rsp, 656		; 00000290H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 56   : char           *pgm;                    /* less any extension (.ext) */
; 57   : int             ckddasd=-1;             /* 1=CKD  0=FBA              */

  00023	c7 84 24 98 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ckddasd$[rsp], -1

; 58   : int             rc;                     /* Return code               */
; 59   : int             quiet=0;                /* 1=Don't display status    */

  0002e	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR quiet$[rsp], 0

; 60   : int             comp=255;               /* Compression algorithm     */

  00039	c7 84 24 a8 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR comp$[rsp], 255 ; 000000ffH

; 61   : int             cyls=-1, blks=-1;       /* Size of output file       */

  00044	c7 84 24 8c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR cyls$[rsp], -1
  0004f	c7 84 24 94 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR blks$[rsp], -1

; 62   : int             lfs=0;                  /* 1=Create 1 large file     */

  0005a	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 0

; 63   : int             alt=0;                  /* 1=Create alt cyls         */

  00065	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR alt$[rsp], 0

; 64   : int             r=0;                    /* 1=Replace output file     */

  00070	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR r$[rsp], 0

; 65   : int             in=0, out=0;            /* Input/Output file types   */

  0007b	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR in$[rsp], 0
  00086	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR out$[rsp], 0

; 66   : int             fd;                     /* Input file descriptor     */
; 67   : char           *ifile, *ofile;          /* -> Input/Output file names*/
; 68   : char           *sfile=NULL;             /* -> Input shadow file name */

  0008e	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR sfile$[rsp], 0

; 69   : CIFBLK         *icif, *ocif;            /* -> Input/Output CIFBLK    */
; 70   : DEVBLK         *idev, *odev;            /* -> Input/Output DEVBLK    */
; 71   : 
; 72   : CKDDEV         *ckd=NULL;               /* -> CKD device table entry */

  0009a	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ckd$[rsp], 0

; 73   : FBADEV         *fba=NULL;               /* -> FBA device table entry */

  000a6	48 c7 84 24 20
	01 00 00 00 00
	00 00		 mov	 QWORD PTR fba$[rsp], 0

; 74   : int             i, n, max;              /* Loop index, limits        */
; 75   : BYTE            unitstat;               /* Device unit status        */
; 76   : U32             imgtyp;                 /* Dasd file image type      */
; 77   : U64             fba_bytes_remaining=0;  /* FBA bytes to be copied    */

  000b2	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fba_bytes_remaining$[rsp], 0

; 78   : int             nullfmt = CKD_NULLTRK_FMT0; /* Null track format     */

  000be	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR nullfmt$[rsp], 0

; 79   : char            pathname[MAX_PATH];     /* file path in host format  */
; 80   : 
; 81   :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  000c9	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168724
  000dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168725
  000e4	48 8b 94 24 a8
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000ec	8b 8c 24 a0 02
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  000f9	89 84 24 a0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 82   : 
; 83   :     if (strcasecmp(pgm, "ckd2cckd") == 0)

  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168728
  00107	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00115	85 c0		 test	 eax, eax
  00117	75 18		 jne	 SHORT $LN19@main

; 84   :     {
; 85   :         in = CKD;

  00119	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR in$[rsp], 1

; 86   :         out = CCKD;

  00124	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR out$[rsp], 2

; 87   :     }

  0012c	e9 88 00 00 00	 jmp	 $LN20@main
$LN19@main:

; 88   :     else if (strcasecmp(pgm, "cckd2ckd") == 0)

  00131	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168731
  00138	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00146	85 c0		 test	 eax, eax
  00148	75 15		 jne	 SHORT $LN21@main

; 89   :     {
; 90   :         in = CCKD;

  0014a	c7 84 24 80 00
	00 00 02 00 00
	00		 mov	 DWORD PTR in$[rsp], 2

; 91   :         out = CKD;

  00155	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR out$[rsp], 1

; 92   :     }

  0015d	eb 5a		 jmp	 SHORT $LN22@main
$LN21@main:

; 93   :     else if (strcasecmp(pgm, "fba2cfba") == 0)

  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168734
  00166	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00174	85 c0		 test	 eax, eax
  00176	75 15		 jne	 SHORT $LN23@main

; 94   :     {
; 95   :         in = FBA;

  00178	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR in$[rsp], 4

; 96   :         out = CFBA;

  00183	c7 44 24 74 08
	00 00 00	 mov	 DWORD PTR out$[rsp], 8

; 97   :     }

  0018b	eb 2c		 jmp	 SHORT $LN24@main
$LN23@main:

; 98   :     else if (strcasecmp(pgm, "cfba2fba") == 0)

  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168736
  00194	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001a2	85 c0		 test	 eax, eax
  001a4	75 13		 jne	 SHORT $LN25@main

; 99   :     {
; 100  :         in = CFBA;

  001a6	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR in$[rsp], 8

; 101  :         out = FBA;

  001b1	c7 44 24 74 04
	00 00 00	 mov	 DWORD PTR out$[rsp], 4
$LN25@main:
$LN24@main:
$LN22@main:
$LN20@main:

; 102  :     }
; 103  : 
; 104  :     /* Process the arguments */
; 105  :     for (argc--, argv++ ; argc > 0 ; argc--, argv++)

  001b9	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  001c0	ff c8		 dec	 eax
  001c2	89 84 24 a0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  001c9	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  001d1	48 83 c0 08	 add	 rax, 8
  001d5	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax
  001dd	eb 24		 jmp	 SHORT $LN4@main
$LN2@main:
  001df	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  001e6	ff c8		 dec	 eax
  001e8	89 84 24 a0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  001ef	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  001f7	48 83 c0 08	 add	 rax, 8
  001fb	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN4@main:
  00203	83 bc 24 a0 02
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  0020b	0f 8e 6b 06 00
	00		 jle	 $LN3@main

; 106  :     {
; 107  :         if (argv[0][0] != '-') break;

  00211	b8 08 00 00 00	 mov	 eax, 8
  00216	48 6b c0 00	 imul	 rax, rax, 0
  0021a	b9 01 00 00 00	 mov	 ecx, 1
  0021f	48 6b c9 00	 imul	 rcx, rcx, 0
  00223	48 8b 94 24 a8
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0022b	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0022f	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00233	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00236	74 05		 je	 SHORT $LN26@main
  00238	e9 3f 06 00 00	 jmp	 $LN3@main
$LN26@main:

; 108  :         if (strcmp(argv[0], "-h") == 0)

  0023d	b8 08 00 00 00	 mov	 eax, 8
  00242	48 6b c0 00	 imul	 rax, rax, 0
  00246	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168740
  0024d	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00255	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00259	e8 00 00 00 00	 call	 strcmp
  0025e	85 c0		 test	 eax, eax
  00260	75 1b		 jne	 SHORT $LN27@main

; 109  :         {
; 110  :             syntax( pgm, NULL );

  00262	33 d2		 xor	 edx, edx
  00264	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0026c	e8 00 00 00 00	 call	 syntax

; 111  :             return 0;

  00271	33 c0		 xor	 eax, eax
  00273	e9 b6 19 00 00	 jmp	 $LN1@main

; 112  :         }

  00278	e9 fa 05 00 00	 jmp	 $LN28@main
$LN27@main:

; 113  :         else if (strcmp(argv[0], "-q") == 0
; 114  :               || strcmp(argv[0], "-quiet") == 0)

  0027d	b8 08 00 00 00	 mov	 eax, 8
  00282	48 6b c0 00	 imul	 rax, rax, 0
  00286	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168744
  0028d	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00295	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00299	e8 00 00 00 00	 call	 strcmp
  0029e	85 c0		 test	 eax, eax
  002a0	74 25		 je	 SHORT $LN31@main
  002a2	b8 08 00 00 00	 mov	 eax, 8
  002a7	48 6b c0 00	 imul	 rax, rax, 0
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168745
  002b2	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002ba	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002be	e8 00 00 00 00	 call	 strcmp
  002c3	85 c0		 test	 eax, eax
  002c5	75 10		 jne	 SHORT $LN29@main
$LN31@main:

; 115  :             quiet = 1;

  002c7	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR quiet$[rsp], 1
  002d2	e9 a0 05 00 00	 jmp	 $LN30@main
$LN29@main:

; 116  :         else if (strcmp(argv[0], "-r") == 0)

  002d7	b8 08 00 00 00	 mov	 eax, 8
  002dc	48 6b c0 00	 imul	 rax, rax, 0
  002e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168748
  002e7	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002ef	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002f3	e8 00 00 00 00	 call	 strcmp
  002f8	85 c0		 test	 eax, eax
  002fa	75 10		 jne	 SHORT $LN32@main

; 117  :             r = 1;

  002fc	c7 84 24 e4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR r$[rsp], 1
  00307	e9 6b 05 00 00	 jmp	 $LN33@main
$LN32@main:

; 118  : #ifdef CCKD_COMPRESS_ZLIB
; 119  :         else if (strcmp(argv[0], "-z") == 0)

  0030c	b8 08 00 00 00	 mov	 eax, 8
  00311	48 6b c0 00	 imul	 rax, rax, 0
  00315	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168751
  0031c	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00324	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00328	e8 00 00 00 00	 call	 strcmp
  0032d	85 c0		 test	 eax, eax
  0032f	75 10		 jne	 SHORT $LN34@main

; 120  :             comp = CCKD_COMPRESS_ZLIB;

  00331	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR comp$[rsp], 1
  0033c	e9 36 05 00 00	 jmp	 $LN35@main
$LN34@main:

; 121  : #endif
; 122  : #ifdef CCKD_COMPRESS_BZIP2
; 123  :         else if (strcmp(argv[0], "-bz2") == 0)

  00341	b8 08 00 00 00	 mov	 eax, 8
  00346	48 6b c0 00	 imul	 rax, rax, 0
  0034a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168754
  00351	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00359	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0035d	e8 00 00 00 00	 call	 strcmp
  00362	85 c0		 test	 eax, eax
  00364	75 10		 jne	 SHORT $LN36@main

; 124  :             comp = CCKD_COMPRESS_BZIP2;

  00366	c7 84 24 a8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR comp$[rsp], 2
  00371	e9 01 05 00 00	 jmp	 $LN37@main
$LN36@main:

; 125  : #endif
; 126  :         else if (strcmp(argv[0], "-0") == 0)

  00376	b8 08 00 00 00	 mov	 eax, 8
  0037b	48 6b c0 00	 imul	 rax, rax, 0
  0037f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168757
  00386	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0038e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00392	e8 00 00 00 00	 call	 strcmp
  00397	85 c0		 test	 eax, eax
  00399	75 10		 jne	 SHORT $LN38@main

; 127  :             comp = CCKD_COMPRESS_NONE;

  0039b	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR comp$[rsp], 0
  003a6	e9 cc 04 00 00	 jmp	 $LN39@main
$LN38@main:

; 128  :         else if ((strcmp(argv[0], "-cyl") == 0
; 129  :                || strcmp(argv[0], "-cyls") == 0) && cyls < 0)

  003ab	b8 08 00 00 00	 mov	 eax, 8
  003b0	48 6b c0 00	 imul	 rax, rax, 0
  003b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168761
  003bb	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003c3	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  003c7	e8 00 00 00 00	 call	 strcmp
  003cc	85 c0		 test	 eax, eax
  003ce	74 29		 je	 SHORT $LN42@main
  003d0	b8 08 00 00 00	 mov	 eax, 8
  003d5	48 6b c0 00	 imul	 rax, rax, 0
  003d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168762
  003e0	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003e8	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  003ec	e8 00 00 00 00	 call	 strcmp
  003f1	85 c0		 test	 eax, eax
  003f3	0f 85 cd 00 00
	00		 jne	 $LN40@main
$LN42@main:
  003f9	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  00401	0f 8d bf 00 00
	00		 jge	 $LN40@main

; 130  :         {
; 131  :             if (argc < 2 || (cyls = atoi(argv[1])) < 0)

  00407	83 bc 24 a0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0040f	7c 2c		 jl	 SHORT $LN44@main
  00411	b8 08 00 00 00	 mov	 eax, 8
  00416	48 6b c0 01	 imul	 rax, rax, 1
  0041a	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00422	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0042c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax
  00433	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  0043b	7d 60		 jge	 SHORT $LN43@main
$LN44@main:

; 132  :                 return syntax( pgm, "invalid %s argument: %s",

  0043d	83 bc 24 a0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00445	7d 11		 jge	 SHORT $LN158@main
  00447	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168765
  0044e	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv196[rsp], rax
  00456	eb 1d		 jmp	 SHORT $LN159@main
$LN158@main:
  00458	b8 08 00 00 00	 mov	 eax, 8
  0045d	48 6b c0 01	 imul	 rax, rax, 1
  00461	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00469	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0046d	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv196[rsp], rax
$LN159@main:
  00475	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR tv196[rsp]
  0047d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168766
  00484	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168767
  0048b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00493	e8 00 00 00 00	 call	 syntax
  00498	e9 91 17 00 00	 jmp	 $LN1@main
$LN43@main:

; 133  :                     "-cyls", argc < 2 ? "(missing)" : argv[1] );
; 134  :             argc--; argv++;

  0049d	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  004a4	ff c8		 dec	 eax
  004a6	89 84 24 a0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  004ad	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004b5	48 83 c0 08	 add	 rax, 8
  004b9	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 135  :         }

  004c1	e9 b1 03 00 00	 jmp	 $LN41@main
$LN40@main:

; 136  :         else if ((strcmp(argv[0], "-blk") == 0
; 137  :                || strcmp(argv[0], "-blks") == 0) && blks < 0)

  004c6	b8 08 00 00 00	 mov	 eax, 8
  004cb	48 6b c0 00	 imul	 rax, rax, 0
  004cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168771
  004d6	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004de	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  004e2	e8 00 00 00 00	 call	 strcmp
  004e7	85 c0		 test	 eax, eax
  004e9	74 29		 je	 SHORT $LN47@main
  004eb	b8 08 00 00 00	 mov	 eax, 8
  004f0	48 6b c0 00	 imul	 rax, rax, 0
  004f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168772
  004fb	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00503	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00507	e8 00 00 00 00	 call	 strcmp
  0050c	85 c0		 test	 eax, eax
  0050e	0f 85 cd 00 00
	00		 jne	 $LN45@main
$LN47@main:
  00514	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  0051c	0f 8d bf 00 00
	00		 jge	 $LN45@main

; 138  :         {
; 139  :             if (argc < 2 || (blks = atoi(argv[1])) < 0)

  00522	83 bc 24 a0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0052a	7c 2c		 jl	 SHORT $LN49@main
  0052c	b8 08 00 00 00	 mov	 eax, 8
  00531	48 6b c0 01	 imul	 rax, rax, 1
  00535	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0053d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00541	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00547	89 84 24 94 00
	00 00		 mov	 DWORD PTR blks$[rsp], eax
  0054e	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  00556	7d 60		 jge	 SHORT $LN48@main
$LN49@main:

; 140  :                 return syntax( pgm, "invalid %s argument: %s",

  00558	83 bc 24 a0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00560	7d 11		 jge	 SHORT $LN160@main
  00562	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168775
  00569	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv226[rsp], rax
  00571	eb 1d		 jmp	 SHORT $LN161@main
$LN160@main:
  00573	b8 08 00 00 00	 mov	 eax, 8
  00578	48 6b c0 01	 imul	 rax, rax, 1
  0057c	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00584	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00588	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv226[rsp], rax
$LN161@main:
  00590	4c 8b 8c 24 30
	01 00 00	 mov	 r9, QWORD PTR tv226[rsp]
  00598	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168776
  0059f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168777
  005a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  005ae	e8 00 00 00 00	 call	 syntax
  005b3	e9 76 16 00 00	 jmp	 $LN1@main
$LN48@main:

; 141  :                     "-blks", argc < 2 ? "(missing)" : argv[1] );
; 142  :             argc--; argv++;

  005b8	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  005bf	ff c8		 dec	 eax
  005c1	89 84 24 a0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  005c8	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005d0	48 83 c0 08	 add	 rax, 8
  005d4	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 143  :         }

  005dc	e9 96 02 00 00	 jmp	 $LN46@main
$LN45@main:

; 144  :         else if (strcmp(argv[0], "-a") == 0
; 145  :               || strcmp(argv[0], "-alt") == 0
; 146  :               || strcmp(argv[0], "-alts") == 0)

  005e1	b8 08 00 00 00	 mov	 eax, 8
  005e6	48 6b c0 00	 imul	 rax, rax, 0
  005ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168781
  005f1	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005f9	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  005fd	e8 00 00 00 00	 call	 strcmp
  00602	85 c0		 test	 eax, eax
  00604	74 4a		 je	 SHORT $LN52@main
  00606	b8 08 00 00 00	 mov	 eax, 8
  0060b	48 6b c0 00	 imul	 rax, rax, 0
  0060f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168782
  00616	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0061e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00622	e8 00 00 00 00	 call	 strcmp
  00627	85 c0		 test	 eax, eax
  00629	74 25		 je	 SHORT $LN52@main
  0062b	b8 08 00 00 00	 mov	 eax, 8
  00630	48 6b c0 00	 imul	 rax, rax, 0
  00634	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168783
  0063b	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00643	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00647	e8 00 00 00 00	 call	 strcmp
  0064c	85 c0		 test	 eax, eax
  0064e	75 10		 jne	 SHORT $LN50@main
$LN52@main:

; 147  :             alt = 1;

  00650	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR alt$[rsp], 1
  0065b	e9 17 02 00 00	 jmp	 $LN51@main
$LN50@main:

; 148  :         else if (strcmp(argv[0], "-lfs") == 0)

  00660	b8 08 00 00 00	 mov	 eax, 8
  00665	48 6b c0 00	 imul	 rax, rax, 0
  00669	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168786
  00670	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00678	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0067c	e8 00 00 00 00	 call	 strcmp
  00681	85 c0		 test	 eax, eax
  00683	75 10		 jne	 SHORT $LN53@main

; 149  :             lfs = 1;

  00685	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 1
  00690	e9 e2 01 00 00	 jmp	 $LN54@main
$LN53@main:

; 150  :         else if (out == 0 && strcmp(argv[0], "-o") == 0)

  00695	83 7c 24 74 00	 cmp	 DWORD PTR out$[rsp], 0
  0069a	0f 85 a9 01 00
	00		 jne	 $LN55@main
  006a0	b8 08 00 00 00	 mov	 eax, 8
  006a5	48 6b c0 00	 imul	 rax, rax, 0
  006a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168789
  006b0	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006b8	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  006bc	e8 00 00 00 00	 call	 strcmp
  006c1	85 c0		 test	 eax, eax
  006c3	0f 85 80 01 00
	00		 jne	 $LN55@main

; 151  :         {
; 152  :             if (argc < 2)

  006c9	83 bc 24 a0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  006d1	7d 27		 jge	 SHORT $LN57@main

; 153  :                 return syntax( pgm, "invalid %s argument: %s",

  006d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168791
  006da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168792
  006e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168793
  006e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  006f0	e8 00 00 00 00	 call	 syntax
  006f5	e9 34 15 00 00	 jmp	 $LN1@main
$LN57@main:

; 154  :                     "-o", "(missing)" );
; 155  :             if (out != 0)

  006fa	83 7c 24 74 00	 cmp	 DWORD PTR out$[rsp], 0
  006ff	74 27		 je	 SHORT $LN58@main

; 156  :                 return syntax( pgm, "invalid %s argument: %s",

  00701	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168795
  00708	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168796
  0070f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168797
  00716	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0071e	e8 00 00 00 00	 call	 syntax
  00723	e9 06 15 00 00	 jmp	 $LN1@main
$LN58@main:

; 157  :                     "-o", "already previously specified" );
; 158  : 
; 159  :                  if (strcasecmp( argv[1], "ckd"  ) == 0) out = CKD;

  00728	b8 08 00 00 00	 mov	 eax, 8
  0072d	48 6b c0 01	 imul	 rax, rax, 1
  00731	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168800
  00738	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00740	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00744	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0074a	85 c0		 test	 eax, eax
  0074c	75 0d		 jne	 SHORT $LN59@main
  0074e	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR out$[rsp], 1
  00756	e9 c8 00 00 00	 jmp	 $LN60@main
$LN59@main:

; 160  :             else if (strcasecmp( argv[1], "cckd" ) == 0) out = CCKD;

  0075b	b8 08 00 00 00	 mov	 eax, 8
  00760	48 6b c0 01	 imul	 rax, rax, 1
  00764	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168803
  0076b	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00773	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00777	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0077d	85 c0		 test	 eax, eax
  0077f	75 0d		 jne	 SHORT $LN61@main
  00781	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR out$[rsp], 2
  00789	e9 95 00 00 00	 jmp	 $LN62@main
$LN61@main:

; 161  :             else if (strcasecmp( argv[1], "fba"  ) == 0) out = FBA;

  0078e	b8 08 00 00 00	 mov	 eax, 8
  00793	48 6b c0 01	 imul	 rax, rax, 1
  00797	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168806
  0079e	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007a6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  007aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  007b0	85 c0		 test	 eax, eax
  007b2	75 0a		 jne	 SHORT $LN63@main
  007b4	c7 44 24 74 04
	00 00 00	 mov	 DWORD PTR out$[rsp], 4
  007bc	eb 65		 jmp	 SHORT $LN64@main
$LN63@main:

; 162  :             else if (strcasecmp( argv[1], "cfba" ) == 0) out = CFBA;

  007be	b8 08 00 00 00	 mov	 eax, 8
  007c3	48 6b c0 01	 imul	 rax, rax, 1
  007c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168809
  007ce	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007d6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  007da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  007e0	85 c0		 test	 eax, eax
  007e2	75 0a		 jne	 SHORT $LN65@main
  007e4	c7 44 24 74 08
	00 00 00	 mov	 DWORD PTR out$[rsp], 8
  007ec	eb 35		 jmp	 SHORT $LN66@main
$LN65@main:

; 163  :             else
; 164  :                 return syntax( pgm, "invalid %s argument: %s",

  007ee	b8 08 00 00 00	 mov	 eax, 8
  007f3	48 6b c0 01	 imul	 rax, rax, 1
  007f7	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007ff	4c 8b 0c 01	 mov	 r9, QWORD PTR [rcx+rax]
  00803	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168810
  0080a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168811
  00811	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00819	e8 00 00 00 00	 call	 syntax
  0081e	e9 0b 14 00 00	 jmp	 $LN1@main
$LN66@main:
$LN64@main:
$LN62@main:
$LN60@main:

; 165  :                     "-o", argv[1] );
; 166  : 
; 167  :             argc--; argv++;

  00823	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0082a	ff c8		 dec	 eax
  0082c	89 84 24 a0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00833	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0083b	48 83 c0 08	 add	 rax, 8
  0083f	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 168  :         }

  00847	eb 2e		 jmp	 SHORT $LN56@main
$LN55@main:

; 169  :         else
; 170  :             return syntax( pgm, "unrecognized/unsupported option: %s",

  00849	b8 08 00 00 00	 mov	 eax, 8
  0084e	48 6b c0 00	 imul	 rax, rax, 0
  00852	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0085a	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  0085e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168812
  00865	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0086d	e8 00 00 00 00	 call	 syntax
  00872	e9 b7 13 00 00	 jmp	 $LN1@main
$LN56@main:
$LN54@main:
$LN51@main:
$LN46@main:
$LN41@main:
$LN39@main:
$LN37@main:
$LN35@main:
$LN33@main:
$LN30@main:
$LN28@main:

; 171  :                 argv[0] );
; 172  :     }

  00877	e9 63 f9 ff ff	 jmp	 $LN2@main
$LN3@main:

; 173  : 
; 174  :     /* Get the file names:
; 175  :        input-file [sf=shadow-file] output-file   */
; 176  :     if (argc < 2)

  0087c	83 bc 24 a0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00884	7d 20		 jge	 SHORT $LN67@main

; 177  :         return syntax( pgm, "%s", "missing input-file specification" );

  00886	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168814
  0088d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168815
  00894	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0089c	e8 00 00 00 00	 call	 syntax
  008a1	e9 88 13 00 00	 jmp	 $LN1@main
$LN67@main:

; 178  :     if (argc > 3)

  008a6	83 bc 24 a0 02
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  008ae	7e 2e		 jle	 SHORT $LN68@main

; 179  :         return syntax( pgm, "extraneous parameter: %s", argv[2] );

  008b0	b8 08 00 00 00	 mov	 eax, 8
  008b5	48 6b c0 02	 imul	 rax, rax, 2
  008b9	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008c1	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  008c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168817
  008cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  008d4	e8 00 00 00 00	 call	 syntax
  008d9	e9 50 13 00 00	 jmp	 $LN1@main
$LN68@main:

; 180  :     ifile = argv[0];

  008de	b8 08 00 00 00	 mov	 eax, 8
  008e3	48 6b c0 00	 imul	 rax, rax, 0
  008e7	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008ef	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  008f3	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR ifile$[rsp], rax

; 181  :     if (argc < 3)

  008fb	83 bc 24 a0 02
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  00903	7d 22		 jge	 SHORT $LN69@main

; 182  :         ofile = argv[1];

  00905	b8 08 00 00 00	 mov	 eax, 8
  0090a	48 6b c0 01	 imul	 rax, rax, 1
  0090e	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00916	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0091a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR ofile$[rsp], rax
  00922	e9 b3 00 00 00	 jmp	 $LN70@main
$LN69@main:

; 183  :     else
; 184  :     {
; 185  :         if (strlen(argv[1]) < 4 || memcmp(argv[1], "sf=", 3) != 0)

  00927	b8 08 00 00 00	 mov	 eax, 8
  0092c	48 6b c0 01	 imul	 rax, rax, 1
  00930	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00938	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0093c	e8 00 00 00 00	 call	 strlen
  00941	48 83 f8 04	 cmp	 rax, 4
  00945	72 2b		 jb	 SHORT $LN72@main
  00947	b8 08 00 00 00	 mov	 eax, 8
  0094c	48 6b c0 01	 imul	 rax, rax, 1
  00950	41 b8 03 00 00
	00		 mov	 r8d, 3
  00956	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168822
  0095d	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00965	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00969	e8 00 00 00 00	 call	 memcmp
  0096e	85 c0		 test	 eax, eax
  00970	74 2e		 je	 SHORT $LN71@main
$LN72@main:

; 186  :             return syntax( pgm, "invalid shadow file specification: %s",

  00972	b8 08 00 00 00	 mov	 eax, 8
  00977	48 6b c0 01	 imul	 rax, rax, 1
  0097b	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00983	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  00987	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168823
  0098e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00996	e8 00 00 00 00	 call	 syntax
  0099b	e9 8e 12 00 00	 jmp	 $LN1@main
$LN71@main:

; 187  :                 argv[1] );
; 188  : 
; 189  :         sfile = argv[1];

  009a0	b8 08 00 00 00	 mov	 eax, 8
  009a5	48 6b c0 01	 imul	 rax, rax, 1
  009a9	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009b1	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  009b5	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR sfile$[rsp], rax

; 190  :         ofile = argv[2];

  009bd	b8 08 00 00 00	 mov	 eax, 8
  009c2	48 6b c0 02	 imul	 rax, rax, 2
  009c6	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009ce	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  009d2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR ofile$[rsp], rax
$LN70@main:

; 191  :     }
; 192  : 
; 193  :     /* If we don't know what the input file is then find out */
; 194  :     if (!in)

  009da	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR in$[rsp], 0
  009e2	0f 85 88 02 00
	00		 jne	 $LN73@main

; 195  :     {
; 196  :         BYTE buf[8];
; 197  : 
; 198  :         hostpath( pathname, ifile, sizeof( pathname ));

  009e8	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  009ee	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR ifile$[rsp]
  009f6	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  009fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 199  : 
; 200  :         if ((fd = HOPEN( pathname, O_RDONLY | O_BINARY )) < 0)

  00a04	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00a09	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00a11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00a17	89 84 24 bc 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax
  00a1e	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  00a26	0f 8d 80 00 00
	00		 jge	 $LN74@main

; 201  :         {
; 202  :             // "Error in function %s: %s"
; 203  :             FWRMSG( stderr, HHC02412, "E", "open()", strerror( errno ));

  00a2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00a32	8b 08		 mov	 ecx, DWORD PTR [rax]
  00a34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00a3a	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv396[rsp], rax
  00a42	b9 02 00 00 00	 mov	 ecx, 2
  00a47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a4d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv396[rsp]
  00a55	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168826
  00a61	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a66	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168827
  00a6d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a72	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168828
  00a79	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a7e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a83	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a89	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168829
  00a90	ba cb 00 00 00	 mov	 edx, 203		; 000000cbH
  00a95	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168830
  00a9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 204  :             return -1;

  00aa2	b8 ff ff ff ff	 mov	 eax, -1
  00aa7	e9 82 11 00 00	 jmp	 $LN1@main
$LN74@main:

; 205  :         }
; 206  : 
; 207  :         if ((rc = read( fd, buf, 8 )) < 8)

  00aac	41 b8 08 00 00
	00		 mov	 r8d, 8
  00ab2	48 8d 94 24 68
	01 00 00	 lea	 rdx, QWORD PTR buf$1[rsp]
  00aba	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00ac1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00ac7	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00ace	83 bc 24 90 00
	00 00 08	 cmp	 DWORD PTR rc$[rsp], 8
  00ad6	0f 8d 80 00 00
	00		 jge	 $LN75@main

; 208  :         {
; 209  :             // "Error in function %s: %s"
; 210  :             FWRMSG( stderr, HHC02412, "E", "read()", strerror( errno ));

  00adc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00ae2	8b 08		 mov	 ecx, DWORD PTR [rax]
  00ae4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00aea	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv415[rsp], rax
  00af2	b9 02 00 00 00	 mov	 ecx, 2
  00af7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00afd	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv415[rsp]
  00b05	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00b0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168832
  00b11	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168833
  00b1d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168834
  00b29	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b2e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b33	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b39	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168835
  00b40	ba d2 00 00 00	 mov	 edx, 210		; 000000d2H
  00b45	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168836
  00b4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 211  :             return -1;

  00b52	b8 ff ff ff ff	 mov	 eax, -1
  00b57	e9 d2 10 00 00	 jmp	 $LN1@main
$LN75@main:

; 212  :         }
; 213  : 
; 214  :         imgtyp = dh_devid_typ( buf );

  00b5c	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00b64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_typ
  00b6a	89 84 24 b8 00
	00 00		 mov	 DWORD PTR imgtyp$[rsp], eax

; 215  : 
; 216  :              if (imgtyp & CKD_P370_TYP) in = CKD;

  00b71	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00b78	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00b7d	85 c0		 test	 eax, eax
  00b7f	74 10		 je	 SHORT $LN76@main
  00b81	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR in$[rsp], 1
  00b8c	e9 d2 00 00 00	 jmp	 $LN77@main
$LN76@main:

; 217  :         else if (imgtyp & CKD_C370_TYP) in = CCKD;

  00b91	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00b98	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00b9d	85 c0		 test	 eax, eax
  00b9f	74 10		 je	 SHORT $LN78@main
  00ba1	c7 84 24 80 00
	00 00 02 00 00
	00		 mov	 DWORD PTR in$[rsp], 2
  00bac	e9 b2 00 00 00	 jmp	 $LN79@main
$LN78@main:

; 218  :         else if (imgtyp & FBA_P370_TYP) in = FBA;

  00bb1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00bb8	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00bbd	85 c0		 test	 eax, eax
  00bbf	74 10		 je	 SHORT $LN80@main
  00bc1	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR in$[rsp], 4
  00bcc	e9 92 00 00 00	 jmp	 $LN81@main
$LN80@main:

; 219  :         else if (imgtyp & FBA_C370_TYP) in = CFBA;

  00bd1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00bd8	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00bdd	85 c0		 test	 eax, eax
  00bdf	74 0d		 je	 SHORT $LN82@main
  00be1	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR in$[rsp], 8
  00bec	eb 75		 jmp	 SHORT $LN83@main
$LN82@main:

; 220  :         else
; 221  :         {
; 222  :             // "Dasd image file format unsupported or unrecognized: %s"
; 223  :             FWRMSG( stderr, HHC02424, "E", ifile );

  00bee	b9 02 00 00 00	 mov	 ecx, 2
  00bf3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bf9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  00c01	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168845
  00c0d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168846
  00c19	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c1e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c23	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c29	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168847
  00c30	ba df 00 00 00	 mov	 edx, 223		; 000000dfH
  00c35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168848
  00c3c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 224  :             close( fd );

  00c42	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00c49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 225  :             return syntax( pgm, NULL );

  00c4f	33 d2		 xor	 edx, edx
  00c51	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00c59	e8 00 00 00 00	 call	 syntax
  00c5e	e9 cb 0f 00 00	 jmp	 $LN1@main
$LN83@main:
$LN81@main:
$LN79@main:
$LN77@main:

; 226  :         }
; 227  : 
; 228  :         close( fd );

  00c63	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00c6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN73@main:

; 229  :     }
; 230  : 
; 231  :     /* If we don't know what the output file type is
; 232  :        then derive it from the input file type */
; 233  :     if (out == 0)

  00c70	83 7c 24 74 00	 cmp	 DWORD PTR out$[rsp], 0
  00c75	0f 85 b4 00 00
	00		 jne	 $LN84@main

; 234  :     {
; 235  :         switch (in) {

  00c7b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR in$[rsp]
  00c82	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv455[rsp], eax
  00c89	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR tv455[rsp], 1
  00c91	74 20		 je	 SHORT $LN85@main
  00c93	83 bc 24 c0 00
	00 00 02	 cmp	 DWORD PTR tv455[rsp], 2
  00c9b	74 34		 je	 SHORT $LN88@main
  00c9d	83 bc 24 c0 00
	00 00 04	 cmp	 DWORD PTR tv455[rsp], 4
  00ca5	74 4b		 je	 SHORT $LN91@main
  00ca7	83 bc 24 c0 00
	00 00 08	 cmp	 DWORD PTR tv455[rsp], 8
  00caf	74 5f		 je	 SHORT $LN94@main
  00cb1	eb 7c		 jmp	 SHORT $LN5@main
$LN85@main:

; 236  :         case CKD:
; 237  :             if (!lfs)

  00cb3	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00cbb	75 0a		 jne	 SHORT $LN86@main

; 238  :             {
; 239  :                 out = CCKD;

  00cbd	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR out$[rsp], 2

; 240  :             }

  00cc5	eb 08		 jmp	 SHORT $LN87@main
$LN86@main:

; 241  :             else
; 242  :             {
; 243  :                 out = CKD;

  00cc7	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR out$[rsp], 1
$LN87@main:

; 244  :             }
; 245  :             break;

  00ccf	eb 5e		 jmp	 SHORT $LN5@main
$LN88@main:

; 246  :         case CCKD:
; 247  :             if (comp == 255)

  00cd1	81 bc 24 a8 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR comp$[rsp], 255 ; 000000ffH
  00cdc	75 0a		 jne	 SHORT $LN89@main

; 248  :             {
; 249  :                 out = CKD;

  00cde	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR out$[rsp], 1

; 250  :             }

  00ce6	eb 08		 jmp	 SHORT $LN90@main
$LN89@main:

; 251  :             else
; 252  :             {
; 253  :                 out = CCKD;

  00ce8	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR out$[rsp], 2
$LN90@main:

; 254  :             }
; 255  :             break;

  00cf0	eb 3d		 jmp	 SHORT $LN5@main
$LN91@main:

; 256  :         case FBA:
; 257  :             if (!lfs)

  00cf2	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00cfa	75 0a		 jne	 SHORT $LN92@main

; 258  :             {
; 259  :                 out = CFBA;

  00cfc	c7 44 24 74 08
	00 00 00	 mov	 DWORD PTR out$[rsp], 8

; 260  :             }

  00d04	eb 08		 jmp	 SHORT $LN93@main
$LN92@main:

; 261  :             else
; 262  :             {
; 263  :                 out = FBA;

  00d06	c7 44 24 74 04
	00 00 00	 mov	 DWORD PTR out$[rsp], 4
$LN93@main:

; 264  :             }
; 265  :             break;

  00d0e	eb 1f		 jmp	 SHORT $LN5@main
$LN94@main:

; 266  :         case CFBA:
; 267  :             if (comp == 255)

  00d10	81 bc 24 a8 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR comp$[rsp], 255 ; 000000ffH
  00d1b	75 0a		 jne	 SHORT $LN95@main

; 268  :             {
; 269  :                 out = FBA;

  00d1d	c7 44 24 74 04
	00 00 00	 mov	 DWORD PTR out$[rsp], 4

; 270  :             }

  00d25	eb 08		 jmp	 SHORT $LN96@main
$LN95@main:

; 271  :             else
; 272  :             {
; 273  :                 out = CFBA;

  00d27	c7 44 24 74 08
	00 00 00	 mov	 DWORD PTR out$[rsp], 8
$LN96@main:
$LN5@main:
$LN84@main:

; 274  :             }
; 275  :             break;
; 276  :         }
; 277  :     }
; 278  : 
; 279  :     /* Set default compression if out file is to be compressed */
; 280  :     if (comp == 255 && (out & COMPMASK))

  00d2f	81 bc 24 a8 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR comp$[rsp], 255 ; 000000ffH
  00d3a	75 16		 jne	 SHORT $LN97@main
  00d3c	8b 44 24 74	 mov	 eax, DWORD PTR out$[rsp]
  00d40	83 e0 0a	 and	 eax, 10
  00d43	85 c0		 test	 eax, eax
  00d45	74 0b		 je	 SHORT $LN97@main

; 281  : #ifdef CCKD_COMPRESS_ZLIB
; 282  :         comp = CCKD_COMPRESS_ZLIB;

  00d47	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR comp$[rsp], 1
$LN97@main:

; 283  : #else
; 284  :         comp = CCKD_COMPRESS_NONE;
; 285  : #endif
; 286  : 
; 287  :     /* Perform sanity checks on the options... */
; 288  : 
; 289  :     if (sfile && !(in & COMPMASK))        return syntax( pgm, "%s",

  00d52	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR sfile$[rsp], 0
  00d5b	74 2e		 je	 SHORT $LN98@main
  00d5d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR in$[rsp]
  00d64	83 e0 0a	 and	 eax, 10
  00d67	85 c0		 test	 eax, eax
  00d69	75 20		 jne	 SHORT $LN98@main
  00d6b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168864
  00d72	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168865
  00d79	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00d81	e8 00 00 00 00	 call	 syntax
  00d86	e9 a3 0e 00 00	 jmp	 $LN1@main
$LN98@main:

; 290  :         "shadow files invalid if input not compressed" );
; 291  : 
; 292  :     if (comp != 255 && !(out & COMPMASK)) return syntax( pgm, "%s",

  00d8b	81 bc 24 a8 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR comp$[rsp], 255 ; 000000ffH
  00d96	74 2b		 je	 SHORT $LN99@main
  00d98	8b 44 24 74	 mov	 eax, DWORD PTR out$[rsp]
  00d9c	83 e0 0a	 and	 eax, 10
  00d9f	85 c0		 test	 eax, eax
  00da1	75 20		 jne	 SHORT $LN99@main
  00da3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168867
  00daa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168868
  00db1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00db9	e8 00 00 00 00	 call	 syntax
  00dbe	e9 6b 0e 00 00	 jmp	 $LN1@main
$LN99@main:

; 293  :         "compress type invalid for uncompressed output" );
; 294  : 
; 295  :     if (lfs && (out & COMPMASK))          return syntax( pgm, "%s",

  00dc3	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00dcb	74 2b		 je	 SHORT $LN100@main
  00dcd	8b 44 24 74	 mov	 eax, DWORD PTR out$[rsp]
  00dd1	83 e0 0a	 and	 eax, 10
  00dd4	85 c0		 test	 eax, eax
  00dd6	74 20		 je	 SHORT $LN100@main
  00dd8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168870
  00ddf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168871
  00de6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00dee	e8 00 00 00 00	 call	 syntax
  00df3	e9 36 0e 00 00	 jmp	 $LN1@main
$LN100@main:

; 296  :         "-lfs invalid if output is compressed" );
; 297  : 
; 298  :     if (cyls >= 0 && (in & FBAMASK ))     return syntax( pgm, "%s",

  00df8	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  00e00	7c 2e		 jl	 SHORT $LN101@main
  00e02	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR in$[rsp]
  00e09	83 e0 0c	 and	 eax, 12
  00e0c	85 c0		 test	 eax, eax
  00e0e	74 20		 je	 SHORT $LN101@main
  00e10	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168873
  00e17	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168874
  00e1e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00e26	e8 00 00 00 00	 call	 syntax
  00e2b	e9 fe 0d 00 00	 jmp	 $LN1@main
$LN101@main:

; 299  :         "-cyls invalid for fba input" );
; 300  : 
; 301  :     if (blks >= 0 && (in & CKDMASK ))     return syntax( pgm, "%s",

  00e30	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  00e38	7c 2e		 jl	 SHORT $LN102@main
  00e3a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR in$[rsp]
  00e41	83 e0 03	 and	 eax, 3
  00e44	85 c0		 test	 eax, eax
  00e46	74 20		 je	 SHORT $LN102@main
  00e48	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168876
  00e4f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168877
  00e56	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00e5e	e8 00 00 00 00	 call	 syntax
  00e63	e9 c6 0d 00 00	 jmp	 $LN1@main
$LN102@main:

; 302  :         "-blks invalid for ckd input" );
; 303  : 
; 304  :     if (alt && (in & FBAMASK ))           return syntax( pgm, "%s",

  00e68	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR alt$[rsp], 0
  00e70	74 2e		 je	 SHORT $LN103@main
  00e72	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR in$[rsp]
  00e79	83 e0 0c	 and	 eax, 12
  00e7c	85 c0		 test	 eax, eax
  00e7e	74 20		 je	 SHORT $LN103@main
  00e80	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168879
  00e87	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168880
  00e8e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00e96	e8 00 00 00 00	 call	 syntax
  00e9b	e9 8e 0d 00 00	 jmp	 $LN1@main
$LN103@main:

; 305  :         "-a invalid for fba input" );
; 306  : 
; 307  :     if (0
; 308  :         || ((in & CKDMASK) && !(out & CKDMASK ))
; 309  :         || ((in & FBAMASK) && !(out & FBAMASK ))

  00ea0	33 c0		 xor	 eax, eax
  00ea2	85 c0		 test	 eax, eax
  00ea4	75 32		 jne	 SHORT $LN105@main
  00ea6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR in$[rsp]
  00ead	83 e0 03	 and	 eax, 3
  00eb0	85 c0		 test	 eax, eax
  00eb2	74 0b		 je	 SHORT $LN106@main
  00eb4	8b 44 24 74	 mov	 eax, DWORD PTR out$[rsp]
  00eb8	83 e0 03	 and	 eax, 3
  00ebb	85 c0		 test	 eax, eax
  00ebd	74 19		 je	 SHORT $LN105@main
$LN106@main:
  00ebf	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR in$[rsp]
  00ec6	83 e0 0c	 and	 eax, 12
  00ec9	85 c0		 test	 eax, eax
  00ecb	74 2b		 je	 SHORT $LN104@main
  00ecd	8b 44 24 74	 mov	 eax, DWORD PTR out$[rsp]
  00ed1	83 e0 0c	 and	 eax, 12
  00ed4	85 c0		 test	 eax, eax
  00ed6	75 20		 jne	 SHORT $LN104@main
$LN105@main:

; 310  :     )
; 311  :         return syntax( pgm, "%s",

  00ed8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168884
  00edf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168885
  00ee6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00eee	e8 00 00 00 00	 call	 syntax
  00ef3	e9 36 0d 00 00	 jmp	 $LN1@main
$LN104@main:

; 312  :             "cannot copy ckd to fba or vice versa" );
; 313  : 
; 314  :     /* Set the type of processing (ckd or fba) */
; 315  :     ckddasd = (in & CKDMASK);

  00ef8	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR in$[rsp]
  00eff	83 e0 03	 and	 eax, 3
  00f02	89 84 24 98 00
	00 00		 mov	 DWORD PTR ckddasd$[rsp], eax

; 316  : 
; 317  :     /* Open the input file */
; 318  :     if (ckddasd)

  00f09	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  00f11	74 29		 je	 SHORT $LN107@main

; 319  :     {
; 320  :         icif = open_ckd_image (ifile, sfile, O_RDONLY|O_BINARY, IMAGE_OPEN_NORMAL);

  00f13	45 33 c9	 xor	 r9d, r9d
  00f16	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00f1c	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR sfile$[rsp]
  00f24	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  00f2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  00f32	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR icif$[rsp], rax

; 321  :     }

  00f3a	eb 27		 jmp	 SHORT $LN108@main
$LN107@main:

; 322  :     else // fba
; 323  :     {
; 324  :         icif = open_fba_image (ifile, sfile, O_RDONLY|O_BINARY, IMAGE_OPEN_NORMAL);

  00f3c	45 33 c9	 xor	 r9d, r9d
  00f3f	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00f45	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR sfile$[rsp]
  00f4d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  00f55	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_fba_image
  00f5b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR icif$[rsp], rax
$LN108@main:

; 325  :     }
; 326  :     if (icif == NULL)

  00f63	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR icif$[rsp], 0
  00f6c	75 5e		 jne	 SHORT $LN109@main

; 327  :     {
; 328  :         // "Failed opening %s"
; 329  :         FWRMSG( stderr, HHC02403, "E", ifile );

  00f6e	b9 02 00 00 00	 mov	 ecx, 2
  00f73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f79	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  00f81	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f86	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168889
  00f8d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f92	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168890
  00f99	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f9e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fa3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fa9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168891
  00fb0	ba 49 01 00 00	 mov	 edx, 329		; 00000149H
  00fb5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168892
  00fbc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 330  :         return -1;

  00fc2	b8 ff ff ff ff	 mov	 eax, -1
  00fc7	e9 62 0c 00 00	 jmp	 $LN1@main
$LN109@main:

; 331  :     }
; 332  :     idev = &icif->devblk;

  00fcc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR icif$[rsp]
  00fd4	48 83 c0 30	 add	 rax, 48			; 00000030H
  00fd8	48 89 44 24 78	 mov	 QWORD PTR idev$[rsp], rax

; 333  :     if (idev->oslinux) nullfmt = CKD_NULLTRK_FMT2;

  00fdd	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  00fe2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00fe8	c1 e8 0d	 shr	 eax, 13
  00feb	83 e0 01	 and	 eax, 1
  00fee	85 c0		 test	 eax, eax
  00ff0	74 0b		 je	 SHORT $LN110@main
  00ff2	c7 84 24 c4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR nullfmt$[rsp], 2
$LN110@main:

; 334  : 
; 335  :     /* Calculate the number of tracks or blocks to copy */
; 336  :     if (ckddasd)

  00ffd	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01005	0f 84 93 01 00
	00		 je	 $LN111@main

; 337  :     {
; 338  :         if (cyls < 0) cyls = idev->ckdcyls;

  0100b	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  01013	7d 14		 jge	 SHORT $LN113@main
  01015	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  0101a	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  01020	89 84 24 8c 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax
  01027	eb 25		 jmp	 SHORT $LN114@main
$LN113@main:

; 339  :         else if (cyls == 0) cyls = (idev->hnd->used)(idev);

  01029	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  01031	75 1b		 jne	 SHORT $LN115@main
  01033	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01038	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0103f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  01044	ff 50 60	 call	 QWORD PTR [rax+96]
  01047	89 84 24 8c 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax
$LN115@main:
$LN114@main:

; 340  :         ckd = dasd_lookup (DASD_CKDDEV, NULL, idev->devtype, 0);

  0104e	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01053	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01057	45 33 c9	 xor	 r9d, r9d
  0105a	44 8b c0	 mov	 r8d, eax
  0105d	33 d2		 xor	 edx, edx
  0105f	b9 01 00 00 00	 mov	 ecx, 1
  01064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  0106a	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ckd$[rsp], rax

; 341  :         if (ckd == NULL)

  01072	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR ckd$[rsp], 0
  0107b	0f 85 85 00 00
	00		 jne	 $LN116@main

; 342  :         {
; 343  :             // "CKD lookup failed: device type %04X cyls %d"
; 344  :             FWRMSG( stderr, HHC02430, "E",

  01081	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01086	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0108a	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv600[rsp], eax
  01091	b9 02 00 00 00	 mov	 ecx, 2
  01096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0109c	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  010a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010a7	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv600[rsp]
  010ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168900
  010b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168901
  010c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  010d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168902
  010dc	ba 59 01 00 00	 mov	 edx, 345		; 00000159H
  010e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168903
  010e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 345  :                      idev->devtype, cyls );
; 346  :             close_image_file (icif);

  010ee	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  010f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 347  :             return -1;

  010fc	b8 ff ff ff ff	 mov	 eax, -1
  01101	e9 28 0b 00 00	 jmp	 $LN1@main
$LN116@main:

; 348  :         }
; 349  :         if (cyls <= ckd->cyls && alt) cyls = ckd->cyls + ckd->altcyls;

  01106	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  0110e	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  01112	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR cyls$[rsp], eax
  01119	7f 2b		 jg	 SHORT $LN117@main
  0111b	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR alt$[rsp], 0
  01123	74 21		 je	 SHORT $LN117@main
  01125	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  0112d	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  01131	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  01139	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  0113d	03 c1		 add	 eax, ecx
  0113f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax
$LN117@main:

; 350  :         n = cyls * idev->ckdheads;

  01146	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  0114b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  01152	0f af 88 c0 12
	00 00		 imul	 ecx, DWORD PTR [rax+4800]
  01159	8b c1		 mov	 eax, ecx
  0115b	89 84 24 88 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 351  :         max = idev->ckdtrks;

  01162	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01167	8b 80 bc 12 00
	00		 mov	 eax, DWORD PTR [rax+4796]
  0116d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR max$[rsp], eax

; 352  :         if (max < n && out == CCKD) n = max;

  01174	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  0117b	39 84 24 ac 00
	00 00		 cmp	 DWORD PTR max$[rsp], eax
  01182	7d 15		 jge	 SHORT $LN118@main
  01184	83 7c 24 74 02	 cmp	 DWORD PTR out$[rsp], 2
  01189	75 0e		 jne	 SHORT $LN118@main
  0118b	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  01192	89 84 24 88 00
	00 00		 mov	 DWORD PTR n$[rsp], eax
$LN118@main:

; 353  :     }

  01199	e9 77 01 00 00	 jmp	 $LN112@main
$LN111@main:

; 354  :     else // fba
; 355  :     {
; 356  :         fba_bytes_remaining = (U64)((S64)idev->fbanumblk * idev->fbablksiz);

  0119e	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  011a3	48 63 80 88 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4488]
  011aa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  011af	48 63 89 8c 11
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4492]
  011b6	48 0f af c1	 imul	 rax, rcx
  011ba	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR fba_bytes_remaining$[rsp], rax

; 357  :         if (blks < 0) blks = idev->fbanumblk;

  011c2	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  011ca	7d 14		 jge	 SHORT $LN119@main
  011cc	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  011d1	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  011d7	89 84 24 94 00
	00 00		 mov	 DWORD PTR blks$[rsp], eax
  011de	eb 25		 jmp	 SHORT $LN120@main
$LN119@main:

; 358  :         else if (blks == 0) blks = (idev->hnd->used)(idev);

  011e0	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  011e8	75 1b		 jne	 SHORT $LN121@main
  011ea	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  011ef	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  011f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  011fb	ff 50 60	 call	 QWORD PTR [rax+96]
  011fe	89 84 24 94 00
	00 00		 mov	 DWORD PTR blks$[rsp], eax
$LN121@main:
$LN120@main:

; 359  :         fba = dasd_lookup (DASD_FBADEV, NULL, idev->devtype, 0);

  01205	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  0120a	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0120e	45 33 c9	 xor	 r9d, r9d
  01211	44 8b c0	 mov	 r8d, eax
  01214	33 d2		 xor	 edx, edx
  01216	b9 03 00 00 00	 mov	 ecx, 3
  0121b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  01221	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR fba$[rsp], rax

; 360  :         if (fba == NULL)

  01229	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR fba$[rsp], 0
  01232	75 6a		 jne	 SHORT $LN122@main

; 361  :         {
; 362  :             // "FBA lookup failed: blks %d"
; 363  :             FWRMSG( stderr, HHC02431, "E", blks );

  01234	b9 02 00 00 00	 mov	 ecx, 2
  01239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0123f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR blks$[rsp]
  01246	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0124a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168910
  01251	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168911
  0125d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01262	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01267	41 b9 03 00 00
	00		 mov	 r9d, 3
  0126d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168912
  01274	ba 6b 01 00 00	 mov	 edx, 363		; 0000016bH
  01279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168913
  01280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 364  :             close_image_file (icif);

  01286	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  0128e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 365  :             return -1;

  01294	b8 ff ff ff ff	 mov	 eax, -1
  01299	e9 90 09 00 00	 jmp	 $LN1@main
$LN122@main:

; 366  :         }
; 367  : 
; 368  :         n = blks;

  0129e	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR blks$[rsp]
  012a5	89 84 24 88 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 369  :         max = idev->fbanumblk;

  012ac	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  012b1	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  012b7	89 84 24 ac 00
	00 00		 mov	 DWORD PTR max$[rsp], eax

; 370  : 
; 371  :         if (max < n && out == CFBA)

  012be	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  012c5	39 84 24 ac 00
	00 00		 cmp	 DWORD PTR max$[rsp], eax
  012cc	7d 15		 jge	 SHORT $LN123@main
  012ce	83 7c 24 74 08	 cmp	 DWORD PTR out$[rsp], 8
  012d3	75 0e		 jne	 SHORT $LN123@main

; 372  :             n = max;

  012d5	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  012dc	89 84 24 88 00
	00 00		 mov	 DWORD PTR n$[rsp], eax
$LN123@main:

; 373  : 
; 374  :         n =   (n   + CFBA_BLKS_PER_GRP - 1) / CFBA_BLKS_PER_GRP;

  012e3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  012ea	83 c0 77	 add	 eax, 119		; 00000077H
  012ed	99		 cdq
  012ee	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  012f3	f7 f9		 idiv	 ecx
  012f5	89 84 24 88 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 375  :         max = (max + CFBA_BLKS_PER_GRP - 1) / CFBA_BLKS_PER_GRP;

  012fc	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  01303	83 c0 77	 add	 eax, 119		; 00000077H
  01306	99		 cdq
  01307	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  0130c	f7 f9		 idiv	 ecx
  0130e	89 84 24 ac 00
	00 00		 mov	 DWORD PTR max$[rsp], eax
$LN112@main:

; 376  :     }
; 377  : 
; 378  :     /* Create the output file */
; 379  :     if (ckddasd)

  01315	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  0131d	0f 84 92 00 00
	00		 je	 $LN124@main

; 380  :     {
; 381  :         rc = create_ckd(ofile, idev->devtype, idev->ckdheads,

  01323	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  0132a	ff c0		 inc	 eax
  0132c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  01334	0f b7 49 16	 movzx	 ecx, WORD PTR [rcx+22]
  01338	c6 44 24 60 00	 mov	 BYTE PTR [rsp+96], 0
  0133d	c6 44 24 58 01	 mov	 BYTE PTR [rsp+88], 1
  01342	c6 44 24 50 00	 mov	 BYTE PTR [rsp+80], 0
  01347	0f b6 94 24 c4
	00 00 00	 movzx	 edx, BYTE PTR nullfmt$[rsp]
  0134f	88 54 24 48	 mov	 BYTE PTR [rsp+72], dl
  01353	88 44 24 40	 mov	 BYTE PTR [rsp+64], al
  01357	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  0135f	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  01363	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0136b	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  0136f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168917
  01376	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0137b	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  01382	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01386	44 8b c9	 mov	 r9d, ecx
  01389	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  0138e	44 8b 80 c0 12
	00 00		 mov	 r8d, DWORD PTR [rax+4800]
  01395	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  0139a	0f b7 50 4a	 movzx	 edx, WORD PTR [rax+74]
  0139e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  013a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_ckd
  013ac	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 382  :                         ckd->r1, cyls, "", comp, lfs, 1+r, nullfmt, 0,
; 383  :                         1, 0);
; 384  :     }

  013b3	eb 6a		 jmp	 SHORT $LN125@main
$LN124@main:

; 385  :     else // fba
; 386  :     {
; 387  :         rc = create_fba(ofile, idev->devtype, fba->size,

  013b5	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  013bc	ff c0		 inc	 eax
  013be	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR [rsp+64], 0
  013c6	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  013ca	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR lfs$[rsp]
  013d1	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  013d5	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  013dd	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  013e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168918
  013e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013ed	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR blks$[rsp]
  013f5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR fba$[rsp]
  013fd	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  01401	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01406	0f b7 50 4a	 movzx	 edx, WORD PTR [rax+74]
  0140a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_fba
  01418	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN125@main:

; 388  :                         blks, "", comp, lfs, 1+r, 0);
; 389  :     }
; 390  :     if (rc < 0)

  0141f	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  01427	7d 6c		 jge	 SHORT $LN126@main

; 391  :     {
; 392  :         // "Failed creating %s"
; 393  :         FWRMSG( stderr, HHC02432, "E", ofile );

  01429	b9 02 00 00 00	 mov	 ecx, 2
  0142e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01434	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  0143c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01441	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168920
  01448	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0144d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168921
  01454	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01459	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0145e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01464	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168922
  0146b	ba 89 01 00 00	 mov	 edx, 393		; 00000189H
  01470	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168923
  01477	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 394  :         close_image_file (icif);

  0147d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  01485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 395  :         return -1;

  0148b	b8 ff ff ff ff	 mov	 eax, -1
  01490	e9 99 07 00 00	 jmp	 $LN1@main
$LN126@main:

; 396  :     }
; 397  : 
; 398  :     /* Open the output file */
; 399  :     if (ckddasd)

  01495	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  0149d	74 26		 je	 SHORT $LN127@main

; 400  :     {
; 401  :         ocif = open_ckd_image (ofile, NULL, O_RDWR|O_BINARY, IMAGE_OPEN_DASDCOPY);

  0149f	41 b9 01 00 00
	00		 mov	 r9d, 1
  014a5	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  014ab	33 d2		 xor	 edx, edx
  014ad	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  014b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  014bb	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR ocif$[rsp], rax

; 402  :     }

  014c3	eb 24		 jmp	 SHORT $LN128@main
$LN127@main:

; 403  :     else // fba
; 404  :     {
; 405  :         ocif = open_fba_image (ofile, NULL, O_RDWR|O_BINARY, IMAGE_OPEN_DASDCOPY);

  014c5	41 b9 01 00 00
	00		 mov	 r9d, 1
  014cb	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  014d1	33 d2		 xor	 edx, edx
  014d3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  014db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_fba_image
  014e1	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR ocif$[rsp], rax
$LN128@main:

; 406  :     }
; 407  :     if (ocif == NULL)

  014e9	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR ocif$[rsp], 0
  014f2	75 6c		 jne	 SHORT $LN129@main

; 408  :     {
; 409  :         // "Failed opening %s"
; 410  :         FWRMSG( stderr, HHC02403, "E", ofile );

  014f4	b9 02 00 00 00	 mov	 ecx, 2
  014f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  014ff	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01507	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0150c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168927
  01513	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01518	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168928
  0151f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01524	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01529	41 b9 03 00 00
	00		 mov	 r9d, 3
  0152f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168929
  01536	ba 9a 01 00 00	 mov	 edx, 410		; 0000019aH
  0153b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168930
  01542	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 411  :         close_image_file (icif);

  01548	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  01550	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 412  :         return -1;

  01556	b8 ff ff ff ff	 mov	 eax, -1
  0155b	e9 ce 06 00 00	 jmp	 $LN1@main
$LN129@main:

; 413  :     }
; 414  :     odev = &ocif->devblk;

  01560	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR ocif$[rsp]
  01568	48 83 c0 30	 add	 rax, 48			; 00000030H
  0156c	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR odev$[rsp], rax
$LN9@main:

; 415  : 
; 416  :     /* Notify GUI of total #of tracks or blocks being copied... */
; 417  :     EXTGUIMSG( "TRKS=%d\n", n );

  01574	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0157b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0157e	74 23		 je	 SHORT $LN130@main
  01580	b9 02 00 00 00	 mov	 ecx, 2
  01585	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0158b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR n$[rsp]
  01593	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168932
  0159a	48 8b c8	 mov	 rcx, rax
  0159d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN130@main:
  015a3	33 c0		 xor	 eax, eax
  015a5	85 c0		 test	 eax, eax
  015a7	75 cb		 jne	 SHORT $LN9@main

; 418  : 
; 419  :     /* Copy the files */
; 420  : 
; 421  :     if (!extgui)

  015a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  015b0	83 38 00	 cmp	 DWORD PTR [rax], 0
  015b3	75 23		 jne	 SHORT $LN131@main

; 422  :         if (!quiet)

  015b5	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  015bd	75 19		 jne	 SHORT $LN132@main

; 423  :             printf ( "  %3d%% %7d of %d", 0, 0, n );

  015bf	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR n$[rsp]
  015c7	45 33 c0	 xor	 r8d, r8d
  015ca	33 d2		 xor	 edx, edx
  015cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168935
  015d3	e8 00 00 00 00	 call	 printf
$LN132@main:
$LN131@main:

; 424  : 
; 425  :     for (i = 0; i < n; i++)

  015d8	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  015e3	eb 10		 jmp	 SHORT $LN12@main
$LN10@main:
  015e5	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  015ec	ff c0		 inc	 eax
  015ee	89 84 24 84 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN12@main:
  015f5	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  015fc	39 84 24 84 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01603	0f 8d 4c 05 00
	00		 jge	 $LN11@main

; 426  :     {
; 427  :         /* Read a track or block */
; 428  :         if (ckddasd)

  01609	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01611	0f 84 9a 00 00
	00		 je	 $LN133@main

; 429  :         {
; 430  :             if (i < max)

  01617	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  0161e	39 84 24 84 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01625	7d 29		 jge	 SHORT $LN135@main

; 431  :                 rc = (idev->hnd->read)(idev, i, &unitstat);

  01627	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  0162c	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01633	4c 8d 44 24 70	 lea	 r8, QWORD PTR unitstat$[rsp]
  01638	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  0163f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  01644	ff 50 50	 call	 QWORD PTR [rax+80]
  01647	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  0164e	eb 5f		 jmp	 SHORT $LN136@main
$LN135@main:

; 432  :             else
; 433  :             {
; 434  :                 memset (idev->buf, 0, idev->ckdtrksz);

  01650	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01655	48 63 80 c4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4804]
  0165c	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv826[rsp], rax
  01664	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  01669	48 8b b9 c8 01
	00 00		 mov	 rdi, QWORD PTR [rcx+456]
  01670	33 c0		 xor	 eax, eax
  01672	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv826[rsp]
  0167a	f3 aa		 rep stosb

; 435  :                 rc = nulltrk(idev->buf, i, idev->ckdheads, nullfmt);

  0167c	44 8b 8c 24 c4
	00 00 00	 mov	 r9d, DWORD PTR nullfmt$[rsp]
  01684	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01689	44 8b 80 c0 12
	00 00		 mov	 r8d, DWORD PTR [rax+4800]
  01690	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01697	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  0169c	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  016a3	e8 00 00 00 00	 call	 nulltrk
  016a8	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN136@main:

; 436  :             }
; 437  :         }

  016af	eb 59		 jmp	 SHORT $LN134@main
$LN133@main:

; 438  :         else
; 439  :         {
; 440  :             if (i < max)

  016b1	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  016b8	39 84 24 84 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  016bf	7d 29		 jge	 SHORT $LN137@main

; 441  :                 rc = (idev->hnd->read)(idev, i, &unitstat);

  016c1	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  016c6	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  016cd	4c 8d 44 24 70	 lea	 r8, QWORD PTR unitstat$[rsp]
  016d2	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  016d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  016de	ff 50 50	 call	 QWORD PTR [rax+80]
  016e1	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  016e8	eb 20		 jmp	 SHORT $LN138@main
$LN137@main:

; 442  :             else
; 443  :             {
; 444  :                 memset (idev->buf, 0, CFBA_BLKGRP_SIZE);

  016ea	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  016ef	48 8b b8 c8 01
	00 00		 mov	 rdi, QWORD PTR [rax+456]
  016f6	33 c0		 xor	 eax, eax
  016f8	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  016fd	f3 aa		 rep stosb

; 445  :                 rc = 0;

  016ff	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$[rsp], 0
$LN138@main:
$LN134@main:

; 446  :             }
; 447  :         }
; 448  :         if (rc < 0)

  0170a	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  01712	0f 8d 73 01 00
	00		 jge	 $LN139@main

; 449  :         {
; 450  :             // "Read error on file %s: %s %d stat=%2.2X, null %s substituted"
; 451  :             FWRMSG( stderr, HHC02433, "E",

  01718	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01720	74 11		 je	 SHORT $LN162@main
  01722	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168943
  01729	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv851[rsp], rax
  01731	eb 0f		 jmp	 SHORT $LN163@main
$LN162@main:
  01733	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168944
  0173a	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv851[rsp], rax
$LN163@main:
  01742	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  0174a	74 11		 je	 SHORT $LN164@main
  0174c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168945
  01753	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv857[rsp], rax
  0175b	eb 0f		 jmp	 SHORT $LN165@main
$LN164@main:
  0175d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168946
  01764	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv857[rsp], rax
$LN165@main:
  0176c	0f b6 44 24 70	 movzx	 eax, BYTE PTR unitstat$[rsp]
  01771	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv853[rsp], eax
  01778	b9 02 00 00 00	 mov	 ecx, 2
  0177d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01783	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv851[rsp]
  0178b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01790	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv853[rsp]
  01797	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0179b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  017a2	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  017a6	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv857[rsp]
  017ae	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  017b3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  017bb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  017c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168947
  017c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  017cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168948
  017d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  017d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  017e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168949
  017ea	ba c5 01 00 00	 mov	 edx, 453		; 000001c5H
  017ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168950
  017f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 452  :                      ifile, ckddasd ? "track" : "block", i, unitstat,
; 453  :                      ckddasd ? "track" : "block" );
; 454  :             if (ckddasd)

  017fc	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01804	74 2e		 je	 SHORT $LN140@main

; 455  :                 nulltrk(idev->buf, i, idev->ckdheads, nullfmt);

  01806	44 8b 8c 24 c4
	00 00 00	 mov	 r9d, DWORD PTR nullfmt$[rsp]
  0180e	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01813	44 8b 80 c0 12
	00 00		 mov	 r8d, DWORD PTR [rax+4800]
  0181a	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01821	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01826	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  0182d	e8 00 00 00 00	 call	 nulltrk
  01832	eb 15		 jmp	 SHORT $LN141@main
$LN140@main:

; 456  :             else
; 457  :                 memset (idev->buf, 0, CFBA_BLKGRP_SIZE);

  01834	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01839	48 8b b8 c8 01
	00 00		 mov	 rdi, QWORD PTR [rax+456]
  01840	33 c0		 xor	 eax, eax
  01842	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  01847	f3 aa		 rep stosb
$LN141@main:

; 458  :             if (!quiet)

  01849	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  01851	75 38		 jne	 SHORT $LN142@main

; 459  :             {
; 460  :                 if (!extgui)

  01853	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0185a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0185d	75 19		 jne	 SHORT $LN143@main

; 461  :                     printf ( "  %3d%% %7d of %d", 0, 0, n );

  0185f	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR n$[rsp]
  01867	45 33 c0	 xor	 r8d, r8d
  0186a	33 d2		 xor	 edx, edx
  0186c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168955
  01873	e8 00 00 00 00	 call	 printf
$LN143@main:

; 462  :                 status (i, n);

  01878	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR n$[rsp]
  0187f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  01886	e8 00 00 00 00	 call	 status
$LN142@main:
$LN139@main:

; 463  :             }
; 464  :         }
; 465  : 
; 466  :         /* Write the track or block just read... */
; 467  : 
; 468  :         if (ckddasd)

  0188b	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01893	74 55		 je	 SHORT $LN144@main

; 469  :         {
; 470  :             rc = (odev->hnd->write)(odev, i, 0, idev->buf,

  01895	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR odev$[rsp]
  0189d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  018a4	48 8d 4c 24 70	 lea	 rcx, QWORD PTR unitstat$[rsp]
  018a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  018ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  018b3	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  018b9	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  018bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  018c2	4c 8b 89 c8 01
	00 00		 mov	 r9, QWORD PTR [rcx+456]
  018c9	45 33 c0	 xor	 r8d, r8d
  018cc	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  018d3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR odev$[rsp]
  018db	ff 50 58	 call	 QWORD PTR [rax+88]
  018de	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 471  :                       idev->ckdtrksz, &unitstat);
; 472  :         }

  018e5	e9 64 01 00 00	 jmp	 $LN145@main
$LN144@main:

; 473  :         else
; 474  :         {
; 475  :             if (fba_bytes_remaining >= (U64)idev->buflen)

  018ea	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  018ef	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  018f6	48 39 84 24 d8
	00 00 00	 cmp	 QWORD PTR fba_bytes_remaining$[rsp], rax
  018fe	72 77		 jb	 SHORT $LN146@main

; 476  :             {
; 477  :                 rc = (odev->hnd->write)(odev,  i, 0, idev->buf,

  01900	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR odev$[rsp]
  01908	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0190f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR unitstat$[rsp]
  01914	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01919	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  0191e	8b 89 dc 01 00
	00		 mov	 ecx, DWORD PTR [rcx+476]
  01924	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01928	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  0192d	4c 8b 89 c8 01
	00 00		 mov	 r9, QWORD PTR [rcx+456]
  01934	45 33 c0	 xor	 r8d, r8d
  01937	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  0193e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR odev$[rsp]
  01946	ff 50 58	 call	 QWORD PTR [rax+88]
  01949	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 478  :                           idev->buflen, &unitstat);
; 479  :                 fba_bytes_remaining -= (U64)idev->buflen;

  01950	48 8b 44 24 78	 mov	 rax, QWORD PTR idev$[rsp]
  01955	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  0195c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR fba_bytes_remaining$[rsp]
  01964	48 2b c8	 sub	 rcx, rax
  01967	48 8b c1	 mov	 rax, rcx
  0196a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR fba_bytes_remaining$[rsp], rax

; 480  :             }

  01972	e9 d7 00 00 00	 jmp	 $LN147@main
$LN146@main:
$LN15@main:

; 481  :             else
; 482  :             {
; 483  :                 ASSERT(fba_bytes_remaining > 0 && (i+1) >= n);

  01977	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR fba_bytes_remaining$[rsp], 0
  01980	76 12		 jbe	 SHORT $LN149@main
  01982	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01989	ff c0		 inc	 eax
  0198b	3b 84 24 88 00
	00 00		 cmp	 eax, DWORD PTR n$[rsp]
  01992	7d 5c		 jge	 SHORT $LN148@main
$LN149@main:
$LN18@main:
  01994	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168962
  0199b	41 b8 e3 01 00
	00		 mov	 r8d, 483		; 000001e3H
  019a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168963
  019a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168964
  019af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  019b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  019bb	85 c0		 test	 eax, eax
  019bd	74 20		 je	 SHORT $LN150@main
  019bf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168966
  019c6	41 b8 e3 01 00
	00		 mov	 r8d, 483		; 000001e3H
  019cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168967
  019d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168968
  019da	e8 00 00 00 00	 call	 DebuggerTrace
$LN150@main:
  019df	33 c0		 xor	 eax, eax
  019e1	85 c0		 test	 eax, eax
  019e3	75 af		 jne	 SHORT $LN18@main
  019e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  019eb	85 c0		 test	 eax, eax
  019ed	74 01		 je	 SHORT $LN151@main
  019ef	cc		 int	 3
$LN151@main:
$LN148@main:
  019f0	33 c0		 xor	 eax, eax
  019f2	85 c0		 test	 eax, eax
  019f4	75 81		 jne	 SHORT $LN15@main

; 484  :                 rc = (odev->hnd->write)(odev,  i, 0, idev->buf,

  019f6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR odev$[rsp]
  019fe	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01a05	48 8d 4c 24 70	 lea	 rcx, QWORD PTR unitstat$[rsp]
  01a0a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01a0f	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR fba_bytes_remaining$[rsp]
  01a16	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01a1a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idev$[rsp]
  01a1f	4c 8b 89 c8 01
	00 00		 mov	 r9, QWORD PTR [rcx+456]
  01a26	45 33 c0	 xor	 r8d, r8d
  01a29	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01a30	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR odev$[rsp]
  01a38	ff 50 58	 call	 QWORD PTR [rax+88]
  01a3b	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 485  :                           (int)fba_bytes_remaining, &unitstat);
; 486  :                 fba_bytes_remaining = 0;

  01a42	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fba_bytes_remaining$[rsp], 0
$LN147@main:
$LN145@main:

; 487  :             }
; 488  :         }
; 489  :         if (rc < 0)

  01a4e	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  01a56	0f 8d d3 00 00
	00		 jge	 $LN152@main

; 490  :         {
; 491  :             // "Write error on file %s: %s %d stat=%2.2X"
; 492  :             FWRMSG( stderr, HHC02434, "E",

  01a5c	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01a64	74 11		 je	 SHORT $LN166@main
  01a66	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168971
  01a6d	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv982[rsp], rax
  01a75	eb 0f		 jmp	 SHORT $LN167@main
$LN166@main:
  01a77	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168972
  01a7e	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv982[rsp], rax
$LN167@main:
  01a86	0f b6 44 24 70	 movzx	 eax, BYTE PTR unitstat$[rsp]
  01a8b	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv978[rsp], eax
  01a92	b9 02 00 00 00	 mov	 ecx, 2
  01a97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a9d	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv978[rsp]
  01aa4	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01aa8	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  01aaf	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01ab3	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv982[rsp]
  01abb	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01ac0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01ac8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01acd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168973
  01ad4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01ad9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168974
  01ae0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01ae5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01aea	41 b9 03 00 00
	00		 mov	 r9d, 3
  01af0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168975
  01af7	ba ed 01 00 00	 mov	 edx, 493		; 000001edH
  01afc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168976
  01b03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 493  :                      ofile, ckddasd ? "track" : "block", i, unitstat );
; 494  :             /* IMPORTANT PROGRAMMING NOTE: please note that the output
; 495  :                file's track is written directly from the INPUT's device
; 496  :                buffer. This means when we are done, we must close the
; 497  :                output file first, which flushes the output of the last
; 498  :                track that was written, which as explained, requires that
; 499  :                the INPUT file's device buffer to still be valid.
; 500  :             */
; 501  :             close_image_file( ocif );   /* Close output file FIRST! */

  01b09	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR ocif$[rsp]
  01b11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 502  :             close_image_file( icif );   /* Close input file SECOND! */

  01b17	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  01b1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 503  :             return -1;

  01b25	b8 ff ff ff ff	 mov	 eax, -1
  01b2a	e9 ff 00 00 00	 jmp	 $LN1@main
$LN152@main:

; 504  :         }
; 505  : 
; 506  :         /* Update the status indicator */
; 507  :         if (!quiet) status (i+1, n);

  01b2f	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  01b37	75 17		 jne	 SHORT $LN153@main
  01b39	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01b40	ff c0		 inc	 eax
  01b42	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR n$[rsp]
  01b49	8b c8		 mov	 ecx, eax
  01b4b	e8 00 00 00 00	 call	 status
$LN153@main:

; 508  :     }

  01b50	e9 90 fa ff ff	 jmp	 $LN10@main
$LN11@main:

; 509  : 
; 510  :     /* IMPORTANT PROGRAMMING NOTE: please note that the output
; 511  :        file's track is written directly from the INPUT's device
; 512  :        buffer. This means when we are done, we must close the
; 513  :        output file first, which flushes the output of the last
; 514  :        track that was written, which as explained, requires that
; 515  :        the INPUT file's device buffer to still be valid.
; 516  :     */
; 517  :     close_image_file( ocif );   /* Close output file FIRST! */

  01b55	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR ocif$[rsp]
  01b5d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 518  :     close_image_file( icif );   /* Close input file SECOND! */

  01b63	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  01b6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 519  : 
; 520  :     if (!extgui)

  01b71	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  01b78	83 38 00	 cmp	 DWORD PTR [rax], 0
  01b7b	75 16		 jne	 SHORT $LN154@main

; 521  :         if (!quiet)

  01b7d	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  01b85	75 0c		 jne	 SHORT $LN155@main

; 522  :             printf ( "\r" );

  01b87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168980
  01b8e	e8 00 00 00 00	 call	 printf
$LN155@main:
$LN154@main:

; 523  : 
; 524  :     if (sfile)

  01b93	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR sfile$[rsp], 0
  01b9c	74 47		 je	 SHORT $LN156@main

; 525  :         // "Shadow file data successfully merged into output"
; 526  :         WRMSG( HHC02595, "I" );

  01b9e	b9 01 00 00 00	 mov	 ecx, 1
  01ba3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01ba9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168982
  01bb0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01bb5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168983
  01bbc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01bc1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bc6	41 b9 03 00 00
	00		 mov	 r9d, 3
  01bcc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168984
  01bd3	ba 0e 02 00 00	 mov	 edx, 526		; 0000020eH
  01bd8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168985
  01bdf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN156@main:

; 527  : 
; 528  :     // "DASD operation completed"
; 529  :     WRMSG( HHC02423, "I" );

  01be5	b9 01 00 00 00	 mov	 ecx, 1
  01bea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01bf0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168986
  01bf7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01bfc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168987
  01c03	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c08	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c0d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01c13	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168988
  01c1a	ba 11 02 00 00	 mov	 edx, 529		; 00000211H
  01c1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168989
  01c26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 530  :     return 0;

  01c2c	33 c0		 xor	 eax, eax
$LN1@main:

; 531  : }

  01c2e	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01c36	48 33 cc	 xor	 rcx, rsp
  01c39	e8 00 00 00 00	 call	 __security_check_cookie
  01c3e	48 81 c4 90 02
	00 00		 add	 rsp, 656		; 00000290H
  01c45	5f		 pop	 rdi
  01c46	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcopy.c
_TEXT	SEGMENT
r$ = 32
cyl$ = 36
head$ = 40
i$ = 44
rechdr$ = 48
pos$ = 56
trkhdr$ = 64
buf$ = 96
trk$ = 104
heads$ = 112
nullfmt$ = 120
nulltrk	PROC

; 537  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 538  : int             i;                      /* Loop counter              */
; 539  : CKD_TRKHDR     *trkhdr;                 /* -> Track header           */
; 540  : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 541  : U32             cyl;                    /* Cylinder number           */
; 542  : U32             head;                   /* Head number               */
; 543  : BYTE            r;                      /* Record number             */
; 544  : BYTE           *pos;                    /* -> Next position in buffer*/
; 545  : 
; 546  :     /* cylinder and head calculations */
; 547  :     cyl = trk / heads;

  00017	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  0001b	99		 cdq
  0001c	f7 7c 24 70	 idiv	 DWORD PTR heads$[rsp]
  00020	89 44 24 24	 mov	 DWORD PTR cyl$[rsp], eax

; 548  :     head = trk % heads;

  00024	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  00028	99		 cdq
  00029	f7 7c 24 70	 idiv	 DWORD PTR heads$[rsp]
  0002d	8b c2		 mov	 eax, edx
  0002f	89 44 24 28	 mov	 DWORD PTR head$[rsp], eax

; 549  : 
; 550  :     /* Build the track header */
; 551  :     trkhdr = (CKD_TRKHDR*)buf;

  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR buf$[rsp]
  00038	48 89 44 24 40	 mov	 QWORD PTR trkhdr$[rsp], rax

; 552  :     trkhdr->bin = 0;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR trkhdr$[rsp]
  00042	c6 00 00	 mov	 BYTE PTR [rax], 0

; 553  :     store_hw(&trkhdr->cyl,  (U16) cyl);

  00045	0f b7 4c 24 24	 movzx	 ecx, WORD PTR cyl$[rsp]
  0004a	e8 00 00 00 00	 call	 _byteswap_ushort
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00054	48 ff c1	 inc	 rcx
  00057	0f b7 d0	 movzx	 edx, ax
  0005a	e8 00 00 00 00	 call	 store_hw_noswap

; 554  :     store_hw(&trkhdr->head, (U16) head);

  0005f	0f b7 4c 24 28	 movzx	 ecx, WORD PTR head$[rsp]
  00064	e8 00 00 00 00	 call	 _byteswap_ushort
  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  0006e	48 83 c1 03	 add	 rcx, 3
  00072	0f b7 d0	 movzx	 edx, ax
  00075	e8 00 00 00 00	 call	 store_hw_noswap

; 555  :     pos = buf + CKD_TRKHDR_SIZE;

  0007a	48 8b 44 24 60	 mov	 rax, QWORD PTR buf$[rsp]
  0007f	48 83 c0 05	 add	 rax, 5
  00083	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 556  : 
; 557  :     /* Build record zero */
; 558  :     r = 0;

  00088	c6 44 24 20 00	 mov	 BYTE PTR r$[rsp], 0

; 559  :     rechdr = (CKD_RECHDR*)pos;

  0008d	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00092	48 89 44 24 30	 mov	 QWORD PTR rechdr$[rsp], rax

; 560  :     pos += CKD_RECHDR_SIZE;

  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0009c	48 83 c0 08	 add	 rax, 8
  000a0	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 561  :     store_hw(&rechdr->cyl,  (U16) cyl);

  000a5	0f b7 4c 24 24	 movzx	 ecx, WORD PTR cyl$[rsp]
  000aa	e8 00 00 00 00	 call	 _byteswap_ushort
  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000b4	0f b7 d0	 movzx	 edx, ax
  000b7	e8 00 00 00 00	 call	 store_hw_noswap

; 562  :     store_hw(&rechdr->head, (U16) head);

  000bc	0f b7 4c 24 28	 movzx	 ecx, WORD PTR head$[rsp]
  000c1	e8 00 00 00 00	 call	 _byteswap_ushort
  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000cb	48 83 c1 02	 add	 rcx, 2
  000cf	0f b7 d0	 movzx	 edx, ax
  000d2	e8 00 00 00 00	 call	 store_hw_noswap

; 563  :     rechdr->rec = r;

  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  000dc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR r$[rsp]
  000e1	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 564  :     rechdr->klen = 0;

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  000e9	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 565  :     store_hw(&rechdr->dlen, CKD_R0_DLEN);

  000ed	66 b9 08 00	 mov	 cx, 8
  000f1	e8 00 00 00 00	 call	 _byteswap_ushort
  000f6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000fb	48 83 c1 06	 add	 rcx, 6
  000ff	0f b7 d0	 movzx	 edx, ax
  00102	e8 00 00 00 00	 call	 store_hw_noswap

; 566  :     pos +=                  CKD_R0_DLEN;

  00107	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0010c	48 83 c0 08	 add	 rax, 8
  00110	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 567  :     r++;

  00115	0f b6 44 24 20	 movzx	 eax, BYTE PTR r$[rsp]
  0011a	fe c0		 inc	 al
  0011c	88 44 24 20	 mov	 BYTE PTR r$[rsp], al

; 568  : 
; 569  :     /* Specific null track formatting */
; 570  :     if (nullfmt == CKD_NULLTRK_FMT0)

  00120	83 7c 24 78 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  00125	0f 85 88 00 00
	00		 jne	 $LN5@nulltrk

; 571  :     {
; 572  :         rechdr = (CKD_RECHDR*)pos;

  0012b	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00130	48 89 44 24 30	 mov	 QWORD PTR rechdr$[rsp], rax

; 573  :         pos += CKD_RECHDR_SIZE;

  00135	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0013a	48 83 c0 08	 add	 rax, 8
  0013e	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 574  : 
; 575  :         store_hw(&rechdr->cyl,  (U16) cyl);

  00143	0f b7 4c 24 24	 movzx	 ecx, WORD PTR cyl$[rsp]
  00148	e8 00 00 00 00	 call	 _byteswap_ushort
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00152	0f b7 d0	 movzx	 edx, ax
  00155	e8 00 00 00 00	 call	 store_hw_noswap

; 576  :         store_hw(&rechdr->head, (U16) head);

  0015a	0f b7 4c 24 28	 movzx	 ecx, WORD PTR head$[rsp]
  0015f	e8 00 00 00 00	 call	 _byteswap_ushort
  00164	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00169	48 83 c1 02	 add	 rcx, 2
  0016d	0f b7 d0	 movzx	 edx, ax
  00170	e8 00 00 00 00	 call	 store_hw_noswap

; 577  :         rechdr->rec = r;

  00175	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  0017a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR r$[rsp]
  0017f	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 578  :         rechdr->klen = 0;

  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  00187	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 579  :         store_hw(&rechdr->dlen, 0);

  0018b	33 c9		 xor	 ecx, ecx
  0018d	e8 00 00 00 00	 call	 _byteswap_ushort
  00192	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00197	48 83 c1 06	 add	 rcx, 6
  0019b	0f b7 d0	 movzx	 edx, ax
  0019e	e8 00 00 00 00	 call	 store_hw_noswap

; 580  :         r++;

  001a3	0f b6 44 24 20	 movzx	 eax, BYTE PTR r$[rsp]
  001a8	fe c0		 inc	 al
  001aa	88 44 24 20	 mov	 BYTE PTR r$[rsp], al

; 581  :     }

  001ae	e9 c4 00 00 00	 jmp	 $LN6@nulltrk
$LN5@nulltrk:

; 582  :     else if (nullfmt == CKD_NULLTRK_FMT2)

  001b3	83 7c 24 78 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  001b8	0f 85 b9 00 00
	00		 jne	 $LN7@nulltrk

; 583  :     {
; 584  :         for (i = 0; i < 12; i++)

  001be	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001c6	eb 0a		 jmp	 SHORT $LN4@nulltrk
$LN2@nulltrk:
  001c8	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  001cc	ff c0		 inc	 eax
  001ce	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN4@nulltrk:
  001d2	83 7c 24 2c 0c	 cmp	 DWORD PTR i$[rsp], 12
  001d7	0f 8d 9a 00 00
	00		 jge	 $LN3@nulltrk

; 585  :         {
; 586  :             rechdr = (CKD_RECHDR*)pos;

  001dd	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  001e2	48 89 44 24 30	 mov	 QWORD PTR rechdr$[rsp], rax

; 587  :             pos += CKD_RECHDR_SIZE;

  001e7	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  001ec	48 83 c0 08	 add	 rax, 8
  001f0	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 588  : 
; 589  :             store_hw(&rechdr->cyl,  (U16) cyl);

  001f5	0f b7 4c 24 24	 movzx	 ecx, WORD PTR cyl$[rsp]
  001fa	e8 00 00 00 00	 call	 _byteswap_ushort
  001ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00204	0f b7 d0	 movzx	 edx, ax
  00207	e8 00 00 00 00	 call	 store_hw_noswap

; 590  :             store_hw(&rechdr->head, (U16) head);

  0020c	0f b7 4c 24 28	 movzx	 ecx, WORD PTR head$[rsp]
  00211	e8 00 00 00 00	 call	 _byteswap_ushort
  00216	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0021b	48 83 c1 02	 add	 rcx, 2
  0021f	0f b7 d0	 movzx	 edx, ax
  00222	e8 00 00 00 00	 call	 store_hw_noswap

; 591  :             rechdr->rec = r;

  00227	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  0022c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR r$[rsp]
  00231	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 592  :             rechdr->klen = 0;

  00234	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  00239	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 593  :             store_hw(&rechdr->dlen, CKD_NULL_FMT2_DLEN );

  0023d	66 b9 00 10	 mov	 cx, 4096		; 00001000H
  00241	e8 00 00 00 00	 call	 _byteswap_ushort
  00246	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0024b	48 83 c1 06	 add	 rcx, 6
  0024f	0f b7 d0	 movzx	 edx, ax
  00252	e8 00 00 00 00	 call	 store_hw_noswap

; 594  :             r++;

  00257	0f b6 44 24 20	 movzx	 eax, BYTE PTR r$[rsp]
  0025c	fe c0		 inc	 al
  0025e	88 44 24 20	 mov	 BYTE PTR r$[rsp], al

; 595  :             pos +=                  CKD_NULL_FMT2_DLEN;

  00262	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00267	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0026d	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 596  :         }

  00272	e9 51 ff ff ff	 jmp	 $LN2@nulltrk
$LN3@nulltrk:
$LN7@nulltrk:
$LN6@nulltrk:

; 597  :     }
; 598  : 
; 599  :     /* Build the end of track marker */
; 600  :     memcpy (pos, &CKD_ENDTRK, CKD_ENDTRK_SIZE);

  00277	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0027c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  00283	48 89 08	 mov	 QWORD PTR [rax], rcx

; 601  :     pos +=                    CKD_ENDTRK_SIZE;

  00286	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0028b	48 83 c0 08	 add	 rax, 8
  0028f	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 602  : 
; 603  :     return 0;

  00294	33 c0		 xor	 eax, eax

; 604  : }

  00296	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0029a	c3		 ret	 0
nulltrk	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcopy.c
_TEXT	SEGMENT
tv83 = 32
i$ = 64
n$ = 72
status	PROC

; 711  : {

$LN13:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 712  :     if (extgui)

  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	74 53		 je	 SHORT $LN8@status
$LN4@status:

; 713  :     {
; 714  :         UNREFERENCED( n );

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@status

; 715  :         if (i % 100)

  0001e	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00022	99		 cdq
  00023	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00028	f7 f9		 idiv	 ecx
  0002a	8b c2		 mov	 eax, edx
  0002c	85 c0		 test	 eax, eax
  0002e	74 05		 je	 SHORT $LN10@status

; 716  :             return;

  00030	e9 8c 00 00 00	 jmp	 $LN1@status
$LN10@status:
$LN7@status:

; 717  :         EXTGUIMSG( "TRK=%d\n", i );

  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0003c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0003f	74 20		 je	 SHORT $LN11@status
  00041	b9 02 00 00 00	 mov	 ecx, 2
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004c	44 8b 44 24 40	 mov	 r8d, DWORD PTR i$[rsp]
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169158
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN11@status:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 ce		 jne	 SHORT $LN7@status

; 718  :         return;

  00067	eb 58		 jmp	 SHORT $LN1@status

; 719  :     }

  00069	eb 56		 jmp	 SHORT $LN9@status
$LN8@status:

; 720  :     else
; 721  :     {
; 722  :         static char indic[] = "|/-\\";
; 723  : //      if (i % 101 != 1)
; 724  : //          return;
; 725  :         printf ("\r%c %3d%% %7d", indic[i%4], (int)((i*100.0)/n), i);

  0006b	f2 0f 2a 44 24
	40		 cvtsi2sd xmm0, DWORD PTR i$[rsp]
  00071	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  00079	f2 0f 2a 4c 24
	48		 cvtsi2sd xmm1, DWORD PTR n$[rsp]
  0007f	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00083	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00087	89 44 24 20	 mov	 DWORD PTR tv83[rsp], eax
  0008b	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0008f	99		 cdq
  00090	83 e2 03	 and	 edx, 3
  00093	03 c2		 add	 eax, edx
  00095	83 e0 03	 and	 eax, 3
  00098	2b c2		 sub	 eax, edx
  0009a	48 98		 cdqe
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?indic@?5??status@@9@9
  000a3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000a7	44 8b 4c 24 40	 mov	 r9d, DWORD PTR i$[rsp]
  000ac	8b 4c 24 20	 mov	 ecx, DWORD PTR tv83[rsp]
  000b0	44 8b c1	 mov	 r8d, ecx
  000b3	8b d0		 mov	 edx, eax
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169159
  000bc	e8 00 00 00 00	 call	 printf
$LN9@status:
$LN1@status:

; 726  :     }
; 727  : }

  000c1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c5	c3		 ret	 0
status	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcopy.c
_TEXT	SEGMENT
buffsize$1 = 96
zlib$ = 100
bzip2$ = 104
lfs$ = 108
rc$2 = 112
msgbuf$3 = 120
chunksize$4 = 128
$T5 = 136
$T6 = 144
$T7 = 152
vargs$8 = 160
lfsbuf$ = 176
bzbuf$ = 256
zbuf$ = 336
__$ArrayPad$ = 416
pgm$ = 448
msgfmt$ = 456
syntax	PROC

; 610  : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 611  :     int zlib  = 0;

  0002d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR zlib$[rsp], 0

; 612  :     int bzip2 = 0;

  00035	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR bzip2$[rsp], 0

; 613  :     int lfs   = 0;

  0003d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR lfs$[rsp], 0

; 614  : 
; 615  :     char zbuf  [80];
; 616  :     char bzbuf [80];
; 617  :     char lfsbuf[80];
; 618  : 
; 619  :     zbuf  [0] = 0;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	48 6b c0 00	 imul	 rax, rax, 0
  0004e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  00056	48 83 bc 24 88
	00 00 00 50	 cmp	 QWORD PTR $T5[rsp], 80	; 00000050H
  0005f	73 02		 jae	 SHORT $LN27@syntax
  00061	eb 05		 jmp	 SHORT $LN28@syntax
$LN27@syntax:
  00063	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN28@syntax:
  00068	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  00070	c6 84 04 50 01
	00 00 00	 mov	 BYTE PTR zbuf$[rsp+rax], 0

; 620  :     bzbuf [0] = 0;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	48 6b c0 00	 imul	 rax, rax, 0
  00081	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T6[rsp], rax
  00089	48 83 bc 24 90
	00 00 00 50	 cmp	 QWORD PTR $T6[rsp], 80	; 00000050H
  00092	73 02		 jae	 SHORT $LN29@syntax
  00094	eb 05		 jmp	 SHORT $LN30@syntax
$LN29@syntax:
  00096	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN30@syntax:
  0009b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  000a3	c6 84 04 00 01
	00 00 00	 mov	 BYTE PTR bzbuf$[rsp+rax], 0

; 621  :     lfsbuf[0] = 0;

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	48 6b c0 00	 imul	 rax, rax, 0
  000b4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T7[rsp], rax
  000bc	48 83 bc 24 98
	00 00 00 50	 cmp	 QWORD PTR $T7[rsp], 80	; 00000050H
  000c5	73 02		 jae	 SHORT $LN31@syntax
  000c7	eb 05		 jmp	 SHORT $LN32@syntax
$LN31@syntax:
  000c9	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN32@syntax:
  000ce	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  000d6	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR lfsbuf$[rsp+rax], 0

; 622  : 
; 623  :     /* Show them their syntax error... */
; 624  :     if (msgfmt)

  000de	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR msgfmt$[rsp], 0
  000e7	0f 84 1e 01 00
	00		 je	 $LN5@syntax

; 625  :     {
; 626  :         const int  chunksize  = 128;

  000ed	c7 84 24 80 00
	00 00 80 00 00
	00		 mov	 DWORD PTR chunksize$4[rsp], 128 ; 00000080H

; 627  :         int        rc         = -1;

  000f8	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR rc$2[rsp], -1

; 628  :         int        buffsize   =  0;

  00100	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR buffsize$1[rsp], 0

; 629  :         char*      msgbuf     = NULL;

  00108	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR msgbuf$3[rsp], 0
$LN33@syntax:
$LN4@syntax:

; 630  :         va_list    vargs;
; 631  : 
; 632  :         do
; 633  :         {
; 634  :             if (msgbuf) free( msgbuf );

  00111	48 83 7c 24 78
	00		 cmp	 QWORD PTR msgbuf$3[rsp], 0
  00117	74 0b		 je	 SHORT $LN6@syntax
  00119	48 8b 4c 24 78	 mov	 rcx, QWORD PTR msgbuf$3[rsp]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@syntax:

; 635  :             if (!(msgbuf = malloc( buffsize += chunksize )))

  00124	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR chunksize$4[rsp]
  0012b	8b 4c 24 60	 mov	 ecx, DWORD PTR buffsize$1[rsp]
  0012f	03 c8		 add	 ecx, eax
  00131	8b c1		 mov	 eax, ecx
  00133	89 44 24 60	 mov	 DWORD PTR buffsize$1[rsp], eax
  00137	48 63 44 24 60	 movsxd	 rax, DWORD PTR buffsize$1[rsp]
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00145	48 89 44 24 78	 mov	 QWORD PTR msgbuf$3[rsp], rax
  0014a	48 83 7c 24 78
	00		 cmp	 QWORD PTR msgbuf$3[rsp], 0
  00150	75 01		 jne	 SHORT $LN7@syntax

; 636  :                 BREAK_INTO_DEBUGGER();

  00152	cc		 int	 3
$LN7@syntax:

; 637  : 
; 638  :             va_end(   vargs );

  00153	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR vargs$8[rsp], 0

; 639  :             va_start( vargs, msgfmt );

  0015f	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR msgfmt$[rsp+8]
  00167	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR vargs$8[rsp], rax

; 640  : 
; 641  :             rc = vsnprintf( msgbuf, buffsize, msgfmt, vargs );

  0016f	48 63 44 24 60	 movsxd	 rax, DWORD PTR buffsize$1[rsp]
  00174	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR vargs$8[rsp]
  0017c	4c 8b 84 24 c8
	01 00 00	 mov	 r8, QWORD PTR msgfmt$[rsp]
  00184	48 8b d0	 mov	 rdx, rax
  00187	48 8b 4c 24 78	 mov	 rcx, QWORD PTR msgbuf$3[rsp]
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf
  00192	89 44 24 70	 mov	 DWORD PTR rc$2[rsp], eax

; 642  :         }
; 643  :         while (rc < 0 || rc >= buffsize);

  00196	83 7c 24 70 00	 cmp	 DWORD PTR rc$2[rsp], 0
  0019b	0f 8c 70 ff ff
	ff		 jl	 $LN4@syntax
  001a1	8b 44 24 60	 mov	 eax, DWORD PTR buffsize$1[rsp]
  001a5	39 44 24 70	 cmp	 DWORD PTR rc$2[rsp], eax
  001a9	0f 8d 62 ff ff
	ff		 jge	 $LN33@syntax

; 644  : 
; 645  :         // "Syntax error: %s"
; 646  :         FWRMSG( stderr, HHC02594, "E", msgbuf );

  001af	b9 02 00 00 00	 mov	 ecx, 2
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR msgbuf$3[rsp]
  001bf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169066
  001cb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169067
  001d7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169068
  001ee	ba 86 02 00 00	 mov	 edx, 646		; 00000286H
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169069
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 647  :         free( msgbuf );

  00200	48 8b 4c 24 78	 mov	 rcx, QWORD PTR msgbuf$3[rsp]
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@syntax:

; 648  :     }
; 649  : 
; 650  : #ifdef CCKD_COMPRESS_ZLIB
; 651  :     zlib = 1;

  0020b	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR zlib$[rsp], 1

; 652  : #endif
; 653  : 
; 654  : #ifdef CCKD_COMPRESS_BZIP2
; 655  :     bzip2 = 1;

  00213	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR bzip2$[rsp], 1

; 656  : #endif
; 657  : 
; 658  :     if (sizeof(off_t) > 4)

  0021b	33 c0		 xor	 eax, eax
  0021d	83 f8 01	 cmp	 eax, 1
  00220	74 08		 je	 SHORT $LN8@syntax

; 659  :         lfs = 1;

  00222	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR lfs$[rsp], 1
$LN8@syntax:

; 660  : 
; 661  : #define HHC02435I  "HHC02435I "     // ckd2cckd
; 662  : #define HHC02436I  "HHC02436I "     // cckd2ckd
; 663  : #define HHC02437I  "HHC02437I "     // fba2cfba
; 664  : #define HHC02438I  "HHC02438I "     // cfba2fba
; 665  : #define HHC02439I  "HHC02439I "     // dasdcopy
; 666  : 
; 667  : #define Z_HELP     "  -z       compress using zlib [default]"
; 668  : #define BZ_HELP    "  -bz2     compress using bzip2"
; 669  : #define LFS_HELP   "  -lfs     create single large output file"
; 670  : 
; 671  :     /* Display help information... */
; 672  :     if (strcasecmp( pgm,                   "ckd2cckd"    ) == 0)

  0022a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169073
  00231	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0023f	85 c0		 test	 eax, eax
  00241	0f 85 ce 00 00
	00		 jne	 $LN9@syntax

; 673  :     {
; 674  :         if (zlib)  MSGBUF(  zbuf, "%s%s\n", HHC02435I,  Z_HELP );

  00247	83 7c 24 64 00	 cmp	 DWORD PTR zlib$[rsp], 0
  0024c	74 2d		 je	 SHORT $LN11@syntax
  0024e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169075
  00255	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169076
  00261	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169077
  00268	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0026d	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN11@syntax:

; 675  :         if (bzip2) MSGBUF( bzbuf, "%s%s\n", HHC02435I, BZ_HELP );

  0027b	83 7c 24 68 00	 cmp	 DWORD PTR bzip2$[rsp], 0
  00280	74 2d		 je	 SHORT $LN12@syntax
  00282	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169079
  00289	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169080
  00295	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169081
  0029c	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  002a1	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN12@syntax:

; 676  :         WRMSG(                              HHC02435, "I", zbuf, bzbuf );

  002af	b9 01 00 00 00	 mov	 ecx, 1
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ba	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  002c2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002c7	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  002cf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169082
  002db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169083
  002e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169084
  002fe	ba a4 02 00 00	 mov	 edx, 676		; 000002a4H
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169085
  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 677  :     }

  00310	e9 62 03 00 00	 jmp	 $LN10@syntax
$LN9@syntax:

; 678  :     else if (strcasecmp( pgm,             "cckd2ckd"     ) == 0)

  00315	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169088
  0031c	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00324	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0032a	85 c0		 test	 eax, eax
  0032c	0f 85 8d 00 00
	00		 jne	 $LN13@syntax

; 679  :     {
; 680  :         if (lfs) MSGBUF( lfsbuf, "%s%s\n", HHC02436I, LFS_HELP );

  00332	83 7c 24 6c 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00337	74 2d		 je	 SHORT $LN15@syntax
  00339	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169090
  00340	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00345	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169091
  0034c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169092
  00353	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00358	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN15@syntax:

; 681  :         WRMSG(                             HHC02436, "I", lfsbuf );

  00366	b9 01 00 00 00	 mov	 ecx, 1
  0036b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00371	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  00379	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169093
  00385	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0038a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169094
  00391	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00396	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0039b	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169095
  003a8	ba a9 02 00 00	 mov	 edx, 681		; 000002a9H
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169096
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 682  :     }

  003ba	e9 b8 02 00 00	 jmp	 $LN14@syntax
$LN13@syntax:

; 683  :     else if (strcasecmp( pgm,              "fba2cfba"    ) == 0)

  003bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169099
  003c6	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  003ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003d4	85 c0		 test	 eax, eax
  003d6	0f 85 ce 00 00
	00		 jne	 $LN16@syntax

; 684  :     {
; 685  :         if (zlib)  MSGBUF(  zbuf, "%s%s\n", HHC02437I,  Z_HELP );

  003dc	83 7c 24 64 00	 cmp	 DWORD PTR zlib$[rsp], 0
  003e1	74 2d		 je	 SHORT $LN18@syntax
  003e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169101
  003ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ef	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169102
  003f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169103
  003fd	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00402	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  0040a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN18@syntax:

; 686  :         if (bzip2) MSGBUF( bzbuf, "%s%s\n", HHC02437I, BZ_HELP );

  00410	83 7c 24 68 00	 cmp	 DWORD PTR bzip2$[rsp], 0
  00415	74 2d		 je	 SHORT $LN19@syntax
  00417	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169105
  0041e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00423	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169106
  0042a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169107
  00431	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00436	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  0043e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN19@syntax:

; 687  :         WRMSG(                              HHC02437, "I", zbuf, bzbuf );

  00444	b9 01 00 00 00	 mov	 ecx, 1
  00449	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0044f	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  00457	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0045c	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  00464	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169108
  00470	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00475	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169109
  0047c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00481	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00486	41 b9 03 00 00
	00		 mov	 r9d, 3
  0048c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169110
  00493	ba af 02 00 00	 mov	 edx, 687		; 000002afH
  00498	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169111
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 688  :     }

  004a5	e9 cd 01 00 00	 jmp	 $LN17@syntax
$LN16@syntax:

; 689  :     else if (strcasecmp( pgm,             "cfba2fba"     ) == 0)

  004aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169114
  004b1	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  004b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  004bf	85 c0		 test	 eax, eax
  004c1	0f 85 8d 00 00
	00		 jne	 $LN20@syntax

; 690  :     {
; 691  :         if (lfs) MSGBUF( lfsbuf, "%s%s\n", HHC02438I, LFS_HELP );

  004c7	83 7c 24 6c 00	 cmp	 DWORD PTR lfs$[rsp], 0
  004cc	74 2d		 je	 SHORT $LN22@syntax
  004ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169116
  004d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004da	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169117
  004e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169118
  004e8	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  004ed	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN22@syntax:

; 692  :         WRMSG(                             HHC02438, "I", lfsbuf );

  004fb	b9 01 00 00 00	 mov	 ecx, 1
  00500	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00506	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  0050e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00513	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169119
  0051a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0051f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169120
  00526	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0052b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00530	41 b9 03 00 00
	00		 mov	 r9d, 3
  00536	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169121
  0053d	ba b4 02 00 00	 mov	 edx, 692		; 000002b4H
  00542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169122
  00549	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 693  :     }

  0054f	e9 23 01 00 00	 jmp	 $LN21@syntax
$LN20@syntax:

; 694  :     else
; 695  :     {
; 696  :         if (zlib)  MSGBUF(   zbuf, "%s%s\n", HHC02439I,   Z_HELP );

  00554	83 7c 24 64 00	 cmp	 DWORD PTR zlib$[rsp], 0
  00559	74 2d		 je	 SHORT $LN23@syntax
  0055b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169124
  00562	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00567	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169125
  0056e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169126
  00575	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0057a	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN23@syntax:

; 697  :         if (bzip2) MSGBUF(  bzbuf, "%s%s\n", HHC02439I,  BZ_HELP );

  00588	83 7c 24 68 00	 cmp	 DWORD PTR bzip2$[rsp], 0
  0058d	74 2d		 je	 SHORT $LN24@syntax
  0058f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169128
  00596	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0059b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169129
  005a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169130
  005a9	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  005ae	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  005b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN24@syntax:

; 698  :         if (lfs)   MSGBUF( lfsbuf, "%s%s\n", HHC02439I, LFS_HELP );

  005bc	83 7c 24 6c 00	 cmp	 DWORD PTR lfs$[rsp], 0
  005c1	74 2d		 je	 SHORT $LN25@syntax
  005c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169132
  005ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005cf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169133
  005d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169134
  005dd	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  005e2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  005ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN25@syntax:

; 699  :         WRMSG(                               HHC02439, "I", pgm, zbuf, bzbuf, lfsbuf,

  005f0	b9 01 00 00 00	 mov	 ecx, 1
  005f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169135
  00602	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00607	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  0060f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00614	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  0061c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00621	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  00629	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0062e	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00636	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0063b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169136
  00642	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00647	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169137
  0064e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00653	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00658	41 b9 03 00 00
	00		 mov	 r9d, 3
  0065e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169138
  00665	ba bc 02 00 00	 mov	 edx, 700		; 000002bcH
  0066a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169139
  00671	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@syntax:
$LN17@syntax:
$LN14@syntax:
$LN10@syntax:

; 700  :             "CKD, CCKD, FBA, CFBA" );
; 701  :     }
; 702  : 
; 703  :     return -1;

  00677	b8 ff ff ff ff	 mov	 eax, -1
$LN26@syntax:

; 704  : 
; 705  : }

  0067c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00684	48 33 cc	 xor	 rcx, rsp
  00687	e8 00 00 00 00	 call	 __security_check_cookie
  0068c	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  00693	c3		 ret	 0
syntax	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
